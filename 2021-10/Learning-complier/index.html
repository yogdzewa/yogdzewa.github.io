

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yogdzewa">
  <meta name="keywords" content="">
  
    <meta name="description" content="冲,哈工大视频看看就得了,关键还得靠英文视频和实验,">
<meta property="og:type" content="article">
<meta property="og:title" content="编译原理complier">
<meta property="og:url" content="https://yogdzewa.github.io/2021-10/Learning-complier/index.html">
<meta property="og:site_name" content="Yogdzewa">
<meta property="og:description" content="冲,哈工大视频看看就得了,关键还得靠英文视频和实验,">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/11/15/AlBoJu85kTGY1FX.png">
<meta property="article:published_time" content="2021-10-03T02:00:00.000Z">
<meta property="article:modified_time" content="2022-12-04T12:13:36.976Z">
<meta property="article:author" content="Yogdzewa">
<meta property="article:tag" content="complier">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://i.loli.net/2021/11/15/AlBoJu85kTGY1FX.png">
  
  
  <title>编译原理complier - Yogdzewa</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/obsidian.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yogdzewa.github.io","root":"/","version":"1.8.13","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>(￣.￣)</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/image/edit2.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="编译原理complier">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-10-03 10:00" pubdate>
        2021年10月3日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      22k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      271 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">编译原理complier</h1>
            
              <p class="note note-info">
                
                  不可视境界线最后变动于：2022年12月4日 晚上
                
              </p>
            
            <div class="markdown-body">
              <h1 id="COMPLIER-CS143"><a href="#COMPLIER-CS143" class="headerlink" title="COMPLIER-CS143"></a>COMPLIER-CS143</h1><p>这篇文章所用到的代码结构其实复杂了一些, 看到个其他的解法</p>
<h2 id="0-预备知识"><a href="#0-预备知识" class="headerlink" title="0. 预备知识"></a>0. 预备知识</h2><h3 id="COOL语言"><a href="#COOL语言" class="headerlink" title="COOL语言"></a>COOL语言</h3><ul>
<li>只能说是比较复杂, manuals和源码分析详见相关文档</li>
<li>比较典型的是继承树结构</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">          &#123; -&gt; [String]<br>          &#123; -&gt; [Int]<br>[OBJECT] =&#123; -&gt; [IO]     -&gt; [B]<br>          &#123; -&gt; [Bool]<br>          &#123; -&gt; [A]<br></code></pre></div></td></tr></table></figure>

<h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><ul>
<li>词法分析-&gt;语法分析-&gt;语义分析</li>
<li><img src="https://i.loli.net/2021/11/15/AlBoJu85kTGY1FX.png" srcset="/img/loading.gif" lazyload alt="image-20211013100444035" style="zoom:67%;" /> </li>
<li><strong>词法分析</strong> <ul>
<li>从左向右逐行扫描源程序的字符，识别出各个单词，确定单词的类型。将识别出的单词转换成统一的机内表示——词法单元(<strong>token</strong>)形式</li>
</ul>
</li>
<li><strong>语法分析</strong> <ul>
<li>语法分析器(parser)从词法分析器输出的token序列中识别出各类短语，并构造语法分析树(<strong>parse tree</strong>)</li>
</ul>
</li>
<li><strong>语义分析</strong> <ul>
<li>收集标识符的属性信息&amp;&amp;语义检查</li>
</ul>
</li>
<li><strong>中间代码</strong> <ul>
<li>三地址码 (Three-address Code)<div class="hljs code-wrapper"><pre><code>三地址码由类似于汇编语言的指令序列组成，每个指令最多有三个操作数(operand)
</code></pre></div>
</li>
<li>语法结构树/语法树 (Syntax Trees)</li>
</ul>
</li>
</ul>
<h3 id="CS143实验文件结构"><a href="#CS143实验文件结构" class="headerlink" title="CS143实验文件结构"></a>CS143实验文件结构</h3><h4 id="list-h"><a href="#list-h" class="headerlink" title="list.h:"></a>list.h:</h4><ul>
<li>注意到head是这个节点存储的数据, 而tail指向下一个节点, 构造节点时在这一串链表的头部添加新的节点. </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>  T *head;<br>  List&lt;T&gt;* tail;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">List</span>(T *h,List&lt;T&gt;* t = <span class="hljs-literal">NULL</span>): <span class="hljs-built_in">head</span>(h), <span class="hljs-built_in">tail</span>(t) &#123; &#125;<br><br>  <span class="hljs-function">T *<span class="hljs-title">hd</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>       </span>&#123; <span class="hljs-keyword">return</span> head; &#125;  <br>  <span class="hljs-function">List&lt;T&gt;* <span class="hljs-title">tl</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> tail; &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h4 id="tree-h-cool-tree-h"><a href="#tree-h-cool-tree-h" class="headerlink" title="tree.h+cool-tree.h:"></a>tree.h+cool-tree.h:</h4><ul>
<li>All APS nodes are derived from tree_node.</li>
<li>Lists of APS objects are implemented by the “list_node” template.</li>
<li>Class_, Feature, Expression等等都是指向constructor(第二层)的指针. 前者是因为Class是c++关键字, 所以加上一个下划线.</li>
<li>属实很抽象, 我觉得三层结构的原因是为了把第二层作成一个通用class, 因为全是**<u>纯虚</u>**函数. 就像Feature那样. 确实是这样, 在把class method加入env的method_table中时只要给出Features指针(<code>typedef Feature_class* Feature</code>)然后调用feature_add函数即可分配到method或者attr的add函数, 整了一个多态. </li>
</ul>
<pre><code class=" mermaid">classDiagram
class tree_node&#123;
    int line_number
   
    tree_node()
    virtual tree_node *copy() = 0
    virtual void dump(ostream&amp; stream, int n) = 0
    int get_line_number()
    tree_node *set(tree_node *)
&#125;
class list_node&#123;
	实现了三个
	返回下标的迭代器
&#125;
class node相关&#123;
	append_node
	nil_node
	single_list_node
&#125;
tree_node --|&gt; list_node
list_node --|&gt; node相关


class Class__class&#123;
    virtual__get_name()
    virtual__get_parent()
    virtual__get_features()
    virtual__get_filename()
    virtual__dump_with_types(ostream&amp;,int)
&#125;
Class__class : define simple_phylum_Class_

class class__class&#123;
   Symbol name;
   Symbol parent;
   Features features;
   Symbol filename;
&#125;
Class__class --|&gt; class__class
tree_node --|&gt; Class__class
tree_node --|&gt; Feature_class
class Feature_class&#123;
	全为纯虚函数:
	dump_with_types(ostream&amp;,int) = 0
	Symbol get_name()
	tc(EnvironmentP)
	add_to_table(EnvironmentP)
&#125;
class method_class&#123;
    Symbol name;
    Formals formals;
    Symbol return_type;
    Expression expr;
    get_return_type()
    get_formals()
    ...
&#125;
class attr_class&#123;
   Symbol name;
   Symbol type_decl;
   Expression init;
&#125;
Feature_class --|&gt; method_class
Feature_class --|&gt; attr_class
tree_node --|&gt; Formal_class
tree_node --|&gt; Case_class
tree_node --|&gt; Expression_class

</code></pre>

<h4 id="stringtable"><a href="#stringtable" class="headerlink" title="stringtable:"></a>stringtable:</h4><ul>
<li>Symbol是指向<strong>Entry</strong>的指针 <code>typedef Entry* Symbol;</code> </li>
</ul>
<pre><code class=" mermaid">classDiagram
direction RL
class Entry&#123;
  char *str;    
  int  len;   
  int index;
&#125;
Entry --|&gt; StringEntry
Entry --|&gt; IntEntry
Entry --|&gt; IdEntry
class StringTable~Elem~&#123;
   List~Elem~ *tbl;
   int index;
&#125;
StringTable .. Entry
</code></pre>

<h2 id="1-lexer-词法分析"><a href="#1-lexer-词法分析" class="headerlink" title="1. lexer - 词法分析"></a>1. lexer - 词法分析</h2><ul>
<li>这一实验看上去就是逐字分析然后根据flex的语法返回token就完事了, 但要知道的是flex的内部原理仍然是有穷自动机finite automate, 具体概念可以看看课程PDF, flex的代码分析可见 <a target="_blank" rel="noopener" href="https://github.com/pcy190/CompilerAnalysis/blob/master/flex_analysis.md">这里</a>, 肖哥的分析在 <a target="_blank" rel="noopener" href="https://github.com/Kiprey/Skr_Learning/tree/master/week3-6#1-lexer---%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90">这里</a> </li>
<li>字符串用到了stringtable. 具体见cool文档: We provide you with a string table implementation, which is discussed in detail in A Tour of the Cool<br>Support Code and in documentation in the code. For the moment, you only need to know that the type of string table entries is Symbol.</li>
</ul>
<p>flex <a target="_blank" rel="noopener" href="https://ftp.gnu.org/old-gnu/Manuals/flex-2.5.4/html_mono/flex.html">document</a> </p>
<ul>
<li><code>yylex()</code>是<a target="_blank" rel="noopener" href="https://ftp.gnu.org/old-gnu/Manuals/flex-2.5.4/html_mono/flex.html#SEC10">扫描例程</a>. </li>
<li>Actions中<code>yyless()</code> and <code>yymore()</code>可以把yytext的字符放到或者取出自input stream中. </li>
<li><code>#define yylval cool_yylval</code>: 返回semantic value.</li>
<li><a target="_blank" rel="noopener" href="https://ftp.gnu.org/old-gnu/Manuals/flex-2.5.4/html_mono/flex.html#SEC10:~:text=Start%20conditions%20are%20declared%20in%20the%20definitions%20(first)%20section">Start conditions</a>: 这个就是匹配成对注释符的条件. <code>&lt;QUOTE_COMMENT&gt;&quot;*)&quot;         &#123; ... &#125;</code> <ul>
<li><code>%x QUOTE_COMMENT</code>: <em>exclusive</em>声明.  If it is <em>exclusive</em>, then <em>only</em> rules qualified with the start condition will be active. </li>
<li><code>BEGIN(INITIAL);</code>: `BEGIN(0/INITIAL)’ returns to the original state where only the rules with no start conditions are active. </li>
</ul>
</li>
</ul>
<p>文件:</p>
<ul>
<li>lexertest.cc是main函数所在文件, 我们写完cool.flex后flex使用此文件和众多依赖文件编译成lexer(executable)<ul>
<li>开头一个handle_flags函数处理命令行参数. 具体见文件. </li>
<li>调用cool_yylex来每次得到一个token, 然后dump打印出来. </li>
</ul>
</li>
<li>cool-lex.cc即为flex自动生成的词法扫描自动机</li>
<li>include中的cool-parser.h是一些宏定义, 比如token type.</li>
</ul>
<h2 id="2-parser-语法分析"><a href="#2-parser-语法分析" class="headerlink" title="2.parser - 语法分析"></a>2.parser - 语法分析</h2><ul>
<li>此阶段主要任务是构建AST树</li>
<li>文件关系:<ul>
<li>parser-phase.cc是main函数所在文件, 调用cool_yyparse函数</li>
<li>把词法分析编译出的lexer文件放进此PA的文件夹中完成词法分析</li>
<li>cool.y为我们要编写的bison文件, cool-parse.cc为bison自动生成的源文件, parser为可执行文件</li>
<li><code>assignments/PA3/cool-tree.handcode.h</code>: 这个真是手写的, 定义了每个class中extra的部分, 使用宏来支持自定义, 在之后的assignment中会加入更多的东西. </li>
</ul>
</li>
<li>If no parent is specified, the class inherits from the Object class. </li>
</ul>
<h3 id="make相关"><a href="#make相关" class="headerlink" title="make相关"></a>make相关</h3><ul>
<li>这make文件中还出现了<code>ln -s</code>命令, 居然只是用来将src或者include文件夹中的源文件复制到当前文件夹下, 真的是有点意义不明. </li>
<li><code>.d</code><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Automatic-Prerequisites.html">文件doc</a> : 为了不用手动更改一个.cc文件的header file prerequisites, 可以先通过编译器自动生成该文件的依赖, 把.d文件名也放到target部分, 输出到.d文件中, 再使用<code>-include</code>加入到makefile中. </li>
<li><code>-include filenames…</code>: This acts like <code>include</code> in every way except that there is no error (not even a warning) if any of the filenames (or any prerequisites of any of the filenames) do not exist or cannot be remade.</li>
<li></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile">ASSN = 3<br>CLASS= cs143<br>CLASSDIR= ../..<br>LIB= -lfl <span class="hljs-comment">#意义不明的flag</span><br>AR= gar<br>ARCHIVE_NEW= -cr<br>RANLIB= gar -qs<br><br>SRC= cool.y cool-tree.handcode.h good.cl bad.cl README<br>CSRC= parser-phase.cc utilities.cc stringtab.cc dumptype.cc \<br>      tree.cc cool-tree.cc tokens-lex.cc  handle_flags.cc <br>TSRC= myparser mycoolc cool-tree.aps <span class="hljs-comment">#这个aps完全都没有用到啊. 确实用不到</span><br>CGEN= cool-parse.cc<br>HGEN= cool-parse.h<br>LIBS= lexer semant cgen<br>CFIL= $&#123;CSRC&#125; $&#123;CGEN&#125;<br>HFIL= cool-tree.h cool-tree.handcode.h <br>LSRC= Makefile<br>OBJS= $&#123;CFIL:.cc=.o&#125; <span class="hljs-comment">#make的字符串替换函数</span><br>OUTPUT= good.output bad.output<br><br><br>CPPINCLUDE= -I. -I$&#123;CLASSDIR&#125;/<span class="hljs-keyword">include</span>/PA$&#123;ASSN&#125; -I$&#123;CLASSDIR&#125;/src/PA$&#123;ASSN&#125;<br><br>BFLAGS = -d -v -y -b cool --debug -p cool_yy<br><br>CC=g++<br>CFLAGS=-g -Wall -Wno-unused -Wno-deprecated  -Wno-write-strings -DDEBUG $&#123;CPPINCLUDE&#125;<br>FLEX=flex $&#123;FFLAGS&#125;<br>BISON= bison $&#123;BFLAGS&#125;<br>DEPEND = $&#123;CC&#125; -MM $&#123;CPPINCLUDE&#125;<br><br><span class="hljs-section">source: $&#123;SRC&#125; $&#123;TSRC&#125; $&#123;LIBS&#125; lsource</span><br><span class="hljs-section">lsource: $&#123;LSRC&#125;</span><br><span class="hljs-section">$&#123;OUTPUT&#125;:	parser good.cl bad.cl</span><br>	@rm -f $&#123;OUTPUT&#125;<br>	./myparser good.cl &gt;good.output 2&gt;&amp;1 <br>	-./myparser bad.cl &gt;bad.output 2&gt;&amp;1 <br><span class="hljs-section">parser: $&#123;OBJS&#125;</span><br>	$&#123;CC&#125; $&#123;CFLAGS&#125; $&#123;OBJS&#125; $&#123;LIB&#125; -o parser<br><span class="hljs-section">.cc.o:</span><br>	$&#123;CC&#125; $&#123;CFLAGS&#125; -c <span class="hljs-variable">$&lt;</span><br><span class="hljs-comment">#使用bison的证据. 但是重命名了一下, 当前文件夹中还有一个cool.tab.h头文件.</span><br>cool-parse.cc cool-parse.h: cool.y<br>	bison $&#123;BFLAGS&#125; cool.y<br>	mv -f cool.tab.c cool-parse.cc<br><span class="hljs-comment">#myparser中使用了lexer, 要先来一个</span><br><span class="hljs-section">dotest:	parser good.cl bad.cl</span><br>	@echo <span class="hljs-string">&quot;\nRunning parser on good.cl\n&quot;</span><br>	-./myparser good.cl <br>	@echo <span class="hljs-string">&quot;\nRunning parser on bad.cl\n&quot;</span><br>	-./myparser bad.cl<br><br><span class="hljs-section">$&#123;LIBS&#125;:</span><br>	$&#123;CLASSDIR&#125;/etc/link-object $&#123;ASSN&#125; <span class="hljs-variable">$@</span><br><span class="hljs-comment">#神奇的符号链接, 把这些源文件都链接到当前文件夹下, 不知道有什么作用. </span><br>$&#123;TSRC&#125; $&#123;CSRC&#125;:<br>	-ln -s $&#123;CLASSDIR&#125;/src/PA$&#123;ASSN&#125;/<span class="hljs-variable">$@</span> <span class="hljs-variable">$@</span><br><span class="hljs-section">$&#123;HSRC&#125;:</span><br>	-ln -s $&#123;CLASSDIR&#125;/<span class="hljs-keyword">include</span>/PA$&#123;ASSN&#125;/<span class="hljs-variable">$@</span> <span class="hljs-variable">$@</span><br><br>clean :<br>	-rm -f $&#123;OUTPUT&#125; *.s core $&#123;OBJS&#125; $&#123;CGEN&#125; $&#123;HGEN&#125; lexer parser cgen semant *~ *.a *.o <br><br><span class="hljs-section">clean-compile:</span><br>	@-rm -f core $&#123;OBJS&#125; $&#123;CGEN&#125; $&#123;HGEN&#125; $&#123;LSRC&#125;<br><br><span class="hljs-section">%.d: %.cc $&#123;LSRC&#125;</span><br>	$&#123;SHELL&#125; -ec &#x27;$&#123;DEPEND&#125; <span class="hljs-variable">$&lt;</span> | sed &#x27;\&#x27;&#x27;s/\(<span class="hljs-variable">$*</span>\.o\)[ :]*/\1 <span class="hljs-variable">$@</span> : /g&#x27;\&#x27;&#x27; &gt; <span class="hljs-variable">$@</span>&#x27;<br><br><span class="hljs-keyword">-include</span> $&#123;CFIL:.cc=.d&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="bison"><a href="#bison" class="headerlink" title="bison:"></a>bison:</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://web.archive.org/web/20210621041953/https://happyers.top/compiler/bison-parser/">生成代码分析</a> | <a target="_blank" rel="noopener" href="https://www.cs.uic.edu/~spopuri/cparser.html">英文</a> | <a target="_blank" rel="noopener" href="https://www.gnu.org/software/bison/manual/bison.html">文档</a> </p>
</li>
<li><p><code>bison</code>所使用的是自底向上，左递归的分析方式。</p>
</li>
<li><p>在语法分析这个过程中，可以过滤出一些不符合语法的错误，例如token排列不符合条件，无法规约。<br>在这种情况下必须进行错误处理程序，将token弹出栈（或者其他操作）。</p>
</li>
<li><p>一个简单的例子</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">%<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>	...<br>    Class_ class_;<br>&#125;<br><br>%type &lt;class_&gt; <span class="hljs-class"><span class="hljs-keyword">class</span></span><br><span class="hljs-class"></span><br><span class="hljs-class">/* <span class="hljs-title">If</span> <span class="hljs-title">no</span> <span class="hljs-title">parent</span> <span class="hljs-title">is</span> <span class="hljs-title">specified</span>, <span class="hljs-title">the</span> <span class="hljs-keyword">class</span> <span class="hljs-title">inherits</span> <span class="hljs-title">from</span> <span class="hljs-title">the</span> <span class="hljs-title">Object</span> <span class="hljs-title">class</span>. */</span><br><span class="hljs-class">/* 定义：以下<span class="hljs-title">token</span>规约后的符号名称为&quot;<span class="hljs-keyword">class</span>&quot; */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> :</span><br>  <span class="hljs-comment">/* 若当前栈中的token满足下面这条式子 */</span><br>  CLASS TYPEID <span class="hljs-string">&#x27;&#123;&#x27;</span> dummy_feature_list <span class="hljs-string">&#x27;&#125;&#x27;</span> <span class="hljs-string">&#x27;;&#x27;</span> <span class="hljs-comment">/* &#x27; */</span><br>    <span class="hljs-comment">/* 进行规约。在规约的同时执行以下这条式子 */</span><br>    <span class="hljs-comment">/* 注意，赋给$$的值，就是规约后新生成&quot;class&quot;的值 */</span><br>    &#123; $$ = <span class="hljs-built_in">class_</span>($<span class="hljs-number">2</span>,idtable.<span class="hljs-built_in">add_string</span>(<span class="hljs-string">&quot;Object&quot;</span>), $<span class="hljs-number">4</span>, stringtable.<span class="hljs-built_in">add_string</span>(curr_filename)); &#125;<br>  | <span class="hljs-comment">/* 或者，如果满足以下式子 */</span><br>  CLASS TYPEID INHERITS TYPEID <span class="hljs-string">&#x27;&#123;&#x27;</span> dummy_feature_list <span class="hljs-string">&#x27;&#125;&#x27;</span> <span class="hljs-string">&#x27;;&#x27;</span><br>    &#123; $$ = <span class="hljs-built_in">class_</span>($<span class="hljs-number">2</span>,$<span class="hljs-number">4</span>,$<span class="hljs-number">6</span>,stringtable.<span class="hljs-built_in">add_string</span>(curr_filename)); &#125;<br>  | <span class="hljs-comment">/* 或者，如果捕获到了错误 */</span><br>  error <span class="hljs-string">&#x27;;&#x27;</span><br>    &#123;&#125;<br>;<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h3 id="语法点"><a href="#语法点" class="headerlink" title="语法点"></a>语法点</h3><ul>
<li><p>You must declare bison “types” for your non-terminals and terminals that have attributes. <code>%type &lt;program&gt; program</code> This declaration says that the non-terminal program has <strong><u>type</u></strong> <code>&lt;program&gt;</code>. The use of the word “type” is misleading here; what it really means is that the <strong>attribute</strong> for the non-terminal program is stored in the program member of the <strong>union</strong> declaration in cool.y, which has type Program. By specifying the type<br><code>%type &lt;member_name&gt; X Y Z ...</code><br>you instruct bison that the attributes of non-terminals (or terminals) X, Y, and Z have a type appropriate for the member member name of the union.</p>
</li>
<li><p>All the union members and their types have similar names by design. It is a coincidence in the example above that the non-terminal program has the same name as a union member.</p>
</li>
<li><p>APS: 在cool_tour.pdf里</p>
<ul>
<li>The Cool abstract syntax is specified in a language called APS</li>
<li>Phyla are really just <strong>types</strong>. That is, instead of having one large group of undifferentiated constructors, the constructors are grouped together <strong>according to function</strong>, 这个意思应该<strong>根据功能</strong>. </li>
<li>the various kinds of abstract syntax tree nodes (let, +, etc.) are called <strong>constructors</strong>.</li>
<li>Each <strong>constructor</strong> takes <strong>typed</strong> arguments and returns a <strong>typed</strong> result. The types may either be phyla or any ordinary C++ type.</li>
<li>In fact, the <strong>phyla</strong> declarations are themselves compiled into <strong>C++ class declarations</strong> by an <strong>APS compiler</strong>.</li>
<li>我没搞清楚aps在哪里被用到了, 还有什么是aps compiler. 不会是自创的吧. <strong>我居然找到一个aps2c++</strong>. 可惜没有什么注释可看. </li>
<li><strong><u><em>重大发现</em></u></strong> : bin文件夹下有个aps2c++, 可以将aps文件转化为<code>cool-tree.cc</code>和<code>cool-tree.h</code>文件, 其中的class成员函数都有. 应该是默认生成的. 果然是自创的吧. 在初始文件中已经转化过了, 所以也不用太在意.<ul>
<li>在aps文件中定义的constructor在cool.y中被使用. The <code>class</code> constructor returns an AST of type (or phylum) <code>Class_</code>.</li>
<li>基本同上: cool-tree.h结尾处定义了在cool.y里用到的constructor, 实际上返回的是对应的class构造函数. 比如<code>class__class()</code> <code>method_class()</code>等等.</li>
</ul>
</li>
<li>真的是太多了. 哪里看的过来.</li>
</ul>
</li>
<li><p>a terminal (<code>CLASS</code>), a non-terminal (<code>class</code>), a constructor (<code>class_</code>), and a phylum (<code>Class_</code>). </p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> Class__class *Class_;<br><span class="hljs-function">Class_ <span class="hljs-title">class__class::copy_Class_</span><span class="hljs-params">()</span></span>&#123;   <br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">class__class</span>(<span class="hljs-built_in">copy_Symbol</span>(name), <span class="hljs-built_in">copy_Symbol</span>(parent), features-&gt;<span class="hljs-built_in">copy_list</span>(), <span class="hljs-built_in">copy_Symbol</span>(filename)); &#125;<br></code></pre></div></td></tr></table></figure></li>
<li><p><strong>反正bison只管推导, 至于分析出结果之后用什么结构存储管理就是我们在定义的部分和其他文件里所写的那样</strong>. </p>
</li>
<li><p>如果要看更多可能要分析bison的输出文件, 暂时不看了. 接下来是语义分析. </p>
</li>
</ul>
<h2 id="3-semantic-语义分析"><a href="#3-semantic-语义分析" class="headerlink" title="3.semantic - 语义分析"></a>3.semantic - 语义分析</h2><ol>
<li>Look at all classes and build an inheritance graph.</li>
<li>Check that the graph is well-formed.</li>
<li>For each class<br>(a) Traverse the AST, gathering all visible declarations in a symbol table.<br>(b) Check each expression for type correctness.<br>(c) Annotate the AST with types.</li>
</ol>
<ul>
<li>semant.h结构如下</li>
<li>注意到symboltable中有三个typedef, 其中SymtabEntry里存储了id和info.<br>tbl指向当前的最里面一层的scope, 当然他是一个list, 可以通过<code>tl()</code>继续找到上一层scope的list节点. </li>
<li>InheritanceNode就是在class_class的基础之上添加了父子类的指针, 还有reachability basic_status+env这些信息. 因为很明显需要存储该类的所有子类以便于继承树检查. </li>
<li>而ClassTable以InheritanceNode的形式存储了所有的class, 文件中所有class检查完之后进入ClassTable的构造函数, 调用private functions例如install_class, build_inheritance_tree等来分析判断继承树的合法性. </li>
<li>创建这三个class的目的也很明显, 语法分析得到的无语法错误的AST树节点由<code>Program_class</code>一类class组成, 但是节点能够存储的信息不够用于继承树和类型检查, 所以在class的基础上添加一些信息继承出InheritanceNode, 再由ClassTable管理, 最终所有的method class var都由一个最大的Environment class管理. </li>
</ul>
<pre><code class=" mermaid">classDiagram
class InheritanceNode
class ClassTable&#123;
   -List&lt;InheritanceNode&gt; *nds
   -install_class()
   -check_improper_inheritance()
   -build_inheritance_tree()
   some_other_funcs()
&#125;
class SymbolTable~Symbol, InheritanceNode~&#123;
   typedef SymtabEntry&lt;SYM,DAT&gt; ScopeEntry;
   typedef List&lt;ScopeEntry&gt; Scope;
   typedef List&lt;Scope&gt; ScopeList;
   -ScopeList *tbl;
   +enterscope() void
   +exitscope() void
   +addid() ScopeEntry*
   +lookup() DAT*
   +probe() DAT*
   +dump() void
&#125;
InheritanceNode &lt;|-- class__class : Inheritance
ClassTable &lt;|-- SymbolTable~Symbol, InheritanceNode~ : Inheritance
class Environment&#123;
    -SymbolTable~Symbol, method_class~ method_table;
    -SymbolTable~Symbol, Entry~  var_table;
    -ClassTableP class_table;
    -Class_      self_class;
    method表操作函数
    variable表操作函数
    type操作函数get_self_type等等
&#125;
InheritanceNode : 该class的信息和environment
class SymtabEntry &#123;
  -SYM id;        // the key field
  -DAT *info;     // associated information for the symbol
  +get_id() SYM
  +get_info() DAT *
&#125;
SymbolTable~Symbol, InheritanceNode~ &lt;|-- SymtabEntry : Inheritance
</code></pre>

<blockquote>
<p>要我写这些东西只能一点点加成员函数啥的, 现在勉强理清楚了结构感觉也能体会到怎么想出这样的程序逻辑. </p>
</blockquote>
<p>先看semant-parse.cc入口main函数</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> Program ast_root;      <span class="hljs-comment">// root of the abstract syntax tree</span><br>FILE *ast_file = stdin;       <span class="hljs-comment">// we read the AST from standard input</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ast_yyparse</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>; <span class="hljs-comment">// entry point to the AST parser</span><br><span class="hljs-keyword">int</span> cool_yydebug;     <span class="hljs-comment">// not used, but needed to link with handle_flags</span><br><span class="hljs-keyword">char</span> *curr_filename;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handle_flags</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;<br>  <span class="hljs-built_in">handle_flags</span>(argc,argv);<br>  <span class="hljs-built_in">ast_yyparse</span>();<br>  ast_root-&gt;<span class="hljs-built_in">semant</span>();<br>  ast_root-&gt;<span class="hljs-built_in">dump_with_types</span>(cout,<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>先是<code>handle_flags()</code>这不知道要干嘛的函数, 然后是<code>ast_yyparse()</code>构造好AST然后将根节点赋值给<code>ast_root</code>, 再执行<code>program_class</code>的<code>semant()</code>函数, <code>dump_with_types()</code>输出AST(不知道要怎么看, 算了也不重要)</p>
<p>再看<code>semant()</code>函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// The function which runs the semantic analyser.</span><br><span class="hljs-function">InheritanceNodeP <span class="hljs-title">program_class::semant</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-built_in">initialize_constants</span>();<br>   ClassTableP classtable = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ClassTable</span>(classes);<br>   <span class="hljs-keyword">if</span> (classtable-&gt;<span class="hljs-built_in">errors</span>()) &#123;<br>      cerr &lt;&lt; <span class="hljs-string">&quot;Compilation halted due to static semantic errors.&quot;</span> &lt;&lt; endl;<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>可以想到在ClassTable的构造函数中完成检查AST树, 其中一个流程如下:</p>
<p>This file implements the semantic checks for Cool.  There are three passes:</p>
<ul>
<li><strong>Pass 1</strong>: This is not a true pass, as only the classes are inspected. The inheritance graph is built and checked for errors.  There are two “sub”-passes: check that classes are not redefined and inherit only from defined classes, and check for <strong>cycles</strong> in the inheritance graph.  Compilation is halted if an error is detected between the sub-passes.<ul>
<li>  enterscope : 新建一个tbl</li>
<li>  install_basic_classes : 注意有三个不可继承的class(No_class SELF_TYPE prim_slot), 具体见semant.cc</li>
<li>  install_classes : 装载构造函数的参数classes</li>
<li>  check_improper_inheritance : </li>
<li>  build_inheritance_tree</li>
<li>  root()-&gt;mark_reachable()</li>
<li>  check_for_cycles</li>
</ul>
</li>
<li><strong>Pass 2</strong>: Symbol tables are built for each class.  This step is done separately because methods and attributes have global scope—therefore, bindings for all methods and attributes must be known before type checking can be done.<ul>
<li>build_feature_tables : 现在有了继承树, <ul>
<li>  首先是初始化Object的env和build_feature_tables(), </li>
<li>  再向env的meth_table或var_table加入该feature, 这个过程中顺带检查一下是否重复定义, 是否错误重载(针对method), 当前类和祖先类是否重名变量(针对attr)</li>
<li>  然后copy the parent’s environment to children’s env, 继续递归迭代.</li>
</ul>
</li>
<li>  check_main : 这个是检查main class和main method是否存在以及main method参数不能为0.</li>
</ul>
</li>
<li><strong>Pass 3</strong>: The inheritance graph—which is known to be a tree if there are no cycles—is traversed again, starting from the root class Object.  For each class, each attribute and method is <strong>typechecked</strong>.  Simultaneously, identifiers are checked for correct definition/use and for multiple definitions.  <strong>An invariant is maintained that all parents of a class are checked before a class is checked.</strong> <ul>
<li>  root()-&gt;type_check_features : 有个东西是type的比较. method最后一条语句的type要&lt;=return_type. 具体见kp博客和代码</li>
</ul>
</li>
</ul>
<p>相应的构造函数为:</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ClassTable::<span class="hljs-built_in">ClassTable</span>(Classes classes) : <span class="hljs-built_in">nds</span>(<span class="hljs-literal">NULL</span>), <br>                                          <span class="hljs-built_in">semant_errors</span>(<span class="hljs-number">0</span>),<br>                                          <span class="hljs-built_in">error_stream</span>(cerr)<br>&#123;<br>  <span class="hljs-built_in">enterscope</span>();             <span class="hljs-comment">// initially the symbol table is empty</span><br>  <span class="hljs-comment">// predefined basic classes, 这个预设的写得差不多了,不过真是套娃结构,也许可以更优雅一点.</span><br>  <span class="hljs-built_in">install_basic_classes</span>();  <br>  <span class="hljs-keyword">if</span> (semant_debug)  cerr &lt;&lt; <span class="hljs-string">&quot;Installed basic classes.&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-comment">//最后程序语法分析出来的最上层的类型是Program,由classes组成</span><br>  <span class="hljs-built_in">install_classes</span>(classes); <span class="hljs-comment">// user defined classes, attach it to the tail of symbolTableList</span><br>  <span class="hljs-keyword">if</span> (semant_debug) <br>    &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Installed user-defined classes&quot;</span> &lt;&lt; endl; <span class="hljs-built_in">dump</span>(); &#125;<br>  <span class="hljs-built_in">check_improper_inheritance</span>();  <span class="hljs-comment">// check for undefined class and `CantInherit` class</span><br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Checked for simple inheritance errors.&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-comment">//遇到上面这种fatal_error的时候就不能往下继续semant了， 必须报错并退出程序</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">errors</span>()) <span class="hljs-keyword">return</span>;<br>                                              <br>  <span class="hljs-comment">//经过了install [basic] classes和check-improper-inheritance，</span><br>  <span class="hljs-comment">//可以保证所建立的继承树每个节点都有valid parent，所以直接使用set_relations</span><br>  <span class="hljs-built_in">build_inheritance_tree</span>(); <span class="hljs-comment">// set class-nodes&#x27; parent and added to parent&#x27;s children list</span><br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Built inheritance tree.&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">mark_reachable</span>(); <span class="hljs-comment">// find all classes reachable from root class</span><br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Marked reachable classes.&quot;</span> &lt;&lt; endl; &#125;                                           <br>  <span class="hljs-comment">// This method should be run only after mark_reachable has executed.</span><br>  <span class="hljs-comment">// **If there are any unreachable classes in the inheritance graph and</span><br>  <span class="hljs-comment">// all of the local checks of check_improper_inheritance succeeded,</span><br>  <span class="hljs-comment">// then there is a cycle in the inheritance graph**.</span><br>  <span class="hljs-built_in">check_for_cycles</span>();       <br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Checked for cycles.&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-comment">//遇到cycles的时候同理 必须报错并退出程序</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">errors</span>()) <span class="hljs-keyword">return</span>;<br>                                              <br>  <span class="hljs-comment">//首先检查完feature每一项, 然后向env的meth_table或var_table加入该feature</span><br>  <span class="hljs-comment">//然后copy the parent&#x27;s environment to children&#x27;s env</span><br>  <span class="hljs-built_in">build_feature_tables</span>();   <span class="hljs-comment">// build symbol tables of features for each class</span><br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Built feature tables.&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-built_in">check_main</span>();             <span class="hljs-comment">// check for Main class and main method</span><br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Checked Main class and method.&quot;</span> &lt;&lt; endl; &#125;<br>                                              <br>  <span class="hljs-comment">// type check all expressions, first root, then all the way down to its children</span><br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">type_check_features</span>(); <br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>然后各种细节细到难以置信, 都不敢想象我自己写到底要用掉多少时间</p>
<p>再次回头看感觉没有那么复杂了. 希望到时中间代码优化也是如此. </p>
<ul>
<li><h2 id="What-requirements-do-I-need-to-check"><a href="#What-requirements-do-I-need-to-check" class="headerlink" title="What requirements do I need to check?"></a>What requirements do I need to check?</h2></li>
<li><h2 id="When-do-I-need-to-check-a-requirement"><a href="#When-do-I-need-to-check-a-requirement" class="headerlink" title="When do I need to check a requirement?"></a>When do I need to check a requirement?</h2></li>
<li><h2 id="When-is-the-information-needed-to-check-a-requirement-generated"><a href="#When-is-the-information-needed-to-check-a-requirement-generated" class="headerlink" title="When is the information needed to check a requirement generated?"></a>When is the information needed to check a requirement generated?</h2></li>
<li><h2 id="Where-is-the-information-I-need-to-check-a-requirement"><a href="#Where-is-the-information-I-need-to-check-a-requirement" class="headerlink" title="Where is the information I need to check a requirement?"></a>Where is the information I need to check a requirement?</h2></li>
</ul>
<h2 id="4-codeGenerate-代码生成"><a href="#4-codeGenerate-代码生成" class="headerlink" title="4.codeGenerate - 代码生成"></a>4.codeGenerate - 代码生成</h2><p>这部分的代码更长了, 诶可真累, 真实的要求可是自己写.</p>
<ol>
<li>Determine and emit code for global constants, such as prototype objects.</li>
<li>Determine and emit code for global tables, such as the class nameTab, the class objTab, and the<br>dispatch tables.</li>
<li>Determine and emit code for the initialization method of each class.</li>
<li>Determine and emit code for each method definition</li>
</ol>
<p>拜拜了, 看累了跳过. </p>
<p>代码生成框架:</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">CgenClassTable::<span class="hljs-built_in">CgenClassTable</span>(Classes classes, ostream&amp; s) : <span class="hljs-built_in">nds</span>(<span class="hljs-literal">NULL</span>) , <span class="hljs-built_in">str</span>(s)<br>&#123;<br>   <span class="hljs-comment">//stringclasstag = 0 /* Change to your String class tag here */;</span><br>   <span class="hljs-comment">//intclasstag =    0 /* Change to your Int class tag here */;</span><br>   <span class="hljs-comment">//boolclasstag =   0 /* Change to your Bool class tag here */;</span><br><br>   <span class="hljs-keyword">if</span> (cgen_debug) cout &lt;&lt; <span class="hljs-string">&quot;Building CgenClassTable&quot;</span> &lt;&lt; endl;<br>   num_classes = <span class="hljs-number">0</span>;<br>   <span class="hljs-comment">// make sure the various tables have a scope</span><br>   class_to_tag_table.<span class="hljs-built_in">enterscope</span>();<br>   class_to_max_child_tag_table.<span class="hljs-built_in">enterscope</span>();<br>   tag_to_class_table.<span class="hljs-built_in">enterscope</span>();<br>   table_of_method_tables.<span class="hljs-built_in">enterscope</span>();<br><br><br>   <span class="hljs-built_in">enterscope</span>();	<span class="hljs-comment">//init a new Scope to ScopeList</span><br>   <span class="hljs-built_in">install_basic_classes</span>();		<span class="hljs-comment">//the same as PA4</span><br>   <span class="hljs-built_in">install_classes</span>(classes);	<br>    <br>   <span class="hljs-built_in">build_inheritance_tree</span>();	<span class="hljs-comment">//building complete</span><br><br>   <span class="hljs-comment">// 递归，将每个CgenNode的attr/method数据</span><br>   <span class="hljs-comment">// 都填入CgenNode和CgenClassTable中的table中</span><br>   <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">init</span>(<span class="hljs-number">0</span>	<span class="hljs-comment">//root() returns CgenNode class</span><br>               ,*(<span class="hljs-keyword">new</span> SymbolTable&lt;Symbol,<span class="hljs-keyword">int</span>&gt;)<br>               ,*(<span class="hljs-keyword">new</span> SymbolTable&lt;<span class="hljs-keyword">int</span>,MethodBinding&gt;)<br>               ,<span class="hljs-number">0</span><br>               ,*(<span class="hljs-keyword">new</span> SymbolTable&lt;Symbol,VarBinding&gt;)<br>               ,*(<span class="hljs-keyword">new</span> SymbolTable&lt;<span class="hljs-keyword">int</span>,Entry&gt;));<br>   <span class="hljs-comment">// 生成代码</span><br>   <span class="hljs-built_in">code</span>();<br>   <span class="hljs-built_in">exitscope</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>在生成目标代码前，需要先读入<strong>AST</strong>的相关信息，**重建继承图<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="因为此时已经通过了semant, 可以确定AST是正确的从而无需检查
">[1]</span></a></sup><strong>，并自上而下的初始化相关的映射表格<br>在该初始化过程中，每个类会遍历其中的<code>feature</code>，并将其相关信息添加至对应的<code>SymbolTable</code>中<br>如果该<code>feature</code>是<code>method</code>，则还会额外自顶向下计算所需要的</strong>最小临时变量数量<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Stanford-cs143-pdf中提到的
">[2]</span></a></sup>**，并将其添加进表格中。</li>
</ul>
<ul>
<li>init()的过程:<ul>
<li>从形参中得到该class初始feature个数</li>
<li>assign_tag</li>
<li>各种enterscope</li>
<li>装载features, 用到了layout_featues:<ul>
<li>layout_method():</li>
<li>layout_attr():</li>
</ul>
</li>
<li>各种map的赋值</li>
</ul>
</li>
<li>code()的过程:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CgenClassTable::code</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <br>  <span class="hljs-keyword">if</span> (cgen_debug) cout &lt;&lt; <span class="hljs-string">&quot;coding global data&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_global_data</span>();<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cout &lt;&lt; <span class="hljs-string">&quot;choosing gc&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_select_gc</span>();<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cout &lt;&lt; <span class="hljs-string">&quot;coding constants&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_constants</span>();<br><br><span class="hljs-comment">//                 Add your code to emit</span><br><span class="hljs-comment">//                   - prototype objects</span><br><span class="hljs-comment">//                   - class_nameTab</span><br><span class="hljs-comment">//                   - dispatch tables</span><br><span class="hljs-comment">//</span><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding class table&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_class_table</span>();<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding object table&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_object_table</span>();<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding dispatch tables&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">code_dispatch_table</span>(str);	<span class="hljs-comment">//recursively</span><br><br>  <span class="hljs-comment">// </span><br>  <span class="hljs-comment">// Check that strings required to code the prototype objects are installed.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-built_in">assert</span>(inttable.<span class="hljs-built_in">lookup_string</span>(<span class="hljs-string">&quot;0&quot;</span>));<br>  <span class="hljs-built_in">assert</span>(stringtable.<span class="hljs-built_in">lookup_string</span>(<span class="hljs-string">&quot;&quot;</span>));<br>  <span class="hljs-built_in">assert</span>(idtable.<span class="hljs-built_in">lookup_string</span>(INTNAME));<br>  <span class="hljs-built_in">assert</span>(idtable.<span class="hljs-built_in">lookup_string</span>(STRINGNAME));<br>  <span class="hljs-built_in">assert</span>(idtable.<span class="hljs-built_in">lookup_string</span>(BOOLNAME));<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding prototypes&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">code_prototype_object</span>(str);<br><br>  <span class="hljs-comment">// /*##*/</span><br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cout &lt;&lt; <span class="hljs-string">&quot;coding global text&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_global_text</span>();<br><br><span class="hljs-comment">//                 Add your code to emit</span><br><span class="hljs-comment">//                   - object initializer</span><br><span class="hljs-comment">//                   - the class methods</span><br><span class="hljs-comment">//                   - etc...</span><br>  CgenEnvTopLevelP env = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CgenEnvTopLevel</span>(&amp;class_to_tag_table,<br>					     &amp;class_to_max_child_tag_table,<br>					     &amp;table_of_method_tables,<br>					     num_classes);<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding init methods&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">code_init</span>(str,env);<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding methods&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">code_methods</span>(str,env);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://kiprey.github.io/2020/06/compiler-learning/#5-cgen-%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90">以下部分 出处, 未全cv</a>:</p>
<ul>
<li><p>声明全局变量。例如以下mips汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">  .data<br>  .align  2<br>  .globl  class_nameTab<br>  .globl  Main_protObj<br>  .globl  Int_protObj<br>  .globl  String_protObj<br>  .globl  bool_const0<br>  .globl  bool_const1<br>  .globl  _int_tag<br>  .globl  _bool_tag<br>  .globl  _string_tag<br><br>_int_tag:<br>  .word 3<br>_bool_tag:<br>  .word 4<br>_string_tag:<br>  .word 5<br>  .globl _MemMgr_INITIALIZER<br></code></pre></div></td></tr></table></figure></li>
<li><p>声明GC器。例如以下汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">_MemMgr_INITIALIZER:<br>  .word _NoGC_Init<br>  .globl _MemMgr_COLLECTOR<br>_MemMgr_COLLECTOR:<br>  .word _NoGC_Collect<br>  .globl _MemMgr_TEST<br>_MemMgr_TEST:<br>  .word 0<br>  .word -1<br></code></pre></div></td></tr></table></figure></li>
<li><p>将常量输出（例如：数字，字符串，布尔常量），例如以下部分汇编代码</p>
<blockquote>
<p>数字常量包括<code>0</code>，字符串常量包括空字符串<code>&quot;&quot;</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">  .word -1          # eye catcher for _gc_check<br>str_const8:             # 该字符串的标签<br>  .word 5               # string class tag<br>  .word 6               # size of the class(include 5,6,string_disptab,string and align)/word<br>  .word String_dispTab  # 该类型可以使用的方法<br>  .word int_const2      # 字符串长度（其中的int_const2指向另一个数字常量）<br>  .ascii &quot;Main&quot;         # 字符串的ASCII码<br>  .byte 0               # 字符串末尾的\0终结符<br>  .align 2              # 对齐<br></code></pre></div></td></tr></table></figure></li>
<li><p>将所有类的名称输出。例如以下汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">class_nameTab:        # 这一个个的str_const都指向特定的字符串<br>  .word str_const6    # str_const6  =&gt; &quot;Object&quot;<br>  .word str_const7    # str_const7  =&gt; &quot;IO&quot;<br>  .word str_const8    # str_const8  =&gt; &quot;Main&quot;<br>  .word str_const9    # str_const9  =&gt; &quot;Int&quot;<br>  .word str_const10   # str_const10 =&gt; &quot;Bool&quot;<br>  .word str_const11   # str_const11 =&gt; &quot;String&quot;<br></code></pre></div></td></tr></table></figure></li>
<li><p>将所有类中的object table输出（未知用途，删除后仍然可以执行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">class_objTab:<br>  .word  Object_protObj<br>  .word  Object_init<br>  .word  IO_protObj<br>  .word  IO_init<br>  .word  Main_protObj<br>  .word  Main_init<br>  .word  Int_protObj<br>  .word  Int_init<br>  .word  Bool_protObj<br>  .word  Bool_init<br>  .word  String_protObj<br>  .word  String_init<br></code></pre></div></td></tr></table></figure></li>
<li><p>将每个类所含的方法输出（包括该类的继承类中的方法），例如以下汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">Main_dispTab:<br>  .word  Object.abort<br>  .word  Object.type_name<br>  .word  Object.copy<br>  .word  IO.out_string<br>  .word  IO.out_int<br>  .word  IO.in_string<br>  .word  IO.in_int<br>  .word  Main.main<br></code></pre></div></td></tr></table></figure></li>
<li><p>将每个类的类型信息输出。<code>protObj</code>中含有当前类的属性以及函数表。例如以下部分汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">  .word  -1         # -1 header for the garbage collector(eye catcher for _gc_check)<br>Main_protObj:         # label<br>  .word  2            # class tag<br>  .word  7            # total_attributes + DEFAULT_OBJFIELDS<br>  .word  Main_dispTab # 函数表<br>  .word  int_const0   # 第一个attribute是数字类型<br>  .word  str_const12  # 第二个attribute是字符串类型<br>  .word  bool_const0  # 第三个attribute是布尔类型<br>  .word  0            # 第四个attribute是其他类型，例如各种类<br></code></pre></div></td></tr></table></figure></li>
<li><p>声明全局代码段的相关信息，例如以下汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">#声明堆的相关信息<br>  .globl  heap_start<br>heap_start:<br>  .word  0<br>#声明text代码段<br>  .text<br>  .globl  Main_init<br>  .globl  Int_init<br>  .globl  String_init<br>  .globl  Bool_init<br>  .globl  Main.main<br></code></pre></div></td></tr></table></figure></li>
<li><p>输出每个类的初始化函数的代码，例如以下汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">String_init:<br>  addiu  $sp $sp -12<br>  sw  $fp 12($sp)<br>  sw  $s0 8($sp)<br>  sw  $ra 4($sp)<br>  addiu  $fp $sp 4<br>  move  $s0 $a0<br>  jal  Object_init<br>  move  $a0 $s0<br>  lw  $fp 12($sp)<br>  lw  $s0 8($sp)<br>  lw  $ra 4($sp)<br>  addiu  $sp $sp 12<br>  jr  $ra<br></code></pre></div></td></tr></table></figure>
<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>因为此时已经通过了semant, 可以确定AST是正确的从而<strong>无需检查</strong>
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Stanford-cs143-pdf中提到的
<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/CS/">CS</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/complier/">complier</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022-01/Learning-Computer-Networking/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Computer Networking</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021-10/Learning-ucore/">
                        <span class="hidden-mobile">Tsinghua操作系统课程</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"312db7ebbc085de5d28d","clientSecret":"85ea3cefd13c73a6d85c1813adfde4f1550bfbda","repo":"yogdzewa.github.io","owner":"yogdzewa","admin":["yogdzewa"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '789d94d32e8b9ca27d432511983a34ff'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" lazyload class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
