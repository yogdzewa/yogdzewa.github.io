

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="虽然妄图和肖哥比是自不量力, 但我还是努力一把">
  <meta name="author" content="Yogdzewa">
  <meta name="keywords" content="">
  
  <title>Tsinghua操作系统课程 - Yogdzewa</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":1280126539,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>nuts-and-bolts</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/image/edit2.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Tsinghua操作系统课程">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Yogdzewa
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-10-01 10:00" pubdate>
        2021年10月1日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      147
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Tsinghua操作系统课程</h1>
            
              <p class="note note-info">
                
                  不可视境界线最后变动于：20 分钟前
                
              </p>
            
            <div class="markdown-body">
              <h1 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="1-BIOS启动顺序"><a href="#1-BIOS启动顺序" class="headerlink" title="1.BIOS启动顺序"></a>1.BIOS启动顺序</h3><ul>
<li>CPU加电后代码段寄存器初始化为<strong>CS = F000H, EIP = 0000FFF0H</strong>, 然后再计算 Base+IP = FFFF0000H + 0000FFF0H = FFFFFFF0H 得到BIOS的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/EPROM">EPROM</a>(Erasable Programmable Read Only Memory)所在地, 这个地址的第一条指令是一个<strong>长跳转指令</strong>(这样CS和EIP都会更新)到BIOS代码中执行</li>
<li>BIOS做完计算机硬件自检和初始化后，会选择一个启动设备（例如软盘、硬盘、光盘等），并且读取该设备的第一扇区(即主引导扇区或启动扇区)到内存一个特定的地址0x7c00处，然后CPU控制权会转移到那个地址继续执行。至此BIOS的初始化工作做完了，进一步的工作交给了ucore的bootloader。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_1_bios_booting.html#%E8%A1%A5%E5%85%85%E4%BF%A1%E6%81%AF">附</a>:</p>
<ul>
<li>在16位的8086 CPU时代，内存限制在1MB范围内，且BIOS的代码固化在EPROM中。在基于Intel的8086 CPU的PC机中的EPROM被编址在1ＭB内存地址空间的最高64KB中。PC加电后，CS寄存器初始化为<strong>0xF000</strong>，IP寄存器初始化为<strong>0xFFF0</strong>, CS:IP=0xF000:0XFFF0（Segment:Offset 表示）=<strong>0xFFFF0</strong>(Linear表示)</li>
<li>默认将执行BIOS ROM编址在32位内存地址空间的最高端，即位于4GB地址的最后一个64KB内。在PC系统开机复位时，CPU进入实模式，并将CS寄存器设置成0xF000，将它的<strong>shadow register</strong>的<strong>Base</strong>值初始化设置为0xFFFF0000，EIP寄存器初始化设置为0x0000FFF0。所以机器执行的第一条指令的物理地址是<strong>0xFFFFFFF0</strong>。80386的BIOS代码也要和以前8086的BIOS代码兼容，故地址0xFFFFFFF0处的指令还是一条长跳转指令<code>jmp F000:E05B</code>。注意，这个长跳转指令会触发更新CS寄存器和它的shadow register，即执行<code>jmp F000 : E05B</code>后，CS将被更新成0xF000。表面上看CS其实没有变化，但CS的shadow register被更新为另外一个值了，它的Base域被更新成0x000F0000，此时形成的物理地址为Base+EIP=0x000FE05B，这就是CPU执行的第二条指令的地址。此时这条指令的地址已经是1M<strong>以内</strong>了，且此地址不再位于BIOS ROM中，而是位于RAM空间中。由于Intel设计了一种映射机制，将内存高端的BIOS ROM映射到1MB以内的RAM空间里，并且可以使这一段被映射的RAM空间具有与ROM类似的只读属性。所以PC机启动时将开启这种映射机制，让4GB地址空间的最高一个64KB的内容等同于1MB地址空间的最高一个64K的内容，从而使得执行了长跳转指令后，其实是回到了早期的8086 CPU初始化控制流，保证了向下兼容</li>
</ul>
<p>例图:</p>
<img src="https://i.loli.net/2021/11/15/gqzhf1o9HjFSRZd.png" srcset="/img/loading.gif" lazyload alt="image-20211110102048633"  />

<img src="https://i.loli.net/2021/11/15/5smFgYn7Bxhq3Ke.png" srcset="/img/loading.gif" lazyload alt="image-20211110101314467" style="zoom:67%;" />

<h3 id="2-实模式"><a href="#2-实模式" class="headerlink" title="2.实模式"></a>2.实模式</h3><p>参考资料:《Intel 80386 Reference Programmers Manual-i386》, 基本是这个的翻译</p>
<p>在bootloader接手BIOS的工作后，当前的PC系统处于实模式（16位模式）运行状态，在这种状态下软件可访问的物理内存空间不能超过1MB，且无法发挥Intel 80386以上级别的32位CPU的4GB内存管理能力。</p>
<p>实模式将整个物理内存看成分段的区域，程序代码和数据位于不同区域，操作系统和用户程序并没有区别对待，<strong>而且每一个指针都是指向实际的物理地址</strong>。这样，用户程序的一个指针如果指向了操作系统区域或其他用户程序区域，并修改了内容，那么其后果就很可能是灾难性的。通过修改A20地址线可以完成从实模式到保护模式的转换。有关A20的进一步信息可参考“<a target="_blank" rel="noopener" href="http://hengch.blog.163.com/blog/static/107800672009013104623747/">关于A20 Gate</a>”。</p>
<img src="https://i.loli.net/2021/11/15/v6fC2e43WESLcaU.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 67%;" />

<ul>
<li>地址<code>0-0x9ffff</code>的640KB内存是DRAM，即插在主板上的内存条。<br>顶部<code>0xf0000-0xfffff</code>的64KB内存是ROM，存放BIOS代码。</li>
<li>EPROM是通过地址来访问的, 80386将其映射到内存的顶端, 其他的一些外设也同样通过映射到地址空间来访问它们</li>
</ul>
<h3 id="3-分段机制-保护模式"><a href="#3-分段机制-保护模式" class="headerlink" title="3.分段机制/保护模式"></a>3.分段机制/保护模式</h3><h4 id="a-保护模式"><a href="#a-保护模式" class="headerlink" title="a.保护模式"></a>a.保护模式</h4><ul>
<li><p>只有在保护模式下，80386的<strong>全部32根地址线有效</strong>，可寻址高达4G字节的线性地址空间和物理地址空间，可访问64TB（有2^14^个段，每个段最大空间为2^32^字节）的逻辑地址空间，可采用分段存储管理机制和分页存储管理机制。这不仅为存储共享和保护提供了硬件支持，而且为实现虚拟存储提供了硬件支持。通过提供4个特权级和完善的特权检查机制，既能实现资源共享又能保证代码数据的安全及任务的隔离。</p>
<blockquote>
<p>【补充】保护模式下，有两个段表：GDT（Global Descriptor Table）和LDT（Local Descriptor Table），每一张段表可以包含8192 (2^13)个描述符[1]，因而最多可以同时存在2 * 2^13 = 2^14^个段。虽然保护模式下可以有这么多段，逻辑地址空间看起来很大，但实际上段并不能扩展物理地址空间，很大程度上各个段的地址空间是<strong>相互重叠</strong>的。目前所谓的64TB（2^(14+32)^=2^46^）逻辑地址空间是一个理论值，没有实际意义。在32位保护模式下，真正的物理空间仍然只有2^32字节那么大。注：在ucore lab中只用到了GDT，没有用LDT。</p>
<p>Reference: [1] 3.5.1 Segment Descriptor Tables, Intel® 64 and IA-32 Architectures Software Developer’s Manual</p>
</blockquote>
</li>
</ul>
<h4 id="b-分段机制"><a href="#b-分段机制" class="headerlink" title="b.分段机制"></a>b.分段机制</h4><blockquote>
<p>b,c,d顺序按照<strong>35</strong>年前的i386文档, 图片来自IA-32文档</p>
</blockquote>
<ul>
<li><p>将内存划分成以起始地址和长度限制这两个二维参数表示的内存块，这些内存块就称之为段（Segment）。编译器把源程序编译成执行程序时用到的代码段、数据段、堆和栈等概念在这里可以与段联系起来，二者在含义上是一致的</p>
</li>
<li><p>转换逻辑地址（Logical Address,应用程序员看到的地址）到物理地址（Physical Address, 实际的物理内存地址）分以下两步：</p>
<p>[1] 分段地址转换：<img src="https://i.loli.net/2021/11/15/2voBNa4eHCJYpDS.png" srcset="/img/loading.gif" lazyload alt="image-20211110224722534" style="zoom:67%;" /></p>
<p>[2] 分页地址转换，这一步中把线性地址转换为物理地址。（注意：这一步是可选的，由操作系统决定是否需要。在后续试验中会涉及。</p>
</li>
</ul>
<h4 id="c-Segment-Selector"><a href="#c-Segment-Selector" class="headerlink" title="c.Segment Selector"></a>c.Segment Selector</h4><ul>
<li>A segment selector is a 16-bit identifier for a segment (see Figure 3-6). It does not point directly to the segment,<br>but instead points to the segment descriptor that defines the segment. </li>
</ul>
<img src="https://i.loli.net/2021/11/15/2pZPMgihVI6QSrR.png" srcset="/img/loading.gif" lazyload alt="image-20211110233814790" style="zoom:67%;" />

<h4 id="d-Segment-register"><a href="#d-Segment-register" class="headerlink" title="d.Segment register"></a>d.Segment register</h4><ul>
<li><p>For virtually any kind of program execution to take place, at least the code-segment (CS), data-segment (DS), and stack-segment (SS) registers must be loaded with valid segment selectors.</p>
</li>
<li><p>three additional data-segment registers (ES, FS, and GS) are optional</p>
<img src="https://i.loli.net/2021/11/15/JX7IuMO4QodfVFK.png" srcset="/img/loading.gif" lazyload alt="image-20211110232108110" style="zoom: 67%;" /></li>
<li><p>For a program to access a segment, the segment selector for the segment <strong>must have been loaded in one of the</strong><br><strong>segment registers</strong>. So, although a system can define thousands of segments, <strong>only 6 can be available</strong> for immediate<br>use. </p>
</li>
<li><p><strong>shadow register(“hidden” part):</strong></p>
<p>When a segment selector is loaded into the visible part, the processor also loads the hidden part from the segment descriptor pointed to by the segment selector</p>
</li>
</ul>
<h4 id="e-Segment-Descriptor"><a href="#e-Segment-Descriptor" class="headerlink" title="e.Segment Descriptor"></a>e.Segment Descriptor</h4><blockquote>
<p><strong>来自IA-32文档 P2902/3-10 Vol. 3A</strong> </p>
</blockquote>
<img src="https://i.loli.net/2021/11/15/IxTJPGOZWVjz2BD.png" srcset="/img/loading.gif" lazyload alt="image-20211110230124631" style="zoom:80%;" />

<h4 id="f-Global-Descriptor-Tables"><a href="#f-Global-Descriptor-Tables" class="headerlink" title="f.Global Descriptor Tables"></a>f.Global Descriptor Tables</h4><blockquote>
<p><strong>(IA-32 P2906/ 3-14 Vol. 3A)</strong>:</p>
</blockquote>
<p>全局描述符表的是一个保存多个段描述符的“数组”，其起始地址保存在全局描述符表寄存器GDTR中。GDTR长48位，其中高32位为基地址，低16位为段界限。由于GDT 不能有GDT本身之内的描述符进行描述定义，所以处理器采用GDTR为GDT这一特殊的系统段。注意，全局描述符表中第一个段描述符设定为空段描述符。GDTR中的段界限以字节为单位。对于含有N个描述符的描述符表的段界限通常可设为8*N-1。</p>
<img src="https://i.loli.net/2021/11/15/t1iNrJbCeBzASFf.png" srcset="/img/loading.gif" lazyload alt="image-20211110230336834" style="zoom:67%;" />

<h4 id="g-Privilege-Level"><a href="#g-Privilege-Level" class="headerlink" title="g.Privilege Level"></a>g.Privilege Level</h4><ul>
<li>Current privilege level (<strong>CPL</strong>) — The CPL is the privilege level of the currently executing program or task. <u>It</u><br><u>is stored in bits 0 and 1 of the CS and SS segment registers.</u> Normally, the CPL is equal to the privilege level of<br>the code segment from which instructions are being fetched. The processor changes the CPL when program<br>control is transferred to a code segment with a different privilege level. </li>
</ul>
<blockquote>
<p>The CPL is treated slightly differently when accessing <strong>conforming code segments</strong>. Conforming code segments can be accessed from any privilege level that is equal to or numerically greater (less privileged) than the DPL of the conforming code segment. Also, the CPL is not changed when the processor accesses a conforming code segment that has a different privilege level than the CPL.</p>
</blockquote>
<ul>
<li>Descriptor privilege level (<strong>DPL</strong>) — The DPL is the privilege level of a segment or gate. It is stored in the DPL<br>field of the segment or gate descriptor for the segment or gate. </li>
<li>Requested privilege level (<strong>RPL</strong>) — The RPL is an override privilege level that is assigned to segment<br>selectors. It is stored in bits 0 and 1 of the segment selector. The RPL can be used to ensure that privileged code<br>does not access a segment on behalf of an application program unless the program itself has access privileges for<br>that segment. See Section 5.10.4, “Checking Caller Access Privileges (ARPL Instruction),” for a detailed description of<br>the purpose and typical use of the RPL.</li>
</ul>
<p><strong>PRIVILEGE CHECK:</strong> </p>
<p><img src="https://i.loli.net/2021/11/16/JGd27NnTwFDipOe.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="4-地址空间"><a href="#4-地址空间" class="headerlink" title="4.地址空间"></a>4.地址空间</h3><pre><code class=" mermaid">flowchart LR
    逻辑地址--&gt;|分段地址转换|线性地址
    线性地址--&gt;|分页地址转换|物理地址
    线性地址--&gt;End
</code></pre>

<h3 id="5-硬件访问"><a href="#5-硬件访问" class="headerlink" title="5.硬件访问"></a>5.<a target="_blank" rel="noopener" href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_2_3_dist_accessing.html">硬件访问</a></h3><p>bootloader让CPU进入保护模式后，下一步的工作就是从硬盘上加载并运行OS。考虑到实现的简单性，bootloader的访问硬盘都是LBA模式的PIO（Program IO）方式，即所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成。</p>
<p>一般主板有2个IDE通道，每个通道可以接2个IDE硬盘。访问第一个硬盘的扇区可设置IO地址寄存器0x1f0-0x1f7实现的，具体参数见下表。一般第一个IDE通道通过访问IO地址0x1f0-0x1f7来实现，第二个IDE通道通过访问0x170-0x17f实现。每个通道的主从盘的选择通过第6个IO偏移地址寄存器来设置。</p>
<p>表一 磁盘IO地址和对应功能</p>
<p>第6位：为1=LBA模式；0 = CHS模式 第7位和第5位必须为1</p>
<table>
<thead>
<tr>
<th>IO地址</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>0x1f0</td>
<td>读数据，当0x1f7不为忙状态时，可以读。</td>
</tr>
<tr>
<td>0x1f2</td>
<td>要读写的扇区数，每次读写前，你需要表明你要读写几个扇区。最小是1个扇区</td>
</tr>
<tr>
<td>0x1f3</td>
<td>如果是LBA模式，就是LBA参数的0-7位</td>
</tr>
<tr>
<td>0x1f4</td>
<td>如果是LBA模式，就是LBA参数的8-15位</td>
</tr>
<tr>
<td>0x1f5</td>
<td>如果是LBA模式，就是LBA参数的16-23位</td>
</tr>
<tr>
<td>0x1f6</td>
<td>第0~3位：如果是LBA模式就是24-27位 第4位：为0主盘；为1从盘</td>
</tr>
<tr>
<td>0x1f7</td>
<td>状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口读数据</td>
</tr>
</tbody></table>
<p>当前 硬盘数据是储存到硬盘扇区中，一个扇区大小为512字节。读一个扇区的流程（可参看boot/bootmain.c中的readsect函数实现）大致如下：</p>
<ol>
<li>等待磁盘准备好</li>
<li>发出读取扇区的命令</li>
<li>等待磁盘准备好</li>
<li>把磁盘扇区数据读到指定内存</li>
</ol>
<h3 id="6-中断与异常"><a href="#6-中断与异常" class="headerlink" title="6.中断与异常"></a>6.中断与异常</h3><ul>
<li>中断机制给操作系统提供了处理意外情况的能力，同时它也是实现进程/线程抢占式调度的一个重要基石。但中断的引入导致了对操作系统的理解更加困难。</li>
<li>在操作系统中，有三种特殊的中断事件。<ul>
<li>由CPU<em>外部设备引起的</em> 外部事件如I/O中断、时钟中断、控制台中断等是异步产生的（即产生的时刻不确定），与CPU的执行无关，我们称之为<strong>异步中断</strong>(asynchronous interrupt)也称外部中断,简称<strong>中断</strong>(interrupt)。</li>
<li>而把在CPU执行指令期间检测到<em>不正常的或非法</em> 的条件(如除零错、地址访问越界)所引起的内部事件称作<strong>同步中断</strong>(synchronous interrupt)，也称内部中断，简称**异常(**exception)。</li>
<li>把在程序中使用<em>请求系统服务</em> 的系统调用而引发的事件，称作<strong>陷入中断</strong>(trap interrupt)，也称<strong>软中断</strong>(soft interrupt)，系统调用(system call)简称trap。在后续试验中会进一步讲解系统调用。</li>
</ul>
</li>
<li><u>本实验只描述保护模式下的处理<strong>过程</strong></u>: 当CPU收到中断（通过<a target="_blank" rel="noopener" href="https://blog.csdn.net/longintchar/article/details/79439466">8259A</a>完成）或者异常的事件时，它会暂停执行当前的程序或任务，通过一定的机制跳转到负责处理这个信号的相关处理例程中，在完成对这个事件的处理后再跳回到刚才被打断的程序或任务中。中断向量和中断服务例程的对应关系主要是由IDT（中断描述符表）负责。操作系统在IDT中设置好各种中断向量对应的中断描述符，留待CPU在产生中断后查询对应中断服务例程的起始地址。</li>
</ul>
<img src="https://i.loli.net/2021/11/16/5HxAC9w4XSiasbK.png" srcset="/img/loading.gif" lazyload  style="zoom: 60%;" />

<ul>
<li><p><strong>Interrupt Descriptor Table</strong>:同GDT一样，IDT是一个8字节的描述符数组，但IDT的第一项可以包含一个描述符。CPU把中断（异常）号乘以8做为IDT的索引。IDT可以位于内存的任意位置，CPU通过IDT寄存器（IDTR）的内容来寻址IDT的起始地址。指令LIDT和SIDT用来操作IDTR。两条指令都有一个显示的操作数：一个6字节表示的内存地址(包含线性地址基址和界限)。</p>
<p>在保护模式下，最多会存在256个Interrupt/Exception Vectors。</p>
<p>范围[0，31]内的32个向量被异常Exception和NMI使用，但当前并非所有这32个向量都已经被使用，有几个当前没有被使用的，请不要擅自使用它们，它们被保留，以备将来可能增加新的Exception。</p>
<p>范围[32，255]内的向量被保留给用户定义的Interrupts。Intel没有定义，也没有保留这些Interrupts。用户可以将它们用作外部I/O设备中断（8259A IRQ），或者系统调用（System Call 、Software Interrupts）等。</p>
</li>
<li><p><strong>IDT gate descriptors</strong>: Interrupts/Exceptions应该使用Interrupt Gate和Trap Gate，它们之间的唯一区别就是：当调用Interrupt Gate时，Interrupt会被CPU自动禁止；而调用Trap Gate时，CPU则不会去禁止或打开中断，而是保留它原来的样子。</p>
<blockquote>
<p>【补充】所谓“自动禁止”，指的是CPU跳转到interrupt gate里的地址时，在将EFLAGS保存到栈上之后，清除EFLAGS里的IF位，以避免重复触发中断。在中断处理例程里，操作系统可以将EFLAGS里的IF设上,从而允许嵌套中断。但是必须在此之前做好处理嵌套中断的必要准备，如保存必要的寄存器等。二在ucore中访问Trap Gate的目的是为了实现系统调用。用户进程在正常执行中是不能禁止中断的，而当它发出系统调用后，将通过Trap Gate完成了从用户态（ring 3）的用户进程进了核心态（ring 0）的OS kernel。如果在到达OS kernel后禁止EFLAGS里的IF位，第一没意义（因为不会出现嵌套系统调用的情况），第二还会导致某些中断得不到及时响应，所以调用Trap Gate时，CPU则不会去禁止中断。总之，interrupt gate和trap gate之间没有优先级之分，仅仅是CPU在处理中断时有不同的方法，供操作系统在实现时根据需要进行选择。</p>
</blockquote>
</li>
<li><p>在IDT中，可以包含如下3种类型的Descriptor：</p>
<ul>
<li>Task-gate descriptor （这里没有使用）</li>
<li>Interrupt-gate descriptor （中断方式用到）</li>
<li>Trap-gate descriptor（系统调用用到）</li>
</ul>
</li>
</ul>
<img src="https://i.loli.net/2021/11/16/qbyzSN56w9eDHKX.png" srcset="/img/loading.gif" lazyload alt="image-20211116161700420" style="zoom:70%;" />

<ul>
<li><p>中断处理中**==硬件负责完成的==**工作: </p>
<ul>
<li><p>硬件中断处理过程1（起始）：从CPU收到中断事件后，打断当前程序或任务的执行，根据某种机制跳转到中断服务例程去执行的过程。其具体流程如下：</p>
<ul>
<li>CPU在执行完当前程序的每一条指令后，都会去确认在执行刚才的指令过程中中断控制器（如：8259A）是否发送中断请求过来，如果有那么CPU就会在相应的时钟脉冲到来时从总线上读取中断请求对应的中断向量；</li>
<li>CPU根据得到的中断向量（以此为索引）到IDT中找到该向量对应的中断描述符，中断描述符里保存着中断服务例程的段选择子；</li>
<li>CPU使用IDT查到的中断服务例程的段选择子从GDT中取得相应的段描述符，段描述符里保存了中断服务例程的段基址和属性信息，此时CPU就得到了中断服务例程的起始地址，并跳转到该地址；</li>
</ul>
<p>以上三个过程示意图: <a target="_blank" rel="noopener" href="https://i.loli.net/2021/11/16/hGLAjlTYVSWpk67.png">link</a> </p>
<ul>
<li>CPU会根据CPL和中断服务例程的段描述符的DPL信息确认是否发生了特权级的转换。比如当前程序正运行在用户态，而中断程序是运行在内核态的，则意味着发生了特权级的转换，这时CPU会从当前程序的TSS信息（该信息在内存中的起始地址存在TR寄存器中）里取得该程序的内核栈地址，即包括内核态的ss和esp的值，并立即将系统当前使用的栈切换成新的内核栈。这个栈就是即将运行的中断服务程序要使用的栈。紧接着就将当前程序使用的用户态的ss和esp压到新的内核栈中保存起来；</li>
<li>CPU需要开始保存当前被打断的程序的现场（即一些寄存器的值），以便于将来恢复被打断的程序继续执行。这需要利用内核栈来保存相关现场信息，即依次压入当前被打断程序使用的eflags，cs，eip，errorCode（如果是有错误码的异常）信息；</li>
<li>CPU利用中断服务例程的段描述符将其第一条指令的地址加载到cs和eip寄存器中，开始执行中断服务例程。这意味着先前的程序被暂停执行，<strong>中断服务程序正式开始工作</strong>。</li>
</ul>
</li>
<li><p>硬件中断处理过程2（结束）：<strong>中断处理工作完成后</strong>需要通过iret（或iretd）指令恢复被打断的程序的执行。CPU执行IRET指令的具体过程如下：</p>
<ul>
<li>程序执行这条iret指令时，首先会从内核栈里弹出先前保存的被打断的程序的现场信息，即eflags，cs，eip重新开始执行；</li>
<li>如果存在特权级转换（从内核态转换到用户态），则还需要从内核栈中弹出用户态栈的ss和esp，这样也意味着栈也被切换回原先使用的用户态的栈了；</li>
<li>如果此次处理的是带有错误码（errorCode）的异常，CPU在恢复先前程序的现场时，并不会弹出errorCode。这一步需要通过软件完成，即要求相关的中断服务例程在调用iret返回之前添加出栈代码主动弹出errorCode。</li>
</ul>
</li>
</ul>
</li>
<li><p>中断处理得==特权级转换==是通过门描述符（gate descriptor）和相关指令来完成的。一个门描述符就是一个系统类型的段描述符，一共有4个子类型：</p>
<ul>
<li>调用门描述符（call-gate descriptor may reside in the GDT or in an LDT, but not in the interrupt descriptor table (IDT)），</li>
<li>中断门描述符（interrupt-gate descriptor）</li>
<li>陷阱门描述符（trap-gate descriptor）</li>
<li>任务门描述符（task-gate descriptor）。</li>
</ul>
<p>Task gates are used for task switching and are discussed in Chapter 7, “Task Management”. Trap and interrupt<br>gates are special kinds of call gates used for calling exception and interrupt handlers。中断门描述符和陷阱门描述符几乎是一样的。</p>
<ul>
<li>中断发生时实施特权检查的过程如下图所示：</li>
</ul>
<img src="https://i.loli.net/2021/11/16/fqGtF4SHxWPCJhg.png" srcset="/img/loading.gif" lazyload alt="这里是图片描述" style="zoom:80%;" />

<ul>
<li>门中的DPL和段选择符一起控制着访问，同时，段选择符结合偏移量（Offset）指出了中断处理例程的入口点。内核一般在门描述符中填入内核代码段的段选择子。产生中断后，CPU一定不会将运行控制从高特权环转向低特权环，特权级必须要么保持不变（当操作系统内核自己被中断的时候），或被提升（当用户态程序被中断的时候）。无论哪一种情况，作为结果的CPL必须大于等于目的代码段的DPL。如果CPL发生了改变，一个堆栈切换操作（通过TSS完成）就会发生。如果中断是被用户态程序中的指令所触发的（比如软件执行INT n生产的中断），还会增加一个额外的检查：门的DPL必须具有与CPL相同或更低的特权。这就防止了用户代码随意触发中断。如果这些检查失败，会产生一个一般保护异常（general-protection exception）。</li>
</ul>
</li>
</ul>
<h2 id="几个练习"><a href="#几个练习" class="headerlink" title="几个练习"></a>几个练习</h2><h3 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h3><blockquote>
<p>理解通过make生成执行文件的过程</p>
</blockquote>
<ul>
<li><p>操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)</p>
<ul>
<li>Makefile掌握不够的话根本看不懂在写什么</li>
</ul>
</li>
<li><p>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</p>
<ul>
<li>最后两个字节是0x55,0xAA</li>
</ul>
</li>
</ul>
<h3 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h3><blockquote>
<p>使用qemu执行并调试lab1中的软件</p>
</blockquote>
<ol>
<li><p>从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。</p>
<ul>
<li>直接将gdb连接到qemu, 断点也不用下直接停在第一条指令上</li>
<li>要注意的是此时<code>$pc($eip)</code>不是真实的地址, <code>(($cs&lt;&lt;4)+$eip)</code>才是</li>
</ul>
</li>
<li><p>在初始化位置0x7c00设置实地址断点,测试断点正常。</p>
<ul>
<li>此时在bootloader中, 设置为<code>file obj/bootblock.o</code>和<code>b *0x7c00</code>即可(别忘了<code>continue</code>要不然就是第一个问题了)</li>
</ul>
</li>
<li><p>从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#改写Makefile文件</span><br><span class="hljs-section">debug: <span class="hljs-variable">$(UCOREIMG)</span></span><br>    <span class="hljs-variable">$(V)</span><span class="hljs-variable">$(TERMINAL)</span> -e <span class="hljs-string">&quot;<span class="hljs-variable">$(QEMU)</span> -S -s -d in_asm -D <span class="hljs-variable">$(BINDIR)</span>/q.log -parallel stdio -hda <span class="hljs-variable">$&lt;</span> -serial null&quot;</span><br>    <span class="hljs-variable">$(V)</span>sleep 2<br>    <span class="hljs-variable">$(V)</span><span class="hljs-variable">$(TERMINAL)</span> -e <span class="hljs-string">&quot;gdb -q -tui -x tools/gdbinit&quot;</span><br></code></pre></td></tr></table></figure>

<p>在调用qemu时增加<code>-d in_asm -D q.log</code>参数，便可以将运行的汇编指令保存在q.log中。</p>
</li>
</ol>
<h3 id="练习三"><a href="#练习三" class="headerlink" title="练习三"></a>练习三</h3><blockquote>
<p>分析bootloader进入保护模式的过程.</p>
</blockquote>
<ul>
<li><p>为何开启A20，以及如何开启A20</p>
<ul>
<li><p>Intel早期的8086 CPU提供了20根地址线，但寄存器只有16位，所以使用<strong>段寄存器值 &lt;&lt; 4 + 段内偏移值</strong>的方法来访问到所有内存，但按这种方式来计算出的地址的最大值为1088KB，超过20根地址线所能表示的范围，会发生“回卷”（和整数溢出有点类似）。但下一代的基于Intel 80286 CPU的计算机系统提供了24根地址线，当CPU计算出的地址超过1MB时便<strong>不会发生回卷</strong>，而这就造成了<strong>向下不兼容</strong>。为了保持完全的向下兼容性，IBM在计算机系统上加个硬件逻辑来模仿早期的回绕特征，而这就是<strong>A20 Gate</strong>。</p>
</li>
<li><p>A20 Gate的方法是把A20地址线控制和键盘控制器的一个输出进行AND操作，这样来控制A20地址线的打开（使能）和关闭（屏蔽\禁止）。一开始时A20地址线控制是被屏蔽的（总为0），直到系统软件通过一定的IO操作去打开它。当A20 地址线控制禁止时，则程序就像在8086中运行，1MB以上的地址不可访问；保护模式下A20地址线控制必须打开。A20控制打开后，内存寻址将不会发生回卷。</p>
</li>
<li><p>在当前环境中，所用到的键盘控制器8042的IO端口只有0x60和0x64两个端口。8042通过这些端口给键盘控制器或键盘发送命令或读取状态。输出端口P2用于特定目的。位0（P20引脚）用于实现CPU复位操作，位1（P21引脚）用于控制A20信号线的开启与否。</p>
</li>
<li><p>有关概念:</p>
<p>8042有4个寄存器：</p>
<ul>
<li>1个8-bit长的Input buffer；Write-Only；</li>
<li>1个8-bit长的Output buffer； Read-Only；</li>
<li>1个8-bit长的Status Register；Read-Only；</li>
<li>1个8-bit长的Control Register；Read/Write。</li>
</ul>
<p>有两个端口地址：60h和64h，有关对它们的读写操作描述如下：</p>
<ul>
<li>读60h端口，读output buffer</li>
<li>写60h端口，写input buffer</li>
<li>读64h端口，读Status Register</li>
<li>操作Control Register，首先要向64h端口写一个命令（20h为读命令，60h为写命令），然后根据命令从60h端口读出Control Register的数据或者向60h端口写入Control Register的数据（64h端口还可以接受许多其它的命令）。<br>如果要<strong>写output</strong>, 则向64h写入命令0d1h, 向input buf写入control register中命令的参数</li>
</ul>
<p>Status Register的定义（要用bit 0和bit 1）：</p>
<table>
<thead>
<tr>
<th>bit</th>
<th>meaning</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>output register (60h) 中有数据</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>input register (60h/64h) 有数据</strong></td>
</tr>
<tr>
<td>2</td>
<td>系统标志（上电复位后被置为0）</td>
</tr>
<tr>
<td>3</td>
<td>data in input register is command (1) or data (0)</td>
</tr>
<tr>
<td>4-7</td>
<td>(Nothing special)</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/11/15/o2X7OPRbzxvVeUS.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li><p>代码中的流程:</p>
<p><strong>读0x64端口(读Status Register), 等待第二位(标志input buffer是否为空)等于0<br>向64h发送0d1h命令(作用是写output port,即一个键盘控制器命令),<br>然后等待input buf为空时向0x60h写入control register的参数(即要输出在output port上的值)</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs asm">    # Enable A20:<br>    #  For backwards compatibility with the earliest PCs, physical<br>    #  address line 20 is tied low, so that addresses higher than<br>    #  1MB wrap around to zero by default. This code undoes this.<br>seta20.1:<br>    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).<br>    testb $0x2, %al<br>    jnz seta20.1<br><br>    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64<br>    outb %al, $0x64                                 # 0xd1 means: write data to 8042&#x27;s P2 port<br><br>seta20.2:<br>    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).<br>    testb $0x2, %al<br>    jnz seta20.2<br><br>    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60<br>    outb %al, $0x60                                 # 0xdf = 11011111, means set P2&#x27;s A20 bit(the 1 bit) to 1<br></code></pre></td></tr></table></figure>

<ul>
<li>如何初始化GDT表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asm">lgdt gdtdesc<br># Bootstrap GDT<br>.p2align 2                                          # force 4 byte alignment<br>gdt:<br>    SEG_NULLASM                                     # null seg<br>    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel<br>    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel<br><br>gdtdesc:<br>    .word 0x17                                      # sizeof(gdt) - 1<br>    .long gdt                                       # address gdt<br>    <br># asm.h<br>#define STA_X       0x8     // Executable segment<br>#define STA_W       0x2     // Writeable (non-executable segments)<br>#define STA_R       0x2     // Readable (executable segments)<br></code></pre></td></tr></table></figure>

<ul>
<li>进入保护模式：通过将cr0寄存器PE位置1便开启了保护模式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">movl %cr0, %eax<br>orl $CR0_PE_ON, %eax	# orl: 或运算<br>movl %eax, %cr0<br></code></pre></td></tr></table></figure>

<ul>
<li>通过长跳转更新cs的基地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">ljmp $PROT_MODE_CSEG, $protcseg<br>.code32<br>protcseg:<br></code></pre></td></tr></table></figure>

<ul>
<li>设置段寄存器，并建立堆栈</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">movw $PROT_MODE_DSEG, %ax<br>movw %ax, %ds<br>movw %ax, %es<br>movw %ax, %fs<br>movw %ax, %gs<br>movw %ax, %ss<br>movl $0x0, %ebp<br>movl $start, %esp<br></code></pre></td></tr></table></figure>

<ul>
<li>转到保护模式完成，进入boot主方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">call bootmain<br></code></pre></td></tr></table></figure>

<ul>
<li>Long jump, use 0xfebc for the CS register and 0x12345678 for the EIP register:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">ljmp $0xfebc, $0x12345678<br></code></pre></td></tr></table></figure>

<h3 id="练习四"><a href="#练习四" class="headerlink" title="练习四"></a>练习四</h3><blockquote>
<p>分析bootloader加载ELF格式的OS的过程。</p>
</blockquote>
<ul>
<li>IDE: Integrated Drive Electronics，它的本意是指把控制器与盘体集成在一起的硬盘驱动器，IDE是表示硬盘的传输接口。</li>
</ul>
<p>bootloader让CPU进入保护模式后，下一步的工作就是从硬盘上加载并运行OS。考虑到实现的简单性，bootloader的访问硬盘都是LBA模式的PIO（Program IO）方式，即所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成。</p>
<p>一般主板有2个IDE通道，每个通道可以接2个IDE硬盘。访问第一个硬盘的扇区可设置IO地址寄存器0x1f0-0x1f7实现的，具体参数见下表。一般第一个IDE通道通过访问IO地址0x1f0-0x1f7来实现，第二个IDE通道通过访问0x170-0x17f实现。每个通道的主从盘的选择通过第6个IO偏移地址寄存器来设置。</p>
<table>
<thead>
<tr>
<th>IO地址</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>0x1f0</td>
<td>读数据，当0x1f7不为忙状态时，可以读。</td>
</tr>
<tr>
<td>0x1f2</td>
<td>要读写的扇区数，每次读写前，你需要表明你要读写几个扇区。最小是1个扇区</td>
</tr>
<tr>
<td>0x1f3</td>
<td>如果是LBA模式，就是LBA参数的0-7位</td>
</tr>
<tr>
<td>0x1f4</td>
<td>如果是LBA模式，就是LBA参数的8-15位</td>
</tr>
<tr>
<td>0x1f5</td>
<td>如果是LBA模式，就是LBA参数的16-23位</td>
</tr>
<tr>
<td>0x1f6</td>
<td>第0~3位：如果是LBA模式就是24-27位 第4位：为0主盘；为1从盘</td>
</tr>
<tr>
<td>0x1f7</td>
<td>状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口读数据</td>
</tr>
</tbody></table>
<p>当前 硬盘数据是储存到硬盘扇区中，一个扇区大小为512字节。读一个扇区的流程（可参看boot/bootmain.c中的readsect函数实现）大致如下：</p>
<ol>
<li>等待磁盘准备好</li>
<li>发出读取扇区的命令</li>
<li>等待磁盘准备好</li>
<li>把磁盘扇区数据读到指定内存</li>
</ol>
<p><strong>分析bootloader加载ELF格式的OS的过程。</strong> </p>
<p>首先看readsect函数，<br><code>readsect</code>从设备的第secno扇区读取数据到dst位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">readsect</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *dst, <span class="hljs-keyword">uint32_t</span> secno)</span> </span>&#123;<br>    <span class="hljs-built_in">waitdisk</span>();<br><br>    <span class="hljs-built_in">outb</span>(<span class="hljs-number">0x1F2</span>, <span class="hljs-number">1</span>);                         <span class="hljs-comment">// 设置读取扇区的数目为1</span><br>    <span class="hljs-built_in">outb</span>(<span class="hljs-number">0x1F3</span>, secno &amp; <span class="hljs-number">0xFF</span>);<br>    <span class="hljs-built_in">outb</span>(<span class="hljs-number">0x1F4</span>, (secno &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>);<br>    <span class="hljs-built_in">outb</span>(<span class="hljs-number">0x1F5</span>, (secno &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFF</span>);<br>    <span class="hljs-built_in">outb</span>(<span class="hljs-number">0x1F6</span>, ((secno &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xF</span>) | <span class="hljs-number">0xE0</span>);<br>        <span class="hljs-comment">// 上面四条指令联合制定了扇区号</span><br>        <span class="hljs-comment">// 在这4个字节线联合构成的32位参数中</span><br>        <span class="hljs-comment">//   29-31位强制设为1</span><br>        <span class="hljs-comment">//   28位(=0)表示访问&quot;Disk 0&quot;</span><br>        <span class="hljs-comment">//   0-27位是28位的偏移量</span><br>    <span class="hljs-built_in">outb</span>(<span class="hljs-number">0x1F7</span>, <span class="hljs-number">0x20</span>);                      <span class="hljs-comment">// 0x20命令，读取扇区</span><br><br>    <span class="hljs-built_in">waitdisk</span>();<br><br>    <span class="hljs-built_in">insl</span>(<span class="hljs-number">0x1F0</span>, dst, SECTSIZE / <span class="hljs-number">4</span>);         <span class="hljs-comment">// 读取到dst位置，</span><br>                                            <span class="hljs-comment">// 幻数4因为这里以DW为单位</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>readseg简单包装了readsect，可以从设备读取任意长度的内容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">readseg</span><span class="hljs-params">(<span class="hljs-keyword">uintptr_t</span> va, <span class="hljs-keyword">uint32_t</span> count, <span class="hljs-keyword">uint32_t</span> offset)</span> </span>&#123;<br>    <span class="hljs-keyword">uintptr_t</span> end_va = va + count;<br><br>    va -= offset % SECTSIZE;<br><br>    <span class="hljs-keyword">uint32_t</span> secno = (offset / SECTSIZE) + <span class="hljs-number">1</span>; <br>    <span class="hljs-comment">// 加1因为0扇区被引导占用</span><br>    <span class="hljs-comment">// ELF文件从1扇区开始</span><br><br>    <span class="hljs-keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;<br>        <span class="hljs-built_in">readsect</span>((<span class="hljs-keyword">void</span> *)va, secno);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在bootmain函数中，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">bootmain</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// 首先读取ELF的头部</span><br>    <span class="hljs-built_in">readseg</span>((<span class="hljs-keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 通过储存在头部的幻数判断是否是合法的ELF文件</span><br>    <span class="hljs-keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;<br>        <span class="hljs-keyword">goto</span> bad;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> *<span class="hljs-title">ph</span>, *<span class="hljs-title">eph</span>;</span><br><br>    <span class="hljs-comment">// ELF头部有描述ELF文件应加载到内存什么位置的描述表，</span><br>    <span class="hljs-comment">// 先将描述表的头地址存在ph</span><br>    ph = (struct proghdr *)((<span class="hljs-keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);<br>    eph = ph + ELFHDR-&gt;e_phnum;<br><br>    <span class="hljs-comment">// 按照描述表将ELF文件中数据载入内存</span><br>    <span class="hljs-keyword">for</span> (; ph &lt; eph; ph ++) &#123;<br>        <span class="hljs-built_in">readseg</span>(ph-&gt;p_va &amp; <span class="hljs-number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);<br>    &#125;<br>    <span class="hljs-comment">// ELF文件0x1000位置后面的0xd1ec比特被载入内存0x00100000</span><br>    <span class="hljs-comment">// ELF文件0xf000位置后面的0x1d20比特被载入内存0x0010e000</span><br><br>    <span class="hljs-comment">// 根据ELF头部储存的入口信息，找到内核的入口</span><br>    ((<span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*)(<span class="hljs-keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="hljs-number">0xFFFFFF</span>))();<br><br>bad:<br>    <span class="hljs-built_in">outw</span>(<span class="hljs-number">0x8A00</span>, <span class="hljs-number">0x8A00</span>);<br>    <span class="hljs-built_in">outw</span>(<span class="hljs-number">0x8A00</span>, <span class="hljs-number">0x8E00</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="练习五"><a href="#练习五" class="headerlink" title="练习五"></a>练习五</h3><blockquote>
<p>实现函数调用堆栈跟踪函数</p>
</blockquote>
<p>ss:ebp指向的堆栈位置储存着caller的ebp，以此为线索可以得到所有使用堆栈的函数ebp。<br>ss:ebp+4指向caller调用时的eip，ss:ebp+8等是（可能的）参数。</p>
<p>输出中，堆栈最深一层为</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">ebp:<span class="hljs-number">0</span>x00007bf8 eip:<span class="hljs-number">0x00007d68</span> args:<span class="hljs-number">0x00000000</span> <span class="hljs-number">0x00000000</span> <span class="hljs-number">0x00000000</span> <span class="hljs-number">0</span>x00007c4f<br>    &lt;unknow&gt;: -- <span class="hljs-number">0x00007d67</span> --<br></code></pre></td></tr></table></figure>

<p>其对应的是第一个使用堆栈的函数，bootmain.c中的bootmain。<br>bootloader设置的堆栈从0x7c00开始，使用”call bootmain”转入bootmain函数。<br>call指令压栈，所以bootmain中ebp为0x7bf8。</p>
<p><strong>print_stackframe:</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">uint32_t</span> eip, ebp;<br>eip = read_eip();<br>ebp = read_ebp();<br><span class="hljs-keyword">int</span> i, j;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; ebp != <span class="hljs-number">0</span> &amp;&amp; i &lt; STACKFRAME_DEPTH; i++)<br>&#123;<br>    cprintf(<span class="hljs-string">&quot;ebp:0x%08x eip:0x%08x args:&quot;</span>, ebp, eip);<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++)<br>    &#123;<br>        cprintf(<span class="hljs-string">&quot;0x%08x &quot;</span>, ((<span class="hljs-keyword">uint32_t</span> *)ebp + <span class="hljs-number">2</span>)[j]);<br>    &#125;<br>    cprintf(<span class="hljs-string">&quot;\n&quot;</span>);<br>    print_debuginfo(eip - <span class="hljs-number">1</span>);<br>    eip = ((<span class="hljs-keyword">uint32_t</span> *)ebp)[<span class="hljs-number">1</span>];<br>    ebp = ((<span class="hljs-keyword">uint32_t</span> *)ebp)[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要注意的问题:</p>
<ul>
<li><p>gdb命令通过文件加载debuginfo, 包括源代码和函数位置, 一般我们直接使用gdb <em>filepath</em> -q直接进入调试界面, 而本实验先启动qemu(使用.img镜像文件), 然后gdb通过remote连接到qemu中, Makefile中指定的gdbinit文件可以指定一些初始命令.</p>
<p>这样, gdb没有任何debuginfo, 全靠远程端口给出信息, 所以我们可以在init文件中添加file命令加载符号信息</p>
</li>
</ul>
<h3 id="练习六"><a href="#练习六" class="headerlink" title="练习六"></a>练习六</h3><blockquote>
<p>完善中断初始化和处理</p>
</blockquote>
<ul>
<li><p>中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？</p>
<ul>
<li><p>一个表项的结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Gate descriptors for interrupts and traps */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gatedesc</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> gd_off_15_0 : <span class="hljs-number">16</span>;        <span class="hljs-comment">// low 16 bits of offset in segment</span><br>    <span class="hljs-keyword">unsigned</span> gd_ss : <span class="hljs-number">16</span>;            <span class="hljs-comment">// segment selector</span><br>    <span class="hljs-keyword">unsigned</span> gd_args : <span class="hljs-number">5</span>;            <span class="hljs-comment">// # args, 0 for interrupt/trap gates</span><br>    <span class="hljs-keyword">unsigned</span> gd_rsv1 : <span class="hljs-number">3</span>;            <span class="hljs-comment">// reserved(should be zero I guess)</span><br>    <span class="hljs-keyword">unsigned</span> gd_type : <span class="hljs-number">4</span>;            <span class="hljs-comment">// type(STS_&#123;TG,IG32,TG32&#125;)</span><br>    <span class="hljs-keyword">unsigned</span> gd_s : <span class="hljs-number">1</span>;                <span class="hljs-comment">// must be 0 (system)</span><br>    <span class="hljs-keyword">unsigned</span> gd_dpl : <span class="hljs-number">2</span>;            <span class="hljs-comment">// descriptor(meaning new) privilege level</span><br>    <span class="hljs-keyword">unsigned</span> gd_p : <span class="hljs-number">1</span>;                <span class="hljs-comment">// Present</span><br>    <span class="hljs-keyword">unsigned</span> gd_off_31_16 : <span class="hljs-number">16</span>;        <span class="hljs-comment">// high bits of offset in segment</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>该表项的大小为<code>16+16+5+3+4+1+2+1+16 == 8*8</code>bit，即<strong>8字节</strong>。</p>
</li>
<li><p>根据IDT表项的结构，我们可以得知，IDT表项的第二个成员<code>gd_ss</code>为段选择子，第一个成员<code>gd_off_15_0</code>和最后一个成员<code>gd_off_31_16</code>共同组成一个段内偏移地址。根据段选择子和段内偏移地址就可以得出中断处理程序的地址。</p>
</li>
</ul>
</li>
<li><p>编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init.</p>
<ul>
<li><p>具体实现如下，详细信息以注释的形式写入代码中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">idt_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>  <span class="hljs-comment">// __vectors定义于vector.S中</span><br>  <span class="hljs-keyword">extern</span> <span class="hljs-keyword">uintptr_t</span> __vectors[];<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(idt) / <span class="hljs-keyword">sizeof</span>(struct gatedesc); i ++)<br>      <span class="hljs-comment">// 目标idt项为idt[i]</span><br>      <span class="hljs-comment">// 该idt项为内核代码，所以使用GD_KTEXT段选择子</span><br>      <span class="hljs-comment">// 中断处理程序的入口地址存放于__vectors[i]</span><br>      <span class="hljs-comment">// 特权级为DPL_KERNEL</span><br>      SETGATE(idt[i], <span class="hljs-number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);<br>  <span class="hljs-comment">// 设置从用户态转为内核态的中断的特权级为DPL_USER</span><br>  <span class="hljs-comment">// 好像就是int 0x80, 不过我没有在任何地方看到说明, 尝试自己写这一段代码花了好多无谓的时间, 诶</span><br>  <span class="hljs-comment">// T_SWITCH_TOK也不知道是什么东西</span><br>  SETGATE(idt[T_SWITCH_TOK], <span class="hljs-number">0</span>, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);<br>  <span class="hljs-comment">// 加载该IDT</span><br>  lidt(&amp;idt_pd);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”。</p>
<ul>
<li><p>这个实现还是比较简单的，注释都说清楚了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* trap_dispatch - dispatch based on what type of trap occurred */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">trap_dispatch</span><span class="hljs-params">(struct trapframe *tf)</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> c;<br>    <span class="hljs-keyword">switch</span> (tf-&gt;tf_trapno) &#123;<br>    <span class="hljs-keyword">case</span> IRQ_OFFSET + IRQ_TIMER:<br>        <span class="hljs-comment">// 全局变量ticks定义于kern/driver/clock.c</span><br>        ticks++;<br>        <span class="hljs-keyword">if</span>(ticks % TICK_NUM == <span class="hljs-number">0</span>)<br>            print_ticks();<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-comment">// .........</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="拓展练习"><a href="#拓展练习" class="headerlink" title="拓展练习"></a>拓展练习</h3><ul>
<li>moocos的密码是空格</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/CS/">CS</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/OS/">OS</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021-10/Learning-complier/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">编译原理complier</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021-09/Learning-Specialty-in-Rust/">
                        <span class="hidden-mobile">Specialty in Rust</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"312db7ebbc085de5d28d","clientSecret":"85ea3cefd13c73a6d85c1813adfde4f1550bfbda","repo":"yogdzewa.github.io","owner":"yogdzewa","admin":["yogdzewa"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":true,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '9fc4bed47dda41453c8f2419b730568d'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" lazyload class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
    <!-- cnzz Analytics Icon -->
    <span id="cnzz_stat_icon_1280126539" style="display: none"></span>
  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.10.1/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  

  

  

  

  

  
    <!-- cnzz Analytics -->
    <script defer src="//s4.cnzz.com/z_stat.php?id=1280126539&show=pic"
            type="text/javascript"></script>
  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
