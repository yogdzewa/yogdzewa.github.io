

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yogdzewa">
  <meta name="keywords" content="">
  
    <meta name="description" content="还是努力一把">
<meta property="og:type" content="article">
<meta property="og:title" content="Tsinghua操作系统课程">
<meta property="og:url" content="https://yogdzewa.github.io/2021-10/Learning-ucore/index.html">
<meta property="og:site_name" content="Yogdzewa">
<meta property="og:description" content="还是努力一把">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/11/15/gqzhf1o9HjFSRZd.png">
<meta property="og:image" content="https://i.loli.net/2021/11/15/5smFgYn7Bxhq3Ke.png">
<meta property="og:image" content="https://i.loli.net/2021/11/15/v6fC2e43WESLcaU.png">
<meta property="og:image" content="https://i.loli.net/2021/11/15/2voBNa4eHCJYpDS.png">
<meta property="og:image" content="https://i.loli.net/2021/11/15/2pZPMgihVI6QSrR.png">
<meta property="og:image" content="https://i.loli.net/2021/11/15/JX7IuMO4QodfVFK.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/ucore/IxTJPGOZWVjz2BD-16373800575412.png">
<meta property="og:image" content="https://i.loli.net/2021/11/15/t1iNrJbCeBzASFf.png">
<meta property="og:image" content="https://i.loli.net/2021/11/16/JGd27NnTwFDipOe.jpg">
<meta property="og:image" content="https://i.loli.net/2021/11/16/5HxAC9w4XSiasbK.png">
<meta property="og:image" content="https://i.loli.net/2021/11/16/qbyzSN56w9eDHKX.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/20/FOG4zJsyutojfen.png">
<meta property="og:image" content="https://i.loli.net/2021/11/16/hGLAjlTYVSWpk67.png">
<meta property="og:image" content="https://i.loli.net/2021/11/16/fqGtF4SHxWPCJhg.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/ucore/image-20211221160818556.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/ucore/image-20211221161024855.png">
<meta property="og:image" content="https://i.loli.net/2021/11/15/o2X7OPRbzxvVeUS.png">
<meta property="og:image" content="https://i.loli.net/2021/11/20/n8cShiWkulDqzpP.png">
<meta property="og:image" content="https://i.loli.net/2021/11/20/Uvnt9ZJfP32FMbr.png">
<meta property="og:image" content="https://i.loli.net/2021/11/23/YQoyfDqFVTZPs6C.png">
<meta property="og:image" content="https://i.loli.net/2021/11/23/9B45OFTQWedfhw1.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/ucore/image-20211224212029857.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/ucore/image-20211224232536016.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/ucore/image-20211228201516840.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/ucore/up.gif">
<meta property="og:image" content="https://yogdzewa.github.io/image/ucore/down.gif">
<meta property="og:image" content="https://yogdzewa.github.io/image/ucore/image001.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/ucore/image-20220105195357089.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/ucore/image-20220105200433737.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/ucore/image-20220105200753016.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/ucore/image-20220107165956521.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/ucore/Calls-file_open.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/ucore/image-20220108132923299.png">
<meta property="article:published_time" content="2021-10-01T02:00:00.000Z">
<meta property="article:modified_time" content="2022-05-08T02:51:33.823Z">
<meta property="article:author" content="Yogdzewa">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://i.loli.net/2021/11/15/gqzhf1o9HjFSRZd.png">
  
  
  <title>Tsinghua操作系统课程 - Yogdzewa</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/obsidian.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yogdzewa.github.io","root":"/","version":"1.8.13","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>(￣.￣)</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/image/edit2.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Tsinghua操作系统课程">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-10-01 10:00" pubdate>
        2021年10月1日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      133k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      1667 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Tsinghua操作系统课程</h1>
            
              <p class="note note-info">
                
                  不可视境界线最后变动于：2022年5月8日 上午
                
              </p>
            
            <div class="markdown-body">
              <h1 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="1-BIOS启动顺序"><a href="#1-BIOS启动顺序" class="headerlink" title="1.BIOS启动顺序"></a>1.BIOS启动顺序</h3><ul>
<li>CPU加电后代码段寄存器初始化为<strong>CS = F000H, EIP = 0000FFF0H</strong>, 然后再计算 Base+IP = FFFF0000H + 0000FFF0H = FFFFFFF0H 得到BIOS的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/EPROM">EPROM</a>(Erasable Programmable Read Only Memory)所在地, 这个地址的第一条指令是一个<strong>长跳转指令</strong>(这样CS和EIP都会更新)到BIOS代码中执行</li>
<li>BIOS做完计算机硬件自检和初始化后，会选择一个启动设备（例如软盘、硬盘、光盘等），并且读取该设备的第一扇区(即主引导扇区或启动扇区)到内存一个特定的地址0x7c00处，然后CPU控制权会转移到那个地址继续执行。至此BIOS的初始化工作做完了，进一步的工作交给了ucore的<strong>bootloader</strong>。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_1_bios_booting.html#%E8%A1%A5%E5%85%85%E4%BF%A1%E6%81%AF">附</a>:</p>
<ul>
<li>在16位的8086 CPU时代，内存限制在1MB范围内，且BIOS的代码固化在EPROM中。在基于Intel的8086 CPU的PC机中的EPROM被编址在1ＭB内存地址空间的最高64KB中。PC加电后，CS寄存器初始化为<strong>0xF000</strong>，IP寄存器初始化为<strong>0xFFF0</strong>, CS:IP=0xF000:0XFFF0（Segment:Offset 表示）=<strong>0xFFFF0</strong>(Linear表示)</li>
<li>默认将执行BIOS ROM编址在32位内存地址空间的最高端，即位于4GB地址的最后一个64KB内。在PC系统开机复位时，CPU进入实模式，并将CS寄存器设置成0xF000，将它的<strong>shadow register</strong>的<strong>Base</strong>值初始化设置为0xFFFF0000，EIP寄存器初始化设置为0x0000FFF0。所以机器执行的第一条指令的物理地址是<strong>0xFFFFFFF0</strong>。80386的BIOS代码也要和以前8086的BIOS代码兼容，故地址0xFFFFFFF0处的指令还是一条长跳转指令<code>jmp F000:E05B</code>。注意，这个长跳转指令会触发更新CS寄存器和它的shadow register，即执行<code>jmp F000 : E05B</code>后，CS将被更新成0xF000。表面上看CS其实没有变化，但CS的shadow register被更新为另外一个值了，它的Base域被更新成0x000F0000，此时形成的物理地址为Base+EIP=0x000FE05B，这就是CPU执行的第二条指令的地址。此时这条指令的地址已经是1M<strong>以内</strong>了，且此地址不再位于BIOS ROM中，而是位于RAM空间中。由于Intel设计了一种映射机制，将内存高端的BIOS ROM映射到1MB以内的RAM空间里，并且可以使这一段被映射的RAM空间具有与ROM类似的只读属性。所以PC机启动时将开启这种映射机制，让4GB地址空间的最高一个64KB的内容等同于1MB地址空间的最高一个64K的内容，从而使得执行了长跳转指令后，其实是回到了早期的8086 CPU初始化控制流，保证了向下兼容</li>
</ul>
<p>例图:</p>
<img src="https://i.loli.net/2021/11/15/gqzhf1o9HjFSRZd.png" srcset="/img/loading.gif" lazyload alt="image-20211110102048633"  />

<img src="https://i.loli.net/2021/11/15/5smFgYn7Bxhq3Ke.png" srcset="/img/loading.gif" lazyload alt="image-20211110101314467" style="zoom:67%;" />

<h3 id="2-实模式"><a href="#2-实模式" class="headerlink" title="2.实模式"></a>2.实模式</h3><p>参考资料:《Intel 80386 Reference Programmers Manual-i386》, 基本是这个的翻译</p>
<p>在<strong>bootloader</strong>接手BIOS的工作后，当前的PC系统处于实模式（16位模式）运行状态，在这种状态下软件可访问的物理内存空间不能超过1MB，且无法发挥Intel 80386以上级别的32位CPU的4GB内存管理能力。</p>
<p>实模式将整个物理内存看成分段的区域，程序代码和数据位于不同区域，操作系统和用户程序并没有区别对待，<strong>而且每一个指针都是指向实际的物理地址</strong>。这样，用户程序的一个指针如果指向了操作系统区域或其他用户程序区域，并修改了内容，那么其后果就很可能是灾难性的。通过修改A20地址线可以完成从实模式到保护模式的转换。有关A20的进一步信息可参考“<a target="_blank" rel="noopener" href="http://hengch.blog.163.com/blog/static/107800672009013104623747/">关于A20 Gate</a>”。z</p>
<img src="https://i.loli.net/2021/11/15/v6fC2e43WESLcaU.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 67%;" />

<ul>
<li><strong>地址<code>0-0x9ffff</code>的640KB内存是DRAM，即插在主板上的内存条。</strong><br>顶部<code>0xf0000-0xfffff</code>的64KB内存是ROM，存放BIOS代码。</li>
<li>EPROM是通过地址来访问的, 80386将其映射到内存的顶端, 其他的一些外设也同样通过映射到地址空间来访问它们</li>
</ul>
<h3 id="3-分段机制-保护模式"><a href="#3-分段机制-保护模式" class="headerlink" title="3.分段机制/保护模式"></a>3.分段机制/保护模式</h3><h4 id="a-保护模式"><a href="#a-保护模式" class="headerlink" title="a.保护模式"></a>a.保护模式</h4><ul>
<li><p>只有在保护模式下，80386的<strong>全部32根地址线有效</strong>，可寻址高达4G字节的线性地址空间和物理地址空间，可访问64TB（有2^14^个段，每个段最大空间为2^32^字节）的逻辑地址空间，可采用分段存储管理机制和分页存储管理机制。这不仅为存储共享和保护提供了硬件支持，而且为实现虚拟存储提供了硬件支持。通过提供4个特权级和完善的特权检查机制，既能实现资源共享又能保证代码数据的安全及任务的隔离。</p>
<blockquote>
<p>【补充】保护模式下，有两个段表：GDT（Global Descriptor Table）和LDT（Local Descriptor Table），每一张段表可以包含8192 (2^13)个描述符[1]，因而最多可以同时存在2 * 2^13 = 2^14^个段。虽然保护模式下可以有这么多段，逻辑地址空间看起来很大，但实际上段并不能扩展物理地址空间，很大程度上各个段的地址空间是<strong>相互重叠</strong>的。目前所谓的64TB（2^(14+32)^=2^46^）逻辑地址空间是一个理论值，没有实际意义。在32位保护模式下，真正的物理空间仍然只有2^32字节那么大。注：在ucore lab中只用到了GDT，没有用LDT。</p>
<p>Reference: [1] 3.5.1 Segment Descriptor Tables, Intel® 64 and IA-32 Architectures Software Developer’s Manual</p>
</blockquote>
</li>
</ul>
<h4 id="b-分段机制"><a href="#b-分段机制" class="headerlink" title="b.分段机制"></a>b.分段机制</h4><blockquote>
<p>b,c,d顺序按照<strong>35</strong>年前的i386文档, 图片来自IA-32文档</p>
</blockquote>
<ul>
<li><p>将内存划分成以起始地址和长度限制这两个二维参数表示的内存块，这些内存块就称之为段（Segment）。编译器把源程序编译成执行程序时用到的代码段、数据段、堆和栈等概念在这里可以与段联系起来，二者在含义上是一致的</p>
</li>
<li><p>转换逻辑地址（Logical Address,应用程序员看到的地址）到物理地址（Physical Address, 实际的物理内存地址）分以下两步：</p>
<p>[1] 分段地址转换：<img src="https://i.loli.net/2021/11/15/2voBNa4eHCJYpDS.png" srcset="/img/loading.gif" lazyload alt="image-20211110224722534" style="zoom:67%;" /></p>
<p>[2] 分页地址转换，这一步中把线性地址转换为物理地址。（注意：这一步是可选的，由操作系统决定是否需要。在后续试验中会涉及。</p>
</li>
</ul>
<h4 id="c-Segment-Selector"><a href="#c-Segment-Selector" class="headerlink" title="c.Segment Selector"></a>c.Segment Selector</h4><ul>
<li>A segment selector is a 16-bit identifier for a segment (see Figure 3-6). It does not point directly to the segment,<br>but instead points to the segment descriptor that defines the segment. </li>
</ul>
<img src="https://i.loli.net/2021/11/15/2pZPMgihVI6QSrR.png" srcset="/img/loading.gif" lazyload alt="image-20211110233814790" style="zoom:67%;" />

<h4 id="d-Segment-register"><a href="#d-Segment-register" class="headerlink" title="d.Segment register"></a>d.Segment register</h4><ul>
<li><p>For virtually any kind of program execution to take place, at least the code-segment (CS), data-segment (DS), and stack-segment (SS) registers must be loaded with valid segment selectors.</p>
</li>
<li><p>three additional data-segment registers (ES, FS, and GS) are optional</p>
<img src="https://i.loli.net/2021/11/15/JX7IuMO4QodfVFK.png" srcset="/img/loading.gif" lazyload alt="image-20211110232108110" style="zoom: 67%;" /></li>
<li><p>For a program to access a segment, the segment selector for the segment <strong>must have been loaded in one of the</strong><br><strong>segment registers</strong>. So, although a system can define thousands of segments, <strong>only 6 can be available</strong> for immediate<br>use. </p>
</li>
<li><p><strong>shadow register(“hidden” part):</strong></p>
<p>When a segment selector is loaded into the visible part, the processor also loads the hidden part from the segment descriptor pointed to by the segment selector</p>
</li>
</ul>
<h4 id="e-Segment-Descriptor"><a href="#e-Segment-Descriptor" class="headerlink" title="e.Segment Descriptor"></a>e.Segment Descriptor</h4><blockquote>
<p><strong>来自IA-32文档 P2902/3-10 Vol. 3A</strong> </p>
</blockquote>
<img src="..\..\image\ucore\IxTJPGOZWVjz2BD-16373800575412.png" srcset="/img/loading.gif" lazyload alt="image-20211110230124631.png" style="zoom:80%;" />

<h4 id="f-Global-Descriptor-Tables"><a href="#f-Global-Descriptor-Tables" class="headerlink" title="f.Global Descriptor Tables"></a>f.Global Descriptor Tables</h4><blockquote>
<p><strong>(IA-32 P2906/ 3-14 Vol. 3A)</strong>:</p>
</blockquote>
<p>全局描述符表的是一个保存多个段描述符的“数组”，其起始地址保存在全局描述符表寄存器GDTR中。GDTR长48位，其中高32位为基地址，低16位为段界限。由于GDT 不能有GDT本身之内的描述符进行描述定义，所以处理器采用GDTR为GDT这一特殊的系统段。注意，全局描述符表中第一个段描述符设定为空段描述符。GDTR中的段界限以字节为单位。对于含有N个描述符的描述符表的段界限通常可设为8*N-1。</p>
<img src="https://i.loli.net/2021/11/15/t1iNrJbCeBzASFf.png" srcset="/img/loading.gif" lazyload alt="image-20211110230336834" style="zoom:67%;" />

<h4 id="g-Privilege-Level"><a href="#g-Privilege-Level" class="headerlink" title="g.Privilege Level"></a>g.Privilege Level</h4><ul>
<li>Current privilege level (<strong>CPL</strong>) — The CPL is the privilege level of the currently executing program or task. <u>It</u><br><u>is stored in bits 0 and 1 of the CS and SS segment registers.</u> Normally, the CPL is equal to the privilege level of<br>the code segment from which instructions are being fetched. The processor changes the CPL when program<br>control is transferred to a code segment with a different privilege level. </li>
</ul>
<blockquote>
<p>The CPL is treated slightly differently when accessing <strong>conforming code segments</strong>. Conforming code segments can be accessed from any privilege level that is equal to or numerically greater (less privileged) than the DPL of the conforming code segment. Also, the CPL is not changed when the processor accesses a conforming code segment that has a different privilege level than the CPL.</p>
</blockquote>
<ul>
<li>Descriptor privilege level (<strong>DPL</strong>) — The DPL is the privilege level of a segment or gate. It is stored in the DPL<br>field of the segment or gate descriptor for the segment or gate. </li>
<li>Requested privilege level (<strong>RPL</strong>) — The RPL is an override privilege level that is assigned to segment<br>selectors. It is stored in bits 0 and 1 of the segment selector. The RPL can be used to ensure that privileged code<br>does not access a segment on behalf of an application program unless the program itself has access privileges for<br>that segment. See Section 5.10.4, “Checking Caller Access Privileges (ARPL Instruction),” for a detailed description of<br>the purpose and typical use of the RPL.</li>
</ul>
<p><strong>PRIVILEGE CHECK:</strong> </p>
<p><img src="https://i.loli.net/2021/11/16/JGd27NnTwFDipOe.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="4-中断与异常"><a href="#4-中断与异常" class="headerlink" title="4.中断与异常"></a>4.中断与异常</h3><ul>
<li>中断机制给操作系统提供了处理意外情况的能力，同时它也是实现进程/线程抢占式调度的一个重要基石。但中断的引入导致了对操作系统的理解更加困难。</li>
<li>在操作系统中，有三种特殊的中断事件。<ul>
<li>由CPU<em>外部设备引起的</em> 外部事件如I/O中断、时钟中断、控制台中断等是异步产生的（即产生的时刻不确定），与CPU的执行无关，我们称之为<strong>异步中断</strong>(asynchronous interrupt)也称外部中断,简称<strong>中断</strong>(interrupt)。</li>
<li>而把在CPU执行指令期间检测到<em>不正常的或非法</em> 的条件(如除零错、地址访问越界)所引起的内部事件称作<strong>同步中断</strong>(synchronous interrupt)，也称内部中断，简称**异常(**exception)。</li>
<li>把在程序中使用<em>请求系统服务</em> 的系统调用而引发的事件，称作<strong>陷入中断</strong>(trap interrupt)，也称<strong>软中断</strong>(soft interrupt)，系统调用(system call)简称<strong>trap</strong>。在后续试验中会进一步讲解系统调用。</li>
</ul>
</li>
</ul>
<img src="https://i.loli.net/2021/11/16/5HxAC9w4XSiasbK.png" srcset="/img/loading.gif" lazyload  style="zoom: 60%;" />

<ul>
<li><p><strong>Interrupt Descriptor Table</strong>:同GDT一样，IDT是一个8字节的描述符数组，但IDT的第一项可以包含一个描述符。CPU把中断（异常）号乘以8做为IDT的索引。IDT可以位于内存的任意位置，CPU通过IDT寄存器（IDTR）的内容来寻址IDT的起始地址。指令LIDT和SIDT用来操作IDTR。两条指令都有一个显示的操作数：一个6字节表示的内存地址(包含线性地址基址和界限)。</p>
<p>在保护模式下，最多会存在256个Interrupt/Exception Vectors。</p>
<p>范围[0，31]内的32个向量被异常Exception和NMI使用，但当前并非所有这32个向量都已经被使用，有几个当前没有被使用的，请不要擅自使用它们，它们被保留，以备将来可能增加新的Exception。</p>
<p>范围[32，255]内的向量被保留给用户定义的Interrupts。Intel没有定义，也没有保留这些Interrupts。用户可以将它们用作外部I/O设备中断（8259A IRQ），或者系统调用（System Call 、Software Interrupts）等。</p>
</li>
<li><p><strong>IDT gate descriptors</strong>: Interrupts/Exceptions应该使用Interrupt Gate和Trap Gate，它们之间的唯一区别就是：当调用Interrupt Gate时，Interrupt会被CPU自动禁止；而调用Trap Gate时，CPU则不会去禁止或打开中断，而是保留它原来的样子。</p>
<blockquote>
<p>【补充】所谓“自动禁止”，指的是CPU跳转到interrupt gate里的地址时，在将EFLAGS保存到栈上之后，清除EFLAGS里的IF位，以避免重复触发中断。在中断处理例程里，操作系统可以将EFLAGS里的IF设上,从而允许嵌套中断。但是必须在此之前做好处理嵌套中断的必要准备，如保存必要的寄存器等。二在ucore中访问Trap Gate的目的是为了实现系统调用。用户进程在正常执行中是不能禁止中断的，而当它发出系统调用后，将通过Trap Gate完成了从用户态（ring 3）的用户进程进了核心态（ring 0）的OS kernel。如果在到达OS kernel后禁止EFLAGS里的IF位，第一没意义（因为不会出现嵌套系统调用的情况），第二还会导致某些中断得不到及时响应，所以调用Trap Gate时，CPU则不会去禁止中断。总之，interrupt gate和trap gate之间没有优先级之分，仅仅是CPU在处理中断时有不同的方法，供操作系统在实现时根据需要进行选择。</p>
</blockquote>
</li>
<li><p>在IDT中，可以包含如下3种类型的Descriptor：</p>
<ul>
<li>Task-gate descriptor （这里没有使用）</li>
<li>Interrupt-gate descriptor （中断方式用到）</li>
<li>Trap-gate descriptor（系统调用用到）</li>
</ul>
</li>
</ul>
<img src="https://i.loli.net/2021/11/16/qbyzSN56w9eDHKX.png" srcset="/img/loading.gif" lazyload alt="image-20211116161700420" style="zoom:70%;" />

<p>​    Interrrupt Gate and Trap Gate 和Call Gate非常相似, 不同的Gate用3bit的Type来表示:</p>
<img src="https://s2.loli.net/2021/12/20/FOG4zJsyutojfen.png" srcset="/img/loading.gif" lazyload alt="image-20211209164600135" style="zoom:67%;" />

<h4 id="由硬件完成的工作"><a href="#由硬件完成的工作" class="headerlink" title="由硬件完成的工作"></a>由硬件完成的工作</h4><ul>
<li><p>硬件中断处理过程1（==起始==）：从CPU收到中断事件后，打断当前程序或任务的执行，根据某种机制跳转到中断服务例程去执行的过程。其具体流程如下：</p>
<ul>
<li>CPU在执行完当前程序的每一条指令后，都会去确认在执行刚才的指令过程中中断控制器（如：<a target="_blank" rel="noopener" href="https://blog.csdn.net/longintchar/article/details/79439466">8259A</a>）是否发送中断请求过来，如果有那么CPU就会在相应的时钟脉冲到来时从总线上读取中断请求对应的中断向量；</li>
<li>CPU根据得到的中断向量（以此为索引）到IDT中找到该向量对应的中断描述符，中断描述符里保存着中断服务例程的段选择子；</li>
<li>CPU使用IDT查到的中断服务例程的段选择子从**GDT(这几个表一定要区分开来, 现在这个是指寻址的段描述符表)**中取得相应的段描述符，段描述符里保存了中断服务例程的段基址和属性信息，此时CPU就得到了中断服务例程的起始地址</li>
</ul>
<p>以上三个过程示意图: <a href='#ipc' id='ipc_r'>link</a> </p>
<ul>
<li>CPU会根据CPL和中断服务例程的段描述符的DPL信息确认是否发生了特权级的转换。比如当前程序正运行在用户态，而中断程序是运行在内核态的，则意味着发生了特权级的转换，这时CPU会从当前程序的<strong>TSS</strong>信息（该信息在内存中的起始地址存在TR寄存器中）里取得该程序的内核栈地址，即包括内核态的ss和esp的值，<strong>并立即将系统当前使用的栈切换成新的内核栈。</strong>这个栈就是即将运行的中断服务程序要使用的栈。紧接着就将当前程序使用的用户态的ss和esp压到新的内核栈中保存起来；</li>
<li>CPU需要开始保存当前被打断的程序的现场（即一些寄存器的值），以便于将来恢复被打断的程序继续执行。这需要利用内核栈来保存相关现场信息，即依次压入当前被打断程序使用的eflags，cs，eip，errorCode（如果是有错误码的异常）信息；</li>
<li>CPU利用中断服务例程的段描述符将其第一条指令的地址加载到cs和eip寄存器中，开始执行中断服务例程。这意味着先前的程序被暂停执行，中断服务程序正式开始工作。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>硬件中断处理过程2（==结束==）：中断处理工作完成后需要通过iret（或iretd）指令恢复被打断的程序的执行。CPU执行IRET指令的具体过程如下：</p>
<ul>
<li>程序执行这条iret指令时，首先会从内核栈里弹出先前保存的被打断的程序的现场信息，即eflags，<code>cs</code>，eip重新开始执行；</li>
<li>如果存在特权级转换（<code>CS(CPL)&gt;DPL</code>），则还需要从内核栈中弹出用户态栈的ss和esp，这样也意味着栈也被切换回原先使用的用户态的栈了；</li>
<li>如果此次处理的是带有错误码（errorCode）的异常，CPU在恢复先前程序的现场时，并不会弹出errorCode。这一步需要通过软件完成，即要求相关的中断服务例程在调用iret返回之前添加出栈代码主动弹出errorCode。</li>
</ul>
</li>
</ul>
<p><a href='#ipc_r' id='ipc'><img src="https://i.loli.net/2021/11/16/hGLAjlTYVSWpk67.png" srcset="/img/loading.gif" lazyload alt="image-20211116161700420" style="zoom:70%;" /></a></p>
<h4 id="特权级检查"><a href="#特权级检查" class="headerlink" title="特权级检查"></a>特权级检查</h4><ul>
<li><p>中断处理得==特权级转换==是通过门描述符（gate descriptor）和相关指令来完成的。一个门描述符就是一个系统类型的段描述符，一共有4个子类型：</p>
<ul>
<li>调用门描述符（call-gate descriptor may reside in the GDT or in an LDT, but not in the interrupt descriptor table (IDT)），</li>
<li>中断门描述符（interrupt-gate descriptor）</li>
<li>陷阱门描述符（trap-gate descriptor）</li>
<li>任务门描述符（task-gate descriptor）。</li>
</ul>
<p>Task gates are used for task switching and are discussed in Chapter 7, “Task Management”. Trap and interrupt<br>gates are special kinds of call gates used for calling exception and interrupt handlers。中断门描述符和陷阱门描述符几乎是一样的。</p>
<ul>
<li>中断发生时实施特权检查的过程如下图所示：</li>
</ul>
<img src="https://i.loli.net/2021/11/16/fqGtF4SHxWPCJhg.png" srcset="/img/loading.gif" lazyload alt="这里是图片描述" style="zoom:80%;" />

<ul>
<li>门中的DPL和段选择符一起控制着访问，同时，段选择符结合偏移量（Offset）指出了中断处理例程的入口点。内核一般在门描述符中填入内核代码段的段选择子。产生中断前后，CPU一定不会将运行控制从高特权环转向低特权环，特权级必须要么保持不变（当操作系统内核自己被中断的时候），或被提升（当用户态程序被中断的时候）。无论哪一种情况，CPL必须大于等于目的代码段的DPL。如果CPL发生了改变，一个堆栈切换操作（通过<strong>TSS</strong>完成）就会发生。如果中断是被用户态程序中的指令所触发的（比如软件执行INT n生产的中断），还会增加一个额外的检查：门的DPL必须具有与CPL相同或更低的特权。这就防止了用户代码随意触发中断。如果这些检查失败，会产生一个一般保护异常（general-protection exception）。</li>
</ul>
</li>
</ul>
<h4 id="ucore的实现流程"><a href="#ucore的实现流程" class="headerlink" title="ucore的实现流程"></a>ucore的实现流程</h4><ol>
<li>首先中断有几种类型<ul>
<li>使用int软中断, 中断号为<code>T_SWITCH_TOU</code>. 由于一开始ucore运行在内核, 所以内核到用户时会弹出栈上的ss和esp, 所以要在int指令前面加上两个push, 还要注意指令的字节长度匹配.</li>
<li>使用int软中断, 中断号为<code>T_SWITCH_TOK</code>. 这个时候从用户态到内核态, 要通过TR寄存器查找当前的内核栈地址, 立即切换然后压入用户态的ss和esp, 由于challenge里有说明不用返回, 所以int执行完后要释放这两个东西.</li>
<li>其他情况就是时钟中断和键盘中断到目前为止都是内核-&gt;内核再跳回内核, 没有什么复杂之处.</li>
</ul>
</li>
<li>cpu接收到中断号, 然后到IDT表里把中断号当做下标查找Interrupt Discriptor, 这个时候就找到了中断处理例程的入口地址.</li>
<li>cpu依次压入eflags，cs，eip, errorCode(如果是有错误码的异常), 然后加载描述符中的地址, 进入中断处理例程.</li>
<li>处理例程一开始就是两个pushl, 分别是errorCode和trapno), 再jmp到<code>__alltraps</code>把可能需要改变的寄存器值压到栈上<br>在栈上倒着构建一个trapframe</li>
<li>接下来进入处理例程, 0-31中断号由Intel保留, ucore定义的用<code>IRQ_OFFSET + IRQ_xx</code><ul>
<li>如果是时钟中断, inc一个全局变量tick, 没啥复杂的</li>
<li>如果是特权级转换, 更改一下trapframe的cs, es, ds, fs即可</li>
</ul>
</li>
<li>执行完毕后弹出由我们压入的寄存器值, 然后到了<code>__altraps</code>的<code>iret</code>指令,  由cpu弹出eip, cs, eflags</li>
<li>判断特权级转换来决定是否弹出ss, esp, <strong>中断结束</strong> </li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* registers as pushed by pushal */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pushregs</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span> reg_edi;<br>    <span class="hljs-keyword">uint32_t</span> reg_esi;<br>    <span class="hljs-keyword">uint32_t</span> reg_ebp;<br>    <span class="hljs-keyword">uint32_t</span> reg_oesp;          <span class="hljs-comment">/* Useless */</span><br>    <span class="hljs-keyword">uint32_t</span> reg_ebx;<br>    <span class="hljs-keyword">uint32_t</span> reg_edx;<br>    <span class="hljs-keyword">uint32_t</span> reg_ecx;<br>    <span class="hljs-keyword">uint32_t</span> reg_eax;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pushregs</span> <span class="hljs-title">tf_regs</span>;</span><br>    <span class="hljs-keyword">uint16_t</span> tf_gs;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding0;<br>    <span class="hljs-keyword">uint16_t</span> tf_fs;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding1;<br>    <span class="hljs-keyword">uint16_t</span> tf_es;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding2;<br>    <span class="hljs-keyword">uint16_t</span> tf_ds;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding3;<br>    <span class="hljs-keyword">uint32_t</span> tf_trapno;<br>    <span class="hljs-comment">/* below here defined by x86 hardware */</span><br>    <span class="hljs-keyword">uint32_t</span> tf_err;<br>    <span class="hljs-keyword">uintptr_t</span> tf_eip;<br>    <span class="hljs-keyword">uint16_t</span> tf_cs;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding4;<br>    <span class="hljs-keyword">uint32_t</span> tf_eflags;<br>    <span class="hljs-comment">/* below here only when crossing rings, such as from user to kernel */</span><br>    <span class="hljs-keyword">uintptr_t</span> tf_esp;<br>    <span class="hljs-keyword">uint16_t</span> tf_ss;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding5;<br>&#125; __attribute__((packed));<br></code></pre></div></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">#----------------------------vector.S<br>.globl vector120<br>vector120:<br>  pushl $0<br>  pushl $120<br>  jmp __alltraps<br>#----------------------------trapentry.S<br>#include &lt;memlayout.h&gt;<br><br># vectors.S sends all traps here.<br>.text<br>.globl __alltraps<br>__alltraps:<br>    # push registers to build a trap frame<br>    # therefore make the stack look like a struct trapframe<br>    pushl %ds<br>    pushl %es<br>    pushl %fs<br>    pushl %gs<br>    pushal<br><br>    # load GD_KDATA into %ds and %es to set up data segments for kernel<br>    movl $GD_KDATA, %eax<br>    movw %ax, %ds<br>    movw %ax, %es<br><br>    # push %esp to pass a pointer to the trapframe as an argument to trap()<br>    pushl %esp<br><br>    # call trap(tf), where tf=%esp<br>    call trap<br><br>    # pop the pushed stack pointer<br>    popl %esp<br><br>    # return falls through to trapret...<br>.globl __trapret<br>__trapret:<br>    # restore registers from stack<br>    popal<br><br>    # restore %ds, %es, %fs and %gs<br>    popl %gs<br>    popl %fs<br>    popl %es<br>    popl %ds<br><br>    # get rid of the trap number and error code<br>    addl $0x8, %esp<br>    iret<br></code></pre></div></td></tr></table></figure>

<h3 id="5-地址空间"><a href="#5-地址空间" class="headerlink" title="5.地址空间"></a>5.地址空间</h3><pre><code class=" mermaid">flowchart LR
    逻辑地址或虚拟地址--&gt;|分段地址转换|线性地址
    线性地址--&gt;|分页地址转换|物理地址
    线性地址--&gt;End
</code></pre>

<h3 id="6-硬件访问"><a href="#6-硬件访问" class="headerlink" title="6.硬件访问"></a>6.<a target="_blank" rel="noopener" href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_2_3_dist_accessing.html">硬件访问</a></h3><p>bootloader让CPU进入保护模式后，下一步的工作就是从硬盘上加载并运行OS。考虑到实现的简单性，bootloader的访问硬盘都是LBA模式的PIO（Program IO）方式，即所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成。</p>
<p>一般主板有2个IDE通道，每个通道可以接2个IDE硬盘。访问第一个硬盘的扇区可设置IO地址寄存器0x1f0-0x1f7实现的，具体参数见下表。一般第一个IDE通道通过访问IO地址0x1f0-0x1f7来实现，第二个IDE通道通过访问0x170-0x17f实现。每个通道的主从盘的选择通过第6个IO偏移地址寄存器来设置。</p>
<p>表一 磁盘IO地址和对应功能</p>
<p>第6位：为1=LBA模式；0 = CHS模式 第7位和第5位必须为1</p>
<table>
<thead>
<tr>
<th>IO地址</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>0x1f0</td>
<td>读数据，当0x1f7不为忙状态时，可以读。</td>
</tr>
<tr>
<td>0x1f2</td>
<td>要读写的扇区数，每次读写前，你需要表明你要读写几个扇区。最小是1个扇区</td>
</tr>
<tr>
<td>0x1f3</td>
<td>如果是LBA模式，就是LBA参数的0-7位</td>
</tr>
<tr>
<td>0x1f4</td>
<td>如果是LBA模式，就是LBA参数的8-15位</td>
</tr>
<tr>
<td>0x1f5</td>
<td>如果是LBA模式，就是LBA参数的16-23位</td>
</tr>
<tr>
<td>0x1f6</td>
<td>第0~3位：如果是LBA模式就是24-27位 第4位：为0主盘；为1从盘</td>
</tr>
<tr>
<td>0x1f7</td>
<td>状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口读数据</td>
</tr>
</tbody></table>
<p>当前 硬盘数据是储存到硬盘扇区中，一个扇区大小为512字节。读一个扇区的流程（可参看boot/bootmain.c中的readsect函数实现）大致如下：</p>
<ol>
<li>等待磁盘准备好</li>
<li>发出读取扇区的命令</li>
<li>等待磁盘准备好</li>
<li>把磁盘扇区数据读到指定内存</li>
</ol>
<h3 id="附-TSS"><a href="#附-TSS" class="headerlink" title="附: TSS"></a>附: TSS</h3><p>在<code>kern_init()-&gt;pmm_init()-&gt;gdt_init()</code>中初始化, TSS中的内核栈地址就在这里设置</p>
<p>TSS可以在内存的任意位置, 而ucore的taskstate定义在pmm.c中, 通过构造<em>门描述符</em> , 弄到<code>struct segdesc gdt[]</code>里面,<br>然后使用lgdt指令加载到GDT中, <strong>内核栈(8KB)从<code>c0120000 bootstack</code>到<code>c0122000 bootstacktop</code></strong>, 在entry.S中找到的, kernel.sym可看地址</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">...详见Lab2<br><span class="hljs-comment">// Since we are using bootloader&#x27;s GDT,</span><br>  <span class="hljs-comment">// we should reload gdt (second time, the last time) to get user segments and the TSS</span><br>  <span class="hljs-comment">// map virtual_addr 0 ~ 4G = linear_addr 0 ~ 4G</span><br>  <span class="hljs-comment">// then set kernel stack (ss:esp) in TSS, setup TSS in gdt, load TSS</span><br>  gdt_init();<br>  ...<br></code></pre></div></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SEG_TSS     5</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GD_TSS      ((SEG_TSS) &lt;&lt; 3)        <span class="hljs-comment">// task segment selector</span></span><br><span class="hljs-comment">/* gdt_init - initialize the default GDT and TSS */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">gdt_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// set boot kernel stack and default SS0</span><br>    load_esp0((<span class="hljs-keyword">uintptr_t</span>)bootstacktop);<br>    ts.ts_ss0 = KERNEL_DS;<br><br>    <span class="hljs-comment">// initialize the TSS filed of the gdt</span><br>    gdt[SEG_TSS] = SEGTSS(STS_T32A, (<span class="hljs-keyword">uintptr_t</span>)&amp;ts, <span class="hljs-keyword">sizeof</span>(ts), DPL_KERNEL);<br><br>    <span class="hljs-comment">// reload all segment registers</span><br>    lgdt(&amp;gdt_pd);<br><br>    <span class="hljs-comment">// load the TSS</span><br>    ltr(GD_TSS);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<img src="../../image/ucore/image-20211221160818556.png" srcset="/img/loading.gif" lazyload alt="image-20211221160818556" style="zoom: 67%;" />

<img src="../../image/ucore/image-20211221161024855.png" srcset="/img/loading.gif" lazyload alt="image-20211221161024855" style="zoom:67%;" />

<h3 id="附2-make"><a href="#附2-make" class="headerlink" title="附2: make"></a>附2: make</h3><p><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/make.html#Special-Targets">Special Built-in Target Names</a> | <a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/make.html#Automatic-Variables-1">Automatic Variables</a> | <a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/make.html#Functions">Functions</a> | <a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules">Using Implicit Rules</a>&amp;<a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/make.html#Catalogue-of-Rules">Catalogue-of-Rules</a> | </p>
<ul>
<li>$(foreach var,list,text):  <code>foreach(var: list)</code> </li>
<li>$(if condition,then-part[,else-part])</li>
<li>$(filter pattern…,text)</li>
<li>$(basename names…)</li>
<li>The eval Function</li>
<li>含有<code>$(1)</code>这个的call function就不是最高一级的call</li>
<li><code>make --trace 2&gt;/dev/null</code> </li>
<li><code>=</code> vs. <code>:=</code> </li>
</ul>
<h2 id="几个练习"><a href="#几个练习" class="headerlink" title="几个练习"></a>几个练习</h2><h3 id="项目组成"><a href="#项目组成" class="headerlink" title="项目组成"></a><a target="_blank" rel="noopener" href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_2_2_files.html">项目组成</a></h3><h3 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h3><blockquote>
<p>理解通过<a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/make.html">make</a>生成执行文件的过程</p>
</blockquote>
<ul>
<li><p>操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)</p>
<ul>
<li>Makefile掌握不够的话根本看不懂在写什么</li>
</ul>
</li>
<li><p>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</p>
<ul>
<li>最后两个字节是0x55,0xAA</li>
</ul>
</li>
<li><p>后面又开了一篇博客: <a href="./ucore_makefile.md">link</a> </p>
</li>
</ul>
<h3 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h3><blockquote>
<p>使用qemu执行并调试lab1中的软件</p>
</blockquote>
<ol>
<li><p>从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。</p>
<ul>
<li>直接将gdb连接到qemu, 断点也不用下直接停在第一条指令上</li>
<li>要注意的是此时<code>$pc($eip)</code>不是真实的地址, <code>(($cs&lt;&lt;4)+$eip)</code>才是</li>
</ul>
</li>
<li><p>在初始化位置0x7c00设置实地址断点,测试断点正常。</p>
<ul>
<li>此时在bootloader中, 设置为<code>file obj/bootblock.o</code>和<code>b *0x7c00</code>即可(别忘了<code>continue</code>要不然就是第一个问题了)</li>
</ul>
</li>
<li><p>从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。</p>
<figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment">#改写Makefile文件</span><br><span class="hljs-section">debug: <span class="hljs-variable">$(UCOREIMG)</span></span><br>    <span class="hljs-variable">$(V)</span><span class="hljs-variable">$(TERMINAL)</span> -e <span class="hljs-string">&quot;<span class="hljs-variable">$(QEMU)</span> -S -s -d in_asm -D <span class="hljs-variable">$(BINDIR)</span>/q.log -parallel stdio -hda <span class="hljs-variable">$&lt;</span> -serial null&quot;</span><br>    <span class="hljs-variable">$(V)</span>sleep 2<br>    <span class="hljs-variable">$(V)</span><span class="hljs-variable">$(TERMINAL)</span> -e <span class="hljs-string">&quot;gdb -q -tui -x tools/gdbinit&quot;</span><br></code></pre></div></td></tr></table></figure>

<p>在调用qemu时增加<code>-d in_asm -D q.log</code>参数，便可以将运行的汇编指令保存在q.log中。</p>
</li>
</ol>
<h3 id="练习三"><a href="#练习三" class="headerlink" title="练习三"></a>练习三</h3><blockquote>
<p>分析bootloader进入保护模式的过程.</p>
</blockquote>
<ul>
<li><p>为何开启A20，以及如何开启A20</p>
<ul>
<li><p>Intel早期的8086 CPU提供了20根地址线，但寄存器只有16位，所以使用<strong>段寄存器值 &lt;&lt; 4 + 段内偏移值</strong>的方法来访问到所有内存，但按这种方式来计算出的地址的最大值为1088KB，超过20根地址线所能表示的范围，会发生“回卷”（和整数溢出有点类似）。但下一代的基于Intel 80286 CPU的计算机系统提供了24根地址线，当CPU计算出的地址超过1MB时便<strong>不会发生回卷</strong>，而这就造成了<strong>向下不兼容</strong>。为了保持完全的向下兼容性，IBM在计算机系统上加个硬件逻辑来模仿早期的回绕特征，而这就是<strong>A20 Gate</strong>。</p>
</li>
<li><p>A20 Gate的方法是把A20地址线控制和键盘控制器的一个输出进行AND操作，这样来控制A20地址线的打开（使能）和关闭（屏蔽\禁止）。一开始时A20地址线控制是被屏蔽的（总为0），直到系统软件通过一定的IO操作去打开它。当A20 地址线控制禁止时，则程序就像在8086中运行，1MB以上的地址不可访问；保护模式下A20地址线控制必须打开。A20控制打开后，内存寻址将不会发生回卷。</p>
</li>
<li><p>在当前环境中，所用到的键盘控制器8042的IO端口只有0x60和0x64两个端口。8042通过这些端口给键盘控制器或键盘发送命令或读取状态。输出端口P2用于特定目的。位0（P20引脚）用于实现CPU复位操作，位1（P21引脚）用于控制A20信号线的开启与否。</p>
</li>
<li><p>有关概念:</p>
<p>8042有4个寄存器：</p>
<ul>
<li>1个8-bit长的Input buffer；Write-Only；</li>
<li>1个8-bit长的Output buffer； Read-Only；</li>
<li>1个8-bit长的Status Register；Read-Only；</li>
<li>1个8-bit长的Control Register；Read/Write。</li>
</ul>
<p>有两个端口地址：60h和64h，有关对它们的读写操作描述如下：</p>
<ul>
<li>读60h端口，读output buffer</li>
<li>写60h端口，写input buffer</li>
<li>读64h端口，读Status Register</li>
<li>操作Control Register，首先要向64h端口写一个命令（20h为读命令，60h为写命令），然后根据命令从60h端口读出Control Register的数据或者向60h端口写入Control Register的数据（64h端口还可以接受许多其它的命令）。<br>如果要<strong>写output</strong>, 则向64h写入命令0d1h, 向input buf写入control register中命令的参数</li>
</ul>
<p>Status Register的定义（要用bit 0和bit 1）：</p>
<table>
<thead>
<tr>
<th>bit</th>
<th>meaning</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>output register (60h) 中有数据</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>input register (60h/64h) 有数据</strong></td>
</tr>
<tr>
<td>2</td>
<td>系统标志（上电复位后被置为0）</td>
</tr>
<tr>
<td>3</td>
<td>data in input register is command (1) or data (0)</td>
</tr>
<tr>
<td>4-7</td>
<td>(Nothing special)</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/11/15/o2X7OPRbzxvVeUS.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li><p>代码中的流程:</p>
<p><strong>读0x64端口(读Status Register), 等待第二位(标志input buffer是否为空)等于0<br>向64h发送0d1h命令(作用是写output port,即一个键盘控制器命令),<br>然后等待input buf为空时向0x60h写入control register的参数(即要输出在output port上的值)</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">    # Enable A20:<br>    #  For backwards compatibility with the earliest PCs, physical<br>    #  address line 20 is tied low, so that addresses higher than<br>    #  1MB wrap around to zero by default. This code undoes this.<br>seta20.1:<br>    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).<br>    testb $0x2, %al<br>    jnz seta20.1<br><br>    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64<br>    outb %al, $0x64                                 # 0xd1 means: write data to 8042&#x27;s P2 port<br><br>seta20.2:<br>    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).<br>    testb $0x2, %al<br>    jnz seta20.2<br><br>    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60<br>    outb %al, $0x60                                 # 0xdf = 11011111, means set P2&#x27;s A20 bit(the 1 bit) to 1<br></code></pre></div></td></tr></table></figure>

<ul>
<li>如何初始化GDT表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">lgdt gdtdesc<br># Bootstrap GDT<br>.p2align 2                                          # force 4 byte alignment<br>gdt:<br>    SEG_NULLASM                                     # null seg<br>    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel<br>    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel<br><br>gdtdesc:<br>    .word 0x17                                      # sizeof(gdt) - 1<br>    .long gdt                                       # address gdt<br>    <br># asm.h<br>#define STA_X       0x8     // Executable segment<br>#define STA_W       0x2     // Writeable (non-executable segments)<br>#define STA_R       0x2     // Readable (executable segments)<br></code></pre></div></td></tr></table></figure>

<ul>
<li>进入保护模式：通过将cr0寄存器PE位置1便开启了保护模式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">movl %cr0, %eax<br>orl $CR0_PE_ON, %eax<br>movl %eax, %cr0<br></code></pre></div></td></tr></table></figure>

<ul>
<li>通过长跳转更新cs的基地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">ljmp $PROT_MODE_CSEG, $protcseg<br>.code32<br>protcseg:<br></code></pre></div></td></tr></table></figure>

<ul>
<li>设置段寄存器，并建立堆栈</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">movw $PROT_MODE_DSEG, %ax<br>movw %ax, %ds<br>movw %ax, %es<br>movw %ax, %fs<br>movw %ax, %gs<br>movw %ax, %ss<br>movl $0x0, %ebp<br>movl $start, %esp<br></code></pre></div></td></tr></table></figure>

<ul>
<li>转到保护模式完成，进入boot主方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">call bootmain<br></code></pre></div></td></tr></table></figure>

<h3 id="练习四"><a href="#练习四" class="headerlink" title="练习四"></a>练习四</h3><blockquote>
<p>分析bootloader加载ELF格式的OS的过程。</p>
</blockquote>
<ul>
<li>IDE: Integrated Drive Electronics，它的本意是指把控制器与盘体集成在一起的硬盘驱动器，IDE是表示硬盘的传输接口。</li>
</ul>
<p>bootloader让CPU进入保护模式后，下一步的工作就是从硬盘上加载并运行OS。考虑到实现的简单性，bootloader的访问硬盘都是LBA模式的PIO（Program IO）方式，即所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成。</p>
<p>一般主板有2个IDE通道，每个通道可以接2个IDE硬盘。访问第一个硬盘的扇区可设置IO地址寄存器0x1f0-0x1f7实现的，具体参数见下表。一般第一个IDE通道通过访问IO地址0x1f0-0x1f7来实现，第二个IDE通道通过访问0x170-0x17f实现。每个通道的主从盘的选择通过第6个IO偏移地址寄存器来设置。</p>
<table>
<thead>
<tr>
<th>IO地址</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>0x1f0</td>
<td>读数据，当0x1f7不为忙状态时，可以读。</td>
</tr>
<tr>
<td>0x1f2</td>
<td>要读写的扇区数，每次读写前，你需要表明你要读写几个扇区。最小是1个扇区</td>
</tr>
<tr>
<td>0x1f3</td>
<td>如果是LBA模式，就是LBA参数的0-7位</td>
</tr>
<tr>
<td>0x1f4</td>
<td>如果是LBA模式，就是LBA参数的8-15位</td>
</tr>
<tr>
<td>0x1f5</td>
<td>如果是LBA模式，就是LBA参数的16-23位</td>
</tr>
<tr>
<td>0x1f6</td>
<td>第0~3位：如果是LBA模式就是24-27位 第4位：为0主盘；为1从盘</td>
</tr>
<tr>
<td>0x1f7</td>
<td>状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口读数据</td>
</tr>
</tbody></table>
<p>当前 硬盘数据是储存到硬盘扇区中，一个扇区大小为512字节。读一个扇区的流程（可参看boot/bootmain.c中的readsect函数实现）大致如下：</p>
<ol>
<li>等待磁盘准备好</li>
<li>发出读取扇区的命令</li>
<li>等待磁盘准备好</li>
<li>把磁盘扇区数据读到指定内存</li>
</ol>
<p><strong>分析bootloader加载ELF格式的OS的过程。</strong> </p>
<p>首先看readsect函数，<br><code>readsect</code>从设备的第secno扇区读取数据到dst位置</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">readsect</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *dst, <span class="hljs-keyword">uint32_t</span> secno)</span> </span>&#123;<br>    waitdisk();<br><br>    outb(<span class="hljs-number">0x1F2</span>, <span class="hljs-number">1</span>);                         <span class="hljs-comment">// 设置读取扇区的数目为1</span><br>    outb(<span class="hljs-number">0x1F3</span>, secno &amp; <span class="hljs-number">0xFF</span>);<br>    outb(<span class="hljs-number">0x1F4</span>, (secno &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>);<br>    outb(<span class="hljs-number">0x1F5</span>, (secno &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFF</span>);<br>    outb(<span class="hljs-number">0x1F6</span>, ((secno &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xF</span>) | <span class="hljs-number">0xE0</span>);<br>        <span class="hljs-comment">// 上面四条指令联合制定了扇区号</span><br>        <span class="hljs-comment">// 在这4个字节线联合构成的32位参数中</span><br>        <span class="hljs-comment">//   29-31位强制设为1</span><br>        <span class="hljs-comment">//   28位(=0)表示访问&quot;Disk 0&quot;</span><br>        <span class="hljs-comment">//   0-27位是28位的偏移量</span><br>    outb(<span class="hljs-number">0x1F7</span>, <span class="hljs-number">0x20</span>);                      <span class="hljs-comment">// 0x20命令，读取扇区</span><br><br>    waitdisk();<br><br>    insl(<span class="hljs-number">0x1F0</span>, dst, SECTSIZE / <span class="hljs-number">4</span>);         <span class="hljs-comment">// 读取到dst位置，</span><br>                                            <span class="hljs-comment">// magic number = 4因为这里以DW为单位</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>readseg简单包装了readsect，可以从设备读取任意长度的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">readseg</span><span class="hljs-params">(<span class="hljs-keyword">uintptr_t</span> va, <span class="hljs-keyword">uint32_t</span> count, <span class="hljs-keyword">uint32_t</span> offset)</span> </span>&#123;<br>    <span class="hljs-keyword">uintptr_t</span> end_va = va + count;<br><br>    va -= offset % SECTSIZE;<br><br>    <span class="hljs-keyword">uint32_t</span> secno = (offset / SECTSIZE) + <span class="hljs-number">1</span>; <br>    <span class="hljs-comment">// 加1因为0扇区被引导占用</span><br>    <span class="hljs-comment">// ELF文件从1扇区开始</span><br><br>    <span class="hljs-keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;<br>        readsect((<span class="hljs-keyword">void</span> *)va, secno);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在bootmain函数中，</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">bootmain</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// 首先读取ELF的头部</span><br>    readseg((<span class="hljs-keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 通过储存在头部的幻数判断是否是合法的ELF文件</span><br>    <span class="hljs-keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;<br>        <span class="hljs-keyword">goto</span> bad;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> *<span class="hljs-title">ph</span>, *<span class="hljs-title">eph</span>;</span><br><br>    <span class="hljs-comment">// ELF头部有描述ELF文件应加载到内存什么位置的描述表，</span><br>    <span class="hljs-comment">// 先将描述表的头地址存在ph</span><br>    ph = (struct proghdr *)((<span class="hljs-keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);<br>    eph = ph + ELFHDR-&gt;e_phnum;<br><br>    <span class="hljs-comment">// 按照描述表将ELF文件中数据载入内存</span><br>    <span class="hljs-keyword">for</span> (; ph &lt; eph; ph ++) &#123;<br>        readseg(ph-&gt;p_va &amp; <span class="hljs-number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);<br>    &#125;<br>    <span class="hljs-comment">// ELF文件0x1000位置后面的0xd1ec比特被载入内存0x00100000</span><br>    <span class="hljs-comment">// ELF文件0xf000位置后面的0x1d20比特被载入内存0x0010e000</span><br><br>    <span class="hljs-comment">// 根据ELF头部储存的入口信息，找到内核的入口</span><br>    ((<span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="hljs-number">0xFFFFFF</span>))();<br><br>bad:<br>    outw(<span class="hljs-number">0x8A00</span>, <span class="hljs-number">0x8A00</span>);<br>    outw(<span class="hljs-number">0x8A00</span>, <span class="hljs-number">0x8E00</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="练习五"><a href="#练习五" class="headerlink" title="练习五"></a>练习五</h3><blockquote>
<p>实现函数调用堆栈跟踪函数</p>
</blockquote>
<p class="note note-primary"style="font-style:italic;background-color:rgb(240,230,250)">发现并没有在这里提到stabs类型文件, 补充一下</p>

<ul>
<li>Stabs refers to a format for information that describes a program to a debugger</li>
<li>This debugging information describes features of the source file like <u>line numbsers, the types and scopes of variables, and function names, parameters, and scopes.</u> </li>
<li>generated by compiler into the ‘.s’ file</li>
<li><a target="_blank" rel="noopener" href="https://www.sourceware.org/gdb/onlinedocs/stabs.pdf">documentation</a> </li>
</ul>
<p>ss:ebp指向的堆栈位置储存着caller的ebp，以此为线索可以得到所有使用堆栈的函数ebp。<br>ss:ebp+4指向caller调用时的eip，ss:ebp+8等是（可能的）参数。</p>
<p>输出中，堆栈最深一层为</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">ebp:<span class="hljs-number">0x00007bf8</span> eip:<span class="hljs-number">0x00007d68</span> args:<span class="hljs-number">0x00000000</span> <span class="hljs-number">0x00000000</span> <span class="hljs-number">0x00000000</span> <span class="hljs-number">0x00007c4f</span><br>    &lt;unknow&gt;: -- <span class="hljs-number">0x00007d67</span> --<br></code></pre></div></td></tr></table></figure>

<p>其对应的是第一个使用堆栈的函数，bootmain.c中的bootmain。<br>bootloader设置的堆栈从0x7c00开始，使用”call bootmain”转入bootmain函数。<br>call指令压栈，所以bootmain中ebp为0x7bf8。</p>
<p><strong>print_stackframe:</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">+|  栈底方向    | 高位地址</span><br><span class="hljs-comment"> |    ...       |</span><br><span class="hljs-comment"> |    ...       |</span><br><span class="hljs-comment"> |  参数3       |</span><br><span class="hljs-comment"> |  参数2       |</span><br><span class="hljs-comment"> |  参数1       |</span><br><span class="hljs-comment"> |  返回地址     |</span><br><span class="hljs-comment"> |  上一层[ebp]  | &lt;-------- [ebp]</span><br><span class="hljs-comment"> |  局部变量     |  低位地址</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">uint32_t</span> eip, ebp;<br>eip = read_eip();<br>ebp = read_ebp();<br><span class="hljs-keyword">int</span> i, j;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; ebp != <span class="hljs-number">0</span> &amp;&amp; i &lt; STACKFRAME_DEPTH; i++)<br>&#123;<br>    cprintf(<span class="hljs-string">&quot;ebp:0x%08x eip:0x%08x args:&quot;</span>, ebp, eip);<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++)<br>    &#123;<br>        cprintf(<span class="hljs-string">&quot;0x%08x &quot;</span>, ((<span class="hljs-keyword">uint32_t</span> *)ebp + <span class="hljs-number">2</span>)[j]);<br>    &#125;<br>    cprintf(<span class="hljs-string">&quot;\n&quot;</span>);<br>    print_debuginfo(eip - <span class="hljs-number">1</span>);<br>    eip = ((<span class="hljs-keyword">uint32_t</span> *)ebp)[<span class="hljs-number">1</span>];<br>    ebp = ((<span class="hljs-keyword">uint32_t</span> *)ebp)[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>需要注意的问题:</p>
<ul>
<li><p>gdb命令通过文件加载debuginfo, 包括源代码和函数位置, 一般我们直接使用gdb <em>filepath</em> -q直接进入调试界面, 而本实验先启动qemu(使用.img镜像文件), 然后gdb通过remote连接到qemu中, Makefile中指定的gdbinit文件可以指定一些初始命令.</p>
<p>这样, gdb没有任何debuginfo, 全靠远程端口给出信息, 所以我们可以在init文件中添加file命令加载符号信息</p>
</li>
</ul>
<h3 id="练习六"><a href="#练习六" class="headerlink" title="练习六"></a>练习六</h3><blockquote>
<p>完善中断初始化和处理</p>
</blockquote>
<ul>
<li><p>中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？</p>
<ul>
<li><p>一个表项的结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Gate descriptors for interrupts and traps */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gatedesc</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> gd_off_15_0 : <span class="hljs-number">16</span>;        <span class="hljs-comment">// low 16 bits of offset in segment</span><br>    <span class="hljs-keyword">unsigned</span> gd_ss : <span class="hljs-number">16</span>;            <span class="hljs-comment">// segment selector</span><br>    <span class="hljs-keyword">unsigned</span> gd_args : <span class="hljs-number">5</span>;            <span class="hljs-comment">// # args, 0 for interrupt/trap gates</span><br>    <span class="hljs-keyword">unsigned</span> gd_rsv1 : <span class="hljs-number">3</span>;            <span class="hljs-comment">// reserved(should be zero I guess)</span><br>    <span class="hljs-keyword">unsigned</span> gd_type : <span class="hljs-number">4</span>;            <span class="hljs-comment">// type(STS_&#123;TG,IG32,TG32&#125;)</span><br>    <span class="hljs-keyword">unsigned</span> gd_s : <span class="hljs-number">1</span>;                <span class="hljs-comment">// must be 0 (system)</span><br>    <span class="hljs-keyword">unsigned</span> gd_dpl : <span class="hljs-number">2</span>;            <span class="hljs-comment">// descriptor(meaning new) privilege level</span><br>    <span class="hljs-keyword">unsigned</span> gd_p : <span class="hljs-number">1</span>;                <span class="hljs-comment">// Present</span><br>    <span class="hljs-keyword">unsigned</span> gd_off_31_16 : <span class="hljs-number">16</span>;        <span class="hljs-comment">// high bits of offset in segment</span><br>&#125;;<br></code></pre></div></td></tr></table></figure></li>
<li><p>该表项的大小为<code>16+16+5+3+4+1+2+1+16 == 8*8</code>bit，即<strong>8字节</strong>。</p>
</li>
<li><p>根据IDT表项的结构，我们可以得知，IDT表项的第二个成员<code>gd_ss</code>为段选择子，第一个成员<code>gd_off_15_0</code>和最后一个成员<code>gd_off_31_16</code>共同组成一个段内偏移地址。根据段选择子和段内偏移地址就可以得出中断处理程序的地址。</p>
</li>
</ul>
</li>
<li><p>编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init.</p>
<ul>
<li><p>具体实现如下，详细信息以注释的形式写入代码中。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">idt_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>  <span class="hljs-comment">// __vectors定义于vector.S中</span><br>  <span class="hljs-keyword">extern</span> <span class="hljs-keyword">uintptr_t</span> __vectors[];<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(idt) / <span class="hljs-keyword">sizeof</span>(struct gatedesc); i ++)<br>      <span class="hljs-comment">// 目标idt项为idt[i]</span><br>      <span class="hljs-comment">// 该idt项为内核代码，所以使用GD_KTEXT段选择子</span><br>      <span class="hljs-comment">// 中断处理程序的入口地址存放于__vectors[i]</span><br>      <span class="hljs-comment">// 特权级为DPL_KERNEL</span><br>      SETGATE(idt[i], <span class="hljs-number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);<br>  <span class="hljs-comment">// 设置从用户态转为内核态的中断的特权级为DPL_USER</span><br>  <span class="hljs-comment">// 好像就是int 0x80, 不过我没有在任何地方看到说明, 尝试自己写这一段代码花了好多无谓的时间</span><br>  SETGATE(idt[T_SWITCH_TOK], <span class="hljs-number">0</span>, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);<br>  <span class="hljs-comment">// 加载该IDT</span><br>  lidt(&amp;idt_pd);<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
</ul>
</li>
<li><p>编程完善trap.c中的中断处理函数trap_dispatch**(called by trap(), and trap() called in trapentry.S)**，在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”。</p>
<ul>
<li><p>这个实现还是比较简单的，注释都说清楚了</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">case</span> IRQ_OFFSET + IRQ_TIMER:        <span class="hljs-comment">// 全局变量ticks定义于kern/driver/clock.c</span><br>	ticks++;       <br>	<span class="hljs-keyword">if</span>(ticks % TICK_NUM == <span class="hljs-number">0</span>)            <br>        print_ticks();        <br><span class="hljs-keyword">break</span>;    <span class="hljs-comment">// .........</span><br></code></pre></div></td></tr></table></figure></li>
</ul>
</li>
<li><p>结果:</p>
</li>
</ul>
<img src="https://i.loli.net/2021/11/20/n8cShiWkulDqzpP.png" srcset="/img/loading.gif" lazyload alt="image-20211120131815160" style="zoom:80%;" />

<h3 id="拓展练习"><a href="#拓展练习" class="headerlink" title="拓展练习"></a>拓展练习</h3><blockquote>
<p>Challenge 1: 扩展proj4,增加syscall功能，即增加一用户态函数（可执行一特定系统调用：获得时钟计数值），当内核初始完毕后，可从内核态返回到用户态的函数，而用户态的函数又通过系统调用得到内核态的服务</p>
</blockquote>
<p>详见知识点</p>
<blockquote>
<p>Challenge 2:用键盘实现用户模式内核模式切换。具体目标是：“键盘输入3时切换到用户模式，键盘输入0时切换到内核模式”。 基本思路是借鉴软中断(syscall功能)的代码，并且把trap.c中软中断处理的设置语句拿过来。</p>
</blockquote>
<h1 id="Lab2"><a href="#Lab2" class="headerlink" title="Lab2"></a>Lab2</h1><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><h3 id="1-探测系统物理内存布局"><a href="#1-探测系统物理内存布局" class="headerlink" title="1.探测系统物理内存布局"></a>1.探测系统物理内存布局</h3><ul>
<li>当 ucore 被启动之后，最重要的事情就是知道还有多少内存可用，一般来说，获取内存大小的方法由 BIOS 中断调用和直接探测两种。但BIOS 中断调用方法是一般只能在实模式下完成，而直接探测方法必须在保护模式下完成。通过 BIOS 中断获取内存布局有三种方式，都是基于INT 15h中断，分别为88h e801h e820h。但是 并非在所有情况下这三种方式都能工作。在 Linux kernel 里，采用的方法是依次尝试这三 种方法。而在本实验中，我们通过e820h中断获取内存信息。因为e820h中断必须在实模式下使用，所以我们在 bootloader 进入保护模式之前调用这个 BIOS 中断，并且把 e820 映 射结构<strong>保存在物理地址0x8000</strong>处。</li>
<li><a target="_blank" rel="noopener" href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab2/lab2_3_5_probe_phymem_methods.html">INT 15h调用</a>完成后, 将返回值存入一个结构体中:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">e820map</span> &#123;</span><br>	<span class="hljs-keyword">int</span> nr_map;	<span class="hljs-comment">//四字节, map中的元素个数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> addr;		<span class="hljs-comment">// 可用内存的起始地址</span><br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> size;		<span class="hljs-comment">// 内存块大小</span><br>        <span class="hljs-keyword">long</span> type;		    <span class="hljs-comment">// 四字节, 某块内存的属性。1标识可被使用内存块；2表示保留的内存块，不可映射</span><br>    &#125; <span class="hljs-built_in">map</span>[E820MAX];<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>​    存入的过程为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">probe_memory:<br>    movl $0, 0x8000   # 初始化，向内存地址0x8000，即uCore结构e820map中的成员nr_map中写入0<br>    xorl %ebx, %ebx   # 初始化%ebx为0，这是int 0x15的其中一个参数<br>    movw $0x8004, %di # 初始化%di寄存器，使其指向结构e820map中的成员数组map<br>start_probe:<br>    movl $0xE820, %eax  # BIOS 0x15中断的子功能编号 %eax == 0xE820<br>    movl $20, %ecx    # 存放地址范围描述符的内存大小，至少20<br>    movl $SMAP, %edx  # 签名， %edx == 0x534D4150h(&quot;SMAP&quot;字符串的ASCII码)<br>    int $0x15     # 调用0x15中断<br>    jnc cont      # 如果该中断执行失败，则CF标志位会置1，此时要通知UCore出错<br>    movw $12345, 0x8000 # 向结构e820map中的成员nr_map中写入特殊信息，报告当前错误<br>    jmp finish_probe    # 跳转至结束，不再探测内存<br>cont:<br>    addw $20, %di   # 如果中断执行正常，则目标写入地址就向后移动一个位置<br>    incl 0x8000     # e820::nr_map++<br>    cmpl $0, %ebx   # 执行中断后，返回的%ebx是原先的%ebx加一。如果%ebx为0，则说明当前内存探测完成<br>    jnz start_probe<br>finish_probe:<br></code></pre></div></td></tr></table></figure>

<p><code>edata</code>表示<code>kernel</code>的<code>data</code>段结束地址；<code>end</code>表示<code>bss</code>段的结束地址（即整个<code>kernel</code>的结束地址）</p>
<p><code>edata[]</code>和 <code>end[]</code>这些变量是ld根据kernel.ld链接脚本生成的全局变量，表示相应段的结束地址，它们不在任何一个.S、.c或.h文件中定义，但仍然可以在源码文件中使用。</p>
<h3 id="2-管理物理-内存"><a href="#2-管理物理-内存" class="headerlink" title="2.管理物理 内存"></a>2.管理<em>物理</em> 内存</h3><ul>
<li>每一个物理页的属性用结构Page来表示</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> &#123;</span><br>    <span class="hljs-keyword">int</span> ref;        <span class="hljs-comment">// page frame&#x27;s reference counter</span><br>    <span class="hljs-keyword">uint32_t</span> flags; <span class="hljs-comment">// array of flags that describe the status of the page frame</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> property;<span class="hljs-comment">// the num of free *page*, used in first fit pm manager</span><br>    <span class="hljs-keyword">list_entry_t</span> page_link;<span class="hljs-comment">// free list link</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>而flag第一位和第二位(即bit 0 and bit 1, PG_reserved和PG_property的0和1是指第几位):</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Flags describing the status of a page frame */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PG_reserved                 0       <span class="hljs-comment">// the page descriptor is reserved for kernel or unusable</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PG_property                 1       <span class="hljs-comment">// the member &#x27;property&#x27; is valid (free or not)</span></span><br></code></pre></div></td></tr></table></figure>

<p>​    需要注意的是用到property成员变量的这个Page比较特殊，是这个连续内存空闲块地址<strong>最小的一页</strong>（即头一页， Head Page）,<br>​    用bit PG_property来enable</p>
<ul>
<li>使用btl指令置位某一个bit:</li>
</ul>
<blockquote>
<p>BTS %1,  %2     :先把%2对应的内存地址的第%1位的值填入cflags寄存器的CF，然后把该位<strong>置位</strong>)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SetPageReserved(page)       set_bit(PG_reserved, &amp;((page)-&gt;flags)) <span class="hljs-comment">//setbit使用的是内联汇编形式的btl指令</span></span><br></code></pre></div></td></tr></table></figure>

<ul>
<li>管理空闲块</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* free_area_t - maintains a doubly linked list to record free (unused) pages */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            <span class="hljs-keyword">list_entry_t</span> free_list;                                <span class="hljs-comment">// the list header</span><br>            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nr_free;                                 <span class="hljs-comment">// num of free pages in this free list</span><br>&#125; <span class="hljs-keyword">free_area_t</span>;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>pmm_manager(): 一个函数指针列表, 用于引用管理内存的函数, 指向这个结构体的指针也是<code>pmm_manager</code><br>项目定义了一个<code>default_pmm_manager</code>, 每一个函数指向的具体函数定义在default_pmm_init.c中, 将此结构体地址赋值给<br>(pmm_manager *)pmm_manager, 可以更改为其他内存分配算法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pmm_manager</span> &#123;</span><br>            <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name; 	<span class="hljs-comment">//物理内存页管理器的名字</span><br>            <span class="hljs-keyword">void</span> (*init)(<span class="hljs-keyword">void</span>); <span class="hljs-comment">//初始化内存管理器</span><br>            <span class="hljs-keyword">void</span> (*init_memmap)(struct Page *base, <span class="hljs-keyword">size_t</span> n); <span class="hljs-comment">//初始化管理空闲内存页的数据结构</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *(*<span class="hljs-title">alloc_pages</span>)(<span class="hljs-title">size_t</span> <span class="hljs-title">n</span>);</span> <span class="hljs-comment">//分配n个物理内存页</span><br>            <span class="hljs-keyword">void</span> (*free_pages)(struct Page *base, <span class="hljs-keyword">size_t</span> n); <span class="hljs-comment">//释放n个物理内存页</span><br>            <span class="hljs-keyword">size_t</span> (*nr_free_pages)(<span class="hljs-keyword">void</span>); <span class="hljs-comment">//返回当前剩余的空闲页数</span><br>            <span class="hljs-keyword">void</span> (*check)(<span class="hljs-keyword">void</span>); <span class="hljs-comment">//用于检测分配/释放实现是否正确的辅助函数</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<ul>
<li><code>kern_init()</code>中<code>pmm_init()</code>的==<code>page_init()</code>==部分内容</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// code above is traverse all memmap(e820map) to search the maxpa and print the memmap out</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> end[];<br><br><span class="hljs-comment">// calc the sum of pages</span><br>npage = maxpa / PGSIZE;<br><span class="hljs-comment">// </span><br>pages = (struct Page *)ROUNDUP((<span class="hljs-keyword">void</span> *)end, PGSIZE);<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; npage; i ++) &#123;<br>	SetPageReserved(pages + i);	<br>&#125;<br><br><span class="hljs-keyword">uintptr_t</span> freemem = PADDR((<span class="hljs-keyword">uintptr_t</span>)pages + <span class="hljs-keyword">sizeof</span>(struct Page) * npage);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*    SetPageReserved只需把物理地址对应的Page结构中的flags标志设置为PG_reserved ，表示这些</span><br><span class="hljs-comment">*	页已经被使用了，将来不能被用于分配。</span><br><span class="hljs-comment">*    而init_memmap函数则是把空闲物理页对应的Page结构中的flags和引用计数ref清零，并加到</span><br><span class="hljs-comment">*	free_area.free_list指向的双向列表中，为将来的空闲页管理做好初始化准备工作。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// code below corrects free physical blocks&#x27; boundaries and initialized </span><br><span class="hljs-comment">// page(not page table), adding page to freelist.</span><br><span class="hljs-comment">// then, all physical pages&#x27; info are stored in base address (struct Page *)pages.</span><br><span class="hljs-comment">// page(s) can be accessed by `struct Page *pages;`, just like array.</span><br></code></pre></div></td></tr></table></figure>

<h3 id="3-内存空间布局"><a href="#3-内存空间布局" class="headerlink" title="3.内存空间布局"></a>3.内存空间布局</h3><ul>
<li><p>在uCore中，CPU先在bootasm.S（实模式）中通过调用BIOS中断，将物理内存的相关描述符写入特定位置<code>0x8000</code>，然后读入kernel至物理地址<code>0x10000</code>、虚拟地址<code>0xC0000000</code>。</p>
</li>
<li><p>而kernel在<code>page_init</code>函数中，读取物理内存地址<code>0x8000</code>处的内存，查找最大物理地址，并计算出所需的<strong>页面数</strong>。虚拟页表<code>VPT(Virtual Page Table)</code>的地址紧跟<code>kernel</code>，其地址为4k对齐。虚拟地址空间结构如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* *</span><br><span class="hljs-comment"> * Virtual memory map:                                          Permissions</span><br><span class="hljs-comment"> *                                                              kernel/user</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *     4G -----------&gt; +---------------------------------+</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     |         Empty Memory (*)        |</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     +---------------------------------+ 0xFB000000</span><br><span class="hljs-comment"> *                     |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE</span><br><span class="hljs-comment"> *     VPT ----------&gt; +---------------------------------+ 0xFAC00000</span><br><span class="hljs-comment"> *                     |        Invalid Memory (*)       | --/--</span><br><span class="hljs-comment"> *     KERNTOP ------&gt; +---------------------------------+ 0xF8000000</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     |    Remapped Physical Memory     | RW/-- KMEMSIZE=896MB</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *     KERNBASE -----&gt; +---------------------------------+ 0xC0000000</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="hljs-comment"> * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span><br><span class="hljs-comment"> *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span><br><span class="hljs-comment"> *     there if desired.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * */</span><br></code></pre></div></td></tr></table></figure>

<p>完成<strong>物理内存页管理初始化工作</strong>后，其物理地址的分布空间如下</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">+----------------------+ &lt;- <span class="hljs-number">0xFFFFFFFF</span>(4GB)       ----------------------------  4GB<br>|  一些保留内存，例如用于|                                保留空间<br>|   32bit设备映射空间等  |<br>+----------------------+ &lt;- 实际物理内存空间结束地址 ----------------------------<br>|                      |<br>|                      |<br>|     用于分配的         |                                 可用的空间<br>|    空闲内存区域        |<br>|                      |<br>|                      |<br>|                      |<br>+----------------------+ &lt;- 空闲内存起始地址      ----------------------------  <br>|     VPT页表存放位置      |                                VPT页表存放的空间   (4MB左右)<br>+----------------------+ &lt;- bss段结束处           ----------------------------<br>|uCore的text、data、bss |                              uCore各段的空间<br>+----------------------+ &lt;- <span class="hljs-number">0x00100000</span>(1MB)       ---------------------------- 1MB<br>|       BIOS ROM       |<br>+----------------------+ &lt;- <span class="hljs-number">0x000F0000</span>(960KB)<br>|     16bit设备扩展ROM  |                             显存与其他ROM映射的空间<br>+----------------------+ &lt;- <span class="hljs-number">0x000C0000</span>(768KB)<br>|     CGA显存空间       |<br>+----------------------+ &lt;- <span class="hljs-number">0x000B8000</span>            ---------------------------- 736KB<br>|        空闲内存       |<br>+----------------------+ &lt;- <span class="hljs-number">0x00011000</span>(+4KB)          uCore header的内存空间<br>| uCore的ELF header数据 |<br>+----------------------+ &lt;-<span class="hljs-number">0x00010000</span>             ---------------------------- 64KB<br>|       空闲内存        |<br>+----------------------+ &lt;- 基于bootloader的大小          bootloader的<br>|      bootloader的   |                                    内存空间<br>|     text段和data段    |<br>+----------------------+ &lt;- <span class="hljs-number">0x00007C00</span>            ---------------------------- 31KB<br>|   bootloader和uCore  |<br>|      共用的堆栈       |                                 堆栈的内存空间<br>+----------------------+ &lt;- 基于栈的使用情况<br>|     低地址空闲空间    |<br>+----------------------+ &lt;-  <span class="hljs-number">0x00000000</span>           ---------------------------- 0KB<br></code></pre></div></td></tr></table></figure>

<p>易知，其页表地址之上的物理内存空间是空闲的（除去保留的内存），故将该物理地址之下的物理空间对应的页表全部设置为保留(reserved)。并将这些空闲的内存全部添加进页表项中。</p>
</li>
</ul>
<h3 id="4-分配算法实现"><a href="#4-分配算法实现" class="headerlink" title="4.分配算法实现"></a>4.分配算法实现</h3><blockquote>
<p>在default_pmm.c中</p>
<p>实现了最简单的first-fit, 其他算法为challenge</p>
</blockquote>
<h3 id="5-段页式存储管理"><a href="#5-段页式存储管理" class="headerlink" title="5.段页式存储管理"></a>5.段页式存储管理</h3><h4 id="总体框架、分页机制图"><a href="#总体框架、分页机制图" class="headerlink" title="总体框架、分页机制图"></a>总体框架、分页机制图</h4><img src="https://i.loli.net/2021/11/20/Uvnt9ZJfP32FMbr.png" srcset="/img/loading.gif" lazyload alt="image-20211120231536312" style="zoom:67%;" />

<p>Page Directory is 4Kbyte-alignd, 所以CR3给的32位地址其实低12位为0, 只要把32:12和Linear address的31:22拼成一个32位地址即可:</p>
<img src="https://i.loli.net/2021/11/23/YQoyfDqFVTZPs6C.png" srcset="/img/loading.gif" lazyload alt="image-20211120233531488" style="zoom:67%;" />

<h4 id="虚拟页表和页目录表结构"><a href="#虚拟页表和页目录表结构" class="headerlink" title=" 虚拟页表和页目录表结构"></a><span id="vpt&pdt"> </span>虚拟页表和页目录表结构</h4><p>每个<strong>页表项</strong>（PTE）都由一个32位整数来存储数据，其结构如下</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">      31-12      9-11     8    7    6   5   4      3    2   1   0<br>+<span class="hljs-params">--------------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">----</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<br>|     Offset   | Avail | MBZ | PS | D | A | PCD | PWT | U | W | P |<br>+<span class="hljs-params">--------------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">----</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<br></code></pre></div></td></tr></table></figure>

<ul>
<li>0 - <strong>P</strong>resent: 表示当前PTE所指向的物理页面是否驻留在内存中</li>
<li>1 - <strong>W</strong>riteable: 表示是否允许读写</li>
<li>2 - <strong>U</strong>ser: 表示该页的访问所需要的特权级。即User(ring 3)是否允许访问</li>
<li>3 - <strong>P</strong>age<strong>W</strong>rite<strong>T</strong>hough: 表示是否使用write through缓存写策略</li>
<li>4 - <strong>P</strong>age<strong>C</strong>ache<strong>D</strong>isable: 表示是否<strong>不对</strong>该页进行缓存</li>
<li>5 - <strong>A</strong>ccess: 表示该页是否已被访问过</li>
<li>6 - <strong>D</strong>irty: 表示该页是否已被修改</li>
<li>7 - <strong>P</strong>age<strong>S</strong>ize: 表示该页的大小</li>
<li>8 - <strong>M</strong>ust<strong>B</strong>e<strong>Z</strong>ero: 该位必须保留为0</li>
<li>9-11 - <strong>Avail</strong>able: 第9-11这三位并没有被内核或中断所使用，可保留给OS使用。</li>
<li>12-31 - Offset: 目标<strong>物理</strong>地址的高20位。</li>
</ul>
<p><strong>页目录表:</strong> </p>
<img src="https://i.loli.net/2021/11/23/9B45OFTQWedfhw1.png" srcset="/img/loading.gif" lazyload alt="image-20211123104109784" style="zoom:80%;" />

<table>
<thead>
<tr>
<th>Bit Position(s)</th>
<th>Contents</th>
</tr>
</thead>
<tbody><tr>
<td>0(P)</td>
<td>Present: must be 1 to reference a page table</td>
</tr>
<tr>
<td>1(R/W)</td>
<td>Read/write; if 0,writes may not be allowed to the 4-MByte region controlled by this entry (see Section 4.6)</td>
</tr>
<tr>
<td>2(U/S)</td>
<td>User/supervisor, if 0, user-mode accesses are not allowed to the 4-MByte region controlled by this entry (see Section 4.6)</td>
</tr>
<tr>
<td>3(PWT)</td>
<td>Page-level write-through; indirectly determines the memory type used to access the page table referenced by this entry (see Section 4.9)</td>
</tr>
<tr>
<td>4(PCD)</td>
<td>Page-level cache disable; indirectly determines the memory type used to access the page table referenced by this entry (see Section 4.9)</td>
</tr>
<tr>
<td>5(A)</td>
<td>Accessed; indicates whether this entry has been used for linear-address translation (see Section 4.8)</td>
</tr>
<tr>
<td>6</td>
<td>lgnored</td>
</tr>
<tr>
<td>7(PS)</td>
<td>lf CR4.PSE= 1, must be 0 (otherwise, this entry maps a 4-MByte page; see Table 4-4); otherwise, ignored</td>
</tr>
<tr>
<td>11:8</td>
<td>lgnored</td>
</tr>
<tr>
<td>31:12</td>
<td><strong>Physical address</strong> of 4-KByte aligned page table referenced by this entry</td>
</tr>
</tbody></table>
<h3 id="6-内存初始化函数pmm-init"><a href="#6-内存初始化函数pmm-init" class="headerlink" title="6.内存初始化函数pmm_init()"></a>6.内存初始化函数pmm_init()</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">pmm_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// 装在cr3的物理地址</span><br>    boot_cr3 = PADDR(boot_pgdir);<br>    <br>    init_pmm_manager();<br><br>    <span class="hljs-comment">// detect physical memory space in 0~KERNMSIZE, reserve already used memory,</span><br>    <span class="hljs-comment">// then use pmm-&gt;init_memmap to create free page list</span><br>    page_init();<br><br>    <span class="hljs-comment">// some simple check</span><br>    check_alloc_page();<br>    check_pgdir();<br>    <span class="hljs-keyword">static_assert</span>(KERNBASE % PTSIZE == <span class="hljs-number">0</span> &amp;&amp; KERNTOP % PTSIZE == <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// recursively insert boot_pgdir in itself</span><br>    <span class="hljs-comment">// to form a virtual page table at virtual address VPT</span><br>    boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;<br><br>    <span class="hljs-comment">// map all physical memory to linear memory with base linear addr KERNBASE</span><br>    <span class="hljs-comment">// linear_addr KERNBASE ~ KERNBASE + KMEMSIZE = phy_addr 0 ~ KMEMSIZE</span><br>    boot_map_segment(boot_pgdir, KERNBASE, KMEMSIZE, <span class="hljs-number">0</span>, PTE_W);<br><br>    <span class="hljs-comment">// map virtual_addr 0 ~ 4G = linear_addr 0 ~ 4G</span><br>    <span class="hljs-comment">// then set kernel stack (ss:esp) in TSS, setup TSS in gdt, load TSS</span><br>    gdt_init();<br><br>    <span class="hljs-comment">//now the basic virtual memory map(see memalyout.h) is established.</span><br>    <span class="hljs-comment">//check the correctness of the basic virtual memory map.</span><br>    check_boot_pgdir();<br>    print_pgdir();<br>    kmalloc_init();	<span class="hljs-comment">//just print some words</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="7-链接脚本与地址映射"><a href="#7-链接脚本与地址映射" class="headerlink" title="7.链接脚本与地址映射"></a>7.链接脚本与地址映射</h3><ul>
<li><strong>edata[]和 end[]这些变量是ld根据kernel.ld链接脚本生成的全局变量，表示相应段的起始地址或结束地址等，它们不在任何一个.S、.c或.h文件中定义。</strong> </li>
<li><strong>逻辑地址或虚拟地址是可执行代码在编译的时候由链接器生成的</strong> </li>
<li>ucore内核的链接地址==ucore内核的虚拟地址；boot loader加载ucore内核用到的加载地址==ucore内核的物理地址。</li>
<li><a target="_blank" rel="noopener" href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab2/lab2_3_7_phymemlab_concepts.html">-&gt;详见实验指导书&lt;-</a> </li>
</ul>
<h4 id="地址映射的四个阶段"><a href="#地址映射的四个阶段" class="headerlink" title="地址映射的四个阶段"></a>地址映射的四个阶段</h4><p>在lab2中，为了建立正确的地址映射关系，ld在链接阶段生成了ucore OS执行代码的虚拟地址，而bootloader与ucore OS协同工作，通过在运行时对地址映射的一系列“腾挪转移”，从计算机加电，启动段式管理机制，启动段页式管理机制，在段页式管理机制下运行这整个过程中，虚拟地址到物理地址的映射产生了多次变化，实现了最终的段页式映射关系：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">virt addr = linear addr = phy addr + <span class="hljs-number">0xC0000000</span><br></code></pre></div></td></tr></table></figure>

<h4 id="最开始-链接脚本"><a href="#最开始-链接脚本" class="headerlink" title="最开始: 链接脚本"></a>最开始: 链接脚本</h4><p>tools/kernel.ld文件在lab1和lab2中的区别。在lab1中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">ENTRY(kern_init)<br><br>SECTIONS &#123;<br>            /* Load the kernel at this address: &quot;.&quot; means the current address */<br>            . = 0x100000;<br><br>            .text : &#123;<br>                       *(.text .stub .text.* .gnu.linkonce.t.*)<br>            &#125;<br></code></pre></div></td></tr></table></figure>

<p>这意味着在lab1中通过ld工具形成的ucore的起始虚拟地址从0x100000开始，注意：这个地址是虚拟地址。但由于lab1中建立的段地址映射关系为对等关系，所以ucore的物理地址也是从0x100000开始，而ucore的入口函数kern_init的起始地址。所以在lab1中虚拟地址、线性地址以及物理地址之间的映射关系如下：</p>
<figure class="highlight nim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nim">lab1: virt <span class="hljs-keyword">addr</span> = linear <span class="hljs-keyword">addr</span> = phy <span class="hljs-keyword">addr</span><br></code></pre></div></td></tr></table></figure>

<p>在lab2中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">ENTRY(kern_entry)<br><br>SECTIONS &#123;<br>            /* Load the kernel at this address: &quot;.&quot; means the current address */<br>            . = 0xC0100000;<br><br>            .text : &#123;<br>                        *(.text .stub .text.* .gnu.linkonce.t.*)<br>            &#125;<br></code></pre></div></td></tr></table></figure>

<p>这意味着lab2中通过ld工具形成的ucore的起始虚拟地址从0xC0100000开始，注意：这个地址也是虚拟地址。入口函数为kern_entry函数（在kern/init/entry.S中）。这与lab1有很大差别。但其实在lab1和lab2中，bootloader把ucore都放在了起始物理地址为0x100000的物理内存空间。<strong>这实际上说明了ucore在lab1和lab2中采用的地址映射不同。lab2在不同阶段有不同的虚拟地址、线性地址以及物理地址之间的映射关系。</strong> </p>
<p>也请注意，这个起始虚拟地址的变化其实并不会影响一般的跳转和函数调用，因为它们实际上是相对跳转。但是，对于绝对寻址的全局变量的引用，就需要用REALLOC宏(即将要重新计算的地址-0xC0100000)进行一些运算来确保地址是正确的。</p>
<h4 id="第一个阶段"><a href="#第一个阶段" class="headerlink" title="第一个阶段"></a>第一个阶段</h4><p>（开启保护模式，创建启动段表）是bootloader阶段，即从bootloader的start函数（在boot/bootasm.S中）到执行ucore kernel的kern_entry函数之前，其虚拟地址、线性地址以及物理地址之间的映射关系与lab1的一样，即：</p>
<figure class="highlight nim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nim">lab2 stage <span class="hljs-number">1</span>: virt <span class="hljs-keyword">addr</span> = linear <span class="hljs-keyword">addr</span> = phy <span class="hljs-keyword">addr</span><br></code></pre></div></td></tr></table></figure>

<h4 id="第二个阶段"><a href="#第二个阶段" class="headerlink" title="第二个阶段"></a>第二个阶段</h4><p>（创建初始页目录表，开启分页模式）从kern_entry函数开始，到pmm_init函数被执行之前。</p>
<p>编译好的ucore自带了一个**设置好的(就在entry.S里, 也不知道为什么要设置成两段映射)**页目录表和相应的页表，将0~4M的线性地址一一映射到物理地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">.align PGSIZE<br>__boot_pgdir:<br>.globl __boot_pgdir<br>    # map va 0 ~ 4M to pa 0 ~ 4M (temporary)<br>    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)<br>    # 这个左移两位是乘以4的意思, 即(PDE *)__boot_pgdir + PDX(KERNBASE), <br>    .space (KERNBASE &gt;&gt; PGSHIFT &gt;&gt; 10 &lt;&lt; 2) - (. - __boot_pgdir) # pad to the PDE of KERNBASE<br>    # map va KERNBASE + (0 ~ 4M) to pa 0 ~ 4M<br>    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)<br>    .space PGSIZE - (. - __boot_pgdir) # pad to PGSIZE<br><br>.set i, 0<br>__boot_pt1:<br>.rept 1024	# repeat 1024 times, a page table<br>    .long i * PGSIZE + (PTE_P | PTE_W)<br>    .set i, i + 1<br>.endr<br></code></pre></div></td></tr></table></figure>

<p>了解了一一映射的二级页表结构后，接下来就要使能分页机制了，这主要是通过几条汇编指令（在kern/init/entry.S中）实现的，主要做了两件事：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm"># load pa of boot pgdir<br>movl $REALLOC(__boot_pgdir), %eax<br>movl %eax, %cr3	# 1.把页目录表的起始地址存入CR3寄存器中；<br><br># enable paging<br>movl %cr0, %eax<br>orl $(CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_TS | CR0_EM | CR0_MP), %eax<br>andl $~(CR0_TS | CR0_EM), %eax<br>movl %eax, %cr0	# 2.把cr0中的CR0_PG标志位设置上。<br></code></pre></div></td></tr></table></figure>

<p>执行完这几条指令后，计算机系统进入了分页模式！虚拟地址、线性地址以及物理地址之间的临时映射关系为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">lab2 stage 2 before:<br>    virt addr = linear addr = phy addr # 线性地址在0~4MB之内三者的映射关系<br>    virt addr = linear addr = phy addr + 0xC0000000 # 线性地址在0xC0000000~0xC0000000+4MB之内三者的映射关系<br></code></pre></div></td></tr></table></figure>

<p>可以看到，其实仅仅比第一个阶段增加了下面一行的0xC0000000偏移的映射，并且作用范围缩小到了0~4M。在下一个阶段, 会将作用范围继续扩充到0~KMEMSIZE。</p>
<p>实际上这种映射限制了内核的大小。当内核大小超过预期的4MB （实际上是3M，因为内核从 0x100000开始编址）就可能导致打开分页之后内核crash，在某些试验中，也的确出现了这种情况。解决方法同样简单，就是正确填充更多的页目录项即可。</p>
<p>此时的内核（EIP）还在0~4M的低虚拟地址区域运行，而在之后，这个区域的虚拟内存是要给用户程序使用的。为此，需要使用一个绝对跳转来使内核跳转到高虚拟地址（代码在kern/init/entry.S中）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">    # update eip<br>    # now, eip = 0x1.....<br>    leal next, %eax<br>    # set eip = KERNBASE + 0x1.....<br>    jmp *%eax<br>next:<br></code></pre></div></td></tr></table></figure>

<p>跳转完毕后，通过把boot_pgdir[0]对应的第一个页目录表项（0~4MB）清零来取消了临时的页映射关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm"># unmap va 0 ~ 4M, it&#x27;s temporary mapping<br>xorl %eax, %eax<br>movl %eax, __boot_pgdir<br></code></pre></div></td></tr></table></figure>

<p>最终，离开这个阶段时，虚拟地址、线性地址以及物理地址之间的映射关系为：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">lab2 stage <span class="hljs-number">2</span>: virt addr = linear addr = phy addr + <span class="hljs-number">0xC0000000</span> <span class="hljs-comment"># 线性地址在0xC0000000~0xC0000000+4MB之内三者的映射关系</span><br></code></pre></div></td></tr></table></figure>

<p>总结来看，这一阶段的目的就是更新映射关系的同时将运行中的内核（EIP）从低虚拟地址“迁移”到高虚拟地址，而不造成伤害。</p>
<p>不过，这还不是我们期望的映射关系，因为它仅仅映射了0~4MB。对于段表而言，也缺少了运行ucore所需的用户态段描述符和TSS（段）描述符相应表项。</p>
<h4 id="第三个阶段"><a href="#第三个阶段" class="headerlink" title="第三个阶段"></a>第三个阶段</h4><p>（完善段表和页表）从pmm_init函数被调用开始。pmm_init函数将页目录表项补充完成（从0~4M扩充到0~KMEMSIZE）。然后，更新了段映射机制，使用了一个新的段表。这个新段表除了包括内核态的代码段和数据段描述符，还包括用户态的代码段和数据段描述符以及TSS（段）的描述符。理论上可以在第一个阶段，即bootloader阶段就将段表设置完全，然后在此阶段继续使用，但这会导致内核的代码和bootloader的代码产生过多的耦合，于是就有了目前的设计。</p>
<p>这时形成了我们期望的虚拟地址、线性地址以及物理地址之间的映射关系：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">lab2 stage <span class="hljs-number">3</span>: virt addr = linear addr = phy addr + <span class="hljs-number">0xC0000000</span><br></code></pre></div></td></tr></table></figure>

<p>段表相应表项和TSS也被设置妥当。</p>
<h3 id="自映射机制"><a href="#自映射机制" class="headerlink" title="自映射机制"></a>自映射机制</h3><p><strong>4GB内存都有用到吗?</strong> </p>
<p>众所周知, 从物理地址空间中的每一个block分配page table之后(在default_init_memmap完成), 虚拟地址空间是一片连续的空间, 从0xC0000000开始, 大小为0x38000000=896MB, 并没有用完全部4GB的地址空间, 这只是一个设定, 可以根据情况进行改变.<br>memlayout.h中定义了常量</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNBASE 0xC0000000</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KMEMSIZE 0x38000000 <span class="hljs-comment">// the maximum amount of physical memory</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNTOP (KERNBASE + KMEMSIZE)</span><br><span class="hljs-comment">//------------------------------</span><br>define VPT	<span class="hljs-number">0xFAC00000</span><br></code></pre></div></td></tr></table></figure>

<p><strong>自映射是什么?</strong> </p>
<p>注意到每一个4KB页表中有1k个4B的pte, 每个pte指向物理空间中4KB的page, 整个page table指向了虚拟空间中4MB大小的pages. 如果我们把映射4GB空间的4MB页表放在4MB对齐的虚拟地址处, 那么可以想到有一个页表刚好映射他所在的4MB区域, 于是就充当了页目录表的功能.</p>
<p>具体而言，ucore是这样设计的，首先设置了一个常量（memlayout.h）：</p>
<p>VPT=<strong>0xFAC00000</strong>， 这个地址的二进制表示为：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1111</span> <span class="hljs-number">1010</span> <span class="hljs-number">11</span>|<span class="hljs-number">00</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span>| <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span>	<span class="hljs-comment">//管道符号表示虚拟地址的三个部分</span><br></code></pre></div></td></tr></table></figure>

<p>高10位为1111 1010 11，即10进制的1003，中间10位为0，低12位也为0。在pmm.c中有两个全局初始化变量</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">pte_t</span> * <span class="hljs-keyword">const</span> vpt = (<span class="hljs-keyword">pte_t</span> *)VPT;<br><span class="hljs-keyword">pde_t</span> * <span class="hljs-keyword">const</span> vpd = (<span class="hljs-keyword">pde_t</span> *)PGADDR(PDX(VPT), PDX(VPT), <span class="hljs-number">0</span>);	<span class="hljs-comment">//这个宏用来拼接虚拟地址</span><br></code></pre></div></td></tr></table></figure>

<p>并在pmm_init函数执行了如下语句：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;<br></code></pre></div></td></tr></table></figure>

<p>这些变量和语句有何特殊含义呢？<strong>其实vpd变量的值就是页目录表的起始虚地址0xFAFEB000</strong>，且它的高10位和中10位是相等的，都是10进制的1003。当执行了上述语句，就确保了vpd变量的值就是页目录表的起始虚地址，且vpt是页目录表中第一个目录表项指向的页表的起始虚地址。此时描述内核虚拟空间的页目录表的虚地址为0xFAFEB000，大小为4KB。页表的理论连续虚拟地址空间0xFAC00000~0xFB000000，大小为4MB。因为这个连续地址空间的大小为4MB，可有1M个PTE，即可映射4GB的地址空间。</p>
<p><strong>有什么好处?</strong> </p>
<p>在页机制建立好后, 如果我们这时需要按虚拟地址的地址顺序显示整个页目录表和页表的内容，则要查找页目录表的页目录表项内容，根据页目录表项内容找到页表的物理地址**(pdt和pt为什么存放的是物理地址?)**，再转换成对应的虚地址，然后访问页表的虚地址，搜索整个页表的每个页目录项。这样过程比较繁琐。</p>
<p>但是利用以上的方法, 通过连续扫描这特定的4MB虚拟地址空间，就很容易访问每个页目录表项和页表项内容。</p>
<p>在pmm.c中的函数<code>print_pgdir</code>就是基于ucore的页表自映射方式完成了对整个页目录表和页表的内容扫描和打印。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//print_pgdir - print the PDT&amp;PT</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">print_pgdir</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    cprintf(<span class="hljs-string">&quot;-------------------- BEGIN --------------------\n&quot;</span>);<br>    <span class="hljs-keyword">size_t</span> left, right = <span class="hljs-number">0</span>, perm;<br>    <span class="hljs-comment">//找出一个页目录表权限相同的range, 存在left和right中</span><br>    <span class="hljs-keyword">while</span> ((perm = get_pgtable_items(<span class="hljs-number">0</span>, NPDEENTRY, right, vpd, &amp;left, &amp;right)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//几个数字分别代表range中条目数量,虚地址范围,大小,权限</span><br>        cprintf(<span class="hljs-string">&quot;PDE(%03x) %08x-%08x %08x %s\n&quot;</span>, right - left,<br>                left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));<br>        <span class="hljs-keyword">size_t</span> l, r = left * NPTEENTRY;<br>        <span class="hljs-keyword">while</span> ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &amp;l, &amp;r)) != <span class="hljs-number">0</span>) &#123;<br>            cprintf(<span class="hljs-string">&quot;  |-- PTE(%05x) %08x-%08x %08x %s\n&quot;</span>, r - l,<br>                    l * PGSIZE, r * PGSIZE, (r - l) * PGSIZE, perm2str(perm));<br>        &#125;<br>    &#125;<br>    cprintf(<span class="hljs-string">&quot;--------------------- END ---------------------\n&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="练习3-2"><a href="#练习3-2" class="headerlink" title="练习3+2"></a>练习3+2</h2><h3 id="练习一-1"><a href="#练习一-1" class="headerlink" title="练习一"></a>练习一</h3><blockquote>
<p>实现 first-fit 连续物理内存分配算法</p>
</blockquote>
<ul>
<li>简单的修改了几个函数, 甚至不用全都改, 不过free函数我调试了好久</li>
</ul>
<h4 id="default-init-memmap"><a href="#default-init-memmap" class="headerlink" title="default_init_memmap"></a>default_init_memmap</h4><ul>
<li><p>该函数将新页面插入链表时，没有按照地址顺序插入</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">list_add(&amp;free_list, &amp;(base-&gt;page_link));<br></code></pre></div></td></tr></table></figure></li>
<li><p>故需要修改该行代码，使其按地址顺序插入至双向链表中。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">list_add_before(&amp;free_list, &amp;(base-&gt;page_link));<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h4 id="default-alloc-pages"><a href="#default-alloc-pages" class="headerlink" title="default_alloc_pages"></a>default_alloc_pages</h4><ul>
<li><p>在原先的代码中，当获取到了一个大小足够大的页面地址时，程序会先将该页头从链表中断开，切割，并将剩余空间放回链表中。但将<em>剩余空间放回链表</em>时，并没有按照地址顺序插入链表。</p>
<blockquote>
<p>连续空闲页面中的第一个页称为页头，page header。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (page != <span class="hljs-literal">NULL</span>) &#123;<br>    list_del(&amp;(page-&gt;page_link));<br>    <span class="hljs-keyword">if</span> (page-&gt;property &gt; n) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">p</span> =</span> page + n;<br>        p-&gt;property = page-&gt;property - n;<br>        <span class="hljs-comment">// 注意这一步</span><br>        list_add(&amp;free_list, &amp;(p-&gt;page_link));<br>    &#125;<br>    nr_free -= n;<br>    ClearPageProperty(page);<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li><p>以下是修改后的代码</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (page != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-keyword">if</span> (page-&gt;property &gt; n) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">p</span> =</span> page + n;<br>        p-&gt;property = page-&gt;property - n;<br>        SetPageProperty(p);<br>        <span class="hljs-comment">// 注意这一步add after</span><br>        list_add_after(&amp;(page-&gt;page_link), &amp;(p-&gt;page_link));<br>    &#125;<br>    list_del(&amp;(page-&gt;page_link));<br>    nr_free -= n;<br>    ClearPageProperty(page);<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h4 id="default-free-pages"><a href="#default-free-pages" class="headerlink" title="default_free_pages"></a>default_free_pages</h4><ul>
<li><p>该函数默认会在函数末尾处，将待释放的页头插入至链表的第一个节点。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">list_add(&amp;free_list, &amp;(base-&gt;page_link));<br></code></pre></div></td></tr></table></figure></li>
<li><p>所以我们需要修改这部分代码，使其按地址顺序插入至对应的链表结点处。</p>
<p>可以在循环中记录比这个page地址小的free_page, 而且还要设置标记来表明是否有这么一个page, 具体参见源码</p>
</li>
</ul>
<h3 id="练习二-1"><a href="#练习二-1" class="headerlink" title="练习二"></a>练习二</h3><blockquote>
<p><strong>实现寻找虚拟地址对应的页表项</strong>.</p>
</blockquote>
<blockquote>
<p>通过设置页表和对应的页表项，可建立虚拟内存地址和物理内存地址的对应关系。</p>
<p>其中的<code>get_pte</code>函数是设置页表项环节中的一个重要步骤。此函数找到一个虚地址对应的二级页表项的内核虚地址，如果此二级页表项不存在，则分配一个包含此项的二级页表。</p>
</blockquote>
<p>以下为实现的代码</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">pte_t</span> * <span class="hljs-title">get_pte</span><span class="hljs-params">(<span class="hljs-keyword">pde_t</span> *pgdir, <span class="hljs-keyword">uintptr_t</span> la, <span class="hljs-keyword">bool</span> create)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取传入的线性地址中所对应的页目录条目的物理地址</span><br>    <span class="hljs-keyword">pde_t</span> *pdep = PDX(la) + pgdir;<br>    <span class="hljs-comment">// 如果该条目不可用(not present)</span><br>    <span class="hljs-keyword">if</span> (!(*pdep &amp; PTE_P)) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page</span>;</span><br>        <span class="hljs-comment">// 如果分配页面失败，或者不允许分配，则返回NULL</span><br>        <span class="hljs-keyword">if</span> (!create || (page = alloc_page()) == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 设置该物理页面的引用次数为1</span><br>        set_page_ref(page, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 获取当前物理页面所管理的物理地址</span><br>        <span class="hljs-keyword">uintptr_t</span> pa = page2pa(page);<br>        <span class="hljs-comment">// 清空该物理页面的数据。需要注意的是使用虚拟地址</span><br>        <span class="hljs-built_in">memset</span>(KADDR(pa), <span class="hljs-number">0</span>, PGSIZE);<br>        <span class="hljs-comment">// 将新分配的页面设置为当前缺失的页目录条目中</span><br>        <span class="hljs-comment">// 之后该页面就是其中的一个二级页面</span><br>        *pdep = pa | PTE_U | PTE_W | PTE_P;<br>    &#125;<br>    <span class="hljs-comment">// 返回在pgdir中对应于la的二级页表项, 注意是虚拟地址, 因为返回一个物理地址也没啥用, cpu操作不了</span><br>    <span class="hljs-keyword">pte_t</span> *ptep = (<span class="hljs-keyword">pte_t</span> *)KADDR(PDE_ADDR(*pdep)) + PTX(la);<br>    <span class="hljs-keyword">return</span> ptep; <br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li><p>请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。</p>
<blockquote>
<p>请查看<a href="#vpt&pdt">虚拟页表结构</a></p>
</blockquote>
</li>
<li><p>如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？</p>
<ul>
<li>将引发页访问异常的地址将被保存在cr2寄存器中</li>
<li>设置错误代码</li>
<li>引发Page Fault，将外存的数据换到内存中</li>
<li>进行上下文切换，退出中断，返回到中断前的状态</li>
</ul>
</li>
</ul>
<h3 id="练习三-1"><a href="#练习三-1" class="headerlink" title="练习三"></a>练习三</h3><blockquote>
<p>释放某虚地址所在的页并取消对应二级页表项的映射</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (*ptep &amp; PTE_P) <span class="hljs-comment">//(1) check if this page table entry is present</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page</span> =</span> pte2page(*ptep); <span class="hljs-comment">//(2) find corresponding page to pte</span><br><br>    <span class="hljs-keyword">if</span> (page_ref_dec(page) == <span class="hljs-number">0</span>) <span class="hljs-comment">//(3) decrease page reference</span><br>    &#123;<br>        free_page(page); <span class="hljs-comment">//(4) and free this page when page reference reachs 0</span><br>    &#125;<br>    *ptep = <span class="hljs-number">0</span>;                 <span class="hljs-comment">//(5) clear second page table entry</span><br>    tlb_invalidate(pgdir, la); <span class="hljs-comment">//(6) flush tlb</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>两个问题:</p>
<p class="note note-primary"style="font-style:italic;background-color:rgb(240,230,250)">数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？</p>

<p>CPU如果要访问内存地址, 送出CPU的肯定是虚拟地址, 经过MMU的转换完成虚拟地址到物理地址的转换.</p>
<p>在MMU中, 取出虚拟地址高10位和%cr3拼接成页目录表条目(pdte), 读取出内存中的页目录表(或者在MMU中的TLB)所存储的页表物理地址, 然后发送这个物理地址+虚拟地址中间十位到内存中访问到页表条目, 读出所在page的物理地址, 然后再和虚拟地址低12位拼接成物理地址到内存中访问. </p>
<p>如果没有TLB, 这中间会有多次访存:</p>
<ol>
<li>为读取目录项而访问主存。</li>
<li>为读取页表项而访问主存。</li>
<li>为读取操作数或指令而访问主存。</li>
</ol>
<p>回答本文章中的一个问题: <strong>为什么页目录表和页表存储的是对应的物理地址而不是虚拟地址?</strong> </p>
<p>原因也明了了, 这两个表就是MMU和内存合作完成虚拟地址到物理地址转换的基础, 而虚拟地址是在内核中使用的一个抽象连续空间的地址, 和MMU关系不大, 更不必往表项里存储虚拟地址, 何况这么做还会导致递归查找<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="即原先查找页目录表的目的是想将某个线性地址转换为物理地址，但如果页目录表中存放的是二级页表的线性地址，则需要先查找该二级页表的物理地址，此时需要递归查找，这可能会出现永远也查找不到物理地址的情况。
">[1]</span></a></sup> </p>
<p class="note note-primary" style="font-style:italic;background-color:rgb(240,230,250)">如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？ 鼓励通过编程来具体完成这个问题 </p>

<ul>
<li><p>将<code>labcodes/lab2/tools/kernel.ld</code>中的加载地址从<code>0xC0100000</code>修改为<code>0x0</code></p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 修改前</span><br>. = <span class="hljs-number">0xC0100000</span>;<br><span class="hljs-comment">// 修改后</span><br>. = <span class="hljs-number">0x0</span>;<br></code></pre></div></td></tr></table></figure></li>
<li><p>将<code>mm/</code>中的内核偏移地址修改为0</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 修改前</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNBASE            0xC0000000</span><br><span class="hljs-comment">// 修改后</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNBASE            0x0</span><br></code></pre></div></td></tr></table></figure></li>
<li><p>最后一步，但也是必须要做的一步——<strong>关闭页机制</strong>。将开启页机制的那一段代码删除或注释掉最后一句即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm"># 修改后<br>movl %cr0, %eax<br>orl $(CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_TS | CR0_EM | CR0_MP), %eax<br>andl $~(CR0_TS | CR0_EM), %eax<br># 注释了最后一句<br># movl %eax, %cr0<br></code></pre></div></td></tr></table></figure></li>
<li><p>需要注意的是，需要把开启页表关闭，否则会报错，**因为页表开启时认为偏移量不为0(有待考证)**。</p>
</li>
</ul>
<h3 id="拓展练习-1"><a href="#拓展练习-1" class="headerlink" title="拓展练习"></a>拓展练习</h3><h4 id="Challenge-1"><a href="#Challenge-1" class="headerlink" title="Challenge 1"></a>Challenge 1</h4><blockquote>
<p><strong>buddy system（伙伴系统）分配算法, <a target="_blank" rel="noopener" href="http://coolshell.cn/articles/10427.html">伙伴分配器的一个极简实现</a> <a target="_blank" rel="noopener" href="https://github.com/wuwenbin/buddy2/blob/master/buddy2.c">具体实现</a></strong></p>
<p>Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128…</p>
</blockquote>
<p>经过一番思考, 属于是没搞懂用在这里的优势在哪, 分配的时候得遍历一遍双向链表, 找到了再分割, 和FIFO没啥区别, 释放时稍微有一点优势,  但最主要的问题是如果内存探测弄出的block很多的话也就只有略微有一点优势, 至于用双向链表而不是二叉树就更离谱了, 不如不写</p>
<h4 id="Challenge-2"><a href="#Challenge-2" class="headerlink" title="Challenge 2"></a>Challenge 2</h4><blockquote>
<p>slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。</p>
<ul>
<li>参考<a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/linux/l-cn-slub/">linux的slub分配算法/</a>，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。</li>
</ul>
</blockquote>
<h1 id="Lab3"><a href="#Lab3" class="headerlink" title="Lab3"></a>Lab3</h1><h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><h3 id="0-项目组成"><a href="#0-项目组成" class="headerlink" title="0.项目组成"></a>0.项目组成</h3><p>相对与实验二，实验三主要改动如下：</p>
<ul>
<li>kern/mm/default_pmm.[ch]：实现基于struct pmm_manager类框架的Fist-Fit物理内存分配参考实现（分配最小单位为页，即4096字节），相关分配页和释放页等实现会间接被kmalloc/kfree等函数使用。</li>
<li>kern/mm/pmm.[ch]：pmm.h定义物理内存分配类框架struct pmm_manager。pmm.c包含了对此物理内存分配类框架的访问，以及与建立、修改、访问页表相关的各种函数实现。在本实验中会用到kmalloc/kfree等函数。</li>
<li>libs/list.h：定义了通用双向链表结构以及相关的查找、插入等基本操作，这是建立基于链表方法的物理内存管理（以及其他内核功能）的基础。在lab0文档中有相关描述。其他有类似双向链表需求的内核功能模块可直接使用list.h中定义的函数。在本实验中会多次用到插入，删除等操作函数。</li>
<li>kern/driver/ide.[ch]：定义和实现了内存页swap机制所需的磁盘扇区的读写操作支持；在本实验中会涉及通过swapfs_*函数间接使用文件中的函数。故了解即可。</li>
<li>kern/fs/*：定义和实现了内存页swap机制所需从磁盘读数据到内存页和写内存数据到磁盘上去的函数 swapfs_read/swapfs_write。在本实验中会涉及使用这两个函数。</li>
<li>kern/mm/memlayout.h：修改了struct Page，增加了两项pra_*成员结构，其中pra_page_link可以用来建立描述各个页访问情况（比如根据访问先后）的链表。在本实验中会涉及使用这两个成员结构，以及le2page等宏。</li>
<li>kern/mm/vmm.[ch]：vmm.h描述了mm_struct，vma_struct等表述可访问的虚存地址访问的一些信息，下面会进一步详细讲解。vmm.c涉及mm,vma结构数据的创建/销毁/查找/插入等函数，这些函数在check_vma、check_vmm等中被使用，理解即可。而page fault处理相关的do_pgfault函数是本次实验需要涉及完成的。</li>
<li>kern/mm/swap.[ch]：定义了实现页替换算法类框架struct swap_manager。swap.c包含了对此页替换算法类框架的初始化、页换入/换出等各种函数实现。重点是要理解何时调用swap_out和swap_in函数。和如何在此框架下连接具体的页替换算法实现。check_swap函数以及被此函数调用的_fifo_check_swap函数完成了对本次实验中的练习2：FIFO页替换算法基本正确性的检查，可了解，便于知道为何产生错误。</li>
<li>kern/mm/swap_fifo.[ch]：FIFO页替换算法的基于页替换算法类框架struct swap_manager的简化实现，主要被swap.c的相关函数调用。重点是_fifo_map_swappable函数（可用于建立页访问属性和关系，比如访问时间的先后顺序）和_fifo_swap_out_victim函数（可用于实现挑选出要换出的页），当然换出哪个页需要借助于fifo_map_swappable函数建立的某种属性关系，已选出合适的页。</li>
<li>kern/mm/mmu.h：其中定义了页表项的各种属性位，比如PTE_P\PET_D\PET_A等，对于实现扩展实验的clock算法会有帮助。</li>
</ul>
<p>本次实验的主要练习集中在vmm.c中的do_pgfault函数和swap_fifo.c中的_fifo_map_swappable函数、_fifo_swap_out_victim函数。</p>
<h3 id="1-实验执行流程概述"><a href="#1-实验执行流程概述" class="headerlink" title="1.实验执行流程概述"></a>1.实验执行流程概述</h3><p>首先是初始化过程。参考ucore总控函数init的代码，可以看到在调用完成虚拟内存初始化的vmm_init函数之前，需要首先调用pmm_init函数完成物理内存的管理，这也是我们lab2已经完成的内容。接着是执行中断和异常相关的初始化工作，即调用pic_init函数和idt_init函数等，这些工作与lab1的中断异常初始化工作的内容是相同的。</p>
<p>在调用完idt_init函数之后，将进一步调用三个lab3中才有的新函数vmm_init、ide_init和swap_init。这三个函数涉及了本次实验中的两个练习。第一个函数vmm_init是检查我们的练习1是否正确实现了。为了表述不在物理内存中的“合法”虚拟页，需要有数据结构来描述这样的页，为此ucore建立了mm_struct和vma_struct数据结构（接下来的小节中有进一步详细描述），假定我们已经描述好了这样的“合法”虚拟页，当ucore访问这些“合法”虚拟页时，会由于没有虚实地址映射而产生页访问异常。如果我们正确实现了练习1，则do_pgfault函数会申请一个空闲物理页，并建立好虚实映射关系，从而使得这样的“合法”虚拟页有实际的物理页帧对应。这样练习1就算完成了。</p>
<p>ide_init和swap_init是为练习2准备的。由于页面置换算法的实现存在对硬盘数据块的读写，所以ide_init就是完成对用于页换入换出的硬盘（简称swap硬盘）的初始化工作。完成ide_init函数后，ucore就可以对这个swap硬盘进行读写操作了。swap_init函数首先建立swap_manager，swap_manager是完成页面替换过程的主要功能模块，其中包含了页面置换算法的实现（具体内容可参考5小节）。然后会进一步调用执行check_swap函数在内核中分配一些页，模拟对这些页的访问，这会产生页访问异常。如果我们正确实现了练习2，就可通过do_pgfault来调用swap_map_swappable函数来查询这些页的访问情况并间接调用实现页面置换算法的相关函数，把“不常用”的页换出到磁盘上。</p>
<h3 id="2-置换算法"><a href="#2-置换算法" class="headerlink" title="2.置换算法"></a>2.置换算法</h3><p>操作系统迟早会碰到没有内存空闲空间而必须要置换出内存中某个“不常用”的页的情况。如何判断内存中哪些是“常用”的页，哪些是“不常用”的页，把“常用”的页保持在内存中，在物理内存空闲空间不够的情况下，把“不常用”的页置换到硬盘上就是页替换算法着重考虑的问题。容易理解，一个好的页替换算法会导致页访问异常次数少，也就意味着访问硬盘的次数也少，从而使得应用程序执行的效率就高。本次实验涉及的页替换算法（包括扩展练习）：</p>
<ul>
<li>先进先出(First In First Out, FIFO)页替换算法：该算法总是淘汰最先进入内存的页，即选择在内存中驻留时间最久的页予以淘汰。只需把一个应用程序在执行过程中已调入内存的页按先后次序链接成一个队列，队列头指向内存中驻留时间最久的页，队列尾指向最近被调入内存的页。这样需要淘汰页时，从队列头很容易查找到需要淘汰的页。FIFO算法只是在应用程序按线性顺序访问地址空间时效果才好，否则效率不高。因为那些常被访问的页，往往在内存中也停留得最久，结果它们因变“老”而不得不被置换出去。FIFO算法的另一个缺点是，它有一种异常现象（Belady现象），即在增加放置页的页帧的情况下，反而使页访问异常次数增多。</li>
<li>时钟（Clock）页替换算法：是LRU算法的一种近似实现。时钟页替换算法把各个页面组织成环形链表的形式，类似于一个钟的表面。然后把一个指针（简称当前指针）指向最老的那个页面，即最先进来的那个页面。另外，时钟算法需要在页表项（PTE）中设置了一位访问位来表示此页表项对应的页当前是否被访问过。当该页被访问时，CPU中的MMU硬件将把访问位置“1”。当操作系统需要淘汰页时，对当前指针指向的页所对应的页表项进行查询，如果访问位为“0”，则淘汰该页，如果该页被写过，则还要把它换出到硬盘上；如果访问位为“1”，则将该页表项的此位置“0”，继续访问下一个页。该算法近似地体现了LRU的思想，且易于实现，开销少，需要硬件支持来设置访问位。时钟页替换算法在本质上与FIFO算法是类似的，不同之处是在时钟页替换算法中跳过了访问位为1的页。</li>
<li>改进的时钟（Enhanced Clock）页替换算法：在时钟置换算法中，淘汰一个页面时只考虑了页面是否被访问过，但在实际情况中，还应考虑被淘汰的页面是否被修改过。因为<strong>淘汰修改过的页面还需要写回硬盘(迷惑, 移到swap分区跟是否修改过有什么关系)<strong>，使得其置换代价大于未修改过的页面，所以优先淘汰没有修改的页，减少磁盘操作次数。改进的时钟置换算法除了考虑页面的访问情况，还需考虑页面的修改情况。即该算法不但希望淘汰的页面是最近未使用的页，而且还希望被淘汰的页是在主存驻留期间其页面内容未被修改过的。这需要为每一页的对应页表项内容中增加一位引用位和一位修改位。当该页被访问时，CPU中的MMU硬件将把访问位置“1”。当该页被“写”时，CPU中的MMU硬件将把修改位置“1”。这样这两位就存在四种可能的组合情况：（0，0）表示最近未被引用也未被修改，首先选择此页淘汰；（0，1）最近未被使用，但被修改，其次选择；（1，0）最近使用而未修改，再次选择；（1，1）最近使用且修改，最后选择。该算法与时钟算法相比，可进一步减少磁盘的I/O操作次数，但为了查找到一个尽可能适合淘汰的页面，</strong>可能需要经过多次扫描，增加了算法本身的执行开销</strong>。</li>
</ul>
<h3 id="3-相关数据结构"><a href="#3-相关数据结构" class="headerlink" title="3.相关数据结构"></a>3.相关数据结构</h3><blockquote>
<p>Typoar给我整了个崩溃, 我也崩溃了⊙▃⊙以下内容直至challenge前复制于<a target="_blank" rel="noopener" href="https://kiprey.github.io/2020/08/uCore-3/#3-uCore%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0">这里</a> </p>
</blockquote>
<h4 id="I-虚拟内存管理"><a href="#I-虚拟内存管理" class="headerlink" title="I. 虚拟内存管理"></a>I. 虚拟内存管理</h4><ul>
<li><p>结构体变量<code>check_mm_struct</code>用于管理虚拟内存页面，其结构体如下</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// the control struct for a set of vma using the same PDT</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> &#123;</span><br>    <span class="hljs-keyword">list_entry_t</span> mmap_list;        <span class="hljs-comment">// 按照虚拟地址顺序双向连接的虚拟页链表</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma_struct</span> *<span class="hljs-title">mmap_cache</span>;</span> <span class="hljs-comment">// 当前使用的虚拟页地址，该成员加速页索引速度。</span><br>    <span class="hljs-keyword">pde_t</span> *pgdir;                  <span class="hljs-comment">// 虚拟页对应的PDT</span><br>    <span class="hljs-keyword">int</span> map_count;                 <span class="hljs-comment">// 虚拟页个数</span><br>    <span class="hljs-keyword">void</span> *sm_priv;                 <span class="hljs-comment">// 用于指向swap manager的某个链表,在FIFO算法中，该双向链表用于将可交换的已分配物理页串起来</span><br>&#125;;<br></code></pre></div></td></tr></table></figure></li>
<li><p>当分配出新的虚拟页时，程序会执行<code>insert_vma_struct</code>函数，此时虚拟页<code>vma_struct</code>就会被插入<code>mm_struct::mmap_list</code>双向链表中。</p>
</li>
<li><p>若程序首次访问该内存而触发缺页中断时，程序会在缺页处理程序中为该虚拟页划分出一块新的物理页。同时，还会更新<code>mm_struct::pgdir</code>上的对应页表条目，之后该页的内存访问即可正常执行。</p>
</li>
<li><p>在FIFO页面置换算法中，初始时，<code>mm_struct</code>中的<code>sm_priv</code>会被设置为<code>pra_list_head</code>。而<code>pra_list_head</code>是一个双向链表的起始结点，该双向链表用于将<strong>可交换的已分配物理页</strong>串起来。</p>
</li>
</ul>
<h4 id="II-页面置换"><a href="#II-页面置换" class="headerlink" title="II. 页面置换"></a>II. 页面置换</h4><ul>
<li><p><code>swap_manager</code>与<code>pmm_manager</code>类似，都设置了一个用于管理某个功能的模块。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">swap_manager</span></span><br><span class="hljs-class">&#123;</span><br>     <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>     <span class="hljs-comment">/* Global initialization for the swap manager */</span><br>     <span class="hljs-keyword">int</span> (*init)            (<span class="hljs-keyword">void</span>);<br>     <span class="hljs-comment">/* Initialize the priv data inside mm_struct */</span><br>     <span class="hljs-keyword">int</span> (*init_mm)         (struct mm_struct *mm);<br>     <span class="hljs-comment">/* Called when tick interrupt occured */</span><br>     <span class="hljs-keyword">int</span> (*tick_event)      (struct mm_struct *mm);<br>     <span class="hljs-comment">/* Called when map a swappable page into the mm_struct */</span><br>     <span class="hljs-keyword">int</span> (*map_swappable)   (struct mm_struct *mm, <span class="hljs-keyword">uintptr_t</span> addr, struct Page *page, <span class="hljs-keyword">int</span> swap_in);<br>     <span class="hljs-comment">/* When a page is marked as shared, this routine is called to</span><br><span class="hljs-comment">      * delete the addr entry from the swap manager */</span><br>     <span class="hljs-keyword">int</span> (*set_unswappable) (struct mm_struct *mm, <span class="hljs-keyword">uintptr_t</span> addr);<br>     <span class="hljs-comment">/* Try to swap out a page, return then victim */</span><br>     <span class="hljs-keyword">int</span> (*swap_out_victim) (struct mm_struct *mm, struct Page **ptr_page, <span class="hljs-keyword">int</span> in_tick);<br>     <span class="hljs-comment">/* check the page relpacement algorithm */</span><br>     <span class="hljs-keyword">int</span> (*check_swap)(<span class="hljs-keyword">void</span>);<br>&#125;;<br></code></pre></div></td></tr></table></figure></li>
<li><p>若使用FIFO页面置换算法，则在缺页中断程序中，程序只会<strong>换入</strong>目标物理页，而不会主动换出。</p>
<p>只有在分配空闲物理页时，若<code>pmm_manager-&gt;alloc_pages(n)</code>失败，则程序才会执行一次页面换出，以腾出空闲的物理页，并重新分配。</p>
</li>
<li><p><code>swap_in</code>函数只会将目标物理页加载进内存中，而不会修改页表条目。所以相关的标志位设置必须在<code>swap_in</code>函数的外部手动处理。而<code>swap_out</code>函数会先执行<code>swap_out_victim</code>，找出最适合换出的物理页，并将其换出，最后刷新TLB, <strong>有可能换出多页</strong>。需要注意的是<code>swap_out</code>函数会在函数内部设置PTE，当某个页面被换出后，PTE会被设置为所换出物理页在硬盘上的偏移, 而且会执行<strong>free_page</strong>, 往空闲链表里面加入该page</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">cprintf(<span class="hljs-string">&quot;swap_out: i %d, store page in vaddr 0x%x to disk swap entry %d\n&quot;</span>, i, v, page-&gt;pra_vaddr/PGSIZE+<span class="hljs-number">1</span>);<br>*ptep = (page-&gt;pra_vaddr/PGSIZE+<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">8</span>;<br>free_page(page);<br></code></pre></div></td></tr></table></figure>

<p>当PTE所对应的物理页存在于内存中，那么该PTE就是正常的页表条目，可被CPU直接寻址用于转换地址。但当所对应的物理页不在内存时，该PTE就成为<code>swap_entry_t</code>，保存该物理页数据在外存的偏移位置。相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * swap_entry_t</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * |         offset        |   reserved   | 0 |</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> *           24 bits            7 bits    1 bit</span><br><span class="hljs-comment"> * /</span><br><span class="hljs-comment"> /* *</span><br><span class="hljs-comment"> * swap_offset - takes a swap_entry (saved in pte), and returns</span><br><span class="hljs-comment"> * the corresponding offset in swap mem_map.</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> swap_offset(entry) (&#123;                                       \</span><br><span class="hljs-meta">               size_t __offset = (entry &gt;&gt; 8);                        \</span><br><span class="hljs-meta">               <span class="hljs-meta-keyword">if</span> (!(__offset &gt; 0 &amp;&amp; __offset &lt; max_swap_offset)) &#123;    \</span><br><span class="hljs-meta">                    panic(<span class="hljs-meta-string">&quot;invalid swap_entry_t = %08x.\n&quot;</span>, entry);    \</span><br><span class="hljs-meta">               &#125;                                                    \</span><br><span class="hljs-meta">               __offset;                                            \</span><br><span class="hljs-meta">          &#125;)</span><br></code></pre></div></td></tr></table></figure></li>
<li><p>同时，不是所有物理页面都可以置换，例如内核关键代码和数据等等，所以在分配物理页时，需要对于那些可被置换的物理页执行<code>swap_map_swappable</code>函数，将该物理页加入到<code>mm_struct::sm_priv</code>指针所指向的双向链表中，换入和换出操作都会操作该链表（插入/移除<strong>可交换的已分配</strong>物理页）。</p>
</li>
<li><p>数据结构<code>Page</code>和<code>vma_struct</code>分别用于管理物理页和虚拟页，其结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 用于描述某个虚拟页的结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma_struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">vm_mm</span>;</span> <span class="hljs-comment">// 管理该虚拟页的mm_struct</span><br>    <span class="hljs-keyword">uintptr_t</span> vm_start;      <span class="hljs-comment">// 虚拟页起始地址，包括当前地址  </span><br>    <span class="hljs-keyword">uintptr_t</span> vm_end;        <span class="hljs-comment">// 虚拟页终止地址，不包括当前地址（地址前闭后开）  </span><br>    <span class="hljs-keyword">uint32_t</span> vm_flags;       <span class="hljs-comment">// 相关标志位</span><br>    <span class="hljs-keyword">list_entry_t</span> list_link;  <span class="hljs-comment">// 用于连接各个虚拟页的双向指针</span><br>&#125;;<br><br><span class="hljs-comment">// 数据结构Page相关成员的用途已在uCore-2中介绍过，这里只提它新增的两个成员pra_*</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> &#123;</span><br>    <span class="hljs-keyword">int</span> ref;<br>    <span class="hljs-keyword">uint32_t</span> flags;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> property;<br>    <span class="hljs-keyword">list_entry_t</span> page_link;<br>    <span class="hljs-keyword">list_entry_t</span> pra_page_link;     <span class="hljs-comment">// 用于连接上一个和下一个*可交换已分配*的物理页</span><br>    <span class="hljs-keyword">uintptr_t</span> pra_vaddr;            <span class="hljs-comment">// 用于保存该物理页所对应的虚拟地址。</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>当分配某个虚拟页<code>vma_struct</code>时，程序会在<code>insert_vma_struct</code>函数中设置其<code>vm_mm</code>成员为某个<code>mm_struct</code>，这样便于后续的管理。</li>
<li>在函数<code>pgdir_alloc_page</code>中，程序会设置<code>Page</code>的<code>pra_vaddr</code>成员，将其设置为当前物理页所对应的虚拟地址，之后便可通过<code>Page-&gt;pra_vaddr-&gt;pte</code>一条链，直接找到当前<strong>物理页</strong>地址所对应的PTE条目。同时，也可通过<code>pra_vaddr</code>来确定对应外存的相对偏移<code>page-&gt;pra_vaddr/PGSIZE+1</code>。</li>
<li><code>Page::page_link</code>用于将空闲物理页连接至双向链表中，而<code>page::pra_page_link</code>用于将<strong>可交换的已分配</strong>物理页连接至另一个双向链表中，注意两者的用途是不同的。</li>
</ul>
</li>
</ul>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="练习0"><a href="#练习0" class="headerlink" title="练习0"></a>练习0</h3><blockquote>
<p><strong>填写已有实验</strong> </p>
</blockquote>
<h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h3><blockquote>
<p><strong>给未被映射的地址映射上物理页</strong></p>
<p>完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限 的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制 结构所指定的页表，而不是内核的页表。</p>
</blockquote>
<p>实验代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">do_pgfault</span><span class="hljs-params">(struct mm_struct *mm, <span class="hljs-keyword">uint32_t</span> error_code, <span class="hljs-keyword">uintptr_t</span> addr)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret = -E_INVAL;<br>    <span class="hljs-comment">// 获取触发pgfault的虚拟地址所在虚拟页</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma_struct</span> *<span class="hljs-title">vma</span> =</span> find_vma(mm, addr);<br><br>    pgfault_num++;<br>    <span class="hljs-comment">// 如果当前访问的虚拟地址不在已经分配的虚拟页中</span><br>    <span class="hljs-keyword">if</span> (vma == <span class="hljs-literal">NULL</span> || vma-&gt;vm_start &gt; addr) &#123;\<br>        cprintf(<span class="hljs-string">&quot;not valid addr %x, and  can not find it in vma\n&quot;</span>, addr);<br>        <span class="hljs-keyword">goto</span> failed;<br>    &#125;<br>    <span class="hljs-comment">// 检测错误代码。这里的检测不涉及特权判断。</span><br>    <span class="hljs-keyword">switch</span> (error_code &amp; <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// 写，同时存在物理页，则写时复制</span><br>        <span class="hljs-comment">// 需要注意的是，default会执行case2的代码，也就是判断是否有写权限。</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        <span class="hljs-comment">// 同时如果当前操作是写入，但所在虚拟页不允许写入</span><br>        <span class="hljs-keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_WRITE)) &#123;<br>            cprintf(<span class="hljs-string">&quot;do_pgfault failed: error code flag = write AND not present, but the addr&#x27;s vma cannot write\n&quot;</span>);<br>            <span class="hljs-keyword">goto</span> failed;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">/* error code flag : (W/R=0, P=1): read, present */</span><br>        <span class="hljs-comment">// 读，同时存在物理页。那就不可能会调用page fault，肯定哪里有问题，直接failed</span><br>        cprintf(<span class="hljs-string">&quot;do_pgfault failed: error code flag = read AND present\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> failed;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">/* error code flag : (W/R=0, P=0): read, not present */</span><br>        <span class="hljs-comment">// 如果当前操作是读取，但所在虚拟页不允许读取或执行</span><br>        <span class="hljs-keyword">if</span> (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))) &#123;<br>            cprintf(<span class="hljs-string">&quot;do_pgfault failed: error code flag = read AND not present, but the addr&#x27;s vma cannot read or exec\n&quot;</span>);<br>            <span class="hljs-keyword">goto</span> failed;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 设置页表条目所对应的权限</span><br>    <span class="hljs-keyword">uint32_t</span> perm = PTE_U;<br>    <span class="hljs-keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE) &#123;<br>        perm |= PTE_W;<br>    &#125;<br>    addr = ROUNDDOWN(addr, PGSIZE);<br>    ret = -E_NO_MEM;<br>    <span class="hljs-keyword">pte_t</span> *ptep=<span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* LAB3 EXERCISE 1: YOUR CODE */</span><br>    <span class="hljs-comment">// 查找当前虚拟地址所对应的页表项</span><br>    <span class="hljs-keyword">if</span> ((ptep = get_pte(mm-&gt;pgdir, addr, <span class="hljs-number">1</span>)) == <span class="hljs-literal">NULL</span>) &#123;<br>        cprintf(<span class="hljs-string">&quot;get_pte in do_pgfault failed\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> failed;<br>    &#125;<br>    <span class="hljs-comment">// 如果这个页表项所对应的物理页不存在，则</span><br>    <span class="hljs-keyword">if</span> (*ptep == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 分配一块物理页，并设置页表项</span><br>        <span class="hljs-keyword">if</span> (pgdir_alloc_page(mm-&gt;pgdir, addr, perm) == <span class="hljs-literal">NULL</span>) &#123;<br>            cprintf(<span class="hljs-string">&quot;pgdir_alloc_page in do_pgfault failed\n&quot;</span>);<br>            <span class="hljs-keyword">goto</span> failed;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* LAB3 EXERCISE 2: YOUR CODE */</span><br>        <span class="hljs-comment">// 如果这个页表项所对应的物理页存在，但不在内存中</span><br>        <span class="hljs-comment">// 如果swap已经初始化完成</span><br>        <span class="hljs-keyword">if</span>(swap_init_ok) &#123;<br>            struct Page *page=<span class="hljs-literal">NULL</span>;<br>            <span class="hljs-comment">// 将目标数据加载到某块新的物理页中。</span><br>            <span class="hljs-comment">// 该物理页可能是尚未分配的物理页，也可能是从别的已分配物理页中取的</span><br>            <span class="hljs-keyword">if</span> ((ret = swap_in(mm, addr, &amp;page)) != <span class="hljs-number">0</span>) &#123;<br>                cprintf(<span class="hljs-string">&quot;swap_in in do_pgfault failed\n&quot;</span>);<br>                <span class="hljs-keyword">goto</span> failed;<br>            &#125;<br>            <span class="hljs-comment">// 将该物理页与对应的虚拟地址关联，同时设置页表。</span><br>            page_insert(mm-&gt;pgdir, page, addr, perm);<br>            <span class="hljs-comment">// 当前缺失的页已经加载回内存中，所以设置当前页为可swap。</span><br>            swap_map_swappable(mm, addr, page, <span class="hljs-number">1</span>);<br>            page-&gt;pra_vaddr = addr;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cprintf(<span class="hljs-string">&quot;no swap_init_ok but ptep is %x, failed\n&quot;</span>,*ptep);<br>            <span class="hljs-keyword">goto</span> failed;<br>        &#125;<br>   &#125;<br>   ret = <span class="hljs-number">0</span>;<br>failed:<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>关于<code>get_pte() and page_remove_pte() vs. page_inseret()</code>回顾: <ul>
<li>get pte and return the kernel virtual address of this pte for la, and if the PT contianing this pte didn’t exist, alloc a page for PT</li>
<li>page的插入和删除意味着page结构的ref增减以及pte的存在与否, 而实验为了弄出一个练习, 在<code>page_remove()</code>中判断pte不为空后调用<code>page_remove_pte()</code>, ref_dec and clear pte.</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。<ul>
<li>即PTE结构与其标志位用途</li>
</ul>
</li>
<li>如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？<ul>
<li>将发生错误的线性地址（虚拟地址）保存至CR2寄存器中。</li>
<li>压入<code>EFLAGS</code>，<code>CS</code>, <code>EIP</code>，错误码和中断号至当前内核栈中。</li>
<li>保存上下文。</li>
<li>执行新的缺页中断程序。</li>
<li>恢复上下文。</li>
<li>继续执行<strong>上一级</strong>的缺页服务例程。</li>
</ul>
</li>
</ul>
<h3 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h3><blockquote>
<p><strong>补充完成基于FIFO的页面替换算法</strong></p>
<p>完成vmm.c中的do_pgfault函数，并且在实现FIFO算法的swap_fifo.c中完成map_swappable和swap_out_victim函数。</p>
</blockquote>
<ul>
<li><p><code>FIFO</code>中，当新加入一个物理页时，我们只需将该物理页加入至链表首部即可。当需要换出某个物理页时，选择链表末尾的物理页即可。</p>
</li>
<li><p>相关实现如下</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span><br>_fifo_map_swappable(struct mm_struct *mm, <span class="hljs-keyword">uintptr_t</span> addr, struct Page   *page, <span class="hljs-keyword">int</span> swap_in)<br>&#123;<br>    <span class="hljs-keyword">list_entry_t</span> *head=(<span class="hljs-keyword">list_entry_t</span>*) mm-&gt;sm_priv;<br>    <span class="hljs-keyword">list_entry_t</span> *entry=&amp;(page-&gt;pra_page_link);<br><br>    assert(entry != <span class="hljs-literal">NULL</span> &amp;&amp; head != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">//record the page access situlation</span><br>    <span class="hljs-comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span><br>    <span class="hljs-comment">//(1)link the most recent arrival page at the back of the pra_list_head qeueue.</span><br>    list_add_before(head, entry);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span><br>_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, <span class="hljs-keyword">int</span> in_tick)<br>&#123;<br>     <span class="hljs-keyword">list_entry_t</span> *head=(<span class="hljs-keyword">list_entry_t</span>*) mm-&gt;sm_priv;<br>         assert(head != <span class="hljs-literal">NULL</span>);<br>     assert(in_tick==<span class="hljs-number">0</span>);<br>     <span class="hljs-comment">/* Select the victim */</span><br>     <span class="hljs-comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span><br>     <span class="hljs-comment">//(1)  unlink the  earliest arrival page in front of pra_list_head qeueue</span><br>     <span class="hljs-comment">//(2)  assign the value of *ptr_page to the addr of this page</span><br>     <span class="hljs-keyword">list_entry_t</span> *le = head-&gt;prev;<br>     assert(head!=le);<br>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">p</span> =</span> le2page(le, pra_page_link);<br>     list_del(le);<br>     assert(p !=<span class="hljs-literal">NULL</span>);<br>     *ptr_page = p;<br><br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li><p>如果要在ucore上实现”extended clock页替换算法”请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案。并需要回答如下问题</p>
<ul>
<li>现有的swap_manager框架可以支持在ucore中实现此算法，具体见<strong>扩展练习1</strong>。</li>
<li>需要被换出的页的特征是什么？<ul>
<li><code>PTE_P</code>(Present)和<code>PTE_D</code>(Dirty)位均为0。</li>
</ul>
</li>
<li>在ucore中如何判断具有这样特征的页？<ul>
<li>获取线性地址所对应的页表项，之后使用位运算判断<code>PTE_P</code>和<code>PTE_D</code>。</li>
</ul>
</li>
<li>何时进行换入和换出操作？<ul>
<li>缺页时换入。</li>
<li>物理页帧满时换出，不过需要注意dirty bit的处理。可以在修改dirty的时候写入外存，或者可以在最终要删除该物理页时再写入外存。后者有利于多个写操作的合并，降低缺页代价，但此时的页替换算法却退化成普通的clock算法，而不是extended clock算法了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="challenge1"><a href="#challenge1" class="headerlink" title="challenge1"></a>challenge1</h3><ul>
<li><p>需要注意的是extended clock算法会修改dirty bit, 但是swap.c中的swap_out()函数直接把<code>_fifo_swap_out_victim()</code>通过参数返回的page写入到磁盘swap分区中, <strong>根本不管有没有修改过</strong>, 或许可以改进</p>
</li>
<li><p>改进的时钟算法会修改dirty bit的原因可能是让被修改过的页面停留在内存中的时间更长, 因为要经过更多次的遍历才能被置换出</p>
</li>
<li><p>我寻思把PTE_D and PTE_A结合起来遍历到了就减一也没啥特别的, 而且下一次进入错误处理例程指针还是按照上次的接着继续(如果严格按照PPT上的话), 按别人的做法还要遍历三次当前swappable的页面, 遍历一次记录第一次遇到的00,10,11不就成了, 减少一点微不足道的写回时间(好像没有</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span><br>_extend_clock_swap_out_victim(struct mm_struct *mm, struct Page **ptr_page, <span class="hljs-keyword">int</span> in_tick)<br>&#123;<br>    <span class="hljs-keyword">list_entry_t</span> *head = (<span class="hljs-keyword">list_entry_t</span> *)mm-&gt;sm_priv;<br>    assert(head != <span class="hljs-literal">NULL</span>);<br>    assert(in_tick == <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//在head双向链表中从头开始遍历, 两个数字代表PTE_A PTE_D组成两位的样子</span><br>    <span class="hljs-comment">//用三个指针取第一次遍历到的page, 00优先级最高</span><br>    <span class="hljs-keyword">list_entry_t</span> *le = head-&gt;next, *_00 = <span class="hljs-literal">NULL</span>, *_10 = <span class="hljs-literal">NULL</span>, *_11 = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (le != head)<br>    &#123;<span class="hljs-comment">//只需遍历一次</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page</span> =</span> le2page(le, pra_page_link); <span class="hljs-comment">//字面意思</span><br><br>        <span class="hljs-keyword">pte_t</span> *ptep = get_pte(mm-&gt;pgdir, page-&gt;pra_vaddr, <span class="hljs-number">0</span>);<br>        assert(ptep != <span class="hljs-literal">NULL</span>);	<span class="hljs-comment">//写着意思一下, 也不知有啥用</span><br>        <span class="hljs-keyword">if</span> (!(*ptep &amp; PTE_A))<br>        &#123;<span class="hljs-comment">//遇到第一个00就可以直接break了, 受害者就是你!</span><br>            _00 = le;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<span class="hljs-comment">//剩下两种情况不能break(为了不写的更复杂</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(*ptep &amp; PTE_D) &amp;&amp; _10 == <span class="hljs-literal">NULL</span>)<br>            _10 = le;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_11 == <span class="hljs-literal">NULL</span>)<br>            _11 = le;<br>        le = le-&gt;next;<br>    &#125;<br>    le = _00 != <span class="hljs-literal">NULL</span> ? _00 : (_10 != <span class="hljs-literal">NULL</span> ? _10 : _11);<span class="hljs-comment">//根据优先级选一个不为零的</span><br>    *ptr_page = le2page(le, pra_page_link);<span class="hljs-comment">//把受害者的page赋值给这东西</span><br>    list_del(le);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>成了, 简化了一下没有什么用的改进时钟算法, 只要一次甚至不用完全的一次遍历即可做到相同效果, 还通过了fifo的检查, 有这么巧吗</p>
<blockquote>
<p>想了一下, 我这快简化成FIFO了, 而改进的时钟置换算法的优势在于<strong>相近的</strong>多次遍历之中, 被写过的页面可以在内存中驻留更久的时间</p>
<p>坑不填了, 问题就是这个意思没有很复杂</p>
</blockquote>
<h3 id="challenge2"><a href="#challenge2" class="headerlink" title="challenge2"></a>challenge2</h3><p>暂时不写</p>
<h1 id="Lab4"><a href="#Lab4" class="headerlink" title="Lab4"></a>Lab4</h1><h2 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h2><h3 id="0-项目组成-1"><a href="#0-项目组成-1" class="headerlink" title="0.项目组成"></a>0.项目组成</h3><p>相对与实验三，实验四中主要改动如下：</p>
<ul>
<li>kern/process/ （新增进程管理相关文件）<ul>
<li>proc.[ch]：新增：实现进程、线程相关功能，包括：创建进程/线程，初始化进程/线程，处理进程/线程退出等功能</li>
<li>entry.S：新增：内核线程入口函数kernel_thread_entry的实现</li>
<li>switch.S：新增：上下文切换，利用堆栈保存、恢复进程上下文</li>
</ul>
</li>
<li>kern/init/<ul>
<li>init.c：修改：完成进程系统初始化，并在内核初始化后切入idle进程</li>
</ul>
</li>
<li>kern/mm/ （基本上与本次实验没有太直接的联系，了解kmalloc和kfree如何使用即可）<ul>
<li>kmalloc.[ch]：新增：定义和实现了新的kmalloc/kfree函数。具体实现是基于slab分配的简化算法 （只要求会调用这两个函数即可）</li>
<li>memlayout.h：增加slab物理内存分配相关的定义与宏 （可不用理会）。</li>
<li>pmm.[ch]：修改：在pmm.c中添加了调用kmalloc_init函数,取消了老的kmalloc/kfree的实现；在pmm.h中取消了老的kmalloc/kfree的定义</li>
<li>swap.c：修改：取消了用于check的Line 185的执行</li>
<li>vmm.c：修改：调用新的kmalloc/kfree</li>
</ul>
</li>
<li>kern/trap/<ul>
<li>trapentry.S：增加了汇编写的函数forkrets，用于do_fork调用的返回处理。</li>
</ul>
</li>
<li>kern/schedule/<ul>
<li>sched.[ch]：新增：实现FIFO策略的进程调度</li>
</ul>
</li>
<li>kern/libs<ul>
<li>rb_tree.[ch]：新增：实现红黑树，被slab分配的简化算法使用（可不用理会）</li>
</ul>
</li>
</ul>
<h3 id="1-重要数据结构-link"><a href="#1-重要数据结构-link" class="headerlink" title="1.重要数据结构[link]"></a>1.重要数据结构<a target="_blank" rel="noopener" href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab4/lab4_3_2_pcb.html">[link]</a></h3><blockquote>
<p>这次的<a target="_blank" rel="noopener" href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab4/lab4_3_1_lab_steps.html">实验指导书</a>真绝, 写的是没法比那个好了, 就写点自己领悟到的流程吧</p>
</blockquote>
<p>为了管理系统中所有的进程控制块，uCore维护了如下全局变量（位于<em>kern/process/proc.c</em>）：</p>
<ul>
<li><code>static struct proc *current</code>：当前占用CPU且处于“运行”状态进程控制块指针。通常这个变量是只读的，只有在进程切换的时候才进行修改，并且整个切换和修改过程需要保证操作的原子性，目前至少需要屏蔽中断。可以参考 switch_to 的实现。</li>
<li><code>static struct proc *initproc</code>：本实验中，指向一个内核线程。本实验以后，此指针将指向第一个用户态进程。</li>
<li><code>static list_entry_t hash_list[HASH_LIST_SIZE]</code>：所有进程控制块的哈希表，proc_struct中的成员变量hash_link将基于pid链接入这个哈希表中。</li>
<li><code>list_entry_t proc_list</code>：所有进程控制块的双向线性列表，proc_struct中的成员变量list_link将链接入这个链表中。</li>
</ul>
<p>PCB好像有所简化:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">proc_state</span> &#123;</span><br>    PROC_UNINIT = <span class="hljs-number">0</span>,  <span class="hljs-comment">// 未初始化的     -- alloc_proc</span><br>    PROC_SLEEPING,    <span class="hljs-comment">// 等待状态       -- try_free_pages, do_wait, do_sleep</span><br>    PROC_RUNNABLE,    <span class="hljs-comment">// 就绪/运行状态   -- proc_init, wakeup_proc,</span><br>    PROC_ZOMBIE,      <span class="hljs-comment">// 僵死状态       -- do_exit</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> &#123;</span>  <span class="hljs-comment">// 保存的上下文寄存器，注意没有eax寄存器和段寄存器</span><br>    <span class="hljs-keyword">uint32_t</span> eip;<br>    <span class="hljs-keyword">uint32_t</span> esp;<br>    <span class="hljs-keyword">uint32_t</span> ebx;<br>    <span class="hljs-keyword">uint32_t</span> ecx;<br>    <span class="hljs-keyword">uint32_t</span> edx;<br>    <span class="hljs-keyword">uint32_t</span> esi;<br>    <span class="hljs-keyword">uint32_t</span> edi;<br>    <span class="hljs-keyword">uint32_t</span> ebp;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">proc_state</span> <span class="hljs-title">state</span>;</span>          <span class="hljs-comment">// 当前进程的状态</span><br>    <span class="hljs-keyword">int</span> pid;                        <span class="hljs-comment">// 进程ID</span><br>    <span class="hljs-keyword">int</span> runs;                       <span class="hljs-comment">// 当前进程被调度的次数</span><br>    <span class="hljs-keyword">uintptr_t</span> kstack;               <span class="hljs-comment">// 内核栈</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">bool</span> need_resched;     <span class="hljs-comment">// 是否需要被调度</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">parent</span>;</span>     <span class="hljs-comment">// 父进程ID</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span>;</span>           <span class="hljs-comment">// 当前进程所管理的虚拟内存页，包括其所属的页目录项PDT</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>         <span class="hljs-comment">// 保存的上下文</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">tf</span>;</span>           <span class="hljs-comment">// 中断所保存的上下文</span><br>    <span class="hljs-keyword">uintptr_t</span> cr3;                  <span class="hljs-comment">// 页目录表的地址</span><br>    <span class="hljs-keyword">uint32_t</span> flags;                 <span class="hljs-comment">// 当前进程的相关标志</span><br>    <span class="hljs-keyword">char</span> name[PROC_NAME_LEN + <span class="hljs-number">1</span>];   <span class="hljs-comment">// 进程名称（可执行文件名）</span><br>    <span class="hljs-keyword">list_entry_t</span> list_link;         <span class="hljs-comment">// 用于连接list</span><br>    <span class="hljs-keyword">list_entry_t</span> hash_link;         <span class="hljs-comment">// 用于连接hash list</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<h3 id="2-流程"><a href="#2-流程" class="headerlink" title="2.流程"></a>2.流程</h3><ul>
<li>首先肯定是<code>proc_init()</code>:</li>
</ul>
<p><img src="../../image/ucore/image-20211224212029857.png" srcset="/img/loading.gif" lazyload alt="image-20211224212029857"></p>
<ul>
<li><p>首先初始化一下<code>proc_list</code>和<code>hash_list</code>, 然后调用<code>alloc_proc()</code>来通过<code>kmalloc()</code>获取一个proc_struct的空间, 以及略微初始化一下第0个内核线程idleproc(指把状态设成PROC_UNINIT, pid设成-1等等)</p>
</li>
<li><p>接着真正初始化一下各个字段的值, 其中kstack直接设置成内核栈bootstack(前面给过出处, 内核栈总共8KB), 弄成current</p>
</li>
<li><p>接着调用kern_thread来创建第1个内核线程</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">kernel_thread(<span class="hljs-keyword">int</span> (*fn)(<span class="hljs-keyword">void</span> *), <span class="hljs-keyword">void</span> *arg, <span class="hljs-keyword">uint32_t</span> clone_flags)<br>&#123;	<span class="hljs-comment">//三个参数为init_main, &quot;Hello World!&quot;, 0</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> <span class="hljs-title">tf</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;tf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct trapframe));<br>    tf.tf_cs = KERNEL_CS;<br>    tf.tf_ds = tf_struct.tf_es = tf_struct.tf_ss = KERNEL_DS;<br>    tf.tf_regs.reg_ebx = (<span class="hljs-keyword">uint32_t</span>)fn;<br>    tf.tf_regs.reg_edx = (<span class="hljs-keyword">uint32_t</span>)arg;<br>    tf.tf_eip = (<span class="hljs-keyword">uint32_t</span>)kernel_thread_entry;<br>    <span class="hljs-keyword">return</span> do_fork(clone_flags | CLONE_VM, <span class="hljs-number">0</span>, &amp;tf);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>用局部变量在栈上保存trapframe, 全部设置成内核的段和栈</li>
<li>注意eip, 设置成了四行汇编的入口及退出代码, 效果相当于c语言main函数之前的准备函数</li>
<li>随后调用do_fork()进行线程的创建(主要根据trapframe)</li>
</ul>
</li>
<li><p>kern_thread中的do_fork()</p>
<ul>
<li><p>分配并初始化进程控制块（alloc_proc函数）</p>
</li>
<li><p>分配并初始化内核栈（setup_stack函数）,调用alloc_pages()分配2个(即<code>KSTACKPAGE</code>)page</p>
</li>
<li><p>根据clone_flag标志复制或共享进程内存管理结构（copy_mm函数）</p>
</li>
<li><p>设置进程在内核（将来也包括用户态）正常运行和调度所需的trapframe和执行context (<strong>copy_thread</strong>函数)</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">copy_thread</span><span class="hljs-params">(struct proc_struct *proc, <span class="hljs-keyword">uintptr_t</span> esp, struct trapframe *tf)</span> </span>&#123;<br>    <span class="hljs-comment">//在内核堆栈的顶部设置中断帧大小的一块栈空间</span><br>    <span class="hljs-comment">//这个减一就很灵性, 因为tf在栈上占据了空间, 所以栈指针下移</span><br>    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack + KSTACKSIZE) - <span class="hljs-number">1</span>;<br>    *(proc-&gt;tf) = *tf; <span class="hljs-comment">//拷贝在kernel_thread函数建立的临时中断帧的初始值</span><br>    proc-&gt;tf-&gt;tf_regs.reg_eax = <span class="hljs-number">0</span>;	<span class="hljs-comment">//设置子进程/线程执行完do_fork后的返回值</span><br>    proc-&gt;tf-&gt;tf_esp = esp; <span class="hljs-comment">//设置中断帧中的栈指针esp,因为我们复制了内存,直接使用父进程esp即可</span><br>    proc-&gt;tf-&gt;tf_eflags |= FL_IF; <span class="hljs-comment">//使能中断</span><br>    <br>    proc-&gt;context.eip = (<span class="hljs-keyword">uintptr_t</span>)forkret;	<span class="hljs-comment">//由调度器中的switch_to把这个push到栈上再ret来恢复执行</span><br>    <span class="hljs-comment">//这个proc-&gt;tf和esp有什么关系? 其实fork执行完后子进程仍然处于内核中中断处理例程的状态(由context决定)</span><br>    <span class="hljs-comment">//如果父进程刚好有一个wait, 那么就会调度子进程执行, 也就是执行fork_ret从中断退出以继续执行用户进程</span><br>    proc-&gt;context.esp = (<span class="hljs-keyword">uintptr_t</span>)(proc-&gt;tf);<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li><p>把设置好的进程控制块放入hash_list和proc_list两个全局进程链表中</p>
</li>
<li><p>自此，进程已经准备好执行了，把进程状态设置为“就绪”态；</p>
</li>
<li><p>设置返回码为子进程的id号。</p>
</li>
<li><p>此时可知init_proc的中断帧如下所示, 控制块记录着该线程的一切必要信息, 在内核态设置好了内核栈以及其上的trapframe, 如果是用户程序(应该在下一个实验中)只需执行一下中断返回的流程即可</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//所在地址位置</span><br>initproc-&gt;tf= (proc-&gt;kstack+KSTACKSIZE) – <span class="hljs-keyword">sizeof</span> (struct trapframe);<br><span class="hljs-comment">//具体内容</span><br>initproc-&gt;tf.tf_cs = KERNEL_CS;<br>initproc-&gt;tf.tf_ds = initproc-&gt;tf.tf_es = initproc-&gt;tf.tf_ss = KERNEL_DS;<br>initproc-&gt;tf.tf_regs.reg_ebx = (<span class="hljs-keyword">uint32_t</span>)init_main;<br>initproc-&gt;tf.tf_regs.reg_edx = (<span class="hljs-keyword">uint32_t</span>) ADDRESS of <span class="hljs-string">&quot;Helloworld!!&quot;</span>;<br>initproc-&gt;tf.tf_eip = (<span class="hljs-keyword">uint32_t</span>)kernel_thread_entry;<br>initproc-&gt;tf.tf_regs.reg_eax = <span class="hljs-number">0</span>;<br>initproc-&gt;tf.tf_esp = esp;<br>initproc-&gt;tf.tf_eflags |= FL_IF;<br></code></pre></div></td></tr></table></figure></li>
</ul>
</li>
<li><p>然后从kern_init()中永真循环的cpu_idle进入调度函数<strong>schedule</strong>(), 是很简单的FIFO, 注意要保证调度操作的atomicity, 即屏蔽中断, IF置零</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// cpu_idle - at the end of kern_init, the first kernel thread idleproc will do below works</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cpu_idle</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-keyword">if</span> (current-&gt;need_resched) &#123;<br>              schedule();<br>          &#125;&#125;&#125;<br></code></pre></div></td></tr></table></figure>

<p><img src="../../image/ucore/image-20211224232536016.png" srcset="/img/loading.gif" lazyload alt="image-20211224232536016"></p>
<ol>
<li>设置当前内核线程current-&gt;need_resched为0； <strong>(?</strong> </li>
<li>在proc_list队列中查找下一个处于“就绪”态的线程或进程<code>next</code>； </li>
<li>找到这样的进程后，就调用proc_run函数，保存当前进程current的执行现场（进程上下文），恢复新进程的执行现场，完成进程切换。</li>
</ol>
</li>
<li><p>proc_run比较重要:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">proc_run</span><span class="hljs-params">(struct proc_struct *proc)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (proc != current) &#123;<br>        <span class="hljs-keyword">bool</span> intr_flag;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">prev</span> =</span> current, *next = proc;<br>        local_intr_save(intr_flag); <br>        &#123;<br>            current = proc;<br>            load_esp0(next-&gt;kstack + KSTACKSIZE);	  <span class="hljs-comment">//在TSS中的ring0栈顶指针</span><br>            lcr3(next-&gt;cr3);						<span class="hljs-comment">//这实际上是完成进程间的页表切换；</span><br>            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));<br>        &#125;<br>        local_intr_restore(intr_flag);<br>&#125;&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>switch()比较特别,因为两个参数都是在内存中,然而并不能从内存直接读取到内存, 只能通过一段汇编来把prev的context通过%eax做媒介存入相应寄存器中, 这样context就建立完成了, 注意到eip被设置成forkrets, 就是在trap.S里的一段汇编, 而且重用了以前的代码</li>
<li><strong>调度完成后先执行forkret, 从栈上弹出entry的地址(和ebp等一起包含在tf中), 然后再执行用户的主函数fn(在这里是initmain)</strong> </li>
</ul>
</li>
<li><p>随后<strong>进程执行完毕后</strong>就返回到kernel_tread_entry函数，并进一步调用<strong>do_exit</strong>执行退出操作了。本来do_exit应该完成一些资源回收工作等，但这些不是实验四涉及的，而是由后续的实验来完成。</p>
</li>
</ul>
<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1-1"><a href="#练习1-1" class="headerlink" title="练习1"></a>练习1</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// alloc_proc - alloc a proc_struct and init all fields of proc_struct</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> struct proc_struct *</span><br><span class="hljs-function"><span class="hljs-title">alloc_proc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span> =</span> kmalloc(<span class="hljs-keyword">sizeof</span>(struct proc_struct));<br>    <span class="hljs-keyword">if</span> (proc != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(proc, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct proc_struct));<br>        proc-&gt;state = PROC_UNINIT;<br>        proc-&gt;pid = <span class="hljs-number">-1</span>;<br>        proc-&gt;cr3 = boot_cr3;<br>    &#125;<br>    <span class="hljs-keyword">return</span> proc;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>请说明proc_struct中<code>struct context context</code>和<code>struct trapframe *tf</code>成员变量含义和在本实验中的作用是啥？</p>
<ul>
<li>context的含义很简单, 就是该线程的上下文即必要的控制流信息, 作用是在proc_run()函数中调用的switch(汇编label)保存当前执行的线程, 然后恢复next线程的context</li>
<li>tf一开始在kern_thread中作为局部变量存在栈上, 设置好从中断返回(通过iret)时的控制流后调用do_fork(), 在do_fork中的copy_thread复制tf到新线程, 至此完成任务</li>
</ul>
<h3 id="练习2-1"><a href="#练习2-1" class="headerlink" title="练习2"></a>练习2</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* do_fork -     parent process for a new child process</span><br><span class="hljs-comment"> * @clone_flags: used to guide how to clone the child process</span><br><span class="hljs-comment"> * @stack:       the parent&#x27;s user stack pointer. if stack==0, It means to fork a kernel thread.</span><br><span class="hljs-comment"> * @tf:          the trapframe info, which will be copied to child process&#x27;s proc-&gt;tf</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">do_fork</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> clone_flags, <span class="hljs-keyword">uintptr_t</span> <span class="hljs-built_in">stack</span>, struct trapframe *tf)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ret = -E_NO_FREE_PROC;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span>;</span><br>    <span class="hljs-keyword">if</span> (nr_process &gt;= MAX_PROCESS)<br>    &#123;<br>        <span class="hljs-keyword">goto</span> fork_out;<br>    &#125;<br>    ret = -E_NO_MEM;<br>    <span class="hljs-comment">//    1. call alloc_proc to allocate a proc_struct</span><br>    <span class="hljs-comment">//    2. call setup_kstack to allocate a kernel stack for child process</span><br>    <span class="hljs-comment">//    3. call copy_mm to dup OR share mm according clone_flag</span><br>    <span class="hljs-comment">//    4. call copy_thread to setup tf &amp; context in proc_struct</span><br>    <span class="hljs-comment">//    5. insert proc_struct into hash_list &amp;&amp; proc_list</span><br>    <span class="hljs-comment">//    6. call wakeup_proc to make the new child process RUNNABLE</span><br>    <span class="hljs-comment">//    7. set ret vaule using child proc&#x27;s pid</span><br>    <span class="hljs-keyword">if</span> ((proc = alloc_proc()) == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        cprintf(<span class="hljs-string">&quot;alloc_proc() failed!&quot;</span>);<br>        <span class="hljs-keyword">goto</span> fork_out;<br>    &#125;<br>    proc-&gt;parent = current;<br>    <span class="hljs-keyword">if</span> ((ret = setup_kstack(proc)) != <span class="hljs-number">0</span>)<br>    &#123; <span class="hljs-comment">//call the alloc_pages to alloc kstack space</span><br>        cprintf(<span class="hljs-string">&quot;set_kstack() failed!&quot;</span>);<br>        <span class="hljs-keyword">goto</span> bad_fork_cleanup_proc;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (copy_mm(clone_flags, proc) != <span class="hljs-number">0</span>)<br>    &#123;<br>	cprintf(<span class="hljs-string">&quot;copy_mm() failed!&quot;</span>);<br>        <span class="hljs-keyword">goto</span> bad_fork_cleanup_kstack;<br>    &#125;<br>    copy_thread(proc, <span class="hljs-built_in">stack</span>, tf);<br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    local_intr_save(intr_flag);<br>    &#123;<span class="hljs-comment">//原来这里还要加上屏蔽中断, 应该是操作当前proc_struct需要一起完成</span><br>     <span class="hljs-comment">//防止某个中断服务例程用到的时候出现错误</span><br>        proc-&gt;pid = get_pid();<br>        hash_proc(proc);<br>        list_add(&amp;proc_list, &amp;(proc-&gt;list_link));<br>        nr_process++;<br>    &#125;<br>    local_intr_restore(intr_flag);<br>    wakeup_proc(proc);<br>    ret = proc-&gt;pid;<br>fork_out:<br>    <span class="hljs-keyword">return</span> ret;<br><br>bad_fork_cleanup_kstack:<br>    put_kstack(proc);<br>bad_fork_cleanup_proc:<br>    kfree(proc);<br>    <span class="hljs-keyword">goto</span> fork_out;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。</p>
<p>uCore中，每个新fork的线程都存在唯一的一个ID，理由如下：</p>
<ul>
<li><p>这一段代码相当于找出了一个初始为(MAX_PID,MAX_PID), 不满足条件时往pid大的方向查找的空闲区间(last_safe, next_safe),<br>只要<code>++last&lt;next</code>则自增后的last即为可分配的pid, 具体流程写进代码注释中</p>
</li>
<li><p>所以说通过维护一个可用PID的区间, 可以提高分配pid的效率</p>
</li>
<li><p><code>get_pid</code>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// get_pid - alloc a unique pid for process</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">get_pid</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static_assert</span>(MAX_PID &gt; MAX_PROCESS);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span>;</span><br>    <span class="hljs-keyword">list_entry_t</span> *<span class="hljs-built_in">list</span> = &amp;proc_list, *le;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> next_safe = MAX_PID, last_pid = MAX_PID;<br>    <span class="hljs-keyword">if</span> (++last_pid &gt;= MAX_PID)<br>    &#123;<span class="hljs-comment">//last自增后&gt;=MAX_PID, 从1重新开始, next设为MAX_PID, 待后续缩小范围</span><br>        last_pid = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">goto</span> inside;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (last_pid &gt;= next_safe)<br>    &#123;<span class="hljs-comment">//last自增后&gt;=next, 当前空闲区间**已用完**, 继续向后查找</span><br>    inside:<br>        next_safe = MAX_PID;<br>    repeat:<span class="hljs-comment">//这段代码看半天, 终于看出来是在遍历proc_list, 如果pid==last, last就++</span><br>        <span class="hljs-comment">//如果pid在last和next之间, 则next=pid以缩小范围.</span><br>        <span class="hljs-comment">//特殊情况: ++last&gt;next,则重启while循环, 并且if(++last&gt;MAX_PID)则重置last为1</span><br>        le = <span class="hljs-built_in">list</span>;<br>        <span class="hljs-keyword">while</span> ((le = list_next(le)) != <span class="hljs-built_in">list</span>)<br>        &#123;<br>            proc = le2proc(le, list_link);<br>            <span class="hljs-keyword">if</span> (proc-&gt;pid == last_pid)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (++last_pid &gt;= next_safe)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (last_pid &gt;= MAX_PID)<br>                    &#123;<br>                        last_pid = <span class="hljs-number">1</span>;<br>                    &#125;<br>                    next_safe = MAX_PID;<br>                    <span class="hljs-keyword">goto</span> repeat;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (proc-&gt;pid &gt; last_pid &amp;&amp; next_safe &gt; proc-&gt;pid)<br>            &#123;<br>                next_safe = proc-&gt;pid;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> last_pid;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h3 id="练习3"><a href="#练习3" class="headerlink" title="练习3"></a>练习3</h3><blockquote>
<p>理解proc_run</p>
</blockquote>
<p><strong>两个问题:</strong> </p>
<ul>
<li>在本实验的执行过程中，创建且运行了几个内核线程？<ul>
<li>两个</li>
</ul>
</li>
<li>语句<code>local_intr_save(intr_flag);....local_intr_restore(intr_flag);</code>在这里有何作用?请说明理由<ul>
<li>屏蔽中断</li>
<li>这两句的配合，使得这两句代码之间的代码块形成<strong>原子操作</strong>，可以使得某些关键的代码不会被打断，从而避免引起一些未预料到的错误，避免条件竞争。</li>
<li>以进程切换为例，在<code>proc_run</code>中，当刚设置好<code>current</code>指针为下一个进程，但还未完全将控制权转移时，如果该过程突然被一个中断所打断，则中断处理例程的执行可能会引发异常，因为<code>current</code>指针指向的进程与实际使用的进程资源不一致。</li>
</ul>
</li>
</ul>
<h3 id="challenge"><a href="#challenge" class="headerlink" title="challenge"></a>challenge</h3><blockquote>
<p>鸽!</p>
</blockquote>
<h1 id="Lab5"><a href="#Lab5" class="headerlink" title="Lab5"></a>Lab5</h1><h2 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h2><h3 id="0-项目结构"><a href="#0-项目结构" class="headerlink" title="0.项目结构"></a>0.项目结构</h3><p>相对与实验四，实验五主要改动如下：</p>
<p>◆ kern/debug/</p>
<p>kdebug.c：修改：解析用户进程的符号信息表示（可不用理会）</p>
<p>◆ kern/mm/ （与本次实验有较大关系）</p>
<p>memlayout.h：修改：增加了用户虚存地址空间的图形表示和宏定义 （需仔细理解）。</p>
<p>pmm.[ch]：修改：添加了用于进程退出（do_exit）的内存资源回收的page_remove_pte、unmap_range、exit_range函数和用于创建子进程（do_fork）中拷贝父进程内存空间的copy_range函数，修改了pgdir_alloc_page函数</p>
<p>vmm.[ch]：修改：扩展了mm_struct数据结构，增加了一系列函数</p>
<ul>
<li>mm_map/dup_mmap/exit_mmap：设定/取消/复制/删除用户进程的合法内存空间</li>
<li>copy_from_user/copy_to_user：用户内存空间内容与内核内存空间内容的相互拷贝的实现</li>
<li>user_mem_check：搜索vma链表，检查是否是一个合法的用户空间范围</li>
</ul>
<p>◆ kern/process/ （与本次实验有较大关系）</p>
<p>proc.[ch]：修改：扩展了proc_struct数据结构。增加或修改了一系列函数</p>
<ul>
<li>setup_pgdir/put_pgdir：创建并设置/释放页目录表</li>
<li>copy_mm：复制用户进程的内存空间和设置相关内存管理（如页表等）信息</li>
<li>do_exit：释放进程自身所占内存空间和相关内存管理（如页表等）信息所占空间，唤醒父进程，好让父进程收了自己，让调度器切换到其他进程</li>
<li>load_icode：被do_execve调用，完成加载放在内存中的执行程序到进程空间，这涉及到对页表等的修改，分配用户栈</li>
<li>do_execve：先回收自身所占用户空间，然后调用load_icode，用新的程序覆盖内存空间，形成一个执行新程序的新进程</li>
<li>do_yield：让调度器执行一次选择新进程的过程</li>
<li>do_wait：父进程等待子进程，并在得到子进程的退出消息后，彻底回收子进程所占的资源（比如子进程的内核栈和进程控制块）</li>
<li>do_kill：给一个进程设置PF_EXITING标志（“kill”信息，即要它死掉），这样在trap函数中，将根据此标志，让进程退出</li>
<li>KERNEL_EXECVE/__KERNEL_EXECVE/__KERNEL_EXECVE2：被user_main调用，执行一用户进程</li>
</ul>
<p>◆ kern/trap/</p>
<p>trap.c：修改：在idt_init函数中，对IDT初始化时，设置好了用于系统调用的中断门（idt[T_SYSCALL]）信息。这主要与syscall的实现相关</p>
<p>◆ user/*</p>
<p>新增的用户程序和用户库</p>
<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><ul>
<li>kern_init()-&gt;proc_init()-&gt;initproc-&gt;init_main()-&gt;kern_thread()-&gt;kernel_execve()</li>
<li>下图是虚拟内存的分布图, 注意page table固定在0xFAC00000的位置, 又给忘记了导致想了一会儿,<br>对于每个进程来说所看到的内存空间都是这样的.</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* *</span><br><span class="hljs-comment"> * Virtual memory map:                                          Permissions</span><br><span class="hljs-comment"> *                                                              kernel/user</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *     4G ------------------&gt; +---------------------------------+</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *                            |         Empty Memory (*)        |</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *                            +---------------------------------+ 0xFB000000</span><br><span class="hljs-comment"> *                            |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE</span><br><span class="hljs-comment"> *     VPT -----------------&gt; +---------------------------------+ 0xFAC00000</span><br><span class="hljs-comment"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="hljs-comment"> *     KERNTOP -------------&gt; +---------------------------------+ 0xF8000000</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *                            |    Remapped Physical Memory     | RW/-- KMEMSIZE</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *     KERNBASE ------------&gt; +---------------------------------+ 0xC0000000</span><br><span class="hljs-comment"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="hljs-comment"> *     USERTOP -------------&gt; +---------------------------------+ 0xB0000000</span><br><span class="hljs-comment"> *                            |           User stack            |</span><br><span class="hljs-comment"> *                            +---------------------------------+</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *                            :                                 :</span><br><span class="hljs-comment"> *                            |         ~~~~~~~~~~~~~~~~        |</span><br><span class="hljs-comment"> *                            :                                 :</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="hljs-comment"> *                            |       User Program &amp; Heap       |</span><br><span class="hljs-comment"> *     UTEXT ---------------&gt; +---------------------------------+ 0x00800000</span><br><span class="hljs-comment"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="hljs-comment"> *                            |  - - - - - - - - - - - - - - -  |</span><br><span class="hljs-comment"> *                            |    User STAB Data (optional)    |</span><br><span class="hljs-comment"> *     USERBASE, USTAB------&gt; +---------------------------------+ 0x00200000</span><br><span class="hljs-comment"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="hljs-comment"> *     0 -------------------&gt; +---------------------------------+ 0x00000000</span><br><span class="hljs-comment"> * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span><br><span class="hljs-comment"> *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span><br><span class="hljs-comment"> *     there if desired.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * */</span><br></code></pre></div></td></tr></table></figure>

<h3 id="2-创建用户进程"><a href="#2-创建用户进程" class="headerlink" title="2.创建用户进程"></a>2.创建用户进程</h3><h4 id="a-应用程序的组成和编译"><a href="#a-应用程序的组成和编译" class="headerlink" title="a. 应用程序的组成和编译"></a>a. 应用程序的组成和编译</h4><p>从实验提供的用户程序编译入手, 可以看出hello应用程序不仅仅是hello.c，还包含了支持hello应用程序的用户态库：</p>
<ul>
<li>user/libs/initcode.S：所有应用程序的起始用户态执行地址“_start”，调整了EBP和ESP后，调用umain函数。</li>
<li>user/libs/umain.c：实现了umain函数，这是所有应用程序执行的第一个C函数，它将调用应用程序的main函数，并在main函数结束后调用exit函数，而exit函数最终将调用sys_exit系统调用，让操作系统回收进程资源。</li>
<li>user/libs/ulib.[ch]：实现了最小的C函数库，除了一些与系统调用无关的函数，其他函数是对访问系统调用的包装。</li>
<li>user/libs/syscall.[ch]：用户层发出系统调用的具体实现。</li>
<li>user/libs/stdio.c：实现cprintf函数，通过系统调用sys_putc来完成字符输出。</li>
<li>user/libs/panic.c：实现__panic/__warn函数，通过系统调用sys_exit完成用户进程退出。</li>
</ul>
<p>除了这些用户态库函数实现外，还有一些libs/*.[ch]是操作系统内核和应用程序共用的函数实现。<strong>这些用户库函数其实在本质上与UNIX系统中的标准libc没有区别</strong>，只是实现得很简单，但hello应用程序的正确执行离不开这些库函数。</p>
<p>在make的最后一步执行了一个ld命令，把hello应用程序的执行码obj/__user_hello.out连接在了ucore kernel的末尾。且ld命令会在kernel中会把__user_hello.out的位置和大小记录在全局变量_binary_obj___user_hello_out_start和_binary_obj___user_hello_out_size中，这样这个hello用户程序就能够和ucore内核一起被 bootloader 加载到内存里中，并且通过这两个全局变量定位hello用户程序执行码的起始位置和大小。而到了与文件系统相关的实验后，ucore会提供一个简单的文件系统，那时所有的用户程序就都不再用这种方法进行加载了，而可以用大家熟悉的文件方式进行加载了。</p>
<h4 id="b-用户进程的虚拟地址空间"><a href="#b-用户进程的虚拟地址空间" class="headerlink" title="b. 用户进程的虚拟地址空间"></a>b. 用户进程的虚拟地址空间</h4><p>在tools/user.ld描述了用户程序的用户虚拟空间的执行入口虚拟地址：</p>
<figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">SECTIONS &#123;<br>    /* <span class="hljs-keyword">Load</span> programs <span class="hljs-built_in">at</span> this address: <span class="hljs-string">&quot;.&quot;</span> means the current address */<br>    . = <span class="hljs-number">0x800020</span>;<br></code></pre></div></td></tr></table></figure>

<p>在tools/kernel.ld描述了操作系统的内核虚拟空间的起始入口虚拟地址：</p>
<figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-class">SECTIONS </span>&#123;<br>    <span class="hljs-comment">/* Load the kernel at this address: &quot;.&quot; means the current address */</span><br>    . = <span class="hljs-number">0xC0100000</span>;<br></code></pre></div></td></tr></table></figure>

<p>这样ucore把用户进程的虚拟地址空间分了两块，一块与内核线程一样，是所有用户进程都共享的内核虚拟地址空间，映射到同样的物理内存空间中，这样在物理内存中只需放置一份内核代码，使得用户进程从用户态进入核心态时，内核代码可以统一应对不同的内核程序；另外一块是用户虚拟地址空间，虽然虚拟地址范围一样，但映射到不同且没有交集的物理内存空间中。这样当ucore把用户进程的执行代码（即应用程序的执行代码）和数据（即应用程序的全局变量等）放到用户虚拟地址空间中时，确保了各个进程不会“非法”访问到其他进程的物理内存空间。</p>
<h4 id="c-创建并执行用户进程"><a href="#c-创建并执行用户进程" class="headerlink" title="c. 创建并执行用户进程"></a>c. 创建并执行用户进程</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">vector128(vectors.S)--\&gt;<br>__alltraps(trapentry.S)--\&gt;trap(trap.c)--\&gt;trap_dispatch(trap.c)--\&gt;syscall(syscall.c)--\&gt;sys_exec(syscall.c）<br>--\&gt;do_execve(proc.c)<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>先清空当前进程的空间, 然后再alloc新的空间</p>
</blockquote>
<p>最终通过<strong>do_execve</strong>函数来完成用户进程的创建工作。</p>
<p><strong>load_icode</strong>函数的主要工作就是给用户进程建立一个能够让用户进程正常运行的用户环境。此函数有一百多行.</p>
<h3 id="3-系统调用实现"><a href="#3-系统调用实现" class="headerlink" title="3.系统调用实现"></a>3.系统调用实现</h3><p>采用系统调用机制为用户进程提供一个获得操作系统服务的统一接口层，这样一来可简化用户进程的实现，把一些共性的、繁琐的、与硬件相关、与特权指令相关的任务放到操作系统层来实现，但提供一个简洁的接口给用户进程调用；二来这层接口事先可规定好，且严格检查用户进程传递进来的参数和操作系统要返回的数据，使得让操作系统给用户进程服务的同时，保护操作系统不会被用户进程破坏。</p>
<p>从硬件层面上看，需要硬件能够支持在用户态的用户进程通过某种机制切换到内核态。试验一讲述中断硬件支持和软件处理过程其实就可以用来完成系统调用所需的软硬件支持。下面我们来看看如何在ucore中实现系统调用。</p>
<h4 id="a-初始化系统调用对应的中断描述符"><a href="#a-初始化系统调用对应的中断描述符" class="headerlink" title="a. 初始化系统调用对应的中断描述符"></a>a. 初始化系统调用对应的中断描述符</h4><p>在ucore初始化函数kern_init中调用了idt_init函数来初始化中断描述符表，并设置一个特定中断号的中断门，专门用于用户进程访问系统调用。此事由ide_init函数完成：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">idt_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">extern</span> <span class="hljs-keyword">uintptr_t</span> __vectors[];<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(idt) / <span class="hljs-keyword">sizeof</span>(struct gatedesc); i ++) &#123;<br>        SETGATE(idt[i], <span class="hljs-number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);<br>    &#125;<br>    SETGATE(idt[T_SYSCALL], <span class="hljs-number">1</span>, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);<br>    lidt(&amp;idt_pd);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在上述代码中，可以看到在执行加载中断描述符表lidt指令前，专门设置了一个特殊的中断描述符idt[T_SYSCALL]，它的特权级设置为DPL_USER，中断向量处理地址在__vectors[T_SYSCALL]处。这样建立好这个中断描述符后，一旦用户进程执行“INT T_SYSCALL”后，由于此中断允许用户态进程产生（注意它的特权级设置为DPL_USER），所以CPU就会从用户态切换到内核态，保存相关寄存器，并跳转到__vectors[T_SYSCALL]处开始执行，形成如下执行路径：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">vector128(vectors.S)--\&gt;<br>__alltraps(trapentry.S)--\&gt;trap(trap.c)--\&gt;trap_dispatch(trap.c)--\&gt;syscall(syscall.c)<br></code></pre></div></td></tr></table></figure>

<p>在syscall中，根据系统调用号来完成不同的系统调用服务。</p>
<h4 id="b-建立系统调用的-用户库-准备"><a href="#b-建立系统调用的-用户库-准备" class="headerlink" title="b. 建立系统调用的**用户库**准备"></a>b. 建立系统调用的**<u>用户库</u>**准备</h4><p>在操作系统中初始化好系统调用相关的中断描述符、中断处理起始地址等后，还需在用户态的应用程序中初始化好相关工作，简化应用程序访问系统调用的复杂性。<strong>为此在用户态建立了一个中间层，即简化的libc实现</strong>，在user/libs/ulib.[ch]和user/libs/syscall.[ch]中完成了对访问系统调用的封装。用户态最终的访问系统调用函数是syscall，实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">syscall</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, ...)</span> </span>&#123;<br>    va_list ap;<br>    va_start(ap, num);<br>    <span class="hljs-keyword">uint32_t</span> a[MAX_ARGS];<br>    <span class="hljs-keyword">int</span> i, ret;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_ARGS; i ++) &#123;<br>        a[i] = va_arg(ap, <span class="hljs-keyword">uint32_t</span>);<br>    &#125;<br>    va_end(ap);<br><br>    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span> <span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;int %1;&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        : <span class="hljs-string">&quot;=a&quot;</span> (ret)</span></span><br><span class="hljs-params"><span class="hljs-function">        : <span class="hljs-string">&quot;i&quot;</span> (T_SYSCALL),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;a&quot;</span> (num),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;d&quot;</span> (a[<span class="hljs-number">0</span>]),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;c&quot;</span> (a[<span class="hljs-number">1</span>]),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;b&quot;</span> (a[<span class="hljs-number">2</span>]),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;D&quot;</span> (a[<span class="hljs-number">3</span>]),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;S&quot;</span> (a[<span class="hljs-number">4</span>])</span></span><br><span class="hljs-params"><span class="hljs-function">        : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>从中可以看出，应用程序调用的exit/fork/wait/getpid等库函数最终都会调用syscall函数，只是调用的参数不同而已，如果看最终的汇编代码会更清楚：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">……<br>  34:    8b 55 d4               mov    -0x2c(%ebp),%edx<br>  37:    8b 4d d8               mov    -0x28(%ebp),%ecx<br>  3a:    8b 5d dc               mov    -0x24(%ebp),%ebx<br>  3d:    8b 7d e0               mov    -0x20(%ebp),%edi<br>  40:    8b 75 e4               mov    -0x1c(%ebp),%esi<br>  43:    8b 45 08               mov    0x8(%ebp),%eax<br>  46:    cd 80                  int    $0x80<br>  48: 89 45 f0                	mov    %eax,-0x10(%ebp)<br>……<br></code></pre></div></td></tr></table></figure>

<p>可以看到其实是把系统调用号放到EAX，其他5个参数a[0]~a[4]分别保存到EDX/ECX/EBX/EDI/ESI五个寄存器中，及最多用6个寄存器来传递系统调用的参数，且系统调用的返回结果是EAX。比如对于getpid库函数而言，系统调用号（SYS_getpid=18）是保存在EAX中，返回值（调用此库函数的的当前进程号pid）也在EAX中。</p>
<h4 id="c-与用户进程相关的系统调用"><a href="#c-与用户进程相关的系统调用" class="headerlink" title="c. 与用户进程相关的系统调用"></a>c. 与用户进程相关的系统调用</h4><p>在本实验中，与进程相关的各个系统调用属性如下所示：</p>
<table>
<thead>
<tr>
<th>系统调用名</th>
<th>含义</th>
<th>具体完成服务的函数</th>
</tr>
</thead>
<tbody><tr>
<td>SYS_exit</td>
<td>process exit</td>
<td>do_exit</td>
</tr>
<tr>
<td>SYS_fork</td>
<td>create child process, dup mm</td>
<td>do_fork–&gt;wakeup_proc</td>
</tr>
<tr>
<td>SYS_wait</td>
<td>wait child process</td>
<td>do_wait</td>
</tr>
<tr>
<td>SYS_exec</td>
<td>after fork, process execute a new program</td>
<td>load a program and refresh the mm</td>
</tr>
<tr>
<td>SYS_yield</td>
<td>process flag itself need resecheduling</td>
<td>proc-&gt;need_sched=1, then scheduler will rescheule this process</td>
</tr>
<tr>
<td>SYS_kill</td>
<td>kill process</td>
<td>do_kill–&gt;proc-&gt;flags |= PF_EXITING, –&gt;wakeup_proc–&gt;do_wait–&gt;do_exit</td>
</tr>
<tr>
<td>SYS_getpid</td>
<td>get the process’s pid</td>
<td></td>
</tr>
</tbody></table>
<p>通过这些系统调用，可方便地完成从进程/线程创建到退出的整个运行过程。</p>
<h4 id="d-系统调用的执行过程"><a href="#d-系统调用的执行过程" class="headerlink" title="d. 系统调用的执行过程"></a>d. 系统调用的执行过程</h4><p>当进入int 0x80中断后, 处理器和汇编码合作完成压入trapframe, 调用trap函数, 可以看到和之前的代码多了判断current的部分, </p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">trap</span><span class="hljs-params">(struct trapframe *tf)</span> </span>&#123;<br>    <span class="hljs-comment">// dispatch based on what type of trap occurred</span><br>    <span class="hljs-comment">// used for previous projects</span><br>    <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">NULL</span>) &#123;<br>        trap_dispatch(tf);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// keep a trapframe chain in stack</span><br>        <span class="hljs-comment">// 干嘛要保存这东西?</span><br>        struct trapframe *otf = current-&gt;tf;<br>        current-&gt;tf = tf;<br><br>        <span class="hljs-keyword">bool</span> in_kernel = trap_in_kernel(tf);<br><br>        trap_dispatch(tf);<br><br>        current-&gt;tf = otf;<br>        <span class="hljs-keyword">if</span> (!in_kernel) &#123;<br>            <span class="hljs-keyword">if</span> (current-&gt;flags &amp; PF_EXITING) &#123;	<span class="hljs-comment">//只有do_kill()才会设置PF_EXITING</span><br>                do_exit(-E_KILLED);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (current-&gt;need_resched) &#123;<br>                schedule();<br>            &#125;&#125;&#125;&#125;<br></code></pre></div></td></tr></table></figure>

<p>然后进入trap_dispatch()中的syscall(), 比较巧妙的是通过<strong>函数指针列表</strong>来确定调用哪个函数:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">int</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> arg[])</span> </span>= &#123; 	<span class="hljs-comment">//funtion ptr array</span><br>    [SYS_exit]              sys_exit,<br>    [SYS_fork]              sys_fork,<br>    [SYS_wait]              sys_wait,<br>    [SYS_exec]              sys_exec,<br>    [SYS_yield]             sys_yield,<br>    [SYS_kill]              sys_kill,<br>    [SYS_getpid]            sys_getpid,<br>    [SYS_putc]              sys_putc,<br>    [SYS_pgdir]             sys_pgdir,<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUM_SYSCALLS        ((sizeof(syscalls)) / (sizeof(syscalls[0])))</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">syscall</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">tf</span> =</span> current-&gt;tf;<br>    <span class="hljs-keyword">uint32_t</span> arg[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">int</span> num = tf-&gt;tf_regs.reg_eax;<br>    <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">0</span> &amp;&amp; num &lt; NUM_SYSCALLS) &#123;<br>        <span class="hljs-keyword">if</span> (syscalls[num] != <span class="hljs-literal">NULL</span>) &#123;<br>            arg[<span class="hljs-number">0</span>] = tf-&gt;tf_regs.reg_edx;<br>            arg[<span class="hljs-number">1</span>] = tf-&gt;tf_regs.reg_ecx;<br>            arg[<span class="hljs-number">2</span>] = tf-&gt;tf_regs.reg_ebx;<br>            arg[<span class="hljs-number">3</span>] = tf-&gt;tf_regs.reg_edi;<br>            arg[<span class="hljs-number">4</span>] = tf-&gt;tf_regs.reg_esi;<br>            tf-&gt;tf_regs.reg_eax = syscalls[num](arg);	<span class="hljs-comment">//`syscalls[num]` is function ptr, and `(arg)` is argument</span><br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br>    print_trapframe(tf);<br>    panic(<span class="hljs-string">&quot;undefined syscall %d, pid = %d, name = %s.\n&quot;</span>,<br>            num, current-&gt;pid, current-&gt;name);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>如果从哪个系统调用返回了就执行正常的中断退出(比如fork).</p>
<h3 id="4-fork-exec-wait-exit"><a href="#4-fork-exec-wait-exit" class="headerlink" title="4.fork/exec/wait/exit"></a>4.fork/exec/wait/exit</h3><h4 id="fork"><a href="#fork" class="headerlink" title="fork():"></a>fork():</h4><blockquote>
<p>重复了一下lab4中的内容, 有点不熟悉, 这种流程分析还是要自己写</p>
</blockquote>
<p><img src="../../image/ucore/image-20211228201516840.png" srcset="/img/loading.gif" lazyload alt="image-20211228201516840"></p>
<p>sys_fork()简单的从current-&gt;tf中取出stack地址, 作为参数调用do_fork():</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">sys_fork</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> arg[])</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">tf</span> =</span> current-&gt;tf;<br>    <span class="hljs-keyword">uintptr_t</span> <span class="hljs-built_in">stack</span> = tf-&gt;tf_esp;<br>    <span class="hljs-comment">//int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf)</span><br>    <span class="hljs-keyword">return</span> do_fork(<span class="hljs-number">0</span>, <span class="hljs-built_in">stack</span>, tf);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p> 在这里值得自己思考一下fork一个进程需要做出哪些工作?</p>
<ul>
<li>首先一个进程有自己的控制块proc_struct, 我们需要alloc_proc()一个</li>
<li>每个进程都有自己的内核栈, 需要重新alloc2个4KB的page(KSTACKSIZE)</li>
<li>还有一个mm_struct也很重要, 需要alloc一个并将旧的复制到新进程中<ul>
<li>还要看clone_flag, 如果为false则建立新的, 否则直接使用旧的</li>
<li>调用mm_creat(); 注意到mm中管理着页目录表, 还要重新建立一个新的; 然后是**lock_mm(oldmm)(不知道是什么)**紧跟着dup_mm来复制内存空间中的内容, 注意到内存空间是由mm中的vma链表管理的, 需要遍历每一个vma块, 然后再调用<code>copy_range(to-&gt;pgdir, from-&gt;pgdir, vma-&gt;vm_start, vma-&gt;vm_end, share)</code>来copy内存, 具体详见练习2.</li>
</ul>
</li>
<li>然后要设置一下子进程的一些状态, copy_thread函数在lab4中有介绍.</li>
<li>插入链表(两个), 设置关系, 然后wakeup, 结束</li>
</ul>
<p><code>set_links</code>函数会为当前进程间设置合适的关系，其实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*************************************************************</span><br><span class="hljs-comment">process relations</span><br><span class="hljs-comment">parent:           proc-&gt;parent  (proc is children)</span><br><span class="hljs-comment">children:         proc-&gt;cptr    (proc is parent)</span><br><span class="hljs-comment">older sibling:    proc-&gt;optr    (proc is younger sibling)</span><br><span class="hljs-comment">younger sibling:  proc-&gt;yptr    (proc is older sibling)</span><br><span class="hljs-comment">*************************************************************/</span><br><span class="hljs-comment">// set_links - set the relation links of process</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set_links</span><span class="hljs-params">(struct proc_struct *proc)</span> </span>&#123;<br>    list_add(&amp;proc_list, &amp;(proc-&gt;list_link));<br>    proc-&gt;yptr = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> ((proc-&gt;optr = proc-&gt;parent-&gt;cptr) != <span class="hljs-literal">NULL</span>)<br>        proc-&gt;optr-&gt;yptr = proc;<br>    proc-&gt;parent-&gt;cptr = proc;<br>    nr_process ++;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li><p>除了lab4熟知的<code>list_add</code>与<code>nr_process++</code>，该函数还设置了<code>proc_struct</code>中的<code>optr、yptr</code>以及<code>cptr</code>成员。</p>
</li>
<li><p>其中，<code>cptr</code>指针指向当前进程的子进程中，<strong>最新创建</strong>的那个子进程，即<code>children</code>；<code>yptr</code>指向<strong>与当前进程共享同一个父进程，但比当前进程的创建时间更晚的进程</strong>，即<code>younger sibling</code>。而<code>optr</code>指针的功能则与<code>yptr</code>相反，指向<code>older sibling</code>。</p>
</li>
<li><p>进程间关系如下图所示</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">                     +----------------+<br>                     | parent process |<br>                     +----------------+<br>              parent ^         \       ^  parent<br>                    /           \       \<br>                   /             \ cptr  \<br>                  /         yptr  V       \      yptr<br>           +-------------+  --&gt;  +-------------+  --&gt;  <span class="hljs-literal">NULL</span><br>           | old process |       | New Process |<br><span class="hljs-literal">NULL</span>  &lt;--  +-------------+  &lt;--  +-------------+<br>      optr                  optr<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h4 id="exec"><a href="#exec" class="headerlink" title="exec():"></a>exec():</h4><p>首先从do_exec参数来看需要创建进程名称字符数组, 程序长度, ELF文件地址, 大小四个参数</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">do_execve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *binary, <span class="hljs-keyword">size_t</span> size)</span> </span><br></code></pre></div></td></tr></table></figure>

<p>具体注释在下方:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">do_execve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *binary, <span class="hljs-keyword">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> current-&gt;mm;<br>    <span class="hljs-comment">//例行检查以及校正名称长度</span><br>    <span class="hljs-keyword">if</span> (!user_mem_check(mm, (<span class="hljs-keyword">uintptr_t</span>)name, len, <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-keyword">return</span> -E_INVAL;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (len &gt; PROC_NAME_LEN) &#123;<br>        len = PROC_NAME_LEN;<br>    &#125;<br>	<span class="hljs-comment">//从name地址上复制名称字符串</span><br>    <span class="hljs-keyword">char</span> local_name[PROC_NAME_LEN + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">memset</span>(local_name, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(local_name));<br>    <span class="hljs-built_in">memcpy</span>(local_name, name, len);<br>	<span class="hljs-comment">//如果current-&gt;mm不为NULL, 说明为用户进程, 清空一下mm(包括vma链表,页目录表,以及mm自身)</span><br>    <span class="hljs-keyword">if</span> (mm != <span class="hljs-literal">NULL</span>) &#123;<br>        lcr3(boot_cr3);<br>        <span class="hljs-keyword">if</span> (mm_count_dec(mm) == <span class="hljs-number">0</span>) &#123;<br>            exit_mmap(mm);<br>            put_pgdir(mm);<br>            mm_destroy(mm);<br>        &#125;<br>        current-&gt;mm = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> ret;<br>    <span class="hljs-comment">//解析ELF文件以及建立mm内容</span><br>    <span class="hljs-keyword">if</span> ((ret = load_icode(binary, size)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">goto</span> execve_exit;	<span class="hljs-comment">//出错则退出</span><br>    &#125;<br>    set_proc_name(current, local_name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>execve_exit:<br>    do_exit(ret);<br>    panic(<span class="hljs-string">&quot;already exit: %e.\n&quot;</span>, ret);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>可以看出解析ELF文件才是大头. 代码在<strong>练习1</strong>或者直接看源码.</p>
<p><strong>load_icode</strong>函数的主要工作就是给用户进程建立一个能够让用户进程正常运行的用户环境。此函数有一百多行，完成了如下重要工作：</p>
<ol>
<li>调用mm_create函数来申请进程的内存管理数据结构mm所需内存空间，并对mm进行初始化；</li>
<li>调用setup_pgdir来申请一个页目录表所需的一个页大小的内存空间，并把描述ucore内核虚空间映射的内核页表（boot_pgdir所指）的内容拷贝到此新目录表中，最后让mm-&gt;pgdir指向此页目录表，这就是进程新的页目录表了，且能够正确映射内核虚空间；</li>
<li>根据应用程序执行码的起始位置来解析此ELF格式的执行程序，并调用mm_map函数根据ELF格式的执行程序说明的各个段（代码段、数据段、BSS段等）的起始位置和大小建立对应的vma结构，并把vma插入到mm结构中，从而表明了用户进程的合法用户态虚拟地址空间；</li>
<li>调用根据执行程序各个段的大小分配物理内存空间，并根据执行程序各个段的起始位置确定虚拟地址，并在页表中建立好物理地址和虚拟地址的映射关系，然后把执行程序各个段的内容拷贝到相应的内核虚拟地址中，至此应用程序执行码和数据已经根据编译时设定地址放置到虚拟内存中了；</li>
<li>需要给用户进程设置用户栈，为此调用mm_mmap函数建立用户栈的vma结构，明确用户栈的位置在用户虚空间的顶端，大小为256个页，即1MB，并分配一定数量的物理内存且建立好栈的虚地址&lt;–&gt;物理地址映射关系；</li>
<li>至此,进程内的内存管理vma和mm数据结构已经建立完成，于是把mm-&gt;pgdir赋值到cr3寄存器中，即更新了用户进程的虚拟内存空间，此时的initproc已经被hello的代码和数据覆盖，成为了第一个用户进程，但此时这个用户进程的执行现场还没建立好；</li>
<li>先清空进程的中断帧，再重新设置进程的中断帧，使得在执行中断返回指令“iret”后，能够让CPU转到用户态特权级，并回到用户态内存空间，使用用户态的代码段、数据段和堆栈，且能够跳转到用户进程的第一条指令执行，并确保在用户态能够响应中断；</li>
</ol>
<p>至此，用户进程的用户环境已经搭建完毕。此时initproc将按产生系统调用的函数调用路径原路返回，执行中断返回指令“iret”（位于trapentry.S的最后一句）后，将切换到用户进程hello的第一条语句位置_start处（位于user/libs/initcode.S的第三句）开始执行。</p>
<h4 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// do_wait - wait one OR any children to become PROC_ZOMBIE state, and free memory space of kernel stack</span><br><span class="hljs-comment">//         - proc struct of this child.</span><br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> only after do_wait function, all resources of the child proces are free.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">do_wait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pid, <span class="hljs-keyword">int</span> *code_store)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> current-&gt;mm;<br>    <span class="hljs-keyword">if</span> (code_store != <span class="hljs-literal">NULL</span>) &#123;	<span class="hljs-comment">//例行检查</span><br>        <span class="hljs-keyword">if</span> (!user_mem_check(mm, (<span class="hljs-keyword">uintptr_t</span>)code_store, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>), <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">return</span> -E_INVAL;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span>;</span><br>    <span class="hljs-keyword">bool</span> intr_flag, haskid;<br>repeat:<br>    haskid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (pid != <span class="hljs-number">0</span>) &#123;	<span class="hljs-comment">//不等于零意味着要在hash_list中寻找特定pid的子程序</span><br>        proc = find_proc(pid);<br>        <span class="hljs-keyword">if</span> (proc != <span class="hljs-literal">NULL</span> &amp;&amp; proc-&gt;parent == current) &#123;<br>            haskid = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;<br>                <span class="hljs-keyword">goto</span> found;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;	<span class="hljs-comment">//查找任意一个为ZOMBIE的子程序</span><br>        proc = current-&gt;cptr;<br>        <span class="hljs-keyword">for</span> (; proc != <span class="hljs-literal">NULL</span>; proc = proc-&gt;optr) &#123;<br>            haskid = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;<br>                <span class="hljs-keyword">goto</span> found;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (haskid) &#123;	<span class="hljs-comment">//存在子程序, 但是没有一个是ZOMBIE, 而且当前是父进程在执行, 所以调用switch()来</span><br>        <span class="hljs-comment">//切换到子进程执行, 并且设置一下父进程为SLEEP状态, wait原因是for child</span><br>        current-&gt;state = PROC_SLEEPING;<br>        current-&gt;wait_state = WT_CHILD;<br>        schedule();	<br>        <span class="hljs-keyword">if</span> (current-&gt;flags &amp; PF_EXITING) &#123;	<span class="hljs-comment">//怎么调用了do_exit()?????</span><br>            do_exit(-E_KILLED);<br>        &#125;<br>        <span class="hljs-keyword">goto</span> repeat;	<span class="hljs-comment">//子进程(应该)执行完了, 重新查找</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> -E_BAD_PROC;	<span class="hljs-comment">//没有子程序的话......</span><br><br>found:<br>    <span class="hljs-keyword">if</span> (proc == idleproc || proc == initproc) &#123;	<span class="hljs-comment">//不可能是任何进程的子进程</span><br>        panic(<span class="hljs-string">&quot;wait idleproc or initproc.\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (code_store != <span class="hljs-literal">NULL</span>) &#123;	<span class="hljs-comment">//如果提供了存放exit_code的变量, 则存入</span><br>        *code_store = proc-&gt;exit_code;<br>    &#125;<br>    local_intr_save(intr_flag);<br>    &#123;<span class="hljs-comment">//对这种链表的操作要屏蔽中断</span><br>        unhash_proc(proc);<br>        remove_links(proc);<br>    &#125;<br>    local_intr_restore(intr_flag);<br>    <span class="hljs-comment">//释放子进程占用资源</span><br>    put_kstack(proc);<br>    kfree(proc);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="exit"><a href="#exit" class="headerlink" title="exit():"></a>exit():</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// do_exit - called by sys_exit</span><br><span class="hljs-comment">//   1. call exit_mmap &amp; put_pgdir &amp; mm_destroy to free the almost all memory space of process</span><br><span class="hljs-comment">//   2. set process&#x27; state as PROC_ZOMBIE, then call wakeup_proc(parent) to ask parent reclaim itself.</span><br><span class="hljs-comment">//   3. call scheduler to switch to other process</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">do_exit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> error_code)</span> </span>&#123;<br>    <span class="hljs-comment">//不能退出的两个内核进程</span><br>    <span class="hljs-keyword">if</span> (current == idleproc) &#123;<br>        panic(<span class="hljs-string">&quot;idleproc exit.\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (current == initproc) &#123;<br>        panic(<span class="hljs-string">&quot;initproc exit.\n&quot;</span>);<br>    &#125;<br>	<span class="hljs-comment">//如果current-&gt;mm不为NULL, 说明为用户进程, 清空一下mm(包括vma链表,页目录表,以及mm自身)</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> current-&gt;mm;<br>    <span class="hljs-keyword">if</span> (mm != <span class="hljs-literal">NULL</span>) &#123;<br>        lcr3(boot_cr3);<br>        <span class="hljs-keyword">if</span> (mm_count_dec(mm) == <span class="hljs-number">0</span>) &#123;<br>            exit_mmap(mm);<br>            put_pgdir(mm);<br>            mm_destroy(mm);<br>        &#125;<br>        current-&gt;mm = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    current-&gt;state = PROC_ZOMBIE;<br>    current-&gt;exit_code = error_code;<br><br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span>;</span><br>    local_intr_save(intr_flag);<br>    &#123;<br>        <span class="hljs-comment">//如果父进程因为WT_CHILD睡眠, 则唤醒父进程</span><br>        proc = current-&gt;parent;<br>        <span class="hljs-keyword">if</span> (proc-&gt;wait_state == WT_CHILD) &#123;	<br>            wakeup_proc(proc);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (current-&gt;cptr != <span class="hljs-literal">NULL</span>) &#123;	<span class="hljs-comment">//当前进程有子进程</span><br>            proc = current-&gt;cptr;<br>            current-&gt;cptr = proc-&gt;optr;<br>		   <span class="hljs-comment">//以下几行把proc从current的cptr上插入到initproc的cptr等关系指针中</span><br>            proc-&gt;yptr = <span class="hljs-literal">NULL</span>;	<br>            <span class="hljs-keyword">if</span> ((proc-&gt;optr = initproc-&gt;cptr) != <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//把current的子进程的父进程设置为initproc</span><br>                initproc-&gt;cptr-&gt;yptr = proc;<br>            &#125;<br>            proc-&gt;parent = initproc;<br>            initproc-&gt;cptr = proc;<br>            <span class="hljs-comment">//如果initproc因为WT_CHILD睡眠, 则唤醒initproc</span><br>            <span class="hljs-keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;<br>                <span class="hljs-keyword">if</span> (initproc-&gt;wait_state == WT_CHILD) &#123;<br>                    wakeup_proc(initproc);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    local_intr_restore(intr_flag);<br><br>    schedule();<br>    panic(<span class="hljs-string">&quot;do_exit will not return!! %d.\n&quot;</span>, current-&gt;pid);<br></code></pre></div></td></tr></table></figure>

<h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1-2"><a href="#练习1-2" class="headerlink" title="练习1"></a>练习1</h3><blockquote>
<p>补充load_icode()的实现</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//(6) setup trapframe for user environment</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">tf</span> =</span> current-&gt;tf;<br><span class="hljs-built_in">memset</span>(tf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct trapframe));<span class="hljs-comment">//清空tf</span><br><span class="hljs-comment">/* LAB5:EXERCISE1 YOUR CODE</span><br><span class="hljs-comment"> * should set tf_cs,tf_ds,tf_es,tf_ss,tf_esp,tf_eip,tf_eflags</span><br><span class="hljs-comment"> * NOTICE: If we set trapframe correctly, then the user level process can return to USER MODE from kernel. So</span><br><span class="hljs-comment"> *          tf_cs should be USER_CS segment (see memlayout.h)</span><br><span class="hljs-comment"> *          tf_ds=tf_es=tf_ss should be USER_DS segment</span><br><span class="hljs-comment"> *          tf_esp should be the top addr of user stack (USTACKTOP)</span><br><span class="hljs-comment"> *          tf_eip should be the entry point of this binary program (elf-&gt;e_entry)</span><br><span class="hljs-comment"> *          tf_eflags should be set to enable computer to produce Interrupt</span><br><span class="hljs-comment"> */</span><br>tf-&gt;tf_cs = USER_CS;<br><span class="hljs-comment">//答案中好像没有tf_fs?虽然不重要但是不知道为什么不加上</span><br>tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_fs = tf-&gt;tf_ss = USER_DS;<br>tf-&gt;tf_esp = USTACKTOP;<br>tf-&gt;tf_eflags |= FL_IF;<br>tf-&gt;tf_eip= elf-&gt;e_entry;<br>ret = <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>请在实验报告中描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。</p>
</blockquote>
<p>简单</p>
<h3 id="练习2-2"><a href="#练习2-2" class="headerlink" title="练习2"></a>练习2</h3><blockquote>
<p>do_fork()-&gt;dum_mmap()-&gt;copy_range()的实现</p>
</blockquote>
<p>按照page unit来复制内存内容, 这样可以同时更改pte的内容. </p>
<p>过程概述: 对于vma中的第一个地址start来说, 取出(pde_t *)from中的pte, 用pte2page转换成start地址开始的一个page, 然后用get_pte找到或创建to中start地址对应的pte, 也转换成page(即npage). 然后显而易见的, 我们需要转换page2kva来当做memcpy()的参数来复制整个页的内容, 进一步调用page_insert()来在to中把 虚拟地址start 和 npage 建立映射关系. </p>
<p>一些细节注释在下面, 整个循环的变量就是不断按照pagesize增加的start虚拟地址.</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* copy_range - copy content of memory (start, end) of one process A to another process B</span><br><span class="hljs-comment"> * @to:    the addr of process B&#x27;s Page Directory</span><br><span class="hljs-comment"> * @from:  the addr of process A&#x27;s Page Directory</span><br><span class="hljs-comment"> * @share: flags to indicate to dup OR share. We just use dup method, so it didn&#x27;t be used.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * CALL GRAPH: copy_mm--&gt;dup_mmap--&gt;copy_range</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">copy_range</span><span class="hljs-params">(<span class="hljs-keyword">pde_t</span> *to, <span class="hljs-keyword">pde_t</span> *from, <span class="hljs-keyword">uintptr_t</span> start, <span class="hljs-keyword">uintptr_t</span> end, <span class="hljs-keyword">bool</span> share)</span> </span>&#123;<br>    assert(start % PGSIZE == <span class="hljs-number">0</span> &amp;&amp; end % PGSIZE == <span class="hljs-number">0</span>);<br>    assert(USER_ACCESS(start, end));<br>    <span class="hljs-comment">// copy content by page unit.</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">//call get_pte to find process A&#x27;s pte according to the addr start</span><br>        <span class="hljs-keyword">pte_t</span> *ptep = get_pte(from, start, <span class="hljs-number">0</span>), *nptep;  <span class="hljs-comment">// nptep for new page table entry pointer</span><br>        <span class="hljs-keyword">if</span> (ptep == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-comment">// this page table does not exit, so skip whole memory that mapped by a page table</span><br>            <span class="hljs-comment">// why would this happen?</span><br>            <span class="hljs-comment">// PTSIZE : bytes mapped by a page directory entry</span><br>            start = ROUNDDOWN(start + PTSIZE, PTSIZE);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//call get_pte to find process B&#x27;s pte according to the addr start. If pte is NULL, just alloc a PT</span><br>        <span class="hljs-keyword">if</span> (*ptep &amp; PTE_P) &#123;<br>            <span class="hljs-keyword">if</span> ((nptep = get_pte(to, start, <span class="hljs-number">1</span>)) == <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-keyword">return</span> -E_NO_MEM;<br>            &#125;<br>            <span class="hljs-keyword">uint32_t</span> perm = (*ptep &amp; PTE_USER);<br>            <span class="hljs-comment">//get page from ptep</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page</span> =</span> pte2page(*ptep);<br>            <span class="hljs-comment">// alloc a page for process B</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">npage</span> =</span> alloc_page();<br>            assert(page != <span class="hljs-literal">NULL</span>);<br>            assert(npage != <span class="hljs-literal">NULL</span>);<br>            <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">/* LAB5:EXERCISE2 YOUR CODE</span><br><span class="hljs-comment">             * (1) find src_kvaddr: the kernel virtual address of page</span><br><span class="hljs-comment">             * (2) find dst_kvaddr: the kernel virtual address of npage</span><br><span class="hljs-comment">             * (3) memory copy from src_kvaddr to dst_kvaddr, size is PGSIZE</span><br><span class="hljs-comment">             * (4) build the map of phy addr of  nage with the linear addr start</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">uintptr_t</span> src_kvaddr, dst_kvaddr;<br>            src_kvaddr = page2kva(page);<br>            dst_kvaddr = page2kva(npage);<br>            <span class="hljs-built_in">memcpy</span>(dst_kvaddr, src_kvaddr, PGSIZE);<br>            ret = page_insert(to, npage, start, perm);<br>            assert(ret == <span class="hljs-number">0</span>);<br>        &#125;<br>        start += PGSIZE;<br>    &#125; <span class="hljs-keyword">while</span> (start != <span class="hljs-number">0</span> &amp;&amp; start &lt; end);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="练习3-1"><a href="#练习3-1" class="headerlink" title="练习3"></a>练习3</h3><blockquote>
<p>分析fork/exec/wait/exit 和 系统调用的实现</p>
</blockquote>
<p>写在知识点里</p>
<ul>
<li>请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？<ul>
<li>fork会修改其子进程的状态为<code>PROC_RUNNABLE</code>，而当前进程状态不变。</li>
<li>exec不修改当前进程的状态，但会替换内存空间里所有的数据与代码。</li>
<li>wait会先检测是否存在子进程。如果存在进入<code>PROC_ZONBIE</code>的子进程，则回收该进程并函数返回。但若存在尚处于<code>PROC_RUNNABLE</code>的子进程，则当前进程会进入<code>PROC_SLEEPING</code>状态，并等待子进程唤醒。</li>
<li>exit会将当前进程状态设置为<code>PROC_ZONBIE</code>，并唤醒父进程，使其处于<code>PROC_RUNNABLE</code>的状态，之后主动让出CPU。</li>
</ul>
</li>
<li>请给出ucore中一个用户态进程的执行状态生命周期图（包括执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。<a target="_blank" rel="noopener" href="https://kiprey.github.io/2020/08/uCore-5/#Questions">link</a> </li>
</ul>
<pre><code class=" mermaid">stateDiagram-v2
[*]--&gt;UNINIT : alloc_proc
UNINIT--&gt;RUNNABLE : proc_init/wakeup_proc
RUNNING--&gt;SLEEPING : try_free_pages/do_wait/do_sleep
RUNNING--&gt;ZOMBIE : do_exit
RUNNABLE--&gt;RUNNING :调度器调度
RUNNING--&gt;RUNNABLE :时间片耗尽
SLEEPING--&gt;RUNNABLE : wakeup_proc
ZOMBIE--&gt;[*]:资源回收
</code></pre>



<h3 id="Big-Challenge-Dirty-COW"><a href="#Big-Challenge-Dirty-COW" class="headerlink" title="Big Challenge: Dirty COW"></a>Big Challenge: Dirty COW</h3><blockquote>
<p><strong>实现 Copy on Write （COW）机制</strong> </p>
<p>同时，由于COW实现比较复杂，容易引入bug，请参考 <a target="_blank" rel="noopener" href="https://dirtycow.ninja/">Dirty COW (CVE-2016-5195)</a> 看看能否在ucore的COW实现中模拟这个错误和解决方案。需要有解释。</p>
<p>这是一个big challenge.</p>
</blockquote>
<h4 id="1-思路"><a href="#1-思路" class="headerlink" title="1. 思路"></a>1. 思路</h4><p><strong>写时复制</strong>（<strong>Copy-on-write</strong>，简称<strong>COW</strong>）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会使用指针指向相同的资源，直到<strong>某个调用者</strong>试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。</p>
<p>具体到ucore而言, 当一个用户父进程创建自己的子进程时，缺页处理例程会把父子进程的页表项改为<strong>只读</strong>，子进程可共享父进程占用的用户内存空间中的页面（这就是一个共享的资源）。当其中任何一个进程修改此用户内存空间中的某页面时，ucore会通过page fault异常获知该操作，并完成拷贝内存页面，使得两个进程都有各自的内存页面。这样一个进程所做的修改不会被另外一个进程可见了。</p>
<h4 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2. 具体实现"></a>2. 具体实现</h4><ul>
<li><p>当进行内存访问时，CPU会根据PTE上的读写位<code>PTE_P</code>、<code>PTE_W</code>来确定当前内存操作是否允许，如果不允许，则缺页中断。我们可以在<code>copy_range</code>函数中，将父进程中所有PTE中的<code>PTE_W</code>置为0，这样便可以将父进程中所有空间都设置为只读。然后使子进程的PTE全部指向父进程中PTE存放的物理地址，这样便可以达到内存共享的目的。</p>
<blockquote>
<p>为什么要设置父进程所有空间为只读呢，因为在之后的内存操作中，如果对这些空间进行写操作的话，程序就会触发缺页中断，那么CPU就可以在缺页中断程序中复制该内存，也就是写时复制。</p>
</blockquote>
<blockquote>
<p>为什么在copy_range函数中实现内存共享呢？因为我们可以在该函数中对其传入的<code>share</code>参数进行处理。</p>
</blockquote>
<p>最终实现把拷贝内存的部分换成复制一下pte的内容就可以了:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">...         <span class="hljs-keyword">if</span>(share)<br>            &#123;<br>                cprintf(<span class="hljs-string">&quot;Sharing the page 0x%x\n&quot;</span>, page2kva(page));<br>                <span class="hljs-comment">// 物理页面共享，并设置两个PTE上的标志位为只读</span><br>                page_insert(from, page, start, perm &amp; ~PTE_W);<br>                ret = page_insert(to, page, start, perm &amp; ~PTE_W);<br>            &#125;<br>            <span class="hljs-comment">// 完整拷贝内存</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>				...<br>            &#125; ...<br></code></pre></div></td></tr></table></figure></li>
<li><p>当某个进程想写入一个共享内存时，由于PTE上的<code>PTE_W</code>为0，所以会触发缺页中断处理程序。此时进程需要在缺页中断处理程序中复制该页内存，并设置该页内存所对应的<code>PTE_W</code>为1。</p>
<blockquote>
<p>需要注意的是，在执行缺页中断处理程序中的内存复制操作前，需要先检查该物理页的引用次数。如果该引用次数已经为1了，则表明此时的物理页只有当前进程所使用，故可以直接设置该页内存所对应的<code>PTE_W</code>为1即可，不需要进行内存复制。</p>
</blockquote>
<p>最终实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">do_pgfault</span><span class="hljs-params">(struct mm_struct *mm, <span class="hljs-keyword">uint32_t</span> error_code, <span class="hljs-keyword">uintptr_t</span> addr)</span> </span>&#123;<br>    <span class="hljs-comment">// ........</span><br>   <span class="hljs-comment">// 查找当前虚拟地址所对应的页表项</span><br>    <span class="hljs-keyword">if</span> ((ptep = get_pte(mm-&gt;pgdir, addr, <span class="hljs-number">1</span>)) == <span class="hljs-literal">NULL</span>) &#123;<br>        cprintf(<span class="hljs-string">&quot;get_pte in do_pgfault failed\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> failed;<br>    &#125;<br>    <span class="hljs-comment">// 如果这个页表项所对应的物理页不存在，则</span><br>    <span class="hljs-keyword">if</span> (*ptep == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 分配一块物理页，并设置页表项</span><br>        <span class="hljs-keyword">if</span> (pgdir_alloc_page(mm-&gt;pgdir, addr, perm) == <span class="hljs-literal">NULL</span>) &#123;<br>            cprintf(<span class="hljs-string">&quot;pgdir_alloc_page in do_pgfault failed\n&quot;</span>);<br>            <span class="hljs-keyword">goto</span> failed;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;	<span class="hljs-comment">//不为空说明需要swap或者COW</span><br>        struct Page *page=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 如果当前页错误的原因是写入了只读页面</span><br>        <span class="hljs-keyword">if</span> (*ptep &amp; PTE_P) &#123;<br>            <span class="hljs-comment">// 写时复制：复制一块内存给当前进程</span><br>            cprintf(<span class="hljs-string">&quot;\n\nCOW: ptep 0x%x, pte 0x%x\n&quot;</span>,ptep, *ptep);<br>            <span class="hljs-comment">// 原先所使用的只读物理页</span><br>            page = pte2page(*ptep);<br>            <span class="hljs-comment">// 如果该物理页面被多个进程引用</span><br>            <span class="hljs-keyword">if</span>(page_ref(page) &gt; <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-comment">// 释放当前PTE的引用并分配一个新物理页</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span>* <span class="hljs-title">newPage</span> =</span> pgdir_alloc_page(mm-&gt;pgdir, addr, perm);<br>                <span class="hljs-keyword">void</span> * kva_src = page2kva(page);<br>                <span class="hljs-keyword">void</span> * kva_dst = page2kva(newPage);<br>                <span class="hljs-comment">// 拷贝数据</span><br>                <span class="hljs-built_in">memcpy</span>(kva_dst, kva_src, PGSIZE);<br>            &#125;<br>            <span class="hljs-comment">// 如果该物理页面只被当前进程所引用,即page_ref等1</span><br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 则可以直接执行page_insert，保留当前物理页并重设其PTE权限。</span><br>                page_insert(mm-&gt;pgdir, page, addr, perm);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// 如果swap已经初始化完成</span><br>            <span class="hljs-keyword">if</span>(swap_init_ok) &#123;<br>                <span class="hljs-comment">// 将目标数据加载到某块新的物理页中。</span><br>                <span class="hljs-comment">// 该物理页可能是尚未分配的物理页，也可能是从别的已分配物理页中取的</span><br>                <span class="hljs-keyword">if</span> ((ret = swap_in(mm, addr, &amp;page)) != <span class="hljs-number">0</span>) &#123;<br>                    cprintf(<span class="hljs-string">&quot;swap_in in do_pgfault failed\n&quot;</span>);<br>                    <span class="hljs-keyword">goto</span> failed;<br>                &#125;<br>                <span class="hljs-comment">// 将该物理页与对应的虚拟地址关联，同时设置页表。</span><br>                page_insert(mm-&gt;pgdir, page, addr, perm);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cprintf(<span class="hljs-string">&quot;no swap_init_ok but ptep is %x, failed\n&quot;</span>,*ptep);<br>                <span class="hljs-keyword">goto</span> failed;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 当前缺失的页已经加载回内存中，所以设置当前页为可swap。</span><br>        swap_map_swappable(mm, addr, page, <span class="hljs-number">1</span>);<br>        page-&gt;pra_vaddr = addr;<br>   &#125;<br>   ret = <span class="hljs-number">0</span>;<br>failed:<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h4 id="3-Dirty-COW浅析"><a href="#3-Dirty-COW浅析" class="headerlink" title="3.Dirty COW浅析"></a>3.Dirty COW浅析</h4><h5 id="0x00-关于linux内核背景知识"><a href="#0x00-关于linux内核背景知识" class="headerlink" title="0x00 关于linux内核背景知识"></a>0x00 关于linux内核背景知识</h5><p>和ucore非常相似, 比如mm_struct, vma, copy_range一些函数. 下面是这个漏洞的相关背景.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/madvise.2.html">madvise</a>(): 内核对该区域的用户虚拟内存应遵循特定的使用模式<ul>
<li>MADV_DONTNEED参数:</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap</a>():<ul>
<li>MAP_PRIVATE参数: Create a private copy-on-write mapping.  Updates to the mapping are not visible to other processes mapping the same file, and are not carried through to the underlying file. </li>
</ul>
</li>
</ul>
<h5 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h5><p>该漏洞是Linux的一个本地提权漏洞，发现者是Phil Oester，影响&gt;=2.6.22的所有Linux内核版本，修复时间是2016年10月18号。该漏洞的原因是<code>get_user_page</code>内核函数在处理<code>Copy-on-Write</code>(以下使用COW表示)的过程中，可能产出竞态条件造成COW过程被破坏，导致出现写数据到进程地址空间内只读内存区域的机会。当我们向带有MAP_PRIVATE标记的只读文件映射区域写数据时，会产生一个映射文件的复制(COW)，对此区域的任何修改都不会写回原来的文件，如果上述的竞态条件发生，就能成功的写回原来的文件。比如我们修改su或者passwd程序就可以达到root的目的。</p>
<blockquote>
<p>Pocsuite 是由知道创宇404实验室打造的一款开源的远程漏洞测试框架</p>
</blockquote>
<h5 id="0x02-POC分析"><a href="#0x02-POC分析" class="headerlink" title="0x02 POC分析"></a>0x02 POC分析</h5><p>首先打开我们需要修改的只读文件并使用<code>MAP_PRIVATE</code>标记映射文件到内存区域，然后启动两个线程：</p>
<ul>
<li>其中一个线程向文件映射的内存区域写数据，这时内核采用COW机制。</li>
<li>另一个线程使用带MADV_DONTNEED参数的madvise系统调用将文件映射内存区域释放，达到干扰另一个线程的COW过程，产生竞态条件，</li>
</ul>
<p>当竞态条件发生时就能写入文件成功。</p>
<h5 id="0x03-大致流程"><a href="#0x03-大致流程" class="headerlink" title="0x03 大致流程"></a>0x03 大致流程</h5><p>当我们用mmap去映射文件到内存区域时使用了<code>MAP_PRIVATE</code>标记，我们写文件时会写到COW机制产生的内存区域中，原文件不受影响。其中获取用户进程内存页的过程如下：</p>
<ol>
<li>第一次调用<code>follow_page_mask</code>查找虚拟地址对应的page，带有<code>FOLL_WRITE</code>标记。因为所在page不在内存中，<code>follow_page_mask</code>返回NULL，第一次失败，进入<code>faultin_page</code>，最终进入<code>do_cow_fault</code>分配不带<code>_PAGE_RW</code>标记的匿名内存页，返回值为0。</li>
<li>重新开始循环，第二次调用<code>follow_page_mask</code>，带有<code>FOLL_WRITE</code>标记。由于不满足<code>((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte))</code>条件，<code>follow_page_mask</code>返回NULL，第二次失败，进入<code>faultin_page</code>，最终进入<code>do_wp_page</code>函数分配COW页。并在上级函数<code>faultin_page</code>中去掉<code>FOLL_WRITE</code>标记,返回0。</li>
<li>重新开始循环，第三次调用<code>follow_page_mask</code>，不带<code>FOLL_WRITE</code>标记。成功得到page。</li>
</ol>
<p>产生竞态条件:</p>
<ol>
<li>第一次<code>follow_page_mask(FOLL_WRITE)</code>，page不在内存中，进行pagefault处理。</li>
<li>第二次<code>follow_page_mask(FOLL_WRITE)</code>，page没有写权限，并去掉<code>FOLL_WRITE</code>。</li>
<li>另一个线程释放上一步分配的COW页</li>
<li>第三次<code>follow_page_mask(无FOLL_WRITE)</code>，page不在内存中，进行pagefault处理。</li>
<li>第四次<code>follow_page_mask(无FOLL_WRITE)</code>,成功返回page，但没有使用COW机制。</li>
</ol>
<h1 id="Lab6"><a href="#Lab6" class="headerlink" title="Lab6"></a>Lab6</h1><h2 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h2><h3 id="0-项目组成-2"><a href="#0-项目组成-2" class="headerlink" title="0.项目组成"></a>0.项目组成</h3><p>相对与实验五，实验六主要增加的文件如上表红色部分所示，主要修改的文件如上表紫色部分所示。主要改动如下： 简单说明如下：</p>
<ul>
<li>libs/skew_heap.h: 提供了基本的优先队列数据结构，为本次实验提供了抽象数据结构方面的支持。</li>
<li>kern/process/proc.[ch]：proc.h中扩展了proc_struct的成员变量，用于RR和stride调度算法。proc.c中实现了lab6_set_priority，用于设置进程的优先级。</li>
<li>kern/schedule/{sched.h,sched.c}: 定义了 ucore 的调度器框架，其中包括相关的数据结构（包括调度器的接口和运行队列的结构），和具体的运行时机制。</li>
<li>kern/schedule/{default_sched.h,default_sched.c}: 具体的 round-robin 算法，在本次实验中你需要了解其实现。</li>
<li>kern/schedule/default_sched_stride_c: Stride Scheduling调度器的基本框架，在此次实验中你需要填充其中的空白部分以实现一个完整的 Stride 调度器。</li>
<li>kern/syscall/syscall.[ch]: 增加了sys_gettime系统调用，便于用户进程获取当前时钟值；增加了sys_lab6_set_priority系统调用，便于用户进程设置进程优先级（给priority.c用）</li>
<li>user/{matrix.c,priority.c,. . . }: 相关的一些测试用户程序，测试调度算法的正确性，user目录下包含但不限于这些程序。在完成实验过程中，建议阅读这些测试程序，以了解这些程序的行为，便于进行调试。</li>
</ul>
<h3 id="1-流程概述"><a href="#1-流程概述" class="headerlink" title="1.流程概述"></a>1.流程概述</h3><p>实验中涉及了idle进程的概念。当cpu没有进程可以执行的时候，系统应该如何工作？在实验五的scheduler实现中，ucore内核不断的遍历进程池，直到找到第一个runnable状态的 process，调用并执行它。也就是说，当系统没有进程可以执行的时候，它会把所有 cpu 时间用在搜索进程池，以实现 idle的目的。但是这样的设计不被大多数操作系统所采用，原因在于它将进程调度和 idle 进程两种不同的概念混在了一起，而且，当调度器比较复杂时，schedule 函数本身也会比较复杂，这样的设计结构很不清晰而且难免会出现错误。所以在此次实验中，ucore建立了一个单独的进程(kern/process/proc.c 中的 idleproc)作为 cpu 空闲时的 idle 进程，这个程序是通常一个死循环。你需要了解这个程序的实现。</p>
<h3 id="2-新增的内容"><a href="#2-新增的内容" class="headerlink" title="2.新增的内容"></a>2.新增的内容</h3><p>ucore定义的进程控制块struct proc_struct包含了成员变量state,用于描述进程的运行状态，而running和runnable共享同一个状态(state)值PROC_RUNNABLE。</p>
<p>Lab5中有一个全局变量<code>list_entry_t proc_list</code>, 用来存放所有的进程, wakeup_proc()函数只要设置进程为PROC_RUNNABLE, 然后调度函数再遍历proc_list就能取出下一个进程.</p>
<p>在Lab6中，runnable的进程会被放在运行队列<code>struct run_queue *rq</code>中。值得注意的是，不同之处在于处于running态的进程不会放在运行队列中, 会被直接dequeue.</p>
<h2 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h2><h3 id="练习0-1"><a href="#练习0-1" class="headerlink" title="练习0"></a>练习0</h3><blockquote>
<p>填写前几个lab的代码并且补充一些内容</p>
</blockquote>
<p>遇到了大问题, 最后clone了肖佬的Lab6, 然后改成我自己的代码才过了编译. 实在无法理解为什么会在check_pgfault()这函数上出错.</p>
<h3 id="练习1-3"><a href="#练习1-3" class="headerlink" title="练习1"></a>练习1</h3><blockquote>
<p>分析了解lab6采用RR调度算法后的执行过程</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// The introduction of scheduling classes is borrrowed from Linux, and makes the </span><br><span class="hljs-comment">// core scheduler quite extensible. These classes (the scheduler modules) encapsulate </span><br><span class="hljs-comment">// the scheduling policies. </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_class</span> &#123;</span><br>    <span class="hljs-comment">// the name of sched_class</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>    <span class="hljs-comment">// Init the run queue</span><br>    <span class="hljs-keyword">void</span> (*init)(struct run_queue *rq);<br>    <span class="hljs-comment">// put the proc into runqueue, and this function must be called with rq_lock</span><br>    <span class="hljs-keyword">void</span> (*enqueue)(struct run_queue *rq, struct proc_struct *proc);<br>    <span class="hljs-comment">// get the proc out runqueue, and this function must be called with rq_lock</span><br>    <span class="hljs-keyword">void</span> (*dequeue)(struct run_queue *rq, struct proc_struct *proc);<br>    <span class="hljs-comment">// choose the next runnable task</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *(*<span class="hljs-title">pick_next</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">run_queue</span> *<span class="hljs-title">rq</span>);</span><br>    <span class="hljs-comment">// dealer of the time-tick</span><br>    <span class="hljs-keyword">void</span> (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);<br>    <span class="hljs-comment">/* for SMP support in the future</span><br><span class="hljs-comment">     *  load_balance</span><br><span class="hljs-comment">     *     void (*load_balance)(struct rq* rq);</span><br><span class="hljs-comment">     *  get some proc from this rq, used in load_balance,</span><br><span class="hljs-comment">     *  return value is the num of gotten proc</span><br><span class="hljs-comment">     *  int (*get_proc)(struct rq* rq, struct proc* procs_moved[]);</span><br><span class="hljs-comment">     */</span><br>&#125;;<br><br></code></pre></div></td></tr></table></figure>

<p>上面的代码即为sched_class, 如果要使用函数指针只要sched_class-&gt;init(…)这样即可</p>
<p>时间片轮转算法在os_kernel_lab\labcodes\lab6\kern\schedule\default_sched.c中, 给每个进程分配时间片的FCFS算法, 简单的入队出队, RR_proc_tick()自减剩余时间片, 判断是否为零, 设置need_resched=1等等, 并不复杂.</p>
<p>在实验报告中完成：</p>
<ul>
<li>请理解并分析sched_class中各个函数指针的用法，并结合Round Robin 调度算法描ucore的调度执行过程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">schedule</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">next</span>;</span><br>    local_intr_save(intr_flag);  <span class="hljs-comment">//inhibit interrupt</span><br>    &#123;<br>        current-&gt;need_resched = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (current-&gt;state == PROC_RUNNABLE) &#123;<br>            <span class="hljs-comment">//change from list search to function</span><br>            sched_class_enqueue(current);<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((next = sched_class_pick_next()) != <span class="hljs-literal">NULL</span>) &#123;<br>            sched_class_dequeue(next);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">NULL</span>) &#123;<br>            next = idleproc;<br>        &#125;<br>        next-&gt;runs ++;<br>        <span class="hljs-keyword">if</span> (next != current) &#123;<br>            proc_run(next);<br>        &#125;<br>    &#125;<br>    local_intr_restore(intr_flag);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>首先是schedule函数, 他被调用的函数在下表:</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>位置</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>proc.c::do_exit</td>
<td>用户线程执行结束，主动放弃CPU控制权。</td>
</tr>
<tr>
<td>2</td>
<td>proc.c::do_wait</td>
<td>用户线程等待子进程结束，主动放弃CPU控制权。</td>
</tr>
<tr>
<td>3</td>
<td>proc.c::init_main</td>
<td>1. initproc内核线程等待所有用户进程结束，如果没有结束，就主动放弃CPU控制权; 2. initproc内核线程在所有用户进程结束后，让kswapd内核线程执行10次，用于回收空闲内存资源</td>
</tr>
<tr>
<td>4</td>
<td>proc.c::cpu_idle</td>
<td>idleproc内核线程的工作就是等待有处于就绪态的进程或线程，如果有就调用schedule函数</td>
</tr>
<tr>
<td>5</td>
<td>sync.h::lock</td>
<td>在获取锁的过程中，如果无法得到锁，则主动放弃CPU控制权</td>
</tr>
<tr>
<td>6</td>
<td>trap.c::trap</td>
<td>如果在当前进程在用户态被打断去，且当前进程控制块的成员变量need_resched设置为1，则当前线程会放弃CPU控制权(<strong>这个感觉挺特别的, 如果需要被调度, 那么只要因为个什么软中断跳转到内核状态进行执行的时候就会放弃控制权. 这实际上体现了对用户进程的可抢占性, 而且是随机抢占</strong>)</td>
</tr>
</tbody></table>
<p>选取下一个完成之后, next变量作为proc_run()的参数进而执行next中的进程.</p>
<ul>
<li>请在实验报告中简要说明如何设计实现”多级反馈队列调度算法“，给出概要设计，鼓励给出详细设计</li>
</ul>
<p><strong>多级反馈队列算法（MLFQ)</strong> </p>
<p>进程可<strong>在不同队列间移动</strong>的多级队列算法, 时间片大小随优先级级别的增加而增加,<br>例如进程在当前时间片内没有完成，则降到下一个优先级。</p>
<p>特征：CPU密集型进程优先级下降的很快，IO密集型进程停留在高优先级</p>
<p><strong>大概设计:</strong> </p>
<p>多级反馈队列要有多个<code>run_queue</code>, 每个queue的时间片不同.</p>
<blockquote>
<p>假设有三个run_queue, rq0, rq1, rq2, 固定时间片为5, 队列间调度使用RR算法, 时间片长度为10, 8, 6</p>
</blockquote>
<ul>
<li><p>sched_init(): 首先list_init()一下三个rq, 将函数指针结构体赋值一下, 设置当前rq=rq0</p>
</li>
<li><p>sched_class_proc_tick: 在时钟中断里被调用, 如果当前时间片用完了, 则设置need_resched为1</p>
</li>
<li><p>sched_pick_next: 判断当前queue时间片以及当前进程时间片是否用完, 前者用完则rq切换到下一个queue, 后者用完rq不变, 从rq取出第一个进程</p>
</li>
<li><p>sched_enqueue: 通过run_times判断为CPU密集或者IO密集, 通过设定阈值来加入到三个不同的queu中</p>
</li>
<li><p>sched_dequeue: delete就完事了</p>
</li>
</ul>
<h3 id="练习2-3"><a href="#练习2-3" class="headerlink" title="练习2"></a>练习2</h3><p><a target="_blank" rel="noopener" href="http://www.waldspurger.org/carl/papers/phd-mit-tr667.pdf">stride算法论文</a> </p>
<h3 id="Challenge-1-1"><a href="#Challenge-1-1" class="headerlink" title="Challenge 1"></a>Challenge 1</h3><blockquote>
<p>实现 Linux 的 CFS 调度算法</p>
</blockquote>
<h1 id="Lab7"><a href="#Lab7" class="headerlink" title="Lab7"></a>Lab7</h1><h2 id="知识点-6"><a href="#知识点-6" class="headerlink" title="知识点"></a>知识点</h2><h3 id="00-基础原理"><a href="#00-基础原理" class="headerlink" title="00.基础原理"></a>00.<a target="_blank" rel="noopener" href="https://kiprey.github.io/2020/09/uCore-7/#%E7%9F%A5%E8%AF%86%E7%82%B9">基础原理</a></h3><h3 id="0-项目组成-3"><a href="#0-项目组成-3" class="headerlink" title="0.项目组成"></a>0.项目组成</h3><ul>
<li>kern/schedule/{sched.h,sched.c}: 增加了定时器（timer）机制，用于进程/线程的do_sleep功能。</li>
<li>kern/sync/sync.h: <strong>去除了lock实现（这对于不抢占内核没用。</strong> </li>
<li>kern/sync/wait.[ch]: 定义了等待队列wait_queue结构和等待entry的wait结构以及在此之上的函数，这是ucore中的信号量semophore机制和条件变量机制的基础，在本次实验中你需要了解其实现。</li>
<li>kern/sync/sem.[ch]:定义并实现了ucore中内核级信号量相关的数据结构和函数，本次试验中你需要了解其中的实现，并基于此完成内核级条件变量的设计与实现。</li>
<li>user/ libs/ {syscall.[ch],ulib.[ch] }与kern/sync/syscall.c：实现了进程sleep相关的系统调用的参数传递和调用关系。</li>
<li>user/{ sleep.c,sleepkill.c}: 进程睡眠相关的一些测试用户程序。</li>
<li>kern/sync/monitor.[ch]:基于管程的条件变量的实现程序，在本次实验中是练习的一部分，要求完成。</li>
<li>kern/sync/check_sync.c：实现了基于管程的哲学家就餐问题，在本次实验中是练习的一部分，要求完成基于管程的哲学家就餐问题。</li>
<li>kern/mm/vmm.[ch]：用信号量mm_sem取代mm_struct中原有的mm_lock。（本次实验不用管）</li>
</ul>
<h3 id="1-定时器相关"><a href="#1-定时器相关" class="headerlink" title="1.定时器相关"></a>1.定时器相关</h3><p>在<code>sched.h</code>中定义了定时器中断相关的函数:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sched_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wakeup_proc</span><span class="hljs-params">(struct proc_struct *proc)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">schedule</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_timer</span><span class="hljs-params">(<span class="hljs-keyword">timer_t</span> *timer)</span></span>;     <span class="hljs-comment">// add timer to timer_list</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del_timer</span><span class="hljs-params">(<span class="hljs-keyword">timer_t</span> *timer)</span></span>;     <span class="hljs-comment">// del timer from timer_list</span><br><span class="hljs-comment">// call scheduler to update tick related info, and check the timer is expired? If expired, then wakup proc</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run_timer_list</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br></code></pre></div></td></tr></table></figure>

<p>add_timer函数只在do_sleep中会被用到, 用于设定sleep的时长, 然后通过时钟中断里的run_timer_lsit来找到expired的进程, 从而继续执行.</p>
<h3 id="2-等待队列实现"><a href="#2-等待队列实现" class="headerlink" title="2.等待队列实现"></a>2.等待队列实现</h3><h4 id="基本结构和函数"><a href="#基本结构和函数" class="headerlink" title="基本结构和函数"></a>基本结构和函数</h4><p>需要等待事件的进程在转入休眠状态后插入到等待队列中。当事件发生之后，内核遍历相应等待队列，唤醒休眠的用户进程或内核线程，并设置其状态为就绪状态（PROC_RUNNABLE），并将该进程从等待队列中清除。ucore在kern/sync/{ wait.h, wait.c }中实现了等待项wait结构和等待队列wait queue结构以及相关函数），这是实现ucore中的信号量机制和条件变量机制的基础</p>
<blockquote>
<p>总结一下, 到目前为止出现了几个queue, 一个是放着所有进程的proc_list, 用于get_pid(), kern_thread()等等函数; 第二个是<code>struct run_queue *rq</code>, 即运行队列, 当然不仅仅只是一个链表头, 也可以是heap的head; 第三个是这里的等待队列wait_queue, 实现在下面:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-string">&quot;数据结构&quot;</span><br><span class="hljs-keyword">typedef</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span>;</span>     <span class="hljs-comment">//等待进程的指针</span><br>    <span class="hljs-keyword">uint32_t</span> wakeup_flags;        <span class="hljs-comment">//进程被放入等待队列的原因标记</span><br>    <span class="hljs-keyword">wait_queue_t</span> *wait_queue;     <span class="hljs-comment">//指向此wait结构所属于的wait_queue</span><br>    <span class="hljs-keyword">list_entry_t</span> wait_link;       <span class="hljs-comment">//用来组织wait_queue中wait节点的连接</span><br>&#125; <span class="hljs-keyword">wait_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">list_entry_t</span> wait_head;       <span class="hljs-comment">//wait_queue的队头</span><br>&#125; <span class="hljs-keyword">wait_queue_t</span>;<br><br>le2wait(le, member)               <span class="hljs-comment">//实现wait_t中成员的指针向wait_t 指针的转化</span><br></code></pre></div></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-string">&quot;底层相关函数, 定义queue级别的操作, wakeup等操作是由高层函数实现的&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_init</span><span class="hljs-params">(<span class="hljs-keyword">wait_t</span> *wait, struct proc_struct *proc)</span></span>;    <span class="hljs-comment">//初始化wait结构</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">wait_in_queue</span><span class="hljs-params">(<span class="hljs-keyword">wait_t</span> *wait)</span></span>;                          <span class="hljs-comment">//wait是否在wait queue中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_queue_init</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>)</span></span>;                 <span class="hljs-comment">//初始化wait_queue结构</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_queue_add</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait)</span></span>;    <span class="hljs-comment">//把wait前插到wait queue中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_queue_del</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait)</span></span>;    <span class="hljs-comment">//从wait queue中删除wait</span><br><span class="hljs-comment">//下两个参数中的queue用于assert检查</span><br><span class="hljs-function"><span class="hljs-keyword">wait_t</span> *<span class="hljs-title">wait_queue_next</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait)</span></span>;<span class="hljs-comment">//取得wait的后一个链接指针</span><br><span class="hljs-function"><span class="hljs-keyword">wait_t</span> *<span class="hljs-title">wait_queue_prev</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait)</span></span>;<span class="hljs-comment">//取得wait的前一个链接指针</span><br><span class="hljs-function"><span class="hljs-keyword">wait_t</span> *<span class="hljs-title">wait_queue_first</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>)</span></span>;             <span class="hljs-comment">//取得wait queue的第一个wait</span><br><span class="hljs-function"><span class="hljs-keyword">wait_t</span> *<span class="hljs-title">wait_queue_last</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>)</span></span>;              <span class="hljs-comment">//取得wait queue的最后一个wait</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">wait_queue_empty</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>)</span></span>;                <span class="hljs-comment">//wait queue是否为空</span><br></code></pre></div></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-string">&quot;高层函数&quot;</span><br><span class="hljs-comment">//让wait与进程关联，且让当前进程关联的wait进入等待队列queue，当前进程睡眠</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_current_set</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait, <span class="hljs-keyword">uint32_t</span> wait_state)</span></span>;<br><span class="hljs-comment">//把与当前进程关联的wait从等待队列queue中删除</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_current_del</span><span class="hljs-params">(<span class="hljs-built_in">queue</span>, wait)</span></span>;<br><span class="hljs-comment">//下面三个函数中的del是指是否删除</span><br><span class="hljs-comment">//唤醒与wait关联的进程, 调用wakeup_proc()-&gt;sche_class_enqueue()把proc加入到rq里</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wakeup_wait</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait, <span class="hljs-keyword">uint32_t</span> wakeup_flags, <span class="hljs-keyword">bool</span> del)</span></span>;<br><span class="hljs-comment">//唤醒等待队列上挂着的第一个wait所关联的进程</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wakeup_first</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">uint32_t</span> wakeup_flags, <span class="hljs-keyword">bool</span> del)</span></span>;<br><span class="hljs-comment">//唤醒等待队列上所有的等待的进程, 会调用wakeup_wait和wait_queue_first(next)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wakeup_queue</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">uint32_t</span> wakeup_flags, <span class="hljs-keyword">bool</span> del)</span></span>;<br></code></pre></div></td></tr></table></figure>

<p>内核前面的流程还是一样的, 由proc_init()函数创建第一个内核进程idleproc, 然后调用kern_thread()创建第二个内核进程initproc, 这个进程会执行init_main函数. 但是一切都还未发生, 直到cpu_idle()函数发现当前(idleproc)的need_resched==1, 换成initproc开始执行, 在这个lab中init_main加上了check_sync()用来检查哲学家思考问题.</p>
<p>下面是调用关系示例:</p>
<h4 id="up-V操作"><a href="#up-V操作" class="headerlink" title="__up(): V操作"></a>__up(): V操作</h4><p><img src="../../image/ucore/up.gif" srcset="/img/loading.gif" lazyload alt="up"></p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> __noinline <span class="hljs-keyword">void</span> __up(<span class="hljs-keyword">semaphore_t</span> *sem, <span class="hljs-keyword">uint32_t</span> wait_state) &#123;<br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    local_intr_save(intr_flag);<br>    &#123;<span class="hljs-comment">//屏蔽中断</span><br>        <span class="hljs-keyword">wait_t</span> *wait;<br>        <span class="hljs-keyword">if</span> ((wait = wait_queue_first(&amp;(sem-&gt;wait_queue))) == <span class="hljs-literal">NULL</span>) <br>        &#123;<span class="hljs-comment">//意味着没有等待的进程</span><br>            sem-&gt;value ++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//否则要唤醒</span><br>            wakeup_wait(&amp;(sem-&gt;wait_queue), wait, wait_state, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    local_intr_restore(intr_flag);<br><br></code></pre></div></td></tr></table></figure>

<h4 id="down-P操作"><a href="#down-P操作" class="headerlink" title="__down(): P操作"></a>__down(): P操作</h4><p><img src="../../image/ucore/down.gif" srcset="/img/loading.gif" lazyload alt="down"></p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> __noinline <span class="hljs-keyword">uint32_t</span> __down(<span class="hljs-keyword">semaphore_t</span> *sem, <span class="hljs-keyword">uint32_t</span> wait_state) &#123;<br>    <span class="hljs-comment">//realize P operation</span><br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    local_intr_save(intr_flag);	<span class="hljs-comment">//save the interrupt flag</span><br>    <span class="hljs-keyword">if</span> (sem-&gt;value &gt; <span class="hljs-number">0</span>) &#123;	<span class="hljs-comment">//能够获取信号量</span><br>        sem-&gt;value --;<br>        local_intr_restore(intr_flag);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//无法获得信号量时:</span><br>    <span class="hljs-keyword">wait_t</span> __wait, *wait = &amp;__wait;<br>    wait_current_set(&amp;(sem-&gt;wait_queue), wait, wait_state); <span class="hljs-comment">//加入等待队列</span><br>    local_intr_restore(intr_flag);	<span class="hljs-comment">//关中断</span><br><br>    schedule();<span class="hljs-comment">//选择另一个进程执行</span><br><br>    local_intr_save(intr_flag);<span class="hljs-comment">//如果被另一个V操作(up函数)唤醒, 继续执行</span><br>    wait_current_del(&amp;(sem-&gt;wait_queue), wait);<span class="hljs-comment">//从wait队列中删除</span><br>    local_intr_restore(intr_flag);<br><br>    <span class="hljs-keyword">if</span> (wait-&gt;wakeup_flags != wait_state) &#123;<br>        <span class="hljs-keyword">return</span> wait-&gt;wakeup_flags;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3.信号量"></a>3.信号量</h3><p>信号量的数据结构定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">int</span> value;                   <span class="hljs-comment">//信号量的当前值</span><br>    <span class="hljs-keyword">wait_queue_t</span> wait_queue;     <span class="hljs-comment">//信号量对应的等待队列</span><br>&#125; <span class="hljs-keyword">semaphore_t</span>;<br></code></pre></div></td></tr></table></figure>

<p>__up()和__down()的分析在上面.</p>
<p>对照信号量的原理性描述和具体实现，可以发现二者在流程上基本一致，只是具体实现采用了关中断的方式保证了对共享资源的互斥访问，通过等待队列让无法获得信号量的进程睡眠等待。</p>
<h3 id="4-管程-monitor-和条件变量"><a href="#4-管程-monitor-和条件变量" class="headerlink" title="4.管程(monitor)和条件变量"></a>4.管程(monitor)和条件变量</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://kiprey.github.io/2020/09/uCore-7/#5-%E7%AE%A1%E7%A8%8B">原理</a> </p>
</blockquote>
<p>ucore中的管程机制是基于信号量和条件变量来实现的。ucore中的管程的数据结构monitor_t定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">monitor</span>&#123;</span><br>    <span class="hljs-keyword">semaphore_t</span> mutex;	<span class="hljs-comment">// the mutex lock for going into the routines in monitor, should be initialized to 1</span><br>    <span class="hljs-comment">// the next semaphore is used to </span><br>    <span class="hljs-comment">//    (1) procs which call cond_signal funciton should DOWN next sema after UP cv.sema</span><br>    <span class="hljs-comment">// OR (2) procs which call cond_wait funciton should UP next sema before DOWN cv.sema</span><br>    <span class="hljs-keyword">semaphore_t</span> next;        <br>    <span class="hljs-keyword">int</span> next_count;         <span class="hljs-comment">// the number of of sleeped procs which cond_signal funciton</span><br>    <span class="hljs-keyword">condvar_t</span> *cv;          <span class="hljs-comment">// the condvars(是一个array) in monitor</span><br>&#125; <span class="hljs-keyword">monitor_t</span>;<br></code></pre></div></td></tr></table></figure>

<p>Since a signaling process must wait until the resumed process either leaves or waits, an additional binary semaphore, next, is introduced, initialized to 0. ==The signaling processes can use next to suspend themselves==. An integer variable next count is also provided to count the number of processes suspended on next. </p>
<p>管程中的条件变量的数据结构condvar_t定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">condvar</span>&#123;</span><br><span class="hljs-comment">// the sem semaphore is used to down the waiting proc, and the signaling proc should up the waiting proc</span><br>    <span class="hljs-keyword">semaphore_t</span> sem;     <br>    <span class="hljs-keyword">int</span> count;       　    <span class="hljs-comment">// the number of waiters on condvar</span><br>    <span class="hljs-keyword">monitor_t</span> * owner;     <span class="hljs-comment">// the owner(monitor) of this condvar</span><br>&#125; <span class="hljs-keyword">condvar_t</span>;<br></code></pre></div></td></tr></table></figure>

<p>条件变量的定义中也包含了一系列的成员变量，信号量sem用于让发出<code>wait_cv</code>操作的等待某个条件Cond为真的进程睡眠，而让发出<code>signal_cv</code>操作的进程通过这个sem来唤醒睡眠的进程, <strong>可以看出条件变量是信号量的高层封装.</strong> </p>
<p>要看懂monitor还可以看看他的初始化函数:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// Initialize monitor.</span><br><span class="hljs-keyword">void</span>  <span class="hljs-comment">//monitor中的cv其实是一个数组头, 大小是这个函数的num_cv参数, 能存放多个条件变量, 这样方便管程控制</span><br>monitor_init (<span class="hljs-keyword">monitor_t</span> * mtp, <span class="hljs-keyword">size_t</span> num_cv) &#123;	<br>    <span class="hljs-keyword">int</span> i;<br>    assert(num_cv&gt;<span class="hljs-number">0</span>);<br>    mtp-&gt;next_count = <span class="hljs-number">0</span>;<br>    mtp-&gt;cv = <span class="hljs-literal">NULL</span>;<br>    sem_init(&amp;(mtp-&gt;mutex), <span class="hljs-number">1</span>); <span class="hljs-comment">//unlocked</span><br>    sem_init(&amp;(mtp-&gt;next), <span class="hljs-number">0</span>);	<span class="hljs-comment">//注意到这两个的初始化并不一致, next一开始是空的</span><br>    mtp-&gt;cv =(<span class="hljs-keyword">condvar_t</span> *)kmalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">condvar_t</span>)*num_cv);<br>    assert(mtp-&gt;cv!=<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;num_cv; i++)&#123;<span class="hljs-comment">//初始化条件变量</span><br>        mtp-&gt;cv[i].count=<span class="hljs-number">0</span>;<br>        sem_init(&amp;(mtp-&gt;cv[i].sem),<span class="hljs-number">0</span>);<br>        mtp-&gt;cv[i].owner=mtp;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>ucore设计实现了条件变量<code>wait_cv</code>操作和<code>signal_cv</code>操作对应的具体函数，即<code>cond_wait</code>函数和<code>cond_signal</code>函数，此外还有<code>cond_init</code>初始化函数（可直接看源码）</p>
<p><strong>signal_cv的原理描述</strong></p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span>( cv.count &gt; <span class="hljs-number">0</span>) &#123;	<span class="hljs-comment">//如果该cv上没有等待的进程, 直接跳过</span><br>   monitor.next_count ++;	<span class="hljs-comment">//否则next_count++</span><br>   sem_signal(cv.sem);		<span class="hljs-comment">//唤醒队列中第一个进程</span><br>   sem_wait(monitor.next);	<span class="hljs-comment">//一开始的时候next.value=0, 当前进程肯定会被挂起并schedule();</span><br>                            <span class="hljs-comment">//后来(???</span><br>   monitor.next_count -- ;	<span class="hljs-comment">//被唤醒后就减掉了</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>实际代码是差不多的:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(cvp-&gt;count&gt;<span class="hljs-number">0</span>) &#123;<br>    cvp-&gt;owner-&gt;next_count ++;<br>    up(&amp;(cvp-&gt;sem));<br>    down(&amp;(cvp-&gt;owner-&gt;next));<br>    cvp-&gt;owner-&gt;next_count --;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>wait_cv的原理描述</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">cv.count++;	<span class="hljs-comment">//等待数量+1</span><br><span class="hljs-keyword">if</span>(monitor.next_count &gt; <span class="hljs-number">0</span>)	<span class="hljs-comment">//有大于等于1个进程执行cond_signal函数且sleep</span><br>   sem_signal(monitor.next);<span class="hljs-comment">//唤醒wait_queue第一个进程</span><br><span class="hljs-keyword">else</span>	<span class="hljs-comment">//没有进程因执行cond_signal而挂起</span><br>   sem_signal(monitor.mutex);	<span class="hljs-comment">//解开互斥锁, 好让其他进程进入管程</span><br>sem_wait(cv.sem);	<span class="hljs-comment">//当前进程需要等待信号(见下方)</span><br>cv.count --;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>有一点迷惑的地方在于等待信号是在程序中判断的吗? 看代码确实是这个意思, 到了sem_wait就一定会等待(通过相邻哲学家的情况提前signal_cv, 设置state_condvar, 然后sem_wait都用不着判断cv.sem的value, 肯定是0.</p>
<p>没有弄清楚什么是必须写在操作系统里的什么是要写在程序中的</p>
</blockquote>
<p>实际代码:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">cvp-&gt;count++;<br><span class="hljs-keyword">if</span>(cvp-&gt;owner-&gt;next_count &gt; <span class="hljs-number">0</span>)<br>    up(&amp;(cvp-&gt;owner-&gt;next));<br><span class="hljs-keyword">else</span><br>    up(&amp;(cvp-&gt;owner-&gt;mutex));<br>down(&amp;(cvp-&gt;sem));<br>cvp-&gt;count --;<br></code></pre></div></td></tr></table></figure>

<h3 id="5-管程中函数的入口出口设计"><a href="#5-管程中函数的入口出口设计" class="headerlink" title="5.管程中函数的入口出口设计"></a>5.管程中函数的入口出口设计</h3><p>为了让整个管程正常运行，还需在管程中的每个函数的入口和出口增加相关操作，即：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">function_in_monitor （…）<br>&#123;<br>  sem.wait(monitor.mutex);<br><span class="hljs-comment">//-----------------------------</span><br>  the real body of function;<br><span class="hljs-comment">//-----------------------------</span><br>  <span class="hljs-keyword">if</span>(monitor.next_count &gt; <span class="hljs-number">0</span>)<br>     sem_signal(monitor.next);<br>  <span class="hljs-keyword">else</span><br>     sem_signal(monitor.mutex);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这样带来的作用有两个，（1）只有一个进程在执行管程中的函数。（2）避免由于执行了cond_signal函数而睡眠的进程无法被唤醒。</p>
<p>具体是这样工作的: </p>
<ul>
<li>如果1号进程进入了临界区, 然后由于某种原因(比如外部中断)而切换到了另一个也要访问管程的进程2号, 那么2号就会在sem.wait()里被挂起来, 并且通过调度最终换到1号继续执行. </li>
<li>当1号执行到出口时, 他会发现next_count=0, 随后释放mutex锁, 发现1号在等待mutex, 所以将其唤醒, 在下一个中断中, 1号进入睡眠, 2号准备执行. (不一定是紧跟着的, 还要看调度器, 这里只是设置成了RUNNALBE)</li>
<li>2 号执行到出口时发现next_count=1, 于是up一下信号量next, 最终回到一号继续往下执行.</li>
</ul>
<h3 id="6-死锁"><a href="#6-死锁" class="headerlink" title="6.死锁"></a>6.死锁</h3><blockquote>
<p>不用可惜了(bushi <a target="_blank" rel="noopener" href="https://kiprey.github.io/2020/09/uCore-7/#7-%E6%AD%BB%E9%94%81">[link]</a> </p>
</blockquote>
<h4 id="a-死锁概念"><a href="#a-死锁概念" class="headerlink" title="a. 死锁概念"></a>a. 死锁概念</h4><h5 id="1-进程访问资源的流程"><a href="#1-进程访问资源的流程" class="headerlink" title="1) 进程访问资源的流程"></a>1) 进程访问资源的流程</h5><ul>
<li>资源类型R1,R2,…，RmR1,R2,…，Rm: CPU执行时间，内存空间，I/O设备等。</li>
<li>每类资源RiRi有WiWi个实例</li>
<li>进程访问资源的流程<ul>
<li>请求/获取：申请空闲资源</li>
<li>使用/占用：进程占用资源</li>
<li>释放：资源状态由占用变成空闲。</li>
</ul>
</li>
</ul>
<h5 id="2-资源分类"><a href="#2-资源分类" class="headerlink" title="2) 资源分类"></a>2) 资源分类</h5><ul>
<li>可重用资源（Reusable Resource）<ul>
<li>资源不能被删除且自任何时刻只能有一个进程在使用</li>
<li>进程释放资源后，其他进程可重用</li>
<li>可重用资源示例：硬件如处理器、I/O设备等，软件如文件、数据库等</li>
<li>可能出现死锁：每个进程占用一部分资源并请求其他资源</li>
</ul>
</li>
<li>消费资源 (Consumable resource)<ul>
<li>资源创建和销毁</li>
<li>消耗资源示例：中断、信号、消息</li>
<li>可能出现死锁：进程间相互等待接收对方的消息</li>
</ul>
</li>
</ul>
<h5 id="3-出现死锁的必要条件"><a href="#3-出现死锁的必要条件" class="headerlink" title="3) 出现死锁的必要条件"></a>3) 出现死锁的必要条件</h5><ul>
<li>互斥：任何时刻只能有一个进程使用一个资源实例</li>
<li>持有并等待：进程保持至少一个资源，并正在等待获取其他进程持有的资源</li>
<li>非抢占：资源只能在进程使用后自愿释放</li>
<li>循环等待：进程间相互循环等待</li>
</ul>
<h4 id="b-死锁处理方法"><a href="#b-死锁处理方法" class="headerlink" title="b. 死锁处理方法"></a>b. 死锁处理方法</h4><blockquote>
<p>死锁检测较为复杂，通常由应用程序处理死锁，<strong>操作系统会忽略死锁</strong> </p>
</blockquote>
<h5 id="1-死锁预防"><a href="#1-死锁预防" class="headerlink" title="1) 死锁预防"></a>1) 死锁预防</h5><blockquote>
<p>死锁预防（Deadlock Prevention) ： 确保系统永远不会进入死锁状态。</p>
</blockquote>
<p>预防是采用某种策略，<strong>限制</strong>并发进程对资源的请求，使系统在任何时刻都<strong>不满足死锁的必要条件</strong>。</p>
<ul>
<li>互斥：把互斥的共享资源封装成可同时访问的</li>
<li>持有并等待：进程请求资源时，要求它不持有任何其他资源。仅允许进程在开始执行时，一次请求所有需要的资源，但这种做法的资源利用率低。</li>
<li>非抢占：如进程请求不能立即分配的资源，则释放已经占用的资源。只在能够同时获得所有需要资源时，才执行分配操作。</li>
<li>循环等待：对资源排序，要求进程按顺序请求资源。</li>
</ul>
<h5 id="2-死锁避免"><a href="#2-死锁避免" class="headerlink" title="2) 死锁避免"></a>2) 死锁避免</h5><blockquote>
<p>死锁避免（Deadlock Avoidance）：在使用前进行判断，只允许不会出现死锁的进程请求资源。</p>
</blockquote>
<p>利用额外的先验信息，在分配资源时判断是否会出现死锁，只在不会出现死锁时分配资源。</p>
<ul>
<li>要求进程声明需要资源的<strong>最大数目</strong>。</li>
<li>限定<strong>提供</strong>与<strong>分配</strong>的资源数量，确保满足进程的<strong>最大</strong>需求。</li>
<li><strong>动态检查</strong>资源分配状态，确保不会出现环形等待。</li>
</ul>
<p>系统资源分配的安全状态</p>
<ul>
<li>当进程请求资源时，系统判断分配后是否处于安全状态。</li>
<li>系统处于安全状态：针对所有已占用进程，存在安全序列</li>
<li>序列&lt;P1,P2,…,PN&gt;是安全的<ul>
<li>PiPi要求的资源 &lt;= 当前可用资源 + 所有PjPj持有资源。其中<code>j&lt;i</code>。</li>
<li>如果PiPi的资源请求不能马上分配，则PiPi等待所有Pj(j&lt;i)Pj(j&lt;i)完成</li>
<li>PiPi完成后，Pi+1Pi+1可得到所需资源，执行并释放所分配的资源。</li>
<li>最终整个序列的所有PiPi都能获得所需资源。</li>
</ul>
</li>
</ul>
<p><strong>银行家算法</strong>（Banker’s Algorithm）</p>
<blockquote>
<p>银行家算法是一个避免死锁产生的算法，以银行借贷分配策略为基础，判断并保证系统处于安全状态。</p>
</blockquote>
<ul>
<li><p>使用的数据结构</p>
<blockquote>
<p>n = 线程数量， m = 资源类型数量</p>
</blockquote>
<ul>
<li>**Max(总需求量)**：n x m 矩阵，线程TiTi最多请求类型RiRi的资源Max[i,j]Max[i,j]个实例</li>
<li>**Available(剩余空闲量)**：长度为m的向量，当前有Available[i]Available[i]个类型RjRj的资源实例可用</li>
<li>**Allocation(已分配量)**：n x m 矩阵，线程TiTi当前分配了Allocation[i,j]Allocation[i,j]个RjRj的实例</li>
<li>**Need(未来需要量)**： n x m矩阵，线程TiTi未来需要Need[i,j]Need[i,j]个RjRj资源实例。</li>
</ul>
<blockquote>
<p>Need[i,j]=Max[i,j]−Allocation[i,j]Need[i,j]=Max[i,j]−Allocation[i,j]</p>
</blockquote>
</li>
<li><p><strong>安全状态判断</strong></p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">COPY<span class="hljs-comment">// Work和Finish分别是长度为m和n的向量初始化</span><br>Work[m], Finish[n];<br><br>Work = Available; <span class="hljs-comment">// 当前资源剩余空闲量</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>  Finish[i] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程i没结束</span><br><br><span class="hljs-comment">// ...每个线程开始运行并分配资源</span><br><br><span class="hljs-comment">// 在一段时间后</span><br><span class="hljs-comment">// 寻找Need比Work小，同时还未结束的线程Ti</span><br><span class="hljs-keyword">while</span>(Finish[i] == <span class="hljs-literal">false</span> &amp;&amp; Need[i] &lt;= Work)<br>&#123;<br>    <span class="hljs-comment">// 线程i的资源需求量小于当前剩余空闲资源量，所以该线程可以正常结束，并回收该线程的所有资源</span><br>    Work += Allocation[i];<br>    Finish[i] = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// 如果所有线程Ti都满足Finish[i] == true,则系统处于安全状态。</span><br><span class="hljs-keyword">if</span>(Finish == <span class="hljs-literal">true</span>)<br>    Safe;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment">// 反之，系统处于不安全状态。</span><br>    NoSafe;<br></code></pre></div></td></tr></table></figure></li>
<li><p>银行家算法具体设计</p>
<ul>
<li><p>初始化：RequestiRequesti：线程TiTi的资源请求向量， Requesti[j]Requesti[j]：线程TiTi请求资源RjRj的实例</p>
</li>
<li><p>循环：</p>
<ol>
<li><p>如果Requesti&lt;=Need[i]Requesti&lt;=Need[i]，则转到步骤2。否则拒绝资源申请，因为线程已经超过了其最大资源要求。</p>
</li>
<li><p>如果Requesti&lt;=AvailableRequesti&lt;=Available，转到步骤3。否则，TiTi必须等待，因为资源不可用。</p>
</li>
<li><p>通过安全状态判断来确定是否分配资源给TiTi</p>
<ul>
<li><p>生成一个需要判断状态是否安全的资源分配环境</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">COPYAvailable = Available - Request_i;<br>Allocation[i] = Allocation[i] + Request_i;<br>Need[i] = Need[i] - Request_i;<br></code></pre></div></td></tr></table></figure></li>
<li><p>并调用上文的<strong>安全状态判断</strong></p>
<ul>
<li>如果返回结果是<strong>安全</strong>，则将资源分配给TiTi</li>
<li>如果返回结果是<strong>不安全</strong>，系统会拒绝TiTi的资源请求</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="3-死锁检测和恢复"><a href="#3-死锁检测和恢复" class="headerlink" title="3) 死锁检测和恢复"></a>3) 死锁检测和恢复</h5><blockquote>
<p>死锁检测和恢复（Deadlock Detection &amp; Recovery） : 在检测到运行系统进入死锁状态后进行恢复。</p>
</blockquote>
<ul>
<li>特点<ul>
<li>允许系统进入死锁状态</li>
<li>维护系统的资源分配图</li>
<li>定期调用死锁检测算法来搜索图中是否存在死锁</li>
<li>出现死锁时，用死锁恢复机制进行恢复。</li>
</ul>
</li>
</ul>
<h6 id="i-死锁检测"><a href="#i-死锁检测" class="headerlink" title="i. 死锁检测"></a>i. 死锁检测</h6><ul>
<li><p>数据结构</p>
<ul>
<li>**Available(剩余空闲量)**：长度为m的向量，每种类型可用资源的数量</li>
<li>**Allocation(已分配量)**：n x m 矩阵，当前分配给各个进程每种类型资源的数量，进程PiPi拥有资源RiRi的Allocation[i,j]Allocation[i,j]个实例。</li>
</ul>
</li>
<li><p>死锁检测算法</p>
<blockquote>
<p>该算法与银行家算法类似。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">COPY<span class="hljs-comment">// Work和Finish分别是长度为m和n的向量初始化</span><br>Work[m], Finish[n];<br><br>Work = Available; <span class="hljs-comment">// 当前资源剩余空闲量</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>    <span class="hljs-comment">// 如果当前遍历到的线程占用资源，则设置Finish为false</span><br>    <span class="hljs-comment">// 反之，如果当前线程不占用资源，则要么是线程已结束，要么是我们不关心的线程</span><br>    <span class="hljs-keyword">if</span>(Allocation[i] &gt; <span class="hljs-number">0</span>)<br>      Finish[i] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程i没结束</span><br>    <span class="hljs-keyword">else</span><br>      Finish[i] = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// ...每个线程开始运行并分配资源</span><br><br><span class="hljs-comment">// 在一段时间后</span><br><span class="hljs-comment">// 寻找Request比Work小，同时还未结束的线程Ti</span><br><span class="hljs-keyword">while</span>(Finish[i] == <span class="hljs-literal">false</span> &amp;&amp; Request[i] &lt;= Work)<br>&#123;<br>    <span class="hljs-comment">// 线程i的资源需求量小于当前剩余空闲资源量，所以该线程可以正常结束，并回收该线程的所有资源</span><br>    Work += Allocation[i];<br>    Finish[i] = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// 如果所有线程Ti都满足Finish[i] == true,则系统处于正常状态</span><br><span class="hljs-keyword">if</span>(Finish == <span class="hljs-literal">true</span>)<br>    NoDeadlock;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment">// 反之，系统处于死锁状态。</span><br>    Deadlock;<br></code></pre></div></td></tr></table></figure></li>
<li><p>死锁检测算法的使用</p>
<ul>
<li>死锁检测的时间和周期选择依据<ul>
<li>死锁多久可能会发生</li>
<li>多少进程需要被回滚</li>
</ul>
</li>
<li>资源图可能有多个循环，难以分辨”造成“死锁的关键进程</li>
</ul>
</li>
</ul>
<h6 id="ii-死锁恢复"><a href="#ii-死锁恢复" class="headerlink" title="ii. 死锁恢复"></a>ii. 死锁恢复</h6><ul>
<li>进程终止<ul>
<li>终止所有的死锁线程</li>
<li>一次只终止一个进程直到死锁消除</li>
<li>终止进程的顺序应该是<ul>
<li>进程的优先级: 通常是优先级低的</li>
<li>进程已运行时间以及还需运行时间: 希望运行时间短的</li>
<li>进程已占用资源: 占用资源少的</li>
<li>进程完成需要的资源</li>
<li>终止进程数目: 自然是越小越好</li>
<li>进程是交互式还是批处理: 通常是用户交互进程</li>
</ul>
</li>
</ul>
</li>
<li>资源抢占<ul>
<li>选择被抢占进程：最小成本目标</li>
<li>进程回退：返回到一些安全状态，重启进程到安全状态</li>
<li>可能会出现饥饿：同一个进程可能一直被选作被抢占者</li>
</ul>
</li>
</ul>
<h2 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1-4"><a href="#练习1-4" class="headerlink" title="练习1"></a>练习1</h3><blockquote>
<p>理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题</p>
</blockquote>
<p>信号量的实现在知识点中有分析. 这里写哲学家就餐问题检查函数的实现和信号量的联系.</p>
<p>在kern\sync\check_sync.c中有check_sync()函数, 分为使用 信号量的检查 以及 管程的检查, 拿前者说明, 该种检查调用<code>sem_init(&amp;mutex, 1)</code>初始化mutex, 需要设置下面这几个变量存储必要信息. </p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> state_sema[N]; <span class="hljs-comment">/* 记录每个人状态的数组 */</span><br><span class="hljs-keyword">semaphore_t</span> mutex; <span class="hljs-comment">/* 临界区互斥 */</span><br><span class="hljs-keyword">semaphore_t</span> s[N]; <span class="hljs-comment">/* 每个哲学家一个信号量, 表示是否得到了叉子 */</span><br></code></pre></div></td></tr></table></figure>

<p>然后创建五个内核线程, 线程调用的函数为philosopher_using_[semaphore, monitor], 进入一个总共4次的循环. </p>
<p>每次循环就是重复思考, 取叉, 进餐, 放叉几个动作, 模拟进程使用资源的几种操作.</p>
<p>比如取叉会调用<code>phi_take_forks_sema()</code>函数, </p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">phi_take_forks_sema</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> <span class="hljs-comment">/* i：哲学家号码从0到N-1 */</span></span><br><span class="hljs-function"></span>&#123; <br>        down(&amp;mutex); <span class="hljs-comment">/* 进入临界区 */</span><br>        state_sema[i]=HUNGRY; <span class="hljs-comment">/* 记录下哲学家i饥饿的事实 */</span><br>        phi_test_sema(i); <span class="hljs-comment">/* 试图得到两只叉子 */</span><br>        up(&amp;mutex); <span class="hljs-comment">/* 离开临界区 */</span><br>        down(&amp;s[i]); <span class="hljs-comment">/* 如果得不到叉子就阻塞 */</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这是一个互斥的资源请求, <del>我认为该函数可以理解为这就相当于进程使用一种系统调用, 在操作系统层面进行进入和离开临界区的操作.</del> ==好吧信号量这种方法其实是需要程序员写出来的.==</p>
<ul>
<li>先是临界区互斥信号量mutex的P操作(实现在知识点2里), 同一时间只能有一个哲学家进入临界区</li>
<li>然后试图得到两只叉子还要查看左边右边哲学家是否在EATING状态, 得到了就进行该哲学家信号量s[i]的V操作, 表示取到了叉子</li>
<li>最后一句就是如果没取到叉子又进行了P操作, 这时候肯定就阻塞了, 这时候会进行schedule(), 切换到其他进程<ul>
<li>这一步有点特别, 因为要在临界区内进行一次V操作, 然后在外面进行一次P操作检查刚刚是否进行了V操作.</li>
</ul>
</li>
</ul>
<p>如果有其他哲学家使用V操作释放了叉子, 就会调用wakeup_wait()来使该信号量的等待队列里的第一个变成RUNNALBLE, 所有使用这种资源的进程只有这个能就绪, 如果调度器调度到了这个进程就可以继续进行了.</p>
<p>接下来进餐sleep 10个时间片, 然后到了放下叉子. 这时候<strong>需要程序员清楚地知道</strong>放下后需要进行的操作, 这里是检查左右邻座是否在HUNGRY状态, 是的话允许他拿起叉子(通过<code>up(&amp;s[i])</code>).</p>
<p>大概的过程就是这样.</p>
<h3 id="练习2-4"><a href="#练习2-4" class="headerlink" title="练习2"></a>练习2</h3><blockquote>
<p>完成内核级条件变量和基于内核级条件变量的哲学家就餐问题</p>
</blockquote>
<p>管程里的全局变量:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> state_condvar[N];                            <span class="hljs-comment">// the philosopher&#x27;s state: EATING, HUNGARY, THINKING  </span><br><span class="hljs-keyword">monitor_t</span> mt, *mtp=&amp;mt;                          <span class="hljs-comment">// monitor</span><br></code></pre></div></td></tr></table></figure>

<p>而monitor是这样的(重复了一下上面的):</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">monitor</span>&#123;</span><br>    <span class="hljs-keyword">semaphore_t</span> mutex;	<span class="hljs-comment">// the mutex lock for going into the routines in monitor, should be initialized to 1</span><br>    <span class="hljs-comment">// the next semaphore is used to </span><br>    <span class="hljs-comment">//    (1) procs which call cond_signal funciton should DOWN next sema after UP cv.sema</span><br>    <span class="hljs-comment">// OR (2) procs which call cond_wait funciton should UP next sema before DOWN cv.sema</span><br>    <span class="hljs-keyword">semaphore_t</span> next;        <br>    <span class="hljs-keyword">int</span> next_count;         <span class="hljs-comment">// the number of of sleeped procs which cond_signal funciton</span><br>    <span class="hljs-keyword">condvar_t</span> *cv;          <span class="hljs-comment">// the condvars in monitor</span><br>&#125; <span class="hljs-keyword">monitor_t</span>;<br></code></pre></div></td></tr></table></figure>

<p>大致流程跟上面差不多, 在管程内部设置了cv数组来记录是否拿到了叉子, cond_signal和cond_wait的原理和实现在知识点中.</p>
<p><del>这里说明一下问题的流程:</del> </p>
<h1 id="Lab8"><a href="#Lab8" class="headerlink" title="Lab8"></a>Lab8</h1><h2 id="知识点-7"><a href="#知识点-7" class="headerlink" title="知识点"></a>知识点</h2><h3 id="0-项目结构-1"><a href="#0-项目结构-1" class="headerlink" title="0.项目结构"></a>0.项目结构</h3><p>本次实验主要是理解kern/fs目录中的部分文件，并可用user/*.c测试所实现的Simple FS文件系统是否能够正常工作。本次实验涉及到的代码包括：</p>
<ul>
<li>文件系统测试用例： user/*.c：对文件系统的实现进行测试的测试用例；</li>
<li>通用文件系统接口<br>user/libs/file.[ch] | dir.[ch] | syscall.c：与文件系统操作相关的用户库实行；<br>kern/syscall.[ch]：文件中包含文件系统相关的内核态系统调用接口<br>kern/fs/sysfile.[ch]|file.[ch]：通用文件系统接口和实行</li>
<li>文件系统抽象层-VFS<br>kern/fs/vfs/*.[ch]：虚拟文件系统接口与实现</li>
<li>Simple FS文件系统<br>kern/fs/sfs/*.[ch]：SimpleFS文件系统实现</li>
<li>文件系统的硬盘IO接口<br>kern/fs/devs/dev.[ch] | dev_disk0.c：disk0硬盘设备提供给文件系统的I/O访问接口和实现</li>
<li>辅助工具<br>tools/mksfs.c：创建一个Simple FS文件系统格式的硬盘镜像。（<strong>理解此文件的实现细节对理解SFS文件系统很有帮助</strong>）</li>
<li>对内核其它模块的扩充<br>kern/process/proc.[ch]：增加成员变量 struct fs_struct *fs_struct，用于支持进程对文件的访问；重写了do_execve load_icode等函数以支持执行文件系统中的文件。<br>kern/init/init.c：增加调用初始化文件系统的函数fs_init。</li>
</ul>
<h3 id="1-ucore文件系统概述"><a href="#1-ucore文件系统概述" class="headerlink" title="1.ucore文件系统概述"></a>1.ucore文件系统概述</h3><p>ucore的文件系统模型源于Havard的OS161的文件系统和Linux文件系统。但其实这二者都是源于传统的UNIX文件系统设计。UNIX提出了四个文件系统抽象概念：文件(file)、目录项(dentry)、索引节点(inode)和安装点(mount point)。</p>
<ul>
<li><strong>文件</strong>：UNIX文件中的内容可理解为是一有序字节buffer，文件都有一个方便应用程序识别的文件名称（也称文件路径名）。典型的文件操作有读、写、创建和删除等。</li>
<li><strong>目录项</strong>：目录项不是目录（又称文件路径），而是目录的组成部分。在UNIX中目录被看作一种特定的文件，而目录项是文件路径中的一部分。如一个文件路径名是“/test/testfile”，则包含的目录项为：根目录“/”，目录“test”和文件“testfile”，这三个都是目录项。一般而言，目录项包含目录项的名字（文件名或目录名）和目录项的索引节点（见下面的描述）位置。</li>
<li><strong>索引节点</strong>：UNIX将文件的相关元数据信息（如访问控制权限、大小、拥有者、创建时间、数据内容等等信息）存储在一个单独的数据结构中，该结构被称为索引节点。</li>
<li><strong>安装点</strong>：在UNIX中，文件系统被安装在一个特定的文件路径位置，这个位置就是安装点。所有的已安装文件系统都作为根文件系统树中的叶子出现在系统中。</li>
</ul>
<p>上述抽象概念形成了UNIX文件系统的逻辑数据结构，并需要通过一个具体文件系统的架构设计与实现把上述信息映射并储存到磁盘介质上，从而在具体文件系统的磁盘布局（即数据在磁盘上的物理组织）上具体体现出上述抽象概念。比如文件元数据信息存储在磁盘块中的索引节点上。当文件被载入内存时，内核需要使用磁盘块中的索引点来构造内存中的索引节点。</p>
<p>ucore模仿了UNIX的文件系统设计，ucore的文件系统架构主要由四部分组成：</p>
<ul>
<li><strong>通用文件系统访问接口层</strong>：该层提供了一个从用户空间到文件系统的标准访问接口。这一层访问接口让应用程序能够通过一个简单的接口获得ucore内核的文件系统服务。</li>
<li><strong>文件系统抽象层</strong>：向上提供一个一致的接口给内核其他部分（文件系统相关的系统调用实现模块和其他内核功能模块）访问。向下提供一个同样的抽象函数指针列表和数据结构屏蔽不同文件系统的实现细节。</li>
<li><strong>Simple FS文件系统层</strong>：一个基于索引方式的简单文件系统实例。向上通过各种具体函数实现以对应文件系统抽象层提出的抽象函数。向下访问外设接口</li>
<li><strong>外设接口层</strong>：向上提供device访问接口屏蔽不同硬件细节。向下实现访问各种具体设备驱动的接口，比如disk设备接口/串口设备接口/键盘设备接口等。</li>
</ul>
<p>文件系统的访问处理过程: 假如应用程序操作文件（打开/创建/删除/读写），首先需要通过文件系统的通用文件系统访问接口层给用户空间提供的访问接口进入文件系统内部，接着由文件系统抽象层把访问请求转发给某一具体文件系统（比如SFS文件系统），具体文件系统（Simple FS文件系统层）把应用程序的访问请求转化为对磁盘上的block的处理请求，并通过外设接口层交给磁盘驱动例程来完成具体的磁盘操作。结合用户态写文件函数write的整个执行过程，我们可以比较清楚地看出ucore文件系统架构的层次和依赖关系。</p>
<p><img src="../../image/ucore/image001.png" srcset="/img/loading.gif" lazyload alt="image"></p>
<h4 id="自上而下的数据结构"><a href="#自上而下的数据结构" class="headerlink" title="自上而下的数据结构"></a>自上而下的数据结构</h4><p>从ucore操作系统不同的角度来看，ucore中的文件系统架构包含四类主要的数据结构, 它们分别是：</p>
<ul>
<li>超级块（SuperBlock），它主要从文件系统的全局角度描述特定文件系统的全局信息。它的作用范围是整个OS空间。</li>
<li>索引节点（inode）：它主要从文件系统的单个文件的角度它描述了文件的各种属性和数据所在位置。它的作用范围是整个OS空间。</li>
<li>目录项（dentry）：它主要从文件系统的文件路径的角度描述了文件路径中的一个特定的目录项（注：一系列目录项形成目录/文件路径）。它的作用范围是整个OS空间。对于SFS而言，inode(具体为struct sfs_disk_inode)对应于物理磁盘上的具体对象，dentry（具体为struct sfs_disk_entry）是一个内存实体，其中的ino成员指向对应的inode number，另外一个成员是file name(文件名).</li>
<li>文件（file），它主要从进程的角度描述了一个进程在访问文件时需要了解的文件标识，文件读写的位置，文件引用情况等信息。它的作用范围是某一具体进程。</li>
</ul>
<p>如果一个用户进程打开了一个文件，那么在ucore中涉及的相关数据结构和关系如下图所示：</p>
<p><img src="../../image/ucore/image-20220105195357089.png" srcset="/img/loading.gif" lazyload alt="image-20220105195357089"></p>
<p>understand生成的关系图:</p>
<p><img src="../../image/ucore/image-20220105200433737.png" srcset="/img/loading.gif" lazyload alt="image-20220105200433737"></p>
<h3 id="2-系统访问接口层"><a href="#2-系统访问接口层" class="headerlink" title="2.系统访问接口层"></a>2.系统访问接口层</h3><p>从用户态函数syscall-&gt;sys_open(syscall.c)-&gt;sysfile_open(sysfile.c)中:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">uint32_t</span> open_flags)</span></span>;     <span class="hljs-comment">// Open or create a file. FLAGS/MODE per the syscall.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;                                      <span class="hljs-comment">// Close a vnode opened  </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *base, <span class="hljs-keyword">size_t</span> len)</span></span>;               <span class="hljs-comment">// Read file</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *base, <span class="hljs-keyword">size_t</span> len)</span></span>;              <span class="hljs-comment">// Write file</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">off_t</span> pos, <span class="hljs-keyword">int</span> whence)</span></span>;                <span class="hljs-comment">// Seek file  </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_fstat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, struct stat *stat)</span></span>;                   <span class="hljs-comment">// Stat file </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_fsync</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;                                      <span class="hljs-comment">// Sync file</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_chdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path)</span></span>;                            <span class="hljs-comment">// change DIR  </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_mkdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path)</span></span>;                            <span class="hljs-comment">// create DIR</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_link</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path2)</span></span>;         <span class="hljs-comment">// set a path1&#x27;s link as path2</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_rename</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path2)</span></span>;       <span class="hljs-comment">// rename file</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_unlink</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path)</span></span>;                           <span class="hljs-comment">// unlink a path</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_getcwd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">size_t</span> len)</span></span>;                      <span class="hljs-comment">// get current working directory</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_getdirentry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, struct dirent *direntp)</span></span>;        <span class="hljs-comment">// get the file entry in DIR </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_dup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd1, <span class="hljs-keyword">int</span> fd2)</span></span>;                              <span class="hljs-comment">// duplicate file</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *fd_store)</span></span>;                                <span class="hljs-comment">// build PIPE   </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_mkfifo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">uint32_t</span> open_flags)</span></span>;      <span class="hljs-comment">// build named PIPE</span><br></code></pre></div></td></tr></table></figure>

<p>然后调用file.c中具体的实现:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_open</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">uint32_t</span> open_flags)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *base, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">size_t</span> *copied_store)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *base, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">size_t</span> *copied_store)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">off_t</span> pos, <span class="hljs-keyword">int</span> whence)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_fstat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, struct stat *stat)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_fsync</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_getdirentry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, struct dirent *dirent)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_dup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd1, <span class="hljs-keyword">int</span> fd2)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd[])</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_mkfifo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">uint32_t</span> open_flags)</span></span>;<br></code></pre></div></td></tr></table></figure>

<p>sysfile_xxx算是在写操作系统的时候比较常用的函数.</p>
<h3 id="3-VFS层"><a href="#3-VFS层" class="headerlink" title="3.VFS层"></a>3.VFS层</h3><p>VFS有四个接口, 分别是file&amp;dir接口, inode接口, fs接口和外设接口. </p>
<h4 id="file-amp-dir接口"><a href="#file-amp-dir接口" class="headerlink" title="file&amp;dir接口"></a>file&amp;dir接口</h4><p>file&amp;dir接口层(共用一个结构体, 毕竟目录也是一种文件)定义了进程在内核中直接访问的文件相关信息，这定义在file数据结构中，具体描述如下：</p>
<blockquote>
<p>其中fd取决于进程的文件打开顺序, 最大值是<code>(4096 - sizeof(struct files_struct)) / sizeof(struct file)</code><br>而且在fd_array初始化的时候看起来file_struct和file挤满4KB空间, 不过不知道为什么</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,<br>    &#125; status;                         <span class="hljs-comment">//访问文件的执行状态</span><br>    <span class="hljs-keyword">bool</span> readable;                    <span class="hljs-comment">//文件是否可读</span><br>    <span class="hljs-keyword">bool</span> writable;                    <span class="hljs-comment">//文件是否可写</span><br>    <span class="hljs-keyword">int</span> fd;                           <span class="hljs-comment">//文件在filemap中的索引值</span><br>    <span class="hljs-keyword">off_t</span> pos;                        <span class="hljs-comment">//访问文件的当前位置</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">node</span>;</span>               <span class="hljs-comment">//该文件对应的内存inode指针</span><br>    <span class="hljs-keyword">int</span> open_count;                   <span class="hljs-comment">//打开此文件的次数</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>而在kern/process/proc.h中的proc_struct结构中描述了进程访问文件的数据接口files_struct，其数据结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">pwd</span>;</span>                <span class="hljs-comment">//进程当前执行目录的内存inode指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">fd_array</span>;</span>            <span class="hljs-comment">//进程打开文件的数组</span><br>    <span class="hljs-keyword">atomic_t</span> files_count;             <span class="hljs-comment">//访问此文件的线程个数</span><br>    <span class="hljs-keyword">semaphore_t</span> files_sem;            <span class="hljs-comment">//确保对进程控制块中fs_struct的互斥访问</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>当创建一个进程后，该进程的files_struct将会被初始化或复制父进程的files_struct。当用户进程打开一个文件时，将从fd_array数组中取得一个空闲file项，然后会把此file的成员变量node指针指向一个代表此文件的inode的起始地址。</p>
<h4 id="inode接口"><a href="#inode接口" class="headerlink" title="inode接口"></a>inode接口</h4><p><u>index node</u>是位于内存的索引节点，它是VFS结构中的重要数据结构，因为它实际负责把不同文件系统的特定索引节点信息（甚至不能算是一个索引节点）统一封装起来，避免了进程直接访问具体文件系统。其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>                                 <span class="hljs-comment">//包含不同文件系统特定inode信息的union成员变量</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> __<span class="hljs-title">device_info</span>;</span>          <span class="hljs-comment">//设备文件系统内存inode信息</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_inode</span> __<span class="hljs-title">sfs_inode_info</span>;</span>    <span class="hljs-comment">//SFS文件系统内存inode信息</span><br>    &#125; in_info;   <br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>        inode_type_device_info = <span class="hljs-number">0x1234</span>,<br>        inode_type_sfs_inode_info,<br>    &#125; in_type;                          <span class="hljs-comment">//此inode所属文件系统类型</span><br>    <span class="hljs-keyword">atomic_t</span> ref_count;                 <span class="hljs-comment">//此inode的引用计数</span><br>    <span class="hljs-keyword">atomic_t</span> open_count;                <span class="hljs-comment">//打开此inode对应文件的个数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs</span> *<span class="hljs-title">in_fs</span>;</span>                   <span class="hljs-comment">//抽象的文件系统，包含访问文件系统的函数指针</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> *<span class="hljs-title">in_ops</span>;</span>     <span class="hljs-comment">//抽象的inode操作，包含访问inode的函数指针     </span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>其中in_ops是一系列函数指针, 其实并不会全部用到, 只要定义需要的即可:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> vop_magic;<br>    <span class="hljs-keyword">int</span> (*vop_open)(struct inode *node, <span class="hljs-keyword">uint32_t</span> open_flags);<br>    <span class="hljs-keyword">int</span> (*vop_close)(struct inode *node);<br>    <span class="hljs-keyword">int</span> (*vop_read)(struct inode *node, struct iobuf *iob);<br>    <span class="hljs-keyword">int</span> (*vop_write)(struct inode *node, struct iobuf *iob);<br>    <span class="hljs-keyword">int</span> (*vop_fstat)(struct inode *node, struct stat *stat);<br>    <span class="hljs-keyword">int</span> (*vop_fsync)(struct inode *node);<br>    <span class="hljs-keyword">int</span> (*vop_namefile)(struct inode *node, struct iobuf *iob);<br>    <span class="hljs-keyword">int</span> (*vop_getdirentry)(struct inode *node, struct iobuf *iob);<br>    <span class="hljs-keyword">int</span> (*vop_reclaim)(struct inode *node);<br>    <span class="hljs-keyword">int</span> (*vop_gettype)(struct inode *node, <span class="hljs-keyword">uint32_t</span> *type_store);<br>    <span class="hljs-keyword">int</span> (*vop_tryseek)(struct inode *node, <span class="hljs-keyword">off_t</span> pos);<br>    <span class="hljs-keyword">int</span> (*vop_truncate)(struct inode *node, <span class="hljs-keyword">off_t</span> len);<br>    <span class="hljs-keyword">int</span> (*vop_create)(struct inode *node, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">bool</span> excl, struct inode **node_store);<br>    <span class="hljs-keyword">int</span> (*vop_lookup)(struct inode *node, <span class="hljs-keyword">char</span> *path, struct inode **node_store);<br>    <span class="hljs-keyword">int</span> (*vop_ioctl)(struct inode *node, <span class="hljs-keyword">int</span> op, <span class="hljs-keyword">void</span> *data);<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>实际用到的时候会使用宏定义简化, 利用语句块的值是最后一条语句的值来返回函数指针:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __vop_op(node, sym)                                                                         \</span><br><span class="hljs-meta">    (&#123;                                                                                              \</span><br><span class="hljs-meta">        struct inode *__node = (node);                                                              \</span><br><span class="hljs-meta">        assert(__node != NULL &amp;&amp; __node-&gt;in_ops != NULL &amp;&amp; __node-&gt;in_ops-&gt;vop_##sym != NULL);      \</span><br><span class="hljs-meta">        inode_check(__node, #sym);                                                                  \</span><br><span class="hljs-meta">        __node-&gt;in_ops-&gt;vop_##sym;  <span class="hljs-comment">/*把字符连接起来*/</span>                                               \</span><br><span class="hljs-meta">     &#125;)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> vop_open(node, open_flags)                                  (__vop_op(node, open)(node, open_flags))</span><br></code></pre></div></td></tr></table></figure>

<p><code>inode_ops</code>成员是对常规文件、目录、设备文件所有操作的一个抽象函数表示。对于某一具体的文件系统中的文件或目录，只需实现相关的函数，就可以被用户进程访问具体的文件了，且用户进程无需了解具体文件系统的实现细节。</p>
<p><strong>注意到这些是对下一层SFS的接口, 在下一层中被实现.</strong> 可选实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Function table for device inodes.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// The sfs specific DIR operations correspond to the abstract operations on a inode.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> <span class="hljs-title">sfs_node_dirops</span> =</span> &#123;<br>    .vop_magic                      = VOP_MAGIC,<br>    .vop_open                       = sfs_opendir,<br>    .vop_close                      = sfs_close,<br>    .vop_fstat                      = sfs_fstat,<br>    .vop_fsync                      = sfs_fsync,<br>    .vop_namefile                   = sfs_namefile,<br>    .vop_getdirentry                = sfs_getdirentry,<br>    .vop_reclaim                    = sfs_reclaim,<br>    .vop_gettype                    = sfs_gettype,<br>    .vop_lookup                     = sfs_lookup,<br>&#125;;<br><span class="hljs-comment">/// The sfs specific FILE operations correspond to the abstract operations on a inode.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> <span class="hljs-title">sfs_node_fileops</span> =</span> &#123;<br>    .vop_magic                      = VOP_MAGIC,<br>    .vop_open                       = sfs_openfile,<br>    .vop_close                      = sfs_close,<br>    .vop_read                       = sfs_read,<br>    .vop_write                      = sfs_write,<br>    .vop_fstat                      = sfs_fstat,<br>    .vop_fsync                      = sfs_fsync,<br>    .vop_reclaim                    = sfs_reclaim,<br>    .vop_gettype                    = sfs_gettype,<br>    .vop_tryseek                    = sfs_tryseek,<br>    .vop_truncate                   = sfs_truncfile,<br>&#125;;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> <span class="hljs-title">dev_node_ops</span> =</span> &#123;<br>    .vop_magic                      = VOP_MAGIC,<br>    .vop_open                       = dev_open,<br>    .vop_close                      = dev_close,<br>    .vop_read                       = dev_read,<br>    .vop_write                      = dev_write,<br>    .vop_fstat                      = dev_fstat,<br>    .vop_ioctl                      = dev_ioctl,<br>    .vop_gettype                    = dev_gettype,<br>    .vop_tryseek                    = dev_tryseek,<br>    .vop_lookup                     = dev_lookup,<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<h4 id="fs接口"><a href="#fs接口" class="headerlink" title="fs接口"></a>fs接口</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_fs</span> __<span class="hljs-title">sfs_info</span>;</span>                   <br>    &#125; fs_info;                                     <span class="hljs-comment">// filesystem-specific data </span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>        fs_type_sfs_info,<br>    &#125; fs_type;                                     <span class="hljs-comment">// filesystem type </span><br>    <span class="hljs-keyword">int</span> (*fs_sync)(struct fs *fs);                 <span class="hljs-comment">// Flush all dirty buffers to disk </span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *(*<span class="hljs-title">fs_get_root</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">fs</span> *<span class="hljs-title">fs</span>);</span>   <span class="hljs-comment">// Return root inode of filesystem.</span><br>    <span class="hljs-keyword">int</span> (*fs_unmount)(struct fs *fs);              <span class="hljs-comment">// Attempt unmount of filesystem.</span><br>    <span class="hljs-keyword">void</span> (*fs_cleanup)(struct fs *fs);             <span class="hljs-comment">// Cleanup of filesystem.???</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<hr>
<p>所以VFS具体是怎么个抽象法儿呢? </p>
<p>首先是对PCB中的文件进行抽象, 弄一个files_struct管理fd_array, 每个文件使用file进行定义, file中有基本的打开计数权限索引等等, 处于一个非常高的抽象层, 而且是针对用户的.</p>
<p>file中包含了一个index node, node记录了设备文件和SFS文件的inode信息(元数据), <strong>向下给sfs_inode和device提供了接口</strong>.</p>
<p>inode包含一个struct fs*, <strong>而fs向下接到了SFS层的sys_fs</strong>结构体, 这个才是具体到文件系统的总体信息, 比如super dev bitmap, 这些都是文件的磁盘布局信息.</p>
<p>当我们需要对文件file层面操作的时候(比如在path下查找 创建 删除等), 我们可以调用file对应inode(元数据)的函数指针, 实际上是调用了sfs层的函数去进行下一步的操作.</p>
<h3 id="4-SFS层"><a href="#4-SFS层" class="headerlink" title="4.SFS层"></a>4.SFS层</h3><p>SFS文件系统中目录和常规文件具有共同的属性，而这些属性保存在索引节点中。SFS通过索引节点来管理目录和常规文件，索引节点包含操作系统所需要的关于某个文件的关键信息，比如文件的属性、访问许可权以及其它控制信息都保存在索引节点中。多个文件名可指向一个索引节点。</p>
<h4 id="函数接口与数据结构"><a href="#函数接口与数据结构" class="headerlink" title="函数接口与数据结构"></a>函数接口与数据结构</h4><blockquote>
<p>在sfs.h中</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sfs_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_mount</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *devname)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock_sfs_fs</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock_sfs_io</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock_sfs_fs</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock_sfs_io</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_rblock</span><span class="hljs-params">(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">uint32_t</span> nblks)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_wblock</span><span class="hljs-params">(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">uint32_t</span> nblks)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_rbuf</span><span class="hljs-params">(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">off_t</span> offset)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_wbuf</span><span class="hljs-params">(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">off_t</span> offset)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_sync_super</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_sync_freemap</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_clear_block</span><span class="hljs-params">(struct sfs_fs *sfs, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">uint32_t</span> nblks)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_load_inode</span><span class="hljs-params">(struct sfs_fs *sfs, struct inode **node_store, <span class="hljs-keyword">uint32_t</span> ino)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sfs_sync</span><span class="hljs-params">(struct fs *fs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> struct inode* <span class="hljs-title">sfs_get_root</span><span class="hljs-params">(struct fs *fs)</span> </span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sfs_unmount</span><span class="hljs-params">(struct fs *fs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sfs_cleanup</span><span class="hljs-params">(struct fs *fs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fs_init_read</span><span class="hljs-params">(struct device *dev, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">void</span> *blk_buffer)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fs_do_mount</span><span class="hljs-params">(struct device *dev, struct fs **fs_store)</span></span>;<br><span class="hljs-comment">// ......</span><br></code></pre></div></td></tr></table></figure>

<p><code>sfs_fs</code>其实现如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* filesystem for sfs */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_fs</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_super</span> <span class="hljs-title">super</span>;</span>                         <span class="hljs-comment">/* on-disk superblock */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span>                             <span class="hljs-comment">/* device mounted on */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bitmap</span> *<span class="hljs-title">freemap</span>;</span>                         <span class="hljs-comment">/* blocks in use are mared 0 */</span><br>    <span class="hljs-keyword">bool</span> super_dirty;                               <span class="hljs-comment">/* true if super/freemap modified */</span><br>    <span class="hljs-keyword">void</span> *sfs_buffer;                               <span class="hljs-comment">/* buffer for non-block aligned io 缓冲区起始地址*/</span><br>    <span class="hljs-keyword">semaphore_t</span> fs_sem;                             <span class="hljs-comment">/* semaphore for fs */</span><br>    <span class="hljs-keyword">semaphore_t</span> io_sem;                             <span class="hljs-comment">/* semaphore for io */</span><br>    <span class="hljs-keyword">semaphore_t</span> mutex_sem;                          <span class="hljs-comment">/* semaphore for link/unlink and rename */</span><br>    <span class="hljs-keyword">list_entry_t</span> inode_list;                        <span class="hljs-comment">/* inode linked-list 应该是在内存中的*/</span><br>    <span class="hljs-keyword">list_entry_t</span> *hash_list;                        <span class="hljs-comment">/* inode hash linked-list */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p><code>sfs_fs</code>结构中包含了底层设备的超级块<code>superblock</code>、所挂载的设备<code>dev</code>、以及底层设备中用于表示空间分配情况的<code>freemap</code>等。</p>
<h4 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h4><p><img src="../../image/ucore/image-20220105200753016.png" srcset="/img/loading.gif" lazyload alt="image-20220105200753016"></p>
<p>文件系统通常保存在磁盘上。在本实验中，第三个磁盘（即disk0，前两个磁盘分别是 ucore.img 和 swap.img）用于存放一个SFS文件系统（Simple Filesystem）。通常文件系统中，磁盘的使用是以扇区（Sector）为单位的，但是为了实现简便，SFS 中以 <strong>block</strong> （4K，与内存 page 大小相等）为基本单位。</p>
<p>第0个块(4K)是<strong>superblock</strong>，它包含了关于文件系统的所有关键参数，当计算机被启动或文件系统被首次接触时，超级块的内容就会被装入内存。其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_super</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span> magic;                                  <span class="hljs-comment">/* magic number, should be SFS_MAGIC */</span><br>    <span class="hljs-keyword">uint32_t</span> blocks;                                 <span class="hljs-comment">/* # of blocks in fs */</span><br>    <span class="hljs-keyword">uint32_t</span> unused_blocks;                         <span class="hljs-comment">/* # of unused blocks in fs */</span><br>    <span class="hljs-keyword">char</span> info[SFS_MAX_INFO_LEN + <span class="hljs-number">1</span>];                <span class="hljs-comment">/* infomation for sfs  */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>magic number就是一串神秘莫测的数字, 这里用来标识SFS文件系统, 值为0x2f8dbe2a</p>
</blockquote>
<p>需要注意的是虽然inode的大小小于一个块的大小（4096B），<strong>但为了实现简单，每个 inode 都占用一个完整的 block。</strong> </p>
<p>在sfs_fs.c文件中的<code>sfs_do_mount</code>函数中，完成了加载位于硬盘上的SFS文件系统的超级块superblock和freemap的工作。这样，在内存中就有了SFS文件系统的全局信息。</p>
<h4 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h4><p>在<code>sfs</code>层面上，<code>inode</code>结构既可表示文件<code>file</code>、目录<code>dir</code>，也可表示设备<code>device</code>。而区分<code>inode</code>结构的操作有两种，一种是其<code>in_info</code>成员变量，另一种是该结构的成员指针<code>in_ops</code>。以下是函数<code>sfs_get_ops</code>的源码，该函数返回某个属性（文件/目录）所对应的<code>inode</code>操作：</p>
<blockquote>
<p>注意，设置inode_ops的操作不止一处，以下代码只作为示例。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sfs_get_ops - return function addr of fs_node_dirops/sfs_node_fileops</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> struct inode_ops *</span><br><span class="hljs-function"><span class="hljs-title">sfs_get_ops</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> type)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (type) &#123;<br>    <span class="hljs-keyword">case</span> SFS_TYPE_DIR:<br>        <span class="hljs-keyword">return</span> &amp;sfs_node_dirops;<br>    <span class="hljs-keyword">case</span> SFS_TYPE_FILE:<br>        <span class="hljs-keyword">return</span> &amp;sfs_node_fileops;<br>    &#125;<br>    panic(<span class="hljs-string">&quot;invalid file type %d.\n&quot;</span>, type);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>当uCore创建一个<strong>用于存储文件/目录</strong>的<code>inode</code>结构（即该<code>inode</code>结构的<code>in_info</code>成员变量为<code>sfs_inode</code>类型）时，程序会执行函数<code>sfs_create_inode</code>。该函数会<strong>将<code>inode</code>结构中的<code>sfs_inode</code>成员与磁盘对应结点<code>sfs_disk_inode</code>相关联</strong>，从而使得只凭<code>inode</code>即可操作该结点。 </p>
<blockquote>
<p>比如在打开文件的时候, 需要调用<code>sfs_dirent_search_nolock</code>查找路径对应inode, 如果找到了会返回ino编号, 然后调用<code>sfs_load_inode</code>根据ino和sfs找到对应inode, 把对应<code>sfs_disk_inode</code>读到内存中, 然后调用**<code>sfs_create_inode</code>**, 初始化<code>inode</code>里的<code>sfs_inode</code>.</p>
</blockquote>
<blockquote>
<p>用于描述设备<code>device</code>的<code>inode</code>会在其他函数中被初始化，不会执行函数<code>sfs_create_inode</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sfs_create_inode - alloc a inode in memroy, and init din/ino/dirty/reclian_count/sem fields in sfs_inode in inode</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">sfs_create_inode</span><span class="hljs-params">(struct sfs_fs *sfs, struct sfs_disk_inode *din, <span class="hljs-keyword">uint32_t</span> ino, struct inode **node_store)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">node</span>;</span><br>    <span class="hljs-keyword">if</span> ((node = alloc_inode(sfs_inode)) != <span class="hljs-literal">NULL</span>) &#123;<br>        vop_init(node, sfs_get_ops(din-&gt;type), info2fs(sfs, sfs));<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_inode</span> *<span class="hljs-title">sin</span> =</span> vop_info(node, sfs_inode);<br>        <span class="hljs-built_in">sin</span>-&gt;din = din, <span class="hljs-built_in">sin</span>-&gt;ino = ino, <span class="hljs-built_in">sin</span>-&gt;dirty = <span class="hljs-number">0</span>, <span class="hljs-built_in">sin</span>-&gt;reclaim_count = <span class="hljs-number">1</span>;<br>        sem_init(&amp;(<span class="hljs-built_in">sin</span>-&gt;sem), <span class="hljs-number">1</span>);<br>        *node_store = node;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -E_NO_MEM;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h5 id="磁盘索引节点"><a href="#磁盘索引节点" class="headerlink" title="磁盘索引节点"></a>磁盘索引节点</h5><p>就是<code>sfs_disk_inode </code>, understand结构图中最后一个结构体, <strong>保存在磁盘上</strong>.</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* inode (on disk) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_disk_inode</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span> size;                                  <span class="hljs-comment">/* size of the file (in bytes) */</span><br>    <span class="hljs-keyword">uint16_t</span> type;                                  <span class="hljs-comment">/* one of SYS_TYPE_* above */</span><br>    <span class="hljs-keyword">uint16_t</span> nlinks;                                <span class="hljs-comment">/* # of hard links to this file */</span><br>    <span class="hljs-keyword">uint32_t</span> blocks;                                <span class="hljs-comment">/* # of blocks */</span><br>    <span class="hljs-keyword">uint32_t</span> direct[SFS_NDIRECT];                   <span class="hljs-comment">/* direct blocks 存储的是ino编号*/</span><br>    <span class="hljs-keyword">uint32_t</span> indirect;                              <span class="hljs-comment">/* indirect blocks */</span><br><span class="hljs-comment">//    uint32_t db_indirect;                           /* double indirect blocks */</span><br><span class="hljs-comment">//   unused</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>对于文件, <u>索引值</u><strong>指向的</strong>是数据块.</p>
<p>对于目录, <u>索引值</u><strong>指向的</strong>是下面这个结构体。数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* file entry (on disk) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_disk_entry</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span> ino;                                   <span class="hljs-comment">//索引节点所占数据块索引值</span><br>    <span class="hljs-keyword">char</span> name[SFS_MAX_FNAME_LEN + <span class="hljs-number">1</span>];               <span class="hljs-comment">//文件名</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<h5 id="内存索引节点"><a href="#内存索引节点" class="headerlink" title="内存索引节点"></a>内存索引节点</h5><p>即<code>sfs_inode</code>.  需要注意，一个内存inode是在打开一个文件后才创建的，如果关机则相关信息都会消失。<br>而硬盘inode(即<code>sfs_disk_inode</code>)的内容是保存在硬盘中的，只是在进程需要时才被读入到内存中，用于访问文件或目录的具体内容数据</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* inode for sfs */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_inode</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_disk_inode</span> *<span class="hljs-title">din</span>;</span>                     <span class="hljs-comment">/* on-disk inode 一对一指针*/</span><br>    <span class="hljs-keyword">uint32_t</span> ino;                                   <span class="hljs-comment">/* inode number */</span><br>    <span class="hljs-keyword">bool</span> dirty;                                     <span class="hljs-comment">/* true if inode modified */</span><br>    <span class="hljs-keyword">int</span> reclaim_count;                              <span class="hljs-comment">/* kill inode if it hits zero */</span><br>    <span class="hljs-keyword">semaphore_t</span> sem;                                <span class="hljs-comment">/* semaphore for din */</span><br>    <span class="hljs-keyword">list_entry_t</span> inode_link;                        <span class="hljs-comment">/* entry for linked-list in sfs_fs */</span><br>    <span class="hljs-keyword">list_entry_t</span> hash_link;                         <span class="hljs-comment">/* entry for hash linked-list in sfs_fs */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>为了方便实现上面提到的多级数据的访问以及目录中 entry 的操作，对 inode SFS实现了一些<strong>辅助的函数</strong>：</p>
<ol>
<li><code>sfs_bmap_load_nolock</code>：将对应 sfs_inode 的第 index 个索引指向的 block 的<strong>索引值</strong>取出存到相应的指针指向的单元（ino_store）。该函数只接受 index &lt;= inode-&gt;blocks 的参数。当 index == inode-&gt;blocks 时，该函数理解为需要为 inode 增长一个 block。<strong>并标记 inode 为 dirty</strong>（所有对 inode 数据的修改都要做这样的操作，这样，当 inode 不再使用的时候，sfs 能够保证 inode 数据能够被写回到磁盘）。sfs_bmap_load_nolock 调用的 sfs_bmap_get_nolock 来完成相应的操作, 分为直接索引和间接索引两种情况, <u>完成ino的load操作</u>.（sfs_bmap_get_nolock 只由 sfs_bmap_load_nolock 调用）</li>
<li><code>sfs_bmap_truncate_nolock</code>：将多级数据索引表的最后一个 entry 释放掉。<strong>他可以认为是 sfs_bmap_load_nolock 中，index == inode-&gt;blocks 的逆操作</strong>(检测到时就会从freemap中alloc一个)。当一个文件或目录被删除时，sfs 会循环调用该函数直到 inode-&gt;blocks 减为 0，释放所有的数据页。函数通过 sfs_bmap_free_nolock 来实现，他应该是 sfs_bmap_get_nolock 的逆操作。和 sfs_bmap_get_nolock 一样，调用 sfs_bmap_free_nolock 也要格外小心。</li>
<li><code>sfs_dirent_read_nolock</code>：将目录的第 slot 个 entry 读取到指定的内存空间。他通过上面提到的函数来完成。</li>
<li><code>sfs_dirent_search_nolock</code>：是常用的查找函数。他在目录下查找 name，并且返回相应的搜索结果（文件或文件夹）的 inode 的编号（<strong>也是磁盘编号</strong>），和相应的 entry 在该目录的 index 编号以及目录下的数据页是否有空闲的 entry。（SFS 实现里文件的数据页是连续的，不存在任何空洞；而对于目录，数据页不是连续的，当某个 entry 删除的时候，SFS 通过设置 entry-&gt;ino 为0将该 entry 所在的 block 标记为 free，在需要添加新 entry 的时候，SFS 优先使用这些 free 的 entry，其次才会去在数据页尾追加新的 entry.)</li>
</ol>
<blockquote>
<p> 从下到上表明了他们之间的包含关系. 注意到<code>dirent</code>是指<code>directory entry</code>, 最后两个函数专用于目录</p>
</blockquote>
<p><strong>注意，这些后缀为 nolock 的函数，只能在已经获得相应 inode 的semaphore才能调用。</strong> </p>
<hr>
<h4 id="Inode的文件-目录操作函数"><a href="#Inode的文件-目录操作函数" class="headerlink" title="Inode的文件,目录操作函数"></a>Inode的文件,目录操作函数</h4><p>这些操作函数使用结构体+函数指针来定义, 在inode结构体中被赋值.</p>
<ul>
<li>首先是文件操作函数: </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> <span class="hljs-title">sfs_node_fileops</span> =</span> &#123;<br>    .vop_magic                      = VOP_MAGIC,<br>	...<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>sfs_openfile不用做什么事；sfs_close需要把对文件的修改内容写回到硬盘上，这样确保硬盘上的文件内容数据是最新的；sfs_read和sfs_write函数都调用了一个函数sfs_io，并最终通过访问硬盘驱动来完成对文件内容数据的读写。</p>
<ul>
<li>然后是目录操作函数: </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> <span class="hljs-title">sfs_node_dirops</span> =</span> &#123;<br>    .vop_magic                      = VOP_MAGIC,<br>	...<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>对于目录操作而言，由于目录也是一种文件，所以sfs_opendir、sys_close对应户进程发出的open、close函数。相对于sfs_open，sfs_opendir只是完成一些open函数传递的参数判断，没做其他更多的事情。目录的close操作与文件的close操作完全一致。由于目录的内容数据与文件的内容数据不同，所以读出目录的内容数据的函数是sfs_getdirentry，其主要工作是获取目录下的文件inode信息。</p>
<h3 id="5-device层"><a href="#5-device层" class="headerlink" title="5.device层"></a>5.device层</h3><blockquote>
<p>目前实现了stdin设备文件文件、stdout设备文件、disk0设备。stdin设备就是键盘，stdout设备就是CONSOLE（串口、并口和文本显示器），而disk0设备是承载SFS文件系统的磁盘设备。(无情的复制机器)</p>
</blockquote>
<p>为了表示一个设备，需要有对应的数据结构，ucore为此定义了struct device，其描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> &#123;</span><br>    <span class="hljs-keyword">size_t</span> d_blocks;    <span class="hljs-comment">//设备占用的数据块个数            </span><br>    <span class="hljs-keyword">size_t</span> d_blocksize;  <span class="hljs-comment">//数据块的大小</span><br>    <span class="hljs-keyword">int</span> (*d_open)(struct device *dev, <span class="hljs-keyword">uint32_t</span> open_flags);  <span class="hljs-comment">//打开设备的函数指针</span><br>    <span class="hljs-keyword">int</span> (*d_close)(struct device *dev); <span class="hljs-comment">//关闭设备的函数指针</span><br>    <span class="hljs-keyword">int</span> (*d_io)(struct device *dev, struct iobuf *iob, <span class="hljs-keyword">bool</span> write); <span class="hljs-comment">//读写设备的函数指针</span><br>    <span class="hljs-keyword">int</span> (*d_ioctl)(struct device *dev, <span class="hljs-keyword">int</span> op, <span class="hljs-keyword">void</span> *data); <span class="hljs-comment">//用ioctl方式控制设备的函数指针</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>这个数据结构能够支持对块设备（比如磁盘）、字符设备（比如键盘、串口）的表示，完成对设备的基本操作。ucore虚拟文件系统为了把这些设备链接在一起，还定义了一个设备链表，即双向链表<strong>vdev_list</strong>，这样通过访问此链表，可以找到ucore能够访问的所有设备文件。</p>
<p>但这个设备描述没有与文件系统以及表示一个文件的inode数据结构建立关系，为此，还需要另外一个数据结构把device和inode联通起来，这就是vfs_dev_t数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// device info entry in vdev_list </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *devname;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">devnode</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs</span> *<span class="hljs-title">fs</span>;</span><br>    <span class="hljs-keyword">bool</span> mountable;<br>    <span class="hljs-keyword">list_entry_t</span> vdev_link;<br>&#125; <span class="hljs-keyword">vfs_dev_t</span>;<br></code></pre></div></td></tr></table></figure>

<p>利用<code>vfs_dev_t</code>数据结构，就可以让文件系统通过一个链接<code>vfs_dev_t</code>结构的双向链表找到device对应的inode数据结构，一个inode节点的成员变量in_type的值是0x1234，则此 inode的成员变量in_info将成为一个device结构。这样inode就和一个设备建立了联系，这个inode就是一个设备文件。</p>
<blockquote>
<p>对于文件来说, inode-&gt;in_info是sfs_inode类型, 记录了文件在磁盘上的信息;<br>而对于设备来说, 是device类型, 存储着针对于device的操作函数和相关信息.1</p>
</blockquote>
<h4 id="stdout"><a href="#stdout" class="headerlink" title="stdout"></a>stdout</h4><p><strong>初始化</strong> </p>
<p>既然stdout设备是设备文件系统的文件，自然有自己的inode结构。在系统初始化时，即只需如下处理过程</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">kern_init--&gt;fs_init--&gt;dev_init--&gt;dev_init_stdout --&gt; dev_create_inode<br>                 --&gt; stdout_device_init<br>                 --&gt; vfs_add_dev<br></code></pre></div></td></tr></table></figure>

<p>在dev_init_stdout中完成了对stdout设备文件的初始化。即首先创建了一个inode，然后通过stdout_device_init完成对inode中的成员变量inode-&gt;__device_info进行初始：</p>
<p>这里的stdout设备文件实际上就是指的console外设（它其实是串口、并口和CGA的组合型外设）。这个设备文件是一个只写设备，如果读这个设备，就会出错。接下来我们看看stdout设备的相关处理过程。</p>
<p><strong>初始化</strong> </p>
<p>stdout设备文件的初始化过程主要由stdout_device_init完成，其具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">stdout_device_init</span><span class="hljs-params">(struct device *dev)</span> </span>&#123;<br>    dev-&gt;d_blocks = <span class="hljs-number">0</span>;<br>    dev-&gt;d_blocksize = <span class="hljs-number">1</span>;<br>    dev-&gt;d_open = stdout_open;<br>    dev-&gt;d_close = stdout_close;<br>    dev-&gt;d_io = stdout_io;<br>    dev-&gt;d_ioctl = stdout_ioctl;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>可以看到，stdout_open函数完成设备文件打开工作，如果发现用户进程调用open函数的参数flags不是只写（O_WRONLY），则会报错。即<code>stdout_open(struct device *dev, uint32_t open_flags)  </code> </p>
<p><strong>访问操作实现</strong> </p>
<p>stdout_io函数完成设备的写操作工作, <strong>具体是从iobuf中一个一个字符输出到串口并口和CGA显示器上</strong>.</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">stdout_io</span><span class="hljs-params">(struct device *dev, struct iobuf *iob, <span class="hljs-keyword">bool</span> write)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (write) &#123;<br>        <span class="hljs-keyword">char</span> *data = iob-&gt;io_base;<br>        <span class="hljs-keyword">for</span> (; iob-&gt;io_resid != <span class="hljs-number">0</span>; iob-&gt;io_resid --) &#123;<br>            cputchar(*data ++);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>可以看到，要写的数据放在iob-&gt;io_base所指的内存区域，一直写到iob-&gt;io_resid的值为0为止。每次写操作都是通过cputchar来完成的，此函数最终将通过console外设驱动来完成把数据输出到串口、并口和CGA显示器上过程。另外，也可以注意到，如果用户想执行读操作，则stdout_io函数直接返回错误值**-**E_INVAL。</p>
<h4 id="stdin"><a href="#stdin" class="headerlink" title="stdin"></a>stdin</h4><p>这里的stdin设备文件实际上就是指的键盘。这个设备文件是一个只读设备，如果写这个设备，就会出错。接下来我们看看stdin设备的相关处理过程。</p>
<p><strong>初始化</strong> </p>
<p>stdin设备文件的初始化过程主要由stdin_device_init完成了主要的初始化工作，具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">stdin_device_init</span><span class="hljs-params">(struct device *dev)</span> </span>&#123;<br>    dev-&gt;d_blocks = <span class="hljs-number">0</span>;<br>    dev-&gt;d_blocksize = <span class="hljs-number">1</span>;<br>    dev-&gt;d_open = stdin_open;<br>    dev-&gt;d_close = stdin_close;<br>    dev-&gt;d_io = stdin_io;<br>    dev-&gt;d_ioctl = stdin_ioctl;<br>	<span class="hljs-comment">/* 这玩意儿是一个在dev_stdin.c中的全局静态变量, </span><br><span class="hljs-comment">     * 分别是pointer_read_position and p_write_position</span><br><span class="hljs-comment">     * 如果read_pos &lt; write_pos则说明有新字符</span><br><span class="hljs-comment">    p_rpos = p_wpos = 0; </span><br><span class="hljs-comment">    wait_queue_init(wait_queue);</span><br><span class="hljs-comment">&#125;</span><br></code></pre></div></td></tr></table></figure>

<p>相对于stdout的初始化过程，stdin的初始化相对复杂一些，多了一个stdin_buffer缓冲区，描述缓冲区读写位置的变量p_rpos、p_wpos以及用于等待缓冲区的等待队列wait_queue。在stdin_device_init函数的初始化中，也完成了对p_rpos、p_wpos和wait_queue的初始化。</p>
<p><strong>访问操作实现</strong> </p>
<p>stdin_io函数负责完成设备的读操作工作，具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">stdin_io</span><span class="hljs-params">(struct device *dev, struct iobuf *iob, <span class="hljs-keyword">bool</span> write)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!write) &#123;<br>        <span class="hljs-keyword">int</span> ret;<br>        <span class="hljs-keyword">if</span> ((ret = dev_stdin_read(iob-&gt;io_base, iob-&gt;io_resid)) &gt; <span class="hljs-number">0</span>) &#123;<br>            iob-&gt;io_resid -= ret;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>可以看到，如果是写操作，则stdin_io函数直接报错返回。所以这也进一步说明了此设备文件是只读文件。如果此读操作，则此函数进一步调用dev_stdin_read函数完成对键盘设备的读入操作。dev_stdin_read函数的实现相对复杂一些，主要的流程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">dev_stdin_read</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">size_t</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    local_intr_save(intr_flag);<br>    &#123;<br>        <span class="hljs-keyword">for</span> (; ret &lt; len; ret ++, p_rpos ++) &#123;<br>        try_again:<br>            <span class="hljs-keyword">if</span> (p_rpos &lt; p_wpos) &#123; <br>                *buf ++ = stdin_buffer[p_rpos % stdin_BUFSIZE];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//没有新字符就要进行睡眠并且调度</span><br>                <span class="hljs-keyword">wait_t</span> __wait, *wait = &amp;__wait;<br>                wait_current_set(wait_queue, wait, WT_KBD);<br>                local_intr_restore(intr_flag);<br><br>                schedule();<br><br>                local_intr_save(intr_flag);<br>                wait_current_del(wait_queue, wait);<br>                <span class="hljs-keyword">if</span> (wait-&gt;wakeup_flags == WT_KBD) &#123;<br>                    <span class="hljs-keyword">goto</span> try_again;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    local_intr_restore(intr_flag);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在上述函数中可以看出，如果<code>p_rpos</code> &lt; <code>p_wpos</code>，则表示有键盘输入的新字符在stdin_buffer中，于是就从stdin_buffer中取出新字符放到iobuf指向的缓冲区中；如果<code>p_rpos</code> &gt;=<code>p_wpos</code>，则表明没有新字符，这样调用read用户态库函数的用户进程就需要采用等待队列的睡眠操作进入睡眠状态，等待键盘输入字符的产生。</p>
<p>键盘输入字符后，如何唤醒等待键盘输入的用户进程呢？回顾lab1中的外设中断处理，可以了解到，当用户敲击键盘时，会产生键盘中断，在trap_dispatch函数中，当识别出中断是键盘中断（中断号为IRQ_OFFSET + IRQ_KBD）时，会调用dev_stdin_write函数，来把字符写入到stdin_buffer中，且会通过等待队列的唤醒操作唤醒正在等待键盘输入的用户进程。</p>
<h3 id="文件系统初始化"><a href="#文件系统初始化" class="headerlink" title=".文件系统初始化"></a>.文件系统初始化</h3><blockquote>
<p>指导书写的真好, 又想复制了(</p>
</blockquote>
<p>首先看看kern_init函数，可以发现与lab7相比增加了对fs_init函数的调用。fs_init函数就是文件系统初始化的总控函数，它进一步调用了虚拟文件系统初始化函数vfs_init，与文件相关的设备初始化函数dev_init和Simple FS文件系统的初始化函数sfs_init。这三个初始化函数联合在一起，协同完成了整个虚拟文件系统、SFS文件系统和文件系统对应的设备（键盘、串口、磁盘）的初始化工作。其函数调用关系图如下所示：</p>
<p><img src="../../image/ucore/image-20220107165956521.png" srcset="/img/loading.gif" lazyload alt="image-20220107165956521"></p>
<p>参考上图，并结合源码分析，可大致了解到文件系统的整个初始化流程。</p>
<ul>
<li>vfs_init主要建立了一个device list双向链表vdev_list，为后续具体设备（键盘、串口、磁盘）以文件的形式呈现建立查找访问通道。</li>
<li>dev_init函数通过进一步调用disk0/stdin/stdout_device_init完成对具体设备的初始化，把它们抽象成一个设备文件，并建立对应的inode数据结构，最后把它们链入到vdev_list中。这样通过虚拟文件系统就可以方便地以文件的形式访问这些设备了。</li>
<li>sfs_init是完成对Simple FS的初始化工作，并把此实例文件系统挂在虚拟文件系统中，从而让ucore的其他部分能够通过访问虚拟文件系统的接口来进一步访问到SFS实例文件系统。</li>
</ul>
<h2 id="练习-5"><a href="#练习-5" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1-5"><a href="#练习1-5" class="headerlink" title="练习1"></a>练习1</h3><h4 id="openfile"><a href="#openfile" class="headerlink" title="openfile"></a>openfile</h4><blockquote>
<p>发现没有讲到的路径格式: </p>
<ul>
<li><p>device:/path  </p>
  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/** 或者:</span><br><span class="hljs-comment">	* we have either /path or :path</span><br><span class="hljs-comment">	* /path is a path relative to the root of the &quot;boot filesystem&quot;</span><br><span class="hljs-comment">	* :path is a path relative to the root of the current filesystem</span><br><span class="hljs-comment">	* */</span><br></code></pre></div></td></tr></table></figure></li>
</ul>
</blockquote>
<p>首先贴一张函数调用图:</p>
<p><img src="../../image/ucore/Calls-file_open.png" srcset="/img/loading.gif" lazyload alt="Calls-file_open"></p>
<p>基本上都有多路分支, 具体可以看源码, 这里讲个大概.</p>
<ul>
<li><p>通过用户libc库中的syscall调用sys_open, 一直到中断处理转到file_open.</p>
</li>
<li><p>这个函数就执行一个简单检查以及调用了vfs_open(最重要的函数)</p>
</li>
<li><p>如果一切正常, 只会执行vfs_lookup. </p>
<ul>
<li><p>第一个get_device是解析路径的, 如果path没有指定设备名称说明只是一个相对路径, 就会执行vfs_getdir</p>
</li>
<li><p>然后会调用sfs_lookup(通过宏定义), 通过path找到对应的inode, 下面是他的调用图</p>
<p><img src="../../image/ucore/image-20220108132923299.png" srcset="/img/loading.gif" lazyload alt="image-20220108132923299"></p>
</li>
</ul>
</li>
</ul>
<h4 id="read-write-file"><a href="#read-write-file" class="headerlink" title="[read,write]file"></a>[read,write]file</h4><p>调用关系如下:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">sys_fileread-&gt;file_read-&gt;vop_read(sfs_read)-&gt;sfs_io<br></code></pre></div></td></tr></table></figure>

<ul>
<li>在<code>sysfile_read</code>里设置了一个4KB的buff, 主要调用了file_read函数将文件中的内容读取到buff中</li>
<li>file_read改变file结构体的文件计数以及移动文件指针, 继续调用sfs_read-&gt;sfs_io(sfs_inode.c)</li>
<li>sfs_io通过第三个参数来判断是读还是写, 接着调用sfs_io_nolock</li>
<li>接下来就是练习的内容, read different kind of blocks in file</li>
</ul>
<blockquote>
<p>struct fs 包装了sfs_fs和一些对sfs_fs的操作</p>
<p>这种规模的代码我只能去理解了, 暂时没法想象要怎么构建这样大的一个工程</p>
<p>代码分析了一遍, 而且肖佬写的那几个部分都看过了, 实在是不想写那么多, 想看直接看现成的吧…[<a target="_blank" rel="noopener" href="https://kiprey.github.io/2020/09/uCore-8/#9-uCore%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0">link</a>]</p>
</blockquote>
<p>基本看懂了, 写了一堆注释在源代码里面.(<code>sfs_inode.c:595</code>)</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*  </span><br><span class="hljs-comment"> * sfs_io_nolock - Rd/Wr a file content from offset position to offset+length disk blocks&lt;--&gt;buffer (in memroy)</span><br><span class="hljs-comment"> * @sfs:      sfs file system</span><br><span class="hljs-comment"> * @sin:      sfs inode in memory</span><br><span class="hljs-comment"> * @buf:      the buffer Rd/Wr</span><br><span class="hljs-comment"> * @offset:   the offset of file</span><br><span class="hljs-comment"> * @alenp:    the length need to read (is a pointer). and will RETURN the really Rd/Wr lenght</span><br><span class="hljs-comment"> * @write:    BOOL, 0 read, 1 write</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">sfs_io_nolock</span><span class="hljs-params">(struct sfs_fs *sfs, struct sfs_inode *<span class="hljs-built_in">sin</span>, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">off_t</span> offset, <span class="hljs-keyword">size_t</span> *alenp, <span class="hljs-keyword">bool</span> write)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_disk_inode</span> *<span class="hljs-title">din</span> =</span> <span class="hljs-built_in">sin</span>-&gt;din;<br>    assert(din-&gt;type != SFS_TYPE_DIR);<br>    <span class="hljs-keyword">off_t</span> endpos = offset + *alenp, blkoff;<span class="hljs-comment">///endpos感觉恒等于4KB??好像不是</span><br>    *alenp = <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">// calculate the Rd/Wr end position</span><br>    <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span> || offset &gt;= SFS_MAX_FILE_SIZE || offset &gt; endpos) &#123;<br>        <span class="hljs-keyword">return</span> -E_INVAL;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (offset == endpos) &#123;<span class="hljs-comment">///这是怎么发生的?</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (endpos &gt; SFS_MAX_FILE_SIZE) &#123;<br>        endpos = SFS_MAX_FILE_SIZE;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!write) &#123;<span class="hljs-comment">///如果是read</span><br>        <span class="hljs-keyword">if</span> (offset &gt;= din-&gt;size) &#123;<span class="hljs-comment">///读完文件了</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (endpos &gt; din-&gt;size) &#123;<span class="hljs-comment">///不用读那么长, 只要din-&gt;size即可</span><br>            endpos = din-&gt;size;<br>        &#125;<br>    &#125;<br>	<span class="hljs-comment">///下面这几行又是什么神奇操作, 这通用接口写的也太绝了</span><br>    <span class="hljs-keyword">int</span> (*sfs_buf_op)(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">off_t</span> offset);<br>    <span class="hljs-keyword">int</span> (*sfs_block_op)(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">uint32_t</span> nblks);<br>    <span class="hljs-keyword">if</span> (write) &#123;<br>        sfs_buf_op = sfs_wbuf, sfs_block_op = sfs_wblock;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">///如果是read, 要换成 把1个block读到buf 和 把多个block读到buf</span><br>        sfs_buf_op = sfs_rbuf, sfs_block_op = sfs_rblock;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">size_t</span> size, alen = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">uint32_t</span> ino; <span class="hljs-comment">//the pointer of inode</span><br>    <span class="hljs-keyword">uint32_t</span> blkno = offset / SFS_BLKSIZE;          <span class="hljs-comment">// The NO. of Rd/Wr begin block ///BUFFER不都是4KB的吗??</span><br>    <span class="hljs-keyword">uint32_t</span> nblks = endpos / SFS_BLKSIZE - blkno;  <span class="hljs-comment">// The size of Rd/Wr blocks</span><br><br>  <span class="hljs-comment">//LAB8:EXERCISE1 YOUR CODE HINT: call sfs_bmap_load_nolock, sfs_rbuf, sfs_rblock,etc. read different kind of blocks in file</span><br>    <span class="hljs-keyword">if</span> ((blkoff = offset % SFS_BLKSIZE) != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">///如果在offset起始block的中间</span><br>        size = (nblks != <span class="hljs-number">0</span>) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);<br>        <span class="hljs-keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="hljs-built_in">sin</span>, blkno, &amp;ino)) != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">///取出inode编号, 也即block编号</span><br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">///从block和其他信息读取到buf中</span><br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        alen += size;<span class="hljs-comment">///要增加alen</span><br>        <span class="hljs-keyword">if</span> (nblks == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">///如果只有一个block, 读/写就完成了</span><br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        buf += size, blkno++, nblks--;<span class="hljs-comment">///否则修改一下剩余的参数</span><br>    &#125;<br><br>    size = SFS_BLKSIZE;<span class="hljs-comment">///使用while循环, 逐block读取, 到了剩余的整个block(nblock)等于0的时候退出</span><br>    <span class="hljs-keyword">while</span> (nblks != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="hljs-built_in">sin</span>, blkno, &amp;ino)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((ret = sfs_block_op(sfs, buf, ino, <span class="hljs-number">1</span>)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        alen += size, buf += size, blkno++, nblks--;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ((size = endpos % SFS_BLKSIZE) != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">///读取最后一个block的部分区域, 这三部分基本相同只能说</span><br>        <span class="hljs-keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="hljs-built_in">sin</span>, blkno, &amp;ino)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        alen += size;<br>    &#125;<br>out:<br>    *alenp = alen;<span class="hljs-comment">///上面要完成alen的赋值, 即真实的读取字节数目</span><br>    <span class="hljs-keyword">if</span> (offset + alen &gt; <span class="hljs-built_in">sin</span>-&gt;din-&gt;size) &#123;<span class="hljs-comment">///好像是用于write的</span><br>        <span class="hljs-built_in">sin</span>-&gt;din-&gt;size = offset + alen;<br>        <span class="hljs-built_in">sin</span>-&gt;dirty = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p class="note note-primary" style="font-style:italic;background-color:rgb(240,230,250)">”UNIX的PIPE机制“的概要设计方案 </p>

<p>?</p>
<h3 id="练习2-5"><a href="#练习2-5" class="headerlink" title="练习2"></a>练习2</h3><p>fork机制在原先lab7的基础上，多了<code>file_struct</code>结构的复制操作与执行失败时的重置操作。这两部操作分别需要调用<code>copy_files</code>和<code>put_files</code>函数</p>
<p><code>load_icode</code>中比较重要的是<code>load_icode_read()</code>, 可以根据ELF文件的特点使用偏移来移动当前文件的指针pos, 并且把内容读取到参数buf指向的空间中.</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">load_icode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **kargv)</span> </span>&#123;<br>    <span class="hljs-comment">/* LAB8:EXERCISE2 YOUR CODE  HINT:how to load the file with handler fd  in to process&#x27;s memory? how to setup argc/argv?</span><br><span class="hljs-comment">     * MACROs or Functions:</span><br><span class="hljs-comment">     *  mm_create        - create a mm</span><br><span class="hljs-comment">     *  setup_pgdir      - setup pgdir in mm</span><br><span class="hljs-comment">     *  load_icode_read  - read raw data content of program file</span><br><span class="hljs-comment">     *  mm_map           - build new vma</span><br><span class="hljs-comment">     *  pgdir_alloc_page - allocate new memory for  TEXT/DATA/BSS/stack parts</span><br><span class="hljs-comment">     *  lcr3             - update Page Directory Addr Register -- CR3</span><br><span class="hljs-comment">     */</span><br>	<span class="hljs-comment">/* (1) create a new mm for current process</span><br><span class="hljs-comment">     * (2) create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT</span><br><span class="hljs-comment">     * (3) copy TEXT/DATA/BSS parts in binary to memory space of process</span><br><span class="hljs-comment">     *    (3.1) read raw data content in file and resolve elfhdr</span><br><span class="hljs-comment">     *    (3.2) read raw data content in file and resolve proghdr based on info in elfhdr</span><br><span class="hljs-comment">     *    (3.3) call mm_map to build vma related to TEXT/DATA</span><br><span class="hljs-comment">     *    (3.4) callpgdir_alloc_page to allocate page for TEXT/DATA, read contents in file</span><br><span class="hljs-comment">     *          and copy them into the new allocated pages</span><br><span class="hljs-comment">     *    (3.5) callpgdir_alloc_page to allocate pages for BSS, memset zero in these pages</span><br><span class="hljs-comment">     * (4) call mm_map to setup user stack, and put parameters into user stack</span><br><span class="hljs-comment">     * (5) setup current process&#x27;s mm, cr3, reset pgidr (using lcr3 MARCO)</span><br><span class="hljs-comment">     * (6) setup uargc and uargv in user stacks</span><br><span class="hljs-comment">     * (7) setup trapframe for user environment</span><br><span class="hljs-comment">     * (8) if up steps failed, you should cleanup the env.</span><br><span class="hljs-comment">     */</span><br>    assert(argc &gt;= <span class="hljs-number">0</span> &amp;&amp; argc &lt;= EXEC_MAX_ARG_NUM);<br><br>    <span class="hljs-keyword">if</span> (current-&gt;mm != <span class="hljs-literal">NULL</span>) &#123;<br>        panic(<span class="hljs-string">&quot;load_icode: current-&gt;mm must be empty.\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> ret = -E_NO_MEM;<br>    <span class="hljs-comment">// 创建proc的内存管理结构</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span>;</span><br>    <span class="hljs-keyword">if</span> ((mm = mm_create()) == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">goto</span> bad_mm;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (setup_pgdir(mm) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">goto</span> bad_pgdir_cleanup_mm;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page</span>;</span><br>    <span class="hljs-comment">// LAB8 这里要从文件中读取ELF header，而不是Lab7中的内存了</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elfhdr</span> __<span class="hljs-title">elf</span>, *<span class="hljs-title">elf</span> =</span> &amp;__elf;<br>    <span class="hljs-keyword">if</span> ((ret = load_icode_read(fd, elf, <span class="hljs-keyword">sizeof</span>(struct elfhdr), <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">goto</span> bad_elf_cleanup_pgdir;<br>    &#125;<br>    <span class="hljs-comment">// 判断读取入的elf header是否正确</span><br>    <span class="hljs-keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123;<br>        ret = -E_INVAL_ELF;<br>        <span class="hljs-keyword">goto</span> bad_elf_cleanup_pgdir;<br>    &#125;<br>    <span class="hljs-comment">// 根据每一段的大小和基地址来分配不同的内存空间</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> __<span class="hljs-title">ph</span>, *<span class="hljs-title">ph</span> =</span> &amp;__ph;<br>    <span class="hljs-keyword">uint32_t</span> vm_flags, perm, phnum;<br>    <span class="hljs-keyword">for</span> (phnum = <span class="hljs-number">0</span>; phnum &lt; elf-&gt;e_phnum; phnum ++) &#123;<br>        <span class="hljs-comment">// LAB8 从文件特定偏移处读取每个段的详细信息（包括大小、基地址等等）</span><br>        <span class="hljs-keyword">off_t</span> phoff = elf-&gt;e_phoff + <span class="hljs-keyword">sizeof</span>(struct proghdr) * phnum;<br>        <span class="hljs-keyword">if</span> ((ret = load_icode_read(fd, ph, <span class="hljs-keyword">sizeof</span>(struct proghdr), phoff)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_type != ELF_PT_LOAD) &#123;<br>            <span class="hljs-keyword">continue</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;<br>            ret = -E_INVAL_ELF;<br>            <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_filesz == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span> ;<br>        &#125;<br>        vm_flags = <span class="hljs-number">0</span>, perm = PTE_U;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_R) vm_flags |= VM_READ;<br>        <span class="hljs-keyword">if</span> (vm_flags &amp; VM_WRITE) perm |= PTE_W;<br>        <span class="hljs-comment">// 为当前段分配内存空间</span><br>        <span class="hljs-keyword">if</span> ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, <span class="hljs-literal">NULL</span>)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>        &#125;<br>        <span class="hljs-keyword">off_t</span> offset = ph-&gt;p_offset;<br>        <span class="hljs-keyword">size_t</span> off, size;<br>        <span class="hljs-keyword">uintptr_t</span> start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE);<br><br>        ret = -E_NO_MEM;<br><br>        end = ph-&gt;p_va + ph-&gt;p_filesz;<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-comment">// 设置该内存所对应的页表项</span><br>            <span class="hljs-keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="hljs-literal">NULL</span>) &#123;<br>                ret = -E_NO_MEM;<br>                <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>            &#125;<br>            off = start - la, size = PGSIZE - off, la += PGSIZE;<br>            <span class="hljs-keyword">if</span> (end &lt; la) &#123;<br>                size -= la - end;<br>            &#125;<br>            <span class="hljs-comment">// LAB8 读取elf对应段内的数据并写入至该内存中</span><br>            <span class="hljs-keyword">if</span> ((ret = load_icode_read(fd, page2kva(page) + off, size, offset)) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>            &#125;<br>            start += size, offset += size;<br>        &#125;<br>        end = ph-&gt;p_va + ph-&gt;p_memsz;<br>        <span class="hljs-comment">// 对于段中当前页中剩余的空间（复制elf数据后剩下的空间），将其置为0</span><br>        <span class="hljs-keyword">if</span> (start &lt; la) &#123;<br>            <span class="hljs-comment">/* ph-&gt;p_memsz == ph-&gt;p_filesz */</span><br>            <span class="hljs-keyword">if</span> (start == end) &#123;<br>                <span class="hljs-keyword">continue</span> ;<br>            &#125;<br>            off = start + PGSIZE - la, size = PGSIZE - off;<br>            <span class="hljs-keyword">if</span> (end &lt; la) &#123;<br>                size -= la - end;<br>            &#125;<br>            <span class="hljs-built_in">memset</span>(page2kva(page) + off, <span class="hljs-number">0</span>, size);<br>            start += size;<br>            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));<br>        &#125;<br>        <span class="hljs-comment">// 对于段中剩余页中的空间（复制elf数据后的多余页面），将其置为0</span><br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="hljs-literal">NULL</span>) &#123;<br>                ret = -E_NO_MEM;<br>                <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>            &#125;<br>            off = start - la, size = PGSIZE - off, la += PGSIZE;<br>            <span class="hljs-keyword">if</span> (end &lt; la) &#123;<br>                size -= la - end;<br>            &#125;<br>            <span class="hljs-built_in">memset</span>(page2kva(page) + off, <span class="hljs-number">0</span>, size);<br>            start += size;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 关闭读取的ELF</span><br>    sysfile_close(fd);<br><br>    <span class="hljs-comment">// 设置栈内存</span><br>    vm_flags = VM_READ | VM_WRITE | VM_STACK;<br>    <span class="hljs-keyword">if</span> ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, <span class="hljs-literal">NULL</span>)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>    &#125;<br>    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE , PTE_USER) != <span class="hljs-literal">NULL</span>);<br>    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="hljs-number">-2</span>*PGSIZE , PTE_USER) != <span class="hljs-literal">NULL</span>);<br>    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="hljs-number">-3</span>*PGSIZE , PTE_USER) != <span class="hljs-literal">NULL</span>);<br>    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="hljs-number">-4</span>*PGSIZE , PTE_USER) != <span class="hljs-literal">NULL</span>);<br><br>    mm_count_inc(mm);<br>    <span class="hljs-comment">// 设置CR3页表相关寄存器</span><br>    current-&gt;mm = mm;<br>    current-&gt;cr3 = PADDR(mm-&gt;pgdir);<br>    lcr3(PADDR(mm-&gt;pgdir));<br><br>    <span class="hljs-comment">//setup argc, argv</span><br>    <span class="hljs-comment">// LAB8 设置execve所启动的程序参数</span><br>    <span class="hljs-keyword">uint32_t</span> argv_size=<span class="hljs-number">0</span>, i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; argc; i ++) &#123;<br>        argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + <span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">uintptr_t</span> stacktop = USTACKTOP - (argv_size/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>)+<span class="hljs-number">1</span>)*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>);<br>    <span class="hljs-comment">// 直接将传入的参数压入至新栈的底部</span><br>    <span class="hljs-keyword">char</span>** uargv=(<span class="hljs-keyword">char</span> **)(stacktop  - argc * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span> *));<br><br>    argv_size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; argc; i ++) &#123;<br>        uargv[i] = <span class="hljs-built_in">strcpy</span>((<span class="hljs-keyword">char</span> *)(stacktop + argv_size ), kargv[i]);<br>        argv_size +=  strnlen(kargv[i],EXEC_MAX_ARG_LEN + <span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;<br>    &#125;<br><br>    stacktop = (<span class="hljs-keyword">uintptr_t</span>)uargv - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>);<br>    *(<span class="hljs-keyword">int</span> *)stacktop = argc;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">tf</span> =</span> current-&gt;tf;<br>    <span class="hljs-built_in">memset</span>(tf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct trapframe));<br>    tf-&gt;tf_cs = USER_CS;<br>    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;<br>    tf-&gt;tf_esp = stacktop;<br>    tf-&gt;tf_eip = elf-&gt;e_entry;<br>    tf-&gt;tf_eflags = FL_IF;<br>    ret = <span class="hljs-number">0</span>;<br>out:<br>    <span class="hljs-keyword">return</span> ret;<br>bad_cleanup_mmap:<br>    exit_mmap(mm);<br>bad_elf_cleanup_pgdir:<br>    put_pgdir(mm);<br>bad_pgdir_cleanup_mm:<br>    mm_destroy(mm);<br>bad_mm:<br>    <span class="hljs-keyword">goto</span> out;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>给出设计实现基于”<strong>UNIX的硬链接和软链接机制</strong>“的概要设计方案</p>
</blockquote>
<p>emmmm</p>
<ul>
<li>moocos的密码是空格<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>即原先查找页目录表的目的是想将某个线性地址转换为物理地址，但如果页目录表中存放的是二级页表的<strong>线性</strong>地址，则需要先查找该二级页表的物理地址，此时需要递归查找，这可能会出现永远也查找不到物理地址的情况。
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/CS/">CS</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/OS/">OS</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021-10/Learning-complier/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">编译原理complier</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021-09/Learning-Specialty-in-Rust/">
                        <span class="hidden-mobile">Specialty in Rust</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"312db7ebbc085de5d28d","clientSecret":"85ea3cefd13c73a6d85c1813adfde4f1550bfbda","repo":"yogdzewa.github.io","owner":"yogdzewa","admin":["yogdzewa"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '9fc4bed47dda41453c8f2419b730568d'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" lazyload class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
